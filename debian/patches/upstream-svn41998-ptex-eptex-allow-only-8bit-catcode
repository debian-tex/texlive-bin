diff --git a/texk/web2c/eptexdir/ChangeLog b/Build/source/texk/web2c/eptexdir/ChangeLog
index d7807ae..bff411c 100644
--- a/texk/web2c/eptexdir/ChangeLog
+++ b/texk/web2c/eptexdir/ChangeLog
@@ -1,3 +1,7 @@
+2016-09-06  Hironori Kitagawa  <h_kitagawa2001@yahoo.co.jp>
+
+	* fam256.ch: Allow only 8bit arguments for \catcode etc.
+
 2016-07-29  Hironori Kitagawa  <h_kitagawa2001@yahoo.co.jp>
 
 	* pdfutils.ch: Improve \pdfsavepos as pointed out by N. Abe.
diff --git a/texk/web2c/eptexdir/fam256.ch b/Build/source/texk/web2c/eptexdir/fam256.ch
index f0e3c34..257cfdb 100644
--- a/texk/web2c/eptexdir/fam256.ch
+++ b/texk/web2c/eptexdir/fam256.ch
@@ -270,13 +270,15 @@ char_given,math_given: scanned_result(cur_chr)(int_val);
 %-----------------------------------------------
 @x
 @ @<Fetch a character code from some table@>=
-begin scan_char_num;
-if m=math_code_base then scanned_result(ho(math_code(cur_val)))(int_val)
+begin
+if m=math_code_base then
+  begin scan_ascii_num;
+  scanned_result(ho(math_code(cur_val)))(int_val); end
 @y
 @ @<Fetch a character code from some table@>=
-begin scan_char_num;
+begin
 if m=math_code_base then begin
-  cur_val1:=ho(math_code(cur_val));
+  scan_ascii_num; cur_val1:=ho(math_code(cur_val));
   if ((cur_val1 div @"10000)>8) or
      (((cur_val1 mod @"10000) div @"100)>15) then
     begin print_err("Extended mathchar used as mathchar");
@@ -289,14 +291,14 @@ if m=math_code_base then begin
   scanned_result(cur_val1)(int_val);
   end
 else if m=(math_code_base+128) then begin
-  cur_val1:=ho(math_code(cur_val));
+  scan_ascii_num; cur_val1:=ho(math_code(cur_val));
   cur_val:=(cur_val1 div @"10000) * @"1000000 
            +((cur_val1 div @"100) mod @"100) * @"10000
            +(cur_val1 mod @"100);
   scanned_result(cur_val)(int_val);
   end
 else if m=del_code_base then begin
-  cur_val1:=del_code(cur_val); cur_val:=del_code1(cur_val);
+  scan_ascii_num; cur_val1:=del_code(cur_val); cur_val:=del_code1(cur_val);
   if ((cur_val1 div @"100) mod @"100 >= 16) or (cur_val>=@"1000) then
   begin print_err("Extended delimiter code used as delcode");
 @.Bad delimiter code@>
@@ -308,7 +310,7 @@ else if m=del_code_base then begin
   end
 else if m=(del_code_base+128) then begin
   { Aleph seems \.{\\odelcode} always returns $-1$.}
-  scanned_result(-1)(int_val);
+  scan_ascii_num; scanned_result(-1)(int_val);
   end
 @z
 %-----------------------------------------------
@@ -1176,11 +1178,10 @@ primitive("odelcode",def_code,del_code_base+128);
 def_code: begin
   @<Let |m| be the minimal legal code value, based on |cur_chr|@>;
   @<Let |n| be the largest legal code value, based on |cur_chr|@>;
-  p:=cur_chr; scan_char_num;
-  if p=kcat_code_base then p:=p+kcatcodekey(cur_val) 
-  else if not is_char_ascii(cur_val) then p:=p+Hi(cur_val) 
-    { If |cur_val| is a KANJI code, we use its upper half, as the case of retrieving. }
-  else p:=p+cur_val;
+  p:=cur_chr;
+  if p=kcat_code_base then
+    begin scan_char_num; p:=p+kcatcodekey(cur_val) end
+  else begin scan_ascii_num; p:=p+cur_val; end;
   scan_optional_equals; scan_int;
   if ((cur_val<m)and(p<del_code_base))or(cur_val>n) then
   begin print_err("Invalid code ("); print_int(cur_val);
@@ -1207,28 +1208,26 @@ def_code: begin
 @y
 @<Assignments@>=
 def_code: begin
- if cur_chr=(del_code_base+128) then begin
-   p:=cur_chr-128; scan_char_num; p:=p+cur_val; scan_optional_equals;
-   scan_int; cur_val1:=cur_val; scan_int; {backwards}
-   if (cur_val1>@"FFFFFF) or (cur_val>@"FFFFFF) then
-     begin print_err("Invalid code ("); print_int(cur_val1); print(" ");
-     print_int(cur_val);
-     print("), should be at most ""FFFFFF ""FFFFFF");
-     help1("I'm going to use 0 instead of that illegal code value.");@/
-     error; cur_val1:=0; cur_val:=0;
-     end;
-   cur_val1:=(cur_val1 div @"10000)*@"100+(cur_val1 mod @"100);
-   cur_val:=(cur_val div @"10000)*@"100+(cur_val mod @"100);
-   del_word_define(p,cur_val1,cur_val);
-   end
+  if cur_chr=(del_code_base+128) then begin
+    p:=cur_chr-128; scan_ascii_num; p:=p+cur_val; scan_optional_equals;
+    scan_int; cur_val1:=cur_val; scan_int; {backwards}
+    if (cur_val1>@"FFFFFF) or (cur_val>@"FFFFFF) then
+      begin print_err("Invalid code ("); print_int(cur_val1); print(" ");
+      print_int(cur_val);
+      print("), should be at most ""FFFFFF ""FFFFFF");
+      help1("I'm going to use 0 instead of that illegal code value.");@/
+      error; cur_val1:=0; cur_val:=0;
+      end;
+    cur_val1:=(cur_val1 div @"10000)*@"100+(cur_val1 mod @"100);
+    cur_val:=(cur_val div @"10000)*@"100+(cur_val mod @"100);
+    del_word_define(p,cur_val1,cur_val);
+    end
   else begin
     @<Let |m| be the minimal legal code value, based on |cur_chr|@>;
     @<Let |n| be the largest legal code value, based on |cur_chr|@>;
-    p:=cur_chr; cur_val1:=p; scan_char_num;
-    if p=kcat_code_base then p:=p+kcatcodekey(cur_val) 
-    else if not is_char_ascii(cur_val) then p:=p+Hi(cur_val) 
-      { If |cur_val| is a KANJI code, we use its upper half, as the case of retrieving. }
-    else p:=p+cur_val;
+    p:=cur_chr; cur_val1:=p;
+    if p=kcat_code_base then begin scan_char_num; p:=p+kcatcodekey(cur_val) end
+    else begin scan_ascii_num; p:=p+cur_val; end;
     scan_optional_equals; scan_int;
     if ((cur_val<m)and(p<del_code_base))or(cur_val>n) then
     begin print_err("Invalid code ("); print_int(cur_val);
diff --git a/texk/web2c/ptexdir/ChangeLog b/Build/source/texk/web2c/ptexdir/ChangeLog
index 32ea821..f0e1e4e 100644
--- a/texk/web2c/ptexdir/ChangeLog
+++ b/texk/web2c/ptexdir/ChangeLog
@@ -1,3 +1,7 @@
+2016-09-06  Hironori Kitagawa  <h_kitagawa2001@yahoo.co.jp>
+
+	* ptex-base.ch: Allow only 8bit arguments for \catcode etc.
+
 2016-06-06  Hironori Kitagawa  <h_kitagawa2001@yahoo.co.jp>
 
 	* ptex-base.ch: Fix a bug in check_box().
diff --git a/texk/web2c/ptexdir/ptex-base.ch b/Build/source/texk/web2c/ptexdir/ptex-base.ch
index f8ebc5d..a40aa7a 100644
--- a/texk/web2c/ptexdir/ptex-base.ch
+++ b/texk/web2c/ptexdir/ptex-base.ch
@@ -2008,22 +2008,24 @@ toks_register,assign_toks,def_family,set_font,def_font,def_jfont,def_tfont:
 @z
 
 @x [26.414] l.8373 - pTeX:
+begin scan_char_num;
 if m=math_code_base then scanned_result(ho(math_code(cur_val)))(int_val)
 else if m<math_code_base then scanned_result(equiv(m+cur_val))(int_val)
 else scanned_result(eqtb[m+cur_val].int)(int_val);
 @y
-if m=math_code_base then scanned_result(ho(math_code(cur_val)))(int_val)
-else if m=kcat_code_base then scanned_result(equiv(m+kcatcodekey(cur_val)))(int_val)
+begin
+if m=math_code_base then
+  begin scan_ascii_num;
+  scanned_result(ho(math_code(cur_val)))(int_val); end
+else if m=kcat_code_base then
+  begin scan_char_num;
+  scanned_result(equiv(m+kcatcodekey(cur_val)))(int_val); end
 else if m<math_code_base then { \.{\\lccode}, \.{\\uccode}, \.{\\sfcode}, \.{\\catcode} }
-  begin if not is_char_ascii(cur_val) then
-  scanned_result(equiv(m+Hi(cur_val)))(int_val)
-  else scanned_result(equiv(m+cur_val))(int_val)
-  end
+  begin scan_ascii_num;
+  scanned_result(equiv(m+cur_val))(int_val) end
 else { \.{\\delcode} }
-  begin if not is_char_ascii(cur_val) then
-  scanned_result(eqtb[m+Hi(cur_val)].int)(int_val)
-  else scanned_result(eqtb[m+cur_val].int)(int_val)
-  end;
+  begin scan_ascii_num;
+  scanned_result(eqtb[m+cur_val].int)(int_val) end;
 @z
 
 @x [26.420] l.8474 - pTeX: Fetch a box dimension: dir_node
@@ -2120,6 +2122,15 @@ if (cur_val<0)or(cur_val>255) then
   end;
 end;
 @y
+procedure scan_ascii_num;
+begin scan_int;
+if (cur_val<0)or(cur_val>255) then
+  begin print_err("Bad character code");
+@.Bad character code@>
+  help2("A character number must be between 0 and 255.")@/
+    ("I changed this one to zero."); int_error(cur_val); cur_val:=0;
+  end;
+end;
 procedure scan_char_num;
 begin scan_int;
 if not is_char_ascii(cur_val) and not is_char_kanji(cur_val) then
@@ -5819,11 +5830,10 @@ def_code: begin @<Let |n| be the largest legal code value, based on |cur_chr|@>;
 def_code: begin
   @<Let |m| be the minimal legal code value, based on |cur_chr|@>;
   @<Let |n| be the largest legal code value, based on |cur_chr|@>;
-  p:=cur_chr; scan_char_num;
-  if p=kcat_code_base then p:=p+kcatcodekey(cur_val) 
-  else if not is_char_ascii(cur_val) then p:=p+Hi(cur_val) 
-    { If |cur_val| is a KANJI code, we use its upper half, as the case of retrieving. }
-  else p:=p+cur_val;
+  p:=cur_chr;
+  if p=kcat_code_base then
+    begin scan_char_num; p:=p+kcatcodekey(cur_val) end
+  else begin scan_ascii_num; p:=p+cur_val; end;
   scan_optional_equals; scan_int;
   if ((cur_val<m)and(p<del_code_base))or(cur_val>n) then
   begin print_err("Invalid code ("); print_int(cur_val);
