From a5f499f4bf951ea37b2db47198fa21c11a5f8645 Mon Sep 17 00:00:00 2001
From: Akira Kakuto <kakuto@fuk.kindai.ac.jp>
Date: Thu, 6 Sep 2018 00:10:18 +0000
Subject: [PATCH] Fix broken ToUnicode CMap support (S. Hirata)

git-svn-id: svn://tug.org/texlive/trunk@48595 c570f23f-e606-0410-a88d-b1316a301751
---
 texk/dvipdfm-x/ChangeLog     |    9 
 texk/dvipdfm-x/configure     |   22 +-
 texk/dvipdfm-x/configure.ac  |    2 
 texk/dvipdfm-x/epdf.c        |   18 -
 texk/dvipdfm-x/pdfdoc.c      |  410 +++++++++++++++++++++++--------------------
 texk/dvipdfm-x/pdfencoding.c |   39 ++--
 texk/dvipdfm-x/pdffont.c     |   13 -
 texk/dvipdfm-x/pdfobj.c      |   59 +++++-
 8 files changed, 333 insertions(+), 239 deletions(-)

--- texlive-bin.orig/texk/dvipdfm-x/ChangeLog
+++ texlive-bin/texk/dvipdfm-x/ChangeLog
@@ -1,3 +1,12 @@
+2018-09-06  Shunsaku Hirata  <shunsaku.hirata74@gmail.com>
+
+	* pdfencoding.c: Reverted change made for 20071115.
+	ToUnicode creation for simple font was broken. Not working
+	as intended at all.
+	* pdfdoc.c, epdf.c, pdffont.c: Rearranged code.
+	* pdfobj.c: Added some debugging code.
+	* configure.ac: Version 20180906.
+
 2018-09-04  Shunsaku Hirata  <shunsaku.hirata74@gmail.com>
 
 	* pdfobj.c: More fix on circular reference issue.
--- texlive-bin.orig/texk/dvipdfm-x/configure
+++ texlive-bin/texk/dvipdfm-x/configure
@@ -1,6 +1,6 @@
 #! /bin/sh
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.69 for dvipdfm-x (TeX Live) 20180904.
+# Generated by GNU Autoconf 2.69 for dvipdfm-x (TeX Live) 20180906.
 #
 # Report bugs to <tex-k@tug.org>.
 #
@@ -590,8 +590,8 @@ MAKEFLAGS=
 # Identity of this package.
 PACKAGE_NAME='dvipdfm-x (TeX Live)'
 PACKAGE_TARNAME='dvipdfm-x--tex-live-'
-PACKAGE_VERSION='20180904'
-PACKAGE_STRING='dvipdfm-x (TeX Live) 20180904'
+PACKAGE_VERSION='20180906'
+PACKAGE_STRING='dvipdfm-x (TeX Live) 20180906'
 PACKAGE_BUGREPORT='tex-k@tug.org'
 PACKAGE_URL=''
 
@@ -1350,7 +1350,7 @@ if test "$ac_init_help" = "long"; then
   # Omit some internal or obsolete options to make the list less imposing.
   # This message is too long to be a string in the A/UX 3.1 sh.
   cat <<_ACEOF
-\`configure' configures dvipdfm-x (TeX Live) 20180904 to adapt to many kinds of systems.
+\`configure' configures dvipdfm-x (TeX Live) 20180906 to adapt to many kinds of systems.
 
 Usage: $0 [OPTION]... [VAR=VALUE]...
 
@@ -1421,7 +1421,7 @@ fi
 
 if test -n "$ac_init_help"; then
   case $ac_init_help in
-     short | recursive ) echo "Configuration of dvipdfm-x (TeX Live) 20180904:";;
+     short | recursive ) echo "Configuration of dvipdfm-x (TeX Live) 20180906:";;
    esac
   cat <<\_ACEOF
 
@@ -1551,7 +1551,7 @@ fi
 test -n "$ac_init_help" && exit $ac_status
 if $ac_init_version; then
   cat <<\_ACEOF
-dvipdfm-x (TeX Live) configure 20180904
+dvipdfm-x (TeX Live) configure 20180906
 generated by GNU Autoconf 2.69
 
 Copyright (C) 2012 Free Software Foundation, Inc.
@@ -2390,7 +2390,7 @@ cat >config.log <<_ACEOF
 This file contains any messages produced by compilers while
 running configure, to aid debugging if configure makes a mistake.
 
-It was created by dvipdfm-x (TeX Live) $as_me 20180904, which was
+It was created by dvipdfm-x (TeX Live) $as_me 20180906, which was
 generated by GNU Autoconf 2.69.  Invocation command line was
 
   $ $0 $@
@@ -8075,7 +8075,7 @@ fi
 
 # Define the identity of the package.
  PACKAGE='dvipdfm-x--tex-live-'
- VERSION='20180904'
+ VERSION='20180906'
 
 
 cat >>confdefs.h <<_ACEOF
@@ -14744,7 +14744,7 @@ Usage: $0 [OPTIONS]
 Report bugs to <bug-libtool@gnu.org>."
 
 lt_cl_version="\
-dvipdfm-x (TeX Live) config.lt 20180904
+dvipdfm-x (TeX Live) config.lt 20180906
 configured by $0, generated by GNU Autoconf 2.69.
 
 Copyright (C) 2011 Free Software Foundation, Inc.
@@ -16624,7 +16624,7 @@ cat >>$CONFIG_STATUS <<\_ACEOF || ac_wri
 # report actual input values of CONFIG_FILES etc. instead of their
 # values after options handling.
 ac_log="
-This file was extended by dvipdfm-x (TeX Live) $as_me 20180904, which was
+This file was extended by dvipdfm-x (TeX Live) $as_me 20180906, which was
 generated by GNU Autoconf 2.69.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
@@ -16694,7 +16694,7 @@ _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 ac_cs_config="`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`"
 ac_cs_version="\\
-dvipdfm-x (TeX Live) config.status 20180904
+dvipdfm-x (TeX Live) config.status 20180906
 configured by $0, generated by GNU Autoconf 2.69,
   with options \\"\$ac_cs_config\\"
 
--- texlive-bin.orig/texk/dvipdfm-x/configure.ac
+++ texlive-bin/texk/dvipdfm-x/configure.ac
@@ -7,7 +7,7 @@ dnl   This file is free software; the co
 dnl   gives unlimited permission to copy and/or distribute it,
 dnl   with or without modifications, as long as this notice is preserved.
 dnl
-AC_INIT([dvipdfm-x (TeX Live)], [20180904], [tex-k@tug.org])
+AC_INIT([dvipdfm-x (TeX Live)], [20180906], [tex-k@tug.org])
 AC_PREREQ([2.65])
 AC_CONFIG_SRCDIR([agl.c])
 AC_CONFIG_AUX_DIR([../../build-aux])
--- texlive-bin.orig/texk/dvipdfm-x/epdf.c
+++ texlive-bin/texk/dvipdfm-x/epdf.c
@@ -149,7 +149,7 @@ pdf_get_page_obj (pdf_file *pf, int page
       WARN("Can't read document catalog.");
       pdf_release_obj(trailer);
       if (catalog)
-	pdf_release_obj(catalog);
+        pdf_release_obj(catalog);
       return NULL;
     }
     pdf_release_obj(trailer);
@@ -457,14 +457,14 @@ pdf_include_page (pdf_ximage        *xim
       int idx, len = pdf_array_length(contents);
       content_new = pdf_new_stream(STREAM_COMPRESS);
       for (idx = 0; idx < len; idx++) {
-	pdf_obj *content_seg = pdf_deref_obj(pdf_get_array(contents, idx));
-	if (!PDF_OBJ_STREAMTYPE(content_seg) ||
-	    pdf_concat_stream(content_new, content_seg) < 0) {
-	  pdf_release_obj(content_seg);
-	  pdf_release_obj(content_new);
-	  goto error;
-	}
-	pdf_release_obj(content_seg);
+        pdf_obj *content_seg = pdf_deref_obj(pdf_get_array(contents, idx));
+        if (!PDF_OBJ_STREAMTYPE(content_seg) ||
+            pdf_concat_stream(content_new, content_seg) < 0) {
+          pdf_release_obj(content_seg);
+          pdf_release_obj(content_new);
+          goto error;
+        }
+        pdf_release_obj(content_seg);
       }
     } else {
       goto error;
--- texlive-bin.orig/texk/dvipdfm-x/pdfdoc.c
+++ texlive-bin/texk/dvipdfm-x/pdfdoc.c
@@ -1,6 +1,6 @@
 /* This is dvipdfmx, an eXtended version of dvipdfm by Mark A. Wicks.
 
-    Copyright (C) 2008-2017 by Jin-Hwan Cho, Matthias Franz, and Shunsaku Hirata,
+    Copyright (C) 2008-2018 by Jin-Hwan Cho, Matthias Franz, and Shunsaku Hirata,
     the dvipdfmx project team.
     
     Copyright (C) 1998, 1999 by Mark A. Wicks <mwicks@kettering.edu>
@@ -921,6 +921,183 @@ pdf_doc_get_page_count (pdf_file *pf)
   return count;
 }
 
+static int
+set_bounding_box (pdf_rect *bbox, int option,
+                  pdf_obj *media_box, pdf_obj *crop_box,
+                  pdf_obj *art_box, pdf_obj *trim_box, pdf_obj *bleed_box)
+{
+  pdf_obj *box = NULL;
+
+  if (!media_box) {
+    WARN("MediaBox not found in included PDF...");
+    return -1;
+  }
+#define VALIDATE_BOX(o) if ((o)) {\
+  if (!PDF_OBJ_ARRAYTYPE((o)) || pdf_array_length((o)) != 4) \
+    return -1;\
+}
+  VALIDATE_BOX(media_box);
+  VALIDATE_BOX(crop_box);
+  VALIDATE_BOX(art_box);
+  VALIDATE_BOX(trim_box);
+  VALIDATE_BOX(bleed_box);
+
+  if (option == 0) {
+    if (crop_box)
+      box = pdf_link_obj(crop_box);
+    else if (art_box)
+      box = pdf_link_obj(art_box);
+    else if (trim_box)
+      box = pdf_link_obj(trim_box);
+    else if (bleed_box)
+      box = pdf_link_obj(bleed_box);
+    else {
+      box = pdf_link_obj(media_box);
+    }
+  } else {
+    if (!crop_box) {
+      crop_box = pdf_link_obj(media_box);
+    }
+    if (!art_box) {
+      art_box = pdf_link_obj(crop_box);
+    }
+    if (!trim_box) {
+      trim_box = pdf_link_obj(crop_box);
+    }
+    if (!bleed_box) {
+      bleed_box = pdf_link_obj(crop_box);
+    }
+    /* At this point all boxes must be defined. */
+    switch (option) {
+    case 1: /* crop box */
+      box = pdf_link_obj(crop_box);
+      break;
+    case 2: /* mdeia box */
+      box = pdf_link_obj(media_box);
+      break;
+    case 3: /* art box */
+      box = pdf_link_obj(art_box);
+      break;
+    case 4: /* trim box */
+      box = pdf_link_obj(trim_box);
+      break;
+    case 5: /* bleen box */
+      box = pdf_link_obj(bleed_box);
+      break;
+    default:
+      box = pdf_link_obj(crop_box);
+      break;
+    }
+  }
+
+  if (!box) {
+    /* Impossible */
+    WARN("No appropriate page boudary box found???");
+    return -1;
+  } else {
+    int i;
+
+    for (i = 4; i--; ) {
+      double x;
+      pdf_obj *tmp = pdf_deref_obj(pdf_get_array(box, i));
+      if (!PDF_OBJ_NUMBERTYPE(tmp)) {
+        pdf_release_obj(tmp);
+        pdf_release_obj(box);
+        return -1;
+      }
+      x = pdf_number_value(tmp);
+      switch (i) {
+      case 0: bbox->llx = x; break;
+      case 1: bbox->lly = x; break;
+      case 2: bbox->urx = x; break;
+      case 3: bbox->ury = x; break;
+      }
+      pdf_release_obj(tmp);
+    }
+
+    /* New scheme only for XDV files */
+    if (is_xdv || option) {
+      for (i = 4; i--; ) {
+        double x;
+        pdf_obj *tmp = pdf_deref_obj(pdf_get_array(media_box, i));
+        if (!PDF_OBJ_NUMBERTYPE(tmp)) {
+          pdf_release_obj(tmp);
+          pdf_release_obj(box);
+          return -1;
+        }
+        x = pdf_number_value(tmp);
+        switch (i) {
+        case 0: if (bbox->llx < x) bbox->llx = x; break;
+        case 1: if (bbox->lly < x) bbox->lly = x; break;
+        case 2: if (bbox->urx > x) bbox->urx = x; break;
+        case 3: if (bbox->ury > x) bbox->ury = x; break;
+        }
+        pdf_release_obj(tmp);
+      }
+    }
+  }
+  pdf_release_obj(box);
+
+  return 0;
+}
+
+static int
+set_transform_matrix (pdf_tmatrix *matrix, pdf_rect *bbox, pdf_obj *rotate)
+{
+  double deg;
+  int    rot;
+
+  matrix->a = matrix->d = 1.0;
+  matrix->b = matrix->c = 0.0;
+  matrix->e = matrix->f = 0.0;
+  /* Handle Rotate */
+  if (rotate) {
+    if (!PDF_OBJ_NUMBERTYPE(rotate)) {
+      return -1;
+    } else {
+      deg = pdf_number_value(rotate);
+      if (deg - (int)deg != 0.0) {
+        WARN("Invalid value specified for /Rotate: %f", deg);
+        return -1;
+      } else if (deg != 0.0) {
+        rot = (int) deg;
+        if (rot % 90 != 0.0) {
+          WARN("Invalid value specified for /Rotate: %f", deg);
+        } else {
+          rot = rot % 360;
+          if (rot < 0) rot += 360;
+          switch (rot) {
+          case 90:
+            matrix->a = matrix->d = 0;
+            matrix->b = -1;
+            matrix->c = 1;
+            matrix->e = bbox->llx - bbox->lly;
+            matrix->f = bbox->lly + bbox->urx;
+            break;
+          case 180:
+            matrix->a = matrix->d = -1;
+            matrix->b = matrix->c = 0;
+            matrix->e = bbox->llx + bbox->urx;
+            matrix->f = bbox->lly + bbox->ury;
+            break;
+          case 270:
+            matrix->a = matrix->d = 0;
+            matrix->b = 1;
+            matrix->c = -1;
+            matrix->e = bbox->llx + bbox->ury;
+            matrix->f = bbox->lly - bbox->llx;
+           break;
+           default:
+            WARN("Invalid value specified for /Rotate: %f", deg);
+            break;
+          }
+        }
+      }
+    }
+  }
+  return 0;
+}
+
 /*
  * From PDFReference15_v6.pdf (p.119 and p.834)
  *
@@ -982,16 +1159,18 @@ pdf_doc_get_page (pdf_file *pf,
                   pdf_rect *bbox, pdf_tmatrix *matrix,  /* returned value */
                   pdf_obj **resources_p /* returned values */
                   ) {
-  pdf_obj *page_tree = NULL;
-  pdf_obj *resources = NULL, *box = NULL, *rotate = NULL, *medbox = NULL;
-  pdf_obj *catalog;
+  pdf_obj *catalog = NULL, *page_tree = NULL;
+  pdf_obj *resources = NULL, *rotate = NULL;
+  pdf_obj *art_box = NULL, *trim_box = NULL, *bleed_box = NULL;
+  pdf_obj *media_box = NULL, *crop_box = NULL;
+  int      error = 0;
 
   catalog = pdf_file_get_catalog(pf);
 
   page_tree = pdf_deref_obj(pdf_lookup_dict(catalog, "Pages"));
 
   if (!PDF_OBJ_DICTTYPE(page_tree))
-    goto error;
+    goto error_exit;
 
   {
     int count;
@@ -999,7 +1178,7 @@ pdf_doc_get_page (pdf_file *pf,
     if (!PDF_OBJ_NUMBERTYPE(tmp)) {
       if (tmp)
         pdf_release_obj(tmp);
-      goto error;
+      goto error_exit;
     }
     count = pdf_number_value(tmp);
     pdf_release_obj(tmp);
@@ -1014,10 +1193,9 @@ pdf_doc_get_page (pdf_file *pf,
    * (Note that these entries can be inherited.)
    */
   {
-    pdf_obj *art_box = NULL, *trim_box = NULL, *bleed_box = NULL;
-    pdf_obj *media_box = NULL, *crop_box = NULL, *kids, *tmp;
-    int depth = PDF_OBJ_MAX_DEPTH;
-    int page_idx = page_no-1, kids_length = 1, i = 0;
+    pdf_obj *kids, *tmp;
+    int      depth = PDF_OBJ_MAX_DEPTH;
+    int      page_idx = page_no - 1, kids_length = 1, i = 0;
 
     while (--depth && i != kids_length) {
       if ((tmp = pdf_deref_obj(pdf_lookup_dict(page_tree, "MediaBox")))) {
@@ -1025,37 +1203,31 @@ pdf_doc_get_page (pdf_file *pf,
           pdf_release_obj(media_box);
         media_box = tmp;
       }
-
       if ((tmp = pdf_deref_obj(pdf_lookup_dict(page_tree, "CropBox")))) {
         if (crop_box)
           pdf_release_obj(crop_box);
         crop_box = tmp;
       }
-
       if ((tmp = pdf_deref_obj(pdf_lookup_dict(page_tree, "ArtBox")))) {
         if (art_box)
           pdf_release_obj(art_box);
         art_box = tmp;
       }
-
       if ((tmp = pdf_deref_obj(pdf_lookup_dict(page_tree, "TrimBox")))) {
         if (trim_box)
           pdf_release_obj(trim_box);
         trim_box = tmp;
       }
-
       if ((tmp = pdf_deref_obj(pdf_lookup_dict(page_tree, "BleedBox")))) {
         if (bleed_box)
           pdf_release_obj(bleed_box);
         bleed_box = tmp;
       }
-
       if ((tmp = pdf_deref_obj(pdf_lookup_dict(page_tree, "Rotate")))) {
         if (rotate)
           pdf_release_obj(rotate);
         rotate = tmp;
       }
-
       if ((tmp = pdf_deref_obj(pdf_lookup_dict(page_tree, "Resources")))) {
         if (resources)
           pdf_release_obj(resources);
@@ -1067,7 +1239,7 @@ pdf_doc_get_page (pdf_file *pf,
         break;
       else if (!PDF_OBJ_ARRAYTYPE(kids)) {
         pdf_release_obj(kids);
-        goto error;
+        goto error_exit;
       }
       kids_length = pdf_array_length(kids);
 
@@ -1077,7 +1249,7 @@ pdf_doc_get_page (pdf_file *pf,
         pdf_release_obj(page_tree);
         page_tree = pdf_deref_obj(pdf_get_array(kids, i));
         if (!PDF_OBJ_DICTTYPE(page_tree))
-          goto error;
+          goto error_exit;
 
         tmp = pdf_deref_obj(pdf_lookup_dict(page_tree, "Count"));
         if (PDF_OBJ_NUMBERTYPE(tmp)) {
@@ -1089,190 +1261,58 @@ pdf_doc_get_page (pdf_file *pf,
           count = 1;
         else {
           pdf_release_obj(tmp);
-          goto error;
+          goto error_exit;
         }
-
         if (page_idx < count)
           break;
-
         page_idx -= count;
-      }
-      
+      }      
       pdf_release_obj(kids);
     }
-
-    if (!depth || kids_length == i) {
-      if (media_box)
-        pdf_release_obj(media_box);
-     if (crop_box)
-        pdf_release_obj(crop_box);
-      goto error;
-    }
-
-    /* Nasty BBox selection... */
-    if ((options == 0) || (options == 1)) {
-      if (crop_box)
-        box = crop_box;
-      else
-        if (!(box = media_box) &&
-            !(box = bleed_box) &&
-            !(box = trim_box) &&
-            art_box) {
-            box = art_box;
-        }
-    } else if (options == 2) {
-      if (media_box)
-        box = media_box;
-      else
-        if (!(box = crop_box) &&
-            !(box = bleed_box) &&
-            !(box = trim_box) &&
-            art_box) {
-            box = art_box;
-        }
-    } else if (options == 3) {
-      if (art_box)
-        box = art_box;
-      else
-        if (!(box = crop_box) &&
-            !(box = media_box) &&
-            !(box = bleed_box) &&
-            trim_box) {
-            box = trim_box;
-        }
-    } else if (options == 4) {
-      if (trim_box)
-        box = trim_box;
-      else
-        if (!(box = crop_box) &&
-            !(box = media_box) &&
-            !(box = bleed_box) &&
-            art_box) {
-            box = art_box;
-        }
-    } else if (options == 5) {
-      if (bleed_box)
-        box = bleed_box;
-      else
-        if (!(box = crop_box) &&
-            !(box = media_box) &&
-            !(box = trim_box) &&
-            art_box) {
-            box = art_box;
-        }
-    }
-    medbox = media_box;
+    if (!depth || kids_length == i)
+      goto error_exit;
   }
 
-  if (!PDF_OBJ_ARRAYTYPE(box) || pdf_array_length(box) != 4 ||
-      !PDF_OBJ_DICTTYPE(resources))
-    goto error;
-
-  {
-    int i;
-
-    for (i = 4; i--; ) {
-      double x;
-      pdf_obj *tmp = pdf_deref_obj(pdf_get_array(box, i));
-      if (!PDF_OBJ_NUMBERTYPE(tmp)) {
-        pdf_release_obj(tmp);
-        goto error;
-      }
-      x = pdf_number_value(tmp);
-      switch (i) {
-      case 0: bbox->llx = x; break;
-      case 1: bbox->lly = x; break;
-      case 2: bbox->urx = x; break;
-      case 3: bbox->ury = x; break;
-      }
-      pdf_release_obj(tmp);
-    }
-
-    /* New scheme only for XDV files */
-    if (medbox && (is_xdv || options)) {
-      for (i = 4; i--; ) {
-        double x;
-        pdf_obj *tmp = pdf_deref_obj(pdf_get_array(medbox, i));
-        if (!PDF_OBJ_NUMBERTYPE(tmp)) {
-          pdf_release_obj(tmp);
-          goto error;
-        }
-        x = pdf_number_value(tmp);
-        switch (i) {
-        case 0: if (bbox->llx < x) bbox->llx = x; break;
-        case 1: if (bbox->lly < x) bbox->lly = x; break;
-        case 2: if (bbox->urx > x) bbox->urx = x; break;
-        case 3: if (bbox->ury > x) bbox->ury = x; break;
-        }
-        pdf_release_obj(tmp);
-      }
-    }
-  }
-  pdf_release_obj(box);
-
-  matrix->a = matrix->d = 1.0;
-  matrix->b = matrix->c = 0.0;
-  matrix->e = matrix->f = 0.0;
-  if (PDF_OBJ_NUMBERTYPE(rotate)) {
-    double deg = pdf_number_value(rotate);
-    if (deg - (int)deg != 0.0)
-    WARN("Invalid value specified for /Rotate: %f", deg);
-    else if (deg != 0.0) {
-      int rot = (int) deg;
-      if (rot % 90 != 0.0) {
-        WARN("Invalid value specified for /Rotate: %f", deg);
-      } else {
-        rot = rot % 360;
-        if (rot < 0) rot += 360;
-        switch (rot) {
-        case 90:
-          matrix->a = matrix->d = 0;
-          matrix->b = -1;
-          matrix->c = 1;
-          matrix->e = bbox->llx - bbox->lly;
-          matrix->f = bbox->lly + bbox->urx;
-          break;
-        case 180:
-          matrix->a = matrix->d = -1;
-          matrix->b = matrix->c = 0;
-          matrix->e = bbox->llx + bbox->urx;
-          matrix->f = bbox->lly + bbox->ury;
-          break;
-        case 270:
-          matrix->a = matrix->d = 0;
-          matrix->b = 1;
-          matrix->c = -1;
-          matrix->e = bbox->llx + bbox->ury;
-          matrix->f = bbox->lly - bbox->llx;
-          break;
-        }
-      }
-    }
-    pdf_release_obj(rotate);
-    rotate = NULL;
-  } else if (rotate)
-    goto error;
-
+  if (!PDF_OBJ_DICTTYPE(resources))
+    goto error_exit;
   if (resources_p)
-    *resources_p = resources;
-  else if (resources)
-    pdf_release_obj(resources);
+    *resources_p = pdf_link_obj(resources);
 
-  return page_tree;
+  /* Select page boundary box */
+  error = set_bounding_box(bbox, options, media_box, crop_box, art_box, trim_box, bleed_box);
+  if (error)
+    goto error_exit;
+  /* Set transformation matrix */
+  error = set_transform_matrix(matrix, bbox, rotate);
+  if (error)
+    goto error_exit;
+
+goto clean_exit; /* Success */
 
- error:
-  WARN("Cannot parse document. Broken PDF file?");
+ error_exit:
+  WARN("Error found in including PDF image.");
  error_silent:
-  if (box)
-    pdf_release_obj(box);
+  if (page_tree)
+    pdf_release_obj(page_tree);
+  page_tree = NULL;
+
+clean_exit:
+  if (crop_box)
+    pdf_release_obj(crop_box);
+  if (bleed_box)
+    pdf_release_obj(bleed_box);
+  if (trim_box)
+    pdf_release_obj(trim_box);
+  if (art_box)
+    pdf_release_obj(art_box);
+  if (media_box)
+    pdf_release_obj(media_box);
   if (rotate)
     pdf_release_obj(rotate);
   if (resources)
     pdf_release_obj(resources);
-  if (page_tree)
-    pdf_release_obj(page_tree);
 
-  return NULL;
+  return page_tree;
 }
 
 #ifndef BOOKMARKS_OPEN_DEFAULT
--- texlive-bin.orig/texk/dvipdfm-x/pdfencoding.c
+++ texlive-bin/texk/dvipdfm-x/pdfencoding.c
@@ -639,6 +639,10 @@ pdf_encoding_get_tounicode (int encoding
  * Note: The PDF 1.4 reference is not consistent: Section 5.9 describes
  * the Unicode mapping of PDF 1.3 and Section 9.7.2 (in the context of
  * Tagged PDF) the one of PDF 1.5.
+ * 
+ * CHANGED: 20180906
+ * Always create ToUnicode CMap unless there is missing mapping.
+ * Change made on rev.7557 broke ToUnicode CMap support. Now reverted.
  */
 pdf_obj *
 pdf_create_ToUnicode_CMap (const char *enc_name,
@@ -646,7 +650,7 @@ pdf_create_ToUnicode_CMap (const char *e
 {
   pdf_obj  *stream;
   CMap     *cmap;
-  int       code, all_predef;
+  int       code, total_fail;
   char     *cmap_name;
   unsigned char *p, *endptr;
 
@@ -664,32 +668,31 @@ pdf_create_ToUnicode_CMap (const char *e
 
   CMap_add_codespacerange(cmap, range_min, range_max, 1);
 
-  all_predef = 1;
+  total_fail = 0;
   for (code = 0; code <= 0xff; code++) {
     if (is_used && !is_used[code])
       continue;
 
     if (enc_vec[code]) {
-      int32_t len;
+      size_t len;
       int    fail_count = 0;
-      agl_name *agln = agl_lookup_list(enc_vec[code]);
-      /* Adobe glyph naming conventions are not used by viewers,
-       * hence even ligatures (e.g, "f_i") must be explicitly defined
-       */
-      if (pdf_check_version(1, 5) < 0 || !agln || !agln->is_predef) {
-        wbuf[0] = (code & 0xff);
-        p      = wbuf + 1;
-        endptr = wbuf + WBUF_SIZE;
-        len = agl_sput_UTF16BE(enc_vec[code], &p, endptr, &fail_count);
-        if (len >= 1 && !fail_count) {
-          CMap_add_bfchar(cmap, wbuf, 1, wbuf + 1, len);
-	  all_predef &= agln && agln->is_predef;
-        }
-      }
+      wbuf[0] = (code & 0xff);
+      p       = wbuf + 1;
+      endptr  = wbuf + WBUF_SIZE;
+      len = agl_sput_UTF16BE(enc_vec[code], &p, endptr, &fail_count);
+      if (len < 1 && fail_count > 0) {
+        total_fail++;
+      } else {
+        CMap_add_bfchar(cmap, wbuf, 1, wbuf + 1, len);
+      }  
     }
   }
 
-  stream = all_predef ? NULL : CMap_create_stream(cmap);
+  if (total_fail > 0) {
+    if (verbose)
+      WARN("Glyphs with no Unicode mapping found. Removing ToUnicode CMap.");
+  }
+  stream = total_fail > 0 ? NULL : CMap_create_stream(cmap);
 
   CMap_release(cmap);
   RELEASE(cmap_name);
--- texlive-bin.orig/texk/dvipdfm-x/pdffont.c
+++ texlive-bin/texk/dvipdfm-x/pdffont.c
@@ -569,11 +569,14 @@ pdf_close_fonts (void)
         pdf_add_dict(font->resource,
 		                 pdf_new_name("Encoding"),
 		                 PDF_OBJ_NAMETYPE(enc_obj) ? pdf_link_obj(enc_obj) : pdf_ref_obj(enc_obj));
-
-      if (!pdf_lookup_dict(font->resource, "ToUnicode") &&
-          (tounicode = pdf_encoding_get_tounicode(font->encoding_id)))
-        pdf_add_dict(font->resource,
-                     pdf_new_name("ToUnicode"), pdf_ref_obj(tounicode));
+      /* For built-in encoding, each font loader create ToUnicode CMap. */
+      if (!pdf_lookup_dict(font->resource, "ToUnicode")) {
+        tounicode = pdf_encoding_get_tounicode(font->encoding_id);
+        if (tounicode) {
+          pdf_add_dict(font->resource,
+                       pdf_new_name("ToUnicode"), pdf_ref_obj(tounicode));
+        }
+      }
     } else if (font->subtype == PDF_FONT_FONTTYPE_TRUETYPE) {
       /* encoding_id < 0 means MacRoman here (but not really)
        * We use MacRoman as "default" encoding. */
--- texlive-bin.orig/texk/dvipdfm-x/pdfobj.c
+++ texlive-bin/texk/dvipdfm-x/pdfobj.c
@@ -67,8 +67,17 @@ struct pdf_obj
   unsigned refcount;  /* Number of links to this object */
   int      flags;
   void    *data;
+
+#if defined(PDFOBJ_DEBUG)
+  int      obj_id;
+#endif
 };
 
+#if defined(PDFOBJ_DEBUG)
+static pdf_obj *bucket[65535];
+static int cur_obj_id = 0;
+#endif
+
 struct pdf_boolean
 {
   char  value;
@@ -540,6 +549,25 @@ pdf_out_flush (void)
 
     MFCLOSE(pdf_output_file);
   }
+#if defined(PDFOBJ_DEBUG)
+  {
+    int i;
+    MESG("\ndebug>> %d PDF objects created.", cur_obj_id);
+    for (i = 0; i < cur_obj_id; i++) {
+      pdf_obj *obj = bucket[i];
+      if (obj) {
+        if (obj->label > 0) {
+          WARN("Object obj_id=<%lu, %u> unreleased...", obj->label, obj->generation);
+          WARN("Reference count=%d", obj->refcount);
+        } else {
+          WARN("Unreleased object found: %d", i);
+          pdf_write_obj(obj, stderr);
+          MESG("\n");
+        }
+      }
+    }
+  }
+#endif
 }
 
 void
@@ -680,6 +708,12 @@ pdf_new_obj(int type)
   result->refcount   = 1;
   result->flags      = 0;
 
+#if defined(PDFOBJ_DEBUG)
+  result->obj_id = cur_obj_id;
+  bucket[cur_obj_id] = result;
+  cur_obj_id++;
+#endif
+
   return result;
 }
 
@@ -2771,6 +2805,9 @@ pdf_release_obj (pdf_obj *object)
   }
   object->refcount -= 1;
   if (object->refcount == 0) {
+#if defined(PDFOBJ_DEBUG)
+  bucket[object->obj_id] = NULL;
+#endif
     /*
      * Nothing is using this object so it's okay to remove it.
      * Nonzero "label" means object needs to be written before it's destroyed.
@@ -3576,19 +3613,17 @@ parse_xref_stream (pdf_file *pf, int xre
   if (index_obj) {
     unsigned int index_len;
     if (!PDF_OBJ_ARRAYTYPE(index_obj) ||
-	((index_len = pdf_array_length(index_obj)) % 2 ))
+        ((index_len = pdf_array_length(index_obj)) % 2 ))
       goto error;
 
     i = 0;
     while (i < index_len) {
       pdf_obj *first = pdf_get_array(index_obj, i++);
       size_obj  = pdf_get_array(index_obj, i++);
-      if (!PDF_OBJ_NUMBERTYPE(first) ||
-	  !PDF_OBJ_NUMBERTYPE(size_obj) ||
-	  parse_xrefstm_subsec(pf, &p, &length, W, wsum,
-			       (int) pdf_number_value(first),
-			       (int) pdf_number_value(size_obj)))
-	goto error;
+      if (!PDF_OBJ_NUMBERTYPE(first) || !PDF_OBJ_NUMBERTYPE(size_obj) ||
+          parse_xrefstm_subsec(pf, &p, &length, W, wsum,
+            (int) pdf_number_value(first), (int) pdf_number_value(size_obj)))
+        goto error;
     }
   } else if (parse_xrefstm_subsec(pf, &p, &length, W, wsum, 0, size))
       goto error;
@@ -3752,6 +3787,10 @@ pdf_file_get_trailer (pdf_file *pf)
   return pdf_link_obj(pf->trailer);
 }
 
+/* FIXME:
+ * pdf_file_get_trailer() does pdf_link_obj() but
+ * pdf_file_get_catalog() does not. Why?
+ */
 pdf_obj *
 pdf_file_get_catalog (pdf_file *pf)
 {
@@ -3807,9 +3846,9 @@ pdf_open (const char *ident, FILE *file)
 
       if (!PDF_OBJ_NAMETYPE(new_version) ||
           sscanf(pdf_name_value(new_version), "%u.%u", &major, &minor) != 2) {
-	pdf_release_obj(new_version);
-	WARN("Illegal Version entry in document catalog. Broken PDF file?");
-	goto error;
+        pdf_release_obj(new_version);
+        WARN("Illegal Version entry in document catalog. Broken PDF file?");
+        goto error;
       }
 
       if (pf->version < major*10+minor)
