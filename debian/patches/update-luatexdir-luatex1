---
 texk/web2c/luatexdir/dvi/dvigen.w          |   29 -
 texk/web2c/luatexdir/font/dofont.w         |    6 
 texk/web2c/luatexdir/font/luafont.w        |   25 -
 texk/web2c/luatexdir/font/mapfile.w        |    6 
 texk/web2c/luatexdir/font/texfont.h        |  149 +++-----
 texk/web2c/luatexdir/font/texfont.w        |  110 ++---
 texk/web2c/luatexdir/font/vfpacket.w       |   12 
 texk/web2c/luatexdir/font/writet1.w        |   20 -
 texk/web2c/luatexdir/image/pdftoepdf.w     |    4 
 texk/web2c/luatexdir/image/writeimg.w      |   27 -
 texk/web2c/luatexdir/lang/hyphen.w         |   10 
 texk/web2c/luatexdir/lang/texlang.h        |    4 
 texk/web2c/luatexdir/lang/texlang.w        |  248 ++++++++-----
 texk/web2c/luatexdir/lua/lcallbacklib.c    |  103 ++---
 texk/web2c/luatexdir/lua/lfontlib.c        |    4 
 texk/web2c/luatexdir/lua/limglib.c         |   17 
 texk/web2c/luatexdir/lua/llanglib.c        |    2 
 texk/web2c/luatexdir/lua/lnewtokenlib.c    |    6 
 texk/web2c/luatexdir/lua/lnodelib.c        |  537 ++++++++++++++++++++++-------
 texk/web2c/luatexdir/lua/lpdflib.c         |   68 +++
 texk/web2c/luatexdir/lua/lpdfscannerlib.cc |   18 
 texk/web2c/luatexdir/lua/ltexlib.c         |  242 +++++++++----
 texk/web2c/luatexdir/lua/ltokenlib.c.old   |  290 +++++++++++++++
 texk/web2c/luatexdir/lua/luainit.w         |   49 +-
 texk/web2c/luatexdir/lua/luanode.w         |  249 +++++--------
 texk/web2c/luatexdir/lua/luatex-api.h      |   16 
 texk/web2c/luatexdir/lua/luatoken.w        |   43 +-
 texk/web2c/luatexdir/luatex.c              |  113 +++++-
 texk/web2c/luatexdir/luatex.h              |    5 
 texk/web2c/luatexdir/luatexcallbackids.h   |    1 
 texk/web2c/luatexdir/pdf/pdfannot.w        |   18 
 texk/web2c/luatexdir/pdf/pdfcolorstack.w   |    5 
 texk/web2c/luatexdir/pdf/pdfgen.h          |   14 
 texk/web2c/luatexdir/pdf/pdfgen.w          |   95 +++--
 texk/web2c/luatexdir/pdf/pdfglyph.w        |    7 
 texk/web2c/luatexdir/pdf/pdflistout.w      |    4 
 texk/web2c/luatexdir/pdf/pdfliteral.w      |    9 
 texk/web2c/luatexdir/pdf/pdfluaapi.h.old   |   29 +
 texk/web2c/luatexdir/pdf/pdfluaapi.w.old   |  113 ++++++
 texk/web2c/luatexdir/pdf/pdfobj.w          |   18 
 texk/web2c/luatexdir/pdf/pdfpage.w         |    7 
 texk/web2c/luatexdir/pdf/pdfrule.w         |   16 
 texk/web2c/luatexdir/pdf/pdfshipout.w      |   88 +---
 texk/web2c/luatexdir/pdf/pdftables.h       |    4 
 texk/web2c/luatexdir/pdf/pdfthread.w       |    8 
 texk/web2c/luatexdir/pdf/pdfxform.h        |    4 
 texk/web2c/luatexdir/pdf/pdfxform.w        |   18 
 texk/web2c/luatexdir/ptexlib.h             |    5 
 texk/web2c/luatexdir/tex/align.w           |   65 +--
 texk/web2c/luatexdir/tex/buildpage.w       |   98 ++---
 texk/web2c/luatexdir/tex/commands.h        |   14 
 texk/web2c/luatexdir/tex/commands.w        |    9 
 texk/web2c/luatexdir/tex/conditional.w     |   13 
 texk/web2c/luatexdir/tex/dumpdata.w        |   16 
 texk/web2c/luatexdir/tex/equivalents.h     |  279 ++++++++++++++-
 texk/web2c/luatexdir/tex/equivalents.w     |   50 +-
 texk/web2c/luatexdir/tex/errors.w          |  204 +++++++++--
 texk/web2c/luatexdir/tex/expand.w          |   14 
 texk/web2c/luatexdir/tex/extensions.w      |   50 +-
 texk/web2c/luatexdir/tex/inputstack.w      |   19 -
 texk/web2c/luatexdir/tex/linebreak.w       |   78 ++--
 texk/web2c/luatexdir/tex/mainbody.h        |    3 
 texk/web2c/luatexdir/tex/mainbody.w        |   11 
 texk/web2c/luatexdir/tex/maincontrol.h     |   15 
 texk/web2c/luatexdir/tex/maincontrol.w     |  410 ++++++++++------------
 texk/web2c/luatexdir/tex/mathcodes.w       |   10 
 texk/web2c/luatexdir/tex/mlist.w           |  263 ++++++++------
 texk/web2c/luatexdir/tex/nesting.w         |   13 
 texk/web2c/luatexdir/tex/packaging.w       |   98 ++---
 texk/web2c/luatexdir/tex/primitive.w       |    2 
 texk/web2c/luatexdir/tex/printing.w        |   33 -
 texk/web2c/luatexdir/tex/scanning.h        |    2 
 texk/web2c/luatexdir/tex/scanning.w        |  143 +++----
 texk/web2c/luatexdir/tex/texfileio.w       |   30 -
 texk/web2c/luatexdir/tex/texmath.h         |    6 
 texk/web2c/luatexdir/tex/texmath.w         |  312 +++++++---------
 texk/web2c/luatexdir/tex/texnodes.h        |   69 ++-
 texk/web2c/luatexdir/tex/texnodes.w        |  171 ++++++---
 texk/web2c/luatexdir/tex/textoken.h        |    2 
 texk/web2c/luatexdir/tex/textoken.w        |   65 +--
 80 files changed, 3443 insertions(+), 1999 deletions(-)

--- texlive-bin.orig/texk/web2c/luatexdir/dvi/dvigen.w
+++ texlive-bin/texk/web2c/luatexdir/dvi/dvigen.w
@@ -39,21 +39,6 @@
 
 #define mode cur_list.mode_field        /* current mode */
 
-#define mag int_par(mag_code)
-#define tracing_output int_par(tracing_output_code)
-#define tracing_stats int_par(tracing_stats_code)
-#define tracing_online int_par(tracing_online_code)
-#define page_width dimen_par(page_width_code)
-#define page_height dimen_par(page_height_code)
-#define page_left_offset dimen_par(page_left_offset_code)
-#define page_right_offset dimen_par(page_right_offset_code)
-#define page_top_offset dimen_par(page_top_offset_code)
-#define page_bottom_offset dimen_par(page_bottom_offset_code)
-#define h_offset dimen_par(h_offset_code)
-#define v_offset dimen_par(v_offset_code)
-
-#define count(A) eqtb[count_base+(A)].cint
-
 @ The most important output produced by a run of \TeX\ is the ``device
 independent'' (\.{DVI}) file that specifies where characters and rules
 are to appear on printed pages. The form of these files was designed by
@@ -1136,7 +1121,7 @@
     dvi_four(25400000);
     dvi_four(473628672);        /* conversion ratio for sp */
     prepare_mag();
-    dvi_four(mag);              /* magnification factor is frozen */
+    dvi_four(mag_par);          /* magnification factor is frozen */
     if (output_comment) {
         l = (unsigned) strlen(output_comment);
         dvi_out(l);
@@ -1146,14 +1131,14 @@
         old_setting = selector;
         selector = new_string;
         tprint(" LuaTeX output ");
-        print_int(int_par(year_code));
+        print_int(year_par);
         print_char('.');
-        print_two(int_par(month_code));
+        print_two(month_par);
         print_char('.');
-        print_two(int_par(day_code));
+        print_two(day_par);
         print_char(':');
-        print_two(int_par(time_code) / 60);
-        print_two(int_par(time_code) % 60);
+        print_two(time_par / 60);
+        print_two(time_par % 60);
         selector = old_setting;
         dvi_out(cur_length);
         for (s = 0; s < cur_length; s++)
@@ -1236,7 +1221,7 @@
         dvi_four(25400000);
         dvi_four(473628672);    /* conversion ratio for sp */
         prepare_mag();
-        dvi_four(mag);          /* magnification factor */
+        dvi_four(mag_par);      /* magnification factor */
         dvi_four(max_v);
         dvi_four(max_h);
         dvi_out(max_push / 256);
--- texlive-bin.orig/texk/web2c/luatexdir/font/dofont.w
+++ texlive-bin/texk/web2c/luatexdir/font/dofont.w
@@ -81,8 +81,8 @@
     } else if (callback_id == 0) {
         res = read_tfm_info(f, cnom, s);
         if (res) {
-            set_hyphen_char(f, int_par(default_hyphen_char_code));
-            set_skew_char(f, int_par(default_skew_char_code));
+            set_hyphen_char(f, default_hyphen_char_par);
+            set_skew_char(f, default_skew_char_par);
         }
     }
     if (font_name(f) && strlen(font_name(f)) > 255) {
@@ -120,7 +120,7 @@
             "e.g., type `I\\font<same font id>=<substitute font name>'.",
             NULL
         };
-        if (int_par(suppress_fontnotfound_error_code) == 0) {
+        if (suppress_fontnotfound_error_par == 0) {
             msg = font_error_message(u, cnom, s);
             tex_error(msg, help);
             free(msg);
--- texlive-bin.orig/texk/web2c/luatexdir/font/luafont.w
+++ texlive-bin/texk/web2c/luatexdir/font/luafont.w
@@ -103,6 +103,8 @@
     "SubscriptShiftDownWithSuperscript",
     "FractionDelimiterSize",
     "FractionDelimiterDisplayStyleSize",
+    "NoLimitSubFactor",
+    "NoLimitSupFactor",
     NULL,
 };
 
@@ -964,7 +966,7 @@
             } else if (t == LUA_TSTRING) {
                 i = ff_checkoption(L, -2, NULL, MATH_param_names);
             }
-            n = (int) lua_tointeger(L, -1);
+            n = (int) lua_roundnumber(L, -1);
             if (i > 0) {
                 set_font_math_param(f, i, n);
             }
@@ -1389,9 +1391,9 @@
         i = FONT_SLANT_MAX;
     set_font_slant(f, i);
 
-    i = lua_numeric_field_by_index(L,lua_key_index(hyphenchar), int_par(default_hyphen_char_code));
+    i = lua_numeric_field_by_index(L,lua_key_index(hyphenchar), default_hyphen_char_par);
     set_hyphen_char(f, i);
-    i = lua_numeric_field_by_index(L,lua_key_index(skewchar), int_par(default_skew_char_code));
+    i = lua_numeric_field_by_index(L,lua_key_index(skewchar), default_skew_char_par);
     set_skew_char(f, i);
     i = n_boolean_field(L, lua_key_index(used), 0);
     set_font_used(f, (char) i);
@@ -2126,21 +2128,20 @@
 @c
 static halfword run_lua_ligkern_callback(halfword head, halfword tail, int callback_id)
 {
-    lua_State *L = Luas;
     int i;
-    int top = lua_gettop(L);
-    if (!get_callback(L, callback_id)) {
-        lua_pop(L, 2);
+    int top = lua_gettop(Luas);
+    if (!get_callback(Luas, callback_id)) {
+        lua_pop(Luas, 2);
         return tail;
     }
-    nodelist_to_lua(L, head);
-    nodelist_to_lua(L, tail);
-    if ((i=lua_pcall(L, 2, 0, 0)) != 0) {
-        luatex_error(L, (i == LUA_ERRRUN ? 0 : 1));
+    nodelist_to_lua(Luas, head);
+    nodelist_to_lua(Luas, tail);
+    if ((i=lua_pcall(Luas, 2, 0, 0)) != 0) {
+        luatex_error(Luas, (i == LUA_ERRRUN ? 0 : 1));
         return tail;
     }
     fix_node_list(head);
-    lua_settop(L, top);
+    lua_settop(Luas, top);
     return tail;
 }
 
--- texlive-bin.orig/texk/web2c/luatexdir/font/mapfile.w
+++ texlive-bin/texk/web2c/luatexdir/font/mapfile.w
@@ -58,7 +58,7 @@
     while (*r != ' ' && *r != '<' && *r != '"' && *r != '\0') \
         *q++ = *r++;                \
     *q = '\0';                      \
-    skip (r, ' ');                  \
+    skip_char(r, ' ');                  \
 } while (0)
 
 #define set_field(F) do {           \
@@ -367,7 +367,7 @@
         }
     }
     while (1) {                 /* loop through "specials", encoding, font file */
-        skip(r, ' ');
+        skip_char(r, ' ');
         switch (*r) {
         case '\0':
             goto done;
@@ -375,7 +375,7 @@
             r++;
             u = v = 0;
             do {
-                skip(r, ' ');
+                skip_char(r, ' ');
                 if (sscanf(r, "%f %n", &d, &j) > 0) {
                     s = r + j;  /* jump behind number, eat also blanks, if any */
                     if (*(s - 1) == 'E' || *(s - 1) == 'e')
--- texlive-bin.orig/texk/web2c/luatexdir/font/texfont.h
+++ texlive-bin/texk/web2c/luatexdir/font/texfont.h
@@ -139,7 +139,6 @@
     int _font_cache_id;         /* internal information */
     char _font_encodingbytes;   /* 1 or 2 bytes */
     boolean _font_oldmath;      /* default to false when MathConstants seen */
-
     int _font_slant;            /* a slant in ppt */
     int _font_extend;           /* an extension in ppt, or 1000 */
     int font_max_shrink;
@@ -230,114 +229,114 @@
 
 boolean cmp_font_area(int, str_number);
 
-#  define font_reassign(a,b)            { if (a!=NULL) free(a); a = b; }
+#  define font_reassign(a,b)             { if (a!=NULL) free(a); a = b; }
 
-#  define font_filename(a)            font_tables[a]->_font_filename
-#  define set_font_filename(f,b)      font_reassign(font_filename(f),b)
+#  define font_filename(a)               font_tables[a]->_font_filename
+#  define set_font_filename(f,b)         font_reassign(font_filename(f),b)
 
-#  define font_fullname(a)            font_tables[a]->_font_fullname
-#  define set_font_fullname(f,b)      font_reassign(font_fullname(f),b)
+#  define font_fullname(a)               font_tables[a]->_font_fullname
+#  define set_font_fullname(f,b)         font_reassign(font_fullname(f),b)
 
-#  define font_psname(a)              font_tables[a]->_font_psname
-#  define set_font_psname(f,b)        font_reassign(font_psname(f),b)
+#  define font_psname(a)                 font_tables[a]->_font_psname
+#  define set_font_psname(f,b)           font_reassign(font_psname(f),b)
 
-#  define font_encodingname(a)        font_tables[a]->_font_encodingname
-#  define set_font_encodingname(f,b)  font_reassign(font_encodingname(f),b)
+#  define font_encodingname(a)           font_tables[a]->_font_encodingname
+#  define set_font_encodingname(f,b)     font_reassign(font_encodingname(f),b)
 
-#  define cmp_font_filename(a,b)      (!(font_filename(a)!=NULL || font_filename(b)!=NULL || \
-                                       strcmp(font_filename(a),font_filename(b))))
-#  define cmp_font_fullname(a,b)      (!(font_fullname(a)!=NULL || font_fullname(b)!=NULL || \
-                                       strcmp(font_fullname(a),font_fullname(b))))
-#  define cmp_font_encodingname(a,b)  (!(font_encoding(a)!=NULL || font_encodingname(b)!=NULL || \
-                                       strcmp(font_encodingname(a),font_encodingname(b))))
+#  define cmp_font_filename(a,b)         (!(font_filename(a)!=NULL || font_filename(b)!=NULL || \
+                                          strcmp(font_filename(a),font_filename(b))))
+#  define cmp_font_fullname(a,b)         (!(font_fullname(a)!=NULL || font_fullname(b)!=NULL || \
+                                          strcmp(font_fullname(a),font_fullname(b))))
+#  define cmp_font_encodingname(a,b)     (!(font_encoding(a)!=NULL || font_encodingname(b)!=NULL || \
+                                          strcmp(font_encodingname(a),font_encodingname(b))))
 
-#  define font_bc(a)                  font_tables[a]->_font_bc
-#  define set_font_bc(f,b)            font_bc(f) = b
+#  define font_bc(a)                     font_tables[a]->_font_bc
+#  define set_font_bc(f,b)               font_bc(f) = b
 
-#  define font_ec(a)                  font_tables[a]->_font_ec
-#  define set_font_ec(f,b)            font_ec(f) = b
+#  define font_ec(a)                     font_tables[a]->_font_ec
+#  define set_font_ec(f,b)               font_ec(f) = b
 
-#  define font_used(a)                (font_tables[a]!=NULL && font_tables[a]->_font_used)
-#  define set_font_used(a,b)          font_tables[a]->_font_used = b
+#  define font_used(a)                   (font_tables[a]!=NULL && font_tables[a]->_font_used)
+#  define set_font_used(a,b)             font_tables[a]->_font_used = b
 
-#  define font_touched(a)             font_tables[a]->_font_touched
-#  define set_font_touched(a,b)       font_touched(a) = b
+#  define font_touched(a)                font_tables[a]->_font_touched
+#  define set_font_touched(a,b)          font_touched(a) = b
 
-#  define font_type(a)                font_tables[a]->_font_type
-#  define set_font_type(a,b)          font_type(a) = b;
+#  define font_type(a)                   font_tables[a]->_font_type
+#  define set_font_type(a,b)             font_type(a) = b;
 
-#  define font_format(a)              font_tables[a]->_font_format
-#  define font_format_name(a)         font_format_strings[font_tables[a]->_font_format]
-#  define set_font_format(a,b)        font_format(a) = b
+#  define font_format(a)                 font_tables[a]->_font_format
+#  define font_format_name(a)            font_format_strings[font_tables[a]->_font_format]
+#  define set_font_format(a,b)           font_format(a) = b
 
-#  define font_embedding(a)           font_tables[a]->_font_embedding
-#  define set_font_embedding(a,b)     font_embedding(a) = b
+#  define font_embedding(a)              font_tables[a]->_font_embedding
+#  define set_font_embedding(a,b)        font_embedding(a) = b
 
-#  define font_cidversion(a)          font_tables[a]->_font_cidversion
-#  define set_font_cidversion(a,b)    font_cidversion(a) = b
+#  define font_cidversion(a)             font_tables[a]->_font_cidversion
+#  define set_font_cidversion(a,b)       font_cidversion(a) = b
 
-#  define font_cidsupplement(a)       font_tables[a]->_font_cidsupplement
-#  define set_font_cidsupplement(a,b) font_cidsupplement(a) = b
+#  define font_cidsupplement(a)          font_tables[a]->_font_cidsupplement
+#  define set_font_cidsupplement(a,b)    font_cidsupplement(a) = b
 
-#  define font_cidordering(a)         font_tables[a]->_font_cidordering
-#  define set_font_cidordering(f,b)   font_reassign(font_cidordering(f),b)
+#  define font_cidordering(a)            font_tables[a]->_font_cidordering
+#  define set_font_cidordering(f,b)      font_reassign(font_cidordering(f),b)
 
-#  define font_cidregistry(a)         font_tables[a]->_font_cidregistry
-#  define set_font_cidregistry(f,b)   font_reassign(font_cidregistry(f),b)
+#  define font_cidregistry(a)            font_tables[a]->_font_cidregistry
+#  define set_font_cidregistry(f,b)      font_reassign(font_cidregistry(f),b)
 
-#  define font_map(a)                 font_tables[a]->_font_map
-#  define set_font_map(a,b)           font_map(a) = b
+#  define font_map(a)                    font_tables[a]->_font_map
+#  define set_font_map(a,b)              font_map(a) = b
 
-#  define font_cache_id(a)            font_tables[a]->_font_cache_id
-#  define set_font_cache_id(a,b)      font_cache_id(a) = b
+#  define font_cache_id(a)               font_tables[a]->_font_cache_id
+#  define set_font_cache_id(a,b)         font_cache_id(a) = b
 
-#  define font_encodingbytes(a)       font_tables[a]->_font_encodingbytes
-#  define set_font_encodingbytes(a,b) font_encodingbytes(a) = b
+#  define font_encodingbytes(a)          font_tables[a]->_font_encodingbytes
+#  define set_font_encodingbytes(a,b)    font_encodingbytes(a) = b
 
-#  define font_oldmath(a)             font_tables[a]->_font_oldmath
-#  define set_font_oldmath(a,b)       font_oldmath(a) = b
+#  define font_oldmath(a)                font_tables[a]->_font_oldmath
+#  define set_font_oldmath(a,b)          font_oldmath(a) = b
 
-#  define font_slant(a)               font_tables[a]->_font_slant
-#  define set_font_slant(a,b)         font_slant(a) = b
+#  define font_slant(a)                  font_tables[a]->_font_slant
+#  define set_font_slant(a,b)            font_slant(a) = b
 
-#  define font_extend(a)              font_tables[a]->_font_extend
-#  define set_font_extend(a,b)        font_extend(a) = b
+#  define font_extend(a)                 font_tables[a]->_font_extend
+#  define set_font_extend(a,b)           font_extend(a) = b
 
-#  define font_shrink(a)              font_tables[a]->_font_shrink
-#  define set_font_shrink(a,b)        font_shrink(a) = b
+#  define font_shrink(a)                 font_tables[a]->_font_shrink
+#  define set_font_shrink(a,b)           font_shrink(a) = b
 
-#  define font_stretch(a)             font_tables[a]->_font_stretch
-#  define set_font_stretch(a,b)       font_stretch(a) = b
+#  define font_stretch(a)                font_tables[a]->_font_stretch
+#  define set_font_stretch(a,b)          font_stretch(a) = b
 
-#  define font_max_shrink(a)          font_tables[a]->font_max_shrink
-#  define set_font_max_shrink(a,b)    font_max_shrink(a) = b
+#  define font_max_shrink(a)             font_tables[a]->font_max_shrink
+#  define set_font_max_shrink(a,b)       font_max_shrink(a) = b
 
-#  define font_max_stretch(a)         font_tables[a]->font_max_stretch
-#  define set_font_max_stretch(a,b)   font_max_stretch(a) = b
+#  define font_max_stretch(a)            font_tables[a]->font_max_stretch
+#  define set_font_max_stretch(a,b)      font_max_stretch(a) = b
 
-#  define font_step(a)                font_tables[a]->_font_step
-#  define set_font_step(a,b)          font_step(a) = b
+#  define font_step(a)                   font_tables[a]->_font_step
+#  define set_font_step(a,b)             font_step(a) = b
 
-#  define font_auto_expand(a)         font_tables[a]->_font_auto_expand
-#  define set_font_auto_expand(a,b)   font_auto_expand(a) = b
+#  define font_auto_expand(a)            font_tables[a]->_font_auto_expand
+#  define set_font_auto_expand(a,b)      font_auto_expand(a) = b
 
-#  define font_tounicode(a)           font_tables[a]->_font_tounicode
-#  define set_font_tounicode(a,b)     font_tounicode(a) = b
+#  define font_tounicode(a)              font_tables[a]->_font_tounicode
+#  define set_font_tounicode(a,b)        font_tounicode(a) = b
 
-#  define hyphen_char(a)              font_tables[a]->_hyphen_char
-#  define set_hyphen_char(a,b)        hyphen_char(a) = b
+#  define hyphen_char(a)                 font_tables[a]->_hyphen_char
+#  define set_hyphen_char(a,b)           hyphen_char(a) = b
 
-#  define skew_char(a)                font_tables[a]->_skew_char
-#  define set_skew_char(a,b)          skew_char(a) = b
+#  define skew_char(a)                   font_tables[a]->_skew_char
+#  define set_skew_char(a,b)             skew_char(a) = b
 
-#  define font_natural_dir(a)         font_tables[a]->_font_natural_dir
-#  define set_font_natural_dir(a,b)   font_natural_dir(a) = b
+#  define font_natural_dir(a)            font_tables[a]->_font_natural_dir
+#  define set_font_natural_dir(a,b)      font_natural_dir(a) = b
 
-#  define pdf_font_num(a)             font_tables[a]->_pdf_font_num
-#  define set_pdf_font_num(a,b)       pdf_font_num(a) = b
+#  define pdf_font_num(a)                font_tables[a]->_pdf_font_num
+#  define set_pdf_font_num(a,b)          pdf_font_num(a) = b
 
-#  define pdf_font_attr(a)            font_tables[a]->_pdf_font_attr
-#  define set_pdf_font_attr(a,b)      pdf_font_attr(a) = b
+#  define pdf_font_attr(a)               font_tables[a]->_pdf_font_attr
+#  define set_pdf_font_attr(a,b)         pdf_font_attr(a) = b
 
 #  define left_boundarychar  -1
 #  define right_boundarychar -2
--- texlive-bin.orig/texk/web2c/luatexdir/font/texfont.w
+++ texlive-bin/texk/web2c/luatexdir/font/texfont.w
@@ -267,18 +267,25 @@
     x = ci->top_left_math_kerns;
     co->top_left_math_kerns = x;
     if (x > 0) {
-        co->top_left_math_kern_array =
-            xmalloc((unsigned) (2 * (int) sizeof(scaled) * x));
+        co->top_left_math_kern_array = xmalloc((unsigned) (2 * (int) sizeof(scaled) * x));
         for (k = 0; k < co->top_left_math_kerns; k++) {
             co->top_left_math_kern_array[(2 * k)] = ci->top_left_math_kern_array[(2 * k)];
             co->top_left_math_kern_array[(2 * k) + 1] = ci->top_left_math_kern_array[(2 * k) + 1];
         }
     }
+    x = ci->bottom_left_math_kerns;
+    co->bottom_left_math_kerns = x;
+    if (x > 0) {
+        co->bottom_left_math_kern_array = xmalloc((unsigned) (2 * (int) sizeof(scaled) * x));
+        for (k = 0; k < co->bottom_left_math_kerns; k++) {
+            co->bottom_left_math_kern_array[(2 * k)] = ci->bottom_left_math_kern_array[(2 * k)];
+            co->bottom_left_math_kern_array[(2 * k) + 1] = ci->bottom_left_math_kern_array[(2 * k) + 1];
+        }
+    }
     x = ci->top_right_math_kerns;
     co->top_right_math_kerns = x;
     if (x > 0) {
-        co->top_right_math_kern_array =
-            xmalloc((unsigned) (2 * (int) sizeof(scaled) * x));
+        co->top_right_math_kern_array = xmalloc((unsigned) (2 * (int) sizeof(scaled) * x));
         for (k = 0; k < co->top_right_math_kerns; k++) {
             co->top_right_math_kern_array[(2 * k)] = ci->top_right_math_kern_array[(2 * k)];
             co->top_right_math_kern_array[(2 * k) + 1] = ci->top_right_math_kern_array[(2 * k) + 1];
@@ -287,23 +294,12 @@
     x = ci->bottom_right_math_kerns;
     co->bottom_right_math_kerns = x;
     if (x > 0) {
-        co->bottom_right_math_kern_array =
-            xmalloc((unsigned) (2 * (int) sizeof(scaled) * x));
+        co->bottom_right_math_kern_array = xmalloc((unsigned) (2 * (int) sizeof(scaled) * x));
         for (k = 0; k < co->bottom_right_math_kerns; k++) {
             co->bottom_right_math_kern_array[(2 * k)] = ci->bottom_right_math_kern_array[(2 * k)];
             co->bottom_right_math_kern_array[(2 * k) + 1] = ci->bottom_right_math_kern_array[(2 * k) + 1];
         }
     }
-    x = ci->bottom_left_math_kerns;
-    co->bottom_left_math_kerns = x;
-    if (x > 0) {
-        co->bottom_left_math_kern_array =
-            xmalloc((unsigned) (2 * (int) sizeof(scaled) * x));
-        for (k = 0; k < co->bottom_left_math_kerns; k++) {
-            co->bottom_left_math_kern_array[(2 * k)] = ci->bottom_left_math_kern_array[(2 * k)];
-            co->bottom_left_math_kern_array[(2 * k) + 1] = ci->bottom_left_math_kern_array[(2 * k) + 1];
-        }
-    }
     return co;
 }
 
@@ -354,22 +350,21 @@
 static int lua_char_exists_callback(internal_font_number f, int c)
 {
     int callback_id;
-    lua_State *L = Luas;
     int ret = 0;
     callback_id = callback_defined(char_exists_callback);
     if (callback_id != 0) {
-        if (!get_callback(L, callback_id)) {
-            lua_pop(L, 2);
+        if (!get_callback(Luas, callback_id)) {
+            lua_pop(Luas, 2);
             return 0;
         }
-        lua_pushinteger(L, f);
-        lua_pushinteger(L, c);
-        if (lua_pcall(L, 2, 1, 0) != 0) {       /* two args, 1 result */
-            fprintf(stdout, "error: %s\n", lua_tostring(L, -1));
-            lua_pop(L, 2);
+        lua_pushinteger(Luas, f);
+        lua_pushinteger(Luas, c);
+        if (lua_pcall(Luas, 2, 1, 0) != 0) {       /* two args, 1 result */
+            fprintf(stdout, "error: %s\n", lua_tostring(Luas, -1));
+            lua_pop(Luas, 2);
             error();
         } else {
-            ret = lua_toboolean(L, -1);
+            ret = lua_toboolean(Luas, -1);
         }
     }
     return ret;
@@ -653,10 +648,10 @@
         k = ci->top_left_math_kerns;
     } else if (id == bottom_left_kern) {
         k = ci->bottom_left_math_kerns;
-    } else if (id == bottom_right_kern) {
-        k = ci->bottom_right_math_kerns;
     } else if (id == top_right_kern) {
         k = ci->top_right_math_kerns;
+    } else if (id == bottom_right_kern) {
+        k = ci->bottom_right_math_kerns;
     } else {
         confusion("get_charinfo_math_kerns");
     }
@@ -675,25 +670,22 @@
         ci->top_left_math_kerns++;
     } else if (id == bottom_left_kern) {
         k = ci->bottom_left_math_kerns;
-        do_realloc(ci->bottom_left_math_kern_array, ((k + 1) * 2),
-                   sizeof(scaled));
+        do_realloc(ci->bottom_left_math_kern_array, ((k + 1) * 2), sizeof(scaled));
         ci->bottom_left_math_kern_array[(2 * (k))] = ht;
         ci->bottom_left_math_kern_array[(2 * (k)) + 1] = krn;
         ci->bottom_left_math_kerns++;
-    } else if (id == bottom_right_kern) {
-        k = ci->bottom_right_math_kerns;
-        do_realloc(ci->bottom_right_math_kern_array, ((k + 1) * 2),
-                   sizeof(scaled));
-        ci->bottom_right_math_kern_array[(2 * (k))] = ht;
-        ci->bottom_right_math_kern_array[(2 * (k)) + 1] = krn;
-        ci->bottom_right_math_kerns++;
     } else if (id == top_right_kern) {
         k = ci->top_right_math_kerns;
-        do_realloc(ci->top_right_math_kern_array, ((k + 1) * 2),
-                   sizeof(scaled));
+        do_realloc(ci->top_right_math_kern_array, ((k + 1) * 2), sizeof(scaled));
         ci->top_right_math_kern_array[(2 * (k))] = ht;
         ci->top_right_math_kern_array[(2 * (k)) + 1] = krn;
         ci->top_right_math_kerns++;
+    } else if (id == bottom_right_kern) {
+        k = ci->bottom_right_math_kerns;
+        do_realloc(ci->bottom_right_math_kern_array, ((k + 1) * 2), sizeof(scaled));
+        ci->bottom_right_math_kern_array[(2 * (k))] = ht;
+        ci->bottom_right_math_kern_array[(2 * (k)) + 1] = krn;
+        ci->bottom_right_math_kerns++;
     } else {
         confusion("add_charinfo_math_kern");
     }
@@ -716,17 +708,17 @@
         dump_int(ci->bottom_left_math_kern_array[(2 * k)]);
         dump_int(ci->bottom_left_math_kern_array[(2 * k) + 1]);
     }
-    l = ci->bottom_right_math_kerns;
+    l = ci->top_right_math_kerns;
     dump_int(l);
     for (k = 0; k < l; k++) {
-        dump_int(ci->bottom_right_math_kern_array[(2 * k)]);
-        dump_int(ci->bottom_right_math_kern_array[(2 * k) + 1]);
+        dump_int(ci->top_right_math_kern_array[(2 * k)]);
+        dump_int(ci->top_right_math_kern_array[(2 * k) + 1]);
     }
-    l = ci->top_right_math_kerns;
+    l = ci->bottom_right_math_kerns;
     dump_int(l);
     for (k = 0; k < l; k++) {
-        dump_int(ci->bottom_left_math_kern_array[(2 * k)]);
-        dump_int(ci->bottom_left_math_kern_array[(2 * k) + 1]);
+        dump_int(ci->bottom_right_math_kern_array[(2 * k)]);
+        dump_int(ci->bottom_right_math_kern_array[(2 * k) + 1]);
     }
 }
 
@@ -738,8 +730,7 @@
     undump_int(x);
     ci->top_left_math_kerns = x;
     if (x > 0)
-        ci->top_left_math_kern_array =
-            xmalloc((unsigned) (2 * (int) sizeof(scaled) * x));
+        ci->top_left_math_kern_array = xmalloc((unsigned) (2 * (int) sizeof(scaled) * x));
     for (k = 0; k < ci->top_left_math_kerns; k++) {
         undump_int(x);
         ci->top_left_math_kern_array[(2 * k)] = (scaled) x;
@@ -749,8 +740,7 @@
     undump_int(x);
     ci->bottom_left_math_kerns = x;
     if (x > 0)
-        ci->bottom_left_math_kern_array =
-            xmalloc((unsigned) (2 * (int) sizeof(scaled) * x));
+        ci->bottom_left_math_kern_array = xmalloc((unsigned) (2 * (int) sizeof(scaled) * x));
     for (k = 0; k < ci->bottom_left_math_kerns; k++) {
         undump_int(x);
         ci->bottom_left_math_kern_array[(2 * k)] = (scaled) x;
@@ -758,26 +748,24 @@
         ci->bottom_left_math_kern_array[(2 * k) + 1] = (scaled) x;
     }
     undump_int(x);
-    ci->bottom_right_math_kerns = x;
+    ci->top_right_math_kerns = x;
     if (x > 0)
-        ci->bottom_right_math_kern_array =
-            xmalloc((unsigned) (2 * (int) sizeof(scaled) * x));
-    for (k = 0; k < ci->bottom_right_math_kerns; k++) {
+        ci->top_right_math_kern_array = xmalloc((unsigned) (2 * (int) sizeof(scaled) * x));
+    for (k = 0; k < ci->top_right_math_kerns; k++) {
         undump_int(x);
-        ci->bottom_right_math_kern_array[(2 * k)] = (scaled) x;
+        ci->top_right_math_kern_array[(2 * k)] = (scaled) x;
         undump_int(x);
-        ci->bottom_right_math_kern_array[(2 * k) + 1] = (scaled) x;
+        ci->top_right_math_kern_array[(2 * k) + 1] = (scaled) x;
     }
     undump_int(x);
-    ci->top_right_math_kerns = x;
+    ci->bottom_right_math_kerns = x;
     if (x > 0)
-        ci->top_right_math_kern_array =
-            xmalloc((unsigned) (2 * (int) sizeof(scaled) * x));
-    for (k = 0; k < ci->top_right_math_kerns; k++) {
+        ci->bottom_right_math_kern_array = xmalloc((unsigned) (2 * (int) sizeof(scaled) * x));
+    for (k = 0; k < ci->bottom_right_math_kerns; k++) {
         undump_int(x);
-        ci->top_right_math_kern_array[(2 * k)] = (scaled) x;
+        ci->bottom_right_math_kern_array[(2 * k)] = (scaled) x;
         undump_int(x);
-        ci->top_right_math_kern_array[(2 * k) + 1] = (scaled) x;
+        ci->bottom_right_math_kern_array[(2 * k) + 1] = (scaled) x;
     }
 }
 
@@ -1798,8 +1786,6 @@
 /* moved from pdffont.w */
 
 @ @c
-#define font_id_text(A) cs_text(font_id_base+(A)) /* a frozen font identifier's name */
-
 int pk_dpi; /* PK pixel density value from \.{texmf.cnf} */
 
 @ @c
--- texlive-bin.orig/texk/web2c/luatexdir/font/vfpacket.w
+++ texlive-bin/texk/web2c/luatexdir/font/vfpacket.w
@@ -202,13 +202,13 @@
             break;
         case packet_char_code:
             packet_number(k);
-            if (!char_exists(vp->lf, (int) k))
+            /* we also check if c == k and font(c) == font)k) */
+            if (!char_exists(vp->lf, (int) k)) {
                 char_warning(vp->lf, (int) k);
-            else {
-                if (has_packet(vp->lf, (int) k))
-                    do_vf_packet(pdf, vp->lf, (int) k, ex_glyph);
-                else
-                    backend_out[glyph_node] (pdf, vp->lf, (int) k, ex_glyph);
+            } else if (! ((c == k && vp->lf == vf_f)) && (has_packet(vp->lf, (int) k))) {
+                do_vf_packet(pdf, vp->lf, (int) k, ex_glyph);
+            } else {
+                backend_out[glyph_node] (pdf, vp->lf, (int) k, ex_glyph);
             }
             w = char_width(vp->lf, (int) k);
             mat_p->pos.h += round_xn_over_d(w, 1000 + ex_glyph, 1000);
--- texlive-bin.orig/texk/web2c/luatexdir/font/writet1.w
+++ texlive-bin/texk/web2c/luatexdir/font/writet1.w
@@ -309,13 +309,13 @@
     }
     names_count = 0;
     r++;                        /* skip '[' */
-    skip(r, ' ');
+    skip_char(r, ' ');
     for (;;) {
         while (*r == '/') {
             for (p = buf, r++;
                  *r != ' ' && *r != 10 && *r != ']' && *r != '/'; *p++ = *r++);
             *p = 0;
-            skip(r, ' ');
+            skip_char(r, ' ');
             if (names_count >= 256)
                 normal_error("type 1","encoding vector contains more than 256 names");
             if (strcmp(buf, notdef) != 0)
@@ -444,7 +444,7 @@
 static float t1_scan_num(char *p, char **r)
 {
     float f;
-    skip(p, ' ');
+    skip_char(p, ' ');
     if (sscanf(p, "%g", &f) != 1) {
         remove_eol(p, t1_line_array);
         formatted_error("type 1","a number expected: '%s'", t1_line_array);
@@ -682,7 +682,7 @@
     if (key - font_key == FONT_KEYS_NUM)
         return;
     p = t1_line_array + strlen(key->t1name) + 1;
-    skip(p, ' ');
+    skip_char(p, ' ');
     if ((k = (int) (key - font_key)) == FONTNAME_CODE) {
         if (*p != '/') {
             remove_eol(p, t1_line_array);
@@ -787,14 +787,14 @@
     t1_encoding = ENC_BUILTIN;
     if (t1_prefix("/Encoding [") || t1_prefix("/Encoding[")) {  /* the first case */
         r = strchr(t1_line_array, '[') + 1;
-        skip(r, ' ');
+        skip_char(r, ' ');
         for (;;) {
             while (*r == '/') {
                 for (p = t1_buf_array, r++;
                      *r != 32 && *r != 10 && *r != ']' && *r != '/';
                      *p++ = *r++);
                 *p = 0;
-                skip(r, ' ');
+                skip_char(r, ' ');
                 if (counter > 255)
                     normal_error("type 1","encoding vector contains more than 256 names");
                 if (strcmp(t1_buf_array, notdef) != 0)
@@ -827,7 +827,7 @@
                 if (strcmp(t1_buf_array + 1, notdef) != 0)
                     glyph_names[i] = xstrdup(t1_buf_array + 1);
                 p = strstr(p, " put") + strlen(" put");
-                skip(p, ' ');
+                skip_char(p, ' ');
             }
             /*
                check for \.{dup dup <to> exch <from> get put}
@@ -836,7 +836,7 @@
                      && valid_code(a) && valid_code(b)) {
                 copy_glyph_names(glyph_names, a, b);
                 p = strstr(p, " get put") + strlen(" get put");
-                skip(p, ' ');
+                skip_char(p, ' ');
             }
             /*
                check for \.{dup dup <from> <size> getinterval <to> exch putinterval}
@@ -848,7 +848,7 @@
                 for (i = 0; i < c; i++)
                     copy_glyph_names(glyph_names, a + i, b + i);
                 p = strstr(p, " putinterval") + strlen(" putinterval");
-                skip(p, ' ');
+                skip_char(p, ' ');
             }
             /*
                check for \.{def} or \.{readonly def}
@@ -862,7 +862,7 @@
             else {
                 while (*p != ' ' && *p != 10)
                     p++;
-                skip(p, ' ');
+                skip_char(p, ' ');
             }
         }
     }
--- texlive-bin.orig/texk/web2c/luatexdir/image/pdftoepdf.w
+++ texlive-bin/texk/web2c/luatexdir/image/pdftoepdf.w
@@ -596,6 +596,10 @@
         pdf_doc = refPdfDocument(img_filepath(idict), FE_FAIL);
     else if (img_type(idict) == IMG_TYPE_PDFMEMSTREAM) {
         pdf_doc = findPdfDocument(img_filepath(idict)) ;
+        if (pdf_doc == NULL ) 
+           normal_error("pdf inclusion", "memstream not initialized");
+        if (pdf_doc->doc == NULL)
+           normal_error("pdf inclusion", "memstream document is empty");
         pdf_doc->occurences++;
     } else {
         normal_error("pdf inclusion","unknown document");
--- texlive-bin.orig/texk/web2c/luatexdir/image/writeimg.w
+++ texlive-bin/texk/web2c/luatexdir/image/writeimg.w
@@ -281,15 +281,22 @@
     callback_id = callback_defined(find_image_file_callback);
     if (img_filepath(idict) == NULL) {
         if (callback_id > 0) {
+            /* we always callback, also for a mem stream */
             if (run_callback(callback_id, "S->S", img_filename(idict),&filepath)) {
                 if (filepath && (strlen(filepath) > 0)) {
                     img_filepath(idict) = strdup(filepath);
                 }
             }
-        } else {
+        }
+        if (img_filepath(idict) == NULL && (strstr(img_filename(idict),"data:application/pdf,") != NULL)) {
+            /* we need to check here for a pdf memstream */
+            img_filepath(idict) = strdup(img_filename(idict));
+        } else if (callback_id == 0) {
+            /* otherwise we use kpse but only when we don't callback  */
             img_filepath(idict) = kpse_find_file(img_filename(idict), kpse_tex_format, true);
         }
         if (img_filepath(idict) == NULL) {
+            /* in any case we need a name */
             formatted_error("pdf backend","cannot find image file '%s'", img_filename(idict));
         }
     }
@@ -420,8 +427,6 @@
 }
 
 @ @c
-#define tail cur_list.tail_field
-
 void scan_pdfrefximage(PDF pdf)
 {
     int transform = 0;          /* one could scan transform as well */
@@ -434,20 +439,20 @@
     idict = idict_array[obj_data_ptr(pdf, cur_val)];
     if (img_state(idict) == DICT_NEW) {
         normal_warning("image","don't rely on the image data to be okay");
-        width(tail) = 0;
-        height(tail) = 0;
-        depth(tail) = 0;
+        width(tail_par) = 0;
+        height(tail_par) = 0;
+        depth(tail_par) = 0;
     } else {
         if (alt_rule.wd != null_flag || alt_rule.ht != null_flag || alt_rule.dp != null_flag) {
             dim = scale_img(idict, alt_rule, transform);
         } else {
             dim = scale_img(idict, img_dimen(idict), img_transform(idict));
         }
-        width(tail) = dim.wd;
-        height(tail) = dim.ht;
-        depth(tail) = dim.dp;
-        rule_transform(tail) = transform;
-        rule_index(tail) = img_index(idict);
+        width(tail_par) = dim.wd;
+        height(tail_par) = dim.ht;
+        depth(tail_par) = dim.dp;
+        rule_transform(tail_par) = transform;
+        rule_index(tail_par) = img_index(idict);
     }
 }
 
--- texlive-bin.orig/texk/web2c/luatexdir/lang/hyphen.w
+++ texlive-bin/texk/web2c/luatexdir/lang/hyphen.w
@@ -805,10 +805,14 @@
          here = get_vlink(here)) {
 
         int ch;
-        if (here == begin_point || here == end_point)
+        if (here == begin_point || here == end_point) {
             ch = '.';
-        else
-            ch = get_lc_code(get_character(here));
+        } else {
+            ch = get_hj_code(char_lang(here),get_character(here));
+            if (ch <= 32) {
+                ch = get_character(here);
+            }
+        }
         while (state != -1) {
 #if 0
             printf("%*s%s%c",char_num-strlen(get_state_str(state)),"",get_state_str(state),(char)ch);
--- texlive-bin.orig/texk/web2c/luatexdir/lang/texlang.h
+++ texlive-bin/texk/web2c/luatexdir/lang/texlang.h
@@ -17,7 +17,6 @@
    You should have received a copy of the GNU General Public License along
    with LuaTeX; if not, see <http://www.gnu.org/licenses/>. */
 
-
 #ifndef TEXLANG_H
 #  define TEXLANG_H
 
@@ -46,8 +45,7 @@
 extern struct tex_language *new_language(int n);
 extern struct tex_language *get_language(int n);
 extern void load_patterns(struct tex_language *lang, const unsigned char *buf);
-extern void load_hyphenation(struct tex_language *lang,
-                             const unsigned char *buf);
+extern void load_hyphenation(struct tex_language *lang, const unsigned char *buf);
 extern int hyphenate_string(struct tex_language *lang, char *w, char **ret);
 
 extern void new_hyphenation(halfword h, halfword t);
--- texlive-bin.orig/texk/web2c/luatexdir/lang/texlang.w
+++ texlive-bin/texk/web2c/luatexdir/lang/texlang.w
@@ -30,8 +30,6 @@
 
 #define MAX_TEX_LANGUAGES  16384
 
-#define ex_hyphen_char int_par(ex_hyphen_char_code)
-
 static struct tex_language *tex_languages[MAX_TEX_LANGUAGES] = { NULL };
 
 static int next_lang_id = 0;
@@ -61,7 +59,7 @@
         lang->pre_exhyphen_char = 0;
         lang->post_exhyphen_char = 0;
         lang->hyphenation_min = -1;
-        if (int_par(saving_hyph_codes_code)) {
+        if (saving_hyph_codes_par) {
             hj_codes_from_lc_codes(l); /* for now, we might just use specific value for whatever task */
         }
         return lang;
@@ -187,7 +185,7 @@
 @ @c
 #define STORE_CHAR(l,x) do { \
     unsigned xx = get_hj_code(l,x); \
-    if (!xx) { \
+    if (!xx || xx <= 32) { \
         xx = x; \
     } \
     uindex = uni2string(uindex, xx); \
@@ -212,7 +210,7 @@
         s++;
         if ((s-buff)>MAX_WORD_LEN) {
             /* todo: this is too strict, should count unicode, not bytes */
-    	    *cleaned = NULL;
+            *cleaned = NULL;
             tex_error("exception too long", NULL);
             return s;
         }
@@ -224,7 +222,7 @@
     /* build the new word string */
     i = 0;
     while (uword[i]>0) {
-	u = uword[i++];
+        u = uword[i++];
         if (u == '-') {        /* skip */
         } else if (u == '=') {
             STORE_CHAR(id,'-');
@@ -276,14 +274,13 @@
     const char *value;
     char *cleaned;
     int id ;
-    lua_State *L = Luas;
     if (lang == NULL)
         return;
     if (lang->exceptions == 0) {
-        lua_newtable(L);
-        lang->exceptions = luaL_ref(L, LUA_REGISTRYINDEX);
+        lua_newtable(Luas);
+        lang->exceptions = luaL_ref(Luas, LUA_REGISTRYINDEX);
     }
-    lua_rawgeti(L, LUA_REGISTRYINDEX, lang->exceptions);
+    lua_rawgeti(Luas, LUA_REGISTRYINDEX, lang->exceptions);
     s = (const char *) buff;
     id = lang->id;
     while (*s) {
@@ -294,9 +291,9 @@
             s = clean_hyphenation(id, s, &cleaned);
             if (cleaned != NULL) {
                 if ((s - value) > 0) {
-                    lua_pushstring(L, cleaned);
-                    lua_pushlstring(L, value, (size_t) (s - value));
-                    lua_rawset(L, -3);
+                    lua_pushstring(Luas, cleaned);
+                    lua_pushlstring(Luas, value, (size_t) (s - value));
+                    lua_rawset(Luas, -3);
                 }
                 free(cleaned);
             } else {
@@ -381,7 +378,7 @@
 {
     halfword g, n;
     n = new_node(disc_node, syllable_disc);
-    disc_penalty(n) = int_par(hyphen_penalty_code);
+    disc_penalty(n) = hyphen_penalty_par;
     couple_nodes(n, vlink(t));
     couple_nodes(t, n);
     delete_attribute_ref(node_attr(n));
@@ -427,7 +424,7 @@
         pre = insert_character(null, lan->pre_exhyphen_char);
     if (lan->post_exhyphen_char > 0)
         pos = insert_character(null, lan->post_exhyphen_char);
-    return insert_discretionary(t, pre, pos, null,int_par(ex_hyphen_penalty_code));
+    return insert_discretionary(t, pre, pos, null,ex_hyphen_penalty_par);
 }
 
 @ @c
@@ -446,7 +443,7 @@
                                       halfword replace)
 {
     (void) lan;
-    return insert_discretionary(t, pre, pos, replace,int_par(hyphen_penalty_code));
+    return insert_discretionary(t, pre, pos, replace,hyphen_penalty_par);
 }
 
 halfword insert_character(halfword t, int c)
@@ -465,7 +462,11 @@
 void set_disc_field(halfword f, halfword t)
 {
     if (t != null) {
-        couple_nodes(f, t);
+        /*
+            couple_nodes(f, t); // better not expose f as prev pointer
+        */
+        vlink(f) = t ;
+        alink(t) = null ;
         tlink(f) = tail_of_list(t);
     } else {
         vlink(f) = null;
@@ -477,18 +478,17 @@
 static char *hyphenation_exception(int exceptions, char *w)
 {
     char *ret = NULL;
-    lua_State *L = Luas;
-    lua_checkstack(L, 2);
-    lua_rawgeti(L, LUA_REGISTRYINDEX, exceptions);
-    if (lua_istable(L, -1)) {   /* ?? */
-        lua_pushstring(L, w);   /* word table */
-        lua_rawget(L, -2);
-        if (lua_type(L, -1) == LUA_TSTRING) {
-            ret = xstrdup(lua_tostring(L, -1));
+    lua_checkstack(Luas, 2);
+    lua_rawgeti(Luas, LUA_REGISTRYINDEX, exceptions);
+    if (lua_istable(Luas, -1)) {   /* ?? */
+        lua_pushstring(Luas, w);   /* word table */
+        lua_rawget(Luas, -2);
+        if (lua_type(Luas, -1) == LUA_TSTRING) {
+            ret = xstrdup(lua_tostring(Luas, -1));
         }
-        lua_pop(L, 2);
+        lua_pop(Luas, 2);
     } else {
-        lua_pop(L, 1);
+        lua_pop(Luas, 1);
     }
     return ret;
 }
@@ -500,16 +500,15 @@
     size_t size = 0, current = 0;
     size_t l = 0;
     char *ret = NULL;
-    lua_State *L = Luas;
     if (lang->exceptions == 0)
         return NULL;
-    lua_checkstack(L, 2);
-    lua_rawgeti(L, LUA_REGISTRYINDEX, lang->exceptions);
-    if (lua_istable(L, -1)) {
+    lua_checkstack(Luas, 2);
+    lua_rawgeti(Luas, LUA_REGISTRYINDEX, lang->exceptions);
+    if (lua_istable(Luas, -1)) {
         /* iterate and join */
-        lua_pushnil(L);         /* first key */
-        while (lua_next(L, -2) != 0) {
-            value = lua_tolstring(L, -1, &l);
+        lua_pushnil(Luas);         /* first key */
+        while (lua_next(Luas, -2) != 0) {
+            value = lua_tolstring(Luas, -1, &l);
             if (current + 2 + l > size) {
                 ret = xrealloc(ret, (unsigned) ((size + size / 5) + current + l + 1024));
                 size = (size + size / 5) + current + l + 1024;
@@ -517,7 +516,7 @@
             *(ret + current) = ' ';
             strcpy(ret + current + 1, value);
             current += l + 1;
-            lua_pop(L, 1);
+            lua_pop(Luas, 1);
         }
     }
     return ret;
@@ -629,7 +628,7 @@
                 try_couple_nodes(t, vlink(q));
                 vlink(q) = null;
             }
-            t = insert_discretionary(t, gg, hh, replace,int_par(hyphen_penalty_code));
+            t = insert_discretionary(t, gg, hh, replace, hyphen_penalty_par);
             t = vlink(t);       /* skip the new disc */
         } else {
             t = vlink(t);
@@ -699,7 +698,30 @@
 there was not the best idea ever.
 
 @c
-static halfword find_next_wordstart(halfword r, halfword first_language)
+/*
+    More strict: \hyphenationbounds
+
+    0 = not strict
+    1 = strict start
+    2 = strict end
+    3 = strict start and strict end
+
+    \parindent0pt \hsize=1.1cm
+    12-34-56 \par
+    12-34-\hbox{56} \par
+    12-34-\vrule width 1em height 1.5ex \par
+    12-\hbox{34}-56 \par
+    12-\vrule width 1em height 1.5ex-56 \par
+    \hjcode`\1=`\1 \hjcode`\2=`\2 \hjcode`\3=`\3 \hjcode`\4=`\4 \vskip.5cm
+    12-34-56 \par
+    12-34-\hbox{56} \par
+    12-34-\vrule width 1em height 1.5ex \par
+    12-\hbox{34}-56 \par
+    12-\vrule width 1em height 1.5ex-56 \par
+
+*/
+
+static halfword find_next_wordstart(halfword r, halfword first_language, halfword strict_bound)
 {
     register int l;
     register int start_ok = 1;
@@ -713,7 +735,14 @@
                 start_ok = 1;
             }
             break;
+        case hlist_node: /* new > 0.95 */
+        case vlist_node: /* new > 0.95 */
+        case rule_node:  /* new > 0.95 */
+        case dir_node:
         case whatsit_node:
+            if (strict_bound == 1 || strict_bound == 3) {
+                start_ok = 0;
+            }
             break;
         case glue_node:
             start_ok = 1;
@@ -735,7 +764,7 @@
         case glyph_node:
             if (is_simple_character(r)) {
                 chr = character(r) ;
-                if (chr == ex_hyphen_char) {
+                if (chr == ex_hyphen_char_par) {
                     /*
                         We only accept an explicit hyphen when there is a preceding glyph and
                         we skip a sequence of explicit hyphens as that normally indicates a
@@ -745,7 +774,7 @@
                         hyphenation, ligaturing and kerning steps. A test is cmr with ------.
                     */
                     t = vlink(r) ;
-                    if ((start_ok > 0) && (t!=null) && (type(t) == glyph_node) && (character(t) != ex_hyphen_char)) {
+                    if ((start_ok == 0) && (t!=null) && (type(t) == glyph_node) && (character(t) != ex_hyphen_char_par)) {
                         t = compound_word_break(r, char_lang(r));
                         subtype(t) = automatic_disc;
                         start_ok = 1 ;
@@ -753,7 +782,7 @@
                         start_ok = 0;
                     }
                 } else if (start_ok && (char_lang(r)>=first_language) && ((l = get_hj_code(char_lang(r),chr)) > 0)) {
-                    if (char_uchyph(r) || l == chr) {
+                    if (char_uchyph(r) || l == chr || l <= 32) {
                         return r;
                     } else {
                         start_ok = 0;
@@ -771,27 +800,35 @@
 }
 
 @ @c
-static int valid_wordend(halfword s)
+static int valid_wordend(halfword s, halfword strict_bound)
 {
     register halfword r = s;
     register int clang = char_lang(s);
     if (r == null)
         return 1;
-    while ((r != null) && (   (type(r) == glyph_node && is_simple_character(r) && clang == char_lang(r))
-                           || (type(r) == kern_node && (subtype(r) == normal))
-           )) {
+    while ( (r != null) &&
+           (    (type(r) == glyph_node && is_simple_character(r) && clang == char_lang(r))
+             || (type(r) == kern_node && (subtype(r) == normal))
+            )
+           ) {
         r = vlink(r);
     }
     if (r == null || (type(r) == glyph_node && is_simple_character(r) && clang != char_lang(r))
                   ||  type(r) == glue_node
-                  ||  type(r) == boundary_node
-                  ||  type(r) == whatsit_node
-                  ||  type(r) == ins_node
-                  ||  type(r) == adjust_node
                   ||  type(r) == penalty_node
-                  || (type(r) == kern_node && (subtype(r) == explicit_kern ||
+                  || (type(r) == kern_node && (subtype(r) == explicit_kern || /* so why not italic correction ? */
                                                subtype(r) == italic_kern   ||
-                                               subtype(r) == accent_kern   )))
+                                               subtype(r) == accent_kern   ))
+                  ||  ((type(r) == hlist_node   || /* new > 0.95 */
+                        type(r) == vlist_node   || /* new > 0.95 */
+                        type(r) == rule_node    || /* new > 0.95 */
+                        type(r) == dir_node     || /* new > 0.97 */
+                        type(r) == whatsit_node ||
+                        type(r) == ins_node     || /* yes or no strict test */
+                        type(r) == adjust_node     /* yes or no strict test */
+                       ) && ! (strict_bound == 2 || strict_bound == 3))
+                  ||  type(r) == boundary_node
+        )
         return 1;
     return 0;
 }
@@ -807,7 +844,8 @@
     char *hy = utf8word;
     char *replacement = NULL;
     boolean explicit_hyphen = false;
-    halfword first_language = int_par(first_valid_language_code);
+    halfword first_language = first_valid_language_par;
+    halfword strict_bound = hyphenation_bounds_par;
     halfword s, r = head, wordstart = null, save_tail1 = null, left = null, right = null;
 
     /* this first movement assures two things:
@@ -822,7 +860,7 @@
         r = vlink(r);
     }
     /* this will make |r| a glyph node with subtype character */
-    r = find_next_wordstart(r,first_language);
+    r = find_next_wordstart(r,first_language,strict_bound);
     if (r == null)
         return;
 
@@ -853,21 +891,41 @@
                 && (    (     (clang >= first_language)
                            && (lchar = get_hj_code(clang,character(r))) > 0
                         )
-                     || (     character(r) == ex_hyphen_char
-                           && (lchar = ex_hyphen_char)
+                     || (     character(r) == ex_hyphen_char_par
+                           && (lchar = ex_hyphen_char_par)
                         )
                    )
               ) {
-            if (character(r) == ex_hyphen_char)
-    	        explicit_hyphen = true;
+            if (character(r) == ex_hyphen_char_par) {
+                explicit_hyphen = true;
+            }
             wordlen++;
+            if (lchar <= 32) {
+                if (lchar == 32) {
+                    lchar = 0 ;
+                }
+                if (wordlen <= lhmin) {
+                    lhmin = lhmin - lchar + 1 ;
+                    if (lhmin < 0)
+                        lhmin = 1;
+                }
+                if (wordlen >= rhmin) {
+                    rhmin = rhmin - lchar + 1 ;
+                    if (rhmin < 0)
+                        rhmin = 1;
+                }
+                hmin = hmin - lchar + 1 ;
+                if (hmin < 0)
+                    rhmin = 1;
+                lchar = character(r) ;
+            }
             hy = uni2string(hy, (unsigned) lchar);
             /* this should not be needed  any more */
             /*if (vlink(r)!=null) alink(vlink(r))=r; */
             end_word = r;
             r = vlink(r);
         }
-        if (     valid_wordend(r)
+        if (     valid_wordend(r,strict_bound)
               && clang >= first_language
               && wordlen >= lhmin + rhmin
               && (hmin <= 0 || wordlen >= hmin)
@@ -884,19 +942,21 @@
                 do_exception(wordstart, r, replacement);
                 free(replacement);
             } else if (explicit_hyphen == true) {
-                /* insert an explicit discretionary after each of the last in a
-	           set of explicit hyphens */
+                /*
+                    insert an explicit discretionary after each of the last in a
+                    set of explicit hyphens
+                */
                 halfword rr = r;
                 halfword t = null;
 #ifdef VERBOSE
                 formatted_warning("hyphenation","explicit hyphen(s) found in %s (c=%d)", utf8word, clang);
 #endif
                 while (rr != wordstart) {
-	            if (is_simple_character(rr)) {
-                        if (character(rr) == ex_hyphen_char) {
+                if (is_simple_character(rr)) {
+                        if (character(rr) == ex_hyphen_char_par) {
                             t = compound_word_break(rr, clang);
                             subtype(t) = automatic_disc;
-                            while (character(alink(rr)) == ex_hyphen_char)
+                            while (character(alink(rr)) == ex_hyphen_char_par)
                                 rr = alink(rr);
                             if (rr == wordstart)
                                 break;
@@ -908,28 +968,43 @@
                 left = wordstart;
                 for (i = lhmin; i > 1; i--) {
                     left = vlink(left);
-                    while (!is_simple_character(left))
+                    while (!is_simple_character(left)) {
                         left = vlink(left);
+                    }
+                    /*
+                    if (!left)
+                        break ;
+                    */
+                    /* what is left overruns right .. a bit messy */
                 }
                 right = r;
                 for (i = rhmin; i > 0; i--) {
                     right = alink(right);
-                    while (!is_simple_character(right))
+                    while (!is_simple_character(right)) {
                         right = alink(right);
+                    }
+                    /*
+                    if (!right)
+                        break ;
+                    */
+                    /* what is right overruns left .. a bit messy */
                 }
+                /* maybe an extra check ... */
+                /* if (left && right) { */
 #ifdef VERBOSE
-                formatted_warning("hyphenation","hyphenate %s (c=%d,l=%d,r=%d) from %c to %c",
-                    utf8word, clang, lhmin, rhmin, character(left), character(right));
+                    formatted_warning("hyphenation","hyphenate %s (c=%d,l=%d,r=%d) from %c to %c",
+                        utf8word, clang, lhmin, rhmin, character(left), character(right));
 #endif
-                (void) hnj_hyphen_hyphenate(lang->patterns, wordstart, end_word, wordlen, left, right, &langdata);
+                    (void) hnj_hyphen_hyphenate(lang->patterns, wordstart, end_word, wordlen, left, right, &langdata);
+                /* } */
             }
         }
-	explicit_hyphen = false;
+        explicit_hyphen = false;
         wordlen = 0;
         hy = utf8word;
         if (r == null)
             break;
-        r = find_next_wordstart(r,first_language);
+        r = find_next_wordstart(r,first_language,strict_bound);
     }
     flush_node(vlink(tail));
     vlink(tail) = save_tail1;
@@ -944,20 +1019,19 @@
     fix_node_list(head);
     callback_id = callback_defined(hyphenate_callback);
     if (callback_id > 0) {
-        lua_State *L = Luas;
-        if (!get_callback(L, callback_id)) {
-            lua_pop(L, 2);
+        if (!get_callback(Luas, callback_id)) {
+            lua_pop(Luas, 2);
             return;
         }
-        nodelist_to_lua(L, head);
-        nodelist_to_lua(L, tail);
-        if (lua_pcall(L, 2, 0, 0) != 0) {
-            formatted_warning("hyphenation","bad specification: %s",lua_tostring(L, -1));
-            lua_pop(L, 2);
-            lua_error(L);
+        nodelist_to_lua(Luas, head);
+        nodelist_to_lua(Luas, tail);
+        if (lua_pcall(Luas, 2, 0, 0) != 0) {
+            formatted_warning("hyphenation","bad specification: %s",lua_tostring(Luas, -1));
+            lua_pop(Luas, 2);
+            lua_error(Luas);
             return;
         }
-        lua_pop(L, 1);
+        lua_pop(Luas, 1);
     } else if (callback_id == 0) {
         hnj_hyphenation(head, tail);
     }
@@ -1072,7 +1146,7 @@
 void new_hyph_exceptions(void)
 {                               /* enters new exceptions */
     (void) scan_toks(false, true);
-    load_tex_hyphenation(int_par(language_code), def_ref);
+    load_tex_hyphenation(language_par, def_ref);
     flush_list(def_ref);
 }
 
@@ -1083,7 +1157,7 @@
 void new_patterns(void)
 {                               /* initializes the hyphenation pattern data */
     (void) scan_toks(false, true);
-    load_tex_patterns(int_par(language_code), def_ref);
+    load_tex_patterns(language_par, def_ref);
     flush_list(def_ref);
 }
 
@@ -1096,14 +1170,14 @@
 {
     scan_optional_equals();
     scan_int();
-    set_pre_hyphen_char(int_par(language_code), cur_val);
+    set_pre_hyphen_char(language_par, cur_val);
 }
 
 void new_post_hyphen_char(void)
 {
     scan_optional_equals();
     scan_int();
-    set_post_hyphen_char(int_par(language_code), cur_val);
+    set_post_hyphen_char(language_par, cur_val);
 }
 
 @ `\.{\\preexhyphenchar}', sets the |pre_break| character, and
@@ -1115,21 +1189,21 @@
 {
     scan_optional_equals();
     scan_int();
-    set_pre_exhyphen_char(int_par(language_code), cur_val);
+    set_pre_exhyphen_char(language_par, cur_val);
 }
 
 void new_post_exhyphen_char(void)
 {
     scan_optional_equals();
     scan_int();
-    set_post_exhyphen_char(int_par(language_code), cur_val);
+    set_post_exhyphen_char(language_par, cur_val);
 }
 
 void new_hyphenation_min(void)
 {
     scan_optional_equals();
     scan_int();
-    set_hyphenation_min(int_par(language_code), cur_val);
+    set_hyphenation_min(language_par, cur_val);
 }
 
 void new_hj_code(void)
@@ -1139,5 +1213,5 @@
     i = cur_val;
     scan_optional_equals();
     scan_int();
-    set_hj_code(int_par(language_code), i, cur_val, -1);
+    set_hj_code(language_par, i, cur_val, -1);
 }
--- texlive-bin.orig/texk/web2c/luatexdir/lua/lcallbacklib.c
+++ texlive-bin/texk/web2c/luatexdir/lua/lcallbacklib.c
@@ -72,6 +72,7 @@
     "process_rule",
     "insert_local_par",
     "contribute_filter",
+    "call_edit",
     NULL
 };
 
@@ -129,7 +130,7 @@
     if (lua_istable(Luas, -1)) {
         lua_getfield(Luas, -1, name);
         if (lua_type(Luas, -1) == LUA_TNUMBER) {
-            *target = (int) lua_tointeger(Luas, -1);
+            *target = (int) lua_roundnumber(Luas, -1); /* was lua_tointeger */
         }
     }
     lua_settop(Luas, stacktop);
@@ -196,20 +197,19 @@
 {
     va_list args;
     int ret = 0;
-    lua_State *L = Luas;
-    int stacktop = lua_gettop(L);
+    int stacktop = lua_gettop(Luas);
     va_start(args, values);
-    luaL_checkstack(L, 2, "out of stack space");
-    lua_rawgeti(L, LUA_REGISTRYINDEX, r);
-    lua_pushstring(L, name);
-    lua_rawget(L, -2);
-    if (lua_isfunction(L, -1)) {
+    luaL_checkstack(Luas, 2, "out of stack space");
+    lua_rawgeti(Luas, LUA_REGISTRYINDEX, r);
+    lua_pushstring(Luas, name);
+    lua_rawget(Luas, -2);
+    if (lua_isfunction(Luas, -1)) {
         saved_callback_count++;
         callback_count++;
         ret = do_run_callback(2, values, args);
     }
     va_end(args);
-    lua_settop(L, stacktop);
+    lua_settop(Luas, stacktop);
     return ret;
 }
 
@@ -230,17 +230,16 @@
 {
     va_list args;
     int ret = 0;
-    lua_State *L = Luas;
-    int stacktop = lua_gettop(L);
+    int stacktop = lua_gettop(Luas);
     va_start(args, values);
-    if (get_callback(L, i)) {
+    if (get_callback(Luas, i)) {
         ret = do_run_callback(1, values, args);
     }
     va_end(args);
     if (ret > 0) {
-        ret = luaL_ref(L, LUA_REGISTRYINDEX);
+        ret = luaL_ref(Luas, LUA_REGISTRYINDEX);
     }
-    lua_settop(L, stacktop);
+    lua_settop(Luas, stacktop);
     return ret;
 }
 
@@ -248,14 +247,13 @@
 {
     va_list args;
     int ret = 0;
-    lua_State *L = Luas;
-    int stacktop = lua_gettop(L);
+    int stacktop = lua_gettop(Luas);
     va_start(args, values);
-    if (get_callback(L, i)) {
+    if (get_callback(Luas, i)) {
         ret = do_run_callback(0, values, args);
     }
     va_end(args);
-    lua_settop(L, stacktop);
+    lua_settop(Luas, stacktop);
     return ret;
 }
 
@@ -270,46 +268,45 @@
     int *bufloc;
     char *ss = NULL;
     int retval = 0;
-    lua_State *L = Luas;
     if (special == 2) {         /* copy the enclosing table */
-        luaL_checkstack(L, 1, "out of stack space");
-        lua_pushvalue(L, -2);
+        luaL_checkstack(Luas, 1, "out of stack space");
+        lua_pushvalue(Luas, -2);
     }
     ss = strchr(values, '>');
-    luaL_checkstack(L, (int) (ss - values + 1), "out of stack space");
+    luaL_checkstack(Luas, (int) (ss - values + 1), "out of stack space");
     ss = NULL;
     for (narg = 0; *values; narg++) {
         switch (*values++) {
             case CALLBACK_CHARNUM: /* an ascii char! */
                 cs = (char) va_arg(vl, int);
-                lua_pushlstring(L, &cs, 1);
+                lua_pushlstring(Luas, &cs, 1);
                 break;
             case CALLBACK_STRING:  /* C string */
                 s = va_arg(vl, char *);
-                lua_pushstring(L, s);
+                lua_pushstring(Luas, s);
                 break;
             case CALLBACK_LSTRING:  /* 'lstring' */
                 lstr = va_arg(vl, lstring *);
-                lua_pushlstring(L, (const char *)lstr->s, lstr->l);
+                lua_pushlstring(Luas, (const char *)lstr->s, lstr->l);
                 break;
             case CALLBACK_INTEGER: /* int */
-                lua_pushinteger(L, va_arg(vl, int));
+                lua_pushinteger(Luas, va_arg(vl, int));
                 break;
             case CALLBACK_STRNUMBER:       /* TeX string */
                 s = makeclstring(va_arg(vl, int), &len);
-                lua_pushlstring(L, s, len);
+                lua_pushlstring(Luas, s, len);
                 break;
             case CALLBACK_BOOLEAN: /* boolean */
-                lua_pushboolean(L, va_arg(vl, int));
+                lua_pushboolean(Luas, va_arg(vl, int));
                 break;
             case CALLBACK_LINE:    /* a buffer section, with implied start */
-                lua_pushlstring(L, (char *) (buffer + first), (size_t) va_arg(vl, int));
+                lua_pushlstring(Luas, (char *) (buffer + first), (size_t) va_arg(vl, int));
                 break;
             case CALLBACK_NODE:
-                lua_nodelib_push_fast(L,va_arg(vl, int));
+                lua_nodelib_push_fast(Luas, va_arg(vl, int));
                 break;
             case CALLBACK_DIR:
-                lua_push_dir_par(L,va_arg(vl, int));
+                lua_push_dir_par(Luas, va_arg(vl, int));
                 break;
             case '-':
                 narg--;
@@ -331,7 +328,7 @@
     {
         int i;
         lua_active++;
-        i = lua_pcall(L, narg, nres, 0);
+        i = lua_pcall(Luas, narg, nres, 0);
         lua_active--;
         /* lua_remove(L, base); *//* remove traceback function */
         if (i != 0) {
@@ -339,11 +336,11 @@
              * TeX initialization is complete
              */
             if (!log_opened_global) {
-                fprintf(stderr, "error in callback: %s\n", lua_tostring(L, -1));
+                fprintf(stderr, "error in callback: %s\n", lua_tostring(Luas, -1));
                 error();
             } else {
-                lua_gc(L, LUA_GCCOLLECT, 0);
-                luatex_error(L, (i == LUA_ERRRUN ? 0 : 1));
+                lua_gc(Luas, LUA_GCCOLLECT, 0);
+                luatex_error(Luas, (i == LUA_ERRRUN ? 0 : 1));
             }
             return 0;
         }
@@ -355,25 +352,25 @@
     while (*values) {
         int b, t;
         halfword p;
-        t = lua_type(L, nres);
+        t = lua_type(Luas, nres);
         switch (*values++) {
             case CALLBACK_BOOLEAN:
                 if (t == LUA_TNIL) {
                     b = 0;
                 } else if (t != LUA_TBOOLEAN) {
-                    fprintf(stderr, "callback should return a boolean, not: %s\n", lua_typename(L, t));
+                    fprintf(stderr, "callback should return a boolean, not: %s\n", lua_typename(Luas, t));
                     goto EXIT;
                 } else {
-                    b = lua_toboolean(L, nres);
+                    b = lua_toboolean(Luas, nres);
                 }
                 *va_arg(vl, boolean *) = (boolean) b;
                 break;
             case CALLBACK_INTEGER:
                 if (t != LUA_TNUMBER) {
-                    fprintf(stderr, "callback should return a number, not: %s\n", lua_typename(L, t));
+                    fprintf(stderr, "callback should return a number, not: %s\n", lua_typename(Luas, t));
                     goto EXIT;
                 }
-                b = lua_tointeger(L, nres);
+                b = lua_tointeger(Luas, nres);
                 *va_arg(vl, int *) = b;
                 break;
             case CALLBACK_LINE:    /* TeX line ... happens frequently when we have a plug-in */
@@ -381,7 +378,7 @@
                     bufloc = 0;
                     goto EXIT;
                 } else if (t == LUA_TSTRING) {
-                    s = lua_tolstring(L, nres, &len);
+                    s = lua_tolstring(Luas, nres, &len);
                     if (s == NULL) {    /* |len| can be zero */
                         bufloc = 0;
                     } else if (len == 0) {
@@ -397,16 +394,16 @@
                             (*bufloc)--;
                     }
                 } else {
-                    fprintf(stderr, "callback should return a string, not: %s\n", lua_typename(L, t));
+                    fprintf(stderr, "callback should return a string, not: %s\n", lua_typename(Luas, t));
                     goto EXIT;
                 }
                 break;
             case CALLBACK_STRNUMBER:       /* TeX string */
                 if (t != LUA_TSTRING) {
-                    fprintf(stderr, "callback should return a string, not: %s\n", lua_typename(L, t));
+                    fprintf(stderr, "callback should return a string, not: %s\n", lua_typename(Luas, t));
                     goto EXIT;
                 }
-                s = lua_tolstring(L, nres, &len);
+                s = lua_tolstring(Luas, nres, &len);
                 if (s == NULL)      /* |len| can be zero */
                     *va_arg(vl, int *) = 0;
                 else {
@@ -415,10 +412,10 @@
                 break;
             case CALLBACK_STRING:  /* C string aka buffer */
                 if (t != LUA_TSTRING) {
-                    fprintf(stderr, "callback should return a string, not: %s\n", lua_typename(L, t));
+                    fprintf(stderr, "callback should return a string, not: %s\n", lua_typename(Luas, t));
                     goto EXIT;
                 }
-                s = lua_tolstring(L, nres, &len);
+                s = lua_tolstring(Luas, nres, &len);
                 if (s == NULL)      /* |len| can be zero */
                     *va_arg(vl, int *) = 0;
                 else {
@@ -431,18 +428,18 @@
                 if (t == LUA_TNIL) {
                     *va_arg(vl, int *) = 0;
                 } else if (t == LUA_TBOOLEAN) {
-                    b = lua_toboolean(L, nres);
+                    b = lua_toboolean(Luas, nres);
                     if (b == 0) {
                         *va_arg(vl, int *) = 0;
                     } else {
-                        fprintf(stderr, "callback should return a string, false or nil, not: %s\n", lua_typename(L, t));
+                        fprintf(stderr, "callback should return a string, false or nil, not: %s\n", lua_typename(Luas, t));
                         goto EXIT;
                     }
                 } else if (t != LUA_TSTRING) {
-                    fprintf(stderr, "callback should return a string, false or nil, not: %s\n", lua_typename(L, t));
+                    fprintf(stderr, "callback should return a string, false or nil, not: %s\n", lua_typename(Luas, t));
                     goto EXIT;
                 } else {
-                    s = lua_tolstring(L, nres, &len);
+                    s = lua_tolstring(Luas, nres, &len);
                     if (s == NULL)      /* |len| can be zero */
                         *va_arg(vl, int *) = 0;
                     else {
@@ -454,10 +451,10 @@
                 break;
             case CALLBACK_LSTRING:  /* lstring */
                 if (t != LUA_TSTRING) {
-                    fprintf(stderr, "callback should return a string, not: %s\n", lua_typename(L, t));
+                    fprintf(stderr, "callback should return a string, not: %s\n", lua_typename(Luas, t));
                     goto EXIT;
                 }
-                s = lua_tolstring(L, nres, &len);
+                s = lua_tolstring(Luas, nres, &len);
                 if (s == NULL)      /* |len| can be zero */
                     *va_arg(vl, int *) = 0;
                 else {
@@ -472,7 +469,7 @@
                 if (t == LUA_TNIL) {
                     p = null;
                 } else {
-                    p = *check_isnode(L,nres);
+                    p = *check_isnode(Luas,nres);
                 }
                 *va_arg(vl, int *) = p;
                 break;
--- texlive-bin.orig/texk/web2c/luatexdir/lua/lfontlib.c
+++ texlive-bin/texk/web2c/luatexdir/lua/lfontlib.c
@@ -40,7 +40,7 @@
     if (lua_type(L, 1) == LUA_TSTRING) {
         const char *cnom = lua_tostring(L, 1);
         if (lua_type(L, 2) == LUA_TNUMBER) {
-            scaled s = (int) lua_tointeger(L, 2);
+            scaled s = (int) lua_roundnumber(L, 2);
             if (strlen(cnom)) {
                 internal_font_number f = get_fontid();
                 if (read_tfm_info(f, cnom, s)) {
@@ -70,7 +70,7 @@
         const char *cnom = lua_tostring(L, 1);
         if (strlen(cnom)) {
             if (lua_type(L, 2) == LUA_TNUMBER) {
-                int i = lua_tointeger(L, 2);
+                int i = lua_roundnumber(L, 2);
                 return make_vf_table(L, cnom, (scaled) i);
             } else {
                 luaL_error(L, "expected an integer size as second argument");
--- texlive-bin.orig/texk/web2c/luatexdir/lua/limglib.c
+++ texlive-bin/texk/web2c/luatexdir/lua/limglib.c
@@ -298,17 +298,16 @@
 {
     image *a, **aa;
     image_dict *ad;
-    lua_State *L = Luas;
-    lua_rawgeti(L, LUA_REGISTRYINDEX, (int) i);
-    aa = (image **) luaL_checkudata(L, -1, TYPE_IMG);
+    lua_rawgeti(Luas, LUA_REGISTRYINDEX, (int) i);
+    aa = (image **) luaL_checkudata(Luas, -1, TYPE_IMG);
     a = *aa;
     ad = img_dict(a);
     if (ad == NULL) {
-        luaL_error(L, "invalid image dictionary");
+        luaL_error(Luas, "invalid image dictionary");
     }
     setup_image(pdf, a, WR_VF_IMG);
     place_img(pdf, ad, img_dimen(a), img_transform(a));
-    lua_pop(L, 1);
+    lua_pop(Luas, 1);
 }
 
 /* metamethods for image */
@@ -483,7 +482,7 @@
         if (t == LUA_TNIL) {
             set_wd_running(a);
         } else if (t == LUA_TNUMBER) {
-            img_width(a) = (int) lua_tointeger(L, -1);
+            img_width(a) = (int) lua_roundnumber(L, -1);
         } else if (t == LUA_TSTRING) {
             img_width(a) = dimen_to_number(L, lua_tostring(L, -1));
         } else {
@@ -493,7 +492,7 @@
         if (t == LUA_TNIL) {
             set_ht_running(a);
         } else if (t == LUA_TNUMBER) {
-            img_height(a) = (int) lua_tointeger(L, -1);
+            img_height(a) = (int) lua_roundnumber(L, -1);
         } else if (t == LUA_TSTRING) {
             img_height(a) = dimen_to_number(L, lua_tostring(L, -1));
         } else {
@@ -503,7 +502,7 @@
         if (t == LUA_TNIL) {
             set_dp_running(a);
         } else if (t == LUA_TNUMBER) {
-            img_depth(a) = (int) lua_tointeger(L, -1);
+            img_depth(a) = (int) lua_roundnumber(L, -1);
         } else if (t == LUA_TSTRING) {
             img_depth(a) = dimen_to_number(L, lua_tostring(L, -1));
         } else {
@@ -619,7 +618,7 @@
                 lua_gettable(L, -2);        /* int v k t ... */
                 t = lua_type(L, -1);
                 if (t == LUA_TNUMBER) {
-                    img_bbox(d)[i - 1] = (int) lua_tointeger(L, -1);
+                    img_bbox(d)[i - 1] = (int) lua_roundnumber(L, -1);
                 } else if (t == LUA_TSTRING) {
                     img_bbox(d)[i - 1] = dimen_to_number(L, lua_tostring(L, -1));
                 } else {
--- texlive-bin.orig/texk/web2c/luatexdir/lua/llanglib.c
+++ texlive-bin/texk/web2c/luatexdir/lua/llanglib.c
@@ -227,7 +227,7 @@
 {
     char *cleaned;
     if (lua_type(L, 1) == LUA_TSTRING) {
-        (void) clean_hyphenation(int_par(cur_lang_code), lua_tostring(L, 1), &cleaned);
+        (void) clean_hyphenation(cur_lang_par, lua_tostring(L, 1), &cleaned);
     } else {
         struct tex_language **lang_ptr;
         lang_ptr = check_islang(L, 1);
--- texlive-bin.orig/texk/web2c/luatexdir/lua/lnewtokenlib.c
+++ texlive-bin/texk/web2c/luatexdir/lua/lnewtokenlib.c
@@ -63,7 +63,7 @@
 
 static lua_token *check_istoken(lua_State * L, int ud);
 
-#define TOKEN_METATABLE  "luatex_token"
+#define TOKEN_METATABLE  "luatex.token"
 
 #define DEBUG 0
 #define DEBUG_OUT stdout
@@ -534,7 +534,7 @@
     if (lua_type(L, 1) == LUA_TNUMBER) {
         int cs = 0;
         int chr = (int) lua_tointeger(L, 1);
-        int cmd = (int) luaL_optinteger(L, 2, get_cat_code(int_par(cat_code_table_code),chr));
+        int cmd = (int) luaL_optinteger(L, 2, get_cat_code(cat_code_table_par,chr));
         if (cmd == 0 || cmd == 9 || cmd == 14 || cmd == 15) {
             formatted_warning("token lib","not a good token, catcode %i can not be returned, so 12 will be used",(int) cmd);
             cmd = 12;
@@ -821,7 +821,7 @@
         if (n > 3)
             s = lua_tostring(L, 4);
     } else {
-        ct = int_par(cat_code_table_code) ;
+        ct = cat_code_table_par;
         name = lua_tolstring(L, 1, &lname);
         if (n > 1)
             str = lua_tolstring(L, 2, &lstr);
--- texlive-bin.orig/texk/web2c/luatexdir/lua/lnodelib.c
+++ texlive-bin/texk/web2c/luatexdir/lua/lnodelib.c
@@ -170,7 +170,6 @@
     t = vlink(t);                        \
 }
 
-#define box(A) eqtb[box_base+(A)].hh.rh
 #define direct_check_index_range(j,s)                                      \
     if (j<0 || j > 65535) {                                                \
         luaL_error(L, "incorrect index value %d for tex.%s()", (int)j, s); \
@@ -1478,7 +1477,7 @@
     int d = -1;
     halfword n = *(check_isnode(L, 1));
     if (lua_gettop(L) > 1) {
-        w = (int) lua_tointeger(L, 2);
+        w = lua_roundnumber(L, 2);
         if (lua_gettop(L) > 2) {
             if (lua_type(L, 3) == LUA_TSTRING) {
                 s = lua_tostring(L, 3);
@@ -1524,7 +1523,7 @@
     halfword n = lua_tointeger(L,1);
     /* could be macro */
     if (lua_gettop(L) > 1) {
-        w = (int) lua_tointeger(L, 2);
+        w = lua_roundnumber(L, 2);
         if (lua_gettop(L) > 2) {
             if (lua_type(L, 3) == LUA_TSTRING) {
                 s = lua_tostring(L, 3);
@@ -1571,7 +1570,7 @@
     int d = -1;
     halfword n = *(check_isnode(L, 1));
     if (lua_gettop(L) > 1) {
-        w = (int) lua_tointeger(L, 2);
+        w = lua_roundnumber(L, 2);
         if (lua_gettop(L) > 2) {
             if (lua_type(L, 3) == LUA_TSTRING) {
                 s = lua_tostring(L, 3);
@@ -1616,7 +1615,7 @@
     int d = -1;
     halfword n = (halfword) lua_tointeger(L,1);
     if (lua_gettop(L) > 1) {
-        w = (int) lua_tointeger(L, 2);
+        w = lua_roundnumber(L, 2);
         if (lua_gettop(L) > 2) {
             if (lua_type(L, 3) == LUA_TSTRING) {
                 s = lua_tostring(L, 3);
@@ -1695,6 +1694,28 @@
     return 0;                   /* not reached */
 }
 
+static int lua_nodelib_rangedimensions(lua_State * L) /* parent, first, last */
+{
+    int top = lua_gettop(L);
+    if (top > 1) {
+        scaled_whd siz;
+        halfword l = *(check_isnode(L, 1)); /* parent */
+        halfword n = *(check_isnode(L, 2)); /* first */
+        halfword p = null;
+        if (top > 2) {
+            p = *(check_isnode(L, 3)); /* last */
+        }
+        siz = natural_sizes(n, p, (glue_ratio) glue_set(l), glue_sign(l), glue_order(l), box_dir(l));
+        lua_pushinteger(L, siz.wd);
+        lua_pushinteger(L, siz.ht);
+        lua_pushinteger(L, siz.dp);
+        return 3;
+    } else {
+        luaL_error(L, "missing argument to 'rangedimensions' (2 or more nodes expected)");
+    }
+    return 0;                   /* not reached */
+}
+
 /* node.direct.dimensions*/
 
 static int lua_nodelib_direct_dimensions(lua_State * L)
@@ -1730,7 +1751,29 @@
         lua_pushinteger(L, siz.dp);
         return 3;
     } else {
-        luaL_error(L, "missing argument to 'dimensions' (node expected)");
+        luaL_error(L, "missing argument to 'dimensions' (direct node expected)");
+    }
+    return 0;                   /* not reached */
+}
+
+static int lua_nodelib_direct_rangedimensions(lua_State * L) /* parent, first, last */
+{
+    int top = lua_gettop(L);
+    if (top > 1) {
+        scaled_whd siz;
+        halfword l = (halfword) lua_tointeger(L,1); /* parent */
+        halfword n = (halfword) lua_tointeger(L,2); /* first */
+        halfword p = null;
+        if (top > 2) {
+            p = (halfword) lua_tointeger(L,3); /* last */
+        }
+        siz = natural_sizes(n, p, (glue_ratio) glue_set(l), glue_sign(l), glue_order(l), box_dir(l));
+        lua_pushinteger(L, siz.wd);
+        lua_pushinteger(L, siz.ht);
+        lua_pushinteger(L, siz.dp);
+        return 3;
+    } else {
+        luaL_error(L, "missing argument to 'rangedimensions' (2 or more direct nodes expected)");
     }
     return 0;                   /* not reached */
 }
@@ -2180,8 +2223,7 @@
 
 static int lua_nodelib_get_attribute(lua_State * L)
 {
-    halfword p;
-    p = *check_isnode(L, 1);
+    halfword p = *check_isnode(L, 1);
     if (nodetype_has_attributes(type(p))) {
         p = node_attr(p);
         if (p != null) {
@@ -2209,6 +2251,43 @@
     return 1;
 }
 
+static int lua_nodelib_find_attribute(lua_State * L) /* returns attr value and node */
+{
+    halfword c = *check_isnode(L, 1);
+    halfword p ;
+    int i = lua_tointeger(L, 2);
+    while (c != null) {
+        if (nodetype_has_attributes(type(c))) {
+            p = node_attr(c);
+            if (p != null) {
+                p = vlink(p);
+                while (p != null) {
+                    if (attribute_id(p) == i) {
+                        int ret = attribute_value(p);
+                        if (ret == UNUSED_ATTRIBUTE) {
+                            break;
+                        } else {
+                            lua_pushinteger(L,ret);
+                            lua_nodelib_push_fast(L, p);
+                            return 2;
+                        }
+                    } else if (attribute_id(p) > i) {
+                        break;
+                    }
+                    p = vlink(p);
+                }
+            }
+        }
+        c = vlink(c);
+    }
+    /*
+        lua_pushnil(L);
+        lua_pushnil(L);
+        return 2;
+    */
+    return 0;
+}
+
 /* node.direct.get_attribute */
 
 static int lua_nodelib_direct_get_attribute(lua_State * L)
@@ -2241,6 +2320,43 @@
     return 1;
 }
 
+static int lua_nodelib_direct_find_attribute(lua_State * L) /* returns attr value and node */
+{
+    halfword c = lua_tointeger(L, 1);
+    halfword p ;
+    int i = lua_tointeger(L, 2);
+    while (c != null) {
+        if (nodetype_has_attributes(type(c))) {
+            p = node_attr(c);
+            if (p != null) {
+                p = vlink(p);
+                while (p != null) {
+                    if (attribute_id(p) == i) {
+                        int ret = attribute_value(p);
+                        if (ret == UNUSED_ATTRIBUTE) {
+                            break;
+                        } else {
+                            lua_pushinteger(L,ret);
+                            lua_pushinteger(L,p);
+                            return 2;
+                        }
+                    } else if (attribute_id(p) > i) {
+                        break;
+                    }
+                    p = vlink(p);
+                }
+            }
+        }
+        c = vlink(c);
+    }
+    /*
+        lua_pushnil(L);
+        lua_pushnil(L);
+        return 2;
+    */
+    return 0;
+}
+
 /* node.set_attribute */
 
 static int lua_nodelib_set_attribute(lua_State * L)
@@ -2331,9 +2447,9 @@
     halfword n = *check_isnode(L, 1);
     int top = lua_gettop(L) ;
     if ((n != null) && (type(n) == glue_node || type(n) == glue_spec_node)) {
-        width(n)         = ((top > 1 && lua_type(L, 2) == LUA_TNUMBER)) ? lua_tointeger(L,2) : 0;
-        stretch(n)       = ((top > 2 && lua_type(L, 3) == LUA_TNUMBER)) ? lua_tointeger(L,3) : 0;
-        shrink(n)        = ((top > 3 && lua_type(L, 4) == LUA_TNUMBER)) ? lua_tointeger(L,4) : 0;
+        width(n)         = ((top > 1 && lua_type(L, 2) == LUA_TNUMBER)) ? lua_roundnumber(L,2) : 0;
+        stretch(n)       = ((top > 2 && lua_type(L, 3) == LUA_TNUMBER)) ? lua_roundnumber(L,3) : 0;
+        shrink(n)        = ((top > 3 && lua_type(L, 4) == LUA_TNUMBER)) ? lua_roundnumber(L,4) : 0;
         stretch_order(n) = ((top > 4 && lua_type(L, 5) == LUA_TNUMBER)) ? lua_tointeger(L,5) : 0;
         shrink_order(n)  = ((top > 5 && lua_type(L, 6) == LUA_TNUMBER)) ? lua_tointeger(L,6) : 0;
         return 0;
@@ -2347,9 +2463,9 @@
     halfword n = lua_tointeger(L, 1);
     int top = lua_gettop(L) ;
     if ((n != null) && (type(n) == glue_node || type(n) == glue_spec_node)) {
-        width(n)         = ((top > 1 && lua_type(L, 2) == LUA_TNUMBER)) ? lua_tointeger(L,2) : 0;
-        stretch(n)       = ((top > 2 && lua_type(L, 3) == LUA_TNUMBER)) ? lua_tointeger(L,3) : 0;
-        shrink(n)        = ((top > 3 && lua_type(L, 4) == LUA_TNUMBER)) ? lua_tointeger(L,4) : 0;
+        width(n)         = ((top > 1 && lua_type(L, 2) == LUA_TNUMBER)) ? lua_roundnumber(L,2) : 0;
+        stretch(n)       = ((top > 2 && lua_type(L, 3) == LUA_TNUMBER)) ? lua_roundnumber(L,3) : 0;
+        shrink(n)        = ((top > 3 && lua_type(L, 4) == LUA_TNUMBER)) ? lua_roundnumber(L,4) : 0;
         stretch_order(n) = ((top > 4 && lua_type(L, 5) == LUA_TNUMBER)) ? lua_tointeger(L,5) : 0;
         shrink_order(n)  = ((top > 5 && lua_type(L, 6) == LUA_TNUMBER)) ? lua_tointeger(L,6) : 0;
         return 0;
@@ -2392,7 +2508,7 @@
 {
     halfword n = *check_isnode(L, 1);
     if ((n != null) && (type(n) == glue_node || type(n) == glue_spec_node)) {
-        lua_toboolean(L,(width(n) == 0 && stretch(n) == 0 && shrink(n) == 0));
+        lua_pushboolean(L,(width(n) == 0 && stretch(n) == 0 && shrink(n) == 0));
         return 1;
     } else {
         return luaL_error(L, "glue (spec) expected");
@@ -2403,7 +2519,7 @@
 {
     halfword n = lua_tointeger(L, 1);
     if ((n != null) && (type(n) == glue_node || type(n) == glue_spec_node)) {
-        lua_toboolean(L,(width(n) == 0 && stretch(n) == 0 && shrink(n) == 0));
+        lua_pushboolean(L,(width(n) == 0 && stretch(n) == 0 && shrink(n) == 0));
         return 1;
     } else {
         return luaL_error(L, "glue (spec) expected");
@@ -3291,7 +3407,7 @@
             lua_pushinteger(L, height(n));
         } else if ((lua_key_eq(s, list)) || (lua_key_eq(s, head))) { /* already mapped */
             fast_metatable_or_nil_alink(ins_ptr(n));
-		/* glue parameters */
+        /* glue parameters */
         } else if (lua_key_eq(s, width)) {
             lua_pushinteger(L, width(n));
         } else if (lua_key_eq(s, stretch)) {
@@ -3310,7 +3426,7 @@
             lua_pushinteger(L, subtype(n));
         } else if (lua_key_eq(s, surround)) {
             lua_pushinteger(L, surround(n));
-		/* glue parameters */
+        /* glue parameters */
         } else if (lua_key_eq(s, width)) {
             lua_pushinteger(L, width(n));
         } else if (lua_key_eq(s, stretch)) {
@@ -3337,6 +3453,10 @@
             fast_metatable_or_nil(left_delimiter(n));
         } else if (lua_key_eq(s, right)) {
             fast_metatable_or_nil(right_delimiter(n));
+        } else if (lua_key_eq(s, middle)) {
+            fast_metatable_or_nil(middle_delimiter(n));
+        } else if (lua_key_eq(s, options)) {
+            lua_pushinteger(L, fractionoptions(n));
         } else {
             lua_pushnil(L);
         }
@@ -3363,6 +3483,8 @@
             fast_metatable_or_nil(bot_accent_chr(n));
         } else if (lua_key_eq(s, overlay_accent)) {
             fast_metatable_or_nil(overlay_accent_chr(n));
+        } else if (lua_key_eq(s, fraction)) {
+            lua_pushinteger(L, accentfraction(n));
         } else {
             lua_pushnil(L);
         }
@@ -3371,6 +3493,16 @@
             lua_pushinteger(L, subtype(n));
         } else if (lua_key_eq(s, delim)) {
             fast_metatable_or_nil(delimiter(n));
+        } else if (lua_key_eq(s, italic)) {
+            lua_pushinteger(L, delimiteritalic(n));
+        } else if (lua_key_eq(s, height)) {
+            lua_pushinteger(L, delimiterheight(n));
+        } else if (lua_key_eq(s, depth)) {
+            lua_pushinteger(L, delimiterdepth(n));
+        } else if (lua_key_eq(s, options)) {
+            lua_pushinteger(L, delimiteroptions(n));
+        } else if (lua_key_eq(s, class)) {
+            lua_pushinteger(L, delimiterclass(n));
         } else {
             lua_pushnil(L);
         }
@@ -3409,6 +3541,10 @@
             fast_metatable_or_nil(left_delimiter(n));
         } else if (lua_key_eq(s, degree)) {
             fast_metatable_or_nil(degree(n));
+        } else if (lua_key_eq(s, width)) {
+            lua_pushinteger(L, radicalwidth(n));
+        } else if (lua_key_eq(s, options)) {
+            lua_pushinteger(L, radicaloptions(n));
         } else {
             lua_pushnil(L);
         }
@@ -4000,7 +4136,7 @@
             lua_pushinteger(L, height(n));
         } else if ((lua_key_eq(s, list)) || (lua_key_eq(s, head))) {
             nodelib_pushdirect_or_nil_alink(ins_ptr(n));
-		/* glue */
+        /* glue */
         } else if (lua_key_eq(s, width)) {
             lua_pushinteger(L, width(n));
         } else if (lua_key_eq(s, stretch)) {
@@ -4042,6 +4178,10 @@
             nodelib_pushdirect_or_nil(left_delimiter(n));
         } else if (lua_key_eq(s, right)) {
             nodelib_pushdirect_or_nil(right_delimiter(n));
+        } else if (lua_key_eq(s, middle)) {
+            nodelib_pushdirect_or_nil(middle_delimiter(n));
+        } else if (lua_key_eq(s, options)) {
+            lua_pushinteger(L, fractionoptions(n));
         } else {
             lua_pushnil(L);
         }
@@ -4064,12 +4204,24 @@
             nodelib_pushdirect_or_nil(bot_accent_chr(n));
         } else if (lua_key_eq(s, overlay_accent)) {
             nodelib_pushdirect_or_nil(overlay_accent_chr(n));
+        } else if (lua_key_eq(s, fraction)) {
+            lua_pushinteger(L, accentfraction(n));
         } else {
             lua_pushnil(L);
         }
     } else if (t == fence_noad) {
         if (lua_key_eq(s, delim)) {
             nodelib_pushdirect_or_nil(delimiter(n));
+        } else if (lua_key_eq(s, italic)) {
+            lua_pushinteger(L, delimiteritalic(n));
+        } else if (lua_key_eq(s, height)) {
+            lua_pushinteger(L, delimiterheight(n));
+        } else if (lua_key_eq(s, depth)) {
+            lua_pushinteger(L, delimiterdepth(n));
+        } else if (lua_key_eq(s, options)) {
+            lua_pushinteger(L, delimiteroptions(n));
+        } else if (lua_key_eq(s, class)) {
+            lua_pushinteger(L, delimiterclass(n));
         } else {
             lua_pushnil(L);
         }
@@ -4102,6 +4254,10 @@
             nodelib_pushdirect_or_nil(left_delimiter(n));
         } else if (lua_key_eq(s, degree)) {
             nodelib_pushdirect_or_nil(degree(n));
+        } else if (lua_key_eq(s, width)) {
+            lua_pushinteger(L, radicalwidth(n));
+        } else if (lua_key_eq(s, options)) {
+            lua_pushinteger(L, radicaloptions(n));
         } else {
             lua_pushnil(L);
         }
@@ -4616,6 +4772,8 @@
 
 /* this is too simplistic, but it helps Hans to get going */
 
+/*
+
 static halfword do_ligature_n(halfword prev, halfword stop, halfword lig)
 {
     vlink(lig) = vlink(stop);
@@ -4625,8 +4783,12 @@
     return lig;
 }
 
+*/
+
 /* node.do_ligature_n(node prev, node last, node lig) */
 
+/*
+
 static int lua_nodelib_do_ligature_n(lua_State * L)
 {
     halfword p;
@@ -4646,8 +4808,12 @@
     return 1;
 }
 
+*/
+
 /* node.direct.do_ligature_n(node prev, node last, node lig) */
 
+/*
+
 static int lua_nodelib_direct_do_ligature_n(lua_State * L)
 {
     halfword p;
@@ -4670,6 +4836,8 @@
     return 1;
 }
 
+*/
+
 /* node.usedlist */
 
 static int lua_nodelib_usedlist(lua_State * L)
@@ -4853,7 +5021,7 @@
                 user_node_value(n) = nodelib_getlist(L, 3);
                 break;
             case 'd':
-                user_node_value(n) = (halfword) lua_tointeger(L, 3);
+                user_node_value(n) = (halfword) lua_roundnumber(L, 3);
                 break;
             case 'l':
                 lua_pushvalue(L, 3);
@@ -4872,7 +5040,7 @@
                 user_node_value(n) = nodelib_gettoks(L, 3);
                 break;
             default:
-                user_node_value(n) = (halfword) lua_tointeger(L, 3);
+                user_node_value(n) = (halfword) lua_roundnumber(L, 3);
                 break;
             }
         } else {
@@ -4880,11 +5048,11 @@
         }
     } else if (t == pdf_annot_node) {
         if (lua_key_eq(s, width)) {
-            width(n) = (halfword) lua_tointeger(L, 3);
+            width(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, depth)) {
-            depth(n) = (halfword) lua_tointeger(L, 3);
+            depth(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, height)) {
-            height(n) = (halfword) lua_tointeger(L, 3);
+            height(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, objnum)) {
             pdf_annot_objnum(n) = (halfword) lua_tointeger(L, 3);
         } else if (lua_key_eq(s, data)) {
@@ -4894,11 +5062,11 @@
         }
     } else if (t == pdf_dest_node) {
         if (lua_key_eq(s, width)) {
-            width(n) = (halfword) lua_tointeger(L, 3);
+            width(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, depth)) {
-            depth(n) = (halfword) lua_tointeger(L, 3);
+            depth(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, height)) {
-            height(n) = (halfword) lua_tointeger(L, 3);
+            height(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, named_id)) {
             pdf_dest_named_id(n) = (quarterword) lua_tointeger(L, 3);
         } else if (lua_key_eq(s, dest_id)) {
@@ -4930,11 +5098,11 @@
         }
     } else if (t == pdf_start_link_node) {
         if (lua_key_eq(s, width)) {
-            width(n) = (halfword) lua_tointeger(L, 3);
+            width(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, depth)) {
-            depth(n) = (halfword) lua_tointeger(L, 3);
+            depth(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, height)) {
-            height(n) = (halfword) lua_tointeger(L, 3);
+            height(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, objnum)) {
             pdf_link_objnum(n) = (halfword) lua_tointeger(L, 3);
         } else if (lua_key_eq(s, link_attr)) {
@@ -4984,11 +5152,11 @@
         }
     } else if ((t == pdf_thread_node) || (t == pdf_start_thread_node)) {
         if (lua_key_eq(s, width)) {
-            width(n) = (halfword) lua_tointeger(L, 3);
+            width(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, depth)) {
-            depth(n) = (halfword) lua_tointeger(L, 3);
+            depth(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, height)) {
-            height(n) = (halfword) lua_tointeger(L, 3);
+            height(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, named_id)) {
             pdf_thread_named_id(n) = (quarterword) lua_tointeger(L, 3);
         } else if (lua_key_eq(s, thread_id)) {
@@ -5085,11 +5253,11 @@
         } else if (lua_key_eq(s, char)) {
             character(n) = (halfword) lua_tointeger(L, 3);
         } else if (lua_key_eq(s, xoffset)) {
-            x_displace(n) = (halfword) lua_tointeger(L, 3);
+            x_displace(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, yoffset)) {
-            y_displace(n) = (halfword) lua_tointeger(L, 3);
+            y_displace(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, xadvance)) {
-            x_advance(n) = (halfword) lua_tointeger(L, 3);
+            x_advance(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, width)) {
             /* not yet */
         } else if (lua_key_eq(s, height)) {
@@ -5097,7 +5265,7 @@
         } else if (lua_key_eq(s, depth)) {
             /* not yet */
         } else if (lua_key_eq(s, expansion_factor)) {
-            ex_glyph(n) = (halfword) lua_tointeger(L, 3);
+            ex_glyph(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, components)) {
             lig_ptr(n) = nodelib_getlist(L, 3);
         } else if (lua_key_eq(s, lang)) {
@@ -5117,15 +5285,15 @@
         } else if (lua_key_eq(s, list) || lua_key_eq(s, head)) {
             list_ptr(n) = nodelib_getlist(L, 3);
         } else if (lua_key_eq(s, width)) {
-            width(n) = (halfword) lua_tointeger(L, 3);
+            width(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, height)) {
-            height(n) = (halfword) lua_tointeger(L, 3);
+            height(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, depth)) {
-            depth(n) = (halfword) lua_tointeger(L, 3);
+            depth(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, dir)) {
             box_dir(n) = nodelib_getdir(L, 3, 1);
         } else if (lua_key_eq(s, shift)) {
-            shift_amount(n) = (halfword) lua_tointeger(L, 3);
+            shift_amount(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, glue_order)) {
             glue_order(n) = (quarterword) lua_tointeger(L, 3);
         } else if (lua_key_eq(s, glue_sign)) {
@@ -5153,11 +5321,11 @@
         if (lua_key_eq(s, subtype)) {
             subtype(n) = (quarterword) lua_tointeger(L, 3);
         } else if (lua_key_eq(s, width)) {
-            width(n) = (halfword) lua_tointeger(L, 3);
+            width(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, stretch)) {
-            stretch(n) = (halfword) lua_tointeger(L, 3);
+            stretch(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, shrink)) {
-            shrink(n) = (halfword) lua_tointeger(L, 3);
+            shrink(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, stretch_order)) {
             stretch_order(n) = (quarterword) lua_tointeger(L, 3);
         } else if (lua_key_eq(s, shrink_order)) {
@@ -5171,9 +5339,9 @@
         if (lua_key_eq(s, subtype)) {
             subtype(n) = (quarterword) lua_tointeger(L, 3);
         } else if (lua_key_eq(s, kern)) {
-            width(n) = (halfword) lua_tointeger(L, 3);
+            width(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, expansion_factor)) {
-            ex_kern(n) = (halfword) lua_tointeger(L, 3);
+            ex_kern(n) = (halfword) lua_roundnumber(L, 3);
         } else {
             return nodelib_cantset(L, n, s);
         }
@@ -5189,17 +5357,17 @@
         if (lua_key_eq(s, subtype)) {
             subtype(n) = (quarterword) lua_tointeger(L, 3);
         } else if (lua_key_eq(s, width)) {
-            width(n) = (halfword) lua_tointeger(L, 3);
+            width(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, height)) {
-            height(n) = (halfword) lua_tointeger(L, 3);
+            height(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, depth)) {
-            depth(n) = (halfword) lua_tointeger(L, 3);
+            depth(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, dir)) {
             rule_dir(n) = nodelib_getdir(L, 3, 1);
         } else if (lua_key_eq(s, index)) {
             rule_index(n) = (halfword) lua_tointeger(L, 3);
         } else if (lua_key_eq(s, transform)) {
-            rule_transform(n) = (halfword) lua_tointeger(L, 3);
+            rule_transform(n) = (halfword) lua_roundnumber(L, 3); /* can also be user value */
         } else {
             return nodelib_cantset(L, n, s);
         }
@@ -5223,11 +5391,11 @@
         } else if (lua_key_eq(s, box_left)) {
             local_box_left(n) = nodelib_getlist(L, 3);
         } else if (lua_key_eq(s, box_left_width)) {
-            local_box_left_width(n) = (halfword) lua_tointeger(L, 3);
+            local_box_left_width(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, box_right)) {
             local_box_right(n) = nodelib_getlist(L, 3);
         } else if (lua_key_eq(s, box_right_width)) {
-            local_box_right_width(n) = (halfword) lua_tointeger(L, 3);
+            local_box_right_width(n) = (halfword) lua_roundnumber(L, 3);
         } else {
             return nodelib_cantset(L, n, s);
         }
@@ -5275,18 +5443,18 @@
         } else if (lua_key_eq(s, cost)) {
             float_cost(n) = (halfword) lua_tointeger(L, 3);
         } else if (lua_key_eq(s, depth)) {
-            depth(n) = (halfword) lua_tointeger(L, 3);
+            depth(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, height)) {
-            height(n) = (halfword) lua_tointeger(L, 3);
+            height(n) = (halfword) lua_roundnumber(L, 3);
         } else if ((lua_key_eq(s, list)) || (lua_key_eq(s, head))) {
             ins_ptr(n) = nodelib_getlist(L, 3);
 		/* glue */
         } else if (lua_key_eq(s, width)) {
-            width(n) = (halfword) lua_tointeger(L, 3);
+            width(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, stretch)) {
-            stretch(n) = (halfword) lua_tointeger(L, 3);
+            stretch(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, shrink)) {
-            shrink(n) = (halfword) lua_tointeger(L, 3);
+            shrink(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, stretch_order)) {
             stretch_order(n) = (quarterword) lua_tointeger(L, 3);
         } else if (lua_key_eq(s, shrink_order)) {
@@ -5298,14 +5466,14 @@
         if (lua_key_eq(s, subtype)) {
             subtype(n) = (quarterword) lua_tointeger(L, 3);
         } else if (lua_key_eq(s, surround)) {
-            surround(n) = (halfword) lua_tointeger(L, 3);
+            surround(n) = (halfword) lua_roundnumber(L, 3);
 		/* glue */
         } else if (lua_key_eq(s, width)) {
-            width(n) = (halfword) lua_tointeger(L, 3);
+            width(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, stretch)) {
-            stretch(n) = (halfword) lua_tointeger(L, 3);
+            stretch(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, shrink)) {
-            shrink(n) = (halfword) lua_tointeger(L, 3);
+            shrink(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, stretch_order)) {
             stretch_order(n) = (quarterword) lua_tointeger(L, 3);
         } else if (lua_key_eq(s, shrink_order)) {
@@ -5317,7 +5485,7 @@
         if (lua_key_eq(s, subtype)) {
             subtype(n) = (quarterword) lua_tointeger(L, 3);
         } else if (lua_key_eq(s, width)) {
-            thickness(n) = (halfword) lua_tointeger(L, 3);
+            thickness(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, num)) {
             numerator(n) = nodelib_getlist(L, 3);
         } else if (lua_key_eq(s, denom)) {
@@ -5326,6 +5494,10 @@
             left_delimiter(n) = nodelib_getlist(L, 3);
         } else if (lua_key_eq(s, right)) {
             right_delimiter(n) = nodelib_getlist(L, 3);
+        } else if (lua_key_eq(s, middle)) {
+            middle_delimiter(n) = nodelib_getlist(L, 3);
+        } else if (lua_key_eq(s, options)) {
+            fractionoptions(n) = (halfword) lua_tointeger(L, 3);
         } else {
             return nodelib_cantset(L, n, s);
         }
@@ -5352,6 +5524,8 @@
             bot_accent_chr(n) = nodelib_getlist(L, 3);
         } else if (lua_key_eq(s, overlay_accent)) {
             overlay_accent_chr(n) = nodelib_getlist(L, 3);
+        } else if (lua_key_eq(s, fraction)) {
+            accentfraction(n) = (halfword) lua_roundnumber(L,3);
         } else {
             return nodelib_cantset(L, n, s);
         }
@@ -5360,6 +5534,16 @@
             subtype(n) = (quarterword) lua_tointeger(L, 3);
         } else if (lua_key_eq(s, delim)) {
             delimiter(n) = nodelib_getlist(L, 3);
+        } else if (lua_key_eq(s, italic)) {
+            delimiteritalic(n) = (halfword) lua_roundnumber(L,3);
+        } else if (lua_key_eq(s, height)) {
+            delimiterheight(n) = (halfword) lua_roundnumber(L,3);
+        } else if (lua_key_eq(s, depth)) {
+            delimiterdepth(n) = (halfword) lua_roundnumber(L,3);
+        } else if (lua_key_eq(s, options)) {
+            delimiteroptions(n) = (halfword) lua_tointeger(L,3);
+        } else if (lua_key_eq(s, class)) {
+            delimiterclass(n) = (halfword) lua_tointeger(L,3);
         } else {
             return nodelib_cantset(L, n, s);
         }
@@ -5398,6 +5582,10 @@
             left_delimiter(n) = nodelib_getlist(L, 3);
         } else if (lua_key_eq(s, degree)) {
             degree(n) = nodelib_getlist(L, 3);
+        } else if (lua_key_eq(s, width)) {
+            radicalwidth(n) = lua_roundnumber(L, 3);
+        } else if (lua_key_eq(s, options)) {
+            radicaloptions(n) = (halfword) lua_tointeger(L,3);
         } else {
             return nodelib_cantset(L, n, s);
         }
@@ -5405,7 +5593,7 @@
         if (lua_key_eq(s, subtype)) {
             subtype(n) = (quarterword) lua_tointeger(L, 3);
         } else if (lua_key_eq(s, width)) {
-            width(n) = (halfword) lua_tointeger(L, 3);
+            width(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, glyph)) {
             margin_char(n) = nodelib_getlist(L, 3);
         } else {
@@ -5471,21 +5659,21 @@
         if (lua_key_eq(s, subtype)) {
             /* dummy subtype */
         } else if (lua_key_eq(s, width)) {
-            width(n) = (halfword) lua_tointeger(L, 3);
+            width(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, height)) {
-            height(n) = (halfword) lua_tointeger(L, 3);
+            height(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, depth)) {
-            depth(n) = (halfword) lua_tointeger(L, 3);
+            depth(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, dir)) {
             box_dir(n) = nodelib_getdir(L, 3, 1);
         } else if (lua_key_eq(s, shrink)) {
-            glue_shrink(n) = (halfword) lua_tointeger(L, 3);
+            glue_shrink(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, glue_order)) {
             glue_order(n) = (quarterword) lua_tointeger(L, 3);
         } else if (lua_key_eq(s, glue_sign)) {
             glue_sign(n) = (quarterword) lua_tointeger(L, 3);
         } else if (lua_key_eq(s, stretch)) {
-            glue_stretch(n) = (halfword) lua_tointeger(L, 3);
+            glue_stretch(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, count)) {
             span_count(n) = (quarterword) lua_tointeger(L, 3);
         } else if ((lua_key_eq(s, list)) || (lua_key_eq(s, head))){
@@ -5509,11 +5697,11 @@
         }
     } else if (t == glue_spec_node) {
         if (lua_key_eq(s, width)) {
-            width(n) = (halfword) lua_tointeger(L, 3);
+            width(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, stretch)) {
-            stretch(n) = (halfword) lua_tointeger(L, 3);
+            stretch(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, shrink)) {
-            shrink(n) = (halfword) lua_tointeger(L, 3);
+            shrink(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, stretch_order)) {
             stretch_order(n) = (quarterword) lua_tointeger(L, 3);
         } else if (lua_key_eq(s, shrink_order)) {
@@ -5596,7 +5784,7 @@
                 user_node_value(n) = nodelib_getlist(L, 3);
                 break;
             case 'd':
-                user_node_value(n) = (halfword) lua_tointeger(L, 3);
+                user_node_value(n) = (halfword) lua_roundnumber(L, 3);
                 break;
             case 'l':
                 lua_pushvalue(L, 3);
@@ -5615,7 +5803,7 @@
                 user_node_value(n) = nodelib_gettoks(L, 3);
                 break;
             default:
-                user_node_value(n) = (halfword) lua_tointeger(L, 3);
+                user_node_value(n) = (halfword) lua_roundnumber(L, 3);
                 break;
             }
         } else {
@@ -5623,11 +5811,11 @@
         }
     } else if (t == pdf_annot_node) {
         if (lua_key_eq(s, width)) {
-            width(n) = (halfword) lua_tointeger(L, 3);
+            width(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, depth)) {
-            depth(n) = (halfword) lua_tointeger(L, 3);
+            depth(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, height)) {
-            height(n) = (halfword) lua_tointeger(L, 3);
+            height(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, objnum)) {
             pdf_annot_objnum(n) = (halfword) lua_tointeger(L, 3);
         } else if (lua_key_eq(s, data)) {
@@ -5637,11 +5825,11 @@
         }
     } else if (t == pdf_dest_node) {
         if (lua_key_eq(s, width)) {
-            width(n) = (halfword) lua_tointeger(L, 3);
+            width(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, depth)) {
-            depth(n) = (halfword) lua_tointeger(L, 3);
+            depth(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, height)) {
-            height(n) = (halfword) lua_tointeger(L, 3);
+            height(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, named_id)) {
             pdf_dest_named_id(n) = (quarterword) lua_tointeger(L, 3);
         } else if (lua_key_eq(s, dest_id)) {
@@ -5673,11 +5861,11 @@
         }
     } else if (t == pdf_start_link_node) {
         if (lua_key_eq(s, width)) {
-            width(n) = (halfword) lua_tointeger(L, 3);
+            width(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, depth)) {
-            depth(n) = (halfword) lua_tointeger(L, 3);
+            depth(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, height)) {
-            height(n) = (halfword) lua_tointeger(L, 3);
+            height(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, objnum)) {
             pdf_link_objnum(n) = (halfword) lua_tointeger(L, 3);
         } else if (lua_key_eq(s, link_attr)) {
@@ -5727,11 +5915,11 @@
         }
     } else if ((t == pdf_thread_node) || (t == pdf_start_thread_node)) {
         if (lua_key_eq(s, width)) {
-            width(n) = (halfword) lua_tointeger(L, 3);
+            width(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, depth)) {
-            depth(n) = (halfword) lua_tointeger(L, 3);
+            depth(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, height)) {
-            height(n) = (halfword) lua_tointeger(L, 3);
+            height(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, named_id)) {
             pdf_thread_named_id(n) = (quarterword) lua_tointeger(L, 3);
         } else if (lua_key_eq(s, thread_id)) {
@@ -5973,13 +6161,13 @@
         } else if (lua_key_eq(s, char)) {
             character(n) = (halfword) lua_tointeger(L, 3);
         } else if (lua_key_eq(s, xoffset)) {
-            x_displace(n) = (halfword) lua_tointeger(L, 3);
+            x_displace(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, yoffset)) {
-            y_displace(n) = (halfword) lua_tointeger(L, 3);
+            y_displace(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, xadvance)) {
-            x_advance(n) = (halfword) lua_tointeger(L, 3);
+            x_advance(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, expansion_factor)) {
-            ex_glyph(n) = (halfword) lua_tointeger(L, 3);
+            ex_glyph(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, components)) {
             lig_ptr(n) = nodelib_popdirect(3);
         } else if (lua_key_eq(s, lang)) {
@@ -6005,15 +6193,15 @@
         } else if (lua_key_eq(s, list) || lua_key_eq(s, head)) {
             list_ptr(n) = nodelib_popdirect(3);
         } else if (lua_key_eq(s, width)) {
-            width(n) = (halfword) lua_tointeger(L, 3);
+            width(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, height)) {
-            height(n) = (halfword) lua_tointeger(L, 3);
+            height(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, depth)) {
-            depth(n) = (halfword) lua_tointeger(L, 3);
+            depth(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, dir)) {
             box_dir(n) = nodelib_getdir(L, 3, 1);
         } else if (lua_key_eq(s, shift)) {
-            shift_amount(n) = (halfword) lua_tointeger(L, 3);
+            shift_amount(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, glue_order)) {
             glue_order(n) = (quarterword) lua_tointeger(L, 3);
         } else if (lua_key_eq(s, glue_sign)) {
@@ -6041,11 +6229,11 @@
         if (lua_key_eq(s, subtype)) {
             subtype(n) = (quarterword) lua_tointeger(L, 3);
         } else if (lua_key_eq(s, width)) {
-            width(n) = (halfword) lua_tointeger(L, 3);
+            width(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, stretch)) {
-            stretch(n) = (halfword) lua_tointeger(L, 3);
+            stretch(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, shrink)) {
-            shrink(n) = (halfword) lua_tointeger(L, 3);
+            shrink(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, stretch_order)) {
             stretch_order(n) = (quarterword) lua_tointeger(L, 3);
         } else if (lua_key_eq(s, shrink_order)) {
@@ -6059,9 +6247,9 @@
         if (lua_key_eq(s, subtype)) {
             subtype(n) = (quarterword) lua_tointeger(L, 3);
         } else if (lua_key_eq(s, kern)) {
-            width(n) = (halfword) lua_tointeger(L, 3);
+            width(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, expansion_factor)) {
-            ex_kern(n) = (halfword) lua_tointeger(L, 3);
+            ex_kern(n) = (halfword) lua_roundnumber(L, 3);
         } else {
             return nodelib_cantset(L, n, s);
         }
@@ -6077,17 +6265,17 @@
         if (lua_key_eq(s, subtype)) {
             subtype(n) = (quarterword) lua_tointeger(L, 3);
         } else if (lua_key_eq(s, width)) {
-            width(n) = (halfword) lua_tointeger(L, 3);
+            width(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, height)) {
-            height(n) = (halfword) lua_tointeger(L, 3);
+            height(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, depth)) {
-            depth(n) = (halfword) lua_tointeger(L, 3);
+            depth(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, dir)) {
             rule_dir(n) = nodelib_getdir(L, 3, 1);
         } else if (lua_key_eq(s, index)) {
             rule_index(n) = (halfword) lua_tointeger(L, 3);
         } else if (lua_key_eq(s, transform)) {
-            rule_transform(n) = (halfword) lua_tointeger(L, 3);
+            rule_transform(n) = (halfword) lua_roundnumber(L, 3); /* can also be user value */
         } else {
             return nodelib_cantset(L, n, s);
         }
@@ -6117,11 +6305,11 @@
         } else if (lua_key_eq(s, box_left)) {
             local_box_left(n) = nodelib_getlist(L, 3);
         } else if (lua_key_eq(s, box_left_width)) {
-            local_box_left_width(n) = (halfword) lua_tointeger(L, 3);
+            local_box_left_width(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, box_right)) {
             local_box_right(n) = nodelib_getlist(L, 3);
         } else if (lua_key_eq(s, box_right_width)) {
-            local_box_right_width(n) = (halfword) lua_tointeger(L, 3);
+            local_box_right_width(n) = (halfword) lua_roundnumber(L, 3);
         } else {
             return nodelib_cantset(L, n, s);
         }
@@ -6163,18 +6351,18 @@
         } else if (lua_key_eq(s, cost)) {
             float_cost(n) = (halfword) lua_tointeger(L, 3);
         } else if (lua_key_eq(s, depth)) {
-            depth(n) = (halfword) lua_tointeger(L, 3);
+            depth(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, height)) {
-            height(n) = (halfword) lua_tointeger(L, 3);
+            height(n) = (halfword) lua_roundnumber(L, 3);
         } else if ((lua_key_eq(s, list)) || (lua_key_eq(s, head))) {
             ins_ptr(n) = nodelib_popdirect(3);
 		/* glue */
         } else if (lua_key_eq(s, width)) {
-            width(n) = (halfword) lua_tointeger(L, 3);
+            width(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, stretch)) {
-            stretch(n) = (halfword) lua_tointeger(L, 3);
+            stretch(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, shrink)) {
-            shrink(n) = (halfword) lua_tointeger(L, 3);
+            shrink(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, stretch_order)) {
             stretch_order(n) = (quarterword) lua_tointeger(L, 3);
         } else if (lua_key_eq(s, shrink_order)) {
@@ -6186,14 +6374,14 @@
         if (lua_key_eq(s, subtype)) {
             subtype(n) = (quarterword) lua_tointeger(L, 3);
         } else if (lua_key_eq(s, surround)) {
-            surround(n) = (halfword) lua_tointeger(L, 3);
+            surround(n) = (halfword) lua_roundnumber(L, 3);
 		/* glue */
         } else if (lua_key_eq(s, width)) {
-            width(n) = (halfword) lua_tointeger(L, 3);
+            width(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, stretch)) {
-            stretch(n) = (halfword) lua_tointeger(L, 3);
+            stretch(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, shrink)) {
-            shrink(n) = (halfword) lua_tointeger(L, 3);
+            shrink(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, stretch_order)) {
             stretch_order(n) = (quarterword) lua_tointeger(L, 3);
         } else if (lua_key_eq(s, shrink_order)) {
@@ -6205,7 +6393,7 @@
         if (lua_key_eq(s, subtype)) {
             subtype(n) = (quarterword) lua_tointeger(L, 3);
         } else if (lua_key_eq(s, width)) {
-            thickness(n) = (halfword) lua_tointeger(L, 3);
+            thickness(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, num)) {
             numerator(n) = nodelib_popdirect(3);
         } else if (lua_key_eq(s, denom)) {
@@ -6214,6 +6402,10 @@
             left_delimiter(n) = nodelib_popdirect(3);
         } else if (lua_key_eq(s, right)) {
             right_delimiter(n) = nodelib_popdirect(3);
+        } else if (lua_key_eq(s, middle)) {
+            middle_delimiter(n) = nodelib_popdirect(3);
+        } else if (lua_key_eq(s, options)) {
+            fractionoptions(n) = (halfword) lua_tointeger(L, 3);
         } else {
             return nodelib_cantset(L, n, s);
         }
@@ -6240,6 +6432,8 @@
             bot_accent_chr(n) = nodelib_popdirect(3);
         } else if (lua_key_eq(s, overlay_accent)) {
             overlay_accent_chr(n) = nodelib_popdirect(3);
+        } else if (lua_key_eq(s, fraction)) {
+            accentfraction(n) = (halfword) lua_roundnumber(L, 3);
         } else {
             return nodelib_cantset(L, n, s);
         }
@@ -6248,6 +6442,16 @@
             subtype(n) = (quarterword) lua_tointeger(L, 3);
         } else if (lua_key_eq(s, delim)) {
             delimiter(n) = nodelib_popdirect(3);
+        } else if (lua_key_eq(s, italic)) {
+            delimiteritalic(n) = (halfword) lua_roundnumber(L,3);
+        } else if (lua_key_eq(s, height)) {
+            delimiterheight(n) = (halfword) lua_roundnumber(L,3);
+        } else if (lua_key_eq(s, depth)) {
+            delimiterdepth(n) = (halfword) lua_roundnumber(L,3);
+        } else if (lua_key_eq(s, options)) {
+            delimiteroptions(n) = (halfword) lua_tointeger(L,3);
+        } else if (lua_key_eq(s, class)) {
+            delimiterclass(n) = (halfword) lua_tointeger(L,3);
         } else {
             return nodelib_cantset(L, n, s);
         }
@@ -6286,6 +6490,10 @@
             left_delimiter(n) = nodelib_popdirect(3);
         } else if (lua_key_eq(s, degree)) {
             degree(n) = nodelib_popdirect(3);
+        } else if (lua_key_eq(s, width)) {
+            radicalwidth(n) = lua_roundnumber(L, 3);
+        } else if (lua_key_eq(s, options)) {
+            radicaloptions(n) = (halfword) lua_tointeger(L,3);
         } else {
             return nodelib_cantset(L, n, s);
         }
@@ -6293,7 +6501,7 @@
         if (lua_key_eq(s, subtype)) {
             subtype(n) = (quarterword) lua_tointeger(L, 3);
         } else if (lua_key_eq(s, width)) {
-            width(n) = (halfword) lua_tointeger(L, 3);
+            width(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, glyph)) {
             margin_char(n) = nodelib_popdirect(3);
         } else {
@@ -6359,21 +6567,21 @@
         if (lua_key_eq(s, subtype)) {
             /* dummy subtype */
         } else if (lua_key_eq(s, width)) {
-            width(n) = (halfword) lua_tointeger(L, 3);
+            width(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, height)) {
-            height(n) = (halfword) lua_tointeger(L, 3);
+            height(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, depth)) {
-            depth(n) = (halfword) lua_tointeger(L, 3);
+            depth(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, dir)) {
             box_dir(n) = nodelib_getdir(L, 3, 1);
         } else if (lua_key_eq(s, shrink)) {
-            glue_shrink(n) = (halfword) lua_tointeger(L, 3);
+            glue_shrink(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, glue_order)) {
             glue_order(n) = (quarterword) lua_tointeger(L, 3);
         } else if (lua_key_eq(s, glue_sign)) {
             glue_sign(n) = (quarterword) lua_tointeger(L, 3);
         } else if (lua_key_eq(s, stretch)) {
-            glue_stretch(n) = (halfword) lua_tointeger(L, 3);
+            glue_stretch(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, count)) {
             span_count(n) = (quarterword) lua_tointeger(L, 3);
         } else if ((lua_key_eq(s, list)) || (lua_key_eq(s, head))){
@@ -6397,11 +6605,11 @@
         }
     } else if (t == glue_spec_node) {
         if (lua_key_eq(s, width)) {
-            width(n) = (halfword) lua_tointeger(L, 3);
+            width(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, stretch)) {
-            stretch(n) = (halfword) lua_tointeger(L, 3);
+            stretch(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, shrink)) {
-            shrink(n) = (halfword) lua_tointeger(L, 3);
+            shrink(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, stretch_order)) {
             stretch_order(n) = (quarterword) lua_tointeger(L, 3);
         } else if (lua_key_eq(s, shrink_order)) {
@@ -6495,12 +6703,12 @@
         }
 
     }
-    save_global_defs = int_par(global_defs_code);
+    save_global_defs = global_defs_par;
     if (isglobal) {
-        int_par(global_defs_code) = 1;
+        global_defs_par = 1;
     }
     err = set_tex_box_register(k, j);
-    int_par(global_defs_code) = save_global_defs;
+    global_defs_par = save_global_defs;
     if (err) {
         luaL_error(L, "incorrect value");
     }
@@ -6710,7 +6918,6 @@
     return 1;
 }
 
-
 static int lua_nodelib_direct_effective_glue(lua_State * L)
 {
     halfword glue = lua_tointeger(L, 1);
@@ -6735,6 +6942,70 @@
     return 1;
 }
 
+/*
+    Disc nodes are kind of special in the sense that their head is not the head as we
+    see it, but a special node that has status info of which head and tail are part.
+    Normally when proper set/get functions are used this status node is all right but
+    if a macro package permits arbitrary messing around, then it can at some point
+    call the following cleaner, just before linebreaking kicks in. This one is not
+    called automatically because if significantly slows down the line break routing.
+
+*/
+
+#define check_disc(c) \
+    p = c ; \
+    if (p != null && vlink(p) != null) \
+        tlink(p) = tail_of_list(vlink(p));
+
+static int lua_nodelib_direct_check_discretionaries(lua_State * L) {
+    halfword c = lua_tointeger(L, 1);
+    halfword p ;
+    while (c != null) {
+        if (type(c) == disc_node) {
+            check_disc(no_break(c)) ;
+            check_disc(pre_break(c)) ;
+            check_disc(post_break(c)) ;
+        }
+        c = vlink(c) ;
+    }
+    return 0;
+}
+
+static int lua_nodelib_direct_check_discretionary(lua_State * L) {
+    halfword c = lua_tointeger(L, 1);
+    if (c != null && type(c) == disc_node) {
+        halfword p ;
+        check_disc(no_break(c)) ;
+        check_disc(pre_break(c)) ;
+        check_disc(post_break(c)) ;
+    }
+    return 0;
+}
+
+static int lua_nodelib_check_discretionaries(lua_State * L) {
+    halfword c = *check_isnode(L, 1);
+    halfword p ;
+    while (c != null) {
+        if (type(c) == disc_node) {
+            check_disc(no_break(c)) ;
+            check_disc(pre_break(c)) ;
+            check_disc(post_break(c)) ;
+        }
+        c = vlink(c) ;
+    }
+    return 0;
+}
+
+static int lua_nodelib_check_discretionary(lua_State * L) {
+    halfword c = *check_isnode(L, 1);
+    if (c != null && type(c) == disc_node) {
+        halfword p ;
+        check_disc(no_break(c)) ;
+        check_disc(pre_break(c)) ;
+        check_disc(post_break(c)) ;
+    }
+    return 0;
+}
 
 static const struct luaL_Reg nodelib_p[] = {
     {"__index",    lua_nodelib_get_property_t},
@@ -6764,7 +7035,8 @@
     {"count", lua_nodelib_direct_count},
     {"current_attr", lua_nodelib_direct_currentattr},
     {"dimensions", lua_nodelib_direct_dimensions},
-    {"do_ligature_n", lua_nodelib_direct_do_ligature_n},
+    {"rangedimensions", lua_nodelib_direct_rangedimensions},
+ /* {"do_ligature_n", lua_nodelib_direct_do_ligature_n}, */
     {"end_of_math", lua_nodelib_direct_end_of_math},
  /* {"family_font", lua_nodelib_mfont}, */ /* no node argument */
  /* {"fields", lua_nodelib_fields}, */ /* no node argument */
@@ -6787,6 +7059,7 @@
     {"has_glyph", lua_nodelib_direct_has_glyph},
     {"has_attribute", lua_nodelib_direct_has_attribute},
     {"get_attribute", lua_nodelib_direct_get_attribute},
+    {"find_attribute", lua_nodelib_direct_find_attribute},
     {"has_field", lua_nodelib_direct_has_field},
     {"is_char", lua_nodelib_direct_is_char},
     {"is_glyph", lua_nodelib_direct_is_glyph},
@@ -6844,6 +7117,8 @@
     {"getproperty", lua_nodelib_direct_get_property},
     {"setproperty", lua_nodelib_direct_set_property},
     {"effective_glue", lua_nodelib_direct_effective_glue},
+    {"check_discretionary", lua_nodelib_direct_check_discretionary},
+    {"check_discretionaries", lua_nodelib_direct_check_discretionaries},
     /* done */
     {NULL, NULL} /* sentinel */
 };
@@ -6856,7 +7131,8 @@
     {"count", lua_nodelib_count},
     {"current_attr", lua_nodelib_currentattr},
     {"dimensions", lua_nodelib_dimensions},
-    {"do_ligature_n", lua_nodelib_do_ligature_n},
+    {"rangedimensions", lua_nodelib_rangedimensions},
+ /* {"do_ligature_n", lua_nodelib_do_ligature_n}, */
     {"end_of_math", lua_nodelib_end_of_math},
     {"family_font", lua_nodelib_mfont},
     {"fields", lua_nodelib_fields},
@@ -6881,6 +7157,7 @@
     {"has_glyph", lua_nodelib_has_glyph},
     {"has_attribute", lua_nodelib_has_attribute},
     {"get_attribute", lua_nodelib_get_attribute},
+    {"find_attribute", lua_nodelib_find_attribute},
     {"has_field", lua_nodelib_has_field},
     {"is_char", lua_nodelib_is_char},
     {"is_glyph", lua_nodelib_is_glyph},
@@ -6930,6 +7207,8 @@
     {"getproperty", lua_nodelib_get_property}, /* hh experiment */
     {"setproperty", lua_nodelib_set_property}, /* hh experiment */
     {"effective_glue", lua_nodelib_effective_glue},
+    {"check_discretionary", lua_nodelib_check_discretionary},
+    {"check_discretionaries", lua_nodelib_check_discretionaries},
     /* done */
     {NULL, NULL} /* sentinel */
 };
--- texlive-bin.orig/texk/web2c/luatexdir/lua/lpdflib.c
+++ texlive-bin/texk/web2c/luatexdir/lua/lpdflib.c
@@ -43,6 +43,8 @@
                 literal_mode = direct_always;
             else if (lua_key_eq(modestr_s,page))
                 literal_mode = direct_page;
+            else if (lua_key_eq(modestr_s,raw))
+                literal_mode = direct_raw;
             else {
                 luaL_error(L, "invalid first argument for print literal mode");
             }
@@ -64,6 +66,9 @@
         case (direct_always):
             pdf_end_string_nl(static_pdf);
             break;
+        case (direct_raw):
+            pdf_end_string_nl(static_pdf);
+            break;
         default:
             assert(0);
     }
@@ -907,6 +912,13 @@
     return 1 ;
 }
 
+static int getpdfcreationdate(lua_State * L)
+{
+    initialize_start_time(static_pdf);
+    lua_pushstring(L,static_pdf->start_time_str);
+    return 1 ;
+}
+
 static int getpdfminorversion(lua_State * L)
 {
  /* lua_pushinteger(L,static_pdf->minor_version); */
@@ -931,9 +943,9 @@
     int h = 0 ;
     int v = 0 ;
     if (lua_type(L, 1) == LUA_TNUMBER) {
-        h = (int) lua_tointeger(L, 1);
+        h = (int) lua_roundnumber(L, 1);
         if (lua_type(L, 2) == LUA_TNUMBER) {
-            v = (int) lua_tointeger(L, 1);
+            v = (int) lua_roundnumber(L, 1);
         } else {
             v = h;
         }
@@ -950,30 +962,44 @@
     return 2 ;
 }
 
+static int setpdfimageresolution(lua_State * L)
+{
+    if (lua_type(L, 1) == LUA_TNUMBER) {
+        set_tex_extension_count_register(c_pdf_image_resolution,lua_tointeger(L, 1));
+    }
+    return 0;
+}
+
+static int getpdfimageresolution(lua_State * L)
+{
+    lua_pushinteger(L,get_tex_extension_count_register(c_pdf_image_resolution));
+    return 1 ;
+}
+
 static int setpdfthreadmargin(lua_State * L) {
     if (lua_type(L, 1) == LUA_TNUMBER) {
-        set_tex_extension_dimen_register(d_pdf_thread_margin,lua_tointeger(L, 1));
+        set_tex_extension_dimen_register(d_pdf_thread_margin,lua_roundnumber(L, 1));
     }
     return 0;
 }
 
 static int setpdfdestmargin(lua_State * L) {
     if (lua_type(L, 1) == LUA_TNUMBER) {
-        set_tex_extension_dimen_register(d_pdf_dest_margin,lua_tointeger(L, 1));
+        set_tex_extension_dimen_register(d_pdf_dest_margin,lua_roundnumber(L, 1));
     }
     return 0;
 }
 
 static int setpdflinkmargin(lua_State * L) {
     if (lua_type(L, 1) == LUA_TNUMBER) {
-        set_tex_extension_dimen_register(d_pdf_link_margin,lua_tointeger(L, 1));
+        set_tex_extension_dimen_register(d_pdf_link_margin,lua_roundnumber(L, 1));
     }
     return 0;
 }
 
 static int setpdfxformmargin(lua_State * L) {
     if (lua_type(L, 1) == LUA_TNUMBER) {
-        set_tex_extension_dimen_register(d_pdf_xform_margin,lua_tointeger(L, 1));
+        set_tex_extension_dimen_register(d_pdf_xform_margin,lua_roundnumber(L, 1));
     }
     return 0;
 }
@@ -1048,11 +1074,13 @@
     if (lua_type(L,2) == LUA_TSTRING) {
         l =	lua_tostring(L, 2);
         if (lua_key_eq(l,origin)) {
-            literal_mode = 0;
+            literal_mode = set_origin;
         } else if (lua_key_eq(l,page))  {
-            literal_mode = 1; /* direct_page */
+            literal_mode = direct_page;
         } else if (lua_key_eq(l,direct)) {
-            literal_mode = 2; /* direct_always */
+            literal_mode = direct_always;
+        } else if (lua_key_eq(l,raw)) {
+            literal_mode = direct_raw;
         } else {
             luaL_error(L, "invalid literal mode in pdf.newcolorstack()");
         }
@@ -1065,6 +1093,24 @@
     return 1 ;
 }
 
+
+static int l_set_font_attributes(lua_State * L)
+{
+    int f = luaL_checkinteger(L, -2);
+    int i ;
+    /*char *s;*/
+    const char *st;
+    if ((lua_type(L,-1) == LUA_TSTRING) && (st = lua_tostring(L, -1)) != NULL) {
+        /* is this dup needed? */
+        /*s = xstrdup(st);*/
+        i = maketexstring(st); /* brrr */
+        set_pdf_font_attr(f, i);
+        /*free(s);*/
+    }
+    return 0;
+}
+
+
 static const struct luaL_Reg pdflib[] = {
     { "gethpos", l_gethpos },
     { "getvpos", l_getvpos },
@@ -1081,6 +1127,7 @@
     { "objtype", l_objtype },
     { "getmatrix", l_getmatrix },
     { "hasmatrix", l_hasmatrix },
+    { "setfontattributes", l_set_font_attributes },
     { "setcatalog", l_set_catalog },
     { "setinfo", l_set_info },
     { "setnames", l_set_names },
@@ -1121,11 +1168,14 @@
     { "fontsize", getpdffontsize },
     { "xformname", getpdfxformname },
     { "getversion", getpdfversion },
+    { "getcreationdate", getpdfcreationdate },
     { "getminorversion", getpdfminorversion },
     { "setminorversion", setpdfminorversion },
     { "newcolorstack", newpdfcolorstack },
     { "setorigin", setpdforigin },
     { "getorigin", getpdforigin },
+    { "setimageresolution", setpdfimageresolution },
+    { "getimageresolution", getpdfimageresolution },
     { "setthreadmargin", setpdfthreadmargin },
     { "setdestmargin", setpdfdestmargin },
     { "setlinkmargin", setpdflinkmargin },
--- texlive-bin.orig/texk/web2c/luatexdir/lua/lpdfscannerlib.cc
+++ texlive-bin/texk/web2c/luatexdir/lua/lpdfscannerlib.cc
@@ -105,17 +105,17 @@
 static Token *_parseToken (scannerdata *self, int c);
 static void push_token (lua_State *L, scannerdata *self);
 
-void *xmalloc (size_t size)
+static void *priv_xmalloc (size_t size)
 {
     void *new_mem = (void *)malloc(size);
     if (new_mem == NULL) {
-        fprintf(stderr, "fatal: memory exhausted (xmalloc of %lu bytes).\n", (unsigned long)size);
+        fprintf(stderr, "fatal: memory exhausted (priv_xmalloc of %lu bytes).\n", (unsigned long)size);
         exit(1);
     }
     return new_mem;
 }
 
-void *xrealloc (void *old_ptr, size_t size)
+static void *priv_xrealloc (void *old_ptr, size_t size)
 {
     void *new_mem = (void *)realloc(old_ptr, size);
     if (new_mem == NULL) {
@@ -125,12 +125,12 @@
     return new_mem;
 }
 
-#define xreallocarray(ptr,type,size) ((type*)xrealloc(ptr,(size+1)*sizeof(type)))
+#define xreallocarray(ptr,type,size) ((type*)priv_xrealloc(ptr,(size+1)*sizeof(type)))
 
 #define INITBUFSIZE 64
 
 #define define_buffer(a)				\
-  char *a = (char *)xmalloc (INITBUFSIZE);		\
+  char *a = (char *)priv_xmalloc (INITBUFSIZE);		\
   int a##_size = INITBUFSIZE;				\
   int a##index = 0;					\
   memset (a,0,INITBUFSIZE)
@@ -194,7 +194,7 @@
 
 static Token * new_operand (pdf_token_type c)
 {
-  Token *token = (Token *)xmalloc(sizeof(Token));
+  Token *token = (Token *)priv_xmalloc(sizeof(Token));
   memset (token, 0, sizeof(Token));
   token->type = c;
   return token;
@@ -586,7 +586,7 @@
   luaL_checktype(L, 3, LUA_TTABLE);
   self = scanner_push(L);
   memset(self,0,sizeof(scannerdata));
-  self->_operandstack = (Token **)xmalloc (MAXOPERANDS * sizeof (Token));
+  self->_operandstack = (Token **)priv_xmalloc (MAXOPERANDS * sizeof (Token));
   memset (self->_operandstack,0,(MAXOPERANDS * sizeof (Token)));
   // 4 = self
   if (lua_type(L,1)== LUA_TTABLE) {
@@ -598,7 +598,7 @@
 	uin = (udstruct *) luaL_checkudata(L, -1, M_Object);
 	if (((Object *) uin->d)->isStream()) {
 	  ObjectList *rover = self->_streams;
-	  ObjectList *item = (ObjectList *)xmalloc (sizeof(ObjectList));
+	  ObjectList *item = (ObjectList *)priv_xmalloc (sizeof(ObjectList));
 	  item->stream = ((Object *) uin->d);
 	  item->next = NULL;
 	  if (!rover) {
@@ -637,7 +637,7 @@
 	arrayref->get(i, val);
 	if (val->isStream()) {
 	  ObjectList *rover = self->_streams;
-	  ObjectList *item = (ObjectList *)xmalloc (sizeof(ObjectList));
+	  ObjectList *item = (ObjectList *)priv_xmalloc (sizeof(ObjectList));
 	  item->stream = val;
 	  item->next = NULL;
 	  if (!rover) {
--- texlive-bin.orig/texk/web2c/luatexdir/lua/ltexlib.c
+++ texlive-bin/texk/web2c/luatexdir/lua/ltexlib.c
@@ -24,14 +24,6 @@
 #include "ptexlib.h"
 #include "lua/luatex-api.h"
 
-#define attribute(A) eqtb[attribute_base+(A)].hh.rh
-#define dimen(A) eqtb[scaled_base+(A)].hh.rh
-#undef skip
-#define skip(A) eqtb[skip_base+(A)].hh.rh
-#define mu_skip(A) eqtb[mu_skip_base+(A)].hh.rh
-#define count(A) eqtb[count_base+(A)].hh.rh
-#define box(A) equiv(box_base+(A))
-
 /* tex random generators */
 extern int unif_rand(int );
 extern int norm_rand(void );
@@ -541,7 +533,7 @@
         v = (x_height(get_cur_font()));
     } else if (strncmp(s, "px", 2) == 0) {
         s += 2;
-        v = dimen_par(px_dimen_code);
+        v = px_dimen_par;
     } else {
         goto NOT_FOUND;
     }
@@ -560,11 +552,11 @@
     if (strncmp(s, "true", 4) == 0) {
         /* Adjust (f)for the magnification ratio */
         s += 4;
-        if (output_mode_used == OMODE_DVI) {
+        if (output_mode_used <= OMODE_DVI) {
             prepare_mag();
-            if (int_par(mag_code) != 1000) {
-                cur_val = xn_over_d(cur_val, 1000, int_par(mag_code));
-                f = (1000 * f + 0200000 * tex_remainder) / int_par(mag_code);
+            if (mag_par != 1000) {
+                cur_val = xn_over_d(cur_val, 1000, mag_par);
+                f = (1000 * f + 0200000 * tex_remainder) / mag_par;
                 cur_val = cur_val + (f / 0200000);
                 f = f % 0200000;
             }
@@ -661,7 +653,7 @@
     int sp;
     int t = lua_type(L, 1);
     if (t == LUA_TNUMBER) {
-        sp = lua_tointeger(L, 1);
+        sp = lua_roundnumber(L, 1);
     } else if (t == LUA_TSTRING) {
         sp = dimen_to_number(L, lua_tostring(L, 1));
     } else {
@@ -749,9 +741,9 @@
     size_t len;                                                                       \
     const char *str;                                                                  \
     int key, err, cs;                                                                 \
-    int save_global_defs = int_par(global_defs_code);                                 \
+    int save_global_defs = global_defs_par;                                           \
     if (is_global) {                                                                  \
-        int_par(global_defs_code) = 1;                                                \
+        global_defs_par = 1;                                                          \
     }                                                                                 \
     switch (lua_type(L, where)) {                                                     \
         case LUA_TSTRING:                                                             \
@@ -779,7 +771,7 @@
             }                                                                         \
             break;                                                                    \
         case LUA_TNUMBER:                                                             \
-            key = luaL_checkinteger(L, where);                                  \
+            key = luaL_checkinteger(L, where);                                        \
             if (key>=0 && key <= 65535) {                                             \
                 err = set_register(key, value);                                       \
                 if (err) {                                                            \
@@ -792,7 +784,7 @@
         default:                                                                      \
             luaL_error(L, "argument of 'set%s' must be a string or a number", what);  \
     }                                                                                 \
-    int_par(global_defs_code) = save_global_defs;                                     \
+    global_defs_par = save_global_defs;                                               \
 }
 
 static int gettex(lua_State * L);
@@ -844,7 +836,7 @@
     int t = lua_type(L, top);
     check_item_global(L,top,isglobal);
     if (t == LUA_TNUMBER) {
-        value = lua_tointeger(L, top);
+        value = lua_roundnumber(L, top);
     } else if (t == LUA_TSTRING) {
         value = dimen_to_number(L, lua_tostring(L, top));
     } else {
@@ -903,13 +895,13 @@
     }
     /* [global] slot [width] [stretch] [shrink] [stretch_order] [shrink_order] */
     if (top > 1) {
-        width(value) = lua_tointeger(L,index+1);
+        width(value) = lua_roundnumber(L,index+1);
     }
     if (top > 2) {
-        stretch(value) = lua_tointeger(L,index+2);
+        stretch(value) = lua_roundnumber(L,index+2);
     }
     if (top > 3) {
-        shrink(value) = lua_tointeger(L,index+3);
+        shrink(value) = lua_roundnumber(L,index+3);
     }
     if (top > 4) {
         stretch_order(value) = lua_tointeger(L,index+4);
@@ -975,13 +967,13 @@
     }
     /* [global] slot [width] [stretch] [shrink] [stretch_order] [shrink_order] */
     if (top > 1) {
-        width(value) = lua_tointeger(L,index+1);
+        width(value) = lua_roundnumber(L,index+1);
     }
     if (top > 2) {
-        stretch(value) = lua_tointeger(L,index+2);
+        stretch(value) = lua_roundnumber(L,index+2);
     }
     if (top > 3) {
-        shrink(value) = lua_tointeger(L,index+3);
+        shrink(value) = lua_roundnumber(L,index+3);
     }
     if (top > 4) {
         stretch_order(value) = lua_tointeger(L,index+4);
@@ -1088,7 +1080,7 @@
     char *s;
     const char *ss;
     int is_global = 0;
-    int save_global_defs = int_par(global_defs_code);
+    int save_global_defs = global_defs_par;
     int n = lua_gettop(L);
     if (n == 3 && (lua_type(L,1) == LUA_TSTRING)) {
         const char *s = lua_tostring(L, 1);
@@ -1096,7 +1088,7 @@
             is_global = 1;
     }
     if (is_global)
-        int_par(global_defs_code) = 1;
+        global_defs_par = 1;
     i = lua_gettop(L);
     if (lua_type(L,i) != LUA_TSTRING) {
         luaL_error(L, "unsupported value type");
@@ -1109,7 +1101,7 @@
     check_index_range(k, "settoks");
     err = set_tex_toks_register(k, str);
     xfree(str.s);
-    int_par(global_defs_code) = save_global_defs;
+    global_defs_par = save_global_defs;
     if (err) {
         luaL_error(L, "incorrect value");
     }
@@ -1123,7 +1115,7 @@
     char *s;
     const char *ss;
     int is_global = 0;
-    int save_global_defs = int_par(global_defs_code);
+    int save_global_defs = global_defs_par;
     int n = lua_gettop(L);
     if (n == 4 && (lua_type(L,1) == LUA_TSTRING)) {
         const char *s = lua_tostring(L, 1);
@@ -1132,7 +1124,7 @@
     }
     /* action : vsettokscct(L, is_global); */
     if (is_global)
-        int_par(global_defs_code) = 1;
+        global_defs_par = 1;
     i = lua_gettop(L);
     if (lua_type(L,i) != LUA_TSTRING) {
         luaL_error(L, "unsupported value type");
@@ -1146,7 +1138,7 @@
     check_index_range(k, "settoks");
     err = scan_tex_toks_register(k, c, str);
     xfree(str.s);
-    int_par(global_defs_code) = save_global_defs;
+    global_defs_par = save_global_defs;
     if (err) {
         luaL_error(L, "incorrect value");
     }
@@ -1225,7 +1217,7 @@
         if ((m<0) || (m>1)) {
             luaL_error(L, "wrong mode in splitbox");
         }
-        nodelist_to_lua(L, vsplit(k,lua_tointeger(L,2),m));
+        nodelist_to_lua(L, vsplit(k,lua_roundnumber(L,2),m));
     } else {
         /* maybe a warning */
         lua_pushnil(L);
@@ -1243,9 +1235,9 @@
 static int vsetbox(lua_State * L, int is_global)
 {
     int j, k, err;
-    int save_global_defs = int_par(global_defs_code);
+    int save_global_defs = global_defs_par;
     if (is_global)
-        int_par(global_defs_code) = 1;
+        global_defs_par = 1;
     k = get_box_id(L, -2, true);
     check_index_range(k, "setbox");
     if (lua_isboolean(L, -1)) {
@@ -1263,7 +1255,7 @@
 
     }
     err = set_tex_box_register(k, j);
-    int_par(global_defs_code) = save_global_defs;
+    global_defs_par = save_global_defs;
     if (err) {
         luaL_error(L, "incorrect value");
     }
@@ -1361,7 +1353,7 @@
     int ch;
     halfword val;
     int level = cur_level;
-    int cattable = int_par(cat_code_table_code);
+    int cattable = cat_code_table_par;
     int n = lua_gettop(L);
     int f = 1;
     if (n>1 && lua_type(L,1) == LUA_TTABLE)
@@ -1386,7 +1378,7 @@
 
 static int getcatcode(lua_State * L)
 {
-    int cattable = int_par(cat_code_table_code);
+    int cattable = cat_code_table_par;
     int ch = luaL_checkinteger(L, -1);
     if (lua_gettop(L)>=2 && lua_type(L,-2)==LUA_TNUMBER) {
         cattable = luaL_checkinteger(L, -2);
@@ -1396,6 +1388,7 @@
     return 1;
 }
 
+/*
 
 static int setmathcode(lua_State * L)
 {
@@ -1434,6 +1427,52 @@
     return 0;
 }
 
+*/
+
+/*
+    [global] code { c f ch }
+    [global] code   c f ch   (a bit easier on memory, counterpart of getter)
+*/
+
+static int setmathcode(lua_State * L)
+{
+    int ch;
+    halfword cval, fval, chval;
+    int level = cur_level;
+    int f = 1;
+    if (lua_type(L,1) == LUA_TSTRING) {
+        const char *s = lua_tostring(L,1);
+        if (lua_key_eq(s,global)) {
+            level = level_one;
+            f = 2;
+        }
+    }
+    ch = luaL_checkinteger(L, f);
+    check_char_range(ch, "setmathcode", 65536*17);
+    f += 1 ;
+    if (lua_type(L,f) == LUA_TNUMBER) {
+        cval = luaL_checkinteger(L, f);
+        fval = luaL_checkinteger(L, f+1);
+        chval = luaL_checkinteger(L, f+2);
+    } else if (lua_type(L,f) == LUA_TTABLE) {
+        lua_rawgeti(L, f, 1);
+        cval = (halfword) luaL_checkinteger(L, -1);
+        lua_rawgeti(L, f, 2);
+        fval = (halfword) luaL_checkinteger(L, -1);
+        lua_rawgeti(L, f, 3);
+        chval = (halfword) luaL_checkinteger(L, -1);
+        lua_pop(L,3);
+    } else {
+        luaL_error(L, "Bad arguments for tex.setmathcode()");
+        return 0;
+    }
+    check_char_range(cval, "setmathcode", 8);
+    check_char_range(fval, "setmathcode", 256);
+    check_char_range(chval, "setmathcode", 65536*17);
+    set_math_code(ch, cval,fval, chval, (quarterword) (level));
+    return 0;
+}
+
 static int getmathcode(lua_State * L)
 {
     mathcodeval mval = { 0, 0, 0 };
@@ -1462,6 +1501,8 @@
     return 3;
 }
 
+/*
+
 static int setdelcode(lua_State * L)
 {
     int ch;
@@ -1502,6 +1543,56 @@
     return 0;
 }
 
+*/
+
+/*
+    [global] code { c f ch }
+    [global] code   c f ch   (a bit easier on memory, counterpart of getter)
+*/
+
+static int setdelcode(lua_State * L)
+{
+    int ch;
+    halfword sfval, scval, lfval, lcval;
+    int level = cur_level;
+    int f = 1;
+    if (lua_type(L,1) == LUA_TSTRING) {
+        const char *s = lua_tostring(L,1);
+        if (lua_key_eq(s,global)) {
+            level = level_one;
+            f = 2;
+        }
+    }
+    ch = luaL_checkinteger(L, f);
+    check_char_range(ch, "setdelcode", 65536*17);
+    f += 1;
+    if (lua_type(L,f) == LUA_TNUMBER) {
+        sfval = luaL_checkinteger(L, f);
+        scval = luaL_checkinteger(L, f+1);
+        lfval = luaL_checkinteger(L, f+2);
+        lcval = luaL_checkinteger(L, f+3);
+    } else if (lua_type(L,f) == LUA_TTABLE) {
+        lua_rawgeti(L, f, 1);
+        sfval = (halfword) luaL_checkinteger(L, -1);
+        lua_rawgeti(L, f, 2);
+        scval = (halfword) luaL_checkinteger(L, -1);
+        lua_rawgeti(L, f, 3);
+        lfval = (halfword) luaL_checkinteger(L, -1);
+        lua_rawgeti(L, f, 4);
+        lcval = (halfword) luaL_checkinteger(L, -1);
+        lua_pop(L,4);
+    } else {
+        luaL_error(L, "Bad arguments for tex.setdelcode()");
+        return 0;
+    }
+    check_char_range(sfval, "setdelcode", 256);
+    check_char_range(scval, "setdelcode", 65536*17);
+    check_char_range(lfval, "setdelcode", 256);
+    check_char_range(lcval, "setdelcode", 65536*17);
+    set_del_code(ch, sfval, scval, lfval, lcval, (quarterword) (level));
+    return 0;
+}
+
 static int getdelcode(lua_State * L)
 {
     delcodeval mval = { 0, 0, 0, 0, 0 };
@@ -1546,7 +1637,7 @@
         st = lua_tolstring(L, (i - 1), &k);
         if (lua_key_eq(st,prevdepth)) {
             if (lua_type(L, i) == LUA_TNUMBER) {
-                cur_list.prev_depth_field = lua_tointeger(L, i);
+                cur_list.prev_depth_field = lua_roundnumber(L, i);
             } else if (lua_type(L, i) == LUA_TSTRING) {
                 cur_list.prev_depth_field = dimen_to_number(L, lua_tostring(L, i));
             } else {
@@ -1562,7 +1653,7 @@
             return 0;
         } else if (lua_key_eq(st,spacefactor)) {
             if (lua_type(L, i) == LUA_TNUMBER) {
-                cur_list.space_factor_field = lua_tointeger(L, i);
+                cur_list.space_factor_field = lua_roundnumber(L, i);
             } else {
                 luaL_error(L, "unsupported value type");
             }
@@ -1587,7 +1678,7 @@
                 }
             } else if (is_dim_assign(cur_cmd1)) {
                 if (lua_type(L, i) == LUA_TNUMBER) {
-                    j = lua_tointeger(L, i);
+                    j = lua_roundnumber(L, i);
                 } else if (lua_type(L, i) == LUA_TSTRING) {
                     j = dimen_to_number(L, lua_tostring(L, i));
                 } else {
@@ -1804,7 +1895,7 @@
             k = *((halfword *)p);
             def_math_param(i, j, (scaled) k, l);
         } else if (lua_type(L, n) == LUA_TNUMBER) {
-            k = lua_tointeger(L, n);
+            k = lua_roundnumber(L, n);
             def_math_param(i, j, (scaled) k, l);
         } else {
             luaL_error(L, "argument must be a number");
@@ -1860,7 +1951,7 @@
 
 static int get_parshape(lua_State * L)
 {
-    halfword par_shape_ptr = equiv(par_shape_loc);
+    halfword par_shape_ptr = par_shape_par_ptr;
     if (par_shape_ptr != 0) {
         int m = 1;
         int n = vinfo(par_shape_ptr + 1);
@@ -2126,10 +2217,10 @@
         i = lua_tointeger(L, -1);
         r->ml_field = i;
     } else if (lua_key_eq(field,prevdepth)) {
-        i = lua_tointeger(L, -1);
+        i = lua_roundnumber(L, -1);
         r->prev_depth_field = i;
     } else if (lua_key_eq(field,spacefactor)) {
-        i = lua_tointeger(L, -1);
+        i = lua_roundnumber(L, -1);
         r->space_factor_field = i;
     } else if (lua_key_eq(field,noad)) {
         n = check_isnode(L, -1);
@@ -2491,11 +2582,11 @@
         if (lua_type(L, i) == LUA_TTABLE) {
             lua_rawgeti(L, -1, 1);      /* indent */
             if (lua_type(L, -1) == LUA_TNUMBER) {
-                indent = lua_tointeger(L, -1);
+                indent = lua_roundnumber(L, -1);
                 lua_pop(L, 1);
                 lua_rawgeti(L, -1, 2);  /* width */
                 if (lua_type(L, -1) == LUA_TNUMBER) {
-                    width = lua_tointeger(L, -1);
+                    width = lua_roundnumber(L, -1);
                     lua_pop(L, 1);
                     varmem[p + 2 * j].cint = indent;
                     varmem[p + 2 * j + 1].cint = width;
@@ -2591,27 +2682,27 @@
     }
     lua_pop(L, 1);
 
-    get_int_par  (pretolerance, int_par(pretolerance_code));
-    get_int_par  (tracingparagraphs, int_par(tracing_paragraphs_code));
-    get_int_par  (tolerance, int_par(tolerance_code));
-    get_int_par  (looseness, int_par(looseness_code));
-    get_int_par  (adjustspacing, int_par(adjust_spacing_code));
-    get_int_par  (adjdemerits, int_par(adj_demerits_code));
-    get_int_par  (protrudechars, int_par(protrude_chars_code));
-    get_int_par  (linepenalty, int_par(line_penalty_code));
-    get_int_par  (lastlinefit, int_par(last_line_fit_code));
-    get_int_par  (doublehyphendemerits, int_par(double_hyphen_demerits_code));
-    get_int_par  (finalhyphendemerits, int_par(final_hyphen_demerits_code));
-    get_int_par  (hangafter, int_par(hang_after_code));
-    get_intx_par (interlinepenalty,int_par(inter_line_penalty_code), interlinepenalties, equiv(inter_line_penalties_loc));
-    get_intx_par (clubpenalty, int_par(club_penalty_code), clubpenalties, equiv(club_penalties_loc));
-    get_intx_par (widowpenalty, int_par(widow_penalty_code), widowpenalties, equiv(widow_penalties_loc));
-    get_int_par  (brokenpenalty, int_par(broken_penalty_code));
-    get_dimen_par(emergencystretch, dimen_par(emergency_stretch_code));
-    get_dimen_par(hangindent, dimen_par(hang_indent_code));
-    get_dimen_par(hsize, dimen_par(hsize_code));
-    get_glue_par (leftskip, glue_par(left_skip_code));
-    get_glue_par (rightskip, glue_par(right_skip_code));
+    get_int_par  (pretolerance, pretolerance_par);
+    get_int_par  (tracingparagraphs, tracing_paragraphs_par);
+    get_int_par  (tolerance, tolerance_par);
+    get_int_par  (looseness, looseness_par);
+    get_int_par  (adjustspacing, adjust_spacing_par);
+    get_int_par  (adjdemerits, adj_demerits_par);
+    get_int_par  (protrudechars, protrude_chars_par);
+    get_int_par  (linepenalty, line_penalty_par);
+    get_int_par  (lastlinefit, last_line_fit_par);
+    get_int_par  (doublehyphendemerits, double_hyphen_demerits_par);
+    get_int_par  (finalhyphendemerits, final_hyphen_demerits_par);
+    get_int_par  (hangafter, hang_after_par);
+    get_intx_par (interlinepenalty,inter_line_penalty_par, interlinepenalties, equiv(inter_line_penalties_loc));
+    get_intx_par (clubpenalty, club_penalty_par, clubpenalties, equiv(club_penalties_loc));
+    get_intx_par (widowpenalty, widow_penalty_par, widowpenalties, equiv(widow_penalties_loc));
+    get_int_par  (brokenpenalty, broken_penalty_par);
+    get_dimen_par(emergencystretch, emergency_stretch_par);
+    get_dimen_par(hangindent, hang_indent_par);
+    get_dimen_par(hsize, hsize_par);
+    get_glue_par (leftskip, left_skip_par);
+    get_glue_par (rightskip, right_skip_par);
     ext_do_line_break(paragraph_dir,
                       pretolerance,
                       tracingparagraphs,
@@ -2743,7 +2834,7 @@
         luaL_error(L, "argument must be a number");
         return 0;
     }
-    sp = lua_tointeger(L, 1);
+    sp = lua_roundnumber(L, 1);
     init_randoms(sp);
     return 0;
 }
@@ -2755,7 +2846,7 @@
         luaL_error(L, "argument must be a number");
         return 0;
     }
-    sp = lua_tointeger(L, 1);
+    sp = lua_roundnumber(L, 1);
     lua_pushinteger(L, unif_rand(sp));
     return 1;
 }
@@ -2768,7 +2859,7 @@
 
 /* Same as lua but  with tex rng */
 
-  static int lua_math_random (lua_State *L)
+static int lua_math_random (lua_State *L)
 {
     lua_Number rand_max = 0x7fffffff ;
     lua_Number r =  unif_rand(rand_max) ;
@@ -2827,6 +2918,7 @@
     int index = null;
     int attributes = null;
     int resources = null;
+    int type = 0;
     boolean immediate = false;
     /* box attributes resources */
     halfword boxnumber = lua_tointeger(L,1);
@@ -2841,6 +2933,9 @@
     if (lua_type(L,4) == LUA_TBOOLEAN) {
         immediate = lua_toboolean(L, 4);
     }
+    if (lua_type(L,5) == LUA_TNUMBER) {
+        type = lua_tointeger(L, 5);
+    }
     /* more or less same as scanner variant */
     boxdata = box(boxnumber);
     if (boxdata == null)
@@ -2856,6 +2951,7 @@
     set_obj_xform_width(static_pdf, index, width(boxdata));
     set_obj_xform_height(static_pdf, index, height(boxdata));
     set_obj_xform_depth(static_pdf, index, depth(boxdata));
+    set_obj_xform_type(static_pdf, index, type);
     box(boxnumber) = null;
     last_saved_box_index = index;
     lua_pushinteger(L, index);
@@ -2882,13 +2978,13 @@
         alt.ht = null_flag;
         alt.dp = null_flag;
         if (lua_type(L,2) == LUA_TNUMBER) {
-            alt.wd = (scaled) lua_tointeger(L,2);
+            alt.wd = (scaled) lua_roundnumber(L,2);
         }
         if (lua_type(L,3) == LUA_TNUMBER) {
-            alt.ht = (scaled) lua_tointeger(L,3);
+            alt.ht = (scaled) lua_roundnumber(L,3);
         }
         if (lua_type(L,4) == LUA_TNUMBER) {
-            alt.dp = (scaled) lua_tointeger(L,4);
+            alt.dp = (scaled) lua_roundnumber(L,4);
         }
         /* sort of the same as backend */
         check_obj_type(static_pdf, obj_type_xform, index);
--- /dev/null
+++ texlive-bin/texk/web2c/luatexdir/lua/ltokenlib.c.old
@@ -0,0 +1,290 @@
+/* ltokenlib.c
+
+   Copyright 2006-2012 Taco Hoekwater <taco@luatex.org>
+
+   This file is part of LuaTeX.
+
+   LuaTeX is free software; you can redistribute it and/or modify it under
+   the terms of the GNU General Public License as published by the Free
+   Software Foundation; either version 2 of the License, or (at your
+   option) any later version.
+
+   LuaTeX is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License along
+   with LuaTeX; if not, see <http://www.gnu.org/licenses/>. */
+
+/* THIS IS THE OLD ONE, ONLY AS REFERENCE. WILL BE REMOVED */
+
+#include "ptexlib.h"
+#include "lua/luatex-api.h"
+
+
+#define  is_valid_token(L,i)  (lua_istable(L,i) && lua_rawlen(L,i)==3)
+#define  get_token_cmd(L,i)  lua_rawgeti(L,i,1)
+#define  get_token_chr(L,i)  lua_rawgeti(L,i,2)
+#define  get_token_cs(L,i)   lua_rawgeti(L,i,3)
+#define  is_active_string(s) (strlen((char *)s)>3 && *s==0xEF && *(s+1)==0xBF && *(s+2)==0xBF)
+
+
+static unsigned char *get_cs_text(int cs)
+{
+    if (cs == null_cs)
+        return (unsigned char *) xstrdup("\\csname\\endcsname");
+    else if ((cs_text(cs) < 0) || (cs_text(cs) >= str_ptr))
+        return (unsigned char *) xstrdup("");
+    else
+        return (unsigned char *) makecstring(cs_text(cs));
+}
+
+
+static int test_expandable(lua_State * L)
+{
+    int cmd = -1;
+    int t;
+    if (is_valid_token(L, -1)) {
+        get_token_cmd(L, -1);
+        t = lua_type(L, -1);
+        if (t == LUA_TNUMBER) {
+            cmd = (int) lua_tointeger(L, -1);
+        } else if (t == LUA_TSTRING) {
+            cmd = get_command_id(lua_tostring(L, -1));
+        }
+        if (cmd > max_command_cmd) {
+            lua_pushboolean(L, 1);
+        } else {
+            lua_pushboolean(L, 0);
+        }
+    } else {
+        lua_pushnil(L);
+    }
+    return 1;
+}
+
+
+static int test_protected(lua_State * L)
+{
+    int chr = -1;
+    int t;
+    if (is_valid_token(L, -1)) {
+        get_token_chr(L, -1);
+        t = lua_type(L, -1);
+        if (t == LUA_TNUMBER) {
+            chr = (int) lua_tointeger(L, -1);
+        } else if (t == LUA_TSTRING) {
+            chr = get_command_id(lua_tostring(L, -1));
+        }
+        if (token_info(token_link(chr)) == protected_token) {
+            lua_pushboolean(L, 1);
+        } else {
+            lua_pushboolean(L, 0);
+        }
+    } else {
+        lua_pushnil(L);
+    }
+    return 1;
+}
+
+static int test_activechar(lua_State * L)
+{
+    if (is_valid_token(L, -1)) {
+        unsigned char *s;
+        int cs = 0;
+        get_token_cs(L, -1);
+        if (lua_type(L, -1) == LUA_TNUMBER) {
+            cs = (int) lua_tointeger(L, -1);
+        }
+        lua_pop(L, 1);
+        if (cs != 0 && ((s = get_cs_text(cs)) != (unsigned char *) NULL)) {
+            if (is_active_string(s)) {
+                free(s);
+                lua_pushboolean(L, 1);
+                return 1;
+            }
+            free(s);
+        }
+    }
+    lua_pushboolean(L, 0);
+    return 1;
+}
+
+
+static int run_get_command_name(lua_State * L)
+{
+    int cs;
+    if (is_valid_token(L, -1)) {
+        get_token_cmd(L, -1);
+        if (lua_type(L, -1) == LUA_TNUMBER) {
+            cs = (int) lua_tointeger(L, -1);
+            lua_pushstring(L, command_names[cs].cmd_name);
+        } else {
+            lua_pushstring(L, "");
+        }
+    } else {
+        lua_pushnil(L);
+    }
+    return 1;
+}
+
+
+static int run_get_csname_name(lua_State * L)
+{
+    int cs /*, cmd*/;
+    unsigned char *s;
+    if (is_valid_token(L, -1)) {
+        get_token_cmd(L, -1);
+        /*
+        if (lua_type(L, -1) == LUA_TNUMBER) {
+            cmd = (int) lua_tointeger(L, -1);
+        }
+        */
+        lua_pop(L, 1);
+        cs = 0;
+        get_token_cs(L, -1);
+        if (lua_type(L, -1) == LUA_TNUMBER) {
+            cs = (int) lua_tointeger(L, -1);
+        }
+        lua_pop(L, 1);
+
+        if (cs != 0 && ((s = get_cs_text(cs)) != (unsigned char *) NULL)) {
+            if (is_active_string(s))
+                lua_pushstring(L, (char *) (s + 3));
+            else
+                lua_pushstring(L, (char *) s);
+        } else {
+            lua_pushstring(L, "");
+        }
+    } else {
+        lua_pushnil(L);
+    }
+    return 1;
+}
+
+static int run_get_command_id(lua_State * L)
+{
+    int cs = -1;
+    if (lua_type(L, -1) == LUA_TSTRING) {
+        cs = get_command_id(lua_tostring(L, -1));
+    }
+    lua_pushnumber(L, cs);
+    return 1;
+}
+
+
+static int run_get_csname_id(lua_State * L)
+{
+    const char *s;
+    size_t k, cs = 0;
+    if (lua_type(L, -1) == LUA_TSTRING) {
+        s = lua_tolstring(L, -1, &k);
+        cs = (size_t) string_lookup(s, k);
+    }
+    lua_pushnumber(L, (lua_Number) cs);
+    return 1;
+}
+
+
+void make_token_table(lua_State * L, int cmd, int chr, int cs)
+{
+    lua_createtable(L, 3, 0);
+    lua_pushnumber(L, cmd);
+    lua_rawseti(L, -2, 1);
+    lua_pushnumber(L, chr);
+    lua_rawseti(L, -2, 2);
+    lua_pushnumber(L, cs);
+    lua_rawseti(L, -2, 3);
+}
+
+static int run_get_next(lua_State * L)
+{
+    int save_nncs;
+    save_nncs = no_new_control_sequence;
+    no_new_control_sequence = 0;
+    get_next();
+    no_new_control_sequence = save_nncs;
+    make_token_table(L, cur_cmd, cur_chr, cur_cs);
+    return 1;
+}
+
+static int run_expand(lua_State * L)
+{
+    (void) L;
+    expand();
+    return 0;
+}
+
+
+static int run_lookup(lua_State * L)
+{
+    const char *s;
+    size_t l;
+    int cs, cmd, chr;
+    int save_nncs;
+    if (lua_type(L, -1) == LUA_TSTRING) {
+        s = lua_tolstring(L, -1, &l);
+        if (l > 0) {
+            save_nncs = no_new_control_sequence;
+            no_new_control_sequence = true;
+            cs = id_lookup((last + 1), (int) l);        /* cleans up the lookup buffer */
+            cs = string_lookup(s, l);
+            cmd = eq_type(cs);
+            chr = equiv(cs);
+            make_token_table(L, cmd, chr, cs);
+            no_new_control_sequence = save_nncs;
+            return 1;
+        }
+    }
+    lua_newtable(L);
+    return 1;
+}
+
+static int run_build(lua_State * L)
+{
+    int cmd, chr, cs;
+    if (lua_type(L, 1) == LUA_TNUMBER) {
+        cs = 0;
+        chr = (int) lua_tointeger(L, 1);
+        cmd = (int) luaL_optinteger(L, 2, get_char_cat_code(chr));
+        if (cmd == 0 || cmd == 9 || cmd == 14 || cmd == 15) {
+            fprintf(stdout,
+                    "\n\nluatex error: not a good token.\nCatcode %i can not be returned, so I replaced it by 12 (other)",
+                    (int) cmd);
+            error();
+            cmd = 12;
+        }
+        if (cmd == 13) {
+            cs = active_to_cs(chr, false);
+            cmd = eq_type(cs);
+            chr = equiv(cs);
+        }
+        make_token_table(L, cmd, chr, cs);
+        return 1;
+    } else {
+        return run_lookup(L);
+    }
+}
+
+
+static const struct luaL_Reg tokenlib[] = {
+    {"get_next", run_get_next},
+    {"expand", run_expand},
+    {"lookup", run_lookup},
+    {"create", run_build},
+    {"is_expandable", test_expandable},
+    {"is_activechar", test_activechar},
+    {"is_protected", test_protected},
+    {"csname_id", run_get_csname_id},
+    {"csname_name", run_get_csname_name},
+    {"command_name", run_get_command_name},
+    {"command_id", run_get_command_id},
+    {NULL, NULL}                /* sentinel */
+};
+
+int luaopen_oldtoken(lua_State * L)
+{
+    luaL_register(L, "oldtoken", tokenlib);
+    return 1;
+}
--- texlive-bin.orig/texk/web2c/luatexdir/lua/luainit.w
+++ texlive-bin/texk/web2c/luatexdir/lua/luainit.w
@@ -88,6 +88,7 @@
     "   --[no-]shell-escape           disable/enable system commands",
     "   --shell-restricted            restrict system commands to a list of commands given in texmf.cnf",
     "   --synctex=NUMBER              enable synctex",
+    "   --utc                         init time to UTC",
     "   --version                     display version and exit",
     "",
     "Alternate behaviour models can be obtained by special switches",
@@ -166,6 +167,10 @@
     return;
 }
 
+
+@ @c
+int kpse_init = -1;
+
 @ @c
 string input_name = NULL;
 
@@ -183,6 +188,7 @@
 
 int safer_option = 0;
 int nosocket_option = 0;
+int utc_option = 0;
 
 @ Reading the options.
 
@@ -212,6 +218,7 @@
     {"jithash", 1, 0, 0},
 #endif
     {"safer", 0, &safer_option, 1},
+    {"utc", 0, &utc_option, 1},
     {"nosocket", 0, &nosocket_option, 1},
     {"help", 0, 0, 0},
     {"ini", 0, &ini_version, 1},
@@ -468,26 +475,16 @@
             }
         }
 #ifdef WIN32
-    } else if (sargv[sargc-1] && sargv[sargc-1][0] != '-' &&
+    } else if (sargc > 1 && sargv[sargc-1] && sargv[sargc-1][0] != '-' &&
                sargv[sargc-1][0] != '\\') {
         if (sargv[sargc-1][0] == '&')
             dump_name = xstrdup(sargv[sargc-1] + 1);
         else  {
-            char *p;
             if (sargv[sargc-1][0] == '*')
                 input_name = xstrdup(sargv[sargc-1] + 1);
             else
                 input_name = xstrdup(sargv[sargc-1]);
             sargv[sargc-1] = normalize_quotes(input_name, "argument");
-            /* Same as
-                  input_name = (char *)xbasename(input_name);
-               but without cast const => non-const.  */
-            input_name += xbasename(input_name) - input_name;
-            p = strrchr(input_name, '.');
-            if (p != NULL && strcasecmp(p, ".tex") == 0)
-                *p = '\0';
-            if (!c_job_name)
-                c_job_name = normalize_quotes(input_name, "jobname");
         }
         if (safer_option)      /* --safer implies --nosocket */
             nosocket_option = 1;
@@ -573,6 +570,7 @@
 
     kpse_set_program_name(argv[0], user_progname);
     init_shell_escape();        /* set up 'restrictedshell' */
+    init_start_time();
     program_name_set = 1 ;
     if (recorderoption) {
         recorder_enabled = 1;
@@ -592,8 +590,10 @@
             TEX_format_default = concat(dump_name, DUMP_EXT);
     } else {
         /* For |dump_name| to be NULL is a bug.  */
-        if (!ini_version)
-            normal_error("luatex","no format given");
+        if (!ini_version) {
+          fprintf(stdout, "no format given, quitting\n");
+          exit(1);
+        }
     }
 }
 
@@ -854,8 +854,10 @@
 {
     char *given_file = NULL;
     char *banner;
-    int kpse_init;
+    /*int kpse_init;*/
     size_t len;
+    int starttime;
+    int utc;
     static char LC_CTYPE_C[] = "LC_CTYPE=C";
     static char LC_COLLATE_C[] = "LC_COLLATE=C";
     static char LC_NUMERIC_C[] = "LC_NUMERIC=C";
@@ -1032,6 +1034,25 @@
             }
         }
 
+        starttime = -1 ;
+        get_lua_number("texconfig", "start_time", &starttime);
+        if (starttime < 0) {
+            /*
+                We provide this one for compatibility reasons and therefore also in
+                uppercase.
+            */
+            get_lua_number("texconfig", "SOURCE_DATE_EPOCH", &starttime);
+        }
+        if (starttime >= 0) {
+            set_start_time(starttime);
+        }
+
+        utc = -1 ;
+        get_lua_boolean("texconfig", "use_utc_time", &utc);
+        if (utc >= 0 && utc <= 1) {
+            utc_option = utc;
+        }
+
         fix_dumpname();
     } else {
         if (luainit) {
--- texlive-bin.orig/texk/web2c/luatexdir/lua/luanode.w
+++ texlive-bin/texk/web2c/luatexdir/lua/luanode.w
@@ -28,109 +28,57 @@
 @ @c
 void lua_node_filter_s(int filterid, int extrainfo)
 {
-    lua_State *L = Luas;
     int callback_id = callback_defined(filterid);
-    int s_top = lua_gettop(L);
+    int s_top = lua_gettop(Luas);
     if (callback_id <= 0) {
-        lua_settop(L, s_top);
+        lua_settop(Luas, s_top);
         return;
     }
-    if (!get_callback(L, callback_id)) {
-        lua_settop(L, s_top);
+    if (!get_callback(Luas, callback_id)) {
+        lua_settop(Luas, s_top);
         return;
     }
-    lua_push_string_by_index(L,extrainfo); /* arg 1 */
-    if (lua_pcall(L, 1, 0, 0) != 0) {
-        fprintf(stdout, "error: %s\n", lua_tostring(L, -1));
-        lua_settop(L, s_top);
+    lua_push_string_by_index(Luas,extrainfo); /* arg 1 */
+    if (lua_pcall(Luas, 1, 0, 0) != 0) {
+        fprintf(stdout, "error: %s\n", lua_tostring(Luas, -1));
+        lua_settop(Luas, s_top);
         error();
         return;
     }
-    lua_settop(L, s_top);
+    lua_settop(Luas, s_top);
     return;
 }
 
 @ @c
-/*
-void lua_node_filter(int filterid, int extrainfo, halfword head_node, halfword * tail_node)
-{
-    halfword ret;
-    int a;
-    lua_State *L = Luas;
-    int s_top = lua_gettop(L);
-    int callback_id = callback_defined(filterid);
-    if (head_node == null || vlink(head_node) == null || callback_id <= 0) {
-	lua_settop(L, s_top);
-        return;
-    }
-    if (!get_callback(L, callback_id)) {
-        lua_settop(L, s_top);
-        return;
-    }
-    alink(vlink(head_node)) = null ;
-    nodelist_to_lua(L, vlink(head_node));
-    lua_push_group_code(L,extrainfo);
-    if (lua_pcall(L, 2, 1, 0) != 0) {
-        fprintf(stdout, "error: %s\n", lua_tostring(L, -1));
-        lua_settop(L, s_top);
-        error();
-        return;
-    }
-    if (lua_isboolean(L, -1)) {
-        if (lua_toboolean(L, -1) != 1) {
-            flush_node_list(vlink(head_node));
-            vlink(head_node) = null;
-        }
-    } else {
-        a = nodelist_from_lua(L);
-        try_couple_nodes(head_node,a);
-    }
-    lua_pop(L, 2);
-    if (fix_node_lists)
-        fix_node_list(head_node);
-    ret = vlink(head_node);
-    if (ret != null) {
-        while (vlink(ret) != null)
-            ret = vlink(ret);
-        *tail_node = ret;
-    } else {
-        *tail_node = head_node;
-    }
-    lua_settop(L, s_top);
-    return;
-}
-*/
-
 void lua_node_filter(int filterid, int extrainfo, halfword head_node, halfword * tail_node)
 {
     halfword start_node, start_done, last_node;
-    lua_State *L = Luas;
-    int s_top = lua_gettop(L);
+    int s_top = lua_gettop(Luas);
     int callback_id = callback_defined(filterid);
     if (head_node == null || callback_id <= 0) {
-        lua_settop(L, s_top);
+        lua_settop(Luas, s_top);
         return;
     }
     /* we start after head */
     start_node = vlink(head_node);
-    if (start_node == null || !get_callback(L, callback_id)) {
-        lua_settop(L, s_top);
+    if (start_node == null || !get_callback(Luas, callback_id)) {
+        lua_settop(Luas, s_top);
         return;
     }
     /* we make sure we have no prev */
     alink(start_node) = null ;
     /* the action */
-    nodelist_to_lua(L, start_node);
-    lua_push_group_code(L,extrainfo);
-    if (lua_pcall(L, 2, 1, 0) != 0) {
-        fprintf(stdout, "error: %s\n", lua_tostring(L, -1));
-        lua_settop(L, s_top);
+    nodelist_to_lua(Luas, start_node);
+    lua_push_group_code(Luas,extrainfo);
+    if (lua_pcall(Luas, 2, 1, 0) != 0) {
+        fprintf(stdout, "error: %s\n", lua_tostring(Luas, -1));
+        lua_settop(Luas, s_top);
         error();
         return;
     }
     /* the result */
-    if (lua_isboolean(L, -1)) {
-        if (lua_toboolean(L, -1) != 1) {
+    if (lua_isboolean(Luas, -1)) {
+        if (lua_toboolean(Luas, -1) != 1) {
             /* discard */
             flush_node_list(start_node);
             vlink(head_node) = null;
@@ -139,11 +87,11 @@
         }
     } else {
         /* append to old head */
-        start_done = nodelist_from_lua(L);
+        start_done = nodelist_from_lua(Luas);
         try_couple_nodes(head_node,start_done);
     }
     /* redundant as we set top anyway */
-    lua_pop(L, 2);
+    lua_pop(Luas, 2);
     /* find tail in order to update tail */
     start_node = vlink(head_node);
     if (start_node != null) {
@@ -168,7 +116,7 @@
         *tail_node = head_node;
     }
     /* clean up */
-    lua_settop(L, s_top);
+    lua_settop(Luas, s_top);
     return;
 }
 
@@ -178,33 +126,32 @@
     int a;
     register halfword *p;
     int ret = 0;                /* failure */
-    lua_State *L = Luas;
-    int s_top = lua_gettop(L);
+    int s_top = lua_gettop(Luas);
     int callback_id = callback_defined(linebreak_filter_callback);
     if (head_node == null || vlink(head_node) == null || callback_id <= 0) {
-        lua_settop(L, s_top);
+        lua_settop(Luas, s_top);
         return ret;
     }
-    if (!get_callback(L, callback_id)) {
-       lua_settop(L, s_top);
+    if (!get_callback(Luas, callback_id)) {
+       lua_settop(Luas, s_top);
         return ret;
     }
     alink(vlink(head_node)) = null ; /* hh-ls */
-    nodelist_to_lua(L, vlink(head_node));       /* arg 1 */
-    lua_pushboolean(L, is_broken);      /* arg 2 */
-    if (lua_pcall(L, 2, 1, 0) != 0) {   /* no arg, 1 result */
-        fprintf(stdout, "error: %s\n", lua_tostring(L, -1));
-        lua_settop(L, s_top);
+    nodelist_to_lua(Luas, vlink(head_node));       /* arg 1 */
+    lua_pushboolean(Luas, is_broken);      /* arg 2 */
+    if (lua_pcall(Luas, 2, 1, 0) != 0) {   /* no arg, 1 result */
+        fprintf(stdout, "error: %s\n", lua_tostring(Luas, -1));
+        lua_settop(Luas, s_top);
         error();
         return ret;
     }
-    p = lua_touserdata(L, -1);
+    p = lua_touserdata(Luas, -1);
     if (p != NULL) {
-        a = nodelist_from_lua(L);
+        a = nodelist_from_lua(Luas);
         try_couple_nodes(*new_head,a);
         ret = 1;
     }
-    lua_settop(L, s_top);
+    lua_settop(Luas, s_top);
     return ret;
 }
 
@@ -212,39 +159,38 @@
 int lua_appendtovlist_callback(halfword box, int location, halfword prev_depth, boolean is_mirrored, halfword * result, int * next_depth, boolean * prev_set)
 {
     register halfword *p;
-    lua_State *L = Luas;
-    int s_top = lua_gettop(L);
+    int s_top = lua_gettop(Luas);
     int callback_id = callback_defined(append_to_vlist_filter_callback);
     if (box == null || callback_id <= 0) {
-        lua_settop(L, s_top);
+        lua_settop(Luas, s_top);
         return 0;
     }
-    if (!get_callback(L, callback_id)) {
-        lua_settop(L, s_top);
+    if (!get_callback(Luas, callback_id)) {
+        lua_settop(Luas, s_top);
         return 0;
     }
-    nodelist_to_lua(L, box);
-    lua_push_string_by_index(L,location);
-    lua_pushinteger(L, (int) prev_depth);
-    lua_pushboolean(L, is_mirrored);
-    if (lua_pcall(L, 4, 2, 0) != 0) {
-        fprintf(stdout, "error: %s\n", lua_tostring(L, -1));
-        lua_settop(L, s_top);
+    nodelist_to_lua(Luas, box);
+    lua_push_string_by_index(Luas,location);
+    lua_pushinteger(Luas, (int) prev_depth);
+    lua_pushboolean(Luas, is_mirrored);
+    if (lua_pcall(Luas, 4, 2, 0) != 0) {
+        fprintf(stdout, "error: %s\n", lua_tostring(Luas, -1));
+        lua_settop(Luas, s_top);
         error();
         return 0;
     }
-    if (lua_type(L,-1) == LUA_TNUMBER) {
-        *next_depth = lua_tointeger(L,-1);
+    if (lua_type(Luas,-1) == LUA_TNUMBER) {
+        *next_depth = lua_roundnumber(Luas,-1);
         *prev_set = true;
-        if (lua_type(L, -2) != LUA_TNIL) {
-            p = check_isnode(L, -2);
+        if (lua_type(Luas, -2) != LUA_TNIL) {
+            p = check_isnode(Luas, -2);
             *result = *p;
         }
-    } else if (lua_type(L, -1) != LUA_TNIL) {
-        p = check_isnode(L, -1);
+    } else if (lua_type(Luas, -1) != LUA_TNIL) {
+        p = check_isnode(Luas, -1);
         *result = *p;
     }
-    lua_settop(L, s_top);
+    lua_settop(Luas, s_top);
     return 1;
 }
 
@@ -252,50 +198,49 @@
 halfword lua_hpack_filter(halfword head_node, scaled size, int pack_type, int extrainfo, int pack_direction, halfword attr)
 {
     halfword ret;
-    lua_State *L = Luas;
-    int s_top = lua_gettop(L);
+    int s_top = lua_gettop(Luas);
     int callback_id = callback_defined(hpack_filter_callback);
     if (head_node == null || callback_id <= 0) {
-        lua_settop(L, s_top);
+        lua_settop(Luas, s_top);
         return head_node;
     }
-    if (!get_callback(L, callback_id)) {
-        lua_settop(L, s_top);
+    if (!get_callback(Luas, callback_id)) {
+        lua_settop(Luas, s_top);
         return head_node;
     }
     alink(head_node) = null ; /* hh-ls */
-    nodelist_to_lua(L, head_node);
-    lua_push_group_code(L,extrainfo);
-    lua_pushinteger(L, size);
-    lua_push_pack_type(L,pack_type);
+    nodelist_to_lua(Luas, head_node);
+    lua_push_group_code(Luas,extrainfo);
+    lua_pushinteger(Luas, size);
+    lua_push_pack_type(Luas, pack_type);
     if (pack_direction >= 0) {
-        lua_push_dir_par(L, pack_direction);
+        lua_push_dir_par(Luas, pack_direction);
     } else {
-        lua_pushnil(L);
+        lua_pushnil(Luas);
     }
     if (attr != null) {
-        nodelist_to_lua(L, attr);
+        nodelist_to_lua(Luas, attr);
     } else {
-        lua_pushnil(L);
+        lua_pushnil(Luas);
     }
-    if (lua_pcall(L, 6, 1, 0) != 0) {
-        fprintf(stdout, "error: %s\n", lua_tostring(L, -1));
-        lua_settop(L, s_top);
+    if (lua_pcall(Luas, 6, 1, 0) != 0) {
+        fprintf(stdout, "error: %s\n", lua_tostring(Luas, -1));
+        lua_settop(Luas, s_top);
         error();
         return head_node;
     }
     ret = head_node;
-    if (lua_isboolean(L, -1)) {
-        if (lua_toboolean(L, -1) != 1) {
+    if (lua_isboolean(Luas, -1)) {
+        if (lua_toboolean(Luas, -1) != 1) {
             flush_node_list(head_node);
             ret = null;
         }
     } else {
-        ret = nodelist_from_lua(L);
+        ret = nodelist_from_lua(Luas);
     }
-    lua_settop(L, s_top);
+    lua_settop(Luas, s_top);
 #if 0
-    lua_gc(L,LUA_GCSTEP, LUA_GC_STEP_SIZE);
+    lua_gc(Luas,LUA_GCSTEP, LUA_GC_STEP_SIZE);
 #endif
     if (fix_node_lists)
         fix_node_list(ret);
@@ -308,10 +253,9 @@
 {
     halfword ret;
     int callback_id;
-    lua_State *L = Luas;
-    int s_top = lua_gettop(L);
+    int s_top = lua_gettop(Luas);
     if (head_node == null) {
-        lua_settop(L, s_top);
+        lua_settop(Luas, s_top);
         return head_node;
     }
     if  (extrainfo == 8)  { /* output */
@@ -320,47 +264,47 @@
         callback_id = callback_defined(vpack_filter_callback);
     }
     if (callback_id <= 0) {
-        lua_settop(L, s_top);
+        lua_settop(Luas, s_top);
         return head_node;
     }
-    if (!get_callback(L, callback_id)) {
-        lua_settop(L, s_top);
+    if (!get_callback(Luas, callback_id)) {
+        lua_settop(Luas, s_top);
         return head_node;
     }
     alink(head_node) = null ; /* hh-ls */
-    nodelist_to_lua(L, head_node);
-    lua_push_group_code(L,extrainfo);
-    lua_pushinteger(L, size);
-    lua_push_pack_type(L,pack_type);
-    lua_pushinteger(L, maxd);
+    nodelist_to_lua(Luas, head_node);
+    lua_push_group_code(Luas, extrainfo);
+    lua_pushinteger(Luas, size);
+    lua_push_pack_type(Luas, pack_type);
+    lua_pushinteger(Luas, maxd);
     if (pack_direction >= 0) {
-         lua_push_dir_par(L, pack_direction);
+         lua_push_dir_par(Luas, pack_direction);
     } else {
-        lua_pushnil(L);
+        lua_pushnil(Luas);
     }
     if (attr != null) {
-        nodelist_to_lua(L, attr);
+        nodelist_to_lua(Luas, attr);
     } else {
-        lua_pushnil(L);
+        lua_pushnil(Luas);
     }
-    if (lua_pcall(L, 7, 1, 0) != 0) {
-        fprintf(stdout, "error: %s\n", lua_tostring(L, -1));
-        lua_settop(L, s_top);
+    if (lua_pcall(Luas, 7, 1, 0) != 0) {
+        fprintf(stdout, "error: %s\n", lua_tostring(Luas, -1));
+        lua_settop(Luas, s_top);
         error();
         return head_node;
     }
     ret = head_node;
-    if (lua_isboolean(L, -1)) {
-        if (lua_toboolean(L, -1) != 1) {
+    if (lua_isboolean(Luas, -1)) {
+        if (lua_toboolean(Luas, -1) != 1) {
             flush_node_list(head_node);
             ret = null;
         }
     } else {
-        ret = nodelist_from_lua(L);
+        ret = nodelist_from_lua(Luas);
     }
-    lua_settop(L, s_top);
+    lua_settop(Luas, s_top);
 #if 0
-    lua_gc(L,LUA_GCSTEP, LUA_GC_STEP_SIZE);
+    lua_gc(Luas,LUA_GCSTEP, LUA_GC_STEP_SIZE);
 #endif
     if (fix_node_lists)
         fix_node_list(ret);
@@ -476,6 +420,9 @@
         case direct_always:
             tprint(" direct");
             break;
+        case direct_raw:
+            tprint(" raw");
+            break;
         default:
             confusion("literal2");
             break;
--- texlive-bin.orig/texk/web2c/luatexdir/lua/luatex-api.h
+++ texlive-bin/texk/web2c/luatexdir/lua/luatex-api.h
@@ -198,6 +198,7 @@
 extern char *startup_filename;
 extern int safer_option;
 extern int nosocket_option;
+extern int utc_option;
 
 extern char *last_source_name;
 extern int last_lineno;
@@ -585,6 +586,7 @@
 make_lua_key(font);\
 make_lua_key(fonts);\
 make_lua_key(format);\
+make_lua_key(fraction);\
 make_lua_key(fullname);\
 make_lua_key(global);\
 make_lua_key(glue);\
@@ -656,6 +658,7 @@
 make_lua_key(mathstyle);\
 make_lua_key(media);\
 make_lua_key(mid);\
+make_lua_key(middle);\
 make_lua_key(mode);\
 make_lua_key(modeline);\
 make_lua_key(name);\
@@ -680,6 +683,7 @@
 make_lua_key(objnum);\
 make_lua_key(oldmath);\
 make_lua_key(ordering);\
+make_lua_key(options);\
 make_lua_key(origin);\
 make_lua_key(output);\
 make_lua_key(overlay_accent);\
@@ -824,7 +828,8 @@
 make_lua_key(xyz_zoom);\
 make_lua_key(yoffset); \
 make_lua_key(yres); \
-make_lua_key(ysize)
+make_lua_key(ysize); \
+make_lua_key(__index)
 
 #define set_init_keys \
 init_lua_key(cmdname);init_lua_key(expandable);init_lua_key(protected);\
@@ -948,6 +953,7 @@
 init_lua_key(font);\
 init_lua_key(fonts);\
 init_lua_key(format);\
+init_lua_key(fraction);\
 init_lua_key(fullname);\
 init_lua_key(global);\
 init_lua_key(glue);\
@@ -1017,6 +1023,7 @@
 init_lua_key(mathstyle);\
 init_lua_key(media);\
 init_lua_key(mid);\
+init_lua_key(middle);\
 init_lua_key(mode);\
 init_lua_key(modeline);\
 init_lua_key(name);\
@@ -1038,6 +1045,7 @@
 init_lua_key(objcompression);\
 init_lua_key(objnum);\
 init_lua_key(oldmath);\
+init_lua_key(options);\
 init_lua_key(origin);\
 init_lua_key(ordering);\
 init_lua_key(output);\
@@ -1178,10 +1186,12 @@
 init_lua_key(yoffset);\
 init_lua_key(yres);\
 init_lua_key(ysize);\
+init_lua_key(__index);\
 init_lua_key_alias(empty_string,"");\
 init_lua_key_alias(lua_bytecodes_indirect,"lua.bytecodes.indirect");\
 init_lua_key_alias(lua_functions,"lua.functions");\
 init_lua_key_alias(luatex_node, "luatex.node");\
+init_lua_key_alias(luatex_token, "luatex.token");\
 init_lua_key_alias(mLTL,"-LTL");\
 init_lua_key_alias(mRTT,"-RTT");\
 init_lua_key_alias(mTLT,"-TLT");\
@@ -1359,6 +1369,7 @@
 use_lua_key(font);
 use_lua_key(fonts);
 use_lua_key(format);
+use_lua_key(fraction);
 use_lua_key(fullname);
 use_lua_key(global);
 use_lua_key(glue);
@@ -1430,6 +1441,7 @@
 use_lua_key(mathstyle);
 use_lua_key(media);
 use_lua_key(mid);
+use_lua_key(middle);
 use_lua_key(mode);
 use_lua_key(modeline);
 use_lua_key(name);
@@ -1453,6 +1465,7 @@
 use_lua_key(objcompression);
 use_lua_key(objnum);
 use_lua_key(oldmath);
+use_lua_key(options);
 use_lua_key(origin);
 use_lua_key(ordering);
 use_lua_key(output);
@@ -1599,3 +1612,4 @@
 use_lua_key(yoffset);
 use_lua_key(yres);
 use_lua_key(ysize);
+use_lua_key(__index);
--- texlive-bin.orig/texk/web2c/luatexdir/lua/luatoken.w
+++ texlive-bin/texk/web2c/luatexdir/lua/luatoken.w
@@ -113,6 +113,7 @@
     {"assign_mu_glue", assign_mu_glue_cmd, NULL},
     {"assign_font_dimen", assign_font_dimen_cmd, NULL},
     {"assign_font_int", assign_font_int_cmd, NULL},
+    {"assign_hang_indent", assign_hang_indent_cmd, NULL},
     {"set_aux", set_aux_cmd, NULL},
     {"set_prev_graf", set_prev_graf_cmd, NULL},
     {"set_page_dimen", set_page_dimen_cmd, NULL},
@@ -362,34 +363,33 @@
 
 static void do_get_token_lua(int callback_id)
 {
-    lua_State *L = Luas;
     while (1) {
-        if (!get_callback(L, callback_id)) {
+        if (!get_callback(Luas, callback_id)) {
             get_next();
-            lua_pop(L, 2);
+            lua_pop(Luas, 2);
             break;
         }
-        if (lua_pcall(L, 0, 1, 0) != 0) {
-            tex_error(lua_tostring(L, -1), NULL);
-            lua_pop(L, 2);
+        if (lua_pcall(Luas, 0, 1, 0) != 0) {
+            tex_error(lua_tostring(Luas, -1), NULL);
+            lua_pop(Luas, 2);
             break;
         }
-        if (lua_istable(L, -1)) {
-            lua_rawgeti(L, -1, 1);
-            if (lua_istable(L, -1)) {
+        if (lua_istable(Luas, -1)) {
+            lua_rawgeti(Luas, -1, 1);
+            if (lua_istable(Luas, -1)) {
                 int p, q, r;
                 size_t i, j;
-                lua_pop(L, 1);
+                lua_pop(Luas, 1);
                 r = get_avail();
                 p = r;
-                j = lua_rawlen(L, -1);
+                j = lua_rawlen(Luas, -1);
                 if (j > 0) {
                     for (i = 1; i <= j; i++) {
-                        lua_rawgeti(L, -1, (int) i);
-                        if (get_cur_cmd(L) || get_cur_cs(L)) {
+                        lua_rawgeti(Luas, -1, (int) i);
+                        if (get_cur_cmd(Luas) || get_cur_cs(Luas)) {
                             store_new_token(cur_tok);
                         }
-                        lua_pop(L, 1);
+                        lua_pop(Luas, 1);
                     }
                 }
                 if (p != r) {
@@ -399,23 +399,22 @@
                     cur_input.nofilter_field = true;
                     get_next();
                 } else {
-                    tex_error("error: illegal or empty token list returned",
-                              NULL);
+                    tex_error("error: illegal or empty token list returned", NULL);
                 }
-                lua_pop(L, 2);
+                lua_pop(Luas, 2);
                 break;
             } else {
-                lua_pop(L, 1);
-                if (get_cur_cmd(L) || get_cur_cs(L)) {
-                    lua_pop(L, 2);
+                lua_pop(Luas, 1);
+                if (get_cur_cmd(Luas) || get_cur_cs(Luas)) {
+                    lua_pop(Luas, 2);
                     break;
                 } else {
-                    lua_pop(L, 2);
+                    lua_pop(Luas, 2);
                     continue;
                 }
             }
         } else {
-            lua_pop(L, 2);
+            lua_pop(Luas, 2);
         }
     }
     return;
--- texlive-bin.orig/texk/web2c/luatexdir/luatex.c
+++ texlive-bin/texk/web2c/luatexdir/luatex.c
@@ -28,10 +28,10 @@
 
 #define TeX
 
-int luatex_version = 95;        /* \.{\\luatexversion}  */
+int luatex_version = 100;        /* \.{\\luatexversion}  */
 int luatex_revision = '0';      /* \.{\\luatexrevision}  */
-int luatex_date_info = 2016042515;     /* the compile date is now hardwired */
-const char *luatex_version_string = "0.95.0";
+int luatex_date_info = 2016092700;     /* the compile date is now hardwired */
+const char *luatex_version_string = "1.0.0";
 const char *engine_name = my_name;     /* the name of this engine */
 
 #include <kpathsea/c-ctype.h>
@@ -61,10 +61,6 @@
 #include <signal.h>             /* Catch interrupts.  */
 
 
-/* {tex,mf}d.h defines TeX, MF, INI, and other such symbols.
-   Unfortunately there's no way to get the banner into this code, so
-   just repeat the text.  */
-#define edit_var "TEXEDIT"
 
 /* Shell escape.
 
@@ -148,6 +144,88 @@
 /* Called from maininit.  Not static because also called from
    luatexdir/lua/luainit.c.  */
 
+/*
+    In order to avoid all kind of time code in the backend code we use a function.
+    The start time can be overloaded in several ways:
+
+    (1) By setting the environmment variable SOURCE_DATE_EPOCH. This will influence
+    the tex parameters, random seed, pdf timestamp and pdf id that is derived
+    from the time. This variable is consulted when the kpse library is enabled
+    which is analogue to other properties.
+
+    (2) By setting the texconfig.start_time variable (as with other variables
+    we use the internal name there). This has the same effect as (1) and is
+    provided for when kpse is not used to set these variables or when an overloaded
+    is wanted. This is analogue to other properties.
+
+    When an utc time is needed one can provide the flag --utc. This property is
+    independent of this time hackery. This flag has a corresponding texconfig
+    option use_utc_time.
+
+    To some extend a cleaner solution would be to have a flag that disables all
+    variable data in one go (like filenames and so) but we just follow the method
+    implemented in pdftex where primitives are used tod disable it.
+
+*/
+
+static int start_time = -1;
+
+int get_start_time(void) {
+    if (start_time < 0) {
+        start_time = time((time_t *) NULL);
+    }
+    return start_time;
+}
+
+/*
+    This one is called as part of the kpse initialization which only happens
+    when this library is enabled.
+*/
+#if defined(_MSC_VER)
+#define strtoull _strtoui64
+#endif
+
+void init_start_time(void) {
+    if (start_time < 0) {
+        unsigned long long epoch;
+        char *endptr;
+        /*
+            We don't really care how kpse sets up this variable but we prefer to
+            just use its abstract interface.
+        */
+     /* char *source_date_epoch = getenv("SOURCE_DATE_EPOCH"); */
+        char *source_date_epoch = kpse_var_value("SOURCE_DATE_EPOCH");
+        if (source_date_epoch && source_date_epoch != '\0' ) {
+            errno = 0;
+            epoch = strtoull(source_date_epoch, &endptr, 10);
+            if (epoch < 0 || *endptr != '\0' || errno != 0) {
+                epoch = 0;
+            }
+#if defined(_MSC_VER)
+            /* We avoid to crash if users test a large value which is not
+             * supported by Visual Studio 2010:
+             * a later time than 3001/01/01 20:59:59.
+             */
+            if (epoch > 32535291599ULL)
+                epoch = 32535291599ULL;
+#endif
+            start_time = epoch;
+        }
+    }
+}
+
+/*
+    This one is used to fetch a value from texconfig which can also be used to
+    set properties. This might come in handy when one has other ways to get date
+    info in the pdf file.
+*/
+
+void set_start_time(int s) {
+    if (s >= 0) {
+        start_time = s ;
+    }
+}
+
 void init_shell_escape(void)
 {
     if (shellenabledp < 0) {    /* --no-shell-escape on cmd line */
@@ -469,7 +547,10 @@
 #    endif
     av[0] = kpse_program_basename (av[0]);
     _setmaxstdio(2048);
+/*
+ *  We choose to crash for fatal errors
     SetErrorMode (SEM_FAILCRITICALERRORS | SEM_NOGPFAULTERRORBOX | SEM_NOOPENFILEERRORBOX);
+ */
     setmode(fileno(stdin), _O_BINARY);
 #  endif
 
@@ -858,8 +939,13 @@
 
 void get_date_and_time(int *minutes, int *day, int *month, int *year)
 {
-    time_t myclock = time((time_t *) 0);
-    struct tm *tmptr = localtime(&myclock);
+    time_t myclock = get_start_time();
+    struct tm *tmptr ;
+    if (utc_option) {
+        tmptr = gmtime(&myclock);
+    } else {
+        tmptr = localtime(&myclock);
+    }
 
     *minutes = tmptr->tm_hour * 60 + tmptr->tm_min;
     *day = tmptr->tm_mday;
@@ -933,8 +1019,13 @@
     ftime(&tb);
     return (tb.millitm + 1000 * tb.time);
 #else
-    time_t myclock = time((time_t *) NULL);
-    struct tm *tmptr = localtime(&myclock);
+    time_t myclock = get_start_time((time_t *) NULL);
+    struct tm *tmptr ;
+    if (utc_option) {
+        tmptr = gmtime(&myclock);
+    } else {
+        tmptr = localtime(&myclock);
+    }
     return (tmptr->tm_sec + 60 * (tmptr->tm_min + 60 * tmptr->tm_hour));
 #endif
 }
--- texlive-bin.orig/texk/web2c/luatexdir/luatexcallbackids.h
+++ texlive-bin/texk/web2c/luatexdir/luatexcallbackids.h
@@ -66,6 +66,7 @@
     process_rule_callback,
     insert_local_par_callback,
     contribute_filter_callback,
+    call_edit_callback,
     total_callbacks
 } callback_callback_types;
 
--- texlive-bin.orig/texk/web2c/luatexdir/luatex.h
+++ texlive-bin/texk/web2c/luatexdir/luatex.h
@@ -71,6 +71,11 @@
 /* Executing shell commands.  */
 extern void mk_shellcmdlist(char *);
 extern void init_shell_escape(void);
+extern void init_start_time(void);
+extern int get_start_time(void);
+extern void set_start_time(int);
+extern boolean get_start_time(void);
+
 extern int shell_cmd_is_allowed(const char *cmd, char **safecmd,
                                 char **cmdname);
 
--- texlive-bin.orig/texk/web2c/luatexdir/pdf/pdfannot.w
+++ texlive-bin/texk/web2c/luatexdir/pdf/pdfannot.w
@@ -22,8 +22,6 @@
 #include "ptexlib.h"
 
 @ @c
-#define tail cur_list.tail_field
-
 void do_annot(PDF pdf, halfword p, halfword parent_box, scaledpos cur)
 {
     scaled_whd alt_rule;
@@ -52,15 +50,15 @@
     scaled_whd alt_rule;
     new_whatsit(w);
     alt_rule = scan_alt_rule(); /* scans |<rule spec>| to |alt_rule| */
-    set_width(tail, alt_rule.wd);
-    set_height(tail, alt_rule.ht);
-    set_depth(tail, alt_rule.dp);
+    set_width(tail_par, alt_rule.wd);
+    set_height(tail_par, alt_rule.ht);
+    set_depth(tail_par, alt_rule.dp);
     if ((w == pdf_thread_node) || (w == pdf_start_thread_node)) {
         if (scan_keyword("attr")) {
             scan_toks(false, true);
-            set_pdf_thread_attr(tail, def_ref);
+            set_pdf_thread_attr(tail_par, def_ref);
         } else {
-            set_pdf_thread_attr(tail, null);
+            set_pdf_thread_attr(tail_par, null);
         }
     }
 }
@@ -87,10 +85,10 @@
             k = pdf_create_obj(pdf, obj_type_annot, 0);
         }
         new_annot_whatsit(pdf_annot_node);
-        obj_annot_ptr(pdf, k) = tail;
-        set_pdf_annot_objnum(tail, k);
+        obj_annot_ptr(pdf, k) = tail_par;
+        set_pdf_annot_objnum(tail_par, k);
         scan_toks(false, true);
-        set_pdf_annot_data(tail, def_ref);
+        set_pdf_annot_data(tail_par, def_ref);
     }
     pdf_last_annot = k;
 }
--- texlive-bin.orig/texk/web2c/luatexdir/pdf/pdfcolorstack.w
+++ texlive-bin/texk/web2c/luatexdir/pdf/pdfcolorstack.w
@@ -47,9 +47,6 @@
 */
 
 #define COLOR_DEFAULT "0 g 0 G"
-#define SET_ORIGIN    0
-#define DIRECT_PAGE   1
-#define DIRECT_ALWAYS 2
 
 typedef struct {
     char **page_stack;
@@ -89,7 +86,7 @@
     colstacks[0].page_current = xstrdup(COLOR_DEFAULT);
     colstacks[0].form_current = xstrdup(COLOR_DEFAULT);
     colstacks[0].form_init = xstrdup(COLOR_DEFAULT);
-    colstacks[0].literal_mode = DIRECT_ALWAYS;
+    colstacks[0].literal_mode = direct_always;
     colstacks[0].page_start = true;
 }
 
--- texlive-bin.orig/texk/web2c/luatexdir/pdf/pdfgen.h
+++ texlive-bin/texk/web2c/luatexdir/pdf/pdfgen.h
@@ -27,8 +27,8 @@
 #  define PROCSET_IMAGE_C (1 << 3)
 #  define PROCSET_IMAGE_I (1 << 4)
 
-#  define inf_pdf_mem_size    10000 /* min size of the |mem| array */
-#  define sup_pdf_mem_size 10000000 /* max size of the |mem| array */
+#  define inf_pdf_mem_size     10000 /* min size of the |mem| array */
+#  define sup_pdf_mem_size 100000000 /* max size of the |mem| array */
 
 extern PDF static_pdf;
 
@@ -43,10 +43,10 @@
 
 */
 
-#  define inf_pdfout_buf_size   16384  /* initial value of |pdf->buf| size */
-#  define sup_pdfout_buf_size   16384  /* arbitrary upper hard limit of |pdf->buf| size */
-#  define inf_objstm_buf_size       1  /* initial value of |os->buf[OBJSTM_BUF]| size */
-#  define sup_objstm_buf_size 5000000  /* arbitrary upper hard limit of |os->buf[OBJSTM_BUF]| size */
+#  define inf_pdfout_buf_size     16384 /* initial value of |pdf->buf| size */
+#  define sup_pdfout_buf_size   8*16384 /* arbitrary upper hard limit of |pdf->buf| size */
+#  define inf_objstm_buf_size         1 /* initial value of |os->buf[OBJSTM_BUF]| size */
+#  define sup_objstm_buf_size   5000000 /* arbitrary upper hard limit of |os->buf[OBJSTM_BUF]| size */
 
 #  define PDF_OS_MAX_OBJS         100  /* maximum number of objects in object stream */
 
@@ -188,7 +188,7 @@
 
 extern char *convertStringToPDFString(const char *in, int len);
 
-extern void init_start_time(PDF);
+extern void initialize_start_time(PDF);
 extern char *getcreationdate(PDF);
 
 extern void check_o_mode(PDF pdf, const char *s, int o_mode, boolean errorflag);
--- texlive-bin.orig/texk/web2c/luatexdir/pdf/pdfgen.w
+++ texlive-bin/texk/web2c/luatexdir/pdf/pdfgen.w
@@ -26,8 +26,6 @@
 #include "lua/luatex-api.h"
 #include "md5.h"
 
-#define is_hex_char isxdigit
-
 #define check_nprintf(size_get, size_want) \
     if ((unsigned)(size_get) >= (unsigned)(size_want)) \
         formatted_error("pdf backend","snprintf() failed in file %s at line %d", __FILE__, __LINE__);
@@ -50,6 +48,7 @@
 halfword pdf_trailer_toks;                           /* additional keys of Trailer dictionary */
 shipping_mode_e global_shipping_mode = NOT_SHIPPING; /* set to |shipping_mode| when |ship_out| starts */
 
+
 @ Create a new buffer |strbuf_s| of size |size| and maximum allowed size |limit|.
 Initialize it and set |p| to begin of data.
 
@@ -245,7 +244,7 @@
 output_mode get_o_mode(void)
 {
     output_mode o_mode;
-    if (int_par(output_mode_code) > 0) {
+    if (output_mode_par > 0) {
         o_mode = OMODE_PDF;
     } else
         o_mode = OMODE_DVI;
@@ -285,9 +284,13 @@
         /* Check that variables for \.{PDF} output are unchanged */
         if (pdf->minor_version != pdf_minor_version)
             normal_error("pdf backend", "minorversion cannot be changed after data is written to the PDF file");
-        if (pdf->draftmode != int_par(draft_mode_code))
-            normal_error("pdf backend", "draftmode cannot be changed after data is written to the PDF file");
     }
+}
+
+static void fix_pdf_draftmode(PDF pdf)
+{
+    if (pdf->draftmode != draft_mode_par)
+        normal_error("pdf backend", "draftmode cannot be changed after data is written to the PDF file");
     if (pdf->draftmode != 0) {
         pdf->compress_level = 0;        /* re-fix it, might have been changed inbetween */
         pdf->objcompresslevel = 0;
@@ -577,7 +580,7 @@
                 pdf_out(pdf, '1');
             } else {
                 char a[24];
-                snprintf(a, 23, "%" LONGINTEGER_PRI "i", m);
+                snprintf(a, 23, "%" LONGINTEGER_PRI "i", (LONGINTEGER_TYPE) m);
                 pdf_puts(pdf, a);
             }
         } else {
@@ -633,7 +636,7 @@
         return;
     }
     s++;
-    while (is_hex_char((unsigned char)*s))
+    while (isxdigit((unsigned char)*s))
         s++;
     if (s != orig + l) {
         pdf_out(pdf, '(');
@@ -960,7 +963,7 @@
 static void init_pdf_outputparameters(PDF pdf)
 {
     int pk_mode;
-    pdf->draftmode = fix_int(int_par(draft_mode_code), 0, 1);
+    pdf->draftmode = fix_int(draft_mode_par, 0, 1);
     pdf->compress_level = fix_int(pdf_compress_level, 0, 9);
     pdf->decimal_digits = fix_int(pdf_decimal_digits, 3, 5);
     pdf->gamma = fix_int(pdf_gamma, 0, 1000000);
@@ -987,15 +990,17 @@
         pk_mode = pdf_pk_mode; /* lookup once */
         if (pk_mode != null) {
             char *s = tokenlist_to_cstring(pk_mode, true, NULL);
+            /* This will become LUATEX in 1.0. */
             kpse_init_prog("PDFTEX", (unsigned) pdf->pk_resolution, s, nil);
             xfree(s);
         } else {
+            /* This will become LUATEX in 1.0. */
             kpse_init_prog("PDFTEX", (unsigned) pdf->pk_resolution, nil, nil);
         }
         if (!kpse_var_value("MKTEXPK"))
             kpse_set_program_enabled(kpse_pk_format, 1, kpse_src_cmdline);
     }
-    set_job_id(pdf, int_par(year_code), int_par(month_code), int_par(day_code), int_par(time_code));
+    set_job_id(pdf, year_par, month_par, day_par, time_par);
     if ((pdf_unique_resname > 0) && (pdf->resname_prefix == NULL))
         pdf->resname_prefix = get_resname_prefix(pdf);
 }
@@ -1024,8 +1029,10 @@
     /* Initialize variables for \.{PDF} output */
     fix_pdf_minorversion(pdf);
     init_pdf_outputparameters(pdf);
+    fix_pdf_draftmode(pdf);
     /* Write \.{PDF} header */
     pdf_printf(pdf, "%%PDF-1.%d\n", pdf->minor_version);
+    /* The next blob will be removed 1.0. */
     pdf_out(pdf, '%');
     pdf_out(pdf, 'P' + 128);
     pdf_out(pdf, 'T' + 128);
@@ -1455,7 +1462,7 @@
             /* start md5 */
             md5_init(&state);
             /* get the time */
-            t = time(NULL);
+            t = pdf->start_time;
             size = strftime(time_str, sizeof(time_str), "%Y%m%dT%H%M%SZ", gmtime(&t));
             md5_append(&state, (const md5_byte_t *) time_str, (int) size);
             /* get the file name */
@@ -1542,7 +1549,11 @@
     time_t t = pdf->start_time;
     char *time_str = pdf->start_time_str;
     /* get the time */
-    lt = *localtime(&t);
+    if (utc_option) {
+        lt = *gmtime(&t);
+    } else {
+        lt = *localtime(&t);
+    }
     size = strftime(time_str, TIME_STR_SIZE, "D:%Y%m%d%H%M%S", &lt);
     /* expected format: "YYYYmmddHHMMSS" */
     if (size == 0) {
@@ -1582,10 +1593,10 @@
 }
 
 @ @c
-void init_start_time(PDF pdf)
+void initialize_start_time(PDF pdf)
 {
     if (pdf->start_time == 0) {
-        pdf->start_time = time((time_t *) NULL);
+        pdf->start_time = get_start_time();
         pdf->start_time_str = xtalloc(TIME_STR_SIZE, char);
         makepdftime(pdf);
     }
@@ -1594,7 +1605,7 @@
 @ @c
 char *getcreationdate(PDF pdf)
 {
-    init_start_time(pdf);
+    initialize_start_time(pdf);
     return pdf->start_time_str;
 }
 
@@ -1642,9 +1653,9 @@
                normal_error("pdf backend","weird output state");
          }
         if (strict)
-            formatted_error("pdf backend", "%s not allowed in %s mode (outputmode = %d)",s, m, (int) int_par(output_mode_code));
+            formatted_error("pdf backend", "%s not allowed in %s mode (outputmode = %d)",s, m, (int) output_mode_par);
         else
-            formatted_warning("pdf backend", "%s not allowed in %s mode (outputmode = %d)",s, m, (int) int_par(output_mode_code));
+            formatted_warning("pdf backend", "%s not allowed in %s mode (outputmode = %d)",s, m, (int) output_mode_par);
     } else if (strict)
         ensure_output_state(pdf, ST_HEADER_WRITTEN);
 }
@@ -1688,11 +1699,10 @@
 }
 
 @ @c
-#define mag int_par(mag_code)
-
 void pdf_begin_page(PDF pdf)
 {
     int xform_attributes;
+    int xform_type = 0;
     scaled form_margin = pdf_xform_margin; /* was one_bp until SVN4066 */
     ensure_output_state(pdf, ST_HEADER_WRITTEN);
     init_pdf_pagecalculations(pdf);
@@ -1711,12 +1721,16 @@
         pdf->last_thread = null;
         pdf_begin_dict(pdf);
     } else {
+        xform_type = obj_xform_type(pdf, pdf_cur_form) ;
         pdf_begin_obj(pdf, pdf_cur_form, OBJSTM_NEVER);
         pdf->last_stream = pdf_cur_form;
         /* Write out Form stream header */
         pdf_begin_dict(pdf);
-        pdf_dict_add_name(pdf, "Type", "XObject");
-        pdf_dict_add_name(pdf, "Subtype", "Form");
+        if (xform_type == 0) {
+            pdf_dict_add_name(pdf, "Type", "XObject");
+            pdf_dict_add_name(pdf, "Subtype", "Form");
+            pdf_dict_add_int(pdf, "FormType", 1);
+        }
         xform_attributes = pdf_xform_attr; /* lookup once */
         if (xform_attributes != null)
             pdf_print_toks(pdf, xform_attributes);
@@ -1730,23 +1744,26 @@
             luaL_unref(Luas, LUA_REGISTRYINDEX, obj_xform_attr_str(pdf, pdf_cur_form));
             set_obj_xform_attr_str(pdf, pdf_cur_form, null);
         }
-        pdf_add_name(pdf, "BBox");
-        pdf_begin_array(pdf);
-        pdf_add_bp(pdf, -form_margin);
-        pdf_add_bp(pdf, -form_margin);
-        pdf_add_bp(pdf, pdf->page_size.h + form_margin);
-        pdf_add_bp(pdf, pdf->page_size.v + form_margin);
-        pdf_end_array(pdf);
-        pdf_dict_add_int(pdf, "FormType", 1);
-        pdf_add_name(pdf, "Matrix");
-        pdf_begin_array(pdf);
-        pdf_add_int(pdf, 1);
-        pdf_add_int(pdf, 0);
-        pdf_add_int(pdf, 0);
-        pdf_add_int(pdf, 1);
-        pdf_add_int(pdf, 0);
-        pdf_add_int(pdf, 0);
-        pdf_end_array(pdf);
+        if (xform_type == 0 || xform_type == 1 || xform_type == 3) {
+            pdf_add_name(pdf, "BBox");
+            pdf_begin_array(pdf);
+            pdf_add_bp(pdf, -form_margin);
+            pdf_add_bp(pdf, -form_margin);
+            pdf_add_bp(pdf, pdf->page_size.h + form_margin);
+            pdf_add_bp(pdf, pdf->page_size.v + form_margin);
+            pdf_end_array(pdf);
+        }
+        if (xform_type == 0 || xform_type == 2 || xform_type == 3) {
+            pdf_add_name(pdf, "Matrix");
+            pdf_begin_array(pdf);
+            pdf_add_int(pdf, 1);
+            pdf_add_int(pdf, 0);
+            pdf_add_int(pdf, 0);
+            pdf_add_int(pdf, 1);
+            pdf_add_int(pdf, 0);
+            pdf_add_int(pdf, 0);
+            pdf_end_array(pdf);
+        }
         pdf_dict_add_ref(pdf, "Resources", pdf->page_resources->last_resources);
     }
     /* Start stream of page/form contents */
@@ -2176,11 +2193,11 @@
         pdf_dict_add_string(pdf, "Creator", "TeX");
     }
     if ((pdf_suppress_optional_info & 32) == 0 && !creationdate_given) {
-        init_start_time(pdf);
+        initialize_start_time(pdf);
         pdf_dict_add_string(pdf, "CreationDate", pdf->start_time_str);
     }
     if ((pdf_suppress_optional_info & 64) == 0 && !moddate_given) {
-        init_start_time(pdf);
+        initialize_start_time(pdf);
         pdf_dict_add_string(pdf, "ModDate", pdf->start_time_str);
     }
     if ((pdf_suppress_optional_info & 256) == 0 && !trapped_given) {
--- texlive-bin.orig/texk/web2c/luatexdir/pdf/pdfglyph.w
+++ texlive-bin/texk/web2c/luatexdir/pdf/pdfglyph.w
@@ -22,13 +22,10 @@
 #include "ptexlib.h"
 #include "pdf/pdfpage.h"
 
-#define pdf2double(a) ((double) (a).m / ten_pow[(a).e])
-
 @ eternal constants
 
 @c
-#define one_bp ((double) 65536 * (double) 72.27 / 72)  /* number of sp per 1bp */
-#define e_tj 3                                         /* must be 3; movements in []TJ are in fontsize/$10^3$ units */
+#define e_tj 3 /* must be 3; movements in []TJ are in fontsize/$10^3$ units */
 
 @ @c
 static int64_t pdf_char_width(pdfstructure * p, internal_font_number f, int i)
@@ -58,7 +55,7 @@
         u = font_units_per_em(f) / 1000.0;
     pdf->f_cur = f;
     p->f_pdf = pdf_set_font(pdf, f);
-    p->fs.m = i64round(font_size(f) / u / one_bp * ten_pow[p->fs.e]);
+    p->fs.m = i64round(font_size(f) / u / by_one_bp * ten_pow[p->fs.e]);
     slant = font_slant(f) / 1000.0;
     extend = font_extend(f) / 1000.0;
     expand = 1.0 + (ex_glyph/1) / 1000.0;
--- texlive-bin.orig/texk/web2c/luatexdir/pdf/pdflistout.w
+++ texlive-bin/texk/web2c/luatexdir/pdf/pdflistout.w
@@ -310,7 +310,7 @@
     int i;                      /* index to scan |pdf_link_stack| */
     int save_loc = 0;           /* DVI! \.{DVI} byte location upon entry */
     scaledpos save_dvi = { 0, 0 };      /* DVI! what |dvi| should pop to */
-    int synctex = int_par(synctex_code) ;
+    int synctex = synctex_par ;
 
     g_order = glue_order(this_box);
     g_sign = glue_sign(this_box);
@@ -764,7 +764,7 @@
     scaled_whd rule;
     int save_loc = 0;              /* DVI byte location upon entry */
     scaledpos save_dvi = { 0, 0 }; /* DVI! what |dvi| should pop to */
-    int synctex = int_par(synctex_code) ;
+    int synctex = synctex_par ;
 
     g_order = (glue_ord) glue_order(this_box);
     g_sign = glue_sign(this_box);
--- texlive-bin.orig/texk/web2c/luatexdir/pdf/pdfliteral.w
+++ texlive-bin/texk/web2c/luatexdir/pdf/pdfliteral.w
@@ -66,6 +66,9 @@
                 pdf_end_string_nl(pdf);
                 ps->need_tm = true;
                 break;
+            case direct_raw:
+                pdf_end_string_nl(pdf);
+                break;
             default:
                 normal_error("pdf backend","bad literal mode");
                 break;
@@ -114,6 +117,9 @@
             } else if (str_in_cstr(s, "page:", strlen("PDF:"))) {
                 j = j + (pool_pointer) strlen("page:");
                 literal_mode = direct_page;
+            } else if (str_in_cstr(s, "raw:", strlen("PDF:"))) {
+                j = j + (pool_pointer) strlen("raw:");
+                literal_mode = direct_raw;
             } else {
                 literal_mode = set_origin;
             }
@@ -131,6 +137,9 @@
             pdf_end_string_nl(pdf);
             p->need_tm = true;
             break;
+        case direct_raw:
+            pdf_end_string_nl(pdf);
+            break;
         default:
             normal_error("pdf backend","bad literal mode");
             break;
--- /dev/null
+++ texlive-bin/texk/web2c/luatexdir/pdf/pdfluaapi.h.old
@@ -0,0 +1,29 @@
+/* pdfluaapi.h
+
+   Copyright 2009 Taco Hoekwater <taco@luatex.org>
+
+   This file is part of LuaTeX.
+
+   LuaTeX is free software; you can redistribute it and/or modify it under
+   the terms of the GNU General Public License as published by the Free
+   Software Foundation; either version 2 of the License, or (at your
+   option) any later version.
+
+   LuaTeX is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License along
+   with LuaTeX; if not, see <http://www.gnu.org/licenses/>. */
+
+
+#ifndef PDFLUAAPI_H
+#  define PDFLUAAPI_H
+
+extern int new_pdflua(void);
+extern void pdflua_begin_page(PDF pdf);
+extern void pdflua_end_page(PDF pdf, int annots, int beads);
+extern void pdflua_output_pages_tree(PDF pdf);
+
+#endif                          /* PDFLUAAPI_H */
--- /dev/null
+++ texlive-bin/texk/web2c/luatexdir/pdf/pdfluaapi.w.old
@@ -0,0 +1,113 @@
+% pdfluaapi.w
+%
+% Copyright 2010 Taco Hoekwater <taco@@luatex.org>
+%
+% This file is part of LuaTeX.
+%
+% LuaTeX is free software; you can redistribute it and/or modify it under
+% the terms of the GNU General Public License as published by the Free
+% Software Foundation; either version 2 of the License, or (at your
+% option) any later version.
+%
+% LuaTeX is distributed in the hope that it will be useful, but WITHOUT
+% ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+% FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
+% License for more details.
+%
+% You should have received a copy of the GNU General Public License along
+% with LuaTeX; if not, see <http://www.gnu.org/licenses/>.
+
+@ @c
+
+
+#include "ptexlib.h"
+
+@ @c
+int new_pdflua(void)
+{
+    int i, err;
+    Byte *uncompr;
+    const zlib_struct *zp = pdflua_zlib_struct_ptr;
+    uLong uncomprLen = zp->uncomprLen;
+    if ((uncompr = xtalloc(zp->uncomprLen, Byte)) == NULL)
+        luatex_fail("new_pdflua(): xtalloc()");
+    err = uncompress(uncompr, &uncomprLen, zp->compr, zp->comprLen);
+    if (err != Z_OK)
+        luatex_fail("new_pdflua(): uncompress()");
+    assert(uncomprLen == zp->uncomprLen);
+    if (luaL_loadbuffer(Luas, (const char *) uncompr, uncomprLen, "pdflua")
+        || lua_pcall(Luas, 0, 1, 0))
+        luatex_fail("new_pdflua(): lua_pcall()");
+    luaL_checktype(Luas, -1, LUA_TTABLE);       /* t */
+    i = luaL_ref(Luas, LUA_REGISTRYINDEX);       /* - */
+    xfree(uncompr);
+    return i;
+}
+
+@ @c
+void pdflua_begin_page(PDF pdf)
+{
+    int err;                    /* ... */
+    lua_rawgeti(Luas, LUA_REGISTRYINDEX, pdf->pdflua_ref);       /* t ... */
+    lua_pushstring(Luas, "beginpage");  /* s t ... */
+    lua_gettable(Luas, -2);     /* f t ... */
+    lua_newtable(Luas);         /* t f t ... */
+    lua_pushnumber(Luas, total_pages + 1);      /* i t f t ... */
+    lua_setfield(Luas, -2, "pagenum");  /* t f t ... */
+    lua_pushnumber(Luas, pdf->last_page);       /*  i t f t ... */
+    lua_setfield(Luas, -2, "page_objnum");      /* t f t ... */
+    lua_pushnumber(Luas, pdf->last_stream);     /* i t f t ... */
+    lua_setfield(Luas, -2, "stream_objnum");    /* t f t ... */
+    lua_pushnumber(Luas, pdf->page_resources->last_resources);  /* i t f t ... */
+    lua_setfield(Luas, -2, "resources_objnum"); /* t f t ... */
+    err = lua_pcall(Luas, 1, 0, 0);     /* (e) t ... */
+    if (err != 0)
+        luatex_fail("pdflua.lua: beginpage()");
+    /* t ... */
+    lua_pop(Luas, 1);           /* ... */
+}
+
+@ @c
+void pdflua_end_page(PDF pdf, int annots, int beads)
+{
+    int err;                    /* ... */
+    lua_rawgeti(Luas, LUA_REGISTRYINDEX, pdf->pdflua_ref);       /* t ... */
+    lua_pushstring(Luas, "endpage");    /* s t ... */
+    lua_gettable(Luas, -2);     /* f t ... */
+    lua_newtable(Luas);         /* t f t ... */
+    lua_pushnumber(Luas, total_pages);  /* i t f t ... */
+    lua_setfield(Luas, -2, "pagenum");  /* t f t ... */
+    lua_pushnumber(Luas, pdf->page_size.h);     /* i t f t ... */
+    lua_setfield(Luas, -2, "hsize");    /* t f t ... */
+    lua_pushnumber(Luas, pdf->page_size.v);     /* i t f t ... */
+    lua_setfield(Luas, -2, "vsize");    /* t f t ... */
+    if (annots != 0) {
+        lua_pushnumber(Luas, annots);   /* i t f t ... */
+        lua_setfield(Luas, -2, "annots");       /* t f t ... */
+    }
+    if (beads != 0) {
+        lua_pushnumber(Luas, beads);    /* i t f t ... */
+        lua_setfield(Luas, -2, "beads");        /* t f t ... */
+    }
+    if (pdf->img_page_group_val != 0) {
+        lua_pushnumber(Luas, pdf->img_page_group_val);  /* i t f t ... */
+        lua_setfield(Luas, -2, "imggroup");     /* t f t ... */
+    }
+    err = lua_pcall(Luas, 1, 0, 0);     /* (e) t ... */
+    if (err != 0)
+        luatex_fail("pdflua.lua: endpage()");
+    /* t ... */
+    lua_pop(Luas, 1);           /* ... */
+}
+
+@ @c
+void pdflua_output_pages_tree(PDF pdf)
+{
+    int err;
+    lua_rawgeti(Luas, LUA_REGISTRYINDEX, pdf->pdflua_ref);       /* t */
+    lua_pushstring(Luas, "outputpagestree");    /* s t */
+    lua_gettable(Luas, -2);     /* f */
+    err = lua_pcall(Luas, 0, 0, 0);     /* - */
+    if (err != 0)
+        luatex_fail("pdflua.lua: outputpagestree()");
+}
--- texlive-bin.orig/texk/web2c/luatexdir/pdf/pdfobj.w
+++ texlive-bin/texk/web2c/luatexdir/pdf/pdfobj.w
@@ -29,13 +29,21 @@
     lstring data;
     const_lstring st;
     size_t li;                  /* index into |data.s| */
-    int saved_compress_level = pdf->compress_level;
+    int saved_compress_level ;
     int os_threshold = OBJSTM_ALWAYS;   /* gives compressed objects for \.{\\pdfvariable objcompresslevel} >= |OBJSTM_ALWAYS| */
     int l = 0;                          /* possibly a lua registry reference */
     int ll = 0;
     data.s = NULL;
-    if (obj_obj_pdfcompresslevel(pdf, k) > -1)  /* -1 = "unset" */
+    /* we can have an immediate object before we are initialized */
+    ensure_output_state(pdf, ST_HEADER_WRITTEN);
+    saved_compress_level = pdf->compress_level;
+    /* end of ugly hack */
+    if (obj_obj_pdfcompresslevel(pdf, k) > -1) { /* -1 = "unset" */
         pdf->compress_level = obj_obj_pdfcompresslevel(pdf, k);
+        if (pdf->compress_level == 0) {
+            pdf->objcompresslevel = 0;
+        }
+    }
     if (obj_obj_objstm_threshold(pdf, k) != OBJSTM_UNSET)
         os_threshold = obj_obj_objstm_threshold(pdf, k);
     if (obj_obj_is_stream(pdf, k)) {
@@ -183,21 +191,19 @@
 }
 
 @ @c
-#define tail cur_list.tail_field
-
 void scan_refobj(PDF pdf)
 {
     scan_int();
     check_obj_type(pdf, obj_type_obj, cur_val);
     new_whatsit(pdf_refobj_node);
-    pdf_obj_objnum(tail) = cur_val;
+    pdf_obj_objnum(tail_par) = cur_val;
 }
 
 void scan_refobj_lua(PDF pdf, int k)
 {
     check_obj_type(pdf, obj_type_obj, k);
     new_whatsit(pdf_refobj_node);
-    pdf_obj_objnum(tail) = k;
+    pdf_obj_objnum(tail_par) = k;
 }
 
 @ @c
--- texlive-bin.orig/texk/web2c/luatexdir/pdf/pdfpage.w
+++ texlive-bin/texk/web2c/luatexdir/pdf/pdfpage.w
@@ -26,11 +26,6 @@
 #include <assert.h>
 #include <math.h>
 
-@ eternal constant: number of sp per 1bp
-
-@c
-#define one_bp ((double) 65536 * (double) 72.27 / 72)
-
 @ @c
 void init_pdf_pagecalculations(PDF pdf)
 {
@@ -66,7 +61,7 @@
     p->ishex = 0;
     p->need_tf = false;
     p->need_tm = false;
-    p->k1 = ten_pow[p->pdf.h.e] / one_bp;
+    p->k1 = ten_pow[p->pdf.h.e] / by_one_bp;
 }
 
 @ @c
--- texlive-bin.orig/texk/web2c/luatexdir/pdf/pdfrule.w
+++ texlive-bin/texk/web2c/luatexdir/pdf/pdfrule.w
@@ -30,14 +30,22 @@
     pdfpos dim;
     pdfstructure *p = pdf->pstruct;
     scaledpos pos = pdf->posstruct->pos;
+    halfword s = subtype(q);
     /*  (void) q; */
-    if (subtype(q) == box_rule) {
+    if (s >= math_over_rule && s <= math_radical_rule) {
+        if (callback_id == 0) {
+            s = normal_rule;
+        } else {
+            s = user_rule;
+        }
+    }
+    if (s == box_rule) {
         pdf_place_form(pdf,q);
-    } else if (subtype(q) == image_rule) {
+    } else if (s == image_rule) {
         pdf_place_image(pdf,q);
-    } else if (subtype(q) == empty_rule) {
+    } else if (s == empty_rule) {
         /* place nothing, only take space */
-    } else if (subtype(q) == user_rule) {
+    } else if (s == user_rule) {
         if (callback_id != 0) {
             pdf_goto_pagemode(pdf);
             pdf_puts(pdf, "q\n");
--- texlive-bin.orig/texk/web2c/luatexdir/pdf/pdfshipout.w
+++ texlive-bin/texk/web2c/luatexdir/pdf/pdfshipout.w
@@ -22,20 +22,6 @@
 #include "ptexlib.h"
 
 @ @c
-#define count(A) eqtb[count_base+(A)].cint
-
-#define mag                int_par(mag_code)
-#define h_offset           dimen_par(h_offset_code)
-#define page_bottom_offset dimen_par(page_bottom_offset_code)
-#define page_height        dimen_par(page_height_code)
-#define page_left_offset   dimen_par(page_left_offset_code)
-#define page_right_offset  dimen_par(page_right_offset_code)
-#define page_top_offset    dimen_par(page_top_offset_code)
-#define page_width         dimen_par(page_width_code)
-#define tracing_output     int_par(tracing_output_code)
-#define tracing_stats      int_par(tracing_stats_code)
-#define v_offset           dimen_par(v_offset_code)
-
 scaledpos shipbox_refpos;
 
 @ |ship_out| is used to shipout a box to PDF or DVI mode. If |shipping_mode| is
@@ -61,16 +47,16 @@
         Start sheet {\sl Sync\TeX} information record; we assume that |pdf_output| is
         properly set up.
     */
-    if (int_par(synctex_code)) {
+    if (synctex_par) {
         if (output_mode_used == OMODE_DVI) {
-            synctexsheet(mag);
+            synctexsheet(mag_par);
         } else {
             synctexsheet(1000);
         }
     }
     pre_callback_id = callback_defined(start_page_number_callback);
     post_callback_id = callback_defined(stop_page_number_callback);
-    if ((tracing_output > 0) && (pre_callback_id == 0)) {
+    if ((tracing_output_par > 0) && (pre_callback_id == 0)) {
         tprint_nl("");
         print_ln();
         tprint("Completed box being shipped out");
@@ -95,7 +81,7 @@
             }
         }
     }
-    if ((tracing_output > 0) && shipping_mode == SHIPPING_PAGE) {
+    if ((tracing_output_par > 0) && shipping_mode == SHIPPING_PAGE) {
         print_char(']');
         update_terminal();
         begin_diagnostic();
@@ -103,7 +89,7 @@
         end_diagnostic(true);
     }
     /* Ship box |p| out */
-    if (shipping_mode == SHIPPING_PAGE && box_dir(p) != page_direction)
+    if (shipping_mode == SHIPPING_PAGE && box_dir(p) != page_direction_par)
         normal_warning("backend","pagedir differs from bodydir, the output may be placed wrongly on the page");
     /*
         Update the values of |max_h| and |max_v|; but if the page is too large,
@@ -111,14 +97,14 @@
         error messages are being ignored. Such pages are not output to the
         \.{dvi} file, since they may confuse the printing software.
     */
-    if ((height(p) > max_dimen) || (depth(p) > max_dimen) || (height(p) + depth(p) + v_offset > max_dimen) || (width(p) + h_offset > max_dimen)) {
+    if ((height(p) > max_dimen) || (depth(p) > max_dimen) || (height(p) + depth(p) + v_offset_par > max_dimen) || (width(p) + h_offset_par > max_dimen)) {
         const char *hlp[] = {
             "The page just created is more than 18 feet tall or",
             "more than 18 feet wide, so I suspect something went wrong.",
             NULL
         };
         tex_error("Huge page cannot be shipped out", hlp);
-        if (tracing_output <= 0) {
+        if (tracing_output_par <= 0) {
             begin_diagnostic();
             tprint_nl("The following box has been deleted:");
             show_box(p);
@@ -126,47 +112,47 @@
         }
         goto DONE;
     }
-    if (height(p) + depth(p) + v_offset > max_v)
-        max_v = height(p) + depth(p) + v_offset;
-    if (width(p) + h_offset > max_h)
-        max_h = width(p) + h_offset;
+    if (height(p) + depth(p) + v_offset_par > max_v)
+        max_v = height(p) + depth(p) + v_offset_par;
+    if (width(p) + h_offset_par > max_h)
+        max_h = width(p) + h_offset_par;
     /* Calculate page dimensions and margins */
     if (global_shipping_mode == SHIPPING_PAGE) {
-        if (page_width > 0)
-            pdf->page_size.h = page_width;
+        if (page_width_par > 0)
+            pdf->page_size.h = page_width_par;
         else {
-            switch (page_direction) {
+            switch (page_direction_par) {
                 case dir_TLT:
-                    pdf->page_size.h = width(p) + 2 * page_left_offset;
+                    pdf->page_size.h = width(p) + 2 * page_left_offset_par;
                     break;
                 case dir_TRT:
-                    pdf->page_size.h = width(p) + 2 * page_right_offset;
+                    pdf->page_size.h = width(p) + 2 * page_right_offset_par;
                     break;
                 case dir_LTL:
-                    pdf->page_size.h = height(p) + depth(p) + 2 * page_left_offset;
+                    pdf->page_size.h = height(p) + depth(p) + 2 * page_left_offset_par;
                     break;
                 case dir_RTT:
-                    pdf->page_size.h = height(p) + depth(p) + 2 * page_right_offset;
+                    pdf->page_size.h = height(p) + depth(p) + 2 * page_right_offset_par;
                     break;
                 default:
-                    pdf->page_size.h = width(p) + 2 * page_left_offset;
+                    pdf->page_size.h = width(p) + 2 * page_left_offset_par;
                     normal_warning("pdf backend","bad page direction, assuming TLT, case 1");
             }
         }
-        if (page_height > 0)
-            pdf->page_size.v = page_height;
+        if (page_height_par > 0)
+            pdf->page_size.v = page_height_par;
         else {
-            switch (page_direction) {
+            switch (page_direction_par) {
                 case dir_TLT:
                 case dir_TRT:
-                    pdf->page_size.v = height(p) + depth(p) + 2 * page_top_offset;
+                    pdf->page_size.v = height(p) + depth(p) + 2 * page_top_offset_par;
                     break;
                 case dir_LTL:
                 case dir_RTT:
-                    pdf->page_size.v = width(p) + 2 * page_top_offset;
+                    pdf->page_size.v = width(p) + 2 * page_top_offset_par;
                     break;
                 default:
-                    pdf->page_size.v = height(p) + depth(p) + 2 * page_top_offset;
+                    pdf->page_size.v = height(p) + depth(p) + 2 * page_top_offset_par;
                     normal_warning("pdf backend","bad page direction, assuming TLT, case 2");
                 }
         }
@@ -193,27 +179,27 @@
             Then shift |refpoint.pos| of the DVI origin depending on the
             |page_direction| within the upright (TLT) page coordinate system
         */
-        switch (page_direction) {
+        switch (page_direction_par) {
             case dir_TLT:
             case dir_LTL:
-                refpoint.pos.h += h_offset;
-                refpoint.pos.v -= v_offset;
+                refpoint.pos.h += h_offset_par;
+                refpoint.pos.v -= v_offset_par;
                 break;
             case dir_TRT:
             case dir_RTT:
-                refpoint.pos.h += pdf->page_size.h - page_right_offset - one_true_inch;
-                refpoint.pos.v -= v_offset;
+                refpoint.pos.h += pdf->page_size.h - page_right_offset_par - one_true_inch;
+                refpoint.pos.v -= v_offset_par;
                 break;
             default:
-                refpoint.pos.h += h_offset;
-                refpoint.pos.v -= v_offset;
+                refpoint.pos.h += h_offset_par;
+                refpoint.pos.v -= v_offset_par;
                 normal_warning("pdf backend","bad page direction, assuming TLT, case 3");
         }
         /*
             Then switch to page box coordinate system; do |height(p)| movement,
             to get the location of the box origin.
         */
-        pdf->posstruct->dir = page_direction;
+        pdf->posstruct->dir = page_direction_par;
         cur.h = 0;
         cur.v = height(p);
         synch_pos_with_cur(pdf->posstruct, &refpoint, cur);
@@ -297,13 +283,13 @@
             normal_error("pdf backend", "unknown output mode");
     }
   DONE:
-    if ((tracing_output <= 0) && (post_callback_id == 0) && shipping_mode == SHIPPING_PAGE) {
+    if ((tracing_output_par <= 0) && (post_callback_id == 0) && shipping_mode == SHIPPING_PAGE) {
         print_char(']');
         update_terminal();
     }
     dead_cycles = 0;
     /* Flush the box from memory, showing statistics if requested */
-    if ((tracing_stats > 1) && (pre_callback_id == 0)) {
+    if ((tracing_stats_par > 1) && (pre_callback_id == 0)) {
         tprint_nl("Memory usage before: ");
         print_int(var_used);
         print_char('&');
@@ -311,7 +297,7 @@
         print_char(';');
     }
     flush_node_list(p);
-    if ((tracing_stats > 1) && (post_callback_id == 0)) {
+    if ((tracing_stats_par > 1) && (post_callback_id == 0)) {
         tprint(" after: ");
         print_int(var_used);
         print_char('&');
@@ -321,7 +307,7 @@
     if (shipping_mode == SHIPPING_PAGE && (post_callback_id > 0))
         (void) run_callback(post_callback_id, "->");
     /* Finish sheet {\sl Sync\TeX} information record */
-    if (int_par(synctex_code))
+    if (synctex_par)
         synctexteehs();
     global_shipping_mode = NOT_SHIPPING;
 }
--- texlive-bin.orig/texk/web2c/luatexdir/pdf/pdftables.h
+++ texlive-bin/texk/web2c/luatexdir/pdf/pdftables.h
@@ -99,6 +99,10 @@
 #  define inf_pk_dpi   72 /* min PK pixel density value from \.{texmf.cnf} */
 #  define sup_pk_dpi 8000 /* max PK pixel density value from \.{texmf.cnf} */
 
+#  define pdf2double(a) ((double) (a).m / ten_pow[(a).e])
+
+#  define by_one_bp ((double) 65536 * (double) 72.27 / 72)  /* number of sp per 1bp */
+
 extern int find_obj(PDF pdf, int t, int i, boolean byname);
 extern void check_obj_exists(PDF pdf, int objnum);
 extern void check_obj_type(PDF pdf, int t, int objnum);
--- texlive-bin.orig/texk/web2c/luatexdir/pdf/pdfthread.w
+++ texlive-bin/texk/web2c/luatexdir/pdf/pdfthread.w
@@ -21,10 +21,6 @@
 
 #include "ptexlib.h"
 
-@ @c
-#define page_width dimen_par(page_width_code)
-#define page_height dimen_par(page_height_code)
-
 @ Threads are handled in similar way as link annotations
 @c
 void append_bead(PDF pdf, halfword p)
@@ -168,8 +164,8 @@
     pdf_begin_array(pdf);
     pdf_add_int(pdf, 0);
     pdf_add_int(pdf, 0);
-    pdf_add_bp(pdf, page_width);
-    pdf_add_bp(pdf, page_height);
+    pdf_add_bp(pdf, page_width_par);
+    pdf_add_bp(pdf, page_height_par);
     pdf_end_array(pdf);
     pdf_end_dict(pdf);
     pdf_end_obj(pdf);
--- texlive-bin.orig/texk/web2c/luatexdir/pdf/pdfxform.h
+++ texlive-bin/texk/web2c/luatexdir/pdf/pdfxform.h
@@ -22,7 +22,7 @@
 #ifndef PDFXFORM_H
 #  define PDFXFORM_H
 
-#  define pdfmem_xform_size 8 /* size of memory in |pdf->mem| which |obj_data_ptr| holds */
+#  define pdfmem_xform_size 9 /* size of memory in |pdf->mem| which |obj_data_ptr| holds */
 
 #  define obj_xform_width(pdf,A)          pdf->mem[obj_data_ptr(pdf,A) + 0]
 #  define obj_xform_height(pdf,A)         pdf->mem[obj_data_ptr(pdf,A) + 1]
@@ -32,6 +32,7 @@
 #  define obj_xform_resources(pdf,A)      pdf->mem[obj_data_ptr(pdf,A) + 5] /* additional xform Resources */
 #  define obj_xform_attr_str(pdf,A)       pdf->mem[obj_data_ptr(pdf,A) + 6]
 #  define obj_xform_resources_str(pdf,A)  pdf->mem[obj_data_ptr(pdf,A) + 7]
+#  define obj_xform_type(pdf,A)           pdf->mem[obj_data_ptr(pdf,A) + 8]
 
 #  define set_pdf_xform_objnum(A,B)            pdf_xform_objnum(A)=B
 #  define set_obj_xform_width(pdf,A,B)         obj_xform_width(pdf,A)=B
@@ -42,6 +43,7 @@
 #  define set_obj_xform_resources(pdf,A,B)     obj_xform_resources(pdf,A)=B
 #  define set_obj_xform_attr_str(pdf,A,B)      obj_xform_attr_str(pdf,A)=B
 #  define set_obj_xform_resources_str(pdf,A,B) obj_xform_resources_str(pdf,A)=B
+#  define set_obj_xform_type(pdf,A,B)          obj_xform_type(pdf,A)=B
 
 extern int pdf_cur_form; /* the form being output */
 
--- texlive-bin.orig/texk/web2c/luatexdir/pdf/pdfxform.w
+++ texlive-bin/texk/web2c/luatexdir/pdf/pdfxform.w
@@ -22,8 +22,6 @@
 #include "pdf/pdfpage.h"
 
 @ @c
-#define box(A) eqtb[box_base+(A)].hh.rh
-
 int pdf_cur_form;               /* the form being output */
 
 void pdf_place_form(PDF pdf, halfword p)
@@ -72,6 +70,12 @@
     pdf->xform_count++;
     k = pdf_create_obj(pdf, obj_type_xform, pdf->xform_count);
     set_obj_data_ptr(pdf, k, pdf_get_mem(pdf, pdfmem_xform_size));
+    if (scan_keyword("type")) {
+        scan_int();
+        set_obj_xform_type(pdf, k, cur_val);
+    } else {
+        set_obj_xform_type(pdf, k, 0);
+    }
     if (scan_keyword("attr")) {
         scan_toks(false, true);
         set_obj_xform_attr(pdf, k, def_ref);
@@ -99,8 +103,6 @@
 }
 
 @ @c
-#define tail          cur_list.tail_field
-
 void scan_pdfrefxform(PDF pdf)
 {
     scaled_whd alt_rule, dim, nat;
@@ -116,8 +118,8 @@
     } else {
         dim = nat;
     }
-    width(tail) = dim.wd;
-    height(tail) = dim.ht;
-    depth(tail) = dim.dp;
-    rule_index(tail) = cur_val;
+    width(tail_par) = dim.wd;
+    height(tail_par) = dim.ht;
+    depth(tail_par) = dim.dp;
+    rule_index(tail_par) = cur_val;
 }
--- texlive-bin.orig/texk/web2c/luatexdir/ptexlib.h
+++ texlive-bin/texk/web2c/luatexdir/ptexlib.h
@@ -111,7 +111,7 @@
         *p = 0;                                        \
 } while (0)
 
-#  define skip(p, c)   if (*p == c)  p++
+#  define skip_char(p, c)   if (*p == c)  p++
 
 #  define alloc_array(T, n, s) do {					\
 	if (T##_array == NULL) {					\
@@ -373,4 +373,7 @@
 
 extern int program_name_set;    /* in lkpselib.c */
 
+extern int kpse_init; /* in luainit.w */
+extern int kpse_available(const char * m); /* in texfileio.w */
+
 #endif                          /* PTEXLIB_H */
--- texlive-bin.orig/texk/web2c/luatexdir/tex/align.w
+++ texlive-bin/texk/web2c/luatexdir/tex/align.w
@@ -31,17 +31,6 @@
 
 #define noDEBUG
 
-#define end_template_token (cs_token_flag+frozen_end_template)
-
-#define prev_depth      cur_list.prev_depth_field
-#define space_factor    cur_list.space_factor_field
-#define incompleat_noad cur_list.incompleat_noad_field
-
-#define every_cr          equiv(every_cr_loc)
-#define display_indent    dimen_par(display_indent_code)
-#define max_depth         dimen_par(max_depth_code)
-#define overfull_rule     dimen_par(overfull_rule_code)
-
 @ It's sort of a miracle whenever \.{\\halign} and \.{\\valign} work, because
 they cut across so many of the control structures of \TeX.
 
@@ -177,10 +166,12 @@
 This information is called the |extra_info| field.
 
 @c
-#define u_part(A) vlink((A)+depth_offset)       /* pointer to \<u_j> token list */
-#define v_part(A) vinfo((A)+depth_offset)       /* pointer to \<v_j> token list */
-#define span_ptr(A) vinfo((A)+1)        /* column spanning list */
-#define extra_info(A) vinfo((A)+list_offset)    /* info to remember during template */
+/* could be in texnodes.h, but documented here*/
+
+#define u_part(A)     vlink((A)+depth_offset) /* pointer to \<u_j> token list */
+#define v_part(A)     vinfo((A)+depth_offset) /* pointer to \<v_j> token list */
+#define span_ptr(A)   vinfo((A)+1)            /* column spanning list */
+#define extra_info(A) vinfo((A)+list_offset)  /* info to remember during template */
 
 @ Alignments can occur within alignments, so a small stack is used to access
 the alignrecord information. At each level we have a |preamble| pointer,
@@ -201,6 +192,8 @@
 |align_ptr| points to the topmost such node.
 
 @c
+/* could be in texnodes.h but documented here*/
+
 #define preamble vlink(align_head)      /* the current preamble list */
 
 pointer cur_align = null;       /* current position in preamble list */
@@ -301,7 +294,7 @@
         && (cur_chr == glue_base + tab_skip_code)) {
         scan_optional_equals();
         scan_glue(glue_val_level);
-        if (int_par(global_defs_code) > 0)
+        if (global_defs_par > 0)
             geq_define(glue_base + tab_skip_code, glue_ref_cmd, cur_val);
         else
             eq_define(glue_base + tab_skip_code, glue_ref_cmd, cur_val);
@@ -332,7 +325,7 @@
 
     if ((cur_list.mode_field == mmode)
         && ((cur_list.tail_field != cur_list.head_field)
-            || (incompleat_noad != null))) {
+            || (incompleat_noad_par != null))) {
         const char *hlp[] =
             { "Displays can use special alignments (like \\eqalignno)",
             "only if nothing but the alignment itself is between $$'s.",
@@ -349,7 +342,7 @@
        correct baseline calculations. */
     if (cur_list.mode_field == mmode) {
         cur_list.mode_field = -vmode;
-        prev_depth = nest[nest_ptr - 2].prev_depth_field;
+        prev_depth_par = nest[nest_ptr - 2].prev_depth_field;
     } else if (cur_list.mode_field > 0) {
         cur_list.mode_field = -(cur_list.mode_field);
     }
@@ -445,8 +438,8 @@
     scanner_status = normal;
 
     new_save_level(align_group);
-    if (every_cr != null)
-        begin_token_list(every_cr, every_cr_text);
+    if (every_cr_par != null)
+        begin_token_list(every_cr_par, every_cr_text);
     align_peek();               /* look for \.{\\noalign} or \.{\\omit} */
 }
 
@@ -494,9 +487,9 @@
 {
     push_nest();
     if (cur_list.mode_field == -hmode) {
-        space_factor = 1000;
+        space_factor_par = 1000;
     } else {
-        prev_depth = ignore_depth;
+        prev_depth_par = ignore_depth;
         normal_paragraph();
     }
     cur_span = p;
@@ -515,9 +508,9 @@
     push_nest();
     cur_list.mode_field = (-hmode - vmode) - cur_list.mode_field;
     if (cur_list.mode_field == -hmode)
-        space_factor = 0;
+        space_factor_par = 0;
     else
-        prev_depth = 0;
+        prev_depth_par = 0;
     tail_append(new_glue(preamble));
     subtype(cur_list.tail_field) = tab_skip_code + 1;
     cur_align = vlink(preamble);
@@ -781,16 +774,16 @@
             append_list(cur_head, cur_tail);
     } else {
         p = filtered_vpackage(vlink(cur_list.head_field),
-            0, additional, max_depth, fin_row_group, -1, 0, 0);
+            0, additional, max_depth_par, fin_row_group, -1, 0, 0);
         pop_nest();
         vlink(cur_list.tail_field) = p;
         cur_list.tail_field = p;
-        space_factor = 1000;
+        space_factor_par = 1000;
     }
     type(p) = unset_node;
     glue_stretch(p) = 0;
-    if (every_cr != null)
-        begin_token_list(every_cr, every_cr_text);
+    if (every_cr_par != null)
+        begin_token_list(every_cr_par, every_cr_text);
     align_peek();
     /* note that |glue_shrink(p)=0| since |glue_shrink==shift_amount| */
 }
@@ -817,7 +810,7 @@
         confusion("align0");
     unsave();                   /* that |align_group| was for the whole alignment */
     if (nest[nest_ptr - 1].mode_field == mmode)
-        o = display_indent;
+        o = display_indent_par;
     else
         o = 0;
     /* Go through the preamble list, determining the column widths and
@@ -856,7 +849,7 @@
             /* Nullify |width(q)| and the tabskip glue following this column */
             width(q) = 0;
             r = vlink(q);
-            reset_glue_to_zero(r); /* is a lready copy */ 
+            reset_glue_to_zero(r); /* is a lready copy */
         }
         if (span_ptr(q) != end_span) {
             /* Merge the widths in the span nodes of |q| with those of |p|,
@@ -917,10 +910,10 @@
     decr(save_ptr);
     pack_begin_line = -cur_list.ml_field;
     if (cur_list.mode_field == -vmode) {
-        rule_save = overfull_rule;
-        overfull_rule = 0;      /* prevent rule from being packaged */
+        rule_save = overfull_rule_par;
+        overfull_rule_par = 0;      /* prevent rule from being packaged */
         p = hpack(preamble, saved_value(0), saved_level(0), -1);
-        overfull_rule = rule_save;
+        overfull_rule_par = rule_save;
     } else {
         q = vlink(preamble);
         do {
@@ -929,7 +922,7 @@
             q = vlink(vlink(q));
         } while (q != null);
         p = filtered_vpackage(preamble,
-            saved_value(0), saved_level(0), max_depth, preamble_group, -1, 0, 0);
+            saved_value(0), saved_level(0), max_depth_par, preamble_group, -1, 0, 0);
         q = vlink(preamble);
         do {
             width(q) = height(q);
@@ -1120,14 +1113,14 @@
        we will need to insert glue before and after the display; that part of the
        program will be deferred until we're more familiar with such operations.)
      */
-    pd = cur_list.prev_depth_field;
+    pd = prev_depth_par;
     p = vlink(cur_list.head_field);
     q = cur_list.tail_field;
     pop_nest();
     if (cur_list.mode_field == mmode) {
         finish_display_alignment(p, q, pd);
     } else {
-	cur_list.prev_depth_field = pd; /* aux:=aux_save; */
+        prev_depth_par = pd; /* aux:=aux_save; */
         vlink(cur_list.tail_field) = p;
         if (p != null)
             cur_list.tail_field = q;
--- texlive-bin.orig/texk/web2c/luatexdir/tex/buildpage.w
+++ texlive-bin/texk/web2c/luatexdir/tex/buildpage.w
@@ -22,29 +22,9 @@
 #include "ptexlib.h"
 
 @ @c
-#define box(A) eqtb[box_base+(A)].hh.rh
-#define count(A) eqtb[count_base+(A)].hh.rh
-#undef skip
-#define skip(A) eqtb[skip_base+(A)].hh.rh
-#define dimen(A) eqtb[scaled_base+(A)].hh.rh
-
-#define vbadness int_par(vbadness_code)
-#define max_dead_cycles int_par(max_dead_cycles_code)
-#define output_box int_par(output_box_code)
-#define holding_inserts int_par(holding_inserts_code)
-
-#define vsize dimen_par(vsize_code)
-#define vfuzz dimen_par(vfuzz_code)
-#define max_depth dimen_par(max_depth_code)
-
-#define output_routine equiv(output_routine_loc)
-#define split_top_skip glue_par(split_top_skip_code)
-
-#define prev_depth cur_list.prev_depth_field
-#define mode_line cur_list.ml_field
-#define mode cur_list.mode_field
-#define tail cur_list.tail_field
-#define head cur_list.head_field
+#define mode mode_par
+#define head head_par
+#define tail tail_par
 
 @ When \TeX\ appends new material to its main vlist in vertical mode, it uses
 a method something like |vsplit| to decide where a page ends, except that
@@ -221,12 +201,12 @@
 void freeze_page_specs(int s)
 {
     page_contents = s;
-    page_goal = vsize;
-    page_max_depth = max_depth;
+    page_goal = vsize_par;
+    page_max_depth = max_depth_par;
     page_depth = 0;
     do_all_six(set_page_so_far_zero);
     least_page_cost = awful_bad;
-    if (int_par(tracing_pages_code) > 0) {
+    if (tracing_pages_par > 0) {
         begin_diagnostic();
         tprint_nl("%% goal height=");
         print_scaled(page_goal);
@@ -360,7 +340,7 @@
                 else
                     page_contents = box_there;
                 q = new_skip_param(top_skip_code);
-                if ((type(p) == hlist_node) && is_mirrored(body_direction)) {
+                if ((type(p) == hlist_node) && is_mirrored(body_direction_par)) {
                     if (width(q) > depth(p))
                         width(q) = width(q) - depth(p);
                     else
@@ -378,7 +358,7 @@
             } else {
                 /* Prepare to move a box or rule node to the current page,
                    then |goto contribute| */
-                if ((type(p) == hlist_node) && is_mirrored(body_direction)) {
+                if ((type(p) == hlist_node) && is_mirrored(body_direction_par)) {
                     page_total = page_total + page_depth + depth(p);
                     page_depth = height(p);
                 } else {
@@ -510,7 +490,7 @@
                         w = dimen(n) - height(r);
                     q = vert_break(ins_ptr(p), w, depth(p));
                     height(r) = height(r) + best_height_plus_depth;
-                    if (int_par(tracing_pages_code) > 0) {
+                    if (tracing_pages_par > 0) {
                         /* Display the insertion split cost */
                         begin_diagnostic();
                         tprint_nl("% split");
@@ -582,7 +562,7 @@
             }
             if (insert_penalties >= 10000)
                 c = awful_bad;
-            if (int_par(tracing_pages_code) > 0) {
+            if (tracing_pages_par > 0) {
                 /* Display the page break cost */
                 begin_diagnostic();
                 tprint_nl("%");
@@ -670,7 +650,7 @@
         /* Recycle node |p| */
         try_couple_nodes(contrib_head,vlink(p));
         vlink(p) = null;
-        if (int_par(saving_vdiscards_code) > 0) {
+        if (saving_vdiscards_par > 0) {
             if (page_disc == null) {
                 page_disc = p;
             } else {
@@ -746,18 +726,18 @@
     if (c == best_page_break)
         best_page_break = null; /* |c| not yet linked in */
     /* Ensure that box |output_box| is empty before output */
-    if (box(output_box) != null) {
+    if (box(output_box_par) != null) {
         print_err("\\box");
-        print_int(output_box);
+        print_int(output_box_par);
         tprint(" is not void");
         help2("You shouldn't use \\box\\outputbox except in \\output routines.",
               "Proceed, and I'll discard its present contents.");
-        box_error(output_box);
+        box_error(output_box_par);
     }
 
     insert_penalties = 0;       /* this will count the number of insertions held over */
-    save_split_top_skip = split_top_skip;
-    if (holding_inserts <= 0) {
+    save_split_top_skip = split_top_skip_par;
+    if (holding_inserts_par <= 0) {
         /* Prepare all the boxes involved in insertions to act as queues */
         /* If many insertions are supposed to go into the same box, we want to know
            the position of the last node in that box, so that we don't need to waste time
@@ -787,7 +767,7 @@
     p = vlink(prev_p);
     while (p != best_page_break) {
         if (type(p) == ins_node) {
-            if (holding_inserts <= 0) {
+            if (holding_inserts_par <= 0) {
                 /* Either insert the material specified by node |p| into the
                    appropriate box, or hold it for the next page;
                    also delete node |p| from the current page */
@@ -814,7 +794,7 @@
                                 while (vlink(s) != broken_ptr(r))
                                     s = vlink(s);
                                 vlink(s) = null;
-                                split_top_skip = split_top_ptr(p);
+                                split_top_skip_par = split_top_ptr(p);
                                 ins_ptr(p) =
                                     prune_page_top(broken_ptr(r), false);
                                 if (ins_ptr(p) != null) {
@@ -831,7 +811,7 @@
                         t = list_ptr(box(n));
                         list_ptr(box(n)) = null;
                         flush_node(box(n));
-                        box(n) = vpack(t, 0, additional, body_direction);
+                        box(n) = vpack(t, 0, additional, body_direction_par);
 
                     } else {
                         while (vlink(s) != null)
@@ -869,7 +849,7 @@
         prev_p = p;
         p = vlink(prev_p);
     }
-    split_top_skip = save_split_top_skip;
+    split_top_skip_par = save_split_top_skip;
     /* Break the current page at node |p|, put it in box~|output_box|,
        and put the remaining nodes on the contribution list */
     /* When the following code is executed, the current page runs from node
@@ -891,14 +871,14 @@
         couple_nodes(contrib_head, p);
         vlink(prev_p) = null;
     }
-    save_vbadness = vbadness;
-    vbadness = inf_bad;
-    save_vfuzz = vfuzz;
-    vfuzz = max_dimen;          /* inhibit error messages */
-    box(output_box) = filtered_vpackage(vlink(page_head),
-        best_size, exactly, page_max_depth, output_group, body_direction, 0, 0);
-    vbadness = save_vbadness;
-    vfuzz = save_vfuzz;
+    save_vbadness = vbadness_par;
+    vbadness_par = inf_bad;
+    save_vfuzz = vfuzz_par;
+    vfuzz_par = max_dimen;          /* inhibit error messages */
+    box(output_box_par) = filtered_vpackage(vlink(page_head),
+        best_size, exactly, page_max_depth, output_group, body_direction_par, 0, 0);
+    vbadness_par = save_vbadness;
+    vfuzz_par = save_vfuzz;
     if (last_glue != max_halfword)
         flush_node(last_glue);
     /* Start a new current page */
@@ -911,7 +891,7 @@
     /* Delete the page-insertion nodes */
     r = vlink(page_ins_head);
     while (r != page_ins_head) {
-	    /* todo: couple */ 
+	    /* todo: couple */
         q = vlink(r);
         flush_node(r);
         r = q;
@@ -924,8 +904,8 @@
             add_token_ref(top_mark(i));
         }
     }
-    if (output_routine != null) {
-        if (dead_cycles >= max_dead_cycles) {
+    if (output_routine_par != null) {
+        if (dead_cycles >= max_dead_cycles_par) {
             /* Explain that too many dead cycles have occurred in a row */
             print_err("Output loop---");
             print_int(dead_cycles);
@@ -941,9 +921,9 @@
             incr(dead_cycles);
             push_nest();
             mode = -vmode;
-            prev_depth = ignore_depth;
-            mode_line = -line;
-            begin_token_list(output_routine, output_text);
+            prev_depth_par = ignore_depth;
+            mode_line_par = -line;
+            begin_token_list(output_routine_par, output_text);
             new_save_level(output_group);
             normal_paragraph();
             scan_left_brace();
@@ -967,8 +947,8 @@
     }
     flush_node_list(page_disc);
     page_disc = null;
-    ship_out(static_pdf, box(output_box), SHIPPING_PAGE);
-    box(output_box) = null;
+    ship_out(static_pdf, box(output_box_par), SHIPPING_PAGE);
+    box(output_box_par) = null;
 }
 
 @ When the user's output routine finishes, it has constructed a vlist
@@ -996,13 +976,13 @@
     output_active = false;
     insert_penalties = 0;
     /* Ensure that box |output_box| is empty after output */
-    if (box(output_box) != null) {
+    if (box(output_box_par) != null) {
         print_err("Output routine didn't use all of \\box");
-        print_int(output_box);
+        print_int(output_box_par);
         help3("Your \\output commands should empty \\box\\outputbox,",
               "e.g., by saying `\\shipout\\box\\outputbox'.",
               "Proceed; I'll discard its present contents.");
-        box_error(output_box);
+        box_error(output_box_par);
     }
 
     if (tail != head) {         /* current list goes after heldover insertions */
--- texlive-bin.orig/texk/web2c/luatexdir/tex/commands.h
+++ texlive-bin/texk/web2c/luatexdir/tex/commands.h
@@ -161,6 +161,7 @@
     assign_mu_glue_cmd,                   /* user-defined muglue ( \.{\\thinmuskip}, etc.~) */
     assign_font_dimen_cmd,                /* user-defined font dimension ( \.{\\fontdimen} ) */
     assign_font_int_cmd,                  /* user-defined font integer ( \.{\\hyphenchar}, \.{\\skewchar} ) */
+    assign_hang_indent_cmd,
     set_aux_cmd,                          /* specify state info ( \.{\\spacefactor}, \.{\\prevdepth} ) */
     set_prev_graf_cmd,                    /* specify state info ( \.{\\prevgraf} ) */
     set_page_dimen_cmd,                   /* specify state info ( \.{\\pagegoal}, etc.~) */
@@ -326,11 +327,14 @@
     expand_font_code,
 } normal_codes;
 
-#  define lp_code_base 2
-#  define rp_code_base 3
-#  define ef_code_base 4
-#  define tag_code 5
-#  define no_lig_code 6
+typedef enum {
+    lp_code_base = 2,
+    rp_code_base = 3,
+    ef_code_base = 4,
+    tag_code     = 5,
+    no_lig_code  = 6,
+    gp_code_base = 7
+} font_codes ;
 
 #  define immediate_code 4      /* command modifier for \.{\\immediate} */
 
--- texlive-bin.orig/texk/web2c/luatexdir/tex/commands.w
+++ texlive-bin/texk/web2c/luatexdir/tex/commands.w
@@ -557,6 +557,8 @@
     primitive_luatex("Umathlimitbelowvgap", set_math_param_cmd, math_param_limit_below_vgap, 0);
     primitive_luatex("Umathlimitbelowbgap", set_math_param_cmd, math_param_limit_below_bgap, 0);
     primitive_luatex("Umathlimitbelowkern", set_math_param_cmd, math_param_limit_below_kern, 0);
+    primitive_luatex("Umathnolimitsubfactor", set_math_param_cmd, math_param_nolimit_sub_factor, 0); /* bonus */
+    primitive_luatex("Umathnolimitsupfactor", set_math_param_cmd, math_param_nolimit_sup_factor, 0); /* bonus */
     primitive_luatex("Umathunderdelimitervgap", set_math_param_cmd, math_param_under_delimiter_vgap, 0);
     primitive_luatex("Umathunderdelimiterbgap", set_math_param_cmd, math_param_under_delimiter_bgap, 0);
     primitive_luatex("Umathoverdelimitervgap", set_math_param_cmd, math_param_over_delimiter_vgap, 0);
@@ -689,6 +691,7 @@
     primitive_luatex("pardir", assign_dir_cmd, int_base + par_direction_code, dir_base);
     primitive_luatex("textdir", assign_dir_cmd, int_base + text_direction_code, dir_base);
     primitive_luatex("mathdir", assign_dir_cmd, int_base + math_direction_code, dir_base);
+    primitive_luatex("linedir", assign_dir_cmd, int_base + line_direction_code, dir_base);
     primitive_luatex("pageleftoffset", assign_dimen_cmd, dimen_base + page_left_offset_code, dimen_base);
     primitive_luatex("pagetopoffset", assign_dimen_cmd, dimen_base + page_top_offset_code, dimen_base);
     primitive_luatex("pagerightoffset", assign_dimen_cmd, dimen_base + page_right_offset_code, dimen_base);
@@ -750,6 +753,9 @@
     primitive_luatex("matheqnogapstep", assign_int_cmd, int_base + math_eqno_gap_step_code, int_base);
     primitive_luatex("mathdisplayskipmode", assign_int_cmd, int_base + math_display_skip_mode_code, int_base);
     primitive_luatex("mathscriptsmode", assign_int_cmd, int_base + math_scripts_mode_code, int_base);
+    primitive_luatex("mathnolimitsmode", assign_int_cmd, int_base + math_nolimits_mode_code, int_base);
+    primitive_luatex("mathrulesmode", assign_int_cmd, int_base + math_rules_mode_code, int_base);
+    primitive_luatex("mathrulesfam", assign_int_cmd, int_base + math_rules_fam_code, int_base);
     primitive_luatex("synctex", assign_int_cmd, int_base + synctex_code, int_base);
 
     primitive_etex("currentgrouplevel", last_item_cmd, current_group_level_code, 0);
@@ -767,6 +773,9 @@
     primitive_etex("parshapeindent", last_item_cmd, par_shape_indent_code, 0);
     primitive_etex("parshapedimen", last_item_cmd, par_shape_dimen_code, 0);
 
+    primitive_luatex("shapemode", assign_int_cmd, int_base + shape_mode_code, int_base);
+    primitive_luatex("hyphenationbounds", assign_int_cmd, int_base + hyphenation_bounds_code, int_base);
+
     primitive_etex("showgroups", xray_cmd, show_groups, 0);
 
     /*
--- texlive-bin.orig/texk/web2c/luatexdir/tex/conditional.w
+++ texlive-bin/texk/web2c/luatexdir/tex/conditional.w
@@ -21,9 +21,6 @@
 
 #include "ptexlib.h"
 
-@ @c
-#define box(A) eqtb[box_base+(A)].hh.rh
-
 @* We consider now the way \TeX\ handles various kinds of \.{\\if} commands.
 
 @ Conditions can be inside conditions, and this nesting has a stack
@@ -79,7 +76,7 @@
         }
     }
     scanner_status = save_scanner_status;
-    if (int_par(tracing_ifs_code) > 0)
+    if (tracing_ifs_par > 0)
         show_cur_cmd_chr();
 }
 
@@ -163,7 +160,7 @@
     }
     if (cur_cmd != end_cs_name_cmd) {
         last_tested_cs = null_cs;
-        if (int_par(suppress_ifcsname_error_code)) {
+        if (suppress_ifcsname_error_par) {
             do {
                 get_x_token();
             } while (cur_cmd != end_cs_name_cmd);
@@ -241,7 +238,7 @@
     halfword save_cond_ptr;     /*|cond_ptr| corresponding to this conditional */
     int this_if;                /*type of this conditional */
     boolean is_unless;          /*was this if preceded by `\.{\\unless}' ? */
-    if ((int_par(tracing_ifs_code) > 0) && (int_par(tracing_commands_code) <= 1))
+    if ((tracing_ifs_par > 0) && (tracing_commands_par <= 1))
         show_cur_cmd_chr();
     push_condition_stack();
     save_cond_ptr = cond_ptr;
@@ -441,7 +438,7 @@
             scan_int();
             /* |n| is the number of cases to pass */
             n = cur_val;
-            if (int_par(tracing_commands_code) > 1) {
+            if (tracing_commands_par > 1) {
                 begin_diagnostic();
                 tprint("{case ");
                 print_int(n);
@@ -508,7 +505,7 @@
     }
     if (is_unless)
         b = !b;
-    if (int_par(tracing_commands_code) > 1) {
+    if (tracing_commands_par > 1) {
         /* Display the value of |b| */
         begin_diagnostic();
         if (b)
--- texlive-bin.orig/texk/web2c/luatexdir/tex/dumpdata.w
+++ texlive-bin/texk/web2c/luatexdir/tex/dumpdata.w
@@ -19,15 +19,11 @@
 
 @ @c
 
-
 #include "ptexlib.h"
 
-#define font_id_text(A) cs_text(font_id_base+(A))
-#define prev_depth cur_list.prev_depth_field
-
 /* we start with 907: the sum of the values of the bytes of "don knuth" */
 
-#define FORMAT_ID (907+15)
+#define FORMAT_ID (907+20)
 #if ((FORMAT_ID>=0) && (FORMAT_ID<=256))
 #error Wrong value for FORMAT_ID.
 #endif
@@ -91,11 +87,11 @@
     tprint(" (format=");
     print(job_name);
     print_char(' ');
-    print_int(int_par(year_code));
+    print_int(year_par);
     print_char('.');
-    print_int(int_par(month_code));
+    print_int(month_par);
     print_char('.');
-    print_int(int_par(day_code));
+    print_int(day_par);
     print_char(')');
     str_room(2);
     format_ident = make_string();
@@ -308,7 +304,7 @@
     dump_int(69069);
     /* We have already printed a lot of statistics, so we set |tracing_stats:=0|
        to prevent them from appearing again. */
-    int_par(tracing_stats_code) = 0;
+    tracing_stats_par = 0;
 
     /* Dump the lua bytecodes */
     dump_luac_registers();
@@ -520,7 +516,7 @@
     /* Undump the lua bytecodes */
     undump_luac_registers();
 
-    prev_depth = ignore_depth;
+    prev_depth_par = ignore_depth;
     return true;                /* it worked! */
   BAD_FMT:
     wake_up_terminal();
--- texlive-bin.orig/texk/web2c/luatexdir/tex/equivalents.h
+++ texlive-bin/texk/web2c/luatexdir/tex/equivalents.h
@@ -278,24 +278,30 @@
 #  define math_eqno_gap_step_code 87                                    /* factor/1000 used for distance between eq and eqno */
 #  define math_display_skip_mode_code 88
 #  define math_scripts_mode_code 89
-#  define synctex_code 90                                               /* is synctex file generation enabled ?  */
-#  define first_valid_language_code 91
+#  define math_nolimits_mode_code 90
+#  define math_rules_mode_code 91
+#  define math_rules_fam_code 92
+#  define synctex_code 93                                               /* is synctex file generation enabled ?  */
+#  define shape_mode_code 94
+#  define first_valid_language_code 95
+#  define hyphenation_bounds_code 96
+
+#  define math_option_code 97
 
-#  define math_option_code 92
+#  define mathoption_int_base (int_base+98)                             /* one reserve */
+#  define mathoption_int_last (int_base+106)
 
-#  define mathoption_int_base (int_base+93)
-#  define mathoption_int_last (int_base+99)
+#  define backend_int_base (int_base+107)
+#  define backend_int_last (int_base+131)
 
-#  define backend_int_base (int_base+100)
-#  define backend_int_last (int_base+124)
-
-#  define tex_int_pars (125)                                            /* total number of integer parameters */
+#  define tex_int_pars (132)                                            /* total number of integer parameters */
 
 #  define page_direction_code (tex_int_pars)
 #  define body_direction_code (tex_int_pars+1)
 #  define par_direction_code  (tex_int_pars+2)
 #  define text_direction_code (tex_int_pars+3)
 #  define math_direction_code (tex_int_pars+4)
+#  define line_direction_code (tex_int_pars+5)                          /* gets remapped so is no real register */
 
 #  define int_pars (tex_int_pars+5)                                     /* total number of integer parameters */
 
@@ -533,16 +539,251 @@
 
 extern halfword last_cs_name;
 
-/* more will move here */
+/*
+    The *_par macros expand to the variables that are (in most cases) also accessible
+    at the users end. Most are registers but some are in the (stack) lists.
+
+    More *_par will move here : there is no real need for thse macros but because there
+    were already a bunch and because they were defined all over the place we moved them
+    here.
+
+*/
+
+#define space_skip_par                     glue_par(space_skip_code)
+#define xspace_skip_par                    glue_par(xspace_skip_code)
+#define math_skip_par                      glue_par(math_skip_code)
+
+#define pre_display_size_par               dimen_par(pre_display_size_code)
+#define display_width_par                  dimen_par(display_width_code)
+#define display_indent_par                 dimen_par(display_indent_code)
+#define math_surround_par                  dimen_par(math_surround_code)
+
+#define display_skip_mode_par              int_par(math_display_skip_mode_code)
+#define math_eqno_gap_step_par             int_par(math_eqno_gap_step_code)
+
+#define body_direction_par                 int_par(body_direction_code)
+#define page_direction_par                 int_par(page_direction_code)
+#define par_direction_par                  int_par(par_direction_code)
+#define text_direction_par                 int_par(text_direction_code)
+#define math_direction_par                 int_par(math_direction_code)
+
+#define shape_mode_par                     int_par(shape_mode_code)
+#define hyphenation_bounds_par             int_par(hyphenation_bounds_code)
+#define first_valid_language_par           int_par(first_valid_language_code)
+
+#define hsize_par                          dimen_par(hsize_code)
+#define vsize_par                          dimen_par(vsize_code)
+#define hfuzz_par                          dimen_par(hfuzz_code)
+#define vfuzz_par                          dimen_par(vfuzz_code)
+#define hbadness_par                       int_par(hbadness_code)
+#define vbadness_par                       int_par(vbadness_code)
+
+#define baseline_skip_par                  glue_par(baseline_skip_code)
+#define par_indent_par                     dimen_par(par_indent_code)
+#define hang_indent_par                    dimen_par(hang_indent_code)
+#define hang_after_par                     int_par(hang_after_code)
+#define left_skip_par                      glue_par(left_skip_code)
+#define right_skip_par                     glue_par(right_skip_code)
+
+#define emergency_stretch_par              dimen_par(emergency_stretch_code)
+#define pretolerance_par                   int_par(pretolerance_code)
+#define tolerance_par                      int_par(tolerance_code)
+#define looseness_par                      int_par(looseness_code)
+#define adjust_spacing_par                 int_par(adjust_spacing_code)
+#define adj_demerits_par                   int_par(adj_demerits_code)
+#define protrude_chars_par                 int_par(protrude_chars_code)
+#define line_penalty_par                   int_par(line_penalty_code)
+#define last_line_fit_par                  int_par(last_line_fit_code)
+#define double_hyphen_demerits_par         int_par(double_hyphen_demerits_code)
+#define final_hyphen_demerits_par          int_par(final_hyphen_demerits_code)
+#define inter_line_penalty_par             int_par(inter_line_penalty_code)
+#define club_penalty_par                   int_par(club_penalty_code)
+#define broken_penalty_par                 int_par(broken_penalty_code)
+#define display_widow_penalty_par          int_par(display_widow_penalty_code)
+#define widow_penalty_par                  int_par(widow_penalty_code)
+#define line_skip_limit_par                dimen_par(line_skip_limit_code)
+
+#define delimiter_shortfall_par            dimen_par(delimiter_shortfall_code)
+#define null_delimiter_space_par           dimen_par(null_delimiter_space_code)
+#define script_space_par                   dimen_par(script_space_code)
+#define max_depth_par                      dimen_par(max_depth_code)
+#define box_max_depth_par                  dimen_par(box_max_depth_code)
+#define split_max_depth_par                dimen_par(split_max_depth_code)
+#define overfull_rule_par                  dimen_par(overfull_rule_code)
+#define box_max_depth_par                  dimen_par(box_max_depth_code)
+#define top_skip_par                       glue_par(top_skip_code)
+#define split_top_skip_par                 glue_par(split_top_skip_code)
+
+#define cur_fam_par                        int_par(cur_fam_code)
+#define pre_display_direction_par          int_par(pre_display_direction_code)
+#define pre_display_penalty_par            int_par(pre_display_penalty_code)
+#define post_display_penalty_par           int_par(post_display_penalty_code)
+
+#define cur_fam_par_in_range               ((cur_fam_par>=0)&&(cur_fam_par<256))
+
+#define local_inter_line_penalty_par       int_par(local_inter_line_penalty_code)
+#define local_broken_penalty_par           int_par(local_broken_penalty_code)
+#define local_left_box_par                 equiv(local_left_box_base)
+#define local_right_box_par                equiv(local_right_box_base)
+
+#define end_line_char_par                  int_par(end_line_char_code)
+#define new_line_char_par                  int_par(new_line_char_code)
+#define escape_char_par                    int_par(escape_char_code)
+
+#define end_line_char_inactive             ((end_line_char_par < 0) || (end_line_char_par > 127))
+
+#define delimiter_factor_par               int_par(delimiter_factor_code)
+#define bin_op_penalty_par                 int_par(bin_op_penalty_code)
+#define rel_penalty_par                    int_par(rel_penalty_code)
+#define null_delimiter_space_par           dimen_par(null_delimiter_space_code)
+#define disable_lig_par                    int_par(disable_lig_code)
+#define disable_kern_par                   int_par(disable_kern_code)
+#define disable_space_par                  int_par(disable_space_code)
+#define scripts_mode_par                   int_par(math_scripts_mode_code)
+#define nolimits_mode_par                  int_par(math_nolimits_mode_code)
+#define math_rules_mode_par                int_par(math_rules_mode_code)
+#define math_rules_fam_par                 int_par(math_rules_fam_code)
+
+#define thin_mu_skip_par                   glue_par(thin_mu_skip_code)
+#define med_mu_skip_par                    glue_par(med_mu_skip_code)
+#define thick_mu_skip_par                  glue_par(thick_mu_skip_code)
+
+#define every_math_par                     equiv(every_math_loc)
+#define every_display_par                  equiv(every_display_loc)
+#define every_cr_par                       equiv(every_cr_loc)
+#define every_hbox_par                     equiv(every_hbox_loc)
+#define every_vbox_par                     equiv(every_vbox_loc)
+#define every_eof_par                      equiv(every_eof_loc)
+#define every_par_par                      equiv(every_par_loc)
+#define err_help_par                       equiv(err_help_loc)
+
+#define no_local_whatsits_par              int_par(no_local_whatsits_code)
+#define no_local_dirs_par                  int_par(no_local_dirs_code)
+
+#define prev_depth_par                     cur_list.prev_depth_field
+#define prev_graf_par                      cur_list.pg_field
+#define tail_par                           cur_list.tail_field
+#define head_par                           cur_list.head_field
+#define mode_par                           cur_list.mode_field
+#define dirs_par                           cur_list.dirs_field
+#define space_factor_par                   cur_list.space_factor_field
+#define incompleat_noad_par                cur_list.incompleat_noad_field
+#define mode_line_par                      cur_list.ml_field
+#define aux_par                            cur_list.eTeX_aux_field
+#define delim_par                          aux_par
+
+#define par_shape_par_ptr                  equiv(par_shape_loc)
+#define inter_line_penalties_par_ptr       equiv(inter_line_penalties_loc)
+#define club_penalties_par_ptr             equiv(club_penalties_loc)
+#define widow_penalties_par_ptr            equiv(widow_penalties_loc)
+#define display_widow_penalties_par_ptr    equiv(display_widow_penalties_loc)
+
+#define page_width_par                     dimen_par(page_width_code)
+#define page_height_par                    dimen_par(page_height_code)
+#define h_offset_par                       dimen_par(h_offset_code)
+#define v_offset_par                       dimen_par(v_offset_code)
+#define page_left_offset_par               dimen_par(page_left_offset_code)
+#define page_top_offset_par                dimen_par(page_top_offset_code)
+#define page_right_offset_par              dimen_par(page_right_offset_code)
+#define page_bottom_offset_par             dimen_par(page_bottom_offset_code)
+#define px_dimen_par                       dimen_par(px_dimen_code)
+
+#define max_dead_cycles_par                int_par(max_dead_cycles_code)
+#define output_box_par                     int_par(output_box_code)
+#define holding_inserts_par                int_par(holding_inserts_code)
+#define output_routine_par                 equiv(output_routine_loc)
+#define floating_penalty_par               int_par(floating_penalty_code)
+
+#define mag_par                            int_par(mag_code)
+
+#define global_defs_par                    int_par(global_defs_code)
+#define cat_code_table_par                 int_par(cat_code_table_code)
+#define saving_vdiscards_par               int_par(saving_vdiscards_code)
+
+#define tracing_output_par                 int_par(tracing_output_code)
+#define tracing_stats_par                  int_par(tracing_stats_code)
+#define tracing_online_par                 int_par(tracing_online_code)
+#define tracing_paragraphs_par             int_par(tracing_paragraphs_code)
+#define tracing_nesting_par                int_par(tracing_nesting_code)
+#define tracing_lost_chars_par             int_par(tracing_lost_chars_code)
+#define tracing_scan_tokens_par            int_par(tracing_scan_tokens_code)
+#define tracing_ifs_par                    int_par(tracing_ifs_code)
+#define tracing_commands_par               int_par(tracing_commands_code)
+#define tracing_macros_par                 int_par(tracing_macros_code)
+#define tracing_assigns_par                int_par(tracing_assigns_code)
+#define tracing_fonts_par                  int_par(tracing_fonts_code)
+#define tracing_pages_par                  int_par(tracing_pages_code)
+#define tracing_restores_par               int_par(tracing_restores_code)
+#define tracing_groups_par                 int_par(tracing_groups_code)
+
+#define show_box_depth_par                 int_par(show_box_depth_code)
+#define show_box_breadth_par               int_par(show_box_breadth_code)
+
+#define pausing_par                        int_par(pausing_code)
+
+#define suppress_outer_error_par           int_par(suppress_outer_error_code)
+#define suppress_long_error_par            int_par(suppress_long_error_code)
+#define suppress_mathpar_error_par         int_par(suppress_mathpar_error_code)
+#define suppress_fontnotfound_error_par    int_par(suppress_fontnotfound_error_code)
+#define suppress_ifcsname_error_par        int_par(suppress_ifcsname_error_code)
+#define error_context_lines_par            int_par(error_context_lines_code)
+
+#define math_old_par                       mathoption_int_par(c_mathoption_old_code)
+#define math_no_italic_compensation_par    mathoption_int_par(c_mathoption_no_italic_compensation_code)
+#define math_no_char_italic_par            mathoption_int_par(c_mathoption_no_char_italic_code)
+#define math_use_old_fraction_scaling_par  mathoption_int_par(c_mathoption_use_old_fraction_scaling_code)
+#define math_umathcode_meaning_par         mathoption_int_par(c_mathoption_umathcode_meaning_code)
+
+#define time_par                           int_par(time_code)
+#define day_par                            int_par(day_code)
+#define month_par                          int_par(month_code)
+#define year_par                           int_par(year_code)
+
+#define output_mode_par                    int_par(output_mode_code)
+#define draft_mode_par                     int_par(draft_mode_code)
+#define synctex_par                        int_par(synctex_code)
+
+#define language_par                       int_par(language_code)
+#define uc_hyph_par                        int_par(uc_hyph_code)
+#define left_hyphen_min_par                int_par(left_hyphen_min_code)
+#define right_hyphen_min_par               int_par(right_hyphen_min_code)
+#define ex_hyphen_char_par                 int_par(ex_hyphen_char_code)
+#define hyphen_penalty_par                 int_par(hyphen_penalty_code)
+#define ex_hyphen_penalty_par              int_par(ex_hyphen_penalty_code)
+#define default_hyphen_char_par            int_par(default_hyphen_char_code)
+#define default_skew_char_par              int_par(default_skew_char_code)
+#define saving_hyph_codes_par              int_par(saving_hyph_codes_code)
+
+#define cur_lang_par                       int_par(cur_lang_code)
+#define cur_font_par                       equiv(cur_font_loc)
+
+/* */
+
+#define math_use_current_family_code 7
+
+/*
+    #define box(A) equiv(box_base+(A))
+    #define box(A) eqtb[box_base+(A)].hh.rh
+*/
+
+#define attribute(A) equiv(attribute_base+(A))
+#define box(A)       equiv(box_base+(A))
+#define count(A)     equiv(count_base+(A))
+#define dimen(A)     equiv(scaled_base+(A))
+#define mu_skip(A)   equiv(mu_skip_base+(A))
+#define skip(A)      equiv(skip_base+(A))
+#define toks(A)      equiv(toks_base+(A))
+
+#define get_tex_attribute_register(j) attribute(j)
+#define get_tex_box_register(j)       box(j)
+#define get_tex_count_register(j)     count(j)
+#define get_tex_dimen_register(j)     dimen(j)
+#define get_tex_mu_skip_register(j)   mu_skip(j)
+#define get_tex_skip_register(j)      skip(j)
+
+#define font_id_text(A) cs_text(font_id_base+(A))
 
-#define space_skip glue_par(space_skip_code)
-#define xspace_skip glue_par(xspace_skip_code)
-#define math_skip glue_par(math_skip_code)
-
-#define body_direction int_par(body_direction_code)
-#define page_direction int_par(page_direction_code)
-#define par_direction  int_par(par_direction_code)
-#define text_direction int_par(text_direction_code)
-#define math_direction int_par(math_direction_code)
+#define end_template_token  (cs_token_flag+frozen_end_template)
+#define end_write_token     (cs_token_flag+end_write)
 
 #endif
--- texlive-bin.orig/texk/web2c/luatexdir/tex/equivalents.w
+++ texlive-bin/texk/web2c/luatexdir/tex/equivalents.w
@@ -37,8 +37,6 @@
 }
 
 @ @c
-#define par_shape_ptr equiv(par_shape_loc)
-
 void show_eqtb_meaning(halfword n);     /* forward */
 
 @ Now that we have studied the data structures for \TeX's semantic routines,
@@ -216,7 +214,7 @@
     /* quit if |(cur_level+1)| is too big to be stored in |eqtb| */
     cur_boundary = save_ptr;
     cur_group = c;
-    if (int_par(tracing_groups_code) > 0)
+    if (tracing_groups_par > 0)
         group_trace(false);
     incr(cur_level);
     incr(save_ptr);
@@ -627,7 +625,7 @@
 @c
 void eq_define(halfword p, quarterword t, halfword e)
 {
-    boolean trace = int_par(tracing_assigns_code) > 0;
+    boolean trace = tracing_assigns_par > 0;
     if ((eq_type(p) == t) && (equiv(p) == e)) {
         if (trace)
             diagnostic_trace(p, "reassigning");
@@ -654,7 +652,7 @@
 @c
 void eq_word_define(halfword p, int w)
 {
-    boolean trace = int_par(tracing_assigns_code) > 0;
+    boolean trace = tracing_assigns_par > 0;
     if (eqtb[p].cint == w) {
         if (trace)
             diagnostic_trace(p, "reassigning");
@@ -680,7 +678,7 @@
 @c
 void geq_define(halfword p, quarterword t, halfword e)
 {                               /* global |eq_define| */
-    boolean trace = int_par(tracing_assigns_code) > 0;
+    boolean trace = tracing_assigns_par > 0;
     if (trace)
         diagnostic_trace(p, "globally changing");
     eq_destroy(eqtb[p]);
@@ -693,7 +691,7 @@
 
 void geq_word_define(halfword p, int w)
 {                               /* global |eq_word_define| */
-    boolean trace = int_par(tracing_assigns_code) > 0;
+    boolean trace = tracing_assigns_par > 0;
     if (trace)
         diagnostic_trace(p, "globally changing");
     eqtb[p].cint = w;
@@ -727,11 +725,11 @@
     quarterword l = level_one;  /* saved level, if in fullword regions of |eqtb| */
     boolean a = false;          /* have we already processed an \.{\\aftergroup} ? */
     unsave_math_codes(cur_level);
-    unsave_cat_codes(int_par(cat_code_table_code), cur_level);
+    unsave_cat_codes(cat_code_table_par, cur_level);
     unsave_text_codes(cur_level);
     unsave_math_data(cur_level);
     if (cur_level > level_one) {
-        boolean trace = int_par(tracing_restores_code) > 0;
+        boolean trace = tracing_restores_par > 0;
         decr(cur_level);
         /* Clear off top level from |save_stack| */
         while (true) {
@@ -778,7 +776,7 @@
                 }
             }
         }
-        if (int_par(tracing_groups_code) > 0)
+        if (tracing_groups_par > 0)
             group_trace(true);
         if (grp_stack[in_open] == cur_boundary)
             group_warning();    /* groups possibly not properly nested with files */
@@ -798,19 +796,17 @@
 whenever it becomes necessary to ``freeze'' it at a particular value.
 
 @c
-int mag_set; /* if nonzero, this magnification should be used henceforth */
+int mag_set = 0; /* if nonzero, this magnification should be used henceforth */
 
 @ The |prepare_mag| subroutine is called whenever \TeX\ wants to use |mag|
 for magnification.
 
 @c
-#define mag int_par(mag_code)
-
 void prepare_mag(void)
 {
-    if ((mag_set > 0) && (mag != mag_set)) {
+    if ((mag_set > 0) && (mag_par != mag_set)) {
         print_err("Incompatible magnification (");
-        print_int(mag);
+        print_int(mag_par);
         tprint(");");
         tprint_nl(" the previous value will be retained");
         help2("I can handle only one magnification ratio per job. So I've",
@@ -818,19 +814,19 @@
         int_error(mag_set);
         geq_word_define(int_base + mag_code, mag_set);  /* |mag:=mag_set| */
     }
-    if ((mag <= 0) || (mag > 32768)) {
+    if ((mag_par <= 0) || (mag_par > 32768)) {
         print_err("Illegal magnification has been changed to 1000");
         help1("The magnification ratio must be between 1 and 32768.");
-        int_error(mag);
+        int_error(mag_par);
         geq_word_define(int_base + mag_code, 1000);
     }
-    if ((mag_set == 0) && (mag != mag_set)) {
-        if (mag != 1000)
-            one_true_inch = xn_over_d(one_hundred_inch, 10, mag);
+    if ((mag_set == 0) && (mag_par != mag_set)) {
+        if (mag_par != 1000)
+            one_true_inch = xn_over_d(one_hundred_inch, 10, mag_par);
         else
             one_true_inch = one_inch;
     }
-    mag_set = mag;
+    mag_set = mag_par;
 }
 
 @ Let's pause a moment now and try to look at the Big Picture.
@@ -888,8 +884,6 @@
 @ Here is a procedure that displays the current command.
 
 @c
-#define mode cur_list.mode_field
-
 void show_cur_cmd_chr(void)
 {
     int n;                      /* level of \.{\\if...\\fi} nesting */
@@ -897,13 +891,13 @@
     halfword p;
     begin_diagnostic();
     tprint_nl("{");
-    if (mode != shown_mode) {
-        print_mode(mode);
+    if (mode_par != shown_mode) {
+        print_mode(mode_par);
         tprint(": ");
-        shown_mode = mode;
+        shown_mode = mode_par;
     }
     print_cmd_chr((quarterword) cur_cmd, cur_chr);
-    if (int_par(tracing_ifs_code) > 0) {
+    if (tracing_ifs_par > 0) {
         if (cur_cmd >= if_test_cmd) {
             if (cur_cmd <= fi_or_else_cmd) {
                 tprint(": ");
@@ -1013,7 +1007,7 @@
                 if (penalty(equiv(n)) > 1)
                     tprint_esc("ETC.");
             } else {
-                print_int(vinfo(par_shape_ptr + 1));
+                print_int(vinfo(par_shape_par_ptr + 1));
             }
         } else if (n < toks_base) {
             print_cmd_chr(assign_toks_cmd, n);
--- texlive-bin.orig/texk/web2c/luatexdir/tex/errors.w
+++ texlive-bin/texk/web2c/luatexdir/tex/errors.w
@@ -24,9 +24,7 @@
 
 @ @c
 #include "ptexlib.h"
-
-@ @c
-#define new_line_char int_par(new_line_char_code)
+#define edit_var "TEXEDIT"
 
 @ When something anomalous is detected, \TeX\ typically does something like this:
 $$\vbox{\halign{#\hfil\cr
@@ -72,9 +70,9 @@
     int saved_new_line_char;
     int saved_new_string_line;
     selector = new_string;
-    saved_new_line_char = new_line_char;
+    saved_new_line_char = new_line_char_par;
     saved_new_string_line = new_string_line;
-    new_line_char = 10;
+    new_line_char_par = 10;
     new_string_line = 10;
     show_context();
     xfree(last_error_context);
@@ -82,7 +80,7 @@
     last_error_context = makecstring(str);
     flush_str(str);
     selector = sel;
-    new_line_char = saved_new_line_char;
+    new_line_char_par = saved_new_line_char;
     new_string_line = saved_new_string_line;
     return;
 }
@@ -222,6 +220,7 @@
 {
     update_terminal();
     ready_already = 0;
+    lua_close(Luas); /* new per 0.99 */
     if ((history != spotless) && (history != warning_issued))
         uexit(1);
     else
@@ -234,6 +233,155 @@
     close_files_and_terminate();
     do_final_end();
 }
+@ Here is the function that calls the editor, if one is defined. This
+is loosely based on a similar function in kpathsea, but the calling
+convention is quite different.
+
+@c
+static const_string edit_value = EDITOR;
+
+#if defined(WIN32)
+static int
+Isspace (char c)
+{
+  return (c == ' ' || c == '\t');
+}
+#endif /* WIN32 */
+
+__attribute__ ((noreturn))
+static void luatex_calledit (int baseptr, int linenumber)
+{
+  char *temp, *command, *fullcmd;
+  char c;
+  int sdone, ddone, i;
+  char *filename = makecstring(input_stack[base_ptr].name_field);
+  int fnlength = strlen(filename);
+
+#ifdef WIN32
+  char *fp, *ffp, *env, editorname[256], buffer[256];
+  int cnt = 0;
+  int dontchange = 0;
+#endif
+
+  sdone = ddone = 0;
+
+  /* Close any open input files, since we're going to kill the job.  */
+  close_files_and_terminate();
+
+  /* Replace the default with the value of the appropriate environment
+     variable or config file value, if it's set.  */
+  temp = kpse_var_value (edit_var);
+  if (temp != NULL)
+    edit_value = temp;
+
+  /* Construct the command string.  The `11' is the maximum length an
+     integer might be.  */
+  command = xmalloc (strlen (edit_value) + fnlength + 11);
+
+  /* So we can construct it as we go.  */
+  temp = command;
+
+#ifdef WIN32
+  fp = editorname;
+  if ((isalpha(*edit_value) && *(edit_value + 1) == ':'
+        && IS_DIR_SEP (*(edit_value + 2)))
+      || (*edit_value == '"' && isalpha(*(edit_value + 1))
+        && *(edit_value + 2) == ':'
+        && IS_DIR_SEP (*(edit_value + 3)))
+     )
+    dontchange = 1;
+#endif
+
+  while ((c = *edit_value++) != 0)
+    {
+      if (c == '%')
+        {
+          switch (c = *edit_value++)
+            {
+            case 'd':
+              if (ddone)
+                FATAL1 ("call_edit: `%%d' appears twice in editor command: `%s'", edit_value);
+              sprintf (temp, "%ld", (long int)linenumber);
+              while (*temp != '\0')
+                temp++;
+              ddone = 1;
+              break;
+
+            case 's':
+              if (sdone)
+                FATAL1 ("call_edit: `%%s' appears twice in editor command: `%s'", edit_value);
+              for (i =0; i < fnlength; i++)
+                *temp++ = filename[i];
+              sdone = 1;
+              break;
+
+            case '\0':
+              *temp++ = '%';
+              /* Back up to the null to force termination.  */
+              edit_value--;
+              break;
+
+            default:
+              *temp++ = '%';
+              *temp++ = c;
+              break;
+            }
+        }
+      else {
+#ifdef WIN32
+        if (dontchange)
+          *temp++ = c;
+        else { if(Isspace(c) && cnt == 0) {
+            cnt++;
+            temp = command;
+            *temp++ = c;
+            *fp = '\0';
+          } else if(!Isspace(c) && cnt == 0) {
+            *fp++ = c;
+          } else {
+            *temp++ = c;
+          }
+        }
+#else
+        *temp++ = c;
+#endif
+      }
+    }
+
+  *temp = 0;
+
+#ifdef WIN32
+  if (dontchange == 0) {
+    if(editorname[0] == '.' ||
+       editorname[0] == '/' ||
+       editorname[0] == '\\') {
+      fprintf(stderr, "%s is not allowed to execute.\n", editorname);
+      do_final_end();
+    }
+    env = (char *)getenv("PATH");
+    if(SearchPath(env, editorname, ".exe", 256, buffer, &ffp)==0) {
+      if(SearchPath(env, editorname, ".bat", 256, buffer, &ffp)==0) {
+        fprintf(stderr, "I cannot find %s in the PATH.\n", editorname);
+        do_final_end();
+      }
+    }
+    fullcmd = (char *)xmalloc(strlen(buffer)+strlen(command)+5);
+    strcpy(fullcmd, "\"");
+    strcat(fullcmd, buffer);
+    strcat(fullcmd, "\"");
+    strcat(fullcmd, command);
+  } else
+#endif
+  fullcmd = command;
+
+  /* Execute the command.  */
+  if (system (fullcmd) != 0)
+    fprintf (stderr, "! Trouble executing `%s'.\n", command);
+
+  /* Quit, since we found an error.  */
+  do_final_end ();
+}
+
 
 @ @c
 void error(void)
@@ -327,12 +475,23 @@
 #endif
             case 'E':
                 if (base_ptr > 0) {
-                    tprint_nl("You want to edit file ");
-                    print(input_stack[base_ptr].name_field);
-                    tprint(" at line ");
-                    print_int(line);
-                    interaction = scroll_mode;
-                    jump_out();
+                    int callback_id = callback_defined(call_edit_callback);
+                    if (callback_id>0) {
+                        (void)run_callback(callback_id, "Sd->", makecstring(input_stack[base_ptr].name_field), line);
+                        jump_out(); /* should not be reached */
+                    } else {
+                        tprint_nl("You want to edit file ");
+                        print(input_stack[base_ptr].name_field);
+                        tprint(" at line ");
+                        print_int(line);
+                        interaction = scroll_mode;
+                        if (kpse_init) {
+                            luatex_calledit(base_ptr, line);
+                        } else {
+                            tprint_nl("There is no valid callback defined.");
+                            jump_out(); /* should not be reached */
+                        }
+                    }
                 }
                 break;
             case 'H':
@@ -511,6 +670,11 @@
     print_char('=');
     print_int((int) n);
     print_char(']');
+    if (varmem == NULL) {
+      print_err("Sorry, I ran out of memory.");
+      print_ln();
+      exit(EXIT_FAILURE);
+    }
     help2("If you really absolutely need more capacity,",
           "you can ask a wizard to enlarge me.");
     succumb();
@@ -629,10 +793,10 @@
 {
     int old_setting;            /* saved value of |tracing_online| */
     int k;                      /* index to current digit; we assume that $0\L n<16^{22}$ */
-    if (int_par(tracing_lost_chars_code) > 0) {
-        old_setting = int_par(tracing_online_code);
-        if (int_par(tracing_lost_chars_code) > 1)
-            int_par(tracing_online_code) = 1;
+    if (tracing_lost_chars_par > 0) {
+        old_setting = tracing_online_par;
+        if (tracing_lost_chars_par > 1)
+            tracing_online_par = 1;
         begin_diagnostic();
         tprint_nl("Missing character: There is no ");
         print(c);
@@ -654,7 +818,7 @@
         print_font_name(f);
         print_char('!');
         end_diagnostic(false);
-        int_par(tracing_online_code) = old_setting;
+        tracing_online_par = old_setting;
     }
 }
 
@@ -737,8 +901,8 @@
     int report_id ;
     if (strcmp(t,"lua") == 0) {
         int saved_new_line_char;
-        saved_new_line_char = new_line_char;
-        new_line_char = 10;
+        saved_new_line_char = new_line_char_par;
+        new_line_char_par = 10;
         report_id = callback_defined(show_lua_error_hook_callback);
         if (report_id == 0) {
             tprint(p);
@@ -748,7 +912,7 @@
             (void) run_callback(report_id, "->");
         }
         error();
-        new_line_char = saved_new_line_char;
+        new_line_char_par = saved_new_line_char;
     } else {
         report_id = callback_defined(show_warning_message_callback);
         if (report_id > 0) {
--- texlive-bin.orig/texk/web2c/luatexdir/tex/expand.w
+++ texlive-bin/texk/web2c/luatexdir/tex/expand.w
@@ -80,7 +80,7 @@
   RESWITCH:
     if (cur_cmd < call_cmd) {
         /* Expand a nonmacro */
-        if (int_par(tracing_commands_code) > 1)
+        if (tracing_commands_par > 1)
             show_cur_cmd_chr();
         switch (cur_cmd) {
         case top_bot_mark_cmd:
@@ -247,8 +247,8 @@
                code, which is actually part of |expand|. It comes into play when
                \.{\\or}, \.{\\else}, or \.{\\fi} is scanned. */
 
-            if (int_par(tracing_ifs_code) > 0)
-                if (int_par(tracing_commands_code) <= 1)
+            if (tracing_ifs_par > 0)
+                if (tracing_commands_par <= 1)
                     show_cur_cmd_chr();
             if (cur_chr > if_limit) {
                 if (if_limit == if_code) {
@@ -554,7 +554,7 @@
     warning_index = cur_cs;
     ref_count = cur_chr;
     r = token_link(ref_count);
-    if (int_par(tracing_macros_code) > 0) {
+    if (tracing_macros_par > 0) {
         /* Show the text of the macro being expanded */
         begin_diagnostic();
         print_ln();
@@ -686,7 +686,7 @@
 
             if (cur_tok == par_token)
                 if (long_state != long_call_cmd)
-                    if (!int_par(suppress_long_error_code)) {
+                    if (!suppress_long_error_par) {
                         goto RUNAWAY;
                     }
             if (cur_tok < right_brace_limit) {
@@ -698,7 +698,7 @@
                         get_token();
                         if (cur_tok == par_token) {
                             if (long_state != long_call_cmd) {
-                                if (!int_par(suppress_long_error_code)) {
+                                if (!suppress_long_error_par) {
                                     goto RUNAWAY;
 
                                 }
@@ -768,7 +768,7 @@
                     pstack[n] = token_link(temp_token_head);
                 }
                 incr(n);
-                if (int_par(tracing_macros_code) > 0) {
+                if (tracing_macros_par > 0) {
                     begin_diagnostic();
                     print_nl(match_chr);
                     print_int(n);
--- texlive-bin.orig/texk/web2c/luatexdir/tex/extensions.w
+++ texlive-bin/texk/web2c/luatexdir/tex/extensions.w
@@ -24,18 +24,10 @@
 #include "ptexlib.h"
 
 @ @c
-#define mode          cur_list.mode_field
-#define tail          cur_list.tail_field
-#define head          cur_list.head_field
-#define prev_graf     cur_list.pg_field
-#define dir_save      cur_list.dirs_field
-
-#define tracing_nesting int_par(tracing_nesting_code)
-#define tracing_online int_par(tracing_online_code)
-#define box(A) eqtb[box_base+(A)].hh.rh
-#define global_defs int_par(global_defs_code)
-#define cat_code_table int_par(cat_code_table_code)
-#define toks(A) equiv(toks_base+(A))
+#define mode     mode_par
+#define tail     tail_par
+#define head     head_par
+#define dir_save dirs_par
 
 @ The program above includes a bunch of ``hooks'' that allow further
 capabilities to be added without upsetting \TeX's basic structure.
@@ -150,6 +142,8 @@
             set_pdf_literal_mode(tail, direct_always);
         else if (scan_keyword("page"))
             set_pdf_literal_mode(tail, direct_page);
+        else if (scan_keyword("raw"))
+            set_pdf_literal_mode(tail, direct_raw);
         else
             set_pdf_literal_mode(tail, set_origin);
         scan_toks(false, true);
@@ -302,7 +296,6 @@
             }
             break;
         case save_image_resource_code:
-            fix_pdf_minorversion(static_pdf);
             scan_pdfximage(static_pdf);
             if (immediate) {
                 pdf_write_image(static_pdf, last_saved_image_index);
@@ -477,8 +470,6 @@
 single page, the stack would overflow.
 
 @c
-#define end_write_token cs_token_flag+end_write
-
 void expand_macros_in_tokenlist(halfword p)
 {
     int old_mode;
@@ -741,7 +732,7 @@
         /* Set variable |w| to indicate if this case should be reported */
         /* This code scans the input stack in order to determine the type of the
            current input file. */
-        if (tracing_nesting > 0) {
+        if (tracing_nesting_par > 0) {
             while ((input_stack[base_ptr].state_field == token_list) ||
                    (input_stack[base_ptr].index_field > i))
                 decr(base_ptr);
@@ -757,7 +748,7 @@
         print_group(true);
         tprint(" of a different file");
         print_ln();
-        if (tracing_nesting > 1)
+        if (tracing_nesting_par > 1)
             show_context();
         if (history == spotless)
             history = warning_issued;
@@ -778,7 +769,7 @@
     input_stack[base_ptr] = cur_input;  /* store current state */
     while (if_stack[i] == cond_ptr) {
         /* Set variable |w| to... */
-        if (tracing_nesting > 0) {
+        if (tracing_nesting_par > 0) {
             while ((input_stack[base_ptr].state_field == token_list) ||
                    (input_stack[base_ptr].index_field > i))
                 decr(base_ptr);
@@ -795,7 +786,7 @@
         print_if_line(if_line);
         tprint(" of a different file");
         print_ln();
-        if (tracing_nesting > 1)
+        if (tracing_nesting_par > 1)
             show_context();
         if (history == spotless)
             history = warning_issued;
@@ -847,7 +838,7 @@
     cur_if = c;
     if_line = i;                /* restore old values */
     print_ln();
-    if (tracing_nesting > 1)
+    if (tracing_nesting_par > 1)
         show_context();
     if (history == spotless)
         history = warning_issued;
@@ -862,9 +853,6 @@
 defines are not available.
 
 @c
-#define dimen(A) eqtb[scaled_base+(A)].hh.rh
-#define count(A) eqtb[count_base+(A)].hh.rh
-
 #define get_tex_dimen_register(j) dimen(j)
 #define get_tex_skip_register(j) skip(j)
 #define get_tex_mu_skip_register(j) mu_skip(j)
@@ -902,7 +890,7 @@
 int set_tex_dimen_register(int j, scaled v)
 {
     int a;                      /* return non-nil for error */
-    if (global_defs > 0)
+    if (global_defs_par > 0)
         a = 4;
     else
         a = 0;
@@ -913,7 +901,7 @@
 int set_tex_skip_register(int j, halfword v)
 {
     int a;                      /* return non-nil for error */
-    if (global_defs > 0)
+    if (global_defs_par > 0)
         a = 4;
     else
         a = 0;
@@ -926,7 +914,7 @@
 int set_tex_mu_skip_register(int j, halfword v)
 {
     int a;                      /* return non-nil for error */
-    if (global_defs > 0)
+    if (global_defs_par > 0)
         a = 4;
     else
         a = 0;
@@ -939,7 +927,7 @@
 int set_tex_count_register(int j, scaled v)
 {
     int a;                      /* return non-nil for error */
-    if (global_defs > 0)
+    if (global_defs_par > 0)
         a = 4;
     else
         a = 0;
@@ -950,7 +938,7 @@
 int set_tex_box_register(int j, scaled v)
 {
     int a;                      /* return non-nil for error */
-    if (global_defs > 0)
+    if (global_defs_par > 0)
         a = 4;
     else
         a = 0;
@@ -961,7 +949,7 @@
 int set_tex_attribute_register(int j, scaled v)
 {
     int a;                      /* return non-nil for error */
-    if (global_defs > 0)
+    if (global_defs_par > 0)
         a = 4;
     else
         a = 0;
@@ -988,7 +976,7 @@
     (void) str_toks(s);
     set_token_ref_count(ref, 0);
     set_token_link(ref, token_link(temp_token_head));
-    if (global_defs > 0)
+    if (global_defs_par > 0)
         a = 4;
     else
         a = 0;
@@ -1003,7 +991,7 @@
     (void) str_scan_toks(c,s);
     set_token_ref_count(ref, 0);
     set_token_link(ref, token_link(temp_token_head));
-    if (global_defs > 0)
+    if (global_defs_par > 0)
         a = 4;
     else
         a = 0;
--- texlive-bin.orig/texk/web2c/luatexdir/tex/inputstack.w
+++ texlive-bin/texk/web2c/luatexdir/tex/inputstack.w
@@ -22,15 +22,11 @@
 #include "ptexlib.h"
 
 @ @c
-#define end_line_char int_par(end_line_char_code)
-#define error_context_lines int_par(error_context_lines_code)
-
 in_state_record *input_stack = NULL;
 int input_ptr = 0;              /* first unused location of |input_stack| */
 int max_in_stack = 0;           /* largest value of |input_ptr| when pushing */
 in_state_record cur_input;      /* the ``top'' input state */
 
-
 int in_open = 0;                /* the number of lines in the buffer, less one */
 int open_parens = 0;            /* the number of open text files */
 alpha_file *input_file = NULL;
@@ -39,7 +35,6 @@
 str_number *source_filename_stack = NULL;
 char **full_source_filename_stack = NULL;
 
-
 int scanner_status = 0;         /* can a subfile end now? */
 pointer warning_index = null;   /* identifier relevant to non-|normal| scanner status */
 pointer def_ref = null;         /* reference count of token list being defined */
@@ -235,7 +230,7 @@
 
 #define PSEUDO_PRINT_THE_LINE()	do { \
     begin_pseudoprint(); \
-    if (buffer[ilimit]==end_line_char) \
+    if (buffer[ilimit]==end_line_char_par) \
         j=ilimit; \
     else \
         j=ilimit+1; /* determine the effective end of the line */ \
@@ -300,7 +295,7 @@
             if ((iname > 21) || (base_ptr == 0))
                 bottom_line = true;
         }
-        if ((base_ptr == input_ptr) || bottom_line || (nn < error_context_lines)) {
+        if ((base_ptr == input_ptr) || bottom_line || (nn < error_context_lines_par)) {
             /* Display the current context */
             if ((base_ptr == input_ptr) || (istate != token_list) || (token_type != backed_up) || (iloc != null)) {
                 /* we omit backed-up token lists that have already been read */
@@ -381,10 +376,10 @@
                     tprint("...");
                 incr(nn);
             }
-        } else if (nn == error_context_lines) {
+        } else if (nn == error_context_lines_par) {
             tprint_nl("...");
             incr(nn);
-            /* omitted if |error_context_lines<0| */
+            /* omitted if |error_context_lines_par<0| */
         }
         if (bottom_line)
             break;
@@ -435,7 +430,7 @@
             param_start = param_ptr;
         } else {
             iloc = token_link(p);
-            if (int_par(tracing_macros_code) > 1) {
+            if (tracing_macros_par > 1) {
                 begin_diagnostic();
                 tprint_nl("");
                 if (t == mark_text)
@@ -726,7 +721,7 @@
     halfword p;    /* for list construction */
     s = make_string();
     /* Convert string |s| into a new pseudo file */
-    p = string_to_pseudo(s, int_par(new_line_char_code));
+    p = string_to_pseudo(s, new_line_char_par);
     vlink(p) = pseudo_files;
     pseudo_files = p;
     flush_str(s);
@@ -735,7 +730,7 @@
     line = 0;
     ilimit = istart;
     iloc = ilimit + 1; /* force line read */
-    if (int_par(tracing_scan_tokens_code) > 0) {
+    if (tracing_scan_tokens_par > 0) {
         if (term_offset > max_print_line - 3)
             print_ln();
         else if ((term_offset > 0) || (file_offset > 0))
--- texlive-bin.orig/texk/web2c/luatexdir/tex/linebreak.w
+++ texlive-bin/texk/web2c/luatexdir/tex/linebreak.w
@@ -146,7 +146,7 @@
                 succumb();
             }
         } else {
-            if (int_par(tracing_paragraphs_code) > 0) {
+            if (tracing_paragraphs_par > 0) {
                 begin_diagnostic();
                 print_int(line);
                 end_diagnostic(true);
@@ -160,31 +160,31 @@
             confusion("weird par dir"); /* assert(0); */ /* |paragraph_dir = 0|; */
         }
         ext_do_line_break(paragraph_dir,
-                          int_par(pretolerance_code),
-                          int_par(tracing_paragraphs_code),
-                          int_par(tolerance_code),
-                          dimen_par(emergency_stretch_code),
-                          int_par(looseness_code),
-                          int_par(adjust_spacing_code),
-                          equiv(par_shape_loc),
-                          int_par(adj_demerits_code),
-                          int_par(protrude_chars_code),
-                          int_par(line_penalty_code),
-                          int_par(last_line_fit_code),
-                          int_par(double_hyphen_demerits_code),
-                          int_par(final_hyphen_demerits_code),
-                          dimen_par(hang_indent_code),
-                          dimen_par(hsize_code),
-                          int_par(hang_after_code),
-                          glue_par(left_skip_code),
-                          glue_par(right_skip_code),
-                          equiv(inter_line_penalties_loc),
-                          int_par(inter_line_penalty_code),
-                          int_par(club_penalty_code),
-                          equiv(club_penalties_loc),
-                          (d ? equiv(display_widow_penalties_loc) : equiv(widow_penalties_loc)),
-                          (d ? int_par(display_widow_penalty_code) : int_par(widow_penalty_code)),
-                          int_par(broken_penalty_code),
+                          pretolerance_par,
+                          tracing_paragraphs_par,
+                          tolerance_par,
+                          emergency_stretch_par,
+                          looseness_par,
+                          adjust_spacing_par,
+                          par_shape_par_ptr,
+                          adj_demerits_par,
+                          protrude_chars_par,
+                          line_penalty_par,
+                          last_line_fit_par,
+                          double_hyphen_demerits_par,
+                          final_hyphen_demerits_par,
+                          hang_indent_par,
+                          hsize_par,
+                          hang_after_par,
+                          left_skip_par,
+                          right_skip_par,
+                          inter_line_penalties_par_ptr,
+                          inter_line_penalty_par,
+                          club_penalty_par,
+                          club_penalties_par_ptr,
+                          (d ? display_widow_penalties_par_ptr : widow_penalties_par_ptr),
+                          (d ? display_widow_penalty_par : widow_penalty_par),
+                          broken_penalty_par,
                           final_par_glue);
     }
     lua_node_filter(post_linebreak_filter_callback,
@@ -898,7 +898,7 @@
         switch (type(s)) {
             case math_node:
                 /* begin mathskip code */
-                if (glue_is_zero(math_skip)) {
+                if (glue_is_zero(math_skip_par)) {
                     break_width[1] -= surround(s);
                     break;
                 } else {
@@ -1630,14 +1630,15 @@
             second_width = hsize;
             second_indent = 0;
         } else {
+            halfword used_hang_indent = swap_hang_indent(hang_indent);
             /*  Set line length parameters in preparation for hanging indentation */
             /* We compute the values of |easy_line| and the other local variables relating
                to line length when the |line_break| procedure is initializing itself. */
             last_special_line = abs(hang_after);
             if (hang_after < 0) {
-                first_width = hsize - abs(hang_indent);
-                if (hang_indent >= 0)
-                    first_indent = hang_indent;
+                first_width = hsize - abs(used_hang_indent);
+                if (used_hang_indent >= 0)
+                    first_indent = used_hang_indent;
                 else
                     first_indent = 0;
                 second_width = hsize;
@@ -1645,19 +1646,18 @@
             } else {
                 first_width = hsize;
                 first_indent = 0;
-                second_width = hsize - abs(hang_indent);
-                if (hang_indent >= 0)
-                    second_indent = hang_indent;
+                second_width = hsize - abs(used_hang_indent);
+                if (used_hang_indent >= 0)
+                    second_indent = used_hang_indent;
                 else
                     second_indent = 0;
             }
         }
     } else {
         last_special_line = vinfo(par_shape_ptr + 1) - 1;
-        second_indent =
-            varmem[(par_shape_ptr + 2 * (last_special_line + 1))].cint;
-        second_width =
-            varmem[(par_shape_ptr + 2 * (last_special_line + 1) + 1)].cint;
+        second_indent = varmem[(par_shape_ptr + 2 * (last_special_line + 1))].cint;
+        second_width = varmem[(par_shape_ptr + 2 * (last_special_line + 1) + 1)].cint;
+        second_indent = swap_parshape_indent(second_indent,second_width);
     }
     if (looseness == 0)
         easy_line = last_special_line;
@@ -1840,7 +1840,7 @@
                 case math_node:
                     auto_breaking = (subtype(cur_p) == after);
                     /* begin mathskip code */
-                    if (glue_is_zero(math_skip)) {
+                    if (glue_is_zero(math_skip_par)) {
                         kern_break();
                         break;
                     } else {
@@ -2132,7 +2132,7 @@
                         protrude_chars,
                         par_shape_ptr,
                         adjust_spacing,
-                        inter_line_penalties_ptr,
+                        inter_line_penalties_par_ptr,
                         inter_line_penalty,
                         club_penalty,
                         club_penalties_ptr,
--- texlive-bin.orig/texk/web2c/luatexdir/tex/mainbody.h
+++ texlive-bin/texk/web2c/luatexdir/tex/mainbody.h
@@ -214,8 +214,7 @@
 @^system dependencies@>
 */
 
-
-#  define fix_date_and_time() dateandtime(int_par(time_code),int_par(day_code),int_par(month_code),int_par(year_code))
+#  define fix_date_and_time() dateandtime(time_par,day_par,month_par,year_par)
 
 extern int get_luatexversion(void);
 extern str_number get_luatexrevision(void);
--- texlive-bin.orig/texk/web2c/luatexdir/tex/mainbody.w
+++ texlive-bin/texk/web2c/luatexdir/tex/mainbody.w
@@ -432,9 +432,9 @@
             incr(iloc);
     }
     if (output_mode_option != 0)
-        int_par(output_mode_code) = output_mode_value;
+        output_mode_par = output_mode_value;
     if (draft_mode_option != 0) {
-        int_par(draft_mode_code) = draft_mode_value;
+        draft_mode_par = draft_mode_value;
     }
     /* can this be moved? */
     pdf_init_map_file((char *) pdftex_map);
@@ -442,15 +442,14 @@
     if (end_line_char_inactive)
         decr(ilimit);
     else
-        buffer[ilimit] = (packed_ASCII_code) int_par(end_line_char_code);
+        buffer[ilimit] = (packed_ASCII_code) end_line_char_par;
     fix_date_and_time();
     random_seed = (microseconds * 1000) + (epochseconds % 1000000);
     init_randoms(random_seed);
     initialize_math();
     fixup_selector(log_opened_global);
     check_texconfig_init();
-    if ((iloc < ilimit) && (get_cat_code(int_par(cat_code_table_code),
-                                         buffer[iloc]) != escape_cmd))
+    if ((iloc < ilimit) && (get_cat_code(cat_code_table_par, buffer[iloc]) != escape_cmd))
         start_input();          /* \.{\\input} assumed */
     /* DIR: Initialize |text_dir_ptr| */
     text_dir_ptr = new_dir(0);
@@ -487,7 +486,7 @@
     int callback_id;
     callback_id = callback_defined(stop_run_callback);
     finalize_write_files();
-    if (int_par(tracing_stats_code) > 0) {
+    if (tracing_stats_par > 0) {
         if (callback_id == 0) {
             /* Output statistics about this job */
             /* The present section goes directly to the log file instead of using
--- texlive-bin.orig/texk/web2c/luatexdir/tex/maincontrol.h
+++ texlive-bin/texk/web2c/luatexdir/tex/maincontrol.h
@@ -71,9 +71,9 @@
 
 #  define define_cat_code(A,B) do {			\
      if (is_global(a))					\
-       set_cat_code(int_par(cat_code_table_code),(A),(B),level_one);	\
+       set_cat_code(cat_code_table_par,(A),(B),level_one);	\
      else						\
-       set_cat_code(int_par(cat_code_table_code),(A),(B),cur_level);	\
+       set_cat_code(cat_code_table_par,(A),(B),cur_level);	\
    } while (0)
 
 #  define define_fam_fnt(A,B,C) do {		\
@@ -174,6 +174,17 @@
     tprint(" entered on line "); print_int((A));	\
   }
 
+/*
+    extern halfword swap_hang_indent(halfword indentation, halfword shape_mode);
+    extern halfword swap_parshape_indent(halfword indentation, halfword width, halfword shape_mode);
+*/
+
+#define swap_hang_indent(indentation) \
+    ( ((shape_mode_par == 1 || shape_mode_par == 3 || shape_mode_par == -1 || shape_mode_par == -3)) ? negate(indentation) : indentation )
+
+#define swap_parshape_indent(indentation,width) \
+    ( ((shape_mode_par == 2 || shape_mode_par == 3 || shape_mode_par == -2 || shape_mode_par == -3)) ? (hsize_par - width - indentation) : indentation )
+
 extern void get_r_token(void);
 extern void assign_internal_value(int a, halfword p, int cur_val);
 extern void do_register_command(int a);
--- texlive-bin.orig/texk/web2c/luatexdir/tex/maincontrol.w
+++ texlive-bin/texk/web2c/luatexdir/tex/maincontrol.w
@@ -22,72 +22,11 @@
 #include "ptexlib.h"
 #include "lua/luatex-api.h"
 
-/* these will move to equivalents.h */
-
 @ @c
-#define lp_code_base 2
-#define rp_code_base 3
-#define ef_code_base 4
-#define tag_code 5
-#define no_lig_code 6
-#define gp_code_base 7
-
-#define prev_depth cur_list.prev_depth_field
-#define space_factor cur_list.space_factor_field
-#define par_shape_ptr  equiv(par_shape_loc)
-
-#define cur_lang int_par(cur_lang_code)
-#define global_defs int_par(global_defs_code)
-#define output_box int_par(output_box_code)
-#define end_line_char int_par(end_line_char_code)
-#define new_line_char int_par(new_line_char_code)
-#define tracing_online int_par(tracing_online_code)
-#define no_local_whatsits int_par(no_local_whatsits_code)
-#define no_local_dirs int_par(no_local_dirs_code)
-#define err_help equiv(err_help_loc)
-#define every_par equiv(every_par_loc)
-
-#define page_left_offset dimen_par(page_left_offset_code)
-#define page_top_offset dimen_par(page_top_offset_code)
-#define page_right_offset dimen_par(page_right_offset_code)
-#define page_bottom_offset dimen_par(page_bottom_offset_code)
-#define px_dimen dimen_par(px_dimen_code)
-
-#define math_eqno_gap_step int_par(math_eqno_gap_step_code)
-
-#define escape_char int_par(escape_char_code)
-#define max_dead_cycles int_par(max_dead_cycles_code)
-#define tolerance int_par(tolerance_code)
-#define mag int_par(mag_code)
-#define cat_code_table int_par(cat_code_table_code)
-
-#define par_indent dimen_par(par_indent_code)
-#define looseness int_par(looseness_code)
-#define space_skip glue_par(space_skip_code)
-#define xspace_skip glue_par(xspace_skip_code)
-#define math_skip glue_par(math_skip_code)
-#define every_vbox equiv(every_vbox_loc)
-
-#define split_top_skip glue_par(split_top_skip_code)
-#define split_max_depth dimen_par(split_max_depth_code)
-
-#define hang_indent dimen_par(hang_indent_code)
-#define hang_after int_par(hang_after_code)
-#define inter_line_penalties_ptr equiv(inter_line_penalties_loc)
-
-#define box(A) eqtb[box_base+(A)].hh.rh
-#define cur_font equiv(cur_font_loc)
-#define hsize dimen_par(hsize_code)
-#define ex_hyphen_char int_par(ex_hyphen_char_code)
-#define floating_penalty int_par(floating_penalty_code)
-
-#define mode          cur_list.mode_field
-#define tail          cur_list.tail_field
-#define head          cur_list.head_field
-#define prev_graf     cur_list.pg_field
-#define dir_save      cur_list.dirs_field
-
-#define var_code 7              /* math code meaning ``use the current family'' */
+#define mode     mode_par
+#define tail     tail_par
+#define head     head_par
+#define dir_save dirs_par
 
 @ We come now to the |main_control| routine, which contains the master
 switch that causes all the various pieces of \TeX\ to do their things,
@@ -140,14 +79,14 @@
 {
     halfword s = get_sf_code(cur_chr);
     if (s == 1000) {
-        space_factor = 1000;
+        space_factor_par = 1000;
     } else if (s < 1000) {
         if (s > 0)
-            space_factor = s;
-    } else if (space_factor < 1000) {
-        space_factor = 1000;
+            space_factor_par = s;
+    } else if (space_factor_par < 1000) {
+        space_factor_par = 1000;
     } else {
-        space_factor = s;
+        space_factor_par = s;
     }
 }
 
@@ -179,12 +118,12 @@
     scan_char_num();
     cur_chr = cur_val;
     adjust_space_factor();
-    tail_append(new_char(cur_font, cur_chr));
+    tail_append(new_char(cur_font_par, cur_chr));
 }
 
 static void run_char (void) {
     adjust_space_factor();
-    tail_append(new_char(cur_font, cur_chr));
+    tail_append(new_char(cur_font_par, cur_chr));
 }
 
 @
@@ -201,23 +140,23 @@
 @c
 static void run_app_space (void) {
     halfword p; /* was a global temp_ptr */
-    int method = int_par(disable_space_code) ;
+    int method = disable_space_par ;
     if (method == 1) {
         /* don't inject anything, not even zero skip */
     } else if (method == 2) {
         p = new_glue(zero_glue);
         couple_nodes(tail,p);
         tail = p;
-    } else if ((abs(mode) + cur_cmd == hmode + spacer_cmd) && (!(space_factor == 1000))) {
+    } else if ((abs(mode) + cur_cmd == hmode + spacer_cmd) && (!(space_factor_par == 1000))) {
         app_space();
     } else {
         /* Append a normal inter-word space to the current list */
-        if (glue_is_zero(space_skip)) {
+        if (glue_is_zero(space_skip_par)) {
             /* Find the glue specification for text spaces in the current font */
             p = new_glue(zero_glue);
-            width(p) = space(cur_font);
-            stretch(p) = space_stretch(cur_font);
-            shrink(p) = space_shrink(cur_font);
+            width(p) = space(cur_font_par);
+            stretch(p) = space_stretch(cur_font_par);
+            shrink(p) = space_shrink(cur_font_par);
 
         } else {
             p = new_param_glue(space_skip_code);
@@ -351,9 +290,9 @@
 static void run_rule (void) {
     tail_append(scan_rule_spec());
     if (abs(mode) == vmode)
-        prev_depth = ignore_depth;
+        prev_depth_par = ignore_depth;
     else if (abs(mode) == hmode)
-        space_factor = 1000;
+        space_factor_par = 1000;
 }
 
 @
@@ -567,9 +506,9 @@
     normal_paragraph();
     push_nest();
     mode = -vmode;
-    prev_depth = ignore_depth;
-    if (every_vbox != null)
-        begin_token_list(every_vbox, every_vbox_text);
+    prev_depth_par = ignore_depth;
+    if (every_vbox_par != null)
+        begin_token_list(every_vbox_par, every_vbox_text);
 }
 
 @ @c
@@ -629,12 +568,12 @@
                 help1("All \\catcode table ids must be between 0 and 0x7FFF");
                 error();
             } else {
-                if (cur_val == cat_code_table) {
+                if (cur_val == cat_code_table_par) {
                     print_err("Invalid \\catcode table");
                     help1("You cannot overwrite the current \\catcode table");
                     error();
                 } else {
-                    copy_cat_codes(cat_code_table, cur_val);
+                    copy_cat_codes(cat_code_table_par, cur_val);
                 }
             }
             break;
@@ -645,7 +584,7 @@
                 help1("All \\catcode table ids must be between 0 and 0x7FFF");
                 error();
             } else {
-                if (cur_val == cat_code_table) {
+                if (cur_val == cat_code_table_par) {
                     print_err("Invalid \\catcode table");
                     help1("You cannot overwrite the current \\catcode table");
                     error();
@@ -965,7 +904,7 @@
             check_interrupt();
             continue;
         }
-        if (int_par(tracing_commands_code) > 0)
+        if (tracing_commands_par > 0)
             show_cur_cmd_chr();
 
         (jump_table[(abs(mode) + cur_cmd)])(); /* run the command */
@@ -981,24 +920,24 @@
 void app_space(void)
 {                               /* handle spaces when |space_factor<>1000| */
     halfword q;                 /* glue node */
-    if ((space_factor >= 2000) && (! glue_is_zero(xspace_skip))) {
+    if ((space_factor_par >= 2000) && (! glue_is_zero(xspace_skip_par))) {
         q = new_param_glue(xspace_skip_code);
         /* so from now we have a subtype with spaces: */
         subtype(q) = xspace_skip_code + 1;
     } else {
-        if (!glue_is_zero(space_skip)) {
-            q = new_glue(space_skip);
+        if (!glue_is_zero(space_skip_par)) {
+            q = new_glue(space_skip_par);
         } else {
             q = new_glue(zero_glue);
-            width(q) = space(cur_font);
-            stretch(q) = space_stretch(cur_font);
-            shrink(q) = space_shrink(cur_font);
+            width(q) = space(cur_font_par);
+            stretch(q) = space_stretch(cur_font_par);
+            shrink(q) = space_shrink(cur_font_par);
         }
         /* Modify the glue specification in |q| according to the space factor */
-        if (space_factor >= 2000)
-            width(q) = width(q) + extra_space(cur_font);
-        stretch(q) = xn_over_d(stretch(q), space_factor, 1000);
-        shrink(q) = xn_over_d(shrink(q), 1000, space_factor);
+        if (space_factor_par >= 2000)
+            width(q) = width(q) + extra_space(cur_font_par);
+        stretch(q) = xn_over_d(stretch(q), space_factor_par, 1000);
+        shrink(q) = xn_over_d(shrink(q), 1000, space_factor_par);
 
         /* so from now we have a subtype with spaces: */
         subtype(q) = space_skip_code + 1;
@@ -1023,7 +962,7 @@
 @c
 void insert_dollar_sign_par_end(void)
 {
-    if (!int_par(suppress_mathpar_error_code)) {
+    if (!suppress_mathpar_error_par) {
         insert_dollar_sign() ;
     }
 }
@@ -1094,7 +1033,7 @@
         }
         back_input();           /* we will try to end again after ejecting residual material */
         tail_append(new_null_box());
-        width(tail) = hsize;
+        width(tail) = hsize_par;
         tail_append(new_glue(fill_glue));
         tail_append(new_penalty(-010000000000));
         normal_page_filter(end);
@@ -1265,9 +1204,9 @@
             break;
         case insert_group:
             end_graf(insert_group);
-            q = new_glue(split_top_skip);
-            d = split_max_depth;
-            f = floating_penalty;
+            q = new_glue(split_top_skip_par);
+            d = split_max_depth_par;
+            f = floating_penalty_par;
             unsave();
             save_ptr--;
             /* now |saved_value(0)| is the insertion number, or the |vadjust| subtype */
@@ -1368,16 +1307,18 @@
 @c
 void normal_paragraph(void)
 {
-    if (looseness != 0)
+    if (looseness_par != 0)
         eq_word_define(int_base + looseness_code, 0);
-    if (hang_indent != 0)
+    if (hang_indent_par != 0)
         eq_word_define(dimen_base + hang_indent_code, 0);
-    if (hang_after != 1)
+    if (hang_after_par != 1)
         eq_word_define(int_base + hang_after_code, 1);
-    if (par_shape_ptr != null)
+    if (par_shape_par_ptr != null)
         eq_define(par_shape_loc, shape_ref_cmd, null);
-    if (inter_line_penalties_ptr != null)
+    if (inter_line_penalties_par_ptr != null)
         eq_define(inter_line_penalties_loc, shape_ref_cmd, null);
+    if (shape_mode_par > 0)
+        eq_word_define(dimen_base + shape_mode_code, 0);
 }
 
 @ The global variable |cur_box| will point to a newly-made box. If the box
@@ -1421,7 +1362,7 @@
                 }
             } else {
                 if (abs(mode) == hmode)
-                    space_factor = 1000;
+                    space_factor_par = 1000;
                 else
                     cur_box = new_sub_box(cur_box);
                 couple_nodes(tail, cur_box);
@@ -1491,19 +1432,19 @@
 {
     halfword p, q, dir_graf_tmp;
     halfword dir_rover;
-    prev_graf = 0;
+    prev_graf_par = 0;
     if ((mode == vmode) || (head != tail)) {
         tail_append(new_param_glue(par_skip_code));
     }
     push_nest();
     mode = hmode;
-    space_factor = 1000;
+    space_factor_par = 1000;
     /* LOCAL: Add local paragraph node */
     tail_append(make_local_par_node(new_graf_par_code));
     if (indented) {
         p = new_null_box();
-        box_dir(p) = par_direction;
-        width(p) = par_indent;
+        box_dir(p) = par_direction_par;
+        width(p) = par_indent_par;
         subtype(p) = indent_list;
         q = tail;
         tail_append(p);
@@ -1512,7 +1453,7 @@
     }
     dir_rover = text_dir_ptr;
     while (dir_rover != null) {
-        if ((vlink(dir_rover) != null) || (dir_dir(dir_rover) != par_direction)) {
+        if ((vlink(dir_rover) != null) || (dir_dir(dir_rover) != par_direction_par)) {
             dir_graf_tmp = new_dir(dir_dir(dir_rover));
             try_couple_nodes(dir_graf_tmp,vlink(q));
             couple_nodes(q,dir_graf_tmp);
@@ -1523,8 +1464,8 @@
     while (vlink(q) != null)
         q = vlink(q);
     tail = q;
-    if (every_par != null)
-        begin_token_list(every_par, every_par_text);
+    if (every_par_par != null)
+        begin_token_list(every_par_par, every_par_text);
     if (nest_ptr == 1) {
         checked_page_filter(new_graf);
         build_page();           /* put |par_skip| glue on current page */
@@ -1537,9 +1478,9 @@
     halfword p;
     if (cur_chr > 0) {          /* \.{\\indent} */
         p = new_null_box();
-        width(p) = par_indent;
+        width(p) = par_indent_par;
         if (abs(mode) == hmode)
-            space_factor = 1000;
+            space_factor_par = 1000;
         else
             p = new_sub_box(p);
         tail_append(p);
@@ -1596,9 +1537,9 @@
 {
     if (cur_cmd != vadjust_cmd) {
         scan_register_num();
-        if (cur_val == output_box) {
+        if (cur_val == output_box_par) {
             print_err("You can't \\insert");
-            print_int(output_box);
+            print_int(output_box_par);
             help1("I'm changing to \\insert0; box \\outputbox is special.");
             error();
             cur_val = 0;
@@ -1615,7 +1556,7 @@
     normal_paragraph();
     push_nest();
     mode = -vmode;
-    prev_depth = ignore_depth;
+    prev_depth_par = ignore_depth;
 }
 
 @ I (TH)'ve renamed the |make_mark| procedure to this, because if the
@@ -1800,7 +1741,7 @@
     scan_left_brace();
     push_nest();
     mode = -hmode;
-    space_factor = 1000;
+    space_factor_par = 1000;
 }
 
 @ Discretionary nodes are easy in the common case `\.{\\-}', but in the
@@ -1817,19 +1758,19 @@
     subtype(tail) = (quarterword) cur_chr;
     if (cur_chr == explicit_disc) {
         /* \- */
-        c = get_pre_hyphen_char(cur_lang);
+        c = get_pre_hyphen_char(cur_lang_par);
         if (c != 0) {
             vlink(pre_break(tail)) = new_char(equiv(cur_font_loc), c);
             alink(vlink(pre_break(tail))) = pre_break(tail);
             tlink(pre_break(tail)) = vlink(pre_break(tail));
         }
-        c = get_post_hyphen_char(cur_lang);
+        c = get_post_hyphen_char(cur_lang_par);
         if (c != 0) {
             vlink(post_break(tail)) = new_char(equiv(cur_font_loc), c);
             alink(vlink(post_break(tail))) = post_break(tail);
             tlink(post_break(tail)) = vlink(post_break(tail));
         }
-        disc_penalty(tail) = int_par(ex_hyphen_penalty_code);
+        disc_penalty(tail) = ex_hyphen_penalty_par;
     } else {
         /* \discretionary */
         if (scan_keyword("penalty")) {
@@ -1842,8 +1783,8 @@
         scan_left_brace();
         push_nest();
         mode = -hmode;
-        space_factor = 1000;
-        /* already preset: disc_penalty(tail) = int_par(hyphen_penalty_code); */
+        space_factor_par = 1000;
+        /* already preset: disc_penalty(tail) = hyphen_penalty_par; */
     }
 }
 
@@ -1871,7 +1812,7 @@
         /* LOCAL: Add local paragraph node */
         tail_append(make_local_par_node(local_box_par_code));
     }
-    eq_word_define(int_base + no_local_whatsits_code, no_local_whatsits + 1);
+    eq_word_define(int_base + no_local_whatsits_code, no_local_whatsits_par + 1);
 }
 
 @ The three discretionary lists are constructed somewhat as if they were
@@ -1954,7 +1895,7 @@
     scan_left_brace();
     push_nest();
     mode = -hmode;
-    space_factor = 1000;
+    space_factor_par = 1000;
 }
 
 @ The positioning of accents is straightforward but tedious. Given an accent
@@ -2023,7 +1964,7 @@
         }
         couple_nodes(tail, p);
         tail = p;
-        space_factor = 1000;
+        space_factor_par = 1000;
     }
 }
 
@@ -2177,6 +2118,25 @@
 } while (0)
 
 @ @c
+/*
+halfword swap_hang_indent(halfword indentation, halfword shape_mode) {
+    if (shape_mode == 1 || shape_mode == 3 || shape_mode == -1 || shape_mode == -3) {
+        return negate(indentation);
+    } else {
+        return indentation;
+    }
+}
+
+halfword swap_parshape_indent(halfword indentation, halfword width, halfword shape_mode) {
+    if (shape_mode == 2 || shape_mode == 3 || shape_mode == -2 || shape_mode == -3) {
+        return hsize_par - width - indentation;
+    } else {
+        return indentation;
+    }
+}
+
+*/
+
 void prefixed_command(void)
 {
     int a;                      /* accumulated prefix codes so far */
@@ -2184,7 +2144,7 @@
     halfword j;                 /* index into a \.{\\parshape} specification */
     halfword p, q;              /* for temporary short-term use */
     int n;                      /* ditto */
-    boolean e;                  /* should a definition be expanded? or was \.{\\let} not done? */
+    boolean e, check_glue;      /* should a definition be expanded? or was \.{\\let} not done? */
     mathcodeval mval;           /* for handling of \.{\\mathchardef}s */
     a = 0;
     while (cur_cmd == prefix_cmd) {
@@ -2206,7 +2166,7 @@
             back_error();
             return;
         }
-        if (int_par(tracing_commands_code) > 2)
+        if (tracing_commands_par > 2)
             show_cur_cmd_chr();
     }
     /* Discard the prefixes \.{\\long} and \.{\\outer} if they are irrelevant */
@@ -2224,8 +2184,8 @@
         error();
     }
     /* Adjust for the setting of \.{\\globaldefs} */
-    if (global_defs != 0) {
-        if (global_defs < 0) {
+    if (global_defs_par != 0) {
+        if (global_defs_par < 0) {
             if (is_global(a))
                 a = a - 4;
         } else {
@@ -2244,7 +2204,7 @@
                |cur_chr| is odd if the definition is supposed to be global, and
                |cur_chr>=2| if the definition is supposed to be expanded. */
 
-            if (odd(cur_chr) && !is_global(a) && (global_defs >= 0))
+            if (odd(cur_chr) && !is_global(a) && (global_defs_par >= 0))
                 a = a + 4;
             e = (cur_chr >= 2);
             get_r_token();
@@ -2325,7 +2285,7 @@
                 break;
             case math_char_def_code:
                 mval = scan_mathchar(tex_mathcode);
-                if (mathoption_int_par(c_mathoption_umathcode_meaning_code) == 1) {
+                if (math_umathcode_meaning_par == 1) {
                     cur_val = (mval.class_value + (8 * mval.family_value)) * (65536 * 32) + mval.character_value;
                     define(p, xmath_given_cmd, cur_val);
                 } else {
@@ -2464,42 +2424,78 @@
             /* DIR: Assign direction codes */
             scan_direction();
             switch (cur_chr) {
-            case int_base + page_direction_code:
-                eq_word_define(int_base + page_direction_code, cur_val);
-                break;
-            case int_base + body_direction_code:
-                eq_word_define(int_base + body_direction_code, cur_val);
-                break;
-            case int_base + par_direction_code:
-                eq_word_define(int_base + par_direction_code, cur_val);
-                break;
-            case int_base + math_direction_code:
-                eq_word_define(int_base + math_direction_code, cur_val);
-                break;
-            case int_base + text_direction_code:
-#if 0
-    /* various tests hint that this is unnecessary and
-     * sometimes even produces weird results, eg
-     *  (\hbox{\textdir TRT ABC\textdir TLT DEF})
-     * becomes
-     *  (DEFCBA)
-     * in the output
-     */
-                if ((no_local_dirs > 0) && (abs(mode) == hmode)) {
-                    /* DIR: Add local dir node */
-                    tail_append(new_dir(text_direction));
-                }
-#endif
-                update_text_dir_ptr(cur_val);
-                if (abs(mode) == hmode) {
-                    /* DIR: Add local dir node */
-                    tail_append(new_dir(cur_val));
-                    dir_level(tail) = cur_level;
+                case int_base + page_direction_code:
+                    eq_word_define(int_base + page_direction_code, cur_val);
+                    break;
+                case int_base + body_direction_code:
+                    eq_word_define(int_base + body_direction_code, cur_val);
+                    break;
+                case int_base + par_direction_code:
+                    eq_word_define(int_base + par_direction_code, cur_val);
+                    break;
+                case int_base + math_direction_code:
+                    eq_word_define(int_base + math_direction_code, cur_val);
+                    break;
+                case int_base + text_direction_code:
+                case int_base + line_direction_code:
+                    /*
+                        pre version 0.97 this was a commented section because various tests hint that this
+                        is unnecessary and sometimes even produces weird results, like:
+
+                            (\hbox{\textdir TRT ABC\textdir TLT DEF}))
+
+                        becomes
+
+                            (DEFCBA)
+
+                        in the output when we use
+
+                            tail_append(new_dir(text_direction_par)
+
+                        but when we append the reverse of the current it goes better
+
+                    */
+                    check_glue = (cur_chr == (int_base + line_direction_code));
+                    if (check_glue) {
+                        cur_chr = int_base + text_direction_code ;
+                    }
+                    if (abs(mode) == hmode) {
+                        if (no_local_dirs_par > 0) {
+                            /* tail is non zero but we test anyway */
+                            if (check_glue && (tail != null && type(tail) == glue_node))  {
+                                halfword prev = alink(tail);
+                                halfword dirn = new_dir(text_direction_par - dir_swap);
+                                couple_nodes(prev,dirn);
+                                couple_nodes(dirn,tail);
+                            } else {
+                                tail_append(new_dir(text_direction_par - dir_swap));
+                            }
+                        } else {
+                            /* what is the use of nolocaldirs .. maybe we should get rid of it */
+                        }
+                        update_text_dir_ptr(cur_val);
+                        tail_append(new_dir(cur_val));
+                        dir_level(tail) = cur_level;
+                    } else {
+                        update_text_dir_ptr(cur_val);
+                    }
+                    /*  original:
+
+                        // if ((no_local_dirs_par > 0) && (abs(mode) == hmode)) {
+                        //  // tail_append(new_dir(text_direction_par)              // kind of wrong
+                        //     tail_append(new_dir(text_direction_par - dir_swap)); // better
+                        // }
+
+                        update_text_dir_ptr(cur_val);
+                        if (abs(mode) == hmode) {
+                            tail_append(new_dir(cur_val));
+                            dir_level(tail) = cur_level;
+                        }
+                    */
+                    eq_word_define(int_base + text_direction_code, cur_val);
+                    eq_word_define(int_base + no_local_dirs_code, no_local_dirs_par + 1);
+                    break;
                 }
-                eq_word_define(int_base + text_direction_code, cur_val);
-                eq_word_define(int_base + no_local_dirs_code, no_local_dirs + 1);
-                break;
-            }
             break;
         case assign_dimen_cmd:
             p = cur_chr;
@@ -2614,11 +2610,11 @@
                     scan_dimen(false, false, false);
             } else {
                 scan_glue(mu_val_level);
-                if (cur_val == glue_par(thin_mu_skip_code))
+                if (cur_val == thin_mu_skip_par)
                     cur_val = thin_mu_skip_code;
-                else if (cur_val == glue_par(med_mu_skip_code))
+                else if (cur_val == med_mu_skip_par)
                     cur_val = med_mu_skip_code;
-                else if (cur_val == glue_par(thick_mu_skip_code))
+                else if (cur_val == thick_mu_skip_par)
                     cur_val = thick_mu_skip_code;
             }
             define_math_param(p, cur_val1, cur_val);
@@ -2812,9 +2808,9 @@
 @ @c
 void fixup_directions(void)
 {
-    int temp_no_whatsits = no_local_whatsits;
-    int temp_no_dirs = no_local_dirs;
-    int temporary_dir = text_direction;
+    int temp_no_whatsits = no_local_whatsits_par;
+    int temp_no_dirs = no_local_dirs_par;
+    int temporary_dir = text_direction_par;
     if (dir_level(text_dir_ptr) == cur_level) {
         /* DIR: Remove from |text_dir_ptr| */
         halfword text_dir_tmp = vlink(text_dir_ptr);
@@ -2825,7 +2821,7 @@
     if (abs(mode) == hmode) {
         if (temp_no_dirs != 0) {
             /* DIR: Add local dir node */
-            tail_append(new_dir(text_direction));
+            tail_append(new_dir(text_direction_par));
             dir_dir(tail) = temporary_dir - dir_swap;
         }
         if (temp_no_whatsits != 0) {
@@ -2870,7 +2866,7 @@
         switch ((p - int_base)) {
         case cat_code_table_code:
             if (valid_catcode_table(val)) {
-                if (val != int_par(cat_code_table_code))
+                if (val != cat_code_table_par)
                     word_define(p, val);
             } else {
                 print_err("Invalid \\catcode table");
@@ -2941,9 +2937,7 @@
              (p == (int_base + local_broken_penalty_code)))) {
             /* LOCAL: Add local paragraph node */
             tail_append(make_local_par_node(penalty_par_code));
-
-            eq_word_define(int_base + no_local_whatsits_code,
-                           no_local_whatsits + 1);
+            eq_word_define(int_base + no_local_whatsits_code, no_local_whatsits_par + 1);
         }
     } else if ((p >= dimen_base) && (p <= eqtb_size)) {
         if (p == (dimen_base + page_left_offset_code)) {
@@ -3117,7 +3111,7 @@
         scan_optional_equals();
         if (c == vmode) {
             scan_normal_dimen();
-            prev_depth = cur_val;
+            prev_depth_par = cur_val;
         } else {
             scan_int();
             if ((cur_val <= 0) || (cur_val > 32767)) {
@@ -3125,7 +3119,7 @@
                 help1("I allow only values in the range 1..32767 here.");
                 int_error(cur_val);
             } else {
-                space_factor = cur_val;
+                space_factor_par = cur_val;
             }
         }
     }
@@ -3301,7 +3295,7 @@
            give a verbose explanation only once. */
         print_err("");
         print(s);
-        if (err_help != null) {
+        if (err_help_par != null) {
             use_err_help = true;
         } else if (long_help_seen) {
             help1("(That was another \\errmessage.)");
@@ -3326,7 +3320,7 @@
 @c
 void give_err_help(void)
 {
-    token_show(err_help);
+    token_show(err_help_par);
 }
 
 @ The \.{\\uppercase} and \.{\\lowercase} commands are implemented by
@@ -3469,7 +3463,7 @@
     end_diagnostic(true);
     print_err("OK");
     if (selector == term_and_log) {
-        if (tracing_online <= 0) {
+        if (tracing_online_par <= 0) {
             selector = term_only;
             tprint(" (see the transcript file)");
             selector = term_and_log;
@@ -3479,7 +3473,7 @@
     if (interaction < error_stop_mode) {
         help0();
         decr(error_count);
-    } else if (tracing_online > 0) {
+    } else if (tracing_online_par > 0) {
         help3("This isn't an error message; I'm just \\showing something.",
               "Type `I\\show...' to show more (e.g., \\show\\cs,",
               "\\showthe\\count10, \\showbox255, \\showlists).");
@@ -3533,7 +3527,7 @@
     initialize_directions();
     initialize_write_files();
     seconds_and_micros(epochseconds, microseconds);
-    init_start_time(static_pdf);
+    initialize_start_time(static_pdf);
 
     edit_name_start = 0;
     stop_at_space = true;
@@ -3560,7 +3554,7 @@
         for (k = glue_base + 1; k <= local_base - 1; k++) {
             eqtb[k] = eqtb[glue_base];
         }
-        par_shape_ptr = null;
+        par_shape_par_ptr = null;
         set_eq_type(par_shape_loc, shape_ref_cmd);
         set_eq_level(par_shape_loc, level_one);
         for (k = etex_pen_base; k <= (etex_pens - 1); k++)
@@ -3572,7 +3566,7 @@
         set_eq_level(box_base, level_one);
         for (k = box_base + 1; k <= (box_base + biggest_reg); k++)
             eqtb[k] = eqtb[box_base];
-        cur_font = null_font;
+        cur_font_par = null_font;
         set_eq_type(cur_font_loc, data_cmd);
         set_eq_level(cur_font_loc, level_one);
         set_equiv(cat_code_base, 0);
@@ -3583,15 +3577,15 @@
         eqtb[uc_code_base] = eqtb[cat_code_base];
         eqtb[sf_code_base] = eqtb[cat_code_base];
         eqtb[math_code_base] = eqtb[cat_code_base];
-        cat_code_table = 0;
+        cat_code_table_par = 0;
         initialize_math_codes();
         initialize_text_codes();
         initex_cat_codes(0);
         for (k = '0'; k <= '9'; k++)
-            set_math_code(k, var_code, 0, k, level_one);
+            set_math_code(k, math_use_current_family_code, 0, k, level_one);
         for (k = 'A'; k <= 'Z'; k++) {
-            set_math_code(k, var_code, 1, k, level_one);
-            set_math_code((k + 32), var_code, 1, (k + 32), level_one);
+            set_math_code(k, math_use_current_family_code, 1, k, level_one);
+            set_math_code((k + 32), math_use_current_family_code, 1, (k + 32), level_one);
             set_lc_code(k, k + 32, level_one);
             set_lc_code(k + 32, k + 32, level_one);
             set_uc_code(k, k, level_one);
@@ -3602,21 +3596,21 @@
             eqtb[k].cint = 0;
         for (k = attribute_base; k <= del_code_base - 1; k++)
             eqtb[k].cint = UNUSED_ATTRIBUTE;
-        mag = 1000;
-        tolerance = 10000;
-        hang_after = 1;
-        max_dead_cycles = 25;
-        escape_char = '\\';
-        end_line_char = carriage_return;
+        mag_par = 1000;
+        tolerance_par = 10000;
+        hang_after_par = 1;
+        max_dead_cycles_par = 25;
+        escape_char_par = '\\';
+        end_line_char_par = carriage_return;
         set_del_code('.', 0, 0, 0, 0, level_one); /* this null delimiter is used in error recovery */
-        ex_hyphen_char = '-';
-        output_box = 255;
+        ex_hyphen_char_par = '-';
+        output_box_par = 255;
         for (k = dimen_base; k <= eqtb_size; k++)
             eqtb[k].cint = 0;
-        page_left_offset = one_inch;
-        page_top_offset = one_inch;
-        page_right_offset = one_inch;
-        page_bottom_offset = one_inch;
+        page_left_offset_par = one_inch;
+        page_top_offset_par = one_inch;
+        page_right_offset_par = one_inch;
+        page_bottom_offset_par = one_inch;
         ini_init_primitives();
         hash_used = frozen_control_sequence;    /* nothing is used */
         hash_high = 0;
@@ -3629,8 +3623,8 @@
         cs_text(frozen_primitive) = maketexstring("primitive");
         create_null_font();
         font_bytes = 0;
-        px_dimen = one_bp;
-        math_eqno_gap_step = 1000 ;
+        px_dimen_par = one_bp;
+        math_eqno_gap_step_par = 1000 ;
         cs_text(frozen_protection) = maketexstring("inaccessible");
         format_ident = maketexstring(" (INITEX)");
         cs_text(end_write) = maketexstring("endwrite");
--- texlive-bin.orig/texk/web2c/luatexdir/tex/mathcodes.w
+++ texlive-bin/texk/web2c/luatexdir/tex/mathcodes.w
@@ -124,7 +124,7 @@
         st = mathcode_head->stack[mathcode_head->stack_ptr];
         if (st.level > 0) {
             rawset_sa_item(mathcode_head, st.code, st.value);
-            if (int_par(tracing_restores_code) > 1) {
+            if (tracing_restores_par > 1) {
                 begin_diagnostic();
                 print_char('{');
                 tprint("restoring");
@@ -150,7 +150,7 @@
         v.math_code_value.character_value = mathcharacter;
     }
     set_sa_item(mathcode_head, n, v, level);
-    if (int_par(tracing_assigns_code) > 1) {
+    if (tracing_assigns_par > 1) {
         begin_diagnostic();
         print_char('{');
         tprint("assigning");
@@ -242,7 +242,7 @@
         st = delcode_head->stack[delcode_head->stack_ptr];
         if (st.level > 0) {
             rawset_sa_item(delcode_head, st.code, st.value);
-            if (int_par(tracing_restores_code) > 1) {
+            if (tracing_restores_par > 1) {
                 begin_diagnostic();
                 print_char('{');
                 tprint("restoring");
@@ -252,7 +252,7 @@
                 end_diagnostic(false);
             }
         }
-        (mathcode_head->stack_ptr)--;
+        (delcode_head->stack_ptr)--;
     }
 }
 
@@ -267,7 +267,7 @@
     v.del_code_value.large_family_value = lmathfamily;
     v.del_code_value.large_character_value = lmathcharacter;
     set_sa_item(delcode_head, n, v, gl); /* always global */
-    if (int_par(tracing_assigns_code) > 1) {
+    if (tracing_assigns_par > 1) {
         begin_diagnostic();
         print_char('{');
         tprint("assigning");
--- texlive-bin.orig/texk/web2c/luatexdir/tex/mlist.w
+++ texlive-bin/texk/web2c/luatexdir/tex/mlist.w
@@ -51,13 +51,9 @@
 already apply that shift.
 
 @ @c
-#define math_old                      mathoption_int_par(c_mathoption_old_code)
-#define math_no_italic_compensation   mathoption_int_par(c_mathoption_no_italic_compensation_code)
-#define math_no_char_italic           mathoption_int_par(c_mathoption_no_char_italic_code)
-#define math_use_old_fraction_scaling mathoption_int_par(c_mathoption_use_old_fraction_scaling_code)
-
-#define is_new_mathfont(A)   ((font_math_params(A) >0) && (math_old == 0))
+#define is_new_mathfont(A)   ((font_math_params(A) >0) && (math_old_par == 0))
 #define is_old_mathfont(A,B) ((font_math_params(A)==0) && (font_params(A)>=(B)))
+#define do_new_math(A)       ((font_math_params(A) >0) && (font_oldmath(A) == 0) && (math_old_par == 0))
 
 @
 \def\LuaTeX{Lua\TeX}
@@ -68,17 +64,6 @@
 #include "lua/luatex-api.h"
 
 @ @c
-#define delimiter_factor     int_par(delimiter_factor_code)
-#define delimiter_shortfall  dimen_par(delimiter_shortfall_code)
-#define bin_op_penalty       int_par(bin_op_penalty_code)
-#define rel_penalty          int_par(rel_penalty_code)
-#define null_delimiter_space dimen_par(null_delimiter_space_code)
-#define script_space         dimen_par(script_space_code)
-#define disable_lig          int_par(disable_lig_code)
-#define disable_kern         int_par(disable_kern_code)
-#define disable_space        int_par(disable_space_code)
-#define scripts_mode         int_par(math_scripts_mode_code)
-
 #define nDEBUG
 
 #define reset_attributes(p,newatt) do {                \
@@ -110,7 +95,7 @@
     }                                                        \
   } while (0)
 
-#define font_MATH_par(a,b)                                                  \
+#define font_MATH_par(a,b) \
   (font_math_params(a)>=b ? font_math_param(a,b) : undefined_math_parameter)
 
 @ here are the math parameters that are font-dependant
@@ -213,7 +198,7 @@
 static scaled accent_base_height(int f)
 {
     scaled a;
-    if (is_new_mathfont(f)) {
+    if (do_new_math(f)) {
         a = font_MATH_par(f, AccentBaseHeight);
         if (a == undefined_math_parameter)
             a = x_height(f);
@@ -286,7 +271,7 @@
 the backward compatibility code, and it means that we can't raise an error here.
 
 @c
-static scaled radical_rule(int var)
+static scaled radical_rule_par(int var)
 {
     scaled a = get_math_param(math_param_radical_rule, var);
     return a;
@@ -296,6 +281,7 @@
 
 @c
 #define get_math_param_or_error(a,b) do_get_math_param_or_error(a, math_param_##b, #b)
+#define get_math_param_or_zero(a,b) do_get_math_param_or_zero(a, math_param_##b, #b)
 
 static scaled do_get_math_param_or_error(int var, int param, const char *name)
 {
@@ -307,6 +293,15 @@
     return a;
 }
 
+static scaled do_get_math_param_or_zero(int var, int param, const char *name)
+{
+    scaled a = get_math_param(param, var);
+    if (a == undefined_math_parameter) {
+        a = 0;
+    }
+    return a;
+}
+
 @ A variant on a suggestion on the list based on analysis by UV.
 
 @c
@@ -322,8 +317,8 @@
         /* |delta1| is max distance from axis */
         delta1 = delta2;
     }
-    delta = (delta1 / 500) * delimiter_factor;
-    delta2 = delta1 + delta1 - delimiter_shortfall;
+    delta = (delta1 / 500) * delimiter_factor_par;
+    delta2 = delta1 + delta1 - delimiter_shortfall_par;
     if (delta < delta2) {
         return delta2;
     } else {
@@ -381,6 +376,9 @@
 #define limit_below_bgap(a)      get_math_param_or_error(a, limit_below_bgap)
 #define limit_below_kern(a)      get_math_param_or_error(a, limit_below_kern)
 
+#define nolimit_sub_factor(a)    get_math_param_or_zero(a, nolimit_sub_factor)
+#define nolimit_sup_factor(a)    get_math_param_or_zero(a, nolimit_sup_factor)
+
 #define sub_shift_drop(a)        get_math_param_or_error(a, sub_shift_drop)
 #define sup_shift_drop(a)        get_math_param_or_error(a, sup_shift_drop)
 #define sub_shift_down(a)        get_math_param_or_error(a, sub_shift_down)
@@ -579,6 +577,14 @@
             0, lvl);
         DEFINE_DMATH_PARAMETERS(math_param_limit_below_kern, size_id,
             0, lvl);
+        DEFINE_MATH_PARAMETERS(math_param_nolimit_sub_factor, size_id,
+            font_MATH_par(f, NoLimitSubFactor), lvl); /* bonus */
+        DEFINE_DMATH_PARAMETERS(math_param_nolimit_sub_factor, size_id,
+            font_MATH_par(f, NoLimitSubFactor), lvl); /* bonus */
+        DEFINE_MATH_PARAMETERS(math_param_nolimit_sup_factor, size_id,
+            font_MATH_par(f, NoLimitSupFactor), lvl); /* bonus */
+        DEFINE_DMATH_PARAMETERS(math_param_nolimit_sup_factor, size_id,
+            font_MATH_par(f, NoLimitSupFactor), lvl); /* bonus */
 
         DEFINE_MATH_PARAMETERS(math_param_fraction_rule, size_id,
             font_MATH_par(f, FractionRuleThickness), lvl);
@@ -835,6 +841,14 @@
            big_op_spacing5(size_id), lvl);
         DEFINE_DMATH_PARAMETERS(math_param_limit_below_kern, size_id,
             big_op_spacing5(size_id), lvl);
+        DEFINE_MATH_PARAMETERS(math_param_nolimit_sub_factor, size_id,
+            font_MATH_par(f, NoLimitSubFactor), lvl); /* bonus */
+        DEFINE_DMATH_PARAMETERS(math_param_nolimit_sub_factor, size_id,
+            font_MATH_par(f, NoLimitSubFactor), lvl); /* bonus */
+        DEFINE_MATH_PARAMETERS(math_param_nolimit_sup_factor, size_id,
+            font_MATH_par(f, NoLimitSupFactor), lvl); /* bonus */
+        DEFINE_DMATH_PARAMETERS(math_param_nolimit_sup_factor, size_id,
+            font_MATH_par(f, NoLimitSupFactor), lvl); /* bonus */
         DEFINE_MATH_PARAMETERS(math_param_subsup_vgap, size_id,
             4 * default_rule_thickness(size_id), lvl);
         DEFINE_DMATH_PARAMETERS(math_param_subsup_vgap, size_id,
@@ -884,27 +898,27 @@
 @c
 static void finalize_math_parameters(void)
 {
-    int saved_trace = int_par(tracing_assigns_code);
-    int_par(tracing_assigns_code) = 0;
+    int saved_trace = tracing_assigns_par;
+    tracing_assigns_par = 0;
     if (get_math_param(math_param_space_after_script, display_style) == undefined_math_parameter) {
         def_math_param(math_param_space_after_script, display_style,
-            script_space, level_one);
+            script_space_par, level_one);
         def_math_param(math_param_space_after_script, text_style,
-            script_space, level_one);
+            script_space_par, level_one);
         def_math_param(math_param_space_after_script, script_style,
-            script_space, level_one);
+            script_space_par, level_one);
         def_math_param(math_param_space_after_script, script_script_style,
-            script_space, level_one);
+            script_space_par, level_one);
         def_math_param(math_param_space_after_script, cramped_display_style,
-            script_space, level_one);
+            script_space_par, level_one);
         def_math_param(math_param_space_after_script, cramped_text_style,
-            script_space, level_one);
+            script_space_par, level_one);
         def_math_param(math_param_space_after_script, cramped_script_style,
-            script_space, level_one);
+            script_space_par, level_one);
         def_math_param(math_param_space_after_script, cramped_script_script_style,
-            script_space, level_one);
+            script_space_par, level_one);
     }
-    int_par(tracing_assigns_code) = saved_trace;
+    tracing_assigns_par = saved_trace;
 }
 
 @ In order to convert mlists to hlists, i.e., noads to nodes, we need several
@@ -964,11 +978,17 @@
   that eventually contains it.
 
 @c
-static pointer do_fraction_rule(scaled t, pointer att)
+static pointer do_fraction_rule(scaled t, pointer att, halfword some_rule, halfword cur_size, halfword cur_fam)
 {
     pointer p;                  /* the new node */
-    p = new_rule(normal_rule);
-    rule_dir(p) = math_direction;
+    if (math_rules_mode_par) {
+        p = new_rule(some_rule);
+        rule_math_size(p) = cur_size;
+        rule_math_font(p) = fam_fnt(cur_fam, cur_size);
+    } else {
+        p = new_rule(normal_rule);
+    }
+    rule_dir(p) = math_direction_par;
     height(p) = t;
     depth(p) = 0;
     reset_attributes(p, att);
@@ -980,18 +1000,18 @@
   fraction rule of thickness |t| under additional space of height |ht|.
 
 @c
-static pointer overbar(pointer b, scaled k, scaled t, scaled ht, pointer att)
+static pointer overbar(pointer b, scaled k, scaled t, scaled ht, pointer att, halfword index, halfword cur_size, halfword cur_fam)
 {
     pointer p, q;               /* nodes being constructed */
     p = new_kern(k);
     reset_attributes(p, att);
     couple_nodes(p,b);
-    q = do_fraction_rule(t, att);
+    q = do_fraction_rule(t, att, index, cur_size, cur_fam);
     couple_nodes(q,p);
     p = new_kern(ht);
     reset_attributes(p, att);
     couple_nodes(p,q);
-    q = vpackage(p, 0, additional, max_dimen, math_direction);
+    q = vpackage(p, 0, additional, max_dimen, math_direction_par);
     reset_attributes(q, att);
     return q;
 }
@@ -1007,7 +1027,7 @@
 {
     pointer b, p; /* the new box and its character node */
     b = new_null_box();
-    if (is_new_mathfont(f))
+    if (do_new_math(f))
         width(b) = char_width(f, c);
     else
         width(b) = char_width(f, c) + char_italic(f, c);
@@ -1134,7 +1154,7 @@
                 NULL
             };
             tex_error("Variant part doesn't exist.", hlp);
-            width(b) = null_delimiter_space;
+            width(b) = null_delimiter_space_par;
             return b;
         }
         if (cur->extender > 0)
@@ -1420,7 +1440,7 @@
                 b = get_delim_box(d, ext, f, v, att, cur_style, vlist_node);
             }
             if (delta != NULL) {
-                if (is_new_mathfont(f)) {
+                if (do_new_math(f)) {
                     *delta = char_vert_italic(f,x);
                 } else {
                     *delta = char_italic(f,x);
@@ -1430,12 +1450,12 @@
                 *stack = true ;
         } else {
             b = char_box(f, c, att);
-            if (!is_new_mathfont(f)) {
+            if (!do_new_math(f)) {
                 /* italic gets added to width */
                 width(b) += char_italic(f, c);
             }
             if (delta != NULL) {
-                *delta = char_italic(f,x);
+                *delta = char_italic(f, c); /* was historically (f, x) */
             }
             if (stack != NULL)
                 *stack = false ;
@@ -1447,7 +1467,7 @@
             width(b) = 0;
         } else {
             /* use this width if no delimiter was found */
-            width(b) = null_delimiter_space;
+            width(b) = null_delimiter_space_par;
         }
         if (delta != NULL) {
             *delta = 0;
@@ -1595,7 +1615,6 @@
 {
     int callback_id;
     int a, sfix;
-    lua_State *L = Luas;
     if (p == null) {
         vlink(temp_head) = null;
         return;
@@ -1603,26 +1622,26 @@
     finalize_math_parameters();
     callback_id = callback_defined(mlist_to_hlist_callback);
     if (callback_id > 0) {
-        sfix = lua_gettop(L);
-        if (!get_callback(L, callback_id)) {
-            lua_settop(L, sfix);
+        sfix = lua_gettop(Luas);
+        if (!get_callback(Luas, callback_id)) {
+            lua_settop(Luas, sfix);
             return;
         }
         alink(p) = null ;
-        nodelist_to_lua(L, p);
-        lua_push_math_style_name(L,mstyle);
-        lua_pushboolean(L, penalties);
-        if (lua_pcall(L, 3, 1, 0) != 0) {            /* 3 args, 1 result */
+        nodelist_to_lua(Luas, p);
+        lua_push_math_style_name(Luas, mstyle);
+        lua_pushboolean(Luas, penalties);
+        if (lua_pcall(Luas, 3, 1, 0) != 0) {            /* 3 args, 1 result */
             char errmsg[256]; /* temp hack ... we will have a formatted error */
-            snprintf(errmsg, 255, "error: %s\n", lua_tostring(L, -1));
+            snprintf(errmsg, 255, "error: %s\n", lua_tostring(Luas, -1));
             errmsg[255]='\0';
-            lua_settop(L, sfix);
+            lua_settop(Luas, sfix);
             normal_error("mlist to hlist",errmsg); /* to be done */
             return;
         }
-        a = nodelist_from_lua(L);
+        a = nodelist_from_lua(Luas);
         /* alink(vlink(a)) = null; */
-        lua_settop(L, sfix);
+        lua_settop(Luas, sfix);
         vlink(temp_head) = a;
     } else if (callback_id == 0) {
         mlist_to_hlist(p, penalties, mstyle);
@@ -1783,17 +1802,17 @@
 couple of simple ones.
 
 @c
-static void make_over(pointer q, int cur_style)
+static void make_over(pointer q, int cur_style, int cur_size, int cur_fam)
 {
     pointer p;
     p = overbar(clean_box(nucleus(q), cramped_style(cur_style), cur_style),
                 overbar_vgap(cur_style), overbar_rule(cur_style),
-                overbar_kern(cur_style), node_attr(nucleus(q)));
+                overbar_kern(cur_style), node_attr(nucleus(q)), math_over_rule, cur_size, cur_fam);
     math_list(nucleus(q)) = p;
     type(nucleus(q)) = sub_box_node;
 }
 
-static void make_under(pointer q, int cur_style)
+static void make_under(pointer q, int cur_style, int cur_size, int cur_fam)
 {
     pointer p, x, y, r;         /* temporary registers for box construction */
     scaled delta;               /* overall height plus depth */
@@ -1801,9 +1820,9 @@
     p = new_kern(underbar_vgap(cur_style));
     reset_attributes(p, node_attr(q));
     couple_nodes(x,p);
-    r = do_fraction_rule(underbar_rule(cur_style), node_attr(q));
+    r = do_fraction_rule(underbar_rule(cur_style), node_attr(q), math_under_rule, cur_size, cur_fam);
     couple_nodes(p,r);
-    y = vpackage(x, 0, additional, max_dimen, math_direction);
+    y = vpackage(x, 0, additional, max_dimen, math_direction_par);
     reset_attributes(y, node_attr(q));
     delta = height(y) + depth(y) + underbar_kern(cur_style);
     height(y) = height(x);
@@ -1865,7 +1884,7 @@
     scaled delta, clr, theta, h; /* dimensions involved in the calculation */
     x = clean_box(nucleus(q), cramped_style(cur_style), cur_style);
     clr = radical_vgap(cur_style);
-    theta = radical_rule(cur_style);
+    theta = radical_rule_par(cur_style);
     if (theta == undefined_math_parameter) {
         /* a real radical */
         theta = fraction_rule(cur_style);
@@ -1899,7 +1918,7 @@
     }
     shift_amount(y) = (height(y) - theta) - (height(x) + clr);
     h = depth(y) + height(y);
-    p = overbar(x, clr, theta, radical_kern(cur_style), node_attr(y));
+    p = overbar(x, clr, theta, radical_kern(cur_style), node_attr(y), math_radical_rule, cur_size, small_fam(left_delimiter(q)));
     couple_nodes(y,p);
     if (degree(q) != null) {
         scaled wr, br, ar;
@@ -2130,7 +2149,7 @@
     boolean s_is_absolute = false; /* will be true if a top-accent is placed in |s| */
     if (type(nucleus(q)) == math_char_node) {
         fetch(nucleus(q));
-        if (is_new_mathfont(cur_f)) {
+        if (do_new_math(cur_f)) {
             /*
                 there is no bot_accent so let's assume similarity
 
@@ -2200,7 +2219,7 @@
     x = clean_box(nucleus(q), cramped_style(cur_style), cur_style);
     w = width(x);
     h = height(x);
-    if (is_new_mathfont(cur_f) && !s_is_absolute) {
+    if (do_new_math(cur_f) && !s_is_absolute) {
         s = half(w);
         s_is_absolute = true;
     }
@@ -2278,7 +2297,7 @@
     } else if ((vlink(q) != null) && (type(nucleus(q)) == math_char_node)) {
         /* only pure math char nodes */
         internal_font_number f = fam_fnt(math_fam(nucleus(q)),cur_size);
-        if (is_new_mathfont(f)) {
+        if (do_new_math(f)) {
             ic = char_italic(f,math_character(nucleus(q)));
         }
     }
@@ -2304,7 +2323,7 @@
             /* just take the center */
             sa = half(width(y));
         }
-        if (math_direction == dir_TRT) {
+        if (math_direction_par == dir_TRT) {
            shift_amount(y) = s + sa - width(y);
         } else {
            shift_amount(y) = s - sa;
@@ -2312,7 +2331,7 @@
     } else {
         if (width(y)== 0) {
             shift_amount(y) = s + w;
-        } else if (math_direction == dir_TRT) {
+        } else if (math_direction_par == dir_TRT) {
             shift_amount(y) = s + width(y); /* ok? */
         } else {
             shift_amount(y) = s + half(w - width(y));
@@ -2328,7 +2347,7 @@
         couple_nodes(x,y);
         y = x;
     }
-    r = vpackage(y, 0, additional, max_dimen, math_direction);
+    r = vpackage(y, 0, additional, max_dimen, math_direction_par);
     reset_attributes(r, node_attr(q));
     width(r) = width(x);
     y = r;
@@ -2447,7 +2466,6 @@
             delta1 = clr1 - ((shift_up   - depth(x) ) - (math_axis_size(cur_size) + delta));
             delta2 = clr2 - ((shift_down - height(z)) + (math_axis_size(cur_size) - delta));
         } else {
-            delta = half(thickness(q));
             clr1 = ext_xn_over_d(clr1, thickness(q), fraction_rule(cur_style));
             clr2 = ext_xn_over_d(clr2, thickness(q), fraction_rule(cur_style));
             delta1 = clr1 - ((shift_up   - depth(x) ) - (math_axis_size(cur_size) + delta));
@@ -2547,7 +2565,7 @@
             p = new_kern((shift_up - depth(x)) - (height(z) - shift_down));
             couple_nodes(p,z);
         } else {
-            y = do_fraction_rule(thickness(q), node_attr(q));
+            y = do_fraction_rule(thickness(q), node_attr(q), math_fraction_rule, cur_size, math_rules_fam_par);
             p = new_kern((math_axis_size(cur_size) - delta) - (height(z) - shift_down));
             reset_attributes(p, node_attr(q));
             couple_nodes(y,p);
@@ -2563,8 +2581,8 @@
         put the fraction into a box with its delimiters, and make |new_hlist(q)|
         point to it
     */
-    if (is_new_mathfont(cur_f)) {
-        if (math_use_old_fraction_scaling) {
+    if (do_new_math(cur_f)) {
+        if (math_use_old_fraction_scaling_par) {
             delta = fraction_del_size_old(cur_style);
         } else {
             delta = fraction_del_size_new(cur_style);
@@ -2628,7 +2646,7 @@
                 small_fam(y) = math_fam(nucleus(q));
                 small_char(y) = math_character(nucleus(q));
                 x = do_delimiter(q, y, text_size, ok_size, false, cur_style, true, NULL, &delta);
-                if (is_new_mathfont(cur_f)) {
+                if (do_new_math(cur_f)) {
                     /* we never added italic correction */
                 } else if ((subscr(q) != null) && (subtype(q) != op_noad_type_limits)) {
                     /* remove italic correction */
@@ -2644,9 +2662,10 @@
                     math_character(nucleus(q)) = c;
                 }
                 delta = char_italic(cur_f, cur_c);
+printf("delta %i\n",delta);
                 x = clean_box(nucleus(q), cur_style, cur_style);
-                if (delta != null) {
-                    if (is_new_mathfont(cur_f)) {
+                if (delta != 0) {
+                    if (do_new_math(cur_f)) {
                         /* we never added italic correction */
                     } else if ((subscr(q) != null) && (subtype(q) != op_noad_type_limits)) {
                         /* remove italic correction */
@@ -2660,7 +2679,7 @@
             delta = char_italic(cur_f, cur_c);
             x = clean_box(nucleus(q), cur_style, cur_style);
             if (delta != 0) {
-                if (is_new_mathfont(cur_f)) {
+                if (do_new_math(cur_f)) {
                     /* we never added italic correction */
                 } else if ((subscr(q) != null) && (subtype(q) != op_noad_type_limits)) {
                     /* remove italic correction */
@@ -2680,15 +2699,55 @@
     /* we now handle op_nod_type_no_limits here too */
 
     if (subtype(q) == op_noad_type_no_limits) {
-        if (is_new_mathfont(cur_f)) {
-            if (delta != 0) {
-                delta = half(delta) ;
-            }
+        if (do_new_math(cur_f)) {
+            /*
+                if (delta != 0) {
+                    delta = half(delta) ;
+                }
+            */
             p = check_nucleus_complexity(q, &dummy, cur_style);
             if ((subscr(q) == null) && (supscr(q) == null)) {
                 assign_new_hlist(q, p);
             } else {
-                make_scripts(q, p, 0, cur_style, delta, -delta);
+                /*
+                    make_scripts(q, p, 0, cur_style, delta, -delta);
+                */
+                int mode = nolimits_mode_par; /* wins */
+                /*
+                    for easy configuration ... fonts are somewhat inconsistent and the
+                    values for italic correction run from 30 to 60% of the width
+                */
+                switch (mode) {
+                    case 0 :
+                        /* full bottom correction */
+                        make_scripts(q, p, 0, cur_style, 0, -delta);
+                        break;
+                    case 1 :
+                        /* MathConstants driven */
+                        make_scripts(q, p, 0, cur_style,
+                             round_xn_over_d(delta, nolimit_sup_factor(cur_style), 1000),
+                            -round_xn_over_d(delta, nolimit_sub_factor(cur_style), 1000));
+                    case 2 :
+                        /* no correction */
+                        make_scripts(q, p, 0, cur_style, 0, 0);
+                        break ;
+                    case 3 :
+                        /* half bottom correction */
+                        make_scripts(q, p, 0, cur_style, 0, -half(delta));
+                        break;
+                    case 4 :
+                        /* half bottom and top correction */
+                        make_scripts(q, p, 0, cur_style, half(delta), -half(delta));
+                        break;
+                    default :
+                        if (mode > 15) {
+                            /* for quickly testing values */
+                            make_scripts(q, p, 0, cur_style, 0, -round_xn_over_d(delta, mode, 1000));
+                        } else {
+                            make_scripts(q, p, 0, cur_style, 0, 0);
+                        }
+                        break;
+                }
             }
             delta = 0;
         } else {
@@ -2709,9 +2768,9 @@
         v = new_null_box();
         reset_attributes(v, node_attr(q));
         type(v) = vlist_node;
-        if (is_new_mathfont(cur_f)) {
+        if (do_new_math(cur_f)) {
             n = null;
-            if (! math_no_italic_compensation) {
+            if (! math_no_italic_compensation_par) {
                 n = nucleus(q);
                 if (n != null) {
                     if ((type(n) == sub_mlist_node) || (type(n) == sub_box_node)) {
@@ -2820,7 +2879,7 @@
             supscr(q) = null;
         }
         assign_new_hlist(q, v);
-        if (is_new_mathfont(cur_f)) {
+        if (do_new_math(cur_f)) {
             delta = 0;
         }
     }
@@ -2862,7 +2921,7 @@
             fetch(nucleus(q));
             a = cur_c;
             /* add italic correction */
-            if (is_new_mathfont(cur_f) && (char_italic(cur_f,math_character(nucleus(q))) != 0)) {
+            if (do_new_math(cur_f) && (char_italic(cur_f,math_character(nucleus(q))) != 0)) {
                 p = new_kern(char_italic(cur_f,math_character(nucleus(q))));
                 reset_attributes(p, node_attr(q));
                 couple_nodes(p,vlink(q));
@@ -2885,7 +2944,7 @@
                     ligatures only when this convention makes sense
                 */
 
-                if (disable_lig == 0 && has_lig(cur_f, a)) {
+                if (disable_lig_par == 0 && has_lig(cur_f, a)) {
                     lig = get_ligature(cur_f, a, cur_c);
                     if (is_valid_ligature(lig)) {
                         check_interrupt();      /* allow a way out of infinite ligature loop */
@@ -2941,7 +3000,7 @@
                         goto RESTART;
                     }
                 }
-                if (disable_kern == 0 && has_kern(cur_f, a)) {
+                if (disable_kern_par == 0 && has_kern(cur_f, a)) {
                     /* todo: should this use mathkerns? */
                     k = get_kern(cur_f, a, cur_c);
                     if (k != 0) {
@@ -3023,7 +3082,7 @@
 {
     scaled corr_height_top = 0, corr_height_bot = 0;
     scaled krn_l = 0, krn_r = 0, krn = 0;
-    if ((!is_new_mathfont(l_f)) || (!is_new_mathfont(r_f)) || (!char_exists(l_f, l_c)) || (!char_exists(r_f, r_c)))
+    if ((!do_new_math(l_f)) || (!do_new_math(r_f)) || (!char_exists(l_f, l_c)) || (!char_exists(r_f, r_c)))
         return MATH_KERN_NOT_FOUND;
 
     if (cmd == sup_mark_cmd) {
@@ -3239,7 +3298,7 @@
         */
         x = clean_box(subscr(q), sub_style(cur_style), cur_style);
         width(x) = width(x) + space_after_script(cur_style);
-        switch (scripts_mode) {
+        switch (scripts_mode_par) {
             case 1:
                 shift_down = sub_shift_down(cur_style) ;
                 break;
@@ -3289,7 +3348,7 @@
         */
         x = clean_box(supscr(q), sup_style(cur_style), cur_style);
         width(x) = width(x) + space_after_script(cur_style);
-        switch (scripts_mode) {
+        switch (scripts_mode_par) {
             case 1:
                 shift_up = sup_shift_up(cur_style);
                 break;
@@ -3344,7 +3403,7 @@
             */
             y = clean_box(subscr(q), sub_style(cur_style), cur_style);
             width(y) = width(y) + space_after_script(cur_style);
-            switch (scripts_mode) {
+            switch (scripts_mode_par) {
                 case 1:
                     shift_down = sub_shift_down(cur_style) ;
                     break;
@@ -3413,7 +3472,7 @@
             couple_nodes(x,p);
             couple_nodes(p,y);
             /* we end up with funny dimensions */
-            x = vpackage(x, 0, additional, max_dimen, math_direction);
+            x = vpackage(x, 0, additional, max_dimen, math_direction_par);
             reset_attributes(x, node_attr(q));
             shift_amount(x) = shift_down;
         }
@@ -3750,15 +3809,15 @@
         fetch(nucleus(q));
         if (char_exists(cur_f, cur_c)) {
             /* we could look at neighbours */
-            if (is_new_mathfont(cur_f)) {
+            if (do_new_math(cur_f)) {
                 *delta = 0 ; /* cf spec only the last one */
             } else {
                 *delta = char_italic(cur_f, cur_c);
             }
             p = new_glyph(cur_f, cur_c);
             reset_attributes(p, node_attr(nucleus(q)));
-            if (is_new_mathfont(cur_f)) {
-                if (! math_no_char_italic) {
+            if (do_new_math(cur_f)) {
+                if (! math_no_char_italic_par) {
                     /* keep italic, but bad with two successive letters */
                 } else if (get_char_cat_code(cur_c) == 11) {
                     /* no italic correction in mid-word of text font */
@@ -3777,7 +3836,7 @@
                 couple_nodes(p,x);
                 *delta = 0;
             }
-            if (is_new_mathfont(cur_f)) {
+            if (do_new_math(cur_f)) {
                 *delta = char_italic(cur_f, cur_c); /* must be more selective */
             }
         }
@@ -3860,10 +3919,10 @@
                 }
                 break;
             case over_noad_type:
-                make_over(q, cur_style);
+                make_over(q, cur_style, cur_size, math_rules_fam_par);
                 break;
             case under_noad_type:
-                make_under(q, cur_style);
+                make_under(q, cur_style, cur_size, math_rules_fam_par);
                 break;
             case vcenter_noad_type:
                 make_vcenter(q);
@@ -4087,10 +4146,10 @@
             t_subtype = subtype(q);
             switch (t_subtype) {
             case bin_noad_type:
-                pen = bin_op_penalty;
+                pen = bin_op_penalty_par;
                 break;
             case rel_noad_type:
-                pen = rel_penalty;
+                pen = rel_penalty_par;
                 break;
             case vcenter_noad_type:
             case over_noad_type:
--- texlive-bin.orig/texk/web2c/luatexdir/tex/nesting.w
+++ texlive-bin/texk/web2c/luatexdir/tex/nesting.w
@@ -19,14 +19,11 @@
 
 @ @c
 
-
 #include "ptexlib.h"
 
 @ these are for |show_activities|
 @c
 #define page_goal page_so_far[0]
-#define count(A) eqtb[count_base+(A)].cint
-
 
 @ \TeX\ is typically in the midst of building many lists at once. For example,
 when a math formula is being processed, \TeX\ is in math mode and
@@ -251,9 +248,7 @@
     init_math_fields();
 }
 
-
-
-@ Here is a common way to make the current list grow: 
+@ Here is a common way to make the current list grow:
 
 @c
 void tail_append(halfword p)
@@ -262,7 +257,6 @@
     cur_list.tail_field = vlink(cur_list.tail_field);
 }
 
-
 @ @c
 halfword pop_tail(void)
 {
@@ -311,7 +305,6 @@
     init_math_fields();
 }
 
-
 @ Conversely, when \TeX\ is finished on the current level, the former
 state is restored by calling |pop_nest|. This routine will never be
 called at the lowest semantic level, nor will it be called unless |head|
@@ -324,7 +317,7 @@
     decr(nest_ptr);
 }
 
-@ Here is a procedure that displays what \TeX\ is working on, at all levels. 
+@ Here is a procedure that displays what \TeX\ is working on, at all levels.
 
 @c
 void show_activities(void)
@@ -343,7 +336,7 @@
         print_int(abs(nest[p].ml_field));
         /* we dont do this any more */
 #if 0
-        
+
            if (m == hmode)
            if (nest[p].pg_field != 040600000) {
            tprint(" (language");
--- texlive-bin.orig/texk/web2c/luatexdir/tex/packaging.w
+++ texlive-bin/texk/web2c/luatexdir/tex/packaging.w
@@ -21,17 +21,6 @@
 
 #include "ptexlib.h"
 
-@ @c
-#define scan_normal_dimen() scan_dimen(false,false,false)
-
-#define prev_depth      cur_list.prev_depth_field
-#define space_factor    cur_list.space_factor_field
-#define box(A) eqtb[box_base+(A)].hh.rh
-
-#define every_hbox equiv(every_hbox_loc)
-#define every_vbox equiv(every_vbox_loc)
-#define box_max_depth dimen_par(box_max_depth_code)
-
 @ We're essentially done with the parts of \TeX\ that are concerned with the
 input (|get_next|) and the output (|ship_out|). So it's time to get heavily into
 the remaining part, which does the real work of typesetting.
@@ -286,7 +275,7 @@
     if (! done) {
         scan_left_brace();
     }
-    /* no gain: if (body_direction != spec_direction) etc */
+    /* no gain: if (body_direction_par != spec_direction) etc */
     eq_word_define(int_base + body_direction_code, spec_direction);
     eq_word_define(int_base + par_direction_code, spec_direction);
     eq_word_define(int_base + text_direction_code, spec_direction);
@@ -439,7 +428,7 @@
         return 0;
     }
     /* we use the old logic, kind of, but average the ef as we might depend on proper overlap */
-    m = (font_max_shrink(font(l)) + font_max_shrink(font(r)))/2;
+    m = (font_max_stretch(font(l)) + font_max_stretch(font(r)))/2;
     if (m == 0) {
         /* nothing to kern */
         return 0;
@@ -478,7 +467,7 @@
     // and a reason to kern
     if ((font(l) != font(r)) || (font_max_shrink(font(l)) == 0))
         return 0;
-    m = font_max_stretch(font(l));
+    m = font_max_shrink(font(l));
     d = get_kern(font(l), character(l), character(r)); // real kern, so what is width(p) then; the messed up one
     d = round_xn_over_d(d, 1000 - m, 1000);
     return round_xn_over_d(width(p) - d, get_ef_code(font(l), character(l)), 1000);
@@ -632,7 +621,7 @@
     halfword pack_interrupt[8];
     scaled font_stretch = 0;
     scaled font_shrink = 0;
-    int adjust_spacing = int_par(adjust_spacing_code);
+    int adjust_spacing = adjust_spacing_par;
 
 /*
     int font_expand_ratio = 0;
@@ -640,7 +629,7 @@
     last_badness = 0;
     r = new_node(hlist_node, min_quarterword); /* the box node that will be returned */
     if (pack_direction == -1) {
-        hpack_dir = text_direction;
+        hpack_dir = text_direction_par;
     } else {
         hpack_dir = pack_direction;
     }
@@ -943,7 +932,7 @@
                     is sufficiently bad.
                 */
                 last_badness = badness(x, total_stretch[normal]);
-                if (last_badness > int_par(hbadness_code)) {
+                if (last_badness > hbadness_par) {
                     int callback_id = callback_defined(hpack_quality_callback);
                     if (callback_id > 0) {
                         halfword rule = null;
@@ -1010,15 +999,15 @@
                 Report an overfull hbox and |goto common_ending|, if this box
                 is sufficiently bad.
             */
-            if ((overshoot > dimen_par(hfuzz_code)) || (int_par(hbadness_code) < 100)) {
+            if ((overshoot > hfuzz_par) || (hbadness_par < 100)) {
                 int callback_id = callback_defined(hpack_quality_callback);
                 halfword rule = null;
                 if (callback_id > 0) {
                     run_callback(callback_id, "SdNdd->N","overfull",overshoot,r,abs(pack_begin_line),line,&rule);
-                } else if (dimen_par(overfull_rule_code) > 0) {
+                } else if (overfull_rule_par > 0) {
                     rule = new_rule(normal_rule);
                     rule_dir(rule) = box_dir(r);
-                    width(rule) = dimen_par(overfull_rule_code);
+                    width(rule) = overfull_rule_par;
                 }
                 if (rule != null) {
                     while (vlink(q) != null) {
@@ -1041,7 +1030,7 @@
                     sufficiently bad.
                 */
                 last_badness = badness(-x, total_shrink[normal]);
-                if (last_badness > int_par(hbadness_code)) {
+                if (last_badness > hbadness_par) {
                     int callback_id = callback_defined(hpack_quality_callback);
                     if (callback_id > 0) {
                         halfword rule = null;
@@ -1119,7 +1108,7 @@
         q = vlink(p);
         /*
             q = new_node(hlist_node, min_quarterword);
-            box_dir(q) = (pac == -1) ? text_direction : pac;
+            box_dir(q) = (pac == -1) ? text_direction_par : pac;
             width(q) = w;
             return q;
         */
@@ -1147,7 +1136,7 @@
     scaled gp = 0;
     scaled gm = 0;
     if (pack_direction == -1) {
-        hpack_dir = text_direction;
+        hpack_dir = text_direction_par;
     } else {
         hpack_dir = pack_direction;
     }
@@ -1292,7 +1281,7 @@
     last_badness = 0;
     r = new_node(vlist_node, 0);
     if (pack_direction == -1) {
-        box_dir(r) = body_direction;
+        box_dir(r) = body_direction_par;
     } else {
         box_dir(r) = pack_direction;
     }
@@ -1434,7 +1423,7 @@
                     is sufficiently bad.
                 */
                 last_badness = badness(x, total_stretch[normal]);
-                if (last_badness > int_par(vbadness_code)) {
+                if (last_badness > vbadness_par) {
                     int callback_id = callback_defined(vpack_quality_callback);
                     if (callback_id > 0) {
                         if (last_badness > 100) {
@@ -1492,7 +1481,7 @@
                 Report an overfull vbox and |goto common_ending|, if this box
                 is sufficiently bad.
             */
-            if ((overshoot > dimen_par(vfuzz_code)) || (int_par(vbadness_code) < 100)) {
+            if ((overshoot > vfuzz_par) || (vbadness_par < 100)) {
                 int callback_id = callback_defined(vpack_quality_callback);
                 if (callback_id > 0) {
                     run_callback(callback_id, "SdNdd->","overfull",overshoot,r,abs(pack_begin_line),line);
@@ -1512,7 +1501,7 @@
                     sufficiently bad.
                 */
                 last_badness = badness(-x, total_shrink[normal]);
-                if (last_badness > int_par(vbadness_code)) {
+                if (last_badness > vbadness_par) {
                     int callback_id = callback_defined(vpack_quality_callback);
                     if (callback_id > 0) {
                         run_callback(callback_id, "SdNdd->","tight",last_badness,r,abs(pack_begin_line),line);
@@ -1579,7 +1568,7 @@
 {
     halfword saved0, saved2, saved3, saved4;
     int grp = cur_group;
-    scaled d = box_max_depth; /* max depth */
+    scaled d = box_max_depth_par; /* max depth */
     unsave();
     save_ptr -= 5;
     saved0 = saved_value(0);
@@ -1633,23 +1622,23 @@
     halfword result = null;
     halfword next_depth = ignore_depth;
     boolean prev_set = false ;
-    if (lua_appendtovlist_callback(b,location,prev_depth,mirrored,&result,&next_depth,&prev_set)) {
+    if (lua_appendtovlist_callback(b,location,prev_depth_par,mirrored,&result,&next_depth,&prev_set)) {
         while (result != null) {
             couple_nodes(cur_list.tail_field, result);
             cur_list.tail_field = result;
             result = vlink(result);
         }
         if (prev_set) {
-            prev_depth = next_depth;
+            prev_depth_par = next_depth;
         }
     } else {
-        if (prev_depth > ignore_depth) {
+        if (prev_depth_par > ignore_depth) {
             if (mirrored) {
-                d = width(glue_par(baseline_skip_code)) - prev_depth - depth(b);
+                d = width(baseline_skip_par) - prev_depth_par - depth(b);
             } else {
-                d = width(glue_par(baseline_skip_code)) - prev_depth - height(b);
+                d = width(baseline_skip_par) - prev_depth_par - height(b);
             }
-            if (d < dimen_par(line_skip_limit_code)) {
+            if (d < line_skip_limit_par) {
                 p = new_param_glue(line_skip_code);
             } else {
                 p = new_skip_param(baseline_skip_code);
@@ -1661,9 +1650,9 @@
         couple_nodes(cur_list.tail_field, b);
         cur_list.tail_field = b;
         if (mirrored) {
-            prev_depth = height(b);
+            prev_depth_par = height(b);
         } else {
-            prev_depth = depth(b);
+            prev_depth_par = depth(b);
         }
     }
 }
@@ -1959,7 +1948,7 @@
         error();
         return null;
     }
-    q = vert_break(list_ptr(v), h, dimen_par(split_max_depth_code));
+    q = vert_break(list_ptr(v), h, split_max_depth_par);
     /*
         Look at all the marks in nodes before the break, and set the final
         link to |null| at the break. It's possible that the box begins with
@@ -1990,7 +1979,7 @@
             p = vlink(p);
         }
     }
-    q = prune_page_top(q, int_par(saving_vdiscards_code) > 0);
+    q = prune_page_top(q, saving_vdiscards_par > 0);
     p = list_ptr(v);
     list_ptr(v) = null;
     flush_node(v);
@@ -1998,12 +1987,12 @@
         /* the |eq_level| of the box stays the same */
         box(n) = null;
     } else {
-        box(n) = filtered_vpackage(q, 0, additional, dimen_par(max_depth_code), split_keep_group, vdir, 0, 0);
+        box(n) = filtered_vpackage(q, 0, additional, max_depth_par, split_keep_group, vdir, 0, 0);
     }
     if (m == exactly) {
-        return filtered_vpackage(p, h, exactly, dimen_par(split_max_depth_code), split_off_group, vdir, 0, 0);
+        return filtered_vpackage(p, h, exactly, split_max_depth_par, split_off_group, vdir, 0, 0);
     } else {
-        return filtered_vpackage(p, 0, additional, dimen_par(max_depth_code), split_off_group, vdir, 0, 0);
+        return filtered_vpackage(p, 0, additional, max_depth_par, split_off_group, vdir, 0, 0);
     }
 }
 
@@ -2020,6 +2009,7 @@
     int n;      /* a box number */
     int spec_direction = -1;
     int just_pack = 0;
+    int split_mode = exactly ;
     switch (cur_chr) {
         case box_code:
             scan_register_num();
@@ -2077,15 +2067,17 @@
             */
             scan_register_num();
             n = cur_val;
-            if (!scan_keyword("to")) {
+            if (scan_keyword("upto")) {
+                split_mode = additional ;
+            } else if (!scan_keyword("to")) {
                 print_err("Missing `to' inserted");
                 help2("I'm working on `\\vsplit<box number> to <dimen>';",
                       "will look for the <dimen> next.");
                 error();
             }
             scan_normal_dimen();
-            cur_box = vsplit(n, cur_val, additional);
-            break;
+            cur_box = vsplit(n, cur_val, split_mode);
+         break;
         default:
             /*
                 Initiate the construction of an hbox or vbox, then |return|. Here is
@@ -2111,13 +2103,13 @@
             set_saved_record(0, saved_boxcontext, 0, box_context);
             switch (abs(cur_list.mode_field)) {
                 case vmode:
-                    spec_direction = body_direction;
+                    spec_direction = body_direction_par;
                     break;
                 case hmode:
-                    spec_direction = text_direction;
+                    spec_direction = text_direction_par;
                     break;
                 case mmode:
-                    spec_direction = math_direction;
+                    spec_direction = math_direction_par;
                     break;
             }
             if (k == hmode) {
@@ -2137,13 +2129,13 @@
             push_nest();
             cur_list.mode_field = -k;
             if (k == vmode) {
-                prev_depth = ignore_depth;
-                if (every_vbox != null)
-                    begin_token_list(every_vbox, every_vbox_text);
+                prev_depth_par = ignore_depth;
+                if (every_vbox_par != null)
+                    begin_token_list(every_vbox_par, every_vbox_text);
             } else {
-                space_factor = 1000;
-                if (every_hbox != null)
-                    begin_token_list(every_hbox, every_hbox_text);
+                space_factor_par = 1000;
+                if (every_hbox_par != null)
+                    begin_token_list(every_hbox_par, every_hbox_text);
             }
             return;
             break;
--- texlive-bin.orig/texk/web2c/luatexdir/tex/primitive.w
+++ texlive-bin/texk/web2c/luatexdir/tex/primitive.w
@@ -555,7 +555,7 @@
         print_hex(chr_code);
         break;
     case math_given_cmd:
-        if (mathoption_int_par(c_mathoption_umathcode_meaning_code) == 1) {
+        if (math_umathcode_meaning_par == 1) {
             tprint_esc("Umathchar");
             show_mathcode_value(mathchar_from_integer(chr_code, tex_mathcode));
         } else {
--- texlive-bin.orig/texk/web2c/luatexdir/tex/printing.w
+++ texlive-bin/texk/web2c/luatexdir/tex/printing.w
@@ -22,8 +22,6 @@
 #include "lua/luatex-api.h" /* for luatex_banner */
 
 @ @c
-#define font_id_text(A) cs_text(font_id_base+(A))
-
 #define wlog(A)  fputc(A,log_file)
 #define wterm(A) fputc(A,term_out)
 
@@ -182,7 +180,7 @@
         formatted_warning("print","weird character %i",s);
         return;
     }
-    if (s == int_par(new_line_char_code)) {
+    if (s == new_line_char_par) {
         if (selector < pseudo) {
             print_ln();
             return;
@@ -270,7 +268,7 @@
                 print_char(s);
                 return;
             }
-            if (s == int_par(new_line_char_code)) {
+            if (s == new_line_char_par) {
                 if (selector < pseudo) {
                     print_ln();
                     return;
@@ -364,7 +362,7 @@
 {
     char *buffer = NULL;
     int i = 0; /* buffer index */
-    int newlinechar = int_par(new_line_char_code);
+    int newlinechar = new_line_char_par;
     int dolog = 0;
     int doterm = 0;
     switch (selector) {
@@ -509,22 +507,22 @@
         "JAN", "FEB", "MAR", "APR", "MAY", "JUN",
         "JUL", "AUG", "SEP", "OCT", "NOV", "DEC"
     };
-    unsigned month = (unsigned) int_par(month_code);
+    unsigned month = (unsigned) month_par;
     if (month > 12)
         month = 0;
     fprintf(log_file, "This is " MyName ", Version %s%s ", v, WEB2CVERSION);
     print(format_ident);
     print_char(' ');
     print_char(' ');
-    print_int(int_par(day_code));
+    print_int(day_par);
     print_char(' ');
     fprintf(log_file, "%s", months[month]);
     print_char(' ');
-    print_int(int_par(year_code));
+    print_int(year_par);
     print_char(' ');
-    print_two(int_par(time_code) / 60);
+    print_two(time_par / 60);
     print_char(':');
-    print_two(int_par(time_code) % 60);
+    print_two(time_par % 60);
     if (shellenabledp) {
         wlog_cr();
         wlog(' ');
@@ -550,7 +548,7 @@
 @c
 void print_esc(str_number s)
 {
-    int c = int_par(escape_char_code); /* Set variable |c| to the current escape character */
+    int c = escape_char_par; /* Set variable |c| to the current escape character */
     if (c >= 0 && c < STRING_OFFSET)
         print(c);
     print(s);
@@ -561,7 +559,7 @@
 @c
 void tprint_esc(const char *s)
 {
-    int c = int_par(escape_char_code); /* Set variable |c| to the current escape character */
+    int c = escape_char_par; /* Set variable |c| to the current escape character */
     if (c >= 0 && c < STRING_OFFSET)
         print(c);
     tprint(s);
@@ -724,8 +722,7 @@
         } else {
             print_esc(t);
             if (single_letter(t)) {
-                if (get_cat_code(int_par(cat_code_table_code),
-                                 pool_to_unichar(str_string(t))) == letter_cmd)
+                if (get_cat_code(cat_code_table_par, pool_to_unichar(str_string(t))) == letter_cmd)
                     print_char(' ');
             } else {
                 print_char(' ');
@@ -851,7 +848,7 @@
         tprint_esc("FONT");
         print_int(f);
     }
-    if (int_par(tracing_fonts_code) > 0) {
+    if (tracing_fonts_par > 0) {
         tprint(" (");
         print_font_name(f);
         if (font_size(f) != font_dsize(f)) {
@@ -955,8 +952,8 @@
 @c
 void show_box(halfword p)
 {
-    depth_threshold = int_par(show_box_depth_code);
-    breadth_max = int_par(show_box_breadth_code);
+    depth_threshold = show_box_depth_par;
+    breadth_max = show_box_breadth_par;
     if (breadth_max <= 0)
         breadth_max = 5;
     /* the show starts at |p| */
@@ -1072,7 +1069,7 @@
 void begin_diagnostic(void)
 {
     global_old_setting = selector;
-    if ((int_par(tracing_online_code) <= 0) && (selector == term_and_log)) {
+    if ((tracing_online_par <= 0) && (selector == term_and_log)) {
         decr(selector);
         if (history == spotless)
             history = warning_issued;
--- texlive-bin.orig/texk/web2c/luatexdir/tex/scanning.h
+++ texlive-bin/texk/web2c/luatexdir/tex/scanning.h
@@ -45,6 +45,8 @@
 
 extern void scan_limited_int(int max, const char *name);
 
+extern void negate_cur_val(boolean delete_glue);
+
 #  define scan_register_num() scan_limited_int(65535,"register code")
 #  define scan_mark_num() scan_limited_int(65535,"marks code")
 #  define scan_char_num() scan_limited_int(biggest_char,"character code")
--- texlive-bin.orig/texk/web2c/luatexdir/tex/scanning.w
+++ texlive-bin/texk/web2c/luatexdir/tex/scanning.w
@@ -22,19 +22,6 @@
 #include "ptexlib.h"
 
 @ @c
-#define prev_depth cur_list.prev_depth_field
-#define space_factor cur_list.space_factor_field
-#define par_shape_ptr  equiv(par_shape_loc)
-#define font_id_text(A) cs_text(font_id_base+(A))
-
-#define attribute(A) eqtb[attribute_base+(A)].hh.rh
-#define dimen(A) eqtb[scaled_base+(A)].hh.rh
-#undef skip
-#define skip(A) eqtb[skip_base+(A)].hh.rh
-#define mu_skip(A) eqtb[mu_skip_base+(A)].hh.rh
-#define count(A) eqtb[count_base+(A)].hh.rh
-#define box(A) equiv(box_base+(A))
-
 static void scan_expr(void);
 
 @ Let's turn now to some procedures that \TeX\ calls upon frequently to digest
@@ -165,7 +152,7 @@
     decr(cur_val_level);
 }
 
-static void negate_cur_val(boolean delete_glue)
+void negate_cur_val(boolean delete_glue)
 {
     halfword m;
     if (cur_val_level >= glue_val_level) {
@@ -208,6 +195,9 @@
         scanned_result(eqtb[m].cint, int_val_level);
         break;
     case assign_dir_cmd:
+        if (m == (int_base + line_direction_code)) {
+            m = int_base + text_direction_code;
+        }
         scanned_result(eqtb[m].cint, dir_val_level);
         break;
     case assign_dimen_cmd:
@@ -215,11 +205,9 @@
         break;
     case assign_glue_cmd:
         scanned_result(equiv(m), glue_val_level);
-// cur_val = new_spec(cur_val);
         break;
     case assign_mu_glue_cmd:
         scanned_result(equiv(m), mu_val_level);
-// cur_val = new_spec(cur_val);
         break;
     case math_style_cmd:
         scanned_result(m, int_val_level);
@@ -239,9 +227,9 @@
             else
                 scanned_result(0, int_val_level);
         } else if (m == vmode) {
-            scanned_result(prev_depth, dimen_val_level);
+            scanned_result(prev_depth_par, dimen_val_level);
         } else {
-            scanned_result(space_factor, int_val_level);
+            scanned_result(space_factor_par, int_val_level);
         }
         break;
     case set_prev_graf_cmd:
@@ -279,10 +267,10 @@
         break;
     case set_tex_shape_cmd:
         /* Fetch the |par_shape| size */
-        if (par_shape_ptr == null)
+        if (par_shape_par_ptr == null)
             cur_val = 0;
         else
-            cur_val = vinfo(par_shape_ptr + 1);
+            cur_val = vinfo(par_shape_par_ptr + 1);
         cur_val_level = int_val_level;
         break;
     case set_etex_shape_cmd:
@@ -381,17 +369,17 @@
                 case par_shape_dimen_code:
                     q = cur_chr - par_shape_length_code;
                     scan_int();
-                    if ((par_shape_ptr == null) || (cur_val <= 0)) {
+                    if ((par_shape_par_ptr == null) || (cur_val <= 0)) {
                         cur_val = 0;
                     } else {
                         if (q == 2) {
                             q = cur_val % 2;
                             cur_val = (cur_val + q) / 2;
                         }
-                        if (cur_val > vinfo(par_shape_ptr + 1))
-                            cur_val = vinfo(par_shape_ptr + 1);
+                        if (cur_val > vinfo(par_shape_par_ptr + 1))
+                            cur_val = vinfo(par_shape_par_ptr + 1);
                         cur_val =
-                            varmem[par_shape_ptr + 2 * cur_val - q + 1].cint;
+                            varmem[par_shape_par_ptr + 2 * cur_val - q + 1].cint;
                     }
                     cur_val_level = dimen_val_level;
                     break;
@@ -531,7 +519,7 @@
                     break;
                 case lastskip_code:
                     if (last_glue != max_halfword)
-                        cur_val = last_glue; /* maybe new_glue */ 
+                        cur_val = last_glue; /* maybe new_glue */
                     break;
                 case last_node_type_code:
                     cur_val = last_node_type;
@@ -614,7 +602,7 @@
                 cur_val1 = get_sf_code(cur_val);
                 scanned_result(cur_val1, int_val_level);
             } else if (m == cat_code_base) {
-                cur_val1 = get_cat_code(int_par(cat_code_table_code), cur_val);
+                cur_val1 = get_cat_code(cat_code_table_par, cur_val);
                 scanned_result(cur_val1, int_val_level);
             } else {
                 confusion("def_char");
@@ -690,11 +678,11 @@
             } else {
                 cur_val1 = get_math_param(cur_val1, cur_chr);
                 if (cur_val1 == thin_mu_skip_code)
-                    cur_val1 = glue_par(thin_mu_skip_code);
+                    cur_val1 = thin_mu_skip_par;
                 else if (cur_val1 == med_mu_skip_code)
-                    cur_val1 = glue_par(med_mu_skip_code);
+                    cur_val1 = med_mu_skip_par;
                 else if (cur_val1 == thick_mu_skip_code)
-                    cur_val1 = glue_par(thick_mu_skip_code);
+                    cur_val1 = thick_mu_skip_par;
                 scanned_result(cur_val1, mu_val_level);
             }
             break;
@@ -803,28 +791,28 @@
                     goto DEFAULT;
                     break;
                 case 2:
-                    cur_val = get_pre_hyphen_char(int_par(language_code));
+                    cur_val = get_pre_hyphen_char(language_par);
                     cur_val_level = int_val_level;
                     break;
                 case 3:
-                    cur_val = get_post_hyphen_char(int_par(language_code));
+                    cur_val = get_post_hyphen_char(language_par);
                     cur_val_level = int_val_level;
                     break;
                 case 4:
-                    cur_val = get_pre_exhyphen_char(int_par(language_code));
+                    cur_val = get_pre_exhyphen_char(language_par);
                     cur_val_level = int_val_level;
                     break;
                 case 5:
-                    cur_val = get_post_exhyphen_char(int_par(language_code));
+                    cur_val = get_post_exhyphen_char(language_par);
                     cur_val_level = int_val_level;
                     break;
                 case 6:
-                    cur_val = get_hyphenation_min(int_par(language_code));
+                    cur_val = get_hyphenation_min(language_par);
                     cur_val_level = int_val_level;
                     break;
                 case 7:
                     scan_int();
-                    cur_val = get_hj_code(int_par(language_code),cur_val);
+                    cur_val = get_hj_code(language_par,cur_val);
                     cur_val_level = int_val_level;
                     break;
             }
@@ -1192,15 +1180,16 @@
 
 void scan_dimen(boolean mu, boolean inf, boolean shortcut)
 {
-    boolean negative; /* should the answer be negated? */
-    int f = 0;        /* numerator of a fraction whose denominator is $2^{16}$ */
-    int num, denom;   /* conversion ratio for the scanned units */
-    halfword q;       /* top of decimal digit stack */
-    scaled v;         /* an internal dimension */
-    int save_cur_val; /* temporary storage of |cur_val| */
+    boolean negative = false; /* should the answer be negated? */
+    boolean is_true  = false;
+    int f = 0;                /* numerator of a fraction whose denominator is $2^{16}$ */
+    int num = 0;              /* conversion ratio for the scanned units */
+    int denom = 0;
+    halfword q;               /* top of decimal digit stack */
+    scaled v;                 /* an internal dimension */
+    int save_cur_val;         /* temporary storage of |cur_val| */
     arith_error = false;
     cur_order = normal;
-    negative = false;
     if (!shortcut) {
         /* Get the next non-blank non-sign... */
         do {
@@ -1370,7 +1359,7 @@
     } else if (scan_keyword("ex")) {
         v = x_height(get_cur_font());
     } else if (scan_keyword("px")) {
-        v = dimen_par(px_dimen_code);
+        v = px_dimen_par;
     } else {
         goto PICKUP_UNIT;
     }
@@ -1388,7 +1377,7 @@
     */
   PICKUP_UNIT:
     if (scan_keyword("pt")) {
-        goto ATTACH_FRACTION;   /* the easy case */
+        goto SCALE_VALUE;   /* the easy case */
     } else if (scan_keyword("mm")) {
         set_conversion(7227, 2540);
         goto SCALE_VALUE;
@@ -1418,28 +1407,37 @@
     } else if (scan_keyword("nc")) {
         set_conversion(1370, 107);
         goto SCALE_VALUE;
-    } else if (scan_keyword("true")) {
-        /* Adjust (f)for the magnification ratio */
-        if (output_mode_used == OMODE_DVI) {
+    } else if (!is_true && scan_keyword("true")) {
+        is_true = true;
+        goto PICKUP_UNIT;
+    }
+    /* Complain about unknown unit and |goto done2| */
+    scan_dimen_unknown_unit_error();
+    goto BAD_NEWS;
+  SCALE_VALUE:
+    /* Adjust (f) for the magnification ratio */
+    if (is_true) {
+        /* maybe at some point we will drop mag completely, even in dvi mode */
+        if (output_mode_used <= OMODE_DVI) {
             prepare_mag();
-            if (int_par(mag_code) != 1000) {
-                cur_val = xn_over_d(cur_val, 1000, int_par(mag_code));
-                f = (1000 * f + 0200000 * tex_remainder) / int_par(mag_code);
+            if (mag_par != 1000) {
+                cur_val = xn_over_d(cur_val, 1000, mag_par);
+                f = (1000 * f + 0200000 * tex_remainder) / mag_par;
                 cur_val = cur_val + (f / 0200000);
                 f = f % 0200000;
             }
+        } else {
+            /* in pdf mode we're always true */
+            one_true_inch = one_inch; /* saveguard */
         }
-        goto PICKUP_UNIT;
-    } else {
-        /* Complain about unknown unit and |goto done2| */
-        scan_dimen_unknown_unit_error();
-        goto BAD_NEWS;
     }
-  SCALE_VALUE:
-    cur_val = xn_over_d(cur_val, num, denom);
-    f = (num * f + 0200000 * tex_remainder) / denom;
-    cur_val = cur_val + (f / 0200000);
-    f = f % 0200000;
+    /* */
+    if (num) {
+        cur_val = xn_over_d(cur_val, num, denom);
+        f = (num * f + 0200000 * tex_remainder) / denom;
+        cur_val = cur_val + (f / 0200000);
+        f = f % 0200000;
+    }
   BAD_NEWS:
   ATTACH_FRACTION:
     if (cur_val >= 040000) {
@@ -1837,11 +1835,11 @@
     }
     if (cur_cmd == vrule_cmd) {
         width(q) = default_rule;
-        rule_dir(q) = body_direction;
+        rule_dir(q) = body_direction_par;
     } else {
         height(q) = default_rule;
         depth(q) = 0;
-        rule_dir(q) = text_direction;
+        rule_dir(q) = text_direction_par;
     }
   RESWITCH:
     if (scan_keyword("width")) {
@@ -2157,15 +2155,14 @@
 
 @c
 typedef enum {
-    expr_none = 0,              /* \.( seen, or \.( $\langle\it expr\rangle$ \.) seen */
-    expr_add = 1,               /* \.( $\langle\it expr\rangle$ \.+ seen */
-    expr_sub = 2,               /* \.( $\langle\it expr\rangle$ \.- seen */
-    expr_mult = 3,              /* $\langle\it term\rangle$ \.* seen */
-    expr_div = 4,               /* $\langle\it term\rangle$ \./ seen */
-    expr_scale = 5,             /* $\langle\it term\rangle$ \.*  $\langle\it factor\rangle$ \./ seen */
+    expr_none  = 0, /* \.( seen, or \.( $\langle\it expr\rangle$ \.) seen */
+    expr_add   = 1, /* \.( $\langle\it expr\rangle$ \.+ seen */
+    expr_sub   = 2, /* \.( $\langle\it expr\rangle$ \.- seen */
+    expr_mult  = 3, /* $\langle\it term\rangle$ \.* seen */
+    expr_div   = 4, /* $\langle\it term\rangle$ \./ seen */
+    expr_scale = 5, /* $\langle\it term\rangle$ \.*  $\langle\it factor\rangle$ \./ seen */
 } expression_states;
 
-
 @  We want to make sure that each term and (intermediate) result is in
   the proper range.  Integer values must not exceed |infinity|
   ($2^{31}-1$) in absolute value, dimensions must not exceed |max_dimen|
@@ -2202,12 +2199,6 @@
 numerator for a combined multiplication and division, if any.
 
 @c
-#define expr_type(A) type((A)+1)
-#define expr_state(A) subtype((A)+1)
-#define expr_e_field(A) vlink((A)+1)    /* saved expression so far */
-#define expr_t_field(A) vlink((A)+2)    /* saved term so far */
-#define expr_n_field(A) vinfo((A)+2)    /* saved numerator */
-
 #define expr_add_sub(A,B,C) add_or_sub((A),(B),(C),(r==expr_sub))
 #define expr_a(A,B) expr_add_sub((A),(B),max_dimen)
 
@@ -2493,7 +2484,7 @@
          */
         t = f;
         if ((l >= glue_val_level) && (o != expr_none)) {
-	        /* do we really need to copy here ? */ 
+	        /* do we really need to copy here ? */
             t = new_spec(f);
             flush_node(f);
             normalize_glue(t);
--- texlive-bin.orig/texk/web2c/luatexdir/tex/texfileio.w
+++ texlive-bin/texk/web2c/luatexdir/tex/texfileio.w
@@ -25,10 +25,6 @@
 #include <string.h>
 #include <kpathsea/absolute.h>
 
-@ @c
-#define end_line_char int_par(end_line_char_code)
-
-
 @ The bane of portability is the fact that different operating systems treat
 input and output quite differently, perhaps because computer scientists
 have not given sufficient attention to this problem. People have felt somehow
@@ -111,13 +107,21 @@
 @ find an \.{\\input} or \.{\\read} file. |n| differentiates between those case.
 
 @c
+int kpse_available(const char *m) {
+    if (!kpse_init) {
+          fprintf(stdout,"missing kpse replacement callback '%s', quitting\n",m);
+          exit(1);
+    }
+    return 1 ;
+}
+
 char *luatex_find_read_file(const char *s, int n, int callback_index)
 {
     char *ftemp = NULL;
     int callback_id = callback_defined(callback_index);
     if (callback_id > 0) {
-        (void) run_callback(callback_id, "dS->S", n, s, &ftemp);
-    } else {
+        (void) run_callback(callback_id, "dS->R", n, s, &ftemp);
+    } else if (kpse_available("find_read_file")) {
         /* use kpathsea here */
         ftemp = find_in_output_directory(s);
         if (!ftemp)
@@ -140,7 +144,7 @@
     if (callback_id > 0) {
         (void) run_callback(callback_id, "S->R", s, &ftemp);
 
-    } else {
+    } else if (kpse_available("find_read_file")) {
         /* use kpathsea here */
         switch (callback_index) {
         case find_enc_file_callback:
@@ -166,12 +170,12 @@
         case find_data_file_callback:
             ftemp = find_in_output_directory(s);
             if (!ftemp)
-                ftemp = kpse_find_file(s, kpse_tex_format, 0);
+                ftemp = kpse_find_file(s, kpse_tex_format, 1);
             break;
         case find_font_file_callback:
-            ftemp = kpse_find_file(s, kpse_ofm_format, 0);
+            ftemp = kpse_find_file(s, kpse_ofm_format, 1);
             if (ftemp == NULL)
-                ftemp = kpse_find_file(s, kpse_tfm_format, 0);
+                ftemp = kpse_find_file(s, kpse_tfm_format, 1);
             break;
         case find_vf_file_callback:
             ftemp = kpse_find_file(s, kpse_ovf_format, 0);
@@ -844,7 +848,7 @@
         input_stack[input_ptr] = cur_input;     /* make sure bottom level is in memory */
         tprint_nl("**");
         l = input_stack[0].limit_field; /* last position of first line */
-        if (buffer[l] == end_line_char)
+        if (buffer[l] == end_line_char_par)
             decr(l);            /* TODO: multichar endlinechar */
         for (k = 1; k <= l; k++)
             print_char(buffer[k]);
@@ -978,7 +982,7 @@
     if (end_line_char_inactive)
         decr(ilimit);
     else
-        buffer[ilimit] = (packed_ASCII_code) end_line_char;
+        buffer[ilimit] = (packed_ASCII_code) end_line_char_par;
     first = ilimit + 1;
     iloc = istart;
 }
@@ -1137,7 +1141,7 @@
     char *fnam;
     callbackid = callback_defined(find_format_file_callback);
     if (callbackid > 0) {
-        res = run_callback(callbackid, "S->S", fname, &fnam);
+        res = run_callback(callbackid, "S->R", fname, &fnam);
         if (res && fnam && strlen(fnam) > 0) {
             *f = fopen(fnam, fopen_mode);
             if (*f == NULL) {
--- texlive-bin.orig/texk/web2c/luatexdir/tex/texmath.h
+++ texlive-bin/texk/web2c/luatexdir/tex/texmath.h
@@ -109,8 +109,6 @@
 #  define script_size 1
 #  define script_script_size 2
 
-#  define math_direction int_par(math_direction_code)
-
 #  define dir_math_save cur_list.math_field
 #  define m_style cur_list.math_style_field
 #  define init_math_fields() do {               \
@@ -157,6 +155,8 @@
     math_param_limit_below_vgap,
     math_param_limit_below_bgap,
     math_param_limit_below_kern,
+    math_param_nolimit_sub_factor, /* bonus */
+    math_param_nolimit_sup_factor, /* bonus */
     math_param_under_delimiter_vgap,
     math_param_under_delimiter_bgap,
     math_param_over_delimiter_vgap,
@@ -309,6 +309,8 @@
     SubscriptShiftDownWithSuperscript,
     FractionDelimiterSize,
     FractionDelimiterDisplayStyleSize,
+    NoLimitSubFactor,
+    NoLimitSupFactor,
     MATH_param_last,
 } MATH_param_codes;
 
--- texlive-bin.orig/texk/web2c/luatexdir/tex/texmath.w
+++ texlive-bin/texk/web2c/luatexdir/tex/texmath.w
@@ -18,21 +18,13 @@
 % with LuaTeX; if not, see <http://www.gnu.org/licenses/>.
 
 @ @c
-
-// define DEBUG
 #include "ptexlib.h"
 
 @ @c
-#define mode          cur_list.mode_field
-#define head          cur_list.head_field
-#define tail          cur_list.tail_field
-#define prev_graf     cur_list.pg_field
-#define eTeX_aux      cur_list.eTeX_aux_field
-#define delim_ptr     eTeX_aux
-#define space_factor  cur_list.space_factor_field
-#define incompleat_noad cur_list.incompleat_noad_field
-
-#define cur_fam int_par(cur_fam_code)
+#define mode     mode_par
+#define tail     tail_par
+#define head     head_par
+#define dir_save dirs_par
 
 /*
 
@@ -47,12 +39,6 @@
 
 */
 
-#define display_skip_mode int_par(math_display_skip_mode_code)
-
-#define math_skip glue_par(math_skip_code)
-
-#define var_code 7
-
 @ TODO: not sure if this is the right order
 @c
 #define back_error(A,B) do {                    \
@@ -67,19 +53,6 @@
 int scan_math_style(pointer, int);
 pointer fin_mlist(pointer);
 
-#define pre_display_size dimen_par(pre_display_size_code)
-#define hsize            dimen_par(hsize_code)
-#define display_width    dimen_par(display_width_code)
-#define display_indent   dimen_par(display_indent_code)
-#define math_surround    dimen_par(math_surround_code)
-#define hang_indent      dimen_par(hang_indent_code)
-#define hang_after       int_par(hang_after_code)
-#define every_math       equiv(every_math_loc)
-#define every_display    equiv(every_display_loc)
-#define par_shape_ptr    equiv(par_shape_loc)
-
-#define math_eqno_gap_step int_par(math_eqno_gap_step_code)
-
 @ When \TeX\ reads a formula that is enclosed between \.\$'s, it constructs an
 {\sl mlist}, which is essentially a tree structure representing that
 formula.  An mlist is a linear sequence of items, but we can regard it as
@@ -175,10 +148,10 @@
 void flush_math(void)
 {
     flush_node_list(vlink(head));
-    flush_node_list(incompleat_noad);
+    flush_node_list(incompleat_noad_par);
     vlink(head) = null;
     tail = head;
-    incompleat_noad = null;
+    incompleat_noad_par = null;
 }
 
 @ Before we can do anything in math mode, we need fonts.
@@ -203,7 +176,7 @@
     sa_value.int_value = f;
     set_sa_item(math_fam_head, n, sa_value, lvl);
     fixup_math_parameters(fam_id, size_id, f, lvl);
-    if (int_par(tracing_assigns_code) > 1) {
+    if (tracing_assigns_par > 1) {
         begin_diagnostic();
         tprint("{assigning");
         print_char(' ');
@@ -229,7 +202,7 @@
         if (st.level > 0) {
             rawset_sa_item(math_fam_head, st.code, st.value);
             /* now do a trace message, if requested */
-            if (int_par(tracing_restores_code) > 1) {
+            if (tracing_restores_par > 1) {
                 int size_id = st.code / 256;
                 int fam_id = st.code % 256;
                 begin_diagnostic();
@@ -262,7 +235,7 @@
     sa_tree_item sa_value = { 0 };
     sa_value.int_value = (int) value;
     set_sa_item(math_param_head, n, sa_value, lvl);
-    if (int_par(tracing_assigns_code) > 1) {
+    if (tracing_assigns_par > 1) {
         begin_diagnostic();
         tprint("{assigning");
         print_char(' ');
@@ -294,7 +267,7 @@
         if (st.level > 0) {
             rawset_sa_item(math_param_head, st.code, st.value);
             /* now do a trace message, if requested */
-            if (int_par(tracing_restores_code) > 1) {
+            if (tracing_restores_par > 1) {
                 int param_id = st.code % 256;
                 int style_id = st.code / 256;
                 begin_diagnostic();
@@ -479,6 +452,7 @@
     "fractiondenomvgap", "fractiondenomdown", "fractiondelsize",
     "limitabovevgap", "limitabovebgap", "limitabovekern",
     "limitbelowvgap", "limitbelowbgap", "limitbelowkern",
+    "nolimitsubfactor", "nolimitsupfactor", /* bonus */
     "underdelimitervgap", "underdelimiterbgap",
     "overdelimitervgap", "overdelimiterbgap",
     "subshiftdrop", "supshiftdrop", "subshiftdown",
@@ -889,22 +863,22 @@
 static void new_save_level_math(group_code c)
 {
     set_saved_record(0, saved_textdir, 0, text_dir_ptr);
-    text_dir_ptr = new_dir(math_direction);
+    text_dir_ptr = new_dir(math_direction_par);
     incr(save_ptr);
     new_save_level(c);
-    eq_word_define(int_base + body_direction_code, math_direction);
-    eq_word_define(int_base + par_direction_code, math_direction);
-    eq_word_define(int_base + text_direction_code, math_direction);
+    eq_word_define(int_base + body_direction_code, math_direction_par);
+    eq_word_define(int_base + par_direction_code, math_direction_par);
+    eq_word_define(int_base + text_direction_code, math_direction_par);
 }
 
 @ @c
 static void push_math(group_code c, int mstyle)
 {
-    if (math_direction != text_direction)
+    if (math_direction_par != text_direction_par)
         dir_math_save = true;
     push_nest();
     mode = -mmode;
-    incompleat_noad = null;
+    incompleat_noad_par = null;
     m_style = mstyle;
     new_save_level_math(c);
 }
@@ -914,8 +888,8 @@
 {
     push_math(math_shift_group, text_style);
     eq_word_define(int_base + cur_fam_code, -1);
-    if (every_math != null)
-        begin_token_list(every_math, every_math_text);
+    if (every_math_par != null)
+        begin_token_list(every_math_par, every_math_text);
 }
 
 @ @c
@@ -1007,7 +981,7 @@
     while (i < save_ptr) {
         if (save_type(i) == restore_old_value &&
             save_value(i) == int_base + par_direction_code) {
-            if (textdir_opposite(math_direction, save_value(i - 1)))
+            if (textdir_opposite(math_direction_par, save_value(i - 1)))
                 return true;
         }
         i++;
@@ -1046,27 +1020,27 @@
     /* now we are in vertical mode, working on the list that will contain the display */
     /* A displayed equation is considered to be three lines long, so we
        calculate the length and offset of line number |prev_graf+2|. */
-    if (par_shape_ptr == null) {
-        if ((hang_indent != 0) &&
-            (((hang_after >= 0) && (prev_graf + 2 > hang_after)) ||
-             (prev_graf + 1 < -hang_after))) {
-            l = hsize - abs(hang_indent);
-            if (hang_indent > 0)
-                s = hang_indent;
+    if (par_shape_par_ptr == null) {
+        if ((hang_indent_par != 0) && (((hang_after_par >= 0) && (prev_graf_par + 2 > hang_after_par)) || (prev_graf_par + 1 < -hang_after_par))) {
+            halfword used_hang_indent = swap_hang_indent(hang_indent_par);
+            l = hsize_par - abs(used_hang_indent);
+            if (used_hang_indent > 0)
+                s = used_hang_indent;
             else
                 s = 0;
         } else {
-            l = hsize;
+            l = hsize_par;
             s = 0;
         }
     } else {
-        n = vinfo(par_shape_ptr + 1);
-        if (prev_graf + 2 >= n)
-            p = par_shape_ptr + 2 * n + 1;
+        n = vinfo(par_shape_par_ptr + 1);
+        if (prev_graf_par + 2 >= n)
+            p = par_shape_par_ptr + 2 * n + 1;
         else
-            p = par_shape_ptr + 2 * (prev_graf + 2) + 1;
+            p = par_shape_par_ptr + 2 * (prev_graf_par + 2) + 1;
         s = varmem[(p - 1)].cint;
         l = varmem[p].cint;
+        s = swap_parshape_indent(s,l);
     }
 
     push_math(math_shift_group, display_style);
@@ -1076,8 +1050,8 @@
     eq_word_define(dimen_base + display_width_code, l);
     eq_word_define(dimen_base + display_indent_code, s);
     eq_word_define(int_base + pre_display_direction_code, (math_and_text_reversed_p() ? -1 : 0));
-    if (every_display != null)
-        begin_token_list(every_display, every_display_text);
+    if (every_display_par != null)
+        begin_token_list(every_display_par, every_display_text);
     if (nest_ptr == 1) {
         checked_page_filter(before_display);
         build_page();
@@ -1090,8 +1064,6 @@
  (the class is passed on for conversion to \.{\\mathchar}).
 
 @c
-#define fam_in_range ((cur_fam>=0)&&(cur_fam<256))
-
 static delcodeval do_scan_extdef_del_code(int extcode, boolean doclass)
 {
     const char *hlp[] = {
@@ -1368,8 +1340,8 @@
     }
     type(p) = math_char_node;
     math_character(p) = mval.character_value;
-    if ((mval.class_value == var_code) && fam_in_range)
-        math_fam(p) = cur_fam;
+    if ((mval.class_value == math_use_current_family_code) && cur_fam_par_in_range)
+        math_fam(p) = cur_fam_par;
     else
         math_fam(p) = mval.family_value;
     return 0;
@@ -1398,9 +1370,9 @@
         nucleus(p) = q;
         math_character(nucleus(p)) = mval.character_value;
         math_fam(nucleus(p)) = mval.family_value;
-        if (mval.class_value == var_code) {
-            if (fam_in_range)
-                math_fam(nucleus(p)) = cur_fam;
+        if (mval.class_value == math_use_current_family_code) {
+            if (cur_fam_par_in_range)
+                math_fam(nucleus(p)) = cur_fam_par;
             subtype(p) = ord_noad_type;
         } else {
             switch (mval.class_value) {
@@ -1668,8 +1640,8 @@
         q = new_node(math_char_node, 0);
         top_accent_chr(tail) = q;
         math_character(top_accent_chr(tail)) = t.character_value;
-        if ((t.class_value == var_code) && fam_in_range)
-            math_fam(top_accent_chr(tail)) = cur_fam;
+        if ((t.class_value == math_use_current_family_code) && cur_fam_par_in_range)
+            math_fam(top_accent_chr(tail)) = cur_fam_par;
         else
             math_fam(top_accent_chr(tail)) = t.family_value;
     }
@@ -1677,8 +1649,8 @@
         q = new_node(math_char_node, 0);
         bot_accent_chr(tail) = q;
         math_character(bot_accent_chr(tail)) = b.character_value;
-        if ((b.class_value == var_code) && fam_in_range)
-            math_fam(bot_accent_chr(tail)) = cur_fam;
+        if ((b.class_value == math_use_current_family_code) && cur_fam_par_in_range)
+            math_fam(bot_accent_chr(tail)) = cur_fam_par;
         else
             math_fam(bot_accent_chr(tail)) = b.family_value;
     }
@@ -1686,8 +1658,8 @@
         q = new_node(math_char_node, 0);
         overlay_accent_chr(tail) = q;
         math_character(overlay_accent_chr(tail)) = o.character_value;
-        if ((o.class_value == var_code) && fam_in_range)
-            math_fam(overlay_accent_chr(tail)) = cur_fam;
+        if ((o.class_value == math_use_current_family_code) && cur_fam_par_in_range)
+            math_fam(overlay_accent_chr(tail)) = cur_fam_par;
         else
             math_fam(overlay_accent_chr(tail)) = o.family_value;
     }
@@ -1807,7 +1779,7 @@
     pointer q;
     halfword options = 0;
     c = cur_chr;
-    if (incompleat_noad != null) {
+    if (incompleat_noad_par != null) {
         const char *hlp[] = {
             "I'm ignoring this fraction specification, since I don't",
             "know whether a construction like `x \\over y \\over z'",
@@ -1822,25 +1794,25 @@
             scan_normal_dimen();
         tex_error("Ambiguous; you need another { and }", hlp);
     } else {
-        incompleat_noad = new_node(fraction_noad, 0);
-        numerator(incompleat_noad) = new_node(sub_mlist_node, 0);
-        math_list(numerator(incompleat_noad)) = vlink(head);
+        incompleat_noad_par = new_node(fraction_noad, 0);
+        numerator(incompleat_noad_par) = new_node(sub_mlist_node, 0);
+        math_list(numerator(incompleat_noad_par)) = vlink(head);
         vlink(head) = null;
         tail = head;
         m_style = cramped_style(m_style);
 
         if ((c % delimited_code) == skewed_code) {
             q = new_node(delim_node, 0);
-            middle_delimiter(incompleat_noad) = q;
-            scan_delimiter(middle_delimiter(incompleat_noad), no_mathcode);
+            middle_delimiter(incompleat_noad_par) = q;
+            scan_delimiter(middle_delimiter(incompleat_noad_par), no_mathcode);
         }
         if (c >= delimited_code) {
             q = new_node(delim_node, 0);
-            left_delimiter(incompleat_noad) = q;
+            left_delimiter(incompleat_noad_par) = q;
             q = new_node(delim_node, 0);
-            right_delimiter(incompleat_noad) = q;
-            scan_delimiter(left_delimiter(incompleat_noad), no_mathcode);
-            scan_delimiter(right_delimiter(incompleat_noad), no_mathcode);
+            right_delimiter(incompleat_noad_par) = q;
+            scan_delimiter(left_delimiter(incompleat_noad_par), no_mathcode);
+            scan_delimiter(right_delimiter(incompleat_noad_par), no_mathcode);
         }
         switch (c % delimited_code) {
             case above_code:
@@ -1851,15 +1823,15 @@
                         break;
                     }
                 }
-                fractionoptions(incompleat_noad) = options;
+                fractionoptions(incompleat_noad_par) = options;
                 scan_normal_dimen();
-                thickness(incompleat_noad) = cur_val;
+                thickness(incompleat_noad_par) = cur_val;
                 break;
             case over_code:
-                thickness(incompleat_noad) = default_code;
+                thickness(incompleat_noad_par) = default_code;
                 break;
             case atop_code:
-                thickness(incompleat_noad) = 0;
+                thickness(incompleat_noad_par) = 0;
                 break;
             case skewed_code:
                 while (1) {
@@ -1871,8 +1843,8 @@
                         break;
                     }
                 }
-                fractionoptions(incompleat_noad) = options;
-                thickness(incompleat_noad) = 0;
+                fractionoptions(incompleat_noad_par) = options;
+                thickness(incompleat_noad_par) = 0;
                 break;
         }
     }
@@ -1888,24 +1860,24 @@
 pointer fin_mlist(pointer p)
 {
     pointer q;                  /* the mlist to return */
-    if (incompleat_noad != null) {
-        if (denominator(incompleat_noad) != null) {
-            type(denominator(incompleat_noad)) = sub_mlist_node;
+    if (incompleat_noad_par != null) {
+        if (denominator(incompleat_noad_par) != null) {
+            type(denominator(incompleat_noad_par)) = sub_mlist_node;
         } else {
             q = new_node(sub_mlist_node, 0);
-            denominator(incompleat_noad) = q;
+            denominator(incompleat_noad_par) = q;
         }
-        math_list(denominator(incompleat_noad)) = vlink(head);
+        math_list(denominator(incompleat_noad_par)) = vlink(head);
         if (p == null) {
-            q = incompleat_noad;
+            q = incompleat_noad_par;
         } else {
-            q = math_list(numerator(incompleat_noad));
+            q = math_list(numerator(incompleat_noad_par));
             if ((type(q) != fence_noad) || (subtype(q) != left_noad_side)
-                || (delim_ptr == null))
+                || (delim_par == null))
                 confusion("right");     /* this can't happen */
-            math_list(numerator(incompleat_noad)) = vlink(delim_ptr);
-            vlink(delim_ptr) = incompleat_noad;
-            vlink(incompleat_noad) = p;
+            math_list(numerator(incompleat_noad_par)) = vlink(delim_par);
+            vlink(delim_par) = incompleat_noad_par;
+            vlink(incompleat_noad_par) = p;
         }
     } else {
         vlink(tail) = p;
@@ -2077,7 +2049,7 @@
             push_math(math_left_group, m_style);
             vlink(head) = q;
             tail = p;
-            delim_ptr = p;
+            delim_par = p;
         } else {
             tail_append(new_noad());
             subtype(tail) = inner_noad_type;
@@ -2133,10 +2105,10 @@
     if (cur_group != math_shift_group)
         confusion("display");
     unsave_math();
-    prev_graf = prev_graf + 3;
+    prev_graf_par = prev_graf_par + 3;
     push_nest();
     mode = hmode;
-    space_factor = 1000;
+    space_factor_par = 1000;
     /* this needs to be intercepted in the display math start ! */
     tail_append(make_local_par_node(penalty_par_code));
     get_x_token();
@@ -2158,6 +2130,39 @@
   |l| is true if there was an \.{\\leqno}/ (so |a| is a horizontal box).
 
 @c
+#define inject_display_skip_before(g) \
+    switch (display_skip_mode_par) { \
+        case 0 : /* normal tex */ \
+            tail_append(new_param_glue(g)); \
+            break;\
+        case 1 : /* always */ \
+            tail_append(new_param_glue(g)); \
+            break; \
+        case 2 : /* non-zero */ \
+            if (g != 0 && ! glue_is_zero(glue_par(g))) \
+                tail_append(new_param_glue(g)); \
+            break; \
+        case 3: /* ignore */ \
+            break; \
+    }
+
+#define inject_display_skip_after(g) \
+    switch (display_skip_mode_par) { \
+        case 0 : /* normal tex */ \
+            if (g != 0 && glue_is_positive(glue_par(g))) \
+                tail_append(new_param_glue(g)); \
+            break; \
+        case 1 : /* always */ \
+            tail_append(new_param_glue(g)); \
+            break; \
+        case 2 : /* non-zero */ \
+            if (g != 0 && ! glue_is_zero(glue_par(g))) \
+                tail_append(new_param_glue(g)); \
+            break; \
+        case 3: /* ignore */ \
+            break; \
+    }
+
 static void finish_displayed_math(boolean l, pointer eqno_box, pointer p)
 {
     pointer eq_box;             /* box containing the equation */
@@ -2173,7 +2178,7 @@
     pointer pre_t;              /* tail of pre-adjustment list */
     boolean swap_dir;           /* true if the math and surrounding text dirs are opposed */
     scaled eqno_width;
-    swap_dir = (int_par(pre_display_direction_code) < 0 ? true : false );
+    swap_dir = (pre_display_direction_par < 0 ? true : false );
     if (eqno_box != null && swap_dir)
         l = !l;
     adjust_tail = adjust_head;
@@ -2187,8 +2192,8 @@
     pre_t = pre_adjust_tail;
     pre_adjust_tail = null;
     eq_w = width(eq_box);
-    line_w = display_width;
-    line_s = display_indent;
+    line_w = display_width_par;
+    line_s = display_indent_par;
     if (eqno_box == null) {
         eqno_w = 0;
         eqno_width = 0;
@@ -2196,7 +2201,7 @@
     } else {
         eqno_w = width(eqno_box);
         eqno_width = eqno_w;
-        eqno_w2 = eqno_w + round_xn_over_d(math_eqno_gap_step, get_math_quad_style(text_style), 1000);
+        eqno_w2 = eqno_w + round_xn_over_d(math_eqno_gap_step_par, get_math_quad_style(text_style), 1000);
         subtype(eqno_box) = equation_number_list; /* new */
      /* build_attribute_list(eqno_box); */ /* probably already set */
    }
@@ -2242,8 +2247,8 @@
                     d = 0;
     }
 
-    tail_append(new_penalty(int_par(pre_display_penalty_code)));
-    if ((d + line_s <= pre_display_size) || l) {        /* not enough clearance */
+    tail_append(new_penalty(pre_display_penalty_par));
+    if ((d + line_s <= pre_display_size_par) || l) {        /* not enough clearance */
         g1 = above_display_skip_code;
         g2 = below_display_skip_code;
     } else {
@@ -2261,35 +2266,22 @@
      /* it follows that |type(a)=hlist_node| */
 
     if (eqno_box && l && (eqno_w == 0)) {
-     /* if (math_direction==dir_TLT) { */
+     /* if (math_direction_par==dir_TLT) { */
             shift_amount(eqno_box) = 0;
      /* } else {                       */
      /* }                              */
         append_to_vlist(eqno_box,lua_key_index(equation_number));
         tail_append(new_penalty(inf_penalty));
     } else {
-        switch (display_skip_mode) {
-            case 0 : /* normal tex */
-                tail_append(new_param_glue(g1));
-                break;
-            case 1 : /* always */
-                tail_append(new_param_glue(g1));
-                break;
-            case 2 : /* non-zero */
-                if (g1 != 0)
-                    tail_append(new_param_glue(g1));
-                break;
-            case 3: /* ignore */
-                break;
-        }
+        inject_display_skip_before(g1);
     }
 
     if (eqno_w != 0) {
         r = new_kern(line_w - eq_w - eqno_w - d);
         if (l) {
             if (swap_dir) {
-                if (math_direction==dir_TLT) {
-                    /* TRT + TLT + \eqno,    (swap_dir=true,  math_direction=TLT, l=true)  */
+                if (math_direction_par==dir_TLT) {
+                    /* TRT + TLT + \eqno,    (swap_dir=true,  math_direction_par=TLT, l=true)  */
 #ifdef DEBUG
         fprintf(stderr, "\nDEBUG: CASE 1\n");
 #endif
@@ -2298,7 +2290,7 @@
                     try_couple_nodes(r,eq_box);
                     try_couple_nodes(eq_box,s);
                 } else {
-                    /* TLT + TRT + \eqno,    (swap_dir=true,  math_direction=TRT, l=true) */
+                    /* TLT + TRT + \eqno,    (swap_dir=true,  math_direction_par=TRT, l=true) */
 #ifdef DEBUG
         fprintf(stderr, "\nDEBUG: CASE 2\n");
 #endif
@@ -2306,14 +2298,14 @@
                     try_couple_nodes(r,eq_box);
                 }
             } else {
-                if (math_direction==dir_TLT) {
-                    /* TLT + TLT + \leqno,   (swap_dir=false, math_direction=TLT, l=true) */ /* OK */
+                if (math_direction_par==dir_TLT) {
+                    /* TLT + TLT + \leqno,   (swap_dir=false, math_direction_par=TLT, l=true) */ /* OK */
 #ifdef DEBUG
         fprintf(stderr, "\nDEBUG: CASE 3\n");
 #endif
                     s = new_kern(width(r) + eqno_w);
                 } else {
-                    /* TRT + TRT + \leqno,    (swap_dir=false, math_direction=TRT, l=true) */
+                    /* TRT + TRT + \leqno,    (swap_dir=false, math_direction_par=TRT, l=true) */
 #ifdef DEBUG
         fprintf(stderr, "\nDEBUG: CASE 4\n");
 #endif
@@ -2326,13 +2318,13 @@
             eq_box = eqno_box;
         } else {
             if (swap_dir) {
-                if (math_direction==dir_TLT) {
-                    /* TRT + TLT + \leqno,   (swap_dir=true,  math_direction=TLT, l=false) */
+                if (math_direction_par==dir_TLT) {
+                    /* TRT + TLT + \leqno,   (swap_dir=true,  math_direction_par=TLT, l=false) */
 #ifdef DEBUG
         fprintf(stderr, "\nDEBUG: CASE 5\n");
 #endif
                 } else {
-                    /* TLT + TRT + \leqno,   (swap_dir=true,  math_direction=TRT, l=false) */
+                    /* TLT + TRT + \leqno,   (swap_dir=true,  math_direction_par=TRT, l=false) */
 #ifdef DEBUG
         fprintf(stderr, "\nDEBUG: CASE 6\n");
 #endif
@@ -2340,14 +2332,14 @@
                 try_couple_nodes(eq_box,r);
                 try_couple_nodes(r,eqno_box);
             } else {
-                if (math_direction==dir_TLT) {
-                    /*  TLT + TLT + \eqno,    (swap_dir=false, math_direction=TLT, l=false) */ /* OK */
+                if (math_direction_par==dir_TLT) {
+                    /*  TLT + TLT + \eqno,    (swap_dir=false, math_direction_par=TLT, l=false) */ /* OK */
 #ifdef DEBUG
         fprintf(stderr, "\nDEBUG: CASE 7\n");
 #endif
                     s = new_kern(d);
                 } else {
-                    /* TRT + TRT + \eqno,   (swap_dir=false, math_direction=TRT, l=false) */
+                    /* TRT + TRT + \eqno,   (swap_dir=false, math_direction_par=TRT, l=false) */
 #ifdef DEBUG
         fprintf(stderr, "\nDEBUG: CASE 8\n");
 #endif
@@ -2371,7 +2363,7 @@
 
     if ((eqno_box != null) && (eqno_w == 0) && !l) {
         tail_append(new_penalty(inf_penalty));
-     /* if (math_direction==dir_TLT) { */
+     /* if (math_direction_par==dir_TLT) { */
             shift_amount(eqno_box) = line_s + line_w - eqno_width ;
      /* } else {                       */
      /* }                              */
@@ -2390,24 +2382,8 @@
         alink(pre_adjust_tail) = alink(tail);
         tail = pre_t;
     }
-    tail_append(new_penalty(int_par(post_display_penalty_code)));
-
-    switch (display_skip_mode) {
-        case 0 : /* normal tex */
-            if (g2 > 0)
-                tail_append(new_param_glue(g2));
-            break;
-        case 1 : /* always */
-            tail_append(new_param_glue(g2));
-            break;
-        case 2 : /* non-zero */
-            if (g2 != 0)
-                tail_append(new_param_glue(g2));
-            break;
-        case 3: /* ignore */
-            break;
-    }
-
+    tail_append(new_penalty(post_display_penalty_par));
+    inject_display_skip_after(g2);
     resume_after_display();
 }
 
@@ -2452,15 +2428,15 @@
         if (cur_cmd == math_shift_cs_cmd) {
             check_inline_math_end();
         }
-        tail_append(new_math(math_surround, before));
+        tail_append(new_math(math_surround_par, before));
         /* begin mathskip code */
-        if (! glue_is_zero(math_skip)) {
-            copy_glue_values(tail,math_skip);
+        if (! glue_is_zero(math_skip_par)) {
+            copy_glue_values(tail,math_skip_par);
             surround(tail) = 0;
         }
         /* end mathskip code */
         if (dir_math_save) {
-            tail_append(new_dir(math_direction));
+            tail_append(new_dir(math_direction_par));
         }
         run_mlist_to_hlist(p, (mode > 0), text_style);
         vlink(tail) = vlink(temp_head);
@@ -2468,17 +2444,17 @@
             tail = vlink(tail);
         }
         if (dir_math_save) {
-            tail_append(new_dir(math_direction - dir_swap));
+            tail_append(new_dir(math_direction_par - dir_swap));
         }
         dir_math_save = false;
-        tail_append(new_math(math_surround, after));
+        tail_append(new_math(math_surround_par, after));
         /* begin mathskip code */
-        if (! glue_is_zero(math_skip)) {
-            copy_glue_values(tail,math_skip);
+        if (! glue_is_zero(math_skip_par)) {
+            copy_glue_values(tail,math_skip_par);
             surround(tail) = 0;
         }
         /* end mathskip code */
-        space_factor = 1000;
+        space_factor_par = 1000;
         unsave_math();
     } else {
         if (a == null) {
@@ -2508,13 +2484,13 @@
         check_display_math_end();
     }
     pop_nest();
-    tail_append(new_penalty(int_par(pre_display_penalty_code)));
-    tail_append(new_param_glue(above_display_skip_code));
+    tail_append(new_penalty(pre_display_penalty_par));
+    inject_display_skip_before(above_display_skip_code);
     vlink(tail) = p;
     if (p != null)
         tail = q;
-    tail_append(new_penalty(int_par(post_display_penalty_code)));
-    tail_append(new_param_glue(below_display_skip_code));
+    tail_append(new_penalty(post_display_penalty_par));
+    inject_display_skip_after(below_display_skip_code);
     cur_list.prev_depth_field = saved_prevdepth;
     resume_after_display();
 }
--- texlive-bin.orig/texk/web2c/luatexdir/tex/texnodes.h
+++ texlive-bin/texk/web2c/luatexdir/tex/texnodes.h
@@ -148,30 +148,33 @@
 #  define synctex_line_glue(a) vlink((a)+6)
 
 #define glue_is_zero(p) \
-	((p == null) || (width(p) == 0 && stretch(p) == 0 && shrink(p) == 0))
+    ((p == null) || (width(p) == 0 && stretch(p) == 0 && shrink(p) == 0))
+
+#define glue_is_positive(p) \
+    ((p == null) || (width(p) > 0))
 
 #define reset_glue_to_zero(p) \
-	if (p != null) { \
-	    width(p) = 0; \
-	    stretch(p) = 0; \
-	    shrink(p) = 0; \
-	    stretch_order(p) = 0; \
-	    shrink_order(p) = 0; \
-	}
+    if (p != null) { \
+        width(p) = 0; \
+        stretch(p) = 0; \
+        shrink(p) = 0; \
+        stretch_order(p) = 0; \
+        shrink_order(p) = 0; \
+    }
 
 #define copy_glue_values(p,q) \
-	if (q == null) { \
-	    width(p) = 0; \
-	    stretch(p) = 0; \
-	    shrink(p) = 0; \
-	    stretch_order(p) = 0; \
-	    shrink_order(p) = 0; \
-	} else { \
-	    width(p) = width(q); \
-	    stretch(p) = stretch(q); \
-	    shrink(p) = shrink(q); \
-	    stretch_order(p) = stretch_order(q); \
-	    shrink_order(p) = shrink_order(q); \
+    if (q == null) { \
+        width(p) = 0; \
+        stretch(p) = 0; \
+        shrink(p) = 0; \
+        stretch_order(p) = 0; \
+        shrink_order(p) = 0; \
+    } else { \
+        width(p) = width(q); \
+        stretch(p) = stretch(q); \
+        shrink(p) = shrink(q); \
+        stretch_order(p) = stretch_order(q); \
+        shrink_order(p) = shrink_order(q); \
     }
 
 
@@ -258,6 +261,10 @@
     image_rule,
     empty_rule,
     user_rule,
+    math_over_rule,
+    math_under_rule,
+    math_fraction_rule,
+    math_radical_rule,
 } rule_subtypes;
 
 #  define rule_node_size       8
@@ -267,6 +274,9 @@
 #  define synctex_tag_rule(a)  vinfo((a)+7)
 #  define synctex_line_rule(a) vlink((a)+7)
 
+#  define rule_math_size       rule_index
+#  define rule_math_font       rule_transform
+
 #  define mark_node_size   3
 #  define mark_ptr(a)      vlink((a)+2)
 #  define mark_class(a)    vinfo((a)+2)
@@ -417,11 +427,17 @@
 #  define last_known_node temp_node     /* used by \lastnodetype */
 
 #  define movement_node_size    3
-#  define expr_node_size        3
 #  define if_node_size          2
 #  define align_stack_node_size 6
 #  define nesting_node_size     2
 
+#  define expr_node_size        3
+#  define expr_type(A)          type((A)+1)
+#  define expr_state(A)         subtype((A)+1)  /* enum defined in scanning.w */
+#  define expr_e_field(A)       vlink((A)+1)    /* saved expression so far */
+#  define expr_t_field(A)       vlink((A)+2)    /* saved term so far */
+#  define expr_n_field(A)       vinfo((A)+2)    /* saved numerator */
+
 #  define span_node_size        3
 #  define span_span(a)          vlink((a)+1)
 #  define span_link(a)          vinfo((a)+1)
@@ -707,6 +723,7 @@
     set_origin = 0,
     direct_page,
     direct_always,
+    direct_raw,
     scan_special,
 } ctm_transform_modes;
 
@@ -944,7 +961,10 @@
 #  define var_mem_stat_max (end_point+glyph_node_size-1)
 
 #  define stretching 1
-#  define shrinking 2
+#  define shrinking  2
+
+#  define last_normal_node  shape_node
+#  define last_whatsit_node pdf_restore_node
 
 #  define is_running(A) ((A)==null_flag)        /* tests for a running dimension */
 
@@ -978,11 +998,6 @@
 extern int lua_properties_level ;
 extern int lua_properties_use_metatable ;
 
-#define local_inter_line_penalty int_par(local_inter_line_penalty_code)
-#define local_broken_penalty int_par(local_broken_penalty_code)
-#define local_left_box equiv(local_left_box_base)
-#define local_right_box equiv(local_right_box_base)
-
 extern halfword make_local_par_node(int mode);
 
 #endif
--- texlive-bin.orig/texk/web2c/luatexdir/tex/texnodes.w
+++ texlive-bin/texk/web2c/luatexdir/tex/texnodes.w
@@ -33,16 +33,8 @@
 used but that is neglectable compared to other memory usage.
 
 @c
-#define attribute(A) eqtb[attribute_base+(A)].cint
-
-#define uc_hyph int_par(uc_hyph_code)
-#define cur_lang int_par(cur_lang_code)
-#define left_hyphen_min int_par(left_hyphen_min_code)
-#define right_hyphen_min int_par(right_hyphen_min_code)
-
-#define MAX_CHAIN_SIZE 13 /* why not a bit larger */
-
-#define CHECK_NODE_USAGE 1 /* this triggers checking */
+#define MAX_CHAIN_SIZE   13 /* why not a bit larger */
+#define CHECK_NODE_USAGE  1 /* this triggers checking */
 
 memory_word *volatile varmem = NULL;
 
@@ -61,8 +53,8 @@
 
 halfword slow_get_node(int s);  /* defined below */
 
-#define fake_node 100
-#define fake_node_size 2
+#define fake_node       100
+#define fake_node_size  2
 #define fake_node_name "fake"
 
 #define variable_node_size 2
@@ -144,18 +136,6 @@
     "attr", "nucleus", "sub", "sup", NULL
 };
 
-#define node_fields_ord     node_fields_noad
-#define node_fields_op      node_fields_noad
-#define node_fields_bin     node_fields_noad
-#define node_fields_rel     node_fields_noad
-#define node_fields_open    node_fields_noad
-#define node_fields_close   node_fields_noad
-#define node_fields_punct   node_fields_noad
-#define node_fields_inner   node_fields_noad
-#define node_fields_under   node_fields_noad
-#define node_fields_over    node_fields_noad
-#define node_fields_vcenter node_fields_noad
-
 const char *node_fields_style[] = {
     "attr", "style", NULL
 };
@@ -163,17 +143,17 @@
     "attr", "display", "text", "script", "scriptscript", NULL
 };
 const char *node_fields_radical[] = {
-    "attr", "nucleus", "sub", "sup", "left", "degree", NULL
+    "attr", "nucleus", "sub", "sup", "left", "degree", "width", "options", NULL
 };
 const char *node_fields_fraction[] = {
-    "attr", "width", "num", "denom", "left", "right", NULL
+    "attr", "width", "num", "denom", "left", "right", "middle", "options", NULL
 };
 const char *node_fields_accent[] = {
     "attr", "nucleus", "sub", "sup", "accent", "bot_accent", "top_accent",
-    "overlay_accent", NULL
+    "overlay_accent", "fraction", NULL
 };
 const char *node_fields_fence[] = {
-    "attr", "delim", NULL
+    "attr", "delim", "italic", "height", "depth", "options", "class", NULL
 };
 const char *node_fields_math_char[] = {
     "attr", "fam", "char", NULL
@@ -288,7 +268,7 @@
     "fontkern", "userkern", "accentkern", "italiccorrection", NULL
 };
 const char *node_subtypes_rule[] = {
-    "normal", "box", "image", "empty", "user", NULL
+    "normal", "box", "image", "empty", "user", "over", "under", "fraction", "radical", NULL
 };
 const char *node_subtypes_glyph[] = {
     "character", "glyph", "ligature", "ghost", "left", "right", NULL
@@ -342,7 +322,7 @@
     { unset_node,          box_node_size,         node_fields_unset,                         "unset",          14 },
     { style_node,          style_node_size,       node_fields_style,                         "style",          15 },
     { choice_node,         style_node_size,       node_fields_choice,                        "choice",         15 },
-    { simple_noad,         noad_size,             node_fields_ord,                           "noad",           15 },
+    { simple_noad,         noad_size,             node_fields_noad,                          "noad",           15 },
     { radical_noad,        radical_noad_size,     node_fields_radical,                       "radical",        15 },
     { fraction_noad,       fraction_noad_size,    node_fields_fraction,                      "fraction",       15 },
     { accent_noad,         accent_noad_size,      node_fields_accent,                        "accent",         15 },
@@ -377,8 +357,6 @@
     { -1,                 -1,                     NULL,                                      NULL,             -1 },
 };
 
-#define last_normal_node shape_node
-
 const char *node_subtypes_pdf_destination[] = {
     "xyz", "fit", "fith", "fitv", "fitb", "fitbh", "fitbv", "fitr", NULL
 };
@@ -552,6 +530,8 @@
 
 /* isn't there a faster way to metatable? */
 
+/*
+
 #define lua_properties_copy(target,source) do { \
     if (lua_properties_enabled) { \
         if (lua_properties_level == 0) { \
@@ -590,6 +570,55 @@
     } \
 } while(0)
 
+*/
+
+/*
+    A simple testrun on many pages of dumb text shows 1% gain (of course it depends
+    on how properties are used but some other tests confirm it).
+*/
+
+#define lua_properties_copy(target,source) do { \
+    if (lua_properties_enabled) { \
+        if (lua_properties_level == 0) { \
+            lua_get_metatablelua_l(Luas,node_properties); \
+            lua_rawgeti(Luas,-1,source); \
+            if (lua_type(Luas,-1)==LUA_TTABLE) { \
+                if (lua_properties_use_metatable) { \
+                    lua_newtable(Luas); \
+                    lua_insert(Luas,-2); \
+                    lua_push_string_by_name(Luas,__index); \
+                    lua_insert(Luas,-2); \
+                    lua_rawset(Luas, -3); \
+                    lua_newtable(Luas); \
+                    lua_insert(Luas,-2); \
+                    lua_setmetatable(Luas,-2); \
+                } \
+                lua_rawseti(Luas,-2,target); \
+            } else { \
+                lua_pop(Luas,1); \
+            } \
+            lua_pop(Luas,1); \
+        } else { \
+            lua_rawgeti(Luas,-1,source); \
+            if (lua_type(Luas,-1)==LUA_TTABLE) { \
+                if (lua_properties_use_metatable) { \
+                    lua_newtable(Luas); \
+                    lua_insert(Luas,-2); \
+                    lua_push_string_by_name(Luas,__index); \
+                    lua_insert(Luas,-2); \
+                    lua_rawset(Luas, -3); \
+                    lua_newtable(Luas); \
+                    lua_insert(Luas,-2); \
+                    lua_setmetatable(Luas,-2); \
+                } \
+                lua_rawseti(Luas,-2,target); \
+            } else { \
+                lua_pop(Luas,1); \
+            } \
+        } \
+    } \
+} while(0)
+
 /* Here end the property handlers. */
 
 @ @c
@@ -862,7 +891,7 @@
         default:
             break;
     }
-    if (int_par(synctex_code)) {
+    if (synctex_par) {
         /* handle synctex extension */
         switch (i) {
             case math_node:
@@ -1063,7 +1092,7 @@
 
     (void) memcpy((void *) (varmem + r), (void *) (varmem + p), (sizeof(memory_word) * (unsigned) i));
 
-    if (int_par(synctex_code)) {
+    if (synctex_par) {
         /* handle synctex extension */
         switch (type(p)) {
             case math_node:
@@ -1224,6 +1253,9 @@
                 break;
             case 'd':
                 break;
+            case 'l':
+                free_user_lua(user_node_value(p));
+                break;
             case 'n':
                 flush_node_list(user_node_value(p));
                 break;
@@ -2795,9 +2827,21 @@
 @ Recursive calls on |show_node_list| therefore use the following pattern:
 @c
 #define node_list_display(A) do { \
-    append_char('.');             \
-    show_node_list(A);            \
-    flush_char();                 \
+    append_char('.');  \
+    show_node_list(A); \
+    flush_char();      \
+} while (0)
+
+#define node_list_display_x(A,B) do { \
+    if ((B) != null) {     \
+        append_char('.');  \
+        append_char(A);    \
+        append_char(' ');  \
+        show_node_list(B); \
+        flush_char();      \
+        flush_char();      \
+        flush_char();      \
+    } \
 } while (0)
 
 /* prints a node list symbolically */
@@ -2815,7 +2859,7 @@
     while (p != null) {
         print_ln();
         print_current_string(); /* display the nesting history */
-        if (int_par(tracing_online_code) < -2)
+        if (tracing_online_par < -2)
             print_int(p);
         incr(n);
         if (n > breadth_max) {  /* time to stop */
@@ -3113,17 +3157,26 @@
                 /* Display discretionary |p|; */
                 /* The |post_break| list of a discretionary node is indicated by a prefixed
                    `\.{\char'174}' instead of the `\..' before the |pre_break| list. */
+                /* We're not compatible anyway  so ...
+                    tprint_esc("discretionary");
+                    print_int(disc_penalty(p));
+                    print_char('|');
+                    if (vlink(no_break(p)) != null) {
+                        tprint(" replacing ");
+                        node_list_display(vlink(no_break(p)));
+                    }
+                    node_list_display(vlink(pre_break(p)));
+                    append_char('|');
+                    show_node_list(vlink(post_break(p)));
+                    flush_char();
+                */
                 tprint_esc("discretionary");
+                tprint(" (penalty ");
                 print_int(disc_penalty(p));
-                print_char('|');
-                if (vlink(no_break(p)) != null) {
-                    tprint(" replacing ");
-                    node_list_display(vlink(no_break(p)));
-                }
-                node_list_display(vlink(pre_break(p))); /* recursive call */
-                append_char('|');
-                show_node_list(vlink(post_break(p)));
-                flush_char();   /* recursive call */
+                print_char(')');
+                node_list_display_x('<',vlink(pre_break(p)));
+                node_list_display_x('>',vlink(post_break(p)));
+                node_list_display_x('=',vlink(no_break(p)));
                 break;
             case mark_node:
                 /* Display mark |p|; */
@@ -3296,7 +3349,7 @@
 halfword new_null_box(void)
 {                               /* creates a new box node */
     halfword p = new_node(hlist_node, min_quarterword);
-    box_dir(p) = text_direction;
+    box_dir(p) = text_direction_par;
     return p;
 }
 
@@ -3413,7 +3466,7 @@
     set_to_character(p);
     font(p) = f;
     character(p) = c;
-    lang_data(p) = make_lang_data(uc_hyph, cur_lang, left_hyphen_min, right_hyphen_min);
+    lang_data(p) = make_lang_data(uc_hyph_par, cur_lang_par, left_hyphen_min_par, right_hyphen_min_par);
     return p;
 }
 
@@ -3471,7 +3524,7 @@
 halfword new_disc(void)
 {                               /* creates an empty |disc_node| */
     halfword p = new_node(disc_node, 0);
-    disc_penalty(p) = int_par(hyphen_penalty_code);
+    disc_penalty(p) = hyphen_penalty_par;
     return p;
 }
 
@@ -3694,19 +3747,19 @@
     int callback_id;
     halfword q;
     halfword p = new_node(local_par_node,0);
-    local_pen_inter(p) = local_inter_line_penalty;
-    local_pen_broken(p) = local_broken_penalty;
-    if (local_left_box != null) {
-        q = copy_node_list(local_left_box);
+    local_pen_inter(p) = local_inter_line_penalty_par;
+    local_pen_broken(p) = local_broken_penalty_par;
+    if (local_left_box_par != null) {
+        q = copy_node_list(local_left_box_par);
         local_box_left(p) = q;
-        local_box_left_width(p) = width(local_left_box);
+        local_box_left_width(p) = width(local_left_box_par);
     }
-    if (local_right_box != null) {
-        q = copy_node_list(local_right_box);
+    if (local_right_box_par != null) {
+        q = copy_node_list(local_right_box_par);
         local_box_right(p) = q;
-        local_box_right_width(p) = width(local_right_box);
+        local_box_right_width(p) = width(local_right_box_par);
     }
-    local_par_dir(p) = par_direction;
+    local_par_dir(p) = par_direction_par;
     /* callback with node passed */
     callback_id = callback_defined(insert_local_par_callback);
     if (callback_id > 0) {
--- texlive-bin.orig/texk/web2c/luatexdir/tex/textoken.h
+++ texlive-bin/texk/web2c/luatexdir/tex/textoken.h
@@ -137,8 +137,6 @@
 */
 
 # define no_expand_flag special_char
-# define end_line_char int_par(end_line_char_code)
-# define end_line_char_inactive ((end_line_char < 0) || (end_line_char > 127))
 
 extern halfword par_loc;
 extern halfword par_token;
--- texlive-bin.orig/texk/web2c/luatexdir/tex/textoken.w
+++ texlive-bin/texk/web2c/luatexdir/tex/textoken.w
@@ -22,17 +22,6 @@
 #include "ptexlib.h"
 
 @ @c
-#define pausing int_par(pausing_code)
-#define cat_code_table int_par(cat_code_table_code)
-#define tracing_nesting int_par(tracing_nesting_code)
-#define suppress_outer_error int_par(suppress_outer_error_code)
-#define suppress_mathpar_error int_par(suppress_mathpar_error_code)
-
-
-#define every_eof equiv(every_eof_loc)
-#define box(A) equiv(box_base+(A))
-#define toks(A) equiv(toks_base+(A))
-
 #define detokenized_line() (line_catcode_table==NO_CAT_TABLE)
 
 /*
@@ -42,13 +31,13 @@
     else if (line_catcode_table!=DEFAULT_CAT_TABLE) \
       a=get_cat_code(line_catcode_table,b); \
     else \
-      a=get_cat_code(cat_code_table,b); \
+      a=get_cat_code(cat_code_table_par,b); \
   } while (0)
 */
 
 #define do_get_cat_code(a,b) do { \
     if (line_catcode_table==DEFAULT_CAT_TABLE) \
-      a=get_cat_code(cat_code_table,b); \
+      a=get_cat_code(cat_code_table_par,b); \
     else if (line_catcode_table>-0xFF) \
       a=get_cat_code(line_catcode_table,b); \
     else \
@@ -766,7 +755,7 @@
 {
     int k;                      /* an index into |buffer| */
     ilimit = last;
-    if (pausing > 0) {
+    if (pausing_par > 0) {
         if (interaction > nonstop_mode) {
             wake_up_terminal();
             print_ln();
@@ -795,7 +784,7 @@
 {
     halfword p;                 /* points to inserted token list */
     halfword q;                 /* auxiliary pointer */
-    if (suppress_outer_error)
+    if (suppress_outer_error_par)
         return;
     if (scanner_status != normal) {
         deletions_allowed = false;
@@ -980,7 +969,7 @@
             case skip_blanks + escape_cmd:
                 /* Scan a control sequence ...; */
                 istate = (unsigned char) scan_control_sequence();
-                if (! suppress_outer_error && cur_cmd >= outer_call_cmd)
+                if (! suppress_outer_error_par && cur_cmd >= outer_call_cmd)
                     check_outer_validity();
                 break;
             case mid_line + active_char_cmd:
@@ -991,7 +980,7 @@
                 cur_cmd = eq_type(cur_cs);
                 cur_chr = equiv(cur_cs);
                 istate = mid_line;
-                if (! suppress_outer_error && cur_cmd >= outer_call_cmd)
+                if (! suppress_outer_error_par && cur_cmd >= outer_call_cmd)
                     check_outer_validity();
                 break;
             case mid_line + sup_mark_cmd:
@@ -1041,7 +1030,7 @@
                 cur_cs = par_loc;
                 cur_cmd = eq_type(cur_cs);
                 cur_chr = equiv(cur_cs);
-                if (! suppress_outer_error && cur_cmd >= outer_call_cmd)
+                if (! suppress_outer_error_par && cur_cmd >= outer_call_cmd)
                     check_outer_validity();
                 break;
             case skip_blanks + left_brace_cmd:
@@ -1141,7 +1130,7 @@
             switch (c-new_line) {
                 case escape_cmd:
                     istate = (unsigned char) scan_control_sequence();
-                    if (! suppress_outer_error && cur_cmd >= outer_call_cmd)
+                    if (! suppress_outer_error_par && cur_cmd >= outer_call_cmd)
                         check_outer_validity();
                     return true;
                 case left_brace_cmd:
@@ -1164,7 +1153,7 @@
                     cur_cs = par_loc;
                     cur_cmd = eq_type(cur_cs);
                     cur_chr = equiv(cur_cs);
-                    if (! suppress_outer_error && cur_cmd >= outer_call_cmd)
+                    if (! suppress_outer_error_par && cur_cmd >= outer_call_cmd)
                         check_outer_validity();
                     return true;
                 case mac_param_cmd:
@@ -1196,7 +1185,7 @@
                     cur_cmd = eq_type(cur_cs);
                     cur_chr = equiv(cur_cs);
                     istate = mid_line;
-                    if (! suppress_outer_error && cur_cmd >= outer_call_cmd)
+                    if (! suppress_outer_error_par && cur_cmd >= outer_call_cmd)
                         check_outer_validity();
                     return true;
                 case comment_cmd:
@@ -1214,7 +1203,7 @@
                 case escape_cmd:
                     /* Scan a control sequence ...; */
                     istate = (unsigned char) scan_control_sequence();
-                    if (! suppress_outer_error && cur_cmd >= outer_call_cmd)
+                    if (! suppress_outer_error_par && cur_cmd >= outer_call_cmd)
                         check_outer_validity();
                     return true;
                 case left_brace_cmd:
@@ -1262,7 +1251,7 @@
                     cur_cmd = eq_type(cur_cs);
                     cur_chr = equiv(cur_cs);
                     istate = mid_line;
-                    if (! suppress_outer_error && cur_cmd >= outer_call_cmd)
+                    if (! suppress_outer_error_par && cur_cmd >= outer_call_cmd)
                         check_outer_validity();
                     return true;
                 case comment_cmd:
@@ -1281,7 +1270,7 @@
             switch (c-mid_line) {
                 case escape_cmd:
                     istate = (unsigned char) scan_control_sequence();
-                    if (! suppress_outer_error && cur_cmd >= outer_call_cmd)
+                    if (! suppress_outer_error_par && cur_cmd >= outer_call_cmd)
                         check_outer_validity();
                     return true;
                 case left_brace_cmd:
@@ -1334,7 +1323,7 @@
                     cur_cmd = eq_type(cur_cs);
                     cur_chr = equiv(cur_cs);
                     istate = mid_line;
-                    if (! suppress_outer_error && cur_cmd >= outer_call_cmd)
+                    if (! suppress_outer_error_par && cur_cmd >= outer_call_cmd)
                         check_outer_validity();
                     return true;
                 case comment_cmd:
@@ -1694,11 +1683,11 @@
                     line_catcode_table = DEFAULT_CAT_TABLE;
                     if ((iname == 19) && (pseudo_lines(pseudo_files) == null))
                         inhibit_eol = true;
-                } else if ((every_eof != null) && !eof_seen[iindex]) {
+                } else if ((every_eof_par != null) && !eof_seen[iindex]) {
                     ilimit = first - 1;
                     eof_seen[iindex] = true; /* fake one empty line */
                     if (iname != 19)
-                        begin_token_list(every_eof, every_eof_text);
+                        begin_token_list(every_eof_par, every_eof_text);
                     return next_line_restart;
                 } else {
                     force_eof = true;
@@ -1721,10 +1710,10 @@
                     if (lua_input_ln(cur_file, 0, true)) { /* not end of file */
                         firm_up_the_line(); /* this sets |ilimit| */
                         line_catcode_table = DEFAULT_CAT_TABLE;
-                    } else if ((every_eof != null) && (!eof_seen[iindex])) {
+                    } else if ((every_eof_par != null) && (!eof_seen[iindex])) {
                         ilimit = first - 1;
                         eof_seen[iindex] = true; /* fake one empty line */
-                        begin_token_list(every_eof, every_eof_text);
+                        begin_token_list(every_eof_par, every_eof_text);
                         return next_line_restart;
                     } else {
                         force_eof = true;
@@ -1733,7 +1722,7 @@
             }
         }
         if (force_eof) {
-            if (tracing_nesting > 0)
+            if (tracing_nesting_par > 0)
                 if ((grp_stack[in_open] != cur_boundary) || (if_stack[in_open] != cond_ptr))
                     if (!((iname == 19) || (iname == 21))) {
                         /* give warning for some unfinished groups and/or conditionals */
@@ -1749,7 +1738,7 @@
                 end_file_reading();
             } else {
                 end_file_reading();
-                if (! suppress_outer_error)
+                if (! suppress_outer_error_par)
                     check_outer_validity();
             }
             return next_line_restart;
@@ -1757,7 +1746,7 @@
         if (inhibit_eol || end_line_char_inactive)
             ilimit--;
         else
-            buffer[ilimit] = (packed_ASCII_code) end_line_char;
+            buffer[ilimit] = (packed_ASCII_code) end_line_char_par;
         first = ilimit + 1;
         iloc = istart; /* ready to read */
     } else {
@@ -1788,7 +1777,7 @@
             if (end_line_char_inactive)
                 ilimit--;
             else
-                buffer[ilimit] = (packed_ASCII_code) end_line_char;
+                buffer[ilimit] = (packed_ASCII_code) end_line_char_par;
             first = ilimit + 1;
             iloc = istart;
         } else {
@@ -1829,7 +1818,7 @@
                     cur_chr = no_expand_flag;
                     return true;
                 }
-            } else if (! suppress_outer_error) {
+            } else if (! suppress_outer_error_par) {
                 check_outer_validity();
             }
         }
@@ -2364,7 +2353,7 @@
 
 /* codes not really needed but cleaner when testing */
 
-#define pdftex_version  40  /* these values will not change any more */
+#define pdftex_version  140 /* these values will not change any more */
 #define pdftex_revision "0" /* these values will not change any more */
 
 static int do_feedback_pdf(halfword c)
@@ -2448,6 +2437,8 @@
             cur_val = direct_always;
         else if (scan_keyword("page"))
             cur_val = direct_page;
+        else if (scan_keyword("raw"))
+            cur_val = direct_raw;
         else
             cur_val = set_origin;
         save_scanner_status = scanner_status;
@@ -3154,7 +3145,7 @@
         if (end_line_char_inactive)
             decr(ilimit);
         else
-            buffer[ilimit] = (packed_ASCII_code) int_par(end_line_char_code);
+            buffer[ilimit] = (packed_ASCII_code) end_line_char_par;
         first = ilimit + 1;
         iloc = istart;
         istate = new_line;
@@ -3285,7 +3276,7 @@
     ret = xmalloc(alloci);
     p = token_link(p);          /* skip refcount */
     if (p != null) {
-        e = int_par(escape_char_code);
+        e = escape_char_par;
     }
     while (p != null) {
         if (p < (int) fix_mem_min || p > (int) fix_mem_end) {
