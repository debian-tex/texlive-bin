commit fabd7dde48918eb14a9a3977b6437e70252159b7
Author: Luigi Scarso <luigi.scarso@gmail.com>
Date:   Wed Sep 5 21:32:42 2018 +0000

    pplib for luatex
    
    git-svn-id: svn://tug.org/texlive/trunk@48592 c570f23f-e606-0410-a88d-b1316a301751

---
 texk/web2c/luatexdir/luapplib/Makefile.orig       |   84 
 texk/web2c/luatexdir/luapplib/ppapi.h             |  391 --
 texk/web2c/luatexdir/luapplib/ppapi.h-OK          |  360 --
 texk/web2c/luatexdir/luapplib/pparray.c           |  146 -
 texk/web2c/luatexdir/luapplib/pparray.h           |    7 
 texk/web2c/luatexdir/luapplib/ppconf.h            |   76 
 texk/web2c/luatexdir/luapplib/ppcrypt.c           |  628 ----
 texk/web2c/luatexdir/luapplib/ppcrypt.c.orig      |  628 ----
 texk/web2c/luatexdir/luapplib/ppcrypt.h           |   61 
 texk/web2c/luatexdir/luapplib/ppdict.c            |  163 -
 texk/web2c/luatexdir/luapplib/ppdict.h            |    7 
 texk/web2c/luatexdir/luapplib/ppfilter.h          |   10 
 texk/web2c/luatexdir/luapplib/ppheap.c            |  424 ---
 texk/web2c/luatexdir/luapplib/ppheap.h            |   29 
 texk/web2c/luatexdir/luapplib/pplib.h             |   22 
 texk/web2c/luatexdir/luapplib/ppload.c            | 2590 -------------------
 texk/web2c/luatexdir/luapplib/ppload.c-OK         | 2555 -------------------
 texk/web2c/luatexdir/luapplib/ppload.c.orig       | 2555 -------------------
 texk/web2c/luatexdir/luapplib/ppload.h            |   54 
 texk/web2c/luatexdir/luapplib/ppstream.c          |  310 --
 texk/web2c/luatexdir/luapplib/ppstream.h          |    9 
 texk/web2c/luatexdir/luapplib/pptest1.c           |   86 
 texk/web2c/luatexdir/luapplib/pptest2.c           |  139 -
 texk/web2c/luatexdir/luapplib/ppxref.c            |  162 -
 texk/web2c/luatexdir/luapplib/ppxref.h            |   35 
 texk/web2c/luatexdir/luapplib/util/utilbasexx.c   | 2108 ---------------
 texk/web2c/luatexdir/luapplib/util/utilbasexx.h   |  133 
 texk/web2c/luatexdir/luapplib/util/utilcrypt.c    | 1191 --------
 texk/web2c/luatexdir/luapplib/util/utilcrypt.h    |   90 
 texk/web2c/luatexdir/luapplib/util/utilcryptdef.h |   30 
 texk/web2c/luatexdir/luapplib/util/utildecl.h     |   28 
 texk/web2c/luatexdir/luapplib/util/utilflate.c    |  319 --
 texk/web2c/luatexdir/luapplib/util/utilflate.h    |   21 
 texk/web2c/luatexdir/luapplib/util/utilfpred.c    |  783 -----
 texk/web2c/luatexdir/luapplib/util/utilfpred.c-OK |  767 -----
 texk/web2c/luatexdir/luapplib/util/utilfpred.h    |   23 
 texk/web2c/luatexdir/luapplib/util/utiliof.c      | 2949 ----------------------
 texk/web2c/luatexdir/luapplib/util/utiliof.c-OK   | 2938 ---------------------
 texk/web2c/luatexdir/luapplib/util/utiliof.h      |  669 ----
 texk/web2c/luatexdir/luapplib/util/utillog.c      |   60 
 texk/web2c/luatexdir/luapplib/util/utillog.h      |   10 
 texk/web2c/luatexdir/luapplib/util/utillzw.c      |  701 -----
 texk/web2c/luatexdir/luapplib/util/utillzw.h      |   30 
 texk/web2c/luatexdir/luapplib/util/utilmd5.c      |  413 ---
 texk/web2c/luatexdir/luapplib/util/utilmd5.c.orig |  413 ---
 texk/web2c/luatexdir/luapplib/util/utilmd5.h      |  115 
 texk/web2c/luatexdir/luapplib/util/utilmd5.h.orig |  115 
 texk/web2c/luatexdir/luapplib/util/utilmem.c      |   68 
 texk/web2c/luatexdir/luapplib/util/utilmem.h      |   59 
 texk/web2c/luatexdir/luapplib/util/utilnumber.c   | 1325 ---------
 texk/web2c/luatexdir/luapplib/util/utilnumber.h   |  354 --
 texk/web2c/luatexdir/luapplib/util/utilplat.h     |   23 
 texk/web2c/luatexdir/luapplib/util/utilsha.c      | 1290 ---------
 texk/web2c/luatexdir/luapplib/util/utilsha.c-OK   | 1198 --------
 texk/web2c/luatexdir/luapplib/util/utilsha.h      |  134 
 texk/web2c/luatexdir/luapplib/zlib/zconf.h        |  428 ---
 texk/web2c/luatexdir/luapplib/zlib/zlib.h         | 1613 ------------
 57 files changed, 31929 deletions(-)

--- texlive-bin.orig/texk/web2c/luatexdir/luapplib/Makefile.orig
+++ /dev/null
@@ -1,84 +0,0 @@
-
-ifeq ($(ARCH),)
-	ARCH=x64
-endif
-
-UNAME:=$(shell uname)
-ifeq ($(UNAME),Linux)
-	BUILDSUFFIX=_ux_$(ARCH)
-	SOEXT=.so
-	EXEEXT=
-	STATICCOPTS=
-#	SHAREDCOPTS=-fPIC
-	LFLAGS=
-	LIBS=-lm
-else
-	BUILDSUFFIX=_win_$(ARCH)
-	SOEXT=.dll
-	EXEEXT=.exe
-	STATICCOPTS=
-#	SHAREDCOPTS=-DPPDLL
-	LFLAGS = -Wl,--output-def,$@.def,--out-implib,$@.a
-	LIBS=
-endif
-
-CC=gcc
-W=-Wall -Wunused -Wimplicit -Wreturn-type -Wdeclaration-after-statement -Wno-unknown-pragmas -Wmissing-prototypes -Wmissing-declarations -Wparentheses -Wswitch -Wtrigraphs -Wcast-qual -Wcast-align -Wwrite-strings -Wold-style-definition -Wpointer-arith
-#W=-Wall
-CFLAGS=$(W) -O2
-
-OBJEXT=$(BUILDSUFFIX).o
-
-PPUTILS=utilmem utillog utilnumber utiliof utilmd5 utilsha utilcrypt
-PPFILTERS=utilbasexx utilflate utillzw utilfpred
-PPMODULES=ppheap pparray ppdict ppstream ppcrypt ppxref ppload
-
-OUTDIR=build
-UTILSDIR=util
-
-PPSTATICUTILSOBJ=$(patsubst %, $(OUTDIR)/%$(OBJEXT), $(PPUTILS))
-PPSTATICFILTERSOBJ=$(patsubst %, $(OUTDIR)/%$(OBJEXT), $(PPFILTERS))
-PPSTATICOBJ=$(patsubst %, $(OUTDIR)/%$(OBJEXT), $(PPMODULES))
-PPSTATICLIB=$(OUTDIR)/libpp.static$(BUILDSUFFIX).a
-
-# dependencies
-FLATEDIR=zlib
-FLATELIB=$(FLATEDIR)/libz.static$(BUILDSUFFIX).a
-PPSTATICDEPS=$(FLATELIB)
-
-# test programm
-PPTEST1=$(OUTDIR)/pptest1$(EXEEXT)
-PPTEST2=$(OUTDIR)/pptest2$(EXEEXT)
-
-# includes
-INC=-I $(UTILSDIR)
-AUX=-I $(FLATEDIR)
-
-default: md $(PPSTATICLIB) $(PPTEST1) $(PPTEST2)
-
-md:
-	@[ -d $(OUTDIR) ] || mkdir -p $(OUTDIR)
-
-$(PPSTATICOBJ): $(OUTDIR)/%$(OBJEXT): %.c %.h
-	$(CC) $(CFLAGS) $(STATICCOPTS) $(INC) -o $@ -c $<
-
-$(PPSTATICUTILSOBJ): $(OUTDIR)/%$(OBJEXT): $(UTILSDIR)/%.c $(UTILSDIR)/%.h
-	$(CC) $(CFLAGS) $(STATICCOPTS) $(INC) -o $@ -c $<
-
-$(PPSTATICFILTERSOBJ): $(OUTDIR)/%$(OBJEXT): $(UTILSDIR)/%.c $(UTILSDIR)/%.h
-	$(CC) $(CFLAGS) $(STATICCOPTS) $(INC) $(AUX) -o $@ -c $<
-
-$(PPSTATICLIB): $(PPSTATICOBJ) $(PPSTATICUTILSOBJ) $(PPSTATICFILTERSOBJ)
-	ar rcs $@ $^
-	strip -N print_hex $@
-
-$(PPTEST1): $(PPSTATICLIB) pptest1.c
-	$(CC) $(CFLAGS) $(STATICCOPTS) -o $(OUTDIR)/pptest1$(OBJEXT) -c pptest1.c
-	$(CC) -static-libgcc $(CFLAGS) -o $(PPTEST1) $(OUTDIR)/pptest1$(OBJEXT) $(PPSTATICLIB) $(PPSTATICDEPS) $(LIBS)
-
-$(PPTEST2): $(PPSTATICLIB) pptest2.c
-	$(CC) $(CFLAGS) $(STATICCOPTS) -o $(OUTDIR)/pptest2$(OBJEXT) -c pptest2.c
-	$(CC) -static-libgcc $(CFLAGS) -o $(PPTEST2) $(OUTDIR)/pptest2$(OBJEXT) $(PPSTATICLIB) $(PPSTATICDEPS) $(LIBS)
-
-clean:
-	rm -f $(OUTDIR)/*$(OBJEXT) $(OUTDIR)/*.a $(OUTDIR)/*$(EXEEXT)
--- texlive-bin.orig/texk/web2c/luatexdir/luapplib/ppapi.h
+++ /dev/null
@@ -1,391 +0,0 @@
-
-#ifndef PP_API_H
-#define PP_API_H
-
-#include <stdint.h>
-#include <stddef.h>
-#include <string.h>
-
-#include "ppconf.h"
-
-#define pplib_version "v0.97"
-#define pplib_author "p.jackowski@gust.org.pl"
-
-/* types */
-
-typedef int64_t ppint;
-typedef size_t ppuint; // machine word
-
-typedef double ppnum;
-typedef char * ppname;
-typedef char * ppstring;
-
-typedef struct {
-  size_t size;
-  int flags;
-} _ppname;
-
-typedef struct {
-  size_t size;
-  int flags;
-} _ppstring;
-
-typedef struct ppobj ppobj;
-typedef struct ppref ppref;
-
-
-#if defined __arm__ || defined __ARM__ || defined ARM || defined __ARM || defined __arm || defined __ARM_ARCH ||defined __aarch64__ 
-typedef struct {
-  ppobj *data;
-  size_t size;
-  ppnum PPARRAY_ALIGNMENT;
-} pparray;
-#else
-typedef struct {
-  ppobj *data;
-  size_t size;
-} pparray;
-#endif
-
-
-#if defined __arm__ || defined __ARM__ || defined ARM || defined __ARM || defined __arm || defined __ARM_ARCH ||defined __aarch64__ 
-typedef struct {
-  ppobj *data;
-	ppname *keys;
-  size_t size;
-  ppnum PPDICT_ALIGNMENT;
-} ppdict;
-
-#else
-typedef struct {
-  ppobj *data;
-	ppname *keys;
-  size_t size;
-} ppdict;
-#endif
-
-
-typedef struct {
-  ppdict *dict;
-  void *input, *I;
-  size_t offset;
-  size_t length;
-  ppstring cryptkey;
-  int flags;
-} ppstream;
-
-#define PPSTREAM_COMPRESSED (1<<0)
-#define PPSTREAM_ENCRYPTED_AES (1<<1)
-#define PPSTREAM_ENCRYPTED_RC4 (1<<2)
-#define PPSTREAM_ENCRYPTED (PPSTREAM_ENCRYPTED_AES|PPSTREAM_ENCRYPTED_RC4)
-#define PPSTREAM_ENCRYPTED_OWN (1<<3)
-
-#define ppstream_compressed(stream) ((stream)->flags & PPSTREAM_COMPRESSED)
-#define ppstream_encrypted(stream) ((stream)->flags & PPSTREAM_ENCRYPTED)
-
-typedef enum {
-  PPNONE = 0,
-  PPNULL,
-  PPBOOL,
-  PPINT,
-  PPNUM,
-  PPNAME,
-  PPSTRING,
-  PPARRAY,
-  PPDICT,
-  PPSTREAM,
-  PPREF
-} ppobjtp;
-
-PPDEF extern const char * ppobj_kind[];
-
-struct ppobj {
-  ppobjtp type;
-  union {
-    ppint integer;
-    ppnum number;
-    ppname name;
-    ppstring string;
-    pparray *array;
-    ppdict *dict;
-    ppstream *stream;
-    ppref *ref;
-    void *any;
-  };
-};
-
-typedef struct ppxref ppxref;
-
-struct ppref {
-  ppobj object;
-  ppuint number, version;
-  size_t offset;
-  size_t length;
-  ppxref *xref;
-};
-
-typedef struct ppdoc ppdoc;
-
-/* object */
-
-#define ppobj_get_null(o) ((o)->type == PPNULL ? 1 : 0)
-#define ppobj_get_bool(o, v) ((o)->type == PPBOOL ? ((v = ((o)->integer != 0)), 1) : 0)
-#define ppobj_get_int(o, v) ((o)->type == PPINT ? ((v = (o)->integer), 1) : 0)
-#define ppobj_get_uint(o, v) ((o)->type == PPINT && (o)->integer >= 0 ? ((v = (ppuint)((o)->integer)), 1) : 0)
-#define ppobj_get_num(o, v) ((o)->type == PPNUM ? ((v = (o)->number), 1) : (((o)->type == PPINT ? ((v = (ppnum)((o)->integer)), 1) : 0)))
-#define ppobj_get_name(o) ((o)->type == PPNAME ? (o)->name : NULL)
-#define ppobj_get_string(o) ((o)->type == PPSTRING ? (o)->string : NULL)
-#define ppobj_get_array(o) ((o)->type == PPARRAY ? (o)->array : NULL)
-#define ppobj_get_dict(o) ((o)->type == PPDICT ? (o)->dict : NULL)
-#define ppobj_get_stream(o) ((o)->type == PPSTREAM ? (o)->stream : NULL)
-#define ppobj_get_ref(o) ((o)->type == PPREF ? (o)->ref : NULL)
-
-#define ppobj_rget_obj(o) ((o)->type == PPREF ? ppref_obj((o)->ref) : o)
-#define ppobj_rget_null(o) ((o)->type == PPNULL ? 1 : ((o)->type == PPREF ? ppobj_get_null(ppref_obj((o)->ref)) : 0))
-#define ppobj_rget_bool(o, v) ((o)->type == PPBOOL ? ((v = ((o)->integer != 0)), 1) : ((o)->type == PPREF ? ppobj_get_bool(ppref_obj((o)->ref), v) : 0))
-#define ppobj_rget_int(o, v) ((o)->type == PPINT ? ((v = (o)->integer), 1) : ((o)->type == PPREF ? ppobj_get_int(ppref_obj((o)->ref), v) : 0))
-#define ppobj_rget_uint(o, v) ((o)->type == PPINT && (o)->integer >= 0 ? ((v = (ppuint)((o)->integer)), 1) : ((o)->type == PPREF ? ppobj_get_uint(ppref_obj((o)->ref), v) : 0))
-#define ppobj_rget_num(o, v) ((o)->type == PPNUM ? ((v = (o)->number), 1) : (((o)->type == PPINT ? ((v = (ppnum)((o)->integer)), 1) : ((o)->type == PPREF ? ppobj_get_num(ppref_obj((o)->ref), v) : 0))))
-#define ppobj_rget_name(o) ((o)->type == PPNAME ? (o)->name : ((o)->type == PPREF ? ppobj_get_name(ppref_obj((o)->ref)) : NULL))
-#define ppobj_rget_string(o) ((o)->type == PPSTRING ? (o)->string : ((o)->type == PPREF ? ppobj_get_string(ppref_obj((o)->ref)) : NULL))
-#define ppobj_rget_array(o) ((o)->type == PPARRAY ? (o)->array : ((o)->type == PPREF ? ppobj_get_array(ppref_obj((o)->ref)) : NULL))
-#define ppobj_rget_dict(o) ((o)->type == PPDICT ? (o)->dict : ((o)->type == PPREF ? ppobj_get_dict(ppref_obj((o)->ref)) : NULL))
-#define ppobj_rget_stream(o) ((o)->type == PPSTREAM ? (o)->stream : ((o)->type == PPREF ? ppobj_get_stream(ppref_obj((o)->ref)) : NULL))
-#define ppobj_rget_ref(o) ((o)->type == PPREF ? (o)->ref : ((o)->type == PPREF ? ppobj_get_ref(ppref_obj((o)->ref)) : NULL))
-
-#define ppobj_get_bool_value(o) ((o)->type == PPBOOL ? ((o)->integer != 0) : 0)
-#define ppobj_get_int_value(o) ((o)->type == PPINT ? (o)->integer : 0)
-#define ppobj_get_num_value(o) ((o)->type == PPNUM  ? (o)->number : ((o)->type == PPINT  ? (ppnum)((o)->integer) : 0.0))
-
-/* name */
-
-#define ppname_is(name, s) (memcmp(name, s, sizeof("" s) - 1) == 0)
-#define ppname_eq(name, n) (memcmp(name, s, ppname_size(name)) == 0)
-
-#if defined __arm__ || defined __ARM__ || defined ARM || defined __ARM || defined __arm || defined __ARM_ARCH ||defined __aarch64__ 
-#define _ppname_ghost(name) (((const _ppname *)((void *)name)) - 1)
-#else
-#define _ppname_ghost(name) (((const _ppname *)(name)) - 1)
-#endif
-
-#define ppname_size(name) (_ppname_ghost(name)->size)
-#define ppname_exec(name) (_ppname_ghost(name)->flags & PPNAME_EXEC)
-
-#define PPNAME_ENCODED (1 << 0)
-#define PPNAME_DECODED (1 << 1)
-#define PPNAME_EXEC (1 << 1)
-
-PPAPI ppname ppname_decoded (ppname name);
-PPAPI ppname ppname_encoded (ppname name);
-
-/* string */
-
-#if defined __arm__ || defined __ARM__ || defined ARM || defined __ARM || defined __arm || defined __ARM_ARCH ||defined __aarch64__ 
-#define _ppstring_ghost(string) (((const _ppstring *)((void *)string)) - 1)
-#else
-#define _ppstring_ghost(string) (((const _ppstring *)(string)) - 1)
-#endif
-
-#define ppstring_size(string) (_ppstring_ghost(string)->size)
-
-#define PPSTRING_ENCODED (1 << 0)
-#define PPSTRING_DECODED (1 << 1)
-//#define PPSTRING_EXEC (1 << 2) // postscript only
-#define PPSTRING_PLAIN 0
-#define PPSTRING_BASE16 (1 << 3)
-#define PPSTRING_BASE85 (1 << 4)
-#define PPSTRING_UTF16BE (1 << 5)
-#define PPSTRING_UTF16LE (1 << 6)
-
-#define ppstring_type(string) (_ppstring_ghost(string)->flags & (PPSTRING_BASE16|PPSTRING_BASE85))
-#define ppstring_hex(string) (_ppstring_ghost(string)->flags & PPSTRING_BASE16)
-#define ppstring_utf(string) (_ppstring_ghost(string)->flags & (PPSTRING_UTF16BE|PPSTRING_UTF16LE))
-
-PPAPI ppstring ppstring_decoded (ppstring string);
-PPAPI ppstring ppstring_encoded (ppstring string);
-
-/* array */
-
-#define pparray_size(array) ((array)->size)
-#define pparray_at(array, index) ((array)->data + index)
-
-#define pparray_first(array, index, obj) ((index) = 0, (obj) = pparray_at(array,  0))
-#define pparray_next(index, obj) (++(index), ++(obj))
-
-#define pparray_get(array, index) (index < (array)->size ? pparray_at(array, index) : NULL)
-
-PPAPI ppobj * pparray_get_obj (pparray *array, size_t index);
-PPAPI int pparray_get_bool (pparray *array, size_t index, int *v);
-PPAPI int pparray_get_int (pparray *array, size_t index, ppint *v);
-PPAPI int pparray_get_uint (pparray *array, size_t index, ppuint *v);
-PPAPI int pparray_get_num (pparray *array, size_t index, ppnum *v);
-PPAPI ppname pparray_get_name (pparray *array, size_t index);
-PPAPI ppstring pparray_get_string (pparray *array, size_t index);
-PPAPI pparray * pparray_get_array (pparray *array, size_t index);
-PPAPI ppdict * pparray_get_dict (pparray *array, size_t index);
-//PPAPI ppstream * pparray_get_stream (pparray *array, size_t index);
-PPAPI ppref * pparray_get_ref (pparray *array, size_t index);
-
-PPAPI ppobj * pparray_rget_obj (pparray *array, size_t index);
-PPAPI int pparray_rget_bool (pparray *array, size_t index, int *v);
-PPAPI int pparray_rget_int (pparray *array, size_t index, ppint *v);
-PPAPI int pparray_rget_uint (pparray *array, size_t index, ppuint *v);
-PPAPI int pparray_rget_num (pparray *array, size_t index, ppnum *v);
-PPAPI ppname pparray_rget_name (pparray *array, size_t index);
-PPAPI ppstring pparray_rget_string (pparray *array, size_t index);
-PPAPI pparray * pparray_rget_array (pparray *array, size_t index);
-PPAPI ppdict * pparray_rget_dict (pparray *array, size_t index);
-PPAPI ppstream * pparray_rget_stream (pparray *array, size_t index);
-PPAPI ppref * pparray_rget_ref (pparray *array, size_t index);
-
-/* dict */
-
-#define ppdict_size(dict) ((dict)->size)
-#define ppdict_at(dict, index) ((dict)->data + index)
-#define ppdict_key(dict, index) ((dict)->keys[index])
-
-PPAPI ppobj * ppdict_get_obj (ppdict *dict, const char *name);
-PPAPI int ppdict_get_bool (ppdict *dict, const char *name, int *v);
-PPAPI int ppdict_get_int (ppdict *dict, const char *name, ppint *v);
-PPAPI int ppdict_get_uint (ppdict *dict, const char *name, ppuint *v);
-PPAPI int ppdict_get_num (ppdict *dict, const char *name, ppnum *v);
-PPAPI ppname ppdict_get_name (ppdict *dict, const char *name);
-PPAPI ppstring ppdict_get_string (ppdict *dict, const char *name);
-PPAPI pparray * ppdict_get_array (ppdict *dict, const char *name);
-PPAPI ppdict * ppdict_get_dict (ppdict *dict, const char *name);
-//PPAPI ppstream * ppdict_get_stream (ppdict *dict, const char *name);
-PPAPI ppref * ppdict_get_ref (ppdict *dict, const char *name);
-
-PPAPI ppobj * ppdict_rget_obj (ppdict *dict, const char *name);
-PPAPI int ppdict_rget_bool (ppdict *dict, const char *name, int *v);
-PPAPI int ppdict_rget_int (ppdict *dict, const char *name, ppint *v);
-PPAPI int ppdict_rget_uint (ppdict *dict, const char *name, ppuint *v);
-PPAPI int ppdict_rget_num (ppdict *dict, const char *name, ppnum *v);
-PPAPI ppname ppdict_rget_name (ppdict *dict, const char *name);
-PPAPI ppstring ppdict_rget_string (ppdict *dict, const char *name);
-PPAPI pparray * ppdict_rget_array (ppdict *dict, const char *name);
-PPAPI ppdict * ppdict_rget_dict (ppdict *dict, const char *name);
-PPAPI ppstream * ppdict_rget_stream (ppdict *dict, const char *name);
-PPAPI ppref * ppdict_rget_ref (ppdict *dict, const char *name);
-
-#define ppdict_first(dict, pkey, obj) (pkey = (dict)->keys, obj = (dict)->data)
-#define ppdict_next(pkey, obj) (++(pkey), ++(obj))
-
-/* stream */
-
-#define ppstream_dict(stream) ((stream)->dict)
-
-PPAPI uint8_t * ppstream_first (ppstream *stream, size_t *size, int decode);
-PPAPI uint8_t * ppstream_next (ppstream *stream, size_t *size);
-PPAPI uint8_t * ppstream_all (ppstream *stream, size_t *size, int decode);
-PPAPI void ppstream_done (ppstream *stream);
-
-PPAPI void ppstream_init_buffers (void);
-PPAPI void ppstream_free_buffers (void);
-
-/* ref */
-
-#define ppref_obj(ref) (&(ref)->object)
-
-/* xref */
-
-PPAPI ppxref * ppdoc_xref (ppdoc *pdf);
-PPAPI ppxref * ppxref_prev (ppxref *xref);
-PPAPI ppdict * ppxref_trailer (ppxref *xref);
-PPAPI ppdict * ppxref_catalog (ppxref *xref);
-PPAPI ppdict * ppxref_info (ppxref *xref);
-PPAPI ppref * ppxref_pages (ppxref *xref);
-PPAPI ppref * ppxref_find (ppxref *xref, ppuint refnumber);
-
-/* doc */
-
-PPAPI ppdoc * ppdoc_load (const char *filename);
-PPAPI ppdoc * ppdoc_mem (const void *data, size_t size);
-PPAPI void ppdoc_free (ppdoc *pdf);
-
-#define ppdoc_trailer(pdf) ppxref_trailer(ppdoc_xref(pdf))
-#define ppdoc_catalog(pdf) ppxref_catalog(ppdoc_xref(pdf))
-#define ppdoc_info(pdf) ppxref_info(ppdoc_xref(pdf))
-#define ppdoc_pages(pdf) ppxref_pages(ppdoc_xref(pdf))
-
-PPAPI ppuint ppdoc_page_count (ppdoc *pdf);
-PPAPI ppref * ppdoc_page (ppdoc *pdf, ppuint index);
-PPAPI ppref *  ppdoc_first_page (ppdoc *pdf);
-PPAPI ppref * ppdoc_next_page (ppdoc *pdf);
-
-PPAPI ppstream * ppcontents_first (ppdict *dict);
-PPAPI ppstream * ppcontents_next (ppdict *dict, ppstream *stream);
-
-/* crypt */
-
-typedef enum {
-  PPCRYPT_NONE = 0,
-  PPCRYPT_DONE = 1,
-  PPCRYPT_FAIL = -1,
-  PPCRYPT_PASS = -2
-} ppcrypt_status;
-
-PPAPI ppcrypt_status ppdoc_crypt_status (ppdoc *pdf);
-PPAPI ppcrypt_status ppdoc_crypt_pass (ppdoc *pdf, const void *userpass, size_t userpasslength, const void *ownerpass, size_t ownerpasslength);
-
-/* permission flags, effect in Acrobat File -> Properties -> Security tab */
-
-PPAPI ppint ppdoc_permissions (ppdoc *pdf);
-
-#define PPDOC_ALLOW_PRINT (1<<2)        // printing
-#define PPDOC_ALLOW_MODIFY (1<<3)       // filling form fields, signing, creating template pages
-#define PPDOC_ALLOW_COPY (1<<4)         // copying, copying for accessibility
-#define PPDOC_ALLOW_ANNOTS (1<<5)       // filling form fields, copying, signing
-#define PPDOC_ALLOW_EXTRACT (1<<9)      // contents copying for accessibility
-#define PPDOC_ALLOW_ASSEMBLY (1<<10)    // (no effect)
-#define PPDOC_ALLOW_PRINT_HIRES (1<<11) // (no effect)
-
-/* context */
-
-typedef struct ppcontext ppcontext;
-
-PPAPI ppcontext * ppcontext_new (void);
-PPAPI void ppcontext_done (ppcontext *context);
-PPAPI void ppcontext_free (ppcontext *context);
-
-/* contents parser */
-
-PPAPI ppobj * ppcontents_first_op (ppcontext *context, ppstream *stream, size_t *psize, ppname *pname);
-PPAPI ppobj * ppcontents_next_op (ppcontext *context, ppstream *stream, size_t *psize, ppname *pname);
-PPAPI ppobj * ppcontents_parse (ppcontext *context, ppstream *stream, size_t *psize);
-
-/* boxes and transforms */
-
-typedef struct {
-  ppnum lx, ly, rx, ry;
-} pprect;
-
-PPAPI pprect * pparray_to_rect (pparray *array, pprect *rect);
-PPAPI pprect * ppdict_get_rect (ppdict *dict, const char *name, pprect *rect);
-PPAPI pprect * ppdict_get_box (ppdict *dict, const char *name, pprect *rect);
-
-typedef struct {
-  ppnum xx, xy, yx, yy, x, y;
-} ppmatrix;
-
-PPAPI ppmatrix * pparray_to_matrix (pparray *array, ppmatrix *matrix);
-PPAPI ppmatrix * ppdict_get_matrix (ppdict *dict, const char *name, ppmatrix *matrix);
-
-/* logger */
-
-typedef void (*pplogger_callback) (const char *message, void *alien);
-PPAPI void pplog_callback (pplogger_callback logger, void *alien);
-PPAPI int pplog_prefix (const char *prefix);
-
-/* version */
-
-PPAPI const char * ppdoc_version_string (ppdoc *pdf);
-PPAPI int ppdoc_version_number (ppdoc *pdf, int *minor);
-
-/* doc info */
-
-PPAPI size_t ppdoc_file_size (ppdoc *pdf);
-PPAPI ppuint ppdoc_objects (ppdoc *pdf);
-PPAPI size_t ppdoc_memory (ppdoc *pdf, size_t *waste);
-
-#endif
--- texlive-bin.orig/texk/web2c/luatexdir/luapplib/ppapi.h-OK
+++ /dev/null
@@ -1,360 +0,0 @@
-
-#ifndef PP_API_H
-#define PP_API_H
-
-#include <stdint.h>
-#include <stddef.h>
-#include <string.h>
-
-#include "ppconf.h"
-
-#define pplib_version "v0.97"
-#define pplib_author "p.jackowski@gust.org.pl"
-
-/* types */
-
-typedef int64_t ppint;
-typedef size_t ppuint; // machine word
-
-typedef double ppnum;
-typedef char * ppname;
-typedef char * ppstring;
-
-typedef struct {
-  size_t size;
-  int flags;
-} _ppname;
-
-typedef struct {
-  size_t size;
-  int flags;
-} _ppstring;
-
-typedef struct ppobj ppobj;
-typedef struct ppref ppref;
-
-typedef struct {
-  ppobj *data;
-  size_t size;
-} pparray;
-
-typedef struct {
-  ppobj *data;
-	ppname *keys;
-  size_t size;
-} ppdict;
-
-typedef struct {
-  ppdict *dict;
-  void *input, *I;
-  size_t offset;
-  size_t length;
-  ppstring cryptkey;
-  int flags;
-} ppstream;
-
-#define PPSTREAM_COMPRESSED (1<<0)
-#define PPSTREAM_ENCRYPTED_AES (1<<1)
-#define PPSTREAM_ENCRYPTED_RC4 (1<<2)
-#define PPSTREAM_ENCRYPTED (PPSTREAM_ENCRYPTED_AES|PPSTREAM_ENCRYPTED_RC4)
-#define PPSTREAM_ENCRYPTED_OWN (1<<3)
-
-#define ppstream_compressed(stream) ((stream)->flags & PPSTREAM_COMPRESSED)
-#define ppstream_encrypted(stream) ((stream)->flags & PPSTREAM_ENCRYPTED)
-
-typedef enum {
-  PPNONE = 0,
-  PPNULL,
-  PPBOOL,
-  PPINT,
-  PPNUM,
-  PPNAME,
-  PPSTRING,
-  PPARRAY,
-  PPDICT,
-  PPSTREAM,
-  PPREF
-} ppobjtp;
-
-PPDEF extern const char * ppobj_kind[];
-
-struct ppobj {
-  ppobjtp type;
-  union {
-    ppint integer;
-    ppnum number;
-    ppname name;
-    ppstring string;
-    pparray *array;
-    ppdict *dict;
-    ppstream *stream;
-    ppref *ref;
-    void *any;
-  };
-};
-
-typedef struct ppxref ppxref;
-
-struct ppref {
-  ppobj object;
-  ppuint number, version;
-  size_t offset;
-  size_t length;
-  ppxref *xref;
-};
-
-typedef struct ppdoc ppdoc;
-
-/* object */
-
-#define ppobj_get_null(o) ((o)->type == PPNULL ? 1 : 0)
-#define ppobj_get_bool(o, v) ((o)->type == PPBOOL ? ((v = ((o)->integer != 0)), 1) : 0)
-#define ppobj_get_int(o, v) ((o)->type == PPINT ? ((v = (o)->integer), 1) : 0)
-#define ppobj_get_uint(o, v) ((o)->type == PPINT && (o)->integer >= 0 ? ((v = (ppuint)((o)->integer)), 1) : 0)
-#define ppobj_get_num(o, v) ((o)->type == PPNUM ? ((v = (o)->number), 1) : (((o)->type == PPINT ? ((v = (ppnum)((o)->integer)), 1) : 0)))
-#define ppobj_get_name(o) ((o)->type == PPNAME ? (o)->name : NULL)
-#define ppobj_get_string(o) ((o)->type == PPSTRING ? (o)->string : NULL)
-#define ppobj_get_array(o) ((o)->type == PPARRAY ? (o)->array : NULL)
-#define ppobj_get_dict(o) ((o)->type == PPDICT ? (o)->dict : NULL)
-#define ppobj_get_stream(o) ((o)->type == PPSTREAM ? (o)->stream : NULL)
-#define ppobj_get_ref(o) ((o)->type == PPREF ? (o)->ref : NULL)
-
-#define ppobj_rget_obj(o) ((o)->type == PPREF ? ppref_obj((o)->ref) : o)
-#define ppobj_rget_null(o) ((o)->type == PPNULL ? 1 : ((o)->type == PPREF ? ppobj_get_null(ppref_obj((o)->ref)) : 0))
-#define ppobj_rget_bool(o, v) ((o)->type == PPBOOL ? ((v = ((o)->integer != 0)), 1) : ((o)->type == PPREF ? ppobj_get_bool(ppref_obj((o)->ref), v) : 0))
-#define ppobj_rget_int(o, v) ((o)->type == PPINT ? ((v = (o)->integer), 1) : ((o)->type == PPREF ? ppobj_get_int(ppref_obj((o)->ref), v) : 0))
-#define ppobj_rget_uint(o, v) ((o)->type == PPINT && (o)->integer >= 0 ? ((v = (ppuint)((o)->integer)), 1) : ((o)->type == PPREF ? ppobj_get_uint(ppref_obj((o)->ref), v) : 0))
-#define ppobj_rget_num(o, v) ((o)->type == PPNUM ? ((v = (o)->number), 1) : (((o)->type == PPINT ? ((v = (ppnum)((o)->integer)), 1) : ((o)->type == PPREF ? ppobj_get_num(ppref_obj((o)->ref), v) : 0))))
-#define ppobj_rget_name(o) ((o)->type == PPNAME ? (o)->name : ((o)->type == PPREF ? ppobj_get_name(ppref_obj((o)->ref)) : NULL))
-#define ppobj_rget_string(o) ((o)->type == PPSTRING ? (o)->string : ((o)->type == PPREF ? ppobj_get_string(ppref_obj((o)->ref)) : NULL))
-#define ppobj_rget_array(o) ((o)->type == PPARRAY ? (o)->array : ((o)->type == PPREF ? ppobj_get_array(ppref_obj((o)->ref)) : NULL))
-#define ppobj_rget_dict(o) ((o)->type == PPDICT ? (o)->dict : ((o)->type == PPREF ? ppobj_get_dict(ppref_obj((o)->ref)) : NULL))
-#define ppobj_rget_stream(o) ((o)->type == PPSTREAM ? (o)->stream : ((o)->type == PPREF ? ppobj_get_stream(ppref_obj((o)->ref)) : NULL))
-#define ppobj_rget_ref(o) ((o)->type == PPREF ? (o)->ref : ((o)->type == PPREF ? ppobj_get_ref(ppref_obj((o)->ref)) : NULL))
-
-#define ppobj_get_bool_value(o) ((o)->type == PPBOOL ? ((o)->integer != 0) : 0)
-#define ppobj_get_int_value(o) ((o)->type == PPINT ? (o)->integer : 0)
-#define ppobj_get_num_value(o) ((o)->type == PPNUM  ? (o)->number : ((o)->type == PPINT  ? (ppnum)((o)->integer) : 0.0))
-
-/* name */
-
-#define ppname_is(name, s) (memcmp(name, s, sizeof("" s) - 1) == 0)
-#define ppname_eq(name, n) (memcmp(name, s, ppname_size(name)) == 0)
-
-#define _ppname_ghost(name) (((const _ppname *)(name)) - 1)
-#define ppname_size(name) (_ppname_ghost(name)->size)
-#define ppname_exec(name) (_ppname_ghost(name)->flags & PPNAME_EXEC)
-
-#define PPNAME_ENCODED (1 << 0)
-#define PPNAME_DECODED (1 << 1)
-#define PPNAME_EXEC (1 << 1)
-
-PPAPI ppname ppname_decoded (ppname name);
-PPAPI ppname ppname_encoded (ppname name);
-
-/* string */
-
-#define _ppstring_ghost(string) (((const _ppstring *)(string)) - 1)
-#define ppstring_size(string) (_ppstring_ghost(string)->size)
-
-#define PPSTRING_ENCODED (1 << 0)
-#define PPSTRING_DECODED (1 << 1)
-//#define PPSTRING_EXEC (1 << 2) // postscript only
-#define PPSTRING_PLAIN 0
-#define PPSTRING_BASE16 (1 << 3)
-#define PPSTRING_BASE85 (1 << 4)
-#define PPSTRING_UTF16BE (1 << 5)
-#define PPSTRING_UTF16LE (1 << 6)
-
-#define ppstring_type(string) (_ppstring_ghost(string)->flags & (PPSTRING_BASE16|PPSTRING_BASE85))
-#define ppstring_hex(string) (_ppstring_ghost(string)->flags & PPSTRING_BASE16)
-#define ppstring_utf(string) (_ppstring_ghost(string)->flags & (PPSTRING_UTF16BE|PPSTRING_UTF16LE))
-
-PPAPI ppstring ppstring_decoded (ppstring string);
-PPAPI ppstring ppstring_encoded (ppstring string);
-
-/* array */
-
-#define pparray_size(array) ((array)->size)
-#define pparray_at(array, index) ((array)->data + index)
-
-#define pparray_first(array, index, obj) ((index) = 0, (obj) = pparray_at(array,  0))
-#define pparray_next(index, obj) (++(index), ++(obj))
-
-#define pparray_get(array, index) (index < (array)->size ? pparray_at(array, index) : NULL)
-
-PPAPI ppobj * pparray_get_obj (pparray *array, size_t index);
-PPAPI int pparray_get_bool (pparray *array, size_t index, int *v);
-PPAPI int pparray_get_int (pparray *array, size_t index, ppint *v);
-PPAPI int pparray_get_uint (pparray *array, size_t index, ppuint *v);
-PPAPI int pparray_get_num (pparray *array, size_t index, ppnum *v);
-PPAPI ppname pparray_get_name (pparray *array, size_t index);
-PPAPI ppstring pparray_get_string (pparray *array, size_t index);
-PPAPI pparray * pparray_get_array (pparray *array, size_t index);
-PPAPI ppdict * pparray_get_dict (pparray *array, size_t index);
-//PPAPI ppstream * pparray_get_stream (pparray *array, size_t index);
-PPAPI ppref * pparray_get_ref (pparray *array, size_t index);
-
-PPAPI ppobj * pparray_rget_obj (pparray *array, size_t index);
-PPAPI int pparray_rget_bool (pparray *array, size_t index, int *v);
-PPAPI int pparray_rget_int (pparray *array, size_t index, ppint *v);
-PPAPI int pparray_rget_uint (pparray *array, size_t index, ppuint *v);
-PPAPI int pparray_rget_num (pparray *array, size_t index, ppnum *v);
-PPAPI ppname pparray_rget_name (pparray *array, size_t index);
-PPAPI ppstring pparray_rget_string (pparray *array, size_t index);
-PPAPI pparray * pparray_rget_array (pparray *array, size_t index);
-PPAPI ppdict * pparray_rget_dict (pparray *array, size_t index);
-PPAPI ppstream * pparray_rget_stream (pparray *array, size_t index);
-PPAPI ppref * pparray_rget_ref (pparray *array, size_t index);
-
-/* dict */
-
-#define ppdict_size(dict) ((dict)->size)
-#define ppdict_at(dict, index) ((dict)->data + index)
-#define ppdict_key(dict, index) ((dict)->keys[index])
-
-PPAPI ppobj * ppdict_get_obj (ppdict *dict, const char *name);
-PPAPI int ppdict_get_bool (ppdict *dict, const char *name, int *v);
-PPAPI int ppdict_get_int (ppdict *dict, const char *name, ppint *v);
-PPAPI int ppdict_get_uint (ppdict *dict, const char *name, ppuint *v);
-PPAPI int ppdict_get_num (ppdict *dict, const char *name, ppnum *v);
-PPAPI ppname ppdict_get_name (ppdict *dict, const char *name);
-PPAPI ppstring ppdict_get_string (ppdict *dict, const char *name);
-PPAPI pparray * ppdict_get_array (ppdict *dict, const char *name);
-PPAPI ppdict * ppdict_get_dict (ppdict *dict, const char *name);
-//PPAPI ppstream * ppdict_get_stream (ppdict *dict, const char *name);
-PPAPI ppref * ppdict_get_ref (ppdict *dict, const char *name);
-
-PPAPI ppobj * ppdict_rget_obj (ppdict *dict, const char *name);
-PPAPI int ppdict_rget_bool (ppdict *dict, const char *name, int *v);
-PPAPI int ppdict_rget_int (ppdict *dict, const char *name, ppint *v);
-PPAPI int ppdict_rget_uint (ppdict *dict, const char *name, ppuint *v);
-PPAPI int ppdict_rget_num (ppdict *dict, const char *name, ppnum *v);
-PPAPI ppname ppdict_rget_name (ppdict *dict, const char *name);
-PPAPI ppstring ppdict_rget_string (ppdict *dict, const char *name);
-PPAPI pparray * ppdict_rget_array (ppdict *dict, const char *name);
-PPAPI ppdict * ppdict_rget_dict (ppdict *dict, const char *name);
-PPAPI ppstream * ppdict_rget_stream (ppdict *dict, const char *name);
-PPAPI ppref * ppdict_rget_ref (ppdict *dict, const char *name);
-
-#define ppdict_first(dict, pkey, obj) (pkey = (dict)->keys, obj = (dict)->data)
-#define ppdict_next(pkey, obj) (++(pkey), ++(obj))
-
-/* stream */
-
-#define ppstream_dict(stream) ((stream)->dict)
-
-PPAPI uint8_t * ppstream_first (ppstream *stream, size_t *size, int decode);
-PPAPI uint8_t * ppstream_next (ppstream *stream, size_t *size);
-PPAPI uint8_t * ppstream_all (ppstream *stream, size_t *size, int decode);
-PPAPI void ppstream_done (ppstream *stream);
-
-PPAPI void ppstream_init_buffers (void);
-PPAPI void ppstream_free_buffers (void);
-
-/* ref */
-
-#define ppref_obj(ref) (&(ref)->object)
-
-/* xref */
-
-PPAPI ppxref * ppdoc_xref (ppdoc *pdf);
-PPAPI ppxref * ppxref_prev (ppxref *xref);
-PPAPI ppdict * ppxref_trailer (ppxref *xref);
-PPAPI ppdict * ppxref_catalog (ppxref *xref);
-PPAPI ppdict * ppxref_info (ppxref *xref);
-PPAPI ppref * ppxref_pages (ppxref *xref);
-PPAPI ppref * ppxref_find (ppxref *xref, ppuint refnumber);
-
-/* doc */
-
-PPAPI ppdoc * ppdoc_load (const char *filename);
-PPAPI ppdoc * ppdoc_mem (const void *data, size_t size);
-PPAPI void ppdoc_free (ppdoc *pdf);
-
-#define ppdoc_trailer(pdf) ppxref_trailer(ppdoc_xref(pdf))
-#define ppdoc_catalog(pdf) ppxref_catalog(ppdoc_xref(pdf))
-#define ppdoc_info(pdf) ppxref_info(ppdoc_xref(pdf))
-#define ppdoc_pages(pdf) ppxref_pages(ppdoc_xref(pdf))
-
-PPAPI ppuint ppdoc_page_count (ppdoc *pdf);
-PPAPI ppref * ppdoc_page (ppdoc *pdf, ppuint index);
-PPAPI ppref *  ppdoc_first_page (ppdoc *pdf);
-PPAPI ppref * ppdoc_next_page (ppdoc *pdf);
-
-PPAPI ppstream * ppcontents_first (ppdict *dict);
-PPAPI ppstream * ppcontents_next (ppdict *dict, ppstream *stream);
-
-/* crypt */
-
-typedef enum {
-  PPCRYPT_NONE = 0,
-  PPCRYPT_DONE = 1,
-  PPCRYPT_FAIL = -1,
-  PPCRYPT_PASS = -2
-} ppcrypt_status;
-
-PPAPI ppcrypt_status ppdoc_crypt_status (ppdoc *pdf);
-PPAPI ppcrypt_status ppdoc_crypt_pass (ppdoc *pdf, const void *userpass, size_t userpasslength, const void *ownerpass, size_t ownerpasslength);
-
-/* permission flags, effect in Acrobat File -> Properties -> Security tab */
-
-PPAPI ppint ppdoc_permissions (ppdoc *pdf);
-
-#define PPDOC_ALLOW_PRINT (1<<2)        // printing
-#define PPDOC_ALLOW_MODIFY (1<<3)       // filling form fields, signing, creating template pages
-#define PPDOC_ALLOW_COPY (1<<4)         // copying, copying for accessibility
-#define PPDOC_ALLOW_ANNOTS (1<<5)       // filling form fields, copying, signing
-#define PPDOC_ALLOW_EXTRACT (1<<9)      // contents copying for accessibility
-#define PPDOC_ALLOW_ASSEMBLY (1<<10)    // (no effect)
-#define PPDOC_ALLOW_PRINT_HIRES (1<<11) // (no effect)
-
-/* context */
-
-typedef struct ppcontext ppcontext;
-
-PPAPI ppcontext * ppcontext_new (void);
-PPAPI void ppcontext_done (ppcontext *context);
-PPAPI void ppcontext_free (ppcontext *context);
-
-/* contents parser */
-
-PPAPI ppobj * ppcontents_first_op (ppcontext *context, ppstream *stream, size_t *psize, ppname *pname);
-PPAPI ppobj * ppcontents_next_op (ppcontext *context, ppstream *stream, size_t *psize, ppname *pname);
-PPAPI ppobj * ppcontents_parse (ppcontext *context, ppstream *stream, size_t *psize);
-
-/* boxes and transforms */
-
-typedef struct {
-  ppnum lx, ly, rx, ry;
-} pprect;
-
-PPAPI pprect * pparray_to_rect (pparray *array, pprect *rect);
-PPAPI pprect * ppdict_get_rect (ppdict *dict, const char *name, pprect *rect);
-PPAPI pprect * ppdict_get_box (ppdict *dict, const char *name, pprect *rect);
-
-typedef struct {
-  ppnum xx, xy, yx, yy, x, y;
-} ppmatrix;
-
-PPAPI ppmatrix * pparray_to_matrix (pparray *array, ppmatrix *matrix);
-PPAPI ppmatrix * ppdict_get_matrix (ppdict *dict, const char *name, ppmatrix *matrix);
-
-/* logger */
-
-typedef void (*pplogger_callback) (const char *message, void *alien);
-PPAPI void pplog_callback (pplogger_callback logger, void *alien);
-PPAPI int pplog_prefix (const char *prefix);
-
-/* version */
-
-PPAPI const char * ppdoc_version_string (ppdoc *pdf);
-PPAPI int ppdoc_version_number (ppdoc *pdf, int *minor);
-
-/* doc info */
-
-PPAPI size_t ppdoc_file_size (ppdoc *pdf);
-PPAPI ppuint ppdoc_objects (ppdoc *pdf);
-PPAPI size_t ppdoc_memory (ppdoc *pdf, size_t *waste);
-
-#endif
--- texlive-bin.orig/texk/web2c/luatexdir/luapplib/pparray.c
+++ /dev/null
@@ -1,146 +0,0 @@
-
-#include "pplib.h"
-
-pparray * pparray_create (const ppobj *stackpos, size_t size, ppheap **pheap)
-{
-	pparray *array;
-	ppobj *data;
-  array = (pparray *)ppheap_take(pheap, sizeof(pparray) + size * sizeof(ppobj));
-  array->size = size;
-  array->data = data = (ppobj *)(array + 1);
-  memcpy(data, stackpos, size * sizeof(ppobj));
-  return array;
-}
-
-ppobj * pparray_get_obj (pparray *array, size_t index)
-{
-  return pparray_get(array, index);
-}
-
-ppobj * pparray_rget_obj (pparray *array, size_t index)
-{
-  ppobj *obj;
-  return (obj = pparray_get(array, index)) != NULL ? ppobj_rget_obj(obj) : NULL;
-}
-
-int pparray_get_bool (pparray *array, size_t index, int *v)
-{
-  ppobj *obj;
-  return (obj = pparray_get(array, index)) != NULL ? ppobj_get_bool(obj, *v) : 0;
-}
-
-int pparray_rget_bool (pparray *array, size_t index, int *v)
-{
-  ppobj *obj;
-  return (obj = pparray_get(array, index)) != NULL ? ppobj_rget_bool(obj, *v) : 0;
-}
-
-int pparray_get_int (pparray *array, size_t index, ppint *v)
-{
-  ppobj *obj;
-  return (obj = pparray_get(array, index)) != NULL ? ppobj_get_int(obj, *v) : 0;
-}
-
-int pparray_rget_int (pparray *array, size_t index, ppint *v)
-{
-  ppobj *obj;
-  return (obj = pparray_get(array, index)) != NULL ? ppobj_rget_int(obj, *v) : 0;
-}
-
-int pparray_get_uint (pparray *array, size_t index, ppuint *v)
-{
-  ppobj *obj;
-  return (obj = pparray_get(array, index)) != NULL ? ppobj_get_uint(obj, *v) : 0;
-}
-
-int pparray_rget_uint (pparray *array, size_t index, ppuint *v)
-{
-  ppobj *obj;
-  return (obj = pparray_get(array, index)) != NULL ? ppobj_rget_uint(obj, *v) : 0;
-}
-
-int pparray_get_num (pparray *array, size_t index, ppnum *v)
-{
-  ppobj *obj;
-  return (obj = pparray_get(array, index)) != NULL ? ppobj_get_num(obj, *v) : 0;
-}
-
-int pparray_rget_num (pparray *array, size_t index, ppnum *v)
-{
-  ppobj *obj;
-  return (obj = pparray_get(array, index)) != NULL ? ppobj_rget_num(obj, *v) : 0;
-}
-
-ppname pparray_get_name (pparray *array, size_t index)
-{
-  ppobj *obj;
-  return (obj = pparray_get(array, index)) != NULL ? ppobj_get_name(obj) : NULL;
-}
-
-ppname pparray_rget_name (pparray *array, size_t index)
-{
-  ppobj *obj;
-  return (obj = pparray_get(array, index)) != NULL ? ppobj_rget_name(obj) : NULL;
-}
-
-ppstring pparray_get_string (pparray *array, size_t index)
-{
-  ppobj *obj;
-  return (obj = pparray_get(array, index)) != NULL ? ppobj_get_string(obj) : NULL;
-}
-
-ppstring pparray_rget_string (pparray *array, size_t index)
-{
-  ppobj *obj;
-  return (obj = pparray_get(array, index)) != NULL ? ppobj_rget_string(obj) : NULL;
-}
-
-pparray * pparray_get_array (pparray *array, size_t index)
-{
-  ppobj *obj;
-  return (obj = pparray_get(array, index)) != NULL ? ppobj_get_array(obj) : NULL;
-}
-
-pparray * pparray_rget_array (pparray *array, size_t index)
-{
-  ppobj *obj;
-  return (obj = pparray_get(array, index)) != NULL ? ppobj_rget_array(obj) : NULL;
-}
-
-ppdict * pparray_get_dict (pparray *array, size_t index)
-{
-  ppobj *obj;
-  return (obj = pparray_get(array, index)) != NULL ? ppobj_get_dict(obj) : NULL;
-}
-
-ppdict * pparray_rget_dict (pparray *array, size_t index)
-{
-  ppobj *obj;
-  return (obj = pparray_get(array, index)) != NULL ? ppobj_rget_dict(obj) : NULL;
-}
-
-/*
-ppstream * pparray_get_stream (pparray *array, size_t index)
-{
-  ppobj *obj;
-  return (obj = pparray_get(array, index)) != NULL ? ppobj_get_stream(obj) : NULL;
-}
-*/
-
-ppstream * pparray_rget_stream (pparray *array, size_t index)
-{
-  ppobj *obj;
-  return (obj = pparray_get(array, index)) != NULL ? ppobj_rget_stream(obj) : NULL;
-}
-
-ppref * pparray_get_ref (pparray *array, size_t index)
-{
-  ppobj *obj;
-  return (obj = pparray_get(array, index)) != NULL ? ppobj_get_ref(obj) : NULL;
-}
-
-ppref * pparray_rget_ref (pparray *array, size_t index)
-{
-  ppobj *obj;
-  return (obj = pparray_get(array, index)) != NULL ? ppobj_rget_ref(obj) : NULL;
-}
--- texlive-bin.orig/texk/web2c/luatexdir/luapplib/pparray.h
+++ /dev/null
@@ -1,7 +0,0 @@
-
-#ifndef PP_ARRAY_H
-#define PP_ARRAY_H
-
-pparray * pparray_create (const ppobj *stack, size_t size, ppheap **pheap);
-
-#endif
\ No newline at end of file
--- texlive-bin.orig/texk/web2c/luatexdir/luapplib/ppconf.h
+++ /dev/null
@@ -1,76 +0,0 @@
-
-#ifndef PP_CONF_H
-#define PP_CONF_H
-
-/*
-Aux flags:
-  PPDLL -- indicates a part of a shared library
-  PPEXE -- indicates a host program using shared library functions
-*/
-
-#if defined(_WIN32) || defined(_WIN64)
-#  ifdef PPDLL
-#    define PPAPI __declspec(dllexport)
-#    define PPDEF __declspec(dllexport)
-#  else
-#    ifdef PPEXE
-#      define PPAPI __declspec(dllimport)
-#      define PPDEF
-#    else
-#      define PPAPI
-#      define PPDEF
-#    endif
-#  endif
-#else
-#  define PPAPI
-#  define PPDEF
-#endif
-
-/* platform vs integers */
-
-#if defined(_WIN32) || defined(WIN32)
-#  ifdef _MSC_VER
-#    if defined(_M_64) || defined(_WIN64)
-#      define MSVC64
-#    else
-#      define MSVC32
-#    endif
-#  else
-#    if defined(__MINGW64__)
-#      define MINGW64
-#    else
-#      if defined(__MINGW32__)
-#        define MINGW32
-#      endif
-#    endif
-#  endif
-#endif
-
-#if defined(_WIN64) || defined(__MINGW32__)
-#  define PPINT64F "%I64d"
-#  define PPUINT64F "%I64u"
-#else
-#  define PPINT64F "%lld"
-#  define PPUINT64F "%llu"
-#endif
-
-#if defined(MSVC64)
-#  define PPINT(N) N##I64
-#  define PPUINT(N) N##UI64
-#  define PPINTF PPINT64F
-#  define PPUINTF PPUINT64F
-#elif defined(MINGW64)
-#  define PPINT(N) N##LL
-#  define PPUINT(N) N##ULL
-#  define PPINTF PPINT64F
-#  define PPUINTF PPUINT64F
-#else // 32bit or sane 64bit (LP64, where long is long indeed)
-#  define PPINT(N) N##L
-#  define PPUINT(N) N##UL
-#  define PPINTF "%ld"
-#  define PPUINTF "%lu"
-#endif
-
-#define PPSIZEF PPUINTF
-
-#endif
\ No newline at end of file
--- texlive-bin.orig/texk/web2c/luatexdir/luapplib/ppcrypt.c
+++ /dev/null
@@ -1,628 +0,0 @@
-
-#include "utilmd5.h"
-#include "utilsha.h"
-
-#include "pplib.h"
-
-/* crypt struct */
-
-#define CRYPT_AES  (1<<0)
-#define CRYPT_RC4  (1<<1)
-#define CRYPT_MD   (1<<2)
-#define CRYPT_NOMD (1<<3)
-
-static ppcrypt * ppcrypt_create (ppheap **pheap)
-{
-  ppcrypt *crypt;
-  crypt = (ppcrypt *)ppheap_take(pheap, sizeof(ppcrypt));
-  memset(crypt, 0, sizeof(ppcrypt));
-  return crypt;
-}
-
-static int ppcrypt_type (ppcrypt *crypt, ppname cryptname, ppuint *length, int *cryptflags)
-{
-  ppdict *filterdict;
-  ppname filtertype;
-  int cryptmd = 0, default256 = 0;
-
-  if (crypt->map == NULL || (filterdict = ppdict_rget_dict(crypt->map, cryptname)) == NULL)
-    return 0;
-  if ((filtertype = ppdict_get_name(filterdict, "CFM")) == NULL)
-    return 0;
-  *cryptflags = 0;
-  if (ppname_is(filtertype, "V2"))
-    *cryptflags |= CRYPT_RC4;
-  else if (ppname_is(filtertype, "AESV2"))
-    *cryptflags |= CRYPT_AES;
-  else if (ppname_is(filtertype, "AESV3"))
-    *cryptflags |= CRYPT_AES, default256 = 1;
-  else
-    return 0;
-  /* pdf spec page. 134: /Length is said to be optional bit-length of the key, but it seems to be a mistake, as Acrobat
-     produces /Length key with bytes lengths, opposite to /Length key of the main encrypt dict. */
-  if (length != NULL)
-    if (!ppdict_get_uint(filterdict, "Length", length))
-      *length = (*cryptflags & CRYPT_RC4) ? 5 : (default256 ? 32 : 16);
-  /* one of metadata flags is set iff there is an explicit EncryptMetadata key */
-  if (ppdict_get_bool(filterdict, "EncryptMetadata", &cryptmd))
-    *cryptflags |= (cryptmd ? CRYPT_MD : CRYPT_NOMD);
-  return 1;
-}
-
-static const uint8_t padding_string[] = {
-  0x28, 0xBF, 0x4E, 0x5E, 0x4E, 0x75, 0x8A, 0x41, 0x64, 0x00, 0x4E, 0x56, 0xFF, 0xFA, 0x01, 0x08,
-  0x2E, 0x2E, 0x00, 0xB6, 0xD0, 0x68, 0x3E, 0x80, 0x2F, 0x0C, 0xA9, 0xFE, 0x64, 0x53, 0x69, 0x7A
-};
-
-static void ppcrypt_set_userpass (ppcrypt *crypt, const void *userpass, size_t userpasslength)
-{
-  crypt->userpasslength = userpasslength > 32 ? 32 : userpasslength;
-  memcpy(crypt->userpass, userpass, crypt->userpasslength);
-  memcpy(crypt->userpass + crypt->userpasslength, padding_string, 32 - crypt->userpasslength);
-  crypt->flags |= PPCRYPT_USER_PASSWORD;
-}
-
-static void ppcrypt_set_ownerpass (ppcrypt *crypt, const void *ownerpass, size_t ownerpasslength)
-{
-  crypt->ownerpasslength = ownerpasslength > 32 ? 32 : ownerpasslength;
-  memcpy(crypt->ownerpass, ownerpass, crypt->ownerpasslength);
-  memcpy(crypt->ownerpass + crypt->ownerpasslength, padding_string, 32 - crypt->ownerpasslength);
-  crypt->flags |= PPCRYPT_OWNER_PASSWORD;
-}
-
-/* retrieving user password from owner password and owner key (variant < 5) */
-
-static void ppcrypt_retrieve_userpass (ppcrypt *crypt, const void *ownerkey, size_t ownerkeysize)
-{
-  uint8_t temp[16], rc4key[32], rc4key2[32];
-  uint8_t i;
-  ppuint k;
-
-  md5init();
-  md5add(crypt->ownerpass, 32);
-  md5put(rc4key);
-  if (crypt->algorithm_revision >= 3)
-  {
-    for (i = 0; i < 50; ++i)
-    {
-      pplib_md5(rc4key, 16, temp);
-      memcpy(rc4key, temp, 16);
-    }
-  }
-  rc4_decode_data(ownerkey, ownerkeysize, crypt->userpass, rc4key, crypt->filekeylength);
-  if (crypt->algorithm_revision >= 3)
-  {
-    for (i = 1; i <= 19; ++i)
-    {
-      for (k = 0; k < crypt->filekeylength; ++k)
-        rc4key2[k] = rc4key[k] ^ i;
-      rc4_decode_data(crypt->userpass, 32, crypt->userpass, rc4key2, crypt->filekeylength);
-    }
-  }
-  //crypt->userpasslength = 32;
-  for (crypt->userpasslength = 0; crypt->userpasslength < 32; ++crypt->userpasslength)
-    if (memcmp(&crypt->userpass[crypt->userpasslength], padding_string, 32 - crypt->userpasslength) == 0)
-      break;
-  crypt->flags |= PPCRYPT_USER_PASSWORD;
-}
-
-/* generating file key; pdf spec p. 125 */
-
-static void ppcrypt_filekey (ppcrypt *crypt, const void *ownerkey, size_t ownerkeysize, const void *id, size_t idsize)
-{
-  uint32_t p;
-  uint8_t permissions[4], temp[16];
-  int i;
-
-  md5init();
-  md5add(crypt->userpass, 32);
-  md5add(ownerkey, ownerkeysize);
-  p = (uint32_t)crypt->permissions;
-  permissions[0] = get_byte1(p);
-  permissions[1] = get_byte2(p);
-  permissions[2] = get_byte3(p);
-  permissions[3] = get_byte4(p);
-  md5add(permissions, 4);
-  md5add(id, idsize);
-  if (crypt->algorithm_revision >= 4 && (crypt->flags & PPCRYPT_NO_METADATA))
-    md5add("\xFF\xFF\xFF\xFF", 4);
-  md5put(crypt->filekey);
-  if (crypt->algorithm_revision >= 3)
-  {
-    for (i = 0; i < 50; ++i)
-    {
-      pplib_md5(crypt->filekey, (size_t)crypt->filekeylength, temp);
-      memcpy(crypt->filekey, temp, 16);
-    }
-  }
-}
-
-/* generating userkey for comparison with /U; requires a general file key and id; pdf spec page 126-127 */
-
-static void ppcrypt_userkey (ppcrypt *crypt, const void *id, size_t idsize, uint8_t *password_hash)
-{
-  uint8_t rc4key2[32];
-  uint8_t i;
-  ppuint k;
-
-  if (crypt->algorithm_revision <= 2)
-  {
-    rc4_encode_data(padding_string, 32, password_hash, crypt->filekey, crypt->filekeylength);
-  }
-  else
-  {
-    md5init();
-    md5add(padding_string, 32);
-    md5add(id, idsize);
-    md5put(password_hash);
-    rc4_encode_data(password_hash, 16, password_hash, crypt->filekey, crypt->filekeylength);
-    for (i = 1; i <= 19; ++i)
-    {
-      for (k = 0; k < crypt->filekeylength; ++k)
-        rc4key2[k] = crypt->filekey[k] ^ i;
-      rc4_encode_data(password_hash, 16, password_hash, rc4key2, crypt->filekeylength);
-    }
-    for (i = 16; i < 32; ++i)
-      password_hash[i] = password_hash[i - 16] ^ i; /* arbitrary 16-bytes padding */
-  }
-}
-
-/* validating /Perms key (pdf 1.7, /V 5 /R 5 crypt) */
-
-static const uint8_t nulliv[16] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}; /* AES-256 initialization vector */
-
-static ppcrypt_status ppcrypt_authenticate_perms (ppcrypt *crypt, ppstring perms)
-{ /* decode /Perms string overriding crypt setup (should match anyway) */
-  uint8_t permsdata[16];
-  //int64_t p;
-  //int i;
-
-  aes_decode_data(perms, ppstring_size(perms), permsdata, crypt->filekey, crypt->filekeylength, nulliv, AES_NULL_PADDING);
-
-  if (permsdata[9] != 'a' || permsdata[10] != 'd' || permsdata[11] != 'b')
-    return PPCRYPT_FAIL;
-
-  // do not update permissions flags; they seem to be different inside crypt string
-  //for (p = 0, i = 0; i < 8; ++i)
-  //  p = p + (permsdata[i] << (i << 3)); /* low order bytes first */
-  //crypt->permissions = (ppint)(int32_t)(p & 0x00000000FFFFFFFFLL); /* unset bits 33..64, treat as 32-bit signed int */
-
-  if (permsdata[8] == 'T')
-    crypt->flags &= ~PPCRYPT_NO_METADATA;
-  else if (permsdata[8] == 'F')
-    crypt->flags |= PPCRYPT_NO_METADATA;
-
-  return PPCRYPT_DONE;
-}
-
-ppcrypt_status ppdoc_crypt_init (ppdoc *pdf, const void *userpass, size_t userpasslength, const void *ownerpass, size_t ownerpasslength)
-{
-  ppcrypt *crypt;
-  ppdict *trailer, *encrypt;
-  ppobj *obj;
-  ppname name, *pkey;
-  ppstring userkey, ownerkey, userkey_e = NULL, ownerkey_e = NULL;
-  size_t hashlength;
-  pparray *idarray;
-  ppstring id = NULL, perms = NULL;
-  int cryptflags, encryptmd;
-  size_t strkeylength, stmkeylength;
-
-  uint8_t password_hash[32]; /* /U and /O are 48 bytes strings for AES-256, but here we use only 32 */
-  uint8_t *validation_salt, *key_salt;
-
-  /* Every xref could theoretically have a separate encryption info. Not clarified in pdf spec but it seems that the top
-     level xref encryption info is the one to be applied to all objects in all xrefs, including older. */
-  trailer = ppxref_trailer(pdf->xref);
-  if ((obj = ppdict_get_obj(trailer, "Encrypt")) == NULL)
-    return PPCRYPT_NONE;
-  /* Typically this is all done early, before loading body, so if /Encrypt is indirect reference, it points nothing. We have to load it here. */
-  obj = ppobj_preloaded(pdf, obj);
-  if (obj->type != PPDICT)
-    return PPCRYPT_FAIL;
-  encrypt = obj->dict;
-  for (ppdict_first(encrypt, pkey, obj); *pkey != NULL; ppdict_next(pkey, obj))
-    (void)ppobj_preloaded(pdf, obj);
-
-  if ((name = ppdict_get_name(encrypt, "Filter")) != NULL && !ppname_is(name, "Standard"))
-    return PPCRYPT_FAIL;
-
-  if ((crypt = pdf->crypt) == NULL)
-    crypt = pdf->crypt = ppcrypt_create(&pdf->heap);
-  if (!ppdict_get_uint(encrypt, "V", &crypt->algorithm_variant))
-    crypt->algorithm_variant = 0;
-  if (crypt->algorithm_variant < 1 || crypt->algorithm_variant > 5)
-    return PPCRYPT_FAIL;
-  if (!ppdict_get_uint(encrypt, "R", &crypt->algorithm_revision))
-    return PPCRYPT_FAIL;
-  if (crypt->algorithm_revision >= 3)
-    crypt->flags |= PPCRYPT_OBSCURITY;
-  if (!ppdict_get_int(encrypt, "P", &crypt->permissions))
-    return PPCRYPT_FAIL;
-  if ((userkey = ppdict_get_string(encrypt, "U")) == NULL || (ownerkey = ppdict_get_string(encrypt, "O")) == NULL)
-    return PPCRYPT_FAIL;
-  userkey = ppstring_decoded(userkey);
-  ownerkey = ppstring_decoded(ownerkey);
-  /* for some reason acrobat pads /O and /U to 127 bytes with NULL, so we don't check the exact length but ensure the minimal */
-  hashlength = crypt->algorithm_variant < 5 ? 32 : 48;
-  if (ppstring_size(userkey) < hashlength || ppstring_size(ownerkey) < hashlength)
-    return PPCRYPT_FAIL;
-  if (crypt->algorithm_variant < 5)
-  { // get first string from /ID (must not be ref)
-    if ((idarray = ppdict_get_array(trailer, "ID")) == NULL || (id = pparray_get_string(idarray, 0)) == NULL)
-      return PPCRYPT_FAIL;
-    id = ppstring_decoded(id);
-  }
-  else
-  {
-    if ((userkey_e = ppdict_get_string(encrypt, "UE")) == NULL || (ownerkey_e = ppdict_get_string(encrypt, "OE")) == NULL)
-      return PPCRYPT_FAIL;
-    userkey_e = ppstring_decoded(userkey_e);
-    ownerkey_e = ppstring_decoded(ownerkey_e);
-    if (ppstring_size(userkey_e) < 32 || ppstring_size(ownerkey_e) < 32)
-      return PPCRYPT_FAIL;
-    if ((perms = ppdict_get_string(encrypt, "Perms")) == NULL)
-      return PPCRYPT_FAIL;
-    perms = ppstring_decoded(perms);
-    if (ppstring_size(perms) != 16)
-      return PPCRYPT_FAIL;
-  }
-
-  switch (crypt->algorithm_revision)
-  {
-    case 1:
-      crypt->filekeylength = 5;
-      crypt->flags |= PPCRYPT_RC4;
-      break;
-    case 2: case 3:
-      if (ppdict_get_uint(encrypt, "Length", &crypt->filekeylength))
-        crypt->filekeylength >>= 3; /* 40..256 bits, 5..32 bytes*/
-      else
-        crypt->filekeylength = 5; /* 40 bits, 5 bytes */
-      crypt->flags |= PPCRYPT_RC4;
-      break;
-    case 4: case 5:
-      if ((crypt->map = ppdict_rget_dict(encrypt, "CF")) == NULL)
-        return PPCRYPT_FAIL;
-      for (ppdict_first(crypt->map, pkey, obj); *pkey != NULL; ppdict_next(pkey, obj))
-        (void)ppobj_preloaded(pdf, obj);
-      /* /EncryptMetadata relevant only for version >=4, may be also provided in crypt filter dictionary; which takes a precedence then?
-         we assume that if there is an explicit EncryptMetadata key, it overrides main encrypt dict flag or default flag (the default is true,
-         meaning that Metadata stream is encrypted as others) */
-      if (ppdict_get_bool(encrypt, "EncryptMetadata", &encryptmd) && !encryptmd)
-        crypt->flags |= PPCRYPT_NO_METADATA;
-
-      strkeylength = stmkeylength = 0;
-      /* streams filter */
-      if ((name = ppdict_get_name(encrypt, "StmF")) != NULL && ppcrypt_type(crypt, name, &stmkeylength, &cryptflags))
-      {
-        if (cryptflags & CRYPT_AES)
-          crypt->flags |= PPCRYPT_STREAM_AES;
-        else if (cryptflags & CRYPT_RC4)
-          crypt->flags |= PPCRYPT_STREAM_RC4;
-        if (cryptflags & CRYPT_NOMD)
-          crypt->flags |= PPCRYPT_NO_METADATA;
-        else if (cryptflags & CRYPT_MD)
-          crypt->flags &= ~PPCRYPT_NO_METADATA;
-      } /* else identity */
-      /* strings filter */
-      if ((name = ppdict_get_name(encrypt, "StrF")) != NULL && ppcrypt_type(crypt, name, &strkeylength, &cryptflags))
-      {
-        if (cryptflags & CRYPT_AES)
-          crypt->flags |= PPCRYPT_STRING_AES;
-        else if (cryptflags & CRYPT_RC4)
-          crypt->flags |= PPCRYPT_STRING_RC4;
-      } /* else identity */
-
-      /* /Length of encrypt dict is irrelevant here, theoretically every crypt filter may have own length... It means that we should
-         actually keep a different file key for streams and strings. But it leads to nonsense, as /U and /O entries refers to a single
-         keylength, without a distinction for strings/streams. So we have to assume /Length is consistent. To expose the limitation: */
-      if ((crypt->flags & PPCRYPT_STREAM) && (crypt->flags & PPCRYPT_STRING))
-        if (strkeylength != stmkeylength)
-          return PPCRYPT_FAIL;
-      crypt->filekeylength = stmkeylength ? stmkeylength : strkeylength;
-      if ((crypt->flags & PPCRYPT_STREAM) || (crypt->flags & PPCRYPT_STRING))
-        if (crypt->filekeylength == 0)
-          return PPCRYPT_FAIL;
-      break;
-    default:
-      return PPCRYPT_FAIL;
-  }
-
-  /* password */
-
-  if (userpass != NULL)
-  {
-    ppcrypt_set_userpass(crypt, userpass, userpasslength);
-  }
-  else if (ownerpass != NULL)
-  {
-    if (crypt->algorithm_variant < 5) // fetch user password from owner password
-      ppcrypt_retrieve_userpass(crypt, ownerkey, ppstring_size(ownerkey));
-    else                              // open the document using owner password
-      ppcrypt_set_ownerpass(crypt, ownerpass, ownerpasslength);
-  }
-  else
-  {
-    return PPCRYPT_FAIL;
-  }
-
-  if (crypt->algorithm_variant < 5)
-  { /* authenticate by comparing a generated vs present /U entry; depending on variant 16 or 32 bytes to compare */
-    ppcrypt_filekey(crypt, ownerkey, ppstring_size(ownerkey), id, ppstring_size(id));
-    ppcrypt_userkey(crypt, id, ppstring_size(id), password_hash); /* needs file key so comes after key generation */
-    if (memcmp(userkey, password_hash, (crypt->algorithm_revision >= 3 ? 16 : 32)) == 0)
-      return PPCRYPT_DONE;
-    return PPCRYPT_PASS;
-  }
-  if (crypt->flags & PPCRYPT_USER_PASSWORD)
-  {
-    validation_salt = (uint8_t *)userkey + 32;
-    key_salt = validation_salt + 8;
-    sha256init();
-    sha256add(crypt->userpass, crypt->userpasslength);
-    sha256add(validation_salt, 8);
-    sha256put(password_hash);
-    if (memcmp(userkey, password_hash, 32) != 0)
-      return PPCRYPT_PASS;
-    sha256init();
-    sha256add(crypt->userpass, crypt->userpasslength);
-    sha256add(key_salt, 8);
-    sha256put(password_hash);
-    aes_decode_data(userkey_e, 32, crypt->filekey, password_hash, 32, nulliv, AES_NULL_PADDING);
-    return ppcrypt_authenticate_perms(crypt, perms);
-  }
-  if (crypt->flags & PPCRYPT_OWNER_PASSWORD)
-  {
-    validation_salt = (uint8_t *)ownerkey + 32;
-    key_salt = validation_salt + 8;
-    sha256init();
-    sha256add(crypt->ownerpass, crypt->ownerpasslength);
-    sha256add(validation_salt, 8);
-    sha256add(userkey, 48);
-    sha256put(password_hash);
-    if (memcmp(ownerkey, password_hash, 32) != 0)
-      return PPCRYPT_PASS;
-    sha256init();
-    sha256add(crypt->ownerpass, crypt->ownerpasslength);
-    sha256add(key_salt, 8);
-    sha256add(userkey, 48);
-    sha256put(password_hash);
-    aes_decode_data(ownerkey_e, 32, crypt->filekey, password_hash, 32, nulliv, AES_NULL_PADDING);
-    return ppcrypt_authenticate_perms(crypt, perms);
-  }
-  return PPCRYPT_FAIL; // should never get here
-}
-
-/* decrypting strings */
-
-/*
-Since strings are generally rare, but might occur in mass (name trees). We generate decryption key when needed.
-All strings within the same reference are crypted with the same key. Both RC4 and AES algorithms expands
-the crypt key in some way and the result of expansion is the same for the same crypt key. Instead of recreating
-the ky for every string, we backup the initial decryption state.
-*/
-
-static void ppcrypt_strkey (ppcrypt *crypt, ppref *ref, int aes)
-{
-  if (crypt->cryptkeylength > 0)
-  { /* crypt key already generated, just reinitialize crypt states */
-    if (aes)
-    { /* aes codecs that works on c-strings do not modify aes_state flags at all, so we actually don't need to revitalize the state,
-         we only rewrite an initialization vector, which is modified during crypt procedure */
-    }
-    else
-    { /* rc4 crypt map is modified during crypt procedure, so here we reinitialize rc4 bytes map */
-      rc4_map_restore(&crypt->rc4state, &crypt->rc4copy);
-    }
-    return;
-  }
-
-  if (crypt->algorithm_variant < 5)
-  {
-    crypt->filekey[crypt->filekeylength + 0] = get_byte1(ref->number);
-    crypt->filekey[crypt->filekeylength + 1] = get_byte2(ref->number);
-    crypt->filekey[crypt->filekeylength + 2] = get_byte3(ref->number);
-    crypt->filekey[crypt->filekeylength + 3] = get_byte1(ref->version);
-    crypt->filekey[crypt->filekeylength + 4] = get_byte2(ref->version);
-
-    if (aes)
-    {
-      crypt->filekey[crypt->filekeylength + 5] = 0x73;
-      crypt->filekey[crypt->filekeylength + 6] = 0x41;
-      crypt->filekey[crypt->filekeylength + 7] = 0x6C;
-      crypt->filekey[crypt->filekeylength + 8] = 0x54;
-    }
-
-    pplib_md5(crypt->filekey, crypt->filekeylength + (aes ? 9 : 5), crypt->cryptkey);
-    crypt->cryptkeylength = crypt->filekeylength + 5 >= 16 ? 16 : crypt->filekeylength + 5;
-  }
-  else
-  {
-    memcpy(crypt->cryptkey, crypt->filekey, 32);
-    crypt->cryptkeylength = 32;
-  }
-
-  if (aes)
-  {
-    aes_decode_initialize(&crypt->aesstate, &crypt->aeskeyblock, crypt->cryptkey, crypt->cryptkeylength, NULL);
-    aes_pdf_mode(&crypt->aesstate);
-  }
-  else
-  {
-    rc4_state_initialize(&crypt->rc4state, &crypt->rc4map, crypt->cryptkey, crypt->cryptkeylength);
-    rc4_map_save(&crypt->rc4state, &crypt->rc4copy);
-  }
-}
-
-int ppstring_decrypt (ppcrypt *crypt, const void *input, size_t size, void *output, size_t *newsize)
-{
-  int aes, rc4;
-  aes = crypt->flags & PPCRYPT_STRING_AES;
-  rc4 = crypt->flags & PPCRYPT_STRING_RC4;
-  if (aes || rc4)
-  {
-    ppcrypt_strkey(crypt, crypt->ref, aes);
-    if (aes)
-      *newsize = aes_decode_state_data(&crypt->aesstate, input, size, output);
-    else // if (rc4)
-      *newsize = rc4_decode_state_data(&crypt->rc4state, input, size, output);
-    return 1;
-  }
-  return 0; // identity crypt
-}
-
-/* decrypting streams */
-
-/*
-Streams are decrypted everytime when accessing the stream data. We need to be able to get or make
-the key for decryption as long as the stream is alive. And to get the key we need the reference
-number and version, plus document crypt info. First thought was to keep the reference to which
-the stream belongs; stream->ref and accessing the crypt info stream->ref->xref->pdf->crypt.
-It would be ok as long as absolutelly nothing happens with ref and crypt. At some point pplib
-may drift into rewriting support, which would imply ref/xref/crypt/pdf structures modifications.
-So I feel better with generating a crypt key for every stream in encrypted document, paying a cost
-of pplib_md5() for all streams, not necessarily those actually read.
-
-Key generation is the same as for strings, but different for distinct encryption methods (rc4 vs aes).
-Since streams and strings might theoretically be encrypted with different filters. No reason to cacche
-decryption state here.
-*/
-
-static ppstring ppcrypt_stmkey (ppcrypt *crypt, ppref *ref, int aes, ppheap **pheap)
-{
-  ppstring cryptkeystring;
-  //if (crypt->cryptkeylength > 0)
-  //  return;
-
-  if (crypt->algorithm_variant < 5)
-  {
-    crypt->filekey[crypt->filekeylength + 0] = get_byte1(ref->number);
-    crypt->filekey[crypt->filekeylength + 1] = get_byte2(ref->number);
-    crypt->filekey[crypt->filekeylength + 2] = get_byte3(ref->number);
-    crypt->filekey[crypt->filekeylength + 3] = get_byte1(ref->version);
-    crypt->filekey[crypt->filekeylength + 4] = get_byte2(ref->version);
-
-    if (aes)
-    {
-      crypt->filekey[crypt->filekeylength + 5] = 0x73;
-      crypt->filekey[crypt->filekeylength + 6] = 0x41;
-      crypt->filekey[crypt->filekeylength + 7] = 0x6C;
-      crypt->filekey[crypt->filekeylength + 8] = 0x54;
-    }
-
-    pplib_md5(crypt->filekey, crypt->filekeylength + (aes ? 9 : 5), crypt->cryptkey);
-    crypt->cryptkeylength = crypt->filekeylength + 5 >= 16 ? 16 : crypt->filekeylength + 5; // how about 256bits AES??
-  }
-  else
-  { // we could actually generate this string once, but.. aes itself is way more expensive that we can earn here
-    memcpy(crypt->cryptkey, crypt->filekey, 32); // just for the record
-    crypt->cryptkeylength = 32;
-  }
-  cryptkeystring = ppstring_internal(crypt->cryptkey, crypt->cryptkeylength, pheap);
-  return ppstring_decoded(cryptkeystring);
-}
-
-void ppstream_info (ppstream *stream, ppdoc *pdf)
-{ // just after the stream creation
-  ppdict *dict;
-  ppobj *fobj, *pobj;
-  pparray *farray;
-  ppname fname, owncryptfilter, tname;
-  ppcrypt *crypt;
-  ppref *ref;
-  size_t i;
-  int owncrypt, cflags;
-
-  dict = stream->dict;
-	ppdict_rget_uint(dict, "Length", &stream->length);
-
-  if ((fobj = ppdict_get_obj(dict, "Filter")) != NULL)
-  {
-    fobj = ppobj_preloaded(pdf, fobj);
-    switch (fobj->type)
-    {
-      case PPNAME:
-        stream->flags |= PPSTREAM_COMPRESSED;
-        break;
-      case PPARRAY:
-        if (fobj->array->size > 0)
-          stream->flags |= PPSTREAM_COMPRESSED;
-        break;
-      default:
-        break;
-    }
-  }
-  if ((crypt = pdf->crypt) == NULL || (ref = crypt->ref) == NULL)
-    return;
-  owncrypt = 0;
-  owncryptfilter = NULL;
-  if (fobj != NULL)
-  {
-    if ((pobj = ppdict_get_obj(dict, "DecodeParms")) != NULL)
-      pobj = ppobj_preloaded(pdf, pobj);
-    switch (fobj->type)
-    {
-      case PPNAME:
-        if (ppname_is(fobj->name, "Crypt"))
-        {
-          owncrypt = 1;
-          if (pobj != NULL && pobj->type == PPDICT) // /Type /CryptFilterDecodeParms
-            owncryptfilter = ppdict_get_name(pobj->dict, "Name");
-        }
-        break;
-      case PPARRAY:
-        farray = fobj->array;
-        for (i = 0; i < farray->size; ++i)
-        {
-          if ((fname = pparray_get_name(farray, i)) != NULL && ppname_is(fname, "Crypt"))
-          {
-            owncrypt = 1;
-            if (pobj != NULL && pobj->type == PPARRAY && (pobj = pparray_get_obj(pobj->array, i)) != NULL)
-            {
-              pobj = ppobj_preloaded(pdf, pobj);
-              if (pobj != NULL && pobj->type == PPDICT) // /Type /CryptFilterDecodeParms
-                owncryptfilter = ppdict_get_name(pobj->dict, "Name");
-            }
-            break;
-          }
-        }
-        break;
-      default:
-        break;
-    }
-  }
-
-  if (owncrypt)
-  {
-    stream->flags |= PPSTREAM_ENCRYPTED_OWN;
-    /* Seems a common habit to use just /Crypt filter name with no params, which defaults to /Identity.
-       A real example with uncompressed metadata: <</Filter[/Crypt]/Length 4217/Subtype/XML/Type/Metadata>> */
-    if (owncryptfilter != NULL && !ppname_is(owncryptfilter, "Identity"))
-    {
-      if (crypt->map != NULL && ppcrypt_type(crypt, owncryptfilter, NULL, &cflags))
-      {
-        if (cflags & CRYPT_AES)
-          stream->flags |= PPSTREAM_ENCRYPTED_AES;
-        else if (cflags & CRYPT_RC4)
-          stream->flags |= PPSTREAM_ENCRYPTED_RC4;
-      }
-    }
-  }
-  else
-  {
-    if ((crypt->flags & PPCRYPT_NO_METADATA) && (tname = ppdict_get_name(dict, "Type")) != NULL && ppname_is(tname, "Metadata"))
-      ; /* special treatment of metadata stream; we assume that explicit /Filter /Crypt setup overrides document level setup of EncryptMetadata. */
-    else
-    {
-      if (crypt->flags & PPCRYPT_STREAM_RC4)
-        stream->flags |= PPSTREAM_ENCRYPTED_RC4;
-      else if (crypt->flags & PPCRYPT_STREAM_AES)
-        stream->flags |= PPSTREAM_ENCRYPTED_AES;
-    }
-  }
-
-  /* finally, if the stream is encrypted with non-identity crypt (implicit or explicit), make and save the crypt key */
-  if (stream->flags & PPSTREAM_ENCRYPTED)
-    stream->cryptkey = ppcrypt_stmkey(crypt, ref, ((stream->flags & PPSTREAM_ENCRYPTED_AES) != 0), &pdf->heap);
-}
--- texlive-bin.orig/texk/web2c/luatexdir/luapplib/ppcrypt.c.orig
+++ /dev/null
@@ -1,628 +0,0 @@
-
-#include "utilmd5.h"
-#include "utilsha.h"
-
-#include "pplib.h"
-
-/* crypt struct */
-
-#define CRYPT_AES  (1<<0)
-#define CRYPT_RC4  (1<<1)
-#define CRYPT_MD   (1<<2)
-#define CRYPT_NOMD (1<<3)
-
-static ppcrypt * ppcrypt_create (ppheap **pheap)
-{
-  ppcrypt *crypt;
-  crypt = ppheap_take(pheap, sizeof(ppcrypt));
-  memset(crypt, 0, sizeof(ppcrypt));
-  return crypt;
-}
-
-static int ppcrypt_type (ppcrypt *crypt, ppname cryptname, ppuint *length, int *cryptflags)
-{
-  ppdict *filterdict;
-  ppname filtertype;
-  int cryptmd = 0, default256 = 0;
-
-  if (crypt->map == NULL || (filterdict = ppdict_rget_dict(crypt->map, cryptname)) == NULL)
-    return 0;
-  if ((filtertype = ppdict_get_name(filterdict, "CFM")) == NULL)
-    return 0;
-  *cryptflags = 0;
-  if (ppname_is(filtertype, "V2"))
-    *cryptflags |= CRYPT_RC4;
-  else if (ppname_is(filtertype, "AESV2"))
-    *cryptflags |= CRYPT_AES;
-  else if (ppname_is(filtertype, "AESV3"))
-    *cryptflags |= CRYPT_AES, default256 = 1;
-  else
-    return 0;
-  /* pdf spec page. 134: /Length is said to be optional bit-length of the key, but it seems to be a mistake, as Acrobat
-     produces /Length key with bytes lengths, opposite to /Length key of the main encrypt dict. */
-  if (length != NULL)
-    if (!ppdict_get_uint(filterdict, "Length", length))
-      *length = (*cryptflags & CRYPT_RC4) ? 5 : (default256 ? 32 : 16);
-  /* one of metadata flags is set iff there is an explicit EncryptMetadata key */
-  if (ppdict_get_bool(filterdict, "EncryptMetadata", &cryptmd))
-    *cryptflags |= (cryptmd ? CRYPT_MD : CRYPT_NOMD);
-  return 1;
-}
-
-static const uint8_t padding_string[] = {
-  0x28, 0xBF, 0x4E, 0x5E, 0x4E, 0x75, 0x8A, 0x41, 0x64, 0x00, 0x4E, 0x56, 0xFF, 0xFA, 0x01, 0x08,
-  0x2E, 0x2E, 0x00, 0xB6, 0xD0, 0x68, 0x3E, 0x80, 0x2F, 0x0C, 0xA9, 0xFE, 0x64, 0x53, 0x69, 0x7A
-};
-
-static void ppcrypt_set_userpass (ppcrypt *crypt, const void *userpass, size_t userpasslength)
-{
-  crypt->userpasslength = userpasslength > 32 ? 32 : userpasslength;
-  memcpy(crypt->userpass, userpass, crypt->userpasslength);
-  memcpy(crypt->userpass + crypt->userpasslength, padding_string, 32 - crypt->userpasslength);
-  crypt->flags |= PPCRYPT_USER_PASSWORD;
-}
-
-static void ppcrypt_set_ownerpass (ppcrypt *crypt, const void *ownerpass, size_t ownerpasslength)
-{
-  crypt->ownerpasslength = ownerpasslength > 32 ? 32 : ownerpasslength;
-  memcpy(crypt->ownerpass, ownerpass, crypt->ownerpasslength);
-  memcpy(crypt->ownerpass + crypt->ownerpasslength, padding_string, 32 - crypt->ownerpasslength);
-  crypt->flags |= PPCRYPT_OWNER_PASSWORD;
-}
-
-/* retrieving user password from owner password and owner key (variant < 5) */
-
-static void ppcrypt_retrieve_userpass (ppcrypt *crypt, const void *ownerkey, size_t ownerkeysize)
-{
-  uint8_t temp[16], rc4key[32], rc4key2[32];
-  uint8_t i;
-  ppuint k;
-
-  md5init();
-  md5add(crypt->ownerpass, 32);
-  md5put(rc4key);
-  if (crypt->algorithm_revision >= 3)
-  {
-    for (i = 0; i < 50; ++i)
-    {
-      md5(rc4key, 16, temp);
-      memcpy(rc4key, temp, 16);
-    }
-  }
-  rc4_decode_data(ownerkey, ownerkeysize, crypt->userpass, rc4key, crypt->filekeylength);
-  if (crypt->algorithm_revision >= 3)
-  {
-    for (i = 1; i <= 19; ++i)
-    {
-      for (k = 0; k < crypt->filekeylength; ++k)
-        rc4key2[k] = rc4key[k] ^ i;
-      rc4_decode_data(crypt->userpass, 32, crypt->userpass, rc4key2, crypt->filekeylength);
-    }
-  }
-  //crypt->userpasslength = 32;
-  for (crypt->userpasslength = 0; crypt->userpasslength < 32; ++crypt->userpasslength)
-    if (memcmp(&crypt->userpass[crypt->userpasslength], padding_string, 32 - crypt->userpasslength) == 0)
-      break;
-  crypt->flags |= PPCRYPT_USER_PASSWORD;
-}
-
-/* generating file key; pdf spec p. 125 */
-
-static void ppcrypt_filekey (ppcrypt *crypt, const void *ownerkey, size_t ownerkeysize, const void *id, size_t idsize)
-{
-  uint32_t p;
-  uint8_t permissions[4], temp[16];
-  int i;
-
-  md5init();
-  md5add(crypt->userpass, 32);
-  md5add(ownerkey, ownerkeysize);
-  p = (uint32_t)crypt->permissions;
-  permissions[0] = get_byte1(p);
-  permissions[1] = get_byte2(p);
-  permissions[2] = get_byte3(p);
-  permissions[3] = get_byte4(p);
-  md5add(permissions, 4);
-  md5add(id, idsize);
-  if (crypt->algorithm_revision >= 4 && (crypt->flags & PPCRYPT_NO_METADATA))
-    md5add("\xFF\xFF\xFF\xFF", 4);
-  md5put(crypt->filekey);
-  if (crypt->algorithm_revision >= 3)
-  {
-    for (i = 0; i < 50; ++i)
-    {
-      md5(crypt->filekey, (size_t)crypt->filekeylength, temp);
-      memcpy(crypt->filekey, temp, 16);
-    }
-  }
-}
-
-/* generating userkey for comparison with /U; requires a general file key and id; pdf spec page 126-127 */
-
-static void ppcrypt_userkey (ppcrypt *crypt, const void *id, size_t idsize, uint8_t *password_hash)
-{
-  uint8_t rc4key2[32];
-  uint8_t i;
-  ppuint k;
-
-  if (crypt->algorithm_revision <= 2)
-  {
-    rc4_encode_data(padding_string, 32, password_hash, crypt->filekey, crypt->filekeylength);
-  }
-  else
-  {
-    md5init();
-    md5add(padding_string, 32);
-    md5add(id, idsize);
-    md5put(password_hash);
-    rc4_encode_data(password_hash, 16, password_hash, crypt->filekey, crypt->filekeylength);
-    for (i = 1; i <= 19; ++i)
-    {
-      for (k = 0; k < crypt->filekeylength; ++k)
-        rc4key2[k] = crypt->filekey[k] ^ i;
-      rc4_encode_data(password_hash, 16, password_hash, rc4key2, crypt->filekeylength);
-    }
-    for (i = 16; i < 32; ++i)
-      password_hash[i] = password_hash[i - 16] ^ i; /* arbitrary 16-bytes padding */
-  }
-}
-
-/* validating /Perms key (pdf 1.7, /V 5 /R 5 crypt) */
-
-static const uint8_t nulliv[16] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}; /* AES-256 initialization vector */
-
-static ppcrypt_status ppcrypt_authenticate_perms (ppcrypt *crypt, ppstring perms)
-{ /* decode /Perms string overriding crypt setup (should match anyway) */
-  uint8_t permsdata[16];
-  //int64_t p;
-  //int i;
-
-  aes_decode_data(perms, ppstring_size(perms), permsdata, crypt->filekey, crypt->filekeylength, nulliv, AES_NULL_PADDING);
-
-  if (permsdata[9] != 'a' || permsdata[10] != 'd' || permsdata[11] != 'b')
-    return PPCRYPT_FAIL;
-
-  // do not update permissions flags; they seem to be different inside crypt string
-  //for (p = 0, i = 0; i < 8; ++i)
-  //  p = p + (permsdata[i] << (i << 3)); /* low order bytes first */
-  //crypt->permissions = (ppint)(int32_t)(p & 0x00000000FFFFFFFFLL); /* unset bits 33..64, treat as 32-bit signed int */
-
-  if (permsdata[8] == 'T')
-    crypt->flags &= ~PPCRYPT_NO_METADATA;
-  else if (permsdata[8] == 'F')
-    crypt->flags |= PPCRYPT_NO_METADATA;
-
-  return PPCRYPT_DONE;
-}
-
-ppcrypt_status ppdoc_crypt_init (ppdoc *pdf, const void *userpass, size_t userpasslength, const void *ownerpass, size_t ownerpasslength)
-{
-  ppcrypt *crypt;
-  ppdict *trailer, *encrypt;
-  ppobj *obj;
-  ppname name, *pkey;
-  ppstring userkey, ownerkey, userkey_e = NULL, ownerkey_e = NULL;
-  size_t hashlength;
-  pparray *idarray;
-  ppstring id = NULL, perms = NULL;
-  int cryptflags, encryptmd;
-  size_t strkeylength, stmkeylength;
-
-  uint8_t password_hash[32]; /* /U and /O are 48 bytes strings for AES-256, but here we use only 32 */
-  uint8_t *validation_salt, *key_salt;
-
-  /* Every xref could theoretically have a separate encryption info. Not clarified in pdf spec but it seems that the top
-     level xref encryption info is the one to be applied to all objects in all xrefs, including older. */
-  trailer = ppxref_trailer(pdf->xref);
-  if ((obj = ppdict_get_obj(trailer, "Encrypt")) == NULL)
-    return PPCRYPT_NONE;
-  /* Typically this is all done early, before loading body, so if /Encrypt is indirect reference, it points nothing. We have to load it here. */
-  obj = ppobj_preloaded(pdf, obj);
-  if (obj->type != PPDICT)
-    return PPCRYPT_FAIL;
-  encrypt = obj->dict;
-  for (ppdict_first(encrypt, pkey, obj); *pkey != NULL; ppdict_next(pkey, obj))
-    (void)ppobj_preloaded(pdf, obj);
-
-  if ((name = ppdict_get_name(encrypt, "Filter")) != NULL && !ppname_is(name, "Standard"))
-    return PPCRYPT_FAIL;
-
-  if ((crypt = pdf->crypt) == NULL)
-    crypt = pdf->crypt = ppcrypt_create(&pdf->heap);
-  if (!ppdict_get_uint(encrypt, "V", &crypt->algorithm_variant))
-    crypt->algorithm_variant = 0;
-  if (crypt->algorithm_variant < 1 || crypt->algorithm_variant > 5)
-    return PPCRYPT_FAIL;
-  if (!ppdict_get_uint(encrypt, "R", &crypt->algorithm_revision))
-    return PPCRYPT_FAIL;
-  if (crypt->algorithm_revision >= 3)
-    crypt->flags |= PPCRYPT_OBSCURITY;
-  if (!ppdict_get_int(encrypt, "P", &crypt->permissions))
-    return PPCRYPT_FAIL;
-  if ((userkey = ppdict_get_string(encrypt, "U")) == NULL || (ownerkey = ppdict_get_string(encrypt, "O")) == NULL)
-    return PPCRYPT_FAIL;
-  userkey = ppstring_decoded(userkey);
-  ownerkey = ppstring_decoded(ownerkey);
-  /* for some reason acrobat pads /O and /U to 127 bytes with NULL, so we don't check the exact length but ensure the minimal */
-  hashlength = crypt->algorithm_variant < 5 ? 32 : 48;
-  if (ppstring_size(userkey) < hashlength || ppstring_size(ownerkey) < hashlength)
-    return PPCRYPT_FAIL;
-  if (crypt->algorithm_variant < 5)
-  { // get first string from /ID (must not be ref)
-    if ((idarray = ppdict_get_array(trailer, "ID")) == NULL || (id = pparray_get_string(idarray, 0)) == NULL)
-      return PPCRYPT_FAIL;
-    id = ppstring_decoded(id);
-  }
-  else
-  {
-    if ((userkey_e = ppdict_get_string(encrypt, "UE")) == NULL || (ownerkey_e = ppdict_get_string(encrypt, "OE")) == NULL)
-      return PPCRYPT_FAIL;
-    userkey_e = ppstring_decoded(userkey_e);
-    ownerkey_e = ppstring_decoded(ownerkey_e);
-    if (ppstring_size(userkey_e) < 32 || ppstring_size(ownerkey_e) < 32)
-      return PPCRYPT_FAIL;
-    if ((perms = ppdict_get_string(encrypt, "Perms")) == NULL)
-      return PPCRYPT_FAIL;
-    perms = ppstring_decoded(perms);
-    if (ppstring_size(perms) != 16)
-      return PPCRYPT_FAIL;
-  }
-
-  switch (crypt->algorithm_revision)
-  {
-    case 1:
-      crypt->filekeylength = 5;
-      crypt->flags |= PPCRYPT_RC4;
-      break;
-    case 2: case 3:
-      if (ppdict_get_uint(encrypt, "Length", &crypt->filekeylength))
-        crypt->filekeylength >>= 3; /* 40..256 bits, 5..32 bytes*/
-      else
-        crypt->filekeylength = 5; /* 40 bits, 5 bytes */
-      crypt->flags |= PPCRYPT_RC4;
-      break;
-    case 4: case 5:
-      if ((crypt->map = ppdict_rget_dict(encrypt, "CF")) == NULL)
-        return PPCRYPT_FAIL;
-      for (ppdict_first(crypt->map, pkey, obj); *pkey != NULL; ppdict_next(pkey, obj))
-        (void)ppobj_preloaded(pdf, obj);
-      /* /EncryptMetadata relevant only for version >=4, may be also provided in crypt filter dictionary; which takes a precedence then?
-         we assume that if there is an explicit EncryptMetadata key, it overrides main encrypt dict flag or default flag (the default is true,
-         meaning that Metadata stream is encrypted as others) */
-      if (ppdict_get_bool(encrypt, "EncryptMetadata", &encryptmd) && !encryptmd)
-        crypt->flags |= PPCRYPT_NO_METADATA;
-
-      strkeylength = stmkeylength = 0;
-      /* streams filter */
-      if ((name = ppdict_get_name(encrypt, "StmF")) != NULL && ppcrypt_type(crypt, name, &stmkeylength, &cryptflags))
-      {
-        if (cryptflags & CRYPT_AES)
-          crypt->flags |= PPCRYPT_STREAM_AES;
-        else if (cryptflags & CRYPT_RC4)
-          crypt->flags |= PPCRYPT_STREAM_RC4;
-        if (cryptflags & CRYPT_NOMD)
-          crypt->flags |= PPCRYPT_NO_METADATA;
-        else if (cryptflags & CRYPT_MD)
-          crypt->flags &= ~PPCRYPT_NO_METADATA;
-      } /* else identity */
-      /* strings filter */
-      if ((name = ppdict_get_name(encrypt, "StrF")) != NULL && ppcrypt_type(crypt, name, &strkeylength, &cryptflags))
-      {
-        if (cryptflags & CRYPT_AES)
-          crypt->flags |= PPCRYPT_STRING_AES;
-        else if (cryptflags & CRYPT_RC4)
-          crypt->flags |= PPCRYPT_STRING_RC4;
-      } /* else identity */
-
-      /* /Length of encrypt dict is irrelevant here, theoretically every crypt filter may have own length... It means that we should
-         actually keep a different file key for streams and strings. But it leads to nonsense, as /U and /O entries refers to a single
-         keylength, without a distinction for strings/streams. So we have to assume /Length is consistent. To expose the limitation: */
-      if ((crypt->flags & PPCRYPT_STREAM) && (crypt->flags & PPCRYPT_STRING))
-        if (strkeylength != stmkeylength)
-          return PPCRYPT_FAIL;
-      crypt->filekeylength = stmkeylength ? stmkeylength : strkeylength;
-      if ((crypt->flags & PPCRYPT_STREAM) || (crypt->flags & PPCRYPT_STRING))
-        if (crypt->filekeylength == 0)
-          return PPCRYPT_FAIL;
-      break;
-    default:
-      return PPCRYPT_FAIL;
-  }
-
-  /* password */
-
-  if (userpass != NULL)
-  {
-    ppcrypt_set_userpass(crypt, userpass, userpasslength);
-  }
-  else if (ownerpass != NULL)
-  {
-    if (crypt->algorithm_variant < 5) // fetch user password from owner password
-      ppcrypt_retrieve_userpass(crypt, ownerkey, ppstring_size(ownerkey));
-    else                              // open the document using owner password
-      ppcrypt_set_ownerpass(crypt, ownerpass, ownerpasslength);
-  }
-  else
-  {
-    return PPCRYPT_FAIL;
-  }
-
-  if (crypt->algorithm_variant < 5)
-  { /* authenticate by comparing a generated vs present /U entry; depending on variant 16 or 32 bytes to compare */
-    ppcrypt_filekey(crypt, ownerkey, ppstring_size(ownerkey), id, ppstring_size(id));
-    ppcrypt_userkey(crypt, id, ppstring_size(id), password_hash); /* needs file key so comes after key generation */
-    if (memcmp(userkey, password_hash, (crypt->algorithm_revision >= 3 ? 16 : 32)) == 0)
-      return PPCRYPT_DONE;
-    return PPCRYPT_PASS;
-  }
-  if (crypt->flags & PPCRYPT_USER_PASSWORD)
-  {
-    validation_salt = (uint8_t *)userkey + 32;
-    key_salt = validation_salt + 8;
-    sha256init();
-    sha256add(crypt->userpass, crypt->userpasslength);
-    sha256add(validation_salt, 8);
-    sha256put(password_hash);
-    if (memcmp(userkey, password_hash, 32) != 0)
-      return PPCRYPT_PASS;
-    sha256init();
-    sha256add(crypt->userpass, crypt->userpasslength);
-    sha256add(key_salt, 8);
-    sha256put(password_hash);
-    aes_decode_data(userkey_e, 32, crypt->filekey, password_hash, 32, nulliv, AES_NULL_PADDING);
-    return ppcrypt_authenticate_perms(crypt, perms);
-  }
-  if (crypt->flags & PPCRYPT_OWNER_PASSWORD)
-  {
-    validation_salt = (uint8_t *)ownerkey + 32;
-    key_salt = validation_salt + 8;
-    sha256init();
-    sha256add(crypt->ownerpass, crypt->ownerpasslength);
-    sha256add(validation_salt, 8);
-    sha256add(userkey, 48);
-    sha256put(password_hash);
-    if (memcmp(ownerkey, password_hash, 32) != 0)
-      return PPCRYPT_PASS;
-    sha256init();
-    sha256add(crypt->ownerpass, crypt->ownerpasslength);
-    sha256add(key_salt, 8);
-    sha256add(userkey, 48);
-    sha256put(password_hash);
-    aes_decode_data(ownerkey_e, 32, crypt->filekey, password_hash, 32, nulliv, AES_NULL_PADDING);
-    return ppcrypt_authenticate_perms(crypt, perms);
-  }
-  return PPCRYPT_FAIL; // should never get here
-}
-
-/* decrypting strings */
-
-/*
-Since strings are generally rare, but might occur in mass (name trees). We generate decryption key when needed.
-All strings within the same reference are crypted with the same key. Both RC4 and AES algorithms expands
-the crypt key in some way and the result of expansion is the same for the same crypt key. Instead of recreating
-the ky for every string, we backup the initial decryption state.
-*/
-
-static void ppcrypt_strkey (ppcrypt *crypt, ppref *ref, int aes)
-{
-  if (crypt->cryptkeylength > 0)
-  { /* crypt key already generated, just reinitialize crypt states */
-    if (aes)
-    { /* aes codecs that works on c-strings do not modify aes_state flags at all, so we actually don't need to revitalize the state,
-         we only rewrite an initialization vector, which is modified during crypt procedure */
-    }
-    else
-    { /* rc4 crypt map is modified during crypt procedure, so here we reinitialize rc4 bytes map */
-      rc4_map_restore(&crypt->rc4state, &crypt->rc4copy);
-    }
-    return;
-  }
-
-  if (crypt->algorithm_variant < 5)
-  {
-    crypt->filekey[crypt->filekeylength + 0] = get_byte1(ref->number);
-    crypt->filekey[crypt->filekeylength + 1] = get_byte2(ref->number);
-    crypt->filekey[crypt->filekeylength + 2] = get_byte3(ref->number);
-    crypt->filekey[crypt->filekeylength + 3] = get_byte1(ref->version);
-    crypt->filekey[crypt->filekeylength + 4] = get_byte2(ref->version);
-
-    if (aes)
-    {
-      crypt->filekey[crypt->filekeylength + 5] = 0x73;
-      crypt->filekey[crypt->filekeylength + 6] = 0x41;
-      crypt->filekey[crypt->filekeylength + 7] = 0x6C;
-      crypt->filekey[crypt->filekeylength + 8] = 0x54;
-    }
-
-    md5(crypt->filekey, crypt->filekeylength + (aes ? 9 : 5), crypt->cryptkey);
-    crypt->cryptkeylength = crypt->filekeylength + 5 >= 16 ? 16 : crypt->filekeylength + 5;
-  }
-  else
-  {
-    memcpy(crypt->cryptkey, crypt->filekey, 32);
-    crypt->cryptkeylength = 32;
-  }
-
-  if (aes)
-  {
-    aes_decode_initialize(&crypt->aesstate, &crypt->aeskeyblock, crypt->cryptkey, crypt->cryptkeylength, NULL);
-    aes_pdf_mode(&crypt->aesstate);
-  }
-  else
-  {
-    rc4_state_initialize(&crypt->rc4state, &crypt->rc4map, crypt->cryptkey, crypt->cryptkeylength);
-    rc4_map_save(&crypt->rc4state, &crypt->rc4copy);
-  }
-}
-
-int ppstring_decrypt (ppcrypt *crypt, const void *input, size_t size, void *output, size_t *newsize)
-{
-  int aes, rc4;
-  aes = crypt->flags & PPCRYPT_STRING_AES;
-  rc4 = crypt->flags & PPCRYPT_STRING_RC4;
-  if (aes || rc4)
-  {
-    ppcrypt_strkey(crypt, crypt->ref, aes);
-    if (aes)
-      *newsize = aes_decode_state_data(&crypt->aesstate, input, size, output);
-    else // if (rc4)
-      *newsize = rc4_decode_state_data(&crypt->rc4state, input, size, output);
-    return 1;
-  }
-  return 0; // identity crypt
-}
-
-/* decrypting streams */
-
-/*
-Streams are decrypted everytime when accessing the stream data. We need to be able to get or make
-the key for decryption as long as the stream is alive. And to get the key we need the reference
-number and version, plus document crypt info. First thought was to keep the reference to which
-the stream belongs; stream->ref and accessing the crypt info stream->ref->xref->pdf->crypt.
-It would be ok as long as absolutelly nothing happens with ref and crypt. At some point pplib
-may drift into rewriting support, which would imply ref/xref/crypt/pdf structures modifications.
-So I feel better with generating a crypt key for every stream in encrypted document, paying a cost
-of md5() for all streams, not necessarily those actually read.
-
-Key generation is the same as for strings, but different for distinct encryption methods (rc4 vs aes).
-Since streams and strings might theoretically be encrypted with different filters. No reason to cacche
-decryption state here.
-*/
-
-static ppstring ppcrypt_stmkey (ppcrypt *crypt, ppref *ref, int aes, ppheap **pheap)
-{
-  ppstring cryptkeystring;
-  //if (crypt->cryptkeylength > 0)
-  //  return;
-
-  if (crypt->algorithm_variant < 5)
-  {
-    crypt->filekey[crypt->filekeylength + 0] = get_byte1(ref->number);
-    crypt->filekey[crypt->filekeylength + 1] = get_byte2(ref->number);
-    crypt->filekey[crypt->filekeylength + 2] = get_byte3(ref->number);
-    crypt->filekey[crypt->filekeylength + 3] = get_byte1(ref->version);
-    crypt->filekey[crypt->filekeylength + 4] = get_byte2(ref->version);
-
-    if (aes)
-    {
-      crypt->filekey[crypt->filekeylength + 5] = 0x73;
-      crypt->filekey[crypt->filekeylength + 6] = 0x41;
-      crypt->filekey[crypt->filekeylength + 7] = 0x6C;
-      crypt->filekey[crypt->filekeylength + 8] = 0x54;
-    }
-
-    md5(crypt->filekey, crypt->filekeylength + (aes ? 9 : 5), crypt->cryptkey);
-    crypt->cryptkeylength = crypt->filekeylength + 5 >= 16 ? 16 : crypt->filekeylength + 5; // how about 256bits AES??
-  }
-  else
-  { // we could actually generate this string once, but.. aes itself is way more expensive that we can earn here
-    memcpy(crypt->cryptkey, crypt->filekey, 32); // just for the record
-    crypt->cryptkeylength = 32;
-  }
-  cryptkeystring = ppstring_internal(crypt->cryptkey, crypt->cryptkeylength, pheap);
-  return ppstring_decoded(cryptkeystring);
-}
-
-void ppstream_info (ppstream *stream, ppdoc *pdf)
-{ // just after the stream creation
-  ppdict *dict;
-  ppobj *fobj, *pobj;
-  pparray *farray;
-  ppname fname, owncryptfilter, tname;
-  ppcrypt *crypt;
-  ppref *ref;
-  size_t i;
-  int owncrypt, cflags;
-
-  dict = stream->dict;
-	ppdict_rget_uint(dict, "Length", &stream->length);
-
-  if ((fobj = ppdict_get_obj(dict, "Filter")) != NULL)
-  {
-    fobj = ppobj_preloaded(pdf, fobj);
-    switch (fobj->type)
-    {
-      case PPNAME:
-        stream->flags |= PPSTREAM_COMPRESSED;
-        break;
-      case PPARRAY:
-        if (fobj->array->size > 0)
-          stream->flags |= PPSTREAM_COMPRESSED;
-        break;
-      default:
-        break;
-    }
-  }
-  if ((crypt = pdf->crypt) == NULL || (ref = crypt->ref) == NULL)
-    return;
-  owncrypt = 0;
-  owncryptfilter = NULL;
-  if (fobj != NULL)
-  {
-    if ((pobj = ppdict_get_obj(dict, "DecodeParms")) != NULL)
-      pobj = ppobj_preloaded(pdf, pobj);
-    switch (fobj->type)
-    {
-      case PPNAME:
-        if (ppname_is(fobj->name, "Crypt"))
-        {
-          owncrypt = 1;
-          if (pobj != NULL && pobj->type == PPDICT) // /Type /CryptFilterDecodeParms
-            owncryptfilter = ppdict_get_name(pobj->dict, "Name");
-        }
-        break;
-      case PPARRAY:
-        farray = fobj->array;
-        for (i = 0; i < farray->size; ++i)
-        {
-          if ((fname = pparray_get_name(farray, i)) != NULL && ppname_is(fname, "Crypt"))
-          {
-            owncrypt = 1;
-            if (pobj != NULL && pobj->type == PPARRAY && (pobj = pparray_get_obj(pobj->array, i)) != NULL)
-            {
-              pobj = ppobj_preloaded(pdf, pobj);
-              if (pobj != NULL && pobj->type == PPDICT) // /Type /CryptFilterDecodeParms
-                owncryptfilter = ppdict_get_name(pobj->dict, "Name");
-            }
-            break;
-          }
-        }
-        break;
-      default:
-        break;
-    }
-  }
-
-  if (owncrypt)
-  {
-    stream->flags |= PPSTREAM_ENCRYPTED_OWN;
-    /* Seems a common habit to use just /Crypt filter name with no params, which defaults to /Identity.
-       A real example with uncompressed metadata: <</Filter[/Crypt]/Length 4217/Subtype/XML/Type/Metadata>> */
-    if (owncryptfilter != NULL && !ppname_is(owncryptfilter, "Identity"))
-    {
-      if (crypt->map != NULL && ppcrypt_type(crypt, owncryptfilter, NULL, &cflags))
-      {
-        if (cflags & CRYPT_AES)
-          stream->flags |= PPSTREAM_ENCRYPTED_AES;
-        else if (cflags & CRYPT_RC4)
-          stream->flags |= PPSTREAM_ENCRYPTED_RC4;
-      }
-    }
-  }
-  else
-  {
-    if ((crypt->flags & PPCRYPT_NO_METADATA) && (tname = ppdict_get_name(dict, "Type")) != NULL && ppname_is(tname, "Metadata"))
-      ; /* special treatment of metadata stream; we assume that explicit /Filter /Crypt setup overrides document level setup of EncryptMetadata. */
-    else
-    {
-      if (crypt->flags & PPCRYPT_STREAM_RC4)
-        stream->flags |= PPSTREAM_ENCRYPTED_RC4;
-      else if (crypt->flags & PPCRYPT_STREAM_AES)
-        stream->flags |= PPSTREAM_ENCRYPTED_AES;
-    }
-  }
-
-  /* finally, if the stream is encrypted with non-identity crypt (implicit or explicit), make and save the crypt key */
-  if (stream->flags & PPSTREAM_ENCRYPTED)
-    stream->cryptkey = ppcrypt_stmkey(crypt, ref, ((stream->flags & PPSTREAM_ENCRYPTED_AES) != 0), &pdf->heap);
-}
--- texlive-bin.orig/texk/web2c/luatexdir/luapplib/ppcrypt.h
+++ /dev/null
@@ -1,61 +0,0 @@
-
-#ifndef PP_CRYPT_H
-#define PP_CRYPT_H
-
-#include "ppfilter.h"
-#include "utilcrypt.h"
-#include "utilcryptdef.h"
-
-typedef struct {
-  ppuint algorithm_variant;  /* /V entry of encrypt dict */
-  ppuint algorithm_revision; /* /R entry of encrypt dict */
-  ppint permissions;         /* /P entry of encrypt dict */
-  ppdict *map;               /* /CF filters map of encrypt dict */
-  uint8_t userpass[32];      /* padded user password */
-  size_t userpasslength;     /* the length of unpadded user password */
-  uint8_t ownerpass[32];     /* padded owner password */
-  size_t ownerpasslength;    /* the length of unpadded owner password */
-  uint8_t filekey[32+5+4];   /* generated file key with extra space of 5..9 bytes for salt */
-  size_t filekeylength;      /* key length; usually 5, 16 or 32 bytes */
-  uint8_t cryptkey[32];      /* final crypt key for a given reference */
-  size_t cryptkeylength;     /* final crypt key length; usually keylength + 5 */
-  ppref *ref;                /* currently loaded ref (each ref may have a different key) */
-  union {                    /* cached crypt states for strings encrypted/decrypted with the same key */
-    struct {
-      rc4_state rc4state;
-      rc4_map rc4map;
-      rc4_map rc4copy;
-    };
-    struct {
-      aes_state aesstate;
-      aes_keyblock aeskeyblock;
-      uint8_t ivcopy[16];
-    };
-  };
-  int flags;
-} ppcrypt;
-
-#define PPCRYPT_NO_METADATA (1<<0)
-#define PPCRYPT_USER_PASSWORD (1<<1)
-#define PPCRYPT_OWNER_PASSWORD (1<<2)
-#define PPCRYPT_STREAM_RC4 (1<<3)
-#define PPCRYPT_STRING_RC4 (1<<4)
-#define PPCRYPT_STREAM_AES (1<<5)
-#define PPCRYPT_STRING_AES (1<<6)
-#define PPCRYPT_OBSCURITY  (1<<7)
-
-#define PPCRYPT_STREAM (PPCRYPT_STREAM_AES|PPCRYPT_STREAM_RC4)
-#define PPCRYPT_STRING (PPCRYPT_STRING_AES|PPCRYPT_STRING_RC4)
-#define PPCRYPT_RC4 (PPCRYPT_STREAM_RC4|PPCRYPT_STRING_RC4)
-#define PPCRYPT_AES (PPCRYPT_STREAM_AES|PPCRYPT_STRING_AES)
-
-ppcrypt_status ppdoc_crypt_init (ppdoc *pdf, const void *userpass, size_t userpasslength, const void *ownerpass, size_t ownerpasslength);
-int ppstring_decrypt (ppcrypt *crypt, const void *input, size_t size, void *output, size_t *newsize);
-
-#define ppcrypt_start_ref(crypt, r) ((crypt)->ref = r, (crypt)->cryptkeylength = 0)
-#define ppcrypt_end_ref(crypt) ((crypt)->ref = NULL, (crypt)->cryptkeylength = 0)
-#define ppcrypt_ref(pdf, crypt) ((crypt = (pdf)->crypt) != NULL && crypt->ref != NULL)
-
-void ppstream_info (ppstream *stream, ppdoc *pdf);
-
-#endif
\ No newline at end of file
--- texlive-bin.orig/texk/web2c/luatexdir/luapplib/ppdict.c
+++ /dev/null
@@ -1,163 +0,0 @@
-
-#include "pplib.h"
-
-ppdict * ppdict_create (const ppobj *stackpos, size_t size, ppheap **pheap)
-{
-	ppdict *dict;
-	ppobj *data;
-	ppname *pkey;
-	size_t i;
-	size >>= 1;
-	dict = (ppdict *)ppheap_take(pheap, sizeof(ppdict) + size * sizeof(ppobj) + (size + 1) * sizeof(ppname *)); // ? + size * sizeof(ppdict_map_node)
-	dict->size = 0;
-	dict->data = data = (ppobj *)(dict + 1);
-	dict->keys = pkey = (ppname *)(dict->data + size);
-	for (i = 0; i < size; ++i, stackpos += 2)
-	{
-	  if (stackpos->type != PPNAME) // we need this check at lest for trailer hack
-	    continue;
-    *pkey = stackpos->name;
-    *data = *(stackpos + 1);
-    ++pkey, ++data, ++dict->size;
-	}
-	*pkey = NULL; // sentinel for convinient iteration
-	return dict;
-}
-
-ppobj * ppdict_get_obj (ppdict *dict, const char *name)
-{ // some lookup? will see
-  ppname *pkey;
-  ppobj *obj;
-  for (ppdict_first(dict, pkey, obj); *pkey != NULL; ppdict_next(pkey, obj))
-    if (strcmp(*pkey, name) == 0) // not ppname_eq() or ppname_is()!!
-      return obj;
-  return NULL;
-}
-
-ppobj * ppdict_rget_obj (ppdict *dict, const char *name)
-{
-	ppobj *obj;
-  return (obj = ppdict_get_obj(dict, name)) != NULL ? ppobj_rget_obj(obj) : NULL;
-}
-
-int ppdict_get_bool (ppdict *dict, const char *name, int *v)
-{
-  ppobj *obj;
-  return (obj = ppdict_get_obj(dict, name)) != NULL ? ppobj_get_bool(obj, *v) : 0;
-}
-
-int ppdict_rget_bool (ppdict *dict, const char *name, int *v)
-{
-  ppobj *obj;
-  return (obj = ppdict_get_obj(dict, name)) != NULL ? ppobj_rget_bool(obj, *v) : 0;
-}
-
-int ppdict_get_int (ppdict *dict, const char *name, ppint *v)
-{
-  ppobj *obj;
-  return (obj = ppdict_get_obj(dict, name)) != NULL ? ppobj_get_int(obj, *v) : 0;
-}
-
-int ppdict_rget_int (ppdict *dict, const char *name, ppint *v)
-{
-  ppobj *obj;
-  return (obj = ppdict_get_obj(dict, name)) != NULL ? ppobj_rget_int(obj, *v) : 0;
-}
-
-int ppdict_get_uint (ppdict *dict, const char *name, ppuint *v)
-{
-  ppobj *obj;
-  return (obj = ppdict_get_obj(dict, name)) != NULL ? ppobj_get_uint(obj, *v) : 0;
-}
-
-int ppdict_rget_uint (ppdict *dict, const char *name, ppuint *v)
-{
-  ppobj *obj;
-  return (obj = ppdict_get_obj(dict, name)) != NULL ? ppobj_rget_uint(obj, *v) : 0;
-}
-
-int ppdict_get_num (ppdict *dict, const char *name, ppnum *v)
-{
-  ppobj *obj;
-  return (obj = ppdict_get_obj(dict, name)) != NULL ? ppobj_get_num(obj, *v) : 0;
-}
-
-int ppdict_rget_num (ppdict *dict, const char *name, ppnum *v)
-{
-  ppobj *obj;
-  return (obj = ppdict_get_obj(dict, name)) != NULL ? ppobj_rget_num(obj, *v) : 0;
-}
-
-ppname ppdict_get_name (ppdict *dict, const char *name)
-{
-  ppobj *obj;
-  return (obj = ppdict_get_obj(dict, name)) != NULL ? ppobj_get_name(obj) : NULL;
-}
-
-ppname ppdict_rget_name (ppdict *dict, const char *name)
-{
-  ppobj *obj;
-  return (obj = ppdict_get_obj(dict, name)) != NULL ? ppobj_rget_name(obj) : NULL;
-}
-
-ppstring ppdict_get_string (ppdict *dict, const char *name)
-{
-  ppobj *obj;
-  return (obj = ppdict_get_obj(dict, name)) != NULL ? ppobj_get_string(obj) : NULL;
-}
-
-ppstring ppdict_rget_string (ppdict *dict, const char *name)
-{
-  ppobj *obj;
-  return (obj = ppdict_get_obj(dict, name)) != NULL ? ppobj_rget_string(obj) : NULL;
-}
-
-pparray * ppdict_get_array (ppdict *dict, const char *name)
-{
-  ppobj *obj;
-  return (obj = ppdict_get_obj(dict, name)) != NULL ? ppobj_get_array(obj) : NULL;
-}
-
-pparray * ppdict_rget_array (ppdict *dict, const char *name)
-{
-  ppobj *obj;
-  return (obj = ppdict_get_obj(dict, name)) != NULL ? ppobj_rget_array(obj) : NULL;
-}
-
-ppdict * ppdict_get_dict (ppdict *dict, const char *name)
-{
-  ppobj *obj;
-  return (obj = ppdict_get_obj(dict, name)) != NULL ? ppobj_get_dict(obj) : NULL;
-}
-
-ppdict * ppdict_rget_dict (ppdict *dict, const char *name)
-{
-  ppobj *obj;
-  return (obj = ppdict_get_obj(dict, name)) != NULL ? ppobj_rget_dict(obj) : NULL;
-}
-
-/*
-ppstream * ppdict_get_stream (ppdict *dict, const char *name)
-{
-  ppobj *obj;
-  return (obj = ppdict_get_obj(dict, name)) != NULL ? ppobj_get_stream(obj) : NULL;
-}
-*/
-
-ppstream * ppdict_rget_stream (ppdict *dict, const char *name)
-{
-  ppobj *obj;
-  return (obj = ppdict_get_obj(dict, name)) != NULL ? ppobj_rget_stream(obj) : NULL;
-}
-
-ppref * ppdict_get_ref (ppdict *dict, const char *name)
-{
-  ppobj *obj;
-  return (obj = ppdict_get_obj(dict, name)) != NULL ? ppobj_get_ref(obj) : NULL;
-}
-
-ppref * ppdict_rget_ref (ppdict *dict, const char *name)
-{
-  ppobj *obj;
-  return (obj = ppdict_get_obj(dict, name)) != NULL ? ppobj_rget_ref(obj) : NULL;
-}
--- texlive-bin.orig/texk/web2c/luatexdir/luapplib/ppdict.h
+++ /dev/null
@@ -1,7 +0,0 @@
-
-#ifndef PP_DICT_H
-#define PP_DICT_H
-
-ppdict * ppdict_create (const ppobj *stack, size_t size, ppheap **pheap);
-
-#endif
\ No newline at end of file
--- texlive-bin.orig/texk/web2c/luatexdir/luapplib/ppfilter.h
+++ /dev/null
@@ -1,10 +0,0 @@
-
-#ifndef PP_FILTER_H
-#define PP_FILTER_H
-
-#include "utilbasexx.h"
-#include "utilflate.h"
-#include "utillzw.h"
-#include "utilfpred.h"
-
-#endif
\ No newline at end of file
--- texlive-bin.orig/texk/web2c/luatexdir/luapplib/ppheap.c
+++ /dev/null
@@ -1,424 +0,0 @@
-
-#include "pplib.h"
-
-#define PPHEAP_BUFFER 0xFFFF
-#define PPHEAP_WASTE 0x00FF
-
-#define ppheap_head(heap) ((uint8_t *)((heap) + 1))
-
-
-#if defined __arm__ || defined __ARM__ || defined ARM || defined __ARM || defined __arm || defined __ARM_ARCH ||defined __aarch64__ 
-# define PPHEAP_ARCH_ARM
-# define PPHEAP_NEED_ALIGNMENT
-#endif
-
-
- 
-#ifdef PPHEAP_NEED_ALIGNMENT 
-/* Tests has shown that long double seems to work: */
-/* for 32bit aligned_data has  algn: 64 as ppxref and ppref, */
-/* the other algns divide algn: 64, so it's ok.*/
-/* Hopefully it's ok for aarch64 too */
-
-/* These data are stored in ppheap.c.001t.tu */
-/* made with gcc -fdump-tree-all-fdump-tree-all */
-
-
-/* @2586   identifier_node  strg: ppxref   lngt: 6        */
-/* @2565   record_type      name: @2586    size: @679     algn: 64       */
-/*                          tag : struct   flds: @2587    */
-
-
-/* @2672   identifier_node  strg: ppxsec   lngt: 6        */
-/* @2648   type_decl        name: @2672    type: @2623    scpe: @221     */
-/*                          srcp: ppxref.h:16             chain: @2673    */
-/* @2623   record_type      name: @2648    unql: @2649    size: @593     */
-/*                          algn: 32       tag : struct   flds: @2650 */
-
-
-/* @2642   identifier_node  strg: ppstream lngt: 8 */
-/* @2615   type_decl        name: @2642    type: @2643    scpe: @221     */
-/*                          srcp: ppapi.h:54              chain: @2644    */
-/* @2643   record_type      name: @2615    unql: @2614    size: @634     */
-/*                          algn: 32       tag : struct   flds: @2641    */
-
-
-/* @2765   identifier_node  strg: ppkids   lngt: 6 */
-/* @2743   type_decl        name: @2765    type: @2766    scpe: @221     */
-/*                          srcp: ppload.h:16             chain: @2767    */
-/* @2766   record_type      name: @2743    unql: @2742    size: @19      */
-/*                          algn: 32       tag : struct   flds: @2764    */
-
-
-/* @2625   identifier_node  strg: ppdoc    lngt: 5        */
-/* @2605   record_type      name: @2625    size: @2626    algn: 32       */
-/*                          tag : struct   flds: @2627    */
-
-/* @2526   identifier_node  strg: ppref    lngt: 5        */
-/* @2513   record_type      name: @2526    size: @662     algn: 64       */
-/*                          tag : struct   flds: @2527    */
-
-
-/* @2595   identifier_node  strg: ppdict   lngt: 6 */
-/* @2576   type_decl        name: @2595    type: @2596    scpe: @221     */
-/*                          srcp: ppapi.h:45              chain: @2597    */
-/* @2596   record_type      name: @2576    unql: @2575    size: @593     */
-/*                          algn: 32       tag : struct   flds: @2594    */
-
-
-/* @2769   identifier_node  strg: ppcrypt_status          lngt: 14 */
-/* @2752   type_decl        name: @2769    type: @2770    scpe: @221     */
-/*                          srcp: ppapi.h:295             chain: @2771 */
-/* @2770   enumeral_type    name: @2752    unql: @2655    size: @5       */
-/*                          algn: 32       prec: 32       sign: signed   */
-/*                          min : @6       max : @7       csts: @2681    */
-
-
-/* @2558   identifier_node  strg: pparray  lngt: 7 */
-/* @2541   type_decl        name: @2558    type: @2559    scpe: @221     */
-/*                          srcp: ppapi.h:39              chain: @2560    */
-/* @2559   record_type      name: @2541    unql: @2540    size: @19      */
-/*                          algn: 32       tag : struct   flds: @2557 */
-
-
-/* @2817   identifier_node  strg: aligned_data */
-/* @2801   type_decl        name: @2817    type: @2818    scpe: @221     */
-/*                          srcp: ppheap.c:22             chain: @2819    */
-/* @2818   real_type        name: @2801    unql: @99      size: @19      */
-/*                          algn: 64       prec: 64       */
-
-
-typedef long double aligned_data;
-
-
-#define ALIGN_BUFF_BUCKET_SIZE  0x3000 /* heuristic value, found by running few tests */
-#ifdef __SIZEOF_POINTER__ 
-#define SIZE_OF_POINTER  __SIZEOF_POINTER__ 
-#else
-#define SIZE_OF_POINTER  (sizeof(void *))
-#endif 
-
-typedef struct _simplereg {
-  size_t bucket_pos;
-  size_t bucket_size;
-  size_t heap_instance;
-  aligned_data **align_data_set ;
-} simplereg;
-
-/* By default static vars are initialized to  NULL, but to be clear.. */
-static simplereg *align_set = NULL ; 
-
-static void align_init_set(void){
-   size_t size ;
-
-   if (align_set) {
-     align_set->heap_instance++;
-     return ;
-   }
-
-   align_set = malloc(sizeof(simplereg)); 
-   if (!align_set) {
-         fprintf(stderr,"! fatal error: unable to setup master register for  aligned pointers\n");
-         exit(EXIT_FAILURE);
-     }
-
-   size = SIZE_OF_POINTER*ALIGN_BUFF_BUCKET_SIZE;
-   align_set->align_data_set = malloc(size);
-   if (!align_set->align_data_set) {
-         fprintf(stderr,"! fatal error: unable to setup register for aligned pointers\n");
-         exit(EXIT_FAILURE);
-     }
-
-   align_set->bucket_pos = 0;
-   align_set->bucket_size = ALIGN_BUFF_BUCKET_SIZE;
-   align_set->heap_instance = 1;
-   memset(align_set->align_data_set, 0UL,size);
-}
-
-static void align_save_into_set(aligned_data *p){
-   if (align_set->bucket_pos >= align_set->bucket_size) {
-     size_t new_size;
-     aligned_data **align_data_set_new; 
-
-     if(!align_set->align_data_set){
-         fprintf(stderr,"! fatal error: unable to save aligned pointer,corrupted set\n");
-         exit(EXIT_FAILURE);
-     }
-     new_size = (ALIGN_BUFF_BUCKET_SIZE+align_set->bucket_size)*SIZE_OF_POINTER;
-     align_data_set_new = malloc(new_size);
-     if (!align_data_set_new) {
-         fprintf(stderr,"! fatal error: unable to save aligned pointer\n");
-         exit(EXIT_FAILURE);
-     }
-     memset(align_data_set_new,0,new_size);
-     memcpy(align_data_set_new, align_set->align_data_set, align_set->bucket_size*SIZE_OF_POINTER);
-     free(align_set->align_data_set);
-     align_set->align_data_set = align_data_set_new ;
-     align_set->bucket_size += ALIGN_BUFF_BUCKET_SIZE;
-   }
-   if (align_set->bucket_pos>align_set->bucket_size){
-     fprintf(stderr,"! fatal error: unable to save aligned pointer, wrong position\n");
-     exit(EXIT_FAILURE);
-   }
-   align_set->align_data_set[align_set->bucket_pos] = p ; 
-   align_set->bucket_pos++;
-
-}
-
-static void align_free_set(void){
-  /* We don't know what heap does with its data, so free here is not secure */
-
-  if(align_set){
-    if (align_set->heap_instance>1) {
-      align_set->heap_instance--;
-    } else if (align_set->heap_instance ==1) {
-      if (align_set->align_data_set){
-	size_t p;
-	for(p=1;p<align_set->bucket_pos;p++){
-	  if (align_set->align_data_set[p]) {
-	    free(align_set->align_data_set[p]);
-	  }
-	}
-	free(align_set->align_data_set);
-	align_set->align_data_set = NULL;
-      }
-      align_set->heap_instance=0;
-      free(align_set);
-      align_set = NULL ;
-    }
-  }
-}
-
-#endif /* PPHEAP_NEED_ALIGNMENT */
-
-
-static ppheap * ppheap_create (size_t size)
-{
-	ppheap *heap;
-	heap = (ppheap *)pp_malloc(sizeof(ppheap) + size * sizeof(uint8_t));
-	heap->size = size;
-	heap->space = size;
-	heap->data = ppheap_head(heap);
-	heap->prev = NULL;
-	return heap;
-}
-
-ppheap * ppheap_new (void)
-{
-#ifdef PPHEAP_NEED_ALIGNMENT
-        align_init_set();
-#endif  
-        return ppheap_create(PPHEAP_BUFFER);
-}
-
-void ppheap_free (ppheap *heap)
-{
-  ppheap *prev;
-  do
-  {
-    prev = heap->prev;
-    pp_free(heap);
-    heap = prev;
-  } while (heap != NULL);
-#ifdef PPHEAP_NEED_ALIGNMENT
-    align_free_set();
-#endif  
-
-}
-
-void ppheap_renew (ppheap *heap)
-{ // free all but first
-  ppheap *prev;
-  if ((prev = heap->prev) != NULL)
-  {
-    heap->prev = NULL;
-    ppheap_free(prev);
-  }
-  heap->size = heap->space;
-  heap->data = ppheap_head(heap);
-}
-
-static ppheap * ppheap_insert_top (ppheap **pheap, size_t size)
-{
-  ppheap *heap;
-  heap = ppheap_create(size);
-  heap->prev = (*pheap);
-  *pheap = heap;
-  return heap;
-}
-
-static ppheap * ppheap_insert_sub (ppheap **pheap, size_t size)
-{
-  ppheap *heap;
-  heap = ppheap_create(size);
-  heap->prev = (*pheap)->prev;
-  (*pheap)->prev = heap;
-  return heap;
-}
-
-void * ppheap_take (ppheap **pheap, size_t size)
-{
-	ppheap *heap;
-	uint8_t *data;
-#ifdef PPHEAP_NEED_ALIGNMENT
-	aligned_data *p_aligned_data;
-#endif  
-	heap = *pheap;
-	if (size <= heap->size)
-	  ;
-	else if (heap->size <= PPHEAP_WASTE && size <= (PPHEAP_BUFFER >> 1))
-	  heap = ppheap_insert_top(pheap, PPHEAP_BUFFER);
-	else
-        heap = ppheap_insert_sub(pheap, size);
- 	data = heap->data;
- 	heap->data += size;
- 	heap->size -= size;
-#ifdef PPHEAP_NEED_ALIGNMENT
-	/* Todo: only if data%sizeof(aligned_data) != 0 */
-	p_aligned_data = malloc(size);
-	memcpy(p_aligned_data,data,size);
-	align_save_into_set(p_aligned_data);
-	return (void *)p_aligned_data;
-#else
- 	return (void *)data;
-#endif  
-
-}
-
-
-/* iof buffer tied to a heap */
-
-static ppheap * ppheap_resize  (ppheap **pheap, size_t size)
-{
-  ppheap *heap;
-  heap = ppheap_create(size);
-  heap->prev = (*pheap)->prev;
-  memcpy(heap->data, (*pheap)->data, (*pheap)->space); // (*pheap)->size is irrelevant
-  pp_free(*pheap);
-  *pheap = heap;
-  return heap;
-}
-
-static size_t ppheap_buffer_handler (iof *O, iof_mode mode)
-{
-  ppheap **pheap, *heap;
-  size_t objectsize, buffersize, neededsize;
-  uint8_t *copyfrom;
-  switch (mode)
-  {
-    case IOFWRITE:
-      /* apparently more space needed then assumed initsize */
-      pheap = (ppheap **)O->link;
-      heap = *pheap;
-      objectsize = (size_t)(O->buf - heap->data);
-      buffersize = (size_t)(O->pos - O->buf);
-      neededsize = objectsize + (buffersize << 1);
-      if (ppheap_head(heap) < heap->data)
-      {
-        if (heap->size <= PPHEAP_WASTE && neededsize <= (PPHEAP_BUFFER >> 1))
-        {
-          heap = ppheap_insert_top(pheap, PPHEAP_BUFFER);
-          copyfrom = heap->prev->data;
-        }
-        else
-        {
-          heap = ppheap_insert_sub(pheap, neededsize);
-          copyfrom = (*pheap)->data;
-          O->link = (void *)(&(*pheap)->prev);
-        }
-        memcpy(heap->data, copyfrom, objectsize + buffersize);
-      }
-      else
-      { /* the buffer was (re)initialized from a new empty heap and occupies its entire space */
-        // ASSERT(ppheap_head(heap) == heap->data);
-        heap = ppheap_resize(pheap, neededsize);
-      }
-      O->buf = heap->data + objectsize;
-      O->pos = O->buf + buffersize;
-      O->end = heap->data + heap->size;
-      return (size_t)(O->end - O->pos);
-    case IOFFLUSH:
-      return 0;
-    case IOFCLOSE:
-      // O->buf = O->pos = O->end = NULL;
-      // O->link = NULL;
-      return 0;
-    default:
-      break;
-  }
-  return 0;
-}
-
-iof * ppheap_buffer (ppheap **pheap, size_t objectsize, size_t initsize)
-{
-  static iof ppheap_buffer_iof = IOF_WRITER_STRUCT(ppheap_buffer_handler, NULL, NULL, 0, 0);
-  ppheap *heap;
-  size_t size;
-  size = objectsize + initsize;
-  heap = *pheap;
-  if (size <= heap->size)
-    ;
-  else if (heap->size <= PPHEAP_WASTE && size <= (PPHEAP_BUFFER >> 1))
-  {
-    heap = ppheap_create(PPHEAP_BUFFER);
-    heap->prev = (*pheap);
-    *pheap = heap;
-  }
-  else
-  {
-    heap = ppheap_create(size);
-    heap->prev = (*pheap)->prev;
-    (*pheap)->prev = heap;
-    pheap = &(*pheap)->prev; // passed to ppheap_buffer_iof.link
-  }
-  ppheap_buffer_iof.buf = ppheap_buffer_iof.pos = heap->data + objectsize;
-  ppheap_buffer_iof.end = heap->data + heap->size;
-  ppheap_buffer_iof.link = pheap; // ASSERT(*pheap == heap)
-  return &ppheap_buffer_iof;
-}
-
-/*
-void * ppheap_buffer_data (iof *O, size_t *psize)
-{
-  ppheap *heap;
-  heap = *((ppheap **)(O->link));
-  *psize = ppheap_buffer_size(O, heap);
-  return heap->data;
-}
-*/
-
-void * ppheap_flush (iof *O, size_t *psize) // not from explicit ppheap ** !!!
-{
-  ppheap *heap;
-  uint8_t *data;
-  size_t size;
-#ifdef PPHEAP_NEED_ALIGNMENT
-  aligned_data *p_aligned_data;
-#endif  
-  heap = *((ppheap **)(O->link));
-  *psize = ppheap_buffer_size(O, heap);
-  size = *psize;
-  data = heap->data;
-/*  heap->data += *psize;
-  heap->size -= *psize;
-*/
-  heap->data += size;
-  heap->size -= size;
-  // O->buf = O->pos = O->end = NULL;
-  // O->link = NULL;
-  // iof_close(O);
-#ifdef PPHEAP_NEED_ALIGNMENT
-  /* Todo: only if data%sizeof(aligned_data) != 0 */
-  p_aligned_data = malloc(size);
-  memcpy(p_aligned_data,data,size);
-  align_save_into_set(p_aligned_data);
-  return (void *)p_aligned_data;
-#else
-  return data;
-
-#endif  
-
-
-}
-
-
--- texlive-bin.orig/texk/web2c/luatexdir/luapplib/ppheap.h
+++ /dev/null
@@ -1,29 +0,0 @@
-
-#ifndef PP_HEAP_H
-#define PP_HEAP_H
-
-#include "utilmem.h"
-
-#define pp_malloc util_malloc
-#define pp_callic util_calloc
-#define pprealloc util_realloc
-#define pp_free util_free
-
-typedef struct ppheap ppheap;
-struct ppheap {
-	size_t size;
-	size_t space;
-	uint8_t *data;
-	ppheap *prev;
-};
-
-ppheap * ppheap_new (void);
-void ppheap_free (ppheap *heap);
-void ppheap_renew (ppheap *heap);
-void * ppheap_take (ppheap **pheap, size_t size);
-iof * ppheap_buffer (ppheap **pheap, size_t objectsize, size_t initsize);
-#define ppheap_buffer_size(O, heap) (size_t)((O)->pos - (heap)->data) // == (size_t)(O->buf - heap->data) + (size_t)(O->pos - O->buf);
-//void * ppheap_buffer_data (iof *O, size_t *psize);
-void * ppheap_flush (iof *O, size_t *psize);
-
-#endif
\ No newline at end of file
--- texlive-bin.orig/texk/web2c/luatexdir/luapplib/pplib.h
+++ /dev/null
@@ -1,22 +0,0 @@
-
-#ifndef PP_LIB_H
-#define PP_LIB_H
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <assert.h>
-
-#include "utiliof.h"
-#include "utillog.h"
-
-#include "ppapi.h"
-#include "ppheap.h"
-#include "ppdict.h"
-#include "ppstream.h"
-#include "pparray.h"
-#include "ppcrypt.h"
-#include "ppxref.h"
-#include "ppload.h"
-
-#endif
\ No newline at end of file
--- texlive-bin.orig/texk/web2c/luatexdir/luapplib/ppload.c
+++ /dev/null
@@ -1,2590 +0,0 @@
-
-#include <utilbasexx.h>
-
-#include "pplib.h"
-
-const char * ppobj_kind[] = { "none", "null", "bool", "integer", "number", "name", "string", "array", "dict", "stream", "ref" };
-
-#define ignored_char(c) (c == 0x20 || c == 0x0A || c == 0x0D || c == 0x09 || c == 0x00)
-#define newline_char(c) (c == 0x0A || c == 0x0D)
-#define IGNORED_CHAR_CASE 0x20: case 0x0A: case 0x0D: case 0x09: case 0x00
-#define NEWLINE_CHAR_CASE 0x0A: case 0x0D
-#define DIGIT_CHAR_CASE '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9'
-#define OCTAL_CHAR_CASE '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7'
-
-#define MAX_INT_DIGITS 32
-
-#define PP_LENGTH_UNKNOWN ((size_t)-1)
-
-static const char * ppref_str (ppuint refnumber, ppuint refversion)
-{
-	static char buffer[MAX_INT_DIGITS + 1 + MAX_INT_DIGITS + 1 + 1 + 1];
-#if defined(MSVC64)|| defined(MINGW64)
-	sprintf(buffer, PPUINTF " " PPUINTF " R", refnumber, refversion);
-#else
-	sprintf(buffer, PPUINTF " " PPUINTF " R", (unsigned long)(refnumber), (unsigned long)(refversion));
-#endif
-	return buffer;
-}
-
-/* name */
-
-// pdf name delimiters: 0..32, ()<>[]{}/%
-// # treated specially
-// .+- are valid part of name; keep in mind names such as -| | |- .notdef ABCDEF+Font etc.
-const char ppname_byte_lookup[] = {
-  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-  0, 1, 1, '#', 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0,
-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1,
-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1,
-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1,
-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
-};
-
-#define PPNAME_INIT (8+1)
-
-#define ppname_flush(O, ghost, siz, flgs) \
-  (iof_put(O, '\0'), \
-   ghost = (_ppname *)ppheap_flush(O, &siz), \
-   ghost->flags = flgs, \
-   ghost->size = siz - sizeof(_ppname) - 1, \
-  (ppname)(ghost + 1))
-
-#define ppname_flush_with_ego(O, ghost, siz, flgs) \
-  (iof_put(O, '\0'), \
-   iof_ensure(O, sizeof(ppname *)), \
-   O->pos += sizeof(ppname *), \
-   ghost = (_ppname *)ppheap_flush(O, &siz), \
-   ghost->flags = flgs, \
-   ghost->size = siz - sizeof(_ppname) - 1 - sizeof(ppname *), \
-  (ppname)(ghost + 1))
-
-
-#if defined __arm__ || defined __ARM__ || defined ARM || defined __ARM || defined __arm || defined __ARM_ARCH ||defined __aarch64__ 
-#define ppname_set_alter_ego(name, ghost, ego) do {\
-    ppname temp;\
-    ppname *temp1;\
-    temp =  (name + (ghost)->size + 1) ; \
-    temp1 = (ppname *)((void*)temp); \
-    *temp1= ego; \
-    }while(0)
-#else
-#define ppname_set_alter_ego(name, ghost, ego) (*((ppname *)(name + (ghost)->size + 1)) = ego)
-#endif
-
-#if defined __arm__ || defined __ARM__ || defined ARM || defined __ARM || defined __arm || defined __ARM_ARCH ||defined __aarch64__ 
-#define ppname_get_alter_ego(name) (*((ppname *)( (void*)(name + ppname_size(name) + 1))))
-#else
-#define ppname_get_alter_ego(name) (*((ppname *)(name + ppname_size(name) + 1)))
-#endif
-
-
-
-
-
-static ppname ppscan_name (iof *I, ppheap **pheap)
-{
-  int c, decode;
-  iof *O;
-  _ppname *ghost1, *ghost2;
-  ppname encoded, decoded;
-  size_t size;
-  const char *p, *e;
-  uint8_t v1, v2;
-  O = ppheap_buffer(pheap, sizeof(_ppname), PPNAME_INIT);
-  for (decode = 0, c = iof_char(I); c >= 0 && ppname_byte_lookup[c]; c = iof_next(I))
-  {
-    if (c == '#')
-      decode = 1;
-    iof_put(O, c);
-  }
-  if (!decode)
-    return ppname_flush(O, ghost1, size, 0);
-  encoded = ppname_flush_with_ego(O, ghost1, size, 0|PPNAME_ENCODED);
-  O = ppheap_buffer(pheap, sizeof(_ppname), PPNAME_INIT);
-  for (p = encoded, e = encoded + ghost1->size; p < e; ++p)
-  {
-    if (*p == '#' && p + 2 < e ){
-      v1 = base16_value(p[1]);
-      v2 = base16_value(p[2]);
-      iof_put(O, ((v1<<4)+v2));
-    }else
-      iof_put(O, *p);
-  }
-  decoded = ppname_flush_with_ego(O, ghost2, size, 0|PPNAME_DECODED);
-  ppname_set_alter_ego(encoded, ghost1, decoded);
-  ppname_set_alter_ego(decoded, ghost2, encoded);
-  return encoded;
-}
-
-static ppname ppscan_exec (iof *I, ppheap **pheap, int first)
-{
-  int c, decode;
-  iof *O;
-  _ppname *ghost1, *ghost2;
-  ppname encoded, decoded;
-  size_t size;
-  const char *p, *e;
-  uint8_t v1, v2;
-
-  O = ppheap_buffer(pheap, sizeof(_ppname), PPNAME_INIT);
-  iof_put(O, first);
-  for (decode = 0, c = iof_char(I); c >= 0 && ppname_byte_lookup[c]; c = iof_next(I))
-  {
-    if (c == '#')
-      decode = 1;
-    iof_put(O, c);
-  }
-  if (!decode)
-    return ppname_flush(O, ghost1, size, PPNAME_EXEC);
-  encoded = ppname_flush_with_ego(O, ghost1, size, PPNAME_EXEC|PPNAME_ENCODED);
-  O = ppheap_buffer(pheap, sizeof(_ppname), PPNAME_INIT);
-  for (p = encoded, e = encoded + ghost1->size; p < e; ++p)
-  {
-    if (*p == '#' && p + 2 < e ){
-      v1 = base16_value(p[1]);
-      v2 = base16_value(p[2]);
-      iof_put(O, ((v1<<4)+v2));
-    }else
-      iof_put(O, *p);
-  }
-  decoded = ppname_flush_with_ego(O, ghost2, size, PPNAME_EXEC|PPNAME_DECODED);
-  ppname_set_alter_ego(encoded, ghost1, decoded);
-  ppname_set_alter_ego(decoded, ghost2, encoded);
-  return encoded;
-}
-
-static ppname ppexec_internal (const void *data, size_t size, ppheap **pheap)
-{ // used only for artificial 'EI' operator name
-  iof *O;
-  _ppname *ghost1;
-
-  O = ppheap_buffer(pheap, sizeof(_ppname), size);
-  iof_write(O, data, size);
-  return ppname_flush(O, ghost1, size, PPNAME_EXEC);
-}
-
-ppname ppname_decoded (ppname name)
-{
-  const _ppname *ghost;
-  ghost = _ppname_ghost(name);
-  return (ghost->flags & PPNAME_ENCODED) ? ppname_get_alter_ego(name) : name;
-}
-
-ppname ppname_encoded (ppname name)
-{
-  const _ppname *ghost;
-  ghost = _ppname_ghost(name);
-  return (ghost->flags & PPNAME_DECODED) ? ppname_get_alter_ego(name) : name;
-}
-
-/* string */
-
-#define PPSTRING_INIT (16+1)
-
-#define ppstring_flush(O, ghost, siz, flgs) \
-  (iof_put(O, '\0'), \
-   ghost = (_ppstring *)ppheap_flush(O, &siz), \
-   ghost->flags = flgs, \
-   ghost->size = siz - sizeof(_ppstring) - 1, \
-  (ppstring)(ghost + 1))
-
-#define ppstring_flush_with_ego(O, ghost, siz, flgs) \
-  (iof_put(O, '\0'), \
-   iof_ensure(O, sizeof(ppstring *)), \
-   O->pos += sizeof(ppstring *), \
-   ghost = (_ppstring *)ppheap_flush(O, &siz), \
-   ghost->flags = flgs, \
-   ghost->size = siz - sizeof(_ppstring) - 1 - sizeof(ppstring *), \
-  (ppstring)(ghost + 1))
-
-#define ppstring_utf16be_bom(decoded) (decoded[0] == ((char)0xFE) && decoded[1] == ((char)0xFF) )
-#define ppstring_utf16le_bom(decoded) (decoded[0] == ((char)0xFF) && decoded[1] == ((char)0xFE))
-
-#define ppstring_check_bom(decoded, ghost) ((void)\
-  (ghost->size >= 2 ? (ppstring_utf16be_bom(decoded) ? (ghost->flags |= PPSTRING_UTF16BE) : \
-                      (ppstring_utf16le_bom(decoded) ? (ghost->flags |= PPSTRING_UTF16LE) : 0)) : 0))
-
-#define ppstring_check_bom2(decoded, ghost1, ghost2) ((void)\
-  (ghost2->size >= 2 ? (ppstring_utf16be_bom(decoded) ? ((ghost1->flags |= PPSTRING_UTF16BE), (ghost2->flags |= PPSTRING_UTF16BE)) : \
-                       (ppstring_utf16le_bom(decoded) ? ((ghost1->flags |= PPSTRING_UTF16LE), (ghost2->flags |= PPSTRING_UTF16LE)) : 0)) : 0))
-
-
-
-#if defined __arm__ || defined __ARM__ || defined ARM || defined __ARM || defined __arm || defined __ARM_ARCH ||defined __aarch64__ 
-#define ppstring_set_alter_ego(string, ghost, ego) (*((ppstring *)((void *)(string + (ghost)->size + 1))) = ego)
-#else
-#define ppstring_set_alter_ego(string, ghost, ego) (*((ppstring *)(string + (ghost)->size + 1)) = ego)
-#endif
-
-
-#if defined __arm__ || defined __ARM__ || defined ARM || defined __ARM || defined __arm || defined __ARM_ARCH ||defined __aarch64__ 
-#define ppstring_get_alter_ego(string) (*((ppstring *)((void *)(string + ppstring_size(string) + 1))))
-#else
-#define ppstring_get_alter_ego(string) (*((ppstring *)(string + ppstring_size(string) + 1)))
-#endif
-
-
-
-
-static ppstring ppscan_string (iof *I, ppheap **pheap)
-{
-  int c, decode, balance;
-  iof *O;
-  _ppstring *ghost1, *ghost2;
-  uint8_t *p, *e;
-  ppstring encoded, decoded;
-  size_t size;
-  O = ppheap_buffer(pheap, sizeof(_ppstring), PPSTRING_INIT);
-  for (decode = 0, balance = 0, c = iof_char(I); c >= 0; )
-  {
-    switch (c)
-    {
-      case '\\':
-        decode = 1; // unescaping later
-        iof_put(O, '\\');
-        if ((c = iof_next(I)) >= 0)
-        {
-          iof_put(O, c);
-          c = iof_next(I);
-        }
-        break;
-      case '(': // may be unescaped if balanced
-        ++balance;
-        iof_put(O, '(');
-        c = iof_next(I);
-        break;
-      case ')':
-        if (balance == 0)
-        {
-          c = IOFEOF;
-          ++I->pos;
-          break;
-        }
-        --balance;
-        iof_put(O, ')');
-        c = iof_next(I);
-        break;
-      default:
-        iof_put(O, c);
-        c = iof_next(I);
-    }
-  }
-  if (!decode)
-  {
-    encoded = ppstring_flush(O, ghost1, size, 0);
-    ppstring_check_bom(encoded, ghost1); // any bytes can be there
-    return encoded;
-  }
-  encoded = ppstring_flush_with_ego(O, ghost1, size, 0|PPSTRING_ENCODED);
-  O = ppheap_buffer(pheap, sizeof(_ppstring), PPSTRING_INIT);
-  for (p = (uint8_t *)encoded, e = (uint8_t *)encoded + ghost1->size; p < e; ++p)
-  {
-    if (*p == '\\')
-    {
-      if (++p >= e)
-        break;
-      switch (*p)
-      {
-        case OCTAL_CHAR_CASE:
-          c = *p - '0';
-          if (++p < e && *p >= '0' && *p <= '7')
-          {
-            c = (c << 3) + *p - '0';
-            if (++p < e && *p >= '0' && *p <= '7')
-              c = (c << 3) + *p - '0';
-          }
-          iof_put(O, c);
-          break;
-        case 'n':
-          iof_put(O, '\n');
-          break;
-        case 'r':
-          iof_put(O, '\r');
-          break;
-        case 't':
-          iof_put(O, '\t');
-          break;
-        case 'b':
-          iof_put(O, '\b');
-          break;
-        case 'f':
-          iof_put(O, '\f');
-          break;
-        case NEWLINE_CHAR_CASE: // not a part of the string, ignore (pdf spec page 55)
-          break;
-        case '(': case ')': case '\\':
-        default: // for enything else backslash is ignored (pdf spec page 54)
-          iof_put(O, *p);
-          break;
-      }
-    }
-    else
-      iof_put(O, *p);
-  }
-  decoded = ppstring_flush_with_ego(O, ghost2, size, 0|PPSTRING_DECODED);
-  ppstring_check_bom2(decoded, ghost1, ghost2);
-  ppstring_set_alter_ego(encoded, ghost1, decoded);
-  ppstring_set_alter_ego(decoded, ghost2, encoded);
-  return encoded;
-}
-
-/* Hex string may contain white characters. If odd number of digits, the last assumed to be '0' */
-
-static ppstring ppscan_base16 (iof *I, ppheap **pheap)
-{
-  int c, v1, v2;
-  iof *O;
-  _ppstring *ghost1, *ghost2;
-  size_t size;
-  ppstring encoded, decoded;
-  uint8_t *p, *e;
-
-  O = ppheap_buffer(pheap, sizeof(_ppstring), PPSTRING_INIT);
-  for (c = iof_char(I); c >= 0 && (base16_digit(c) || ignored_char(c)); c = iof_next(I))
-    iof_put(O, c);
-  if (c == '>')
-    ++I->pos;
-  encoded = ppstring_flush_with_ego(O, ghost1, size, PPSTRING_BASE16|PPSTRING_ENCODED);
-  O = ppheap_buffer(pheap, sizeof(_ppstring), (ghost1->size >> 1) + 1);
-  for (p = (uint8_t *)encoded, e = (uint8_t *)encoded + ghost1->size; p < e; ++p)
-  {
-    if ((v1 = base16_value(*p)) < 0) // ignored
-      continue;
-    for (v2 = 0, ++p; p < e && (v2 = base16_value(*p)) < 0; ++p);
-    iof_put(O, (v1<<4)|v2);
-  }
-  decoded = ppstring_flush_with_ego(O, ghost2, size, 0|PPSTRING_DECODED);
-  ppstring_check_bom2(decoded, ghost1, ghost2);
-  ppstring_set_alter_ego(encoded, ghost1, decoded);
-  ppstring_set_alter_ego(decoded, ghost2, encoded);
-  return encoded;
-}
-
-/* internal use only; binary string */
-
-static ppstring ppstring_buffer (iof *O, ppheap **pheap)
-{
-   _ppstring *ghost1, *ghost2;
-   ppstring encoded, decoded;
-   uint8_t *p, *e;
-   size_t size;
-
-   decoded = ppstring_flush_with_ego(O, ghost2, size, 0|PPSTRING_DECODED);
-   O = ppheap_buffer(pheap, sizeof(_ppstring), (ghost2->size << 1) + 1);
-   for (p = (uint8_t *)decoded, e = (uint8_t *)decoded + ghost2->size; p < e; ++p)
-     iof_set2(O, base16_uc_alphabet[(*p)>>4], base16_uc_alphabet[(*p)&15]);
-   encoded = ppstring_flush_with_ego(O, ghost1, size, PPSTRING_BASE16|PPSTRING_ENCODED);
-   ppstring_set_alter_ego(encoded, ghost1, decoded);
-   ppstring_set_alter_ego(decoded, ghost2, encoded);
-   return encoded;
-}
-
-ppstring ppstring_internal (const void *data, size_t size, ppheap **pheap)
-{ // so far used only for crypt key
-  iof *O;
-
-  O = ppheap_buffer(pheap, sizeof(_ppstring), size);
-  iof_write(O, data, size);
-  return ppstring_buffer(O, pheap);
-}
-
-/* PDF spec says nothing about base85 strings, but streams might be (afair no leading '<~' but present trailing '~>') */
-
-static ppstring ppscan_base85 (iof *I, ppheap **pheap)
-{ // bawse85 alphabet is 33.117, adobe also hires 'z' and 'y' for compression
-  int c;
-  iof *O, B;
-  _ppstring *ghost1, *ghost2;
-  size_t size;
-  ppstring encoded, decoded;
-  O = ppheap_buffer(pheap, sizeof(_ppstring), PPSTRING_INIT);
-  for (c = iof_char(I); (c >= '!' && c <= 'u') || c == 'z' || c == 'y'; c = iof_next(I))
-    iof_put(O, c);
-  if (c == '~')
-    if ((c = iof_next(I)) == '>')
-      ++I->pos;
-  encoded = ppstring_flush_with_ego(O, ghost1, size, PPSTRING_BASE85|PPSTRING_ENCODED);
-  iof_string_reader(&B, encoded, ghost1->size);
-  O = ppheap_buffer(pheap, sizeof(_ppstring), (ghost1->size * 5 / 4) + 1);
-  base85_decode(&B, O);
-  decoded = ppstring_flush_with_ego(O, ghost2, size, 0|PPSTRING_DECODED);
-  ppstring_check_bom2(decoded, ghost1, ghost2);
-  ppstring_set_alter_ego(encoded, ghost1, decoded);
-  ppstring_set_alter_ego(decoded, ghost2, encoded);
-  return encoded;
-}
-
-/*
-Encrypted strings. In case of encrypted strings, we first need to decode the string (saving original form hardly makes sense),
-then decrypt the string, and encode it again.
-*/
-
-const char ppstring_byte_escape[] = { /* -1 escaped with octal, >0 escaped with \\, 0 left intact*/
- -1,-1,-1,-1,-1,-1,-1,-1,'b','t','n',-1,'f','r',-1,-1,
- -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  0, 0, 0, 0, 0, 0, 0, 0,'(',')', 0, 0, 0, 0, 0, 0,
-  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,'\\', 0, 0, 0,
-  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
- -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
- -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
- -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
- -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
- -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
- -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
- -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
- -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1
-};
-
-
-static ppstring ppscan_crypt_string (iof *I, ppcrypt *crypt, ppheap **pheap)
-{
-  int c, b, balance, encode;
-  iof *O;
-  _ppstring *ghost1, *ghost2;
-  ppstring encoded, decoded;
-  uint8_t *p, *e;
-  size_t size;
-
-  O = ppheap_buffer(pheap, sizeof(_ppstring), PPSTRING_INIT);
-  for (balance = 0, encode = 0, c = iof_char(I); c >= 0; )
-  {
-    switch (c)
-    {
-      case '\\':
-        if ((c = iof_next(I)) < 0)
-          break;
-        encode = 1;
-        switch (c)
-        {
-          case OCTAL_CHAR_CASE:
-            b = c - '0';
-            if ((c = iof_next(I)) >= 0 && c >= '0' && c <= '7')
-            {
-              b = (b << 3) + c - '0';
-              if ((c = iof_next(I)) >= 0 && c >= '0' && c <= '7')
-              {
-                b = (b << 3) + c - '0';
-                c = iof_next(I);
-              }
-            }
-            iof_put(O, b);
-            // c is set to the next char
-            break;
-          case 'n':
-            iof_put(O, '\n');
-            c = iof_next(I);
-            break;
-          case 'r':
-            iof_put(O, '\r');
-            c = iof_next(I);
-            break;
-          case 't':
-            iof_put(O, '\t');
-            c = iof_next(I);
-            break;
-          case 'b':
-            iof_put(O, '\b');
-            c = iof_next(I);
-            break;
-          case 'f':
-            iof_put(O, '\f');
-            c = iof_next(I);
-            break;
-          case NEWLINE_CHAR_CASE: // not a part of the string, ignore (pdf spec page 55)
-            c = iof_next(I);
-            break;
-          case '(': case ')': case '\\':
-          default: // for enything else backslash is ignored (pdf spec page 54)
-            iof_put(O, c);
-            c = iof_next(I);
-            break;
-        }
-        break;
-      case '(':
-        ++balance;
-        encode = 1;
-        iof_put(O, '(');
-        c = iof_next(I);
-        break;
-      case ')':
-        if (balance == 0)
-        {
-          c = IOFEOF;
-          ++I->pos;
-        }
-        else
-        {
-          --balance;
-          //encode = 1;
-          iof_put(O, ')');
-          c = iof_next(I);
-        }
-        break;
-      default:
-        if (ppstring_byte_escape[c] != 0)
-          encode = 1;
-        iof_put(O, c);
-        c = iof_next(I);
-    }
-  }
-  /* decrypt the buffer in place, update size */
-  if (ppstring_decrypt(crypt, O->buf, iof_size(O), O->buf, &size))
-    O->pos = O->buf + size;
-  /* make encoded counterpart */
-  if (!encode)
-  {
-    decoded = ppstring_flush(O, ghost2, size, 0);
-    ppstring_check_bom(decoded, ghost2);
-    return decoded;
-  }
-  decoded = ppstring_flush_with_ego(O, ghost2, size, PPSTRING_DECODED);
-  O = ppheap_buffer(pheap, sizeof(_ppstring), ghost2->size);
-  for (p = (uint8_t *)decoded, e = (uint8_t *)decoded + ghost2->size; p < e; ++p)
-  {
-    switch ((b = ppstring_byte_escape[*p]))
-    {
-      case 0:
-        iof_put(O, *p);
-        break;
-      case -1:
-        iof_put4(O, '\\', (c >> 6) + '0', ((c >> 3) & 7) + '0', (c & 7) + '0');
-        break;
-      default:
-        iof_put2(O, '\\', b);
-        break;
-    }
-  }
-  encoded = ppstring_flush_with_ego(O, ghost1, size, PPSTRING_ENCODED);
-  ppstring_check_bom2(decoded, ghost1, ghost2);
-  ppstring_set_alter_ego(encoded, ghost1, decoded);
-  ppstring_set_alter_ego(decoded, ghost2, encoded);
-  return encoded;
-}
-
-
-static ppstring ppscan_crypt_base16 (iof *I, ppcrypt *crypt, ppheap **pheap)
-{
-  int c, v1, v2;
-  iof *O;
-  _ppstring *ghost1, *ghost2;
-  ppstring encoded, decoded;
-  uint8_t *p, *e;
-  size_t size;
-
-  O = ppheap_buffer(pheap, sizeof(_ppstring), PPSTRING_INIT);
-  // base16_decode(I, O); // no info about the last char..
-  for (c = iof_char(I); c != '>' && c >= 0; )
-  {
-    if ((v1 = base16_value(c)) < 0)
-    {
-      if (ignored_char(c))
-      {
-        c = iof_next(I);
-        continue;
-      }
-      break;
-    }
-    do {
-      c = iof_next(I);
-      if ((v2 = base16_value(c)) >= 0)
-      {
-        c = iof_next(I);
-        break;
-      }
-      if (!ignored_char(c)) // c == '>' || c < 0 or some crap
-      {
-        v2 = 0;
-        break;
-      }
-    } while (1);
-    iof_put(O, (v1 << 4)|v2);
-  }
-  if (c == '>')
-    ++I->pos;
-  /* decrypt the buffer in place, update size */
-  if (ppstring_decrypt(crypt, O->buf, iof_size(O), O->buf, &size))
-    O->pos = O->buf + size;
-  decoded = ppstring_flush_with_ego(O, ghost2, size, PPSTRING_DECODED);
-  /* recreate an encoded form */
-  O = ppheap_buffer(pheap, sizeof(_ppstring), (ghost2->size << 1) + 1);
-  for (p = (uint8_t *)decoded, e = (uint8_t *)decoded + ghost2->size; p < e; ++p)
-    iof_set2(O, base16_uc_alphabet[(*p)>>4], base16_uc_alphabet[(*p)&15]);
-  encoded = ppstring_flush_with_ego(O, ghost1, size, PPSTRING_BASE16|PPSTRING_ENCODED);
-  ppstring_check_bom2(decoded, ghost1, ghost2);
-  ppstring_set_alter_ego(encoded, ghost1, decoded);
-  ppstring_set_alter_ego(decoded, ghost2, encoded);
-  return encoded;
-}
-
-/* ppstring alter ego switcher */
-
-ppstring ppstring_decoded (ppstring string)
-{
-  const _ppstring *ghost;
-  ghost = _ppstring_ghost(string);
-  return (ghost->flags & PPSTRING_ENCODED) ? ppstring_get_alter_ego(string) : string;
-}
-
-ppstring ppstring_encoded (ppstring string)
-{
-  const _ppstring *ghost;
-  ghost = _ppstring_ghost(string);
-  return (ghost->flags & PPSTRING_DECODED) ? ppstring_get_alter_ego(string) : string;
-}
-
-/* scanner stack */
-
-#define PPSTACK_BUFFER 512
-
-static void ppstack_init (ppstack *stack, ppheap **pheap)
-{
-  stack->buf = stack->pos = (ppobj *)pp_malloc(PPSTACK_BUFFER * sizeof(ppobj));
-  stack->size = 0;
-  stack->space = PPSTACK_BUFFER;
-  stack->pheap = pheap;
-}
-
-#define ppstack_free_buffer(stack) (pp_free((stack)->buf))
-
-static void ppstack_resize (ppstack *stack)
-{
-  ppobj *newbuffer;
-  stack->space <<= 1;
-  newbuffer = (ppobj *)pp_malloc(stack->space * sizeof(ppobj));
-  memcpy(newbuffer, stack->buf, stack->size * sizeof(ppobj));
-  ppstack_free_buffer(stack);
-  stack->buf = newbuffer;
-  stack->pos = newbuffer + stack->size;
-}
-
-#define ppstack_push(stack) ((void)((stack)->size < (stack)->space || (ppstack_resize(stack), 0)), ++(stack)->size, (stack)->pos++)
-#define ppstack_pop(stack, n) ((stack)->size -= (n), (stack)->pos -= (n))
-#define ppstack_at(stack, i) ((stack)->buf + i)
-#define ppstack_clear(stack) ((stack)->pos = (stack)->buf, (stack)->size = 0)
-
-/* scanner commons */
-
-#define ppscan_uint(I, u) iof_get_uintlw(I, u)
-#define ppread_uint(s, u) string_to_uintlw((const char *)(s), u)
-
-static ppobj * ppscan_numobj (iof *I, ppobj *obj, int negative)
-{
-  ppint integer;
-  ppnum number;
-  int exponent;
-  int c;
-  c = iof_char(I);
-  iof_scan_integer(I, c, integer);
-  switch(c)
-  {
-    case '.':
-    {
-      number = (ppnum)integer;
-      c = iof_next(I);
-      iof_scan_fraction(I, c, number, exponent);
-      double_negative_exp10(number, exponent);
-      obj->type = PPNUM, obj->number = negative ? -number : number;
-      break;
-    }
-    default:
-      obj->type = PPINT, obj->integer = negative ? -integer : integer;
-      break;
-  }
-  return obj;
-}
-
-static ppobj * ppscan_numobj_frac (iof *I, ppobj *obj, int negative)
-{
-  ppnum number;
-  int c, exponent;
-
-  number = 0.0;
-  c = iof_next(I);
-  iof_scan_fraction(I, c, number, exponent);
-  double_negative_exp10(number, exponent);
-  obj->type = PPNUM, obj->number = negative ? -number : number;
-  return obj;
-}
-
-static int ppscan_find (iof *I)
-{ // skips whitechars and comments
-  int c;
-  for (c = iof_char(I); ; c = iof_next(I))
-  {
-    switch (c)
-    {
-      case IGNORED_CHAR_CASE:
-        break;
-      case '%': {
-        do {
-          if ((c = iof_next(I)) < 0)
-            return c;
-        } while (!newline_char(c));
-        break;
-      }
-      default:
-        return c;
-    }
-  }
-  return c; // never reached
-}
-
-static int ppscan_keyword (iof *I, const char *keyword, size_t size)
-{
-  size_t i;
-  int c;
-  if (iof_left(I) >= size)
-  {
-    if (memcmp(I->pos, keyword, size) != 0)
-      return 0;
-    I->pos += size;
-    return 1;
-  }
-  // sticky case, we can't go back
-  for (i = 0, c = iof_char(I); i < size; ++i, ++keyword, c = iof_next(I))
-    if (i != c)
-      return 0;
-  return 1;
-}
-
-#define ppscan_key(I, literal) ppscan_keyword(I, "" literal, sizeof(literal) - 1)
-
-/* objects parser */
-
-static ppref * ppref_unresolved (ppheap **pheap, ppuint refnumber, ppuint refversion)
-{
-  ppref *ref = (ppref *)ppheap_take(pheap, sizeof(ppref));
-  memset(ref, 0, sizeof(ppref));
-  ref->object.type = PPNONE;
-  ref->number = refnumber;
-  ref->version = refversion;
-  return ref;
-}
-
-#define PPMARK PPNONE
-
-static ppobj * ppscan_obj (iof *I, ppdoc *pdf, ppxref *xref)
-{
-  int c;
-  ppobj *obj;
-  size_t mark, size;
-  ppuint refnumber, refversion;
-  ppref *ref;
-  ppstack *stack;
-  ppcrypt *crypt;
-
-  stack = &pdf->stack;
-  c = iof_char(I);
-  switch (c)
-  {
-    case DIGIT_CHAR_CASE:
-      return ppscan_numobj(I, ppstack_push(stack), 0);
-    case '.':
-      return ppscan_numobj_frac(I, ppstack_push(stack), 0);
-    case '+':
-      ++I->pos;
-      return ppscan_numobj(I, ppstack_push(stack), 0);
-    case '-':
-      ++I->pos;
-      return ppscan_numobj(I, ppstack_push(stack), 1);
-    case '/':
-      ++I->pos;
-      obj = ppstack_push(stack);
-      obj->type = PPNAME;
-      obj->name = ppscan_name(I, &pdf->heap);
-      return obj;
-    case '(':
-      ++I->pos;
-      obj = ppstack_push(stack);
-      obj->type = PPSTRING;
-      if (ppcrypt_ref(pdf, crypt))
-        obj->string = ppscan_crypt_string(I, crypt, &pdf->heap);
-      else
-        obj->string = ppscan_string(I, &pdf->heap);
-      return obj;
-    case '[':
-      mark = stack->size;
-      obj = ppstack_push(stack);
-      obj->type = PPMARK; // ppscan_obj() checks types backward for 'R', so set the type immediatelly (reserved for PPARRAY)
-      obj->any = NULL;
-      ++I->pos;
-      for (c = ppscan_find(I); c != ']'; c = ppscan_find(I))
-      {
-        if (ppscan_obj(I, pdf, xref) == NULL)
-        { // callers assume that NULL returns means nothing pushed
-          size = stack->size - mark; // pop items AND the obj reserved for array
-          ppstack_pop(stack, size);
-          return NULL;
-        }
-      }
-      ++I->pos;
-      size = stack->size - mark - 1;
-      obj = ppstack_at(stack, mark); // stack might have been realocated
-      obj->type = PPARRAY;
-      obj->array = pparray_create(ppstack_at(stack, mark + 1), size, &pdf->heap);
-      ppstack_pop(stack, size); // pop array items, leave the array on top
-      return obj;
-    case '<':
-      if ((c = iof_next(I)) == '<')
-      {
-        mark = stack->size;
-        obj = ppstack_push(stack);
-        obj->type = PPMARK;
-        obj->any = NULL;
-        ++I->pos;
-        for (c = ppscan_find(I); c != '>'; c = ppscan_find(I))
-        {
-          if (ppscan_obj(I, pdf, xref) == NULL)
-          {
-            size = stack->size - mark;
-            ppstack_pop(stack, size);
-            return NULL;
-          }
-        }
-        if (iof_next(I) == '>')
-          ++I->pos;
-        size = stack->size - mark - 1;
-        obj = ppstack_at(stack, mark);
-        obj->type = PPDICT;
-        obj->dict = ppdict_create(ppstack_at(stack, mark + 1), size, &pdf->heap);
-        ppstack_pop(stack, size);
-        return obj;
-      }
-      obj = ppstack_push(stack);
-      obj->type = PPSTRING;
-      if (ppcrypt_ref(pdf, crypt))
-        obj->string = ppscan_crypt_base16(I, crypt, &pdf->heap);
-      else
-        obj->string = ppscan_base16(I, &pdf->heap);
-      return obj;
-    case 'R':
-      if (stack->size >= 2 && stack->pos[-1].type == PPINT && stack->pos[-2].type == PPINT)
-      {
-        ++I->pos;
-        obj = &stack->pos[-2];
-        refnumber = (ppuint)obj->integer;
-        ppstack_pop(stack, 1); // pop version number, retype obj to a reference
-        if (xref == NULL || (ref = ppxref_find(xref, refnumber)) == NULL)
-        { /* pdf spec page 64: unresolvable reference is not an error, should just be treated as a reference to null.
-             we also need this to read trailer, where refs can't be resolved yet */
-          refversion = (obj + 1)->integer;
-          //if (xref != NULL)
-          //  loggerf("unresolved reference %s", ppref_str(refnumber, refversion));
-          ref = ppref_unresolved(stack->pheap, refnumber, refversion);
-        }
-        obj->type = PPREF;
-        obj->ref = ref;
-        return obj;
-      }
-      break;
-    case 't':
-      if (iof_next(I) == 'r' && iof_next(I) == 'u' && iof_next(I) == 'e')
-      {
-        ++I->pos;
-        obj = ppstack_push(stack);
-        obj->type = PPBOOL;
-        obj->integer = 1;
-        return obj;
-      }
-      break;
-    case 'f':
-      if (iof_next(I) == 'a' && iof_next(I) == 'l' && iof_next(I) == 's' && iof_next(I) == 'e')
-      {
-        ++I->pos;
-        obj = ppstack_push(stack);
-        obj->type = PPBOOL;
-        obj->integer = 0;
-        return obj;
-      }
-      break;
-    case 'n':
-      if (iof_next(I) == 'u' && iof_next(I) == 'l' && iof_next(I) == 'l')
-      {
-        ++I->pos;
-        obj = ppstack_push(stack);
-        obj->type = PPNULL;
-        obj->any = NULL;
-        return obj;
-      }
-      break;
-  }
-  return NULL;
-}
-
-/*
-A variant for contents streams (aka postscript); wise of operators, blind to references.
-We are still PDF, so we don't care about postscript specific stuff such as radix numbers
-and scientific numbers notation. It takes ppstack * as context (no ppdoc *) to be able
-to run contents parser beyond the scope of ppdoc heap.
-*/
-
-static ppstring ppstring_inline (iof *I, ppdict *imagedict, ppheap **pheap);
-
-static ppobj * ppscan_psobj (iof *I, ppstack *stack)
-{
-  int c;
-  ppobj *obj, *op;
-  size_t size, mark;
-  ppname exec;
-
-  c = iof_char(I);
-  switch (c)
-  {
-    case DIGIT_CHAR_CASE:
-      return ppscan_numobj(I, ppstack_push(stack), 0);
-    case '.':
-      return ppscan_numobj_frac(I, ppstack_push(stack), 0);
-    case '+':
-      c = iof_next(I);
-      if (base10_digit(c)) // '+.abc' is probably an executable name, but we are not in postscript
-        return ppscan_numobj(I, ppstack_push(stack), 0);
-      else if (c == '.')
-        return ppscan_numobj_frac(I, ppstack_push(stack), 0);
-      obj = ppstack_push(stack);
-      obj->type = PPNAME;
-      obj->name = ppscan_exec(I, stack->pheap, '+');
-      return obj;
-    case '-':
-      c = iof_next(I);
-      if (base10_digit(c)) // ditto, we would handle type1 '-|' '|-' operators though
-        return ppscan_numobj(I, ppstack_push(stack), 1);
-      else if (c == '.')
-        return ppscan_numobj_frac(I, ppstack_push(stack), 1);
-      obj = ppstack_push(stack);
-      obj->type = PPNAME;
-      obj->name = ppscan_exec(I, stack->pheap, '-');
-      return obj;
-    case '/':
-      ++I->pos;
-      obj = ppstack_push(stack);
-      obj->type = PPNAME;
-      obj->name = ppscan_name(I, stack->pheap);
-      return obj;
-    case '(':
-      ++I->pos;
-      obj = ppstack_push(stack);
-      obj->type = PPSTRING;
-      obj->string = ppscan_string(I, stack->pheap);
-      return obj;
-    case '[':
-      mark = stack->size;
-      obj = ppstack_push(stack);
-      obj->type = PPMARK;
-      obj->any = NULL;
-      ++I->pos;
-      for (c = ppscan_find(I); c != ']'; c = ppscan_find(I))
-      {
-        if (ppscan_psobj(I, stack) == NULL)
-        {
-          size = stack->size - mark;
-          ppstack_pop(stack, size);
-          return NULL;
-        }
-      }
-      ++I->pos;
-      size = stack->size - mark - 1;
-      obj = ppstack_at(stack, mark);
-      obj->type = PPARRAY;
-      obj->array = pparray_create(ppstack_at(stack, mark + 1), size, stack->pheap);
-      ppstack_pop(stack, size);
-      return obj;
-    case '<':
-      if ((c = iof_next(I)) == '<')
-      {
-        mark = stack->size;
-        obj = ppstack_push(stack);
-        obj->type = PPMARK;
-        obj->any = NULL;
-        ++I->pos;
-        for (c = ppscan_find(I); c != '>'; c = ppscan_find(I))
-        {
-          if (ppscan_psobj(I, stack) == NULL)
-          {
-            size = stack->size - mark;
-            ppstack_pop(stack, size);
-            return NULL;
-          }
-        }
-        if (iof_next(I) == '>')
-          ++I->pos;
-        size = stack->size - mark - 1;
-        obj = ppstack_at(stack, mark);
-        obj->type = PPDICT;
-        obj->dict = ppdict_create(ppstack_at(stack, mark + 1), size, stack->pheap);
-        ppstack_pop(stack, size);
-        return obj;
-      }
-      obj = ppstack_push(stack);
-      obj->type = PPSTRING;
-      if (c == '~')
-        ++I->pos, obj->string = ppscan_base85(I, stack->pheap);
-      else
-        obj->string = ppscan_base16(I, stack->pheap);
-      return obj;
-    default:
-      if (c < 0 || !ppname_byte_lookup[c])
-        break; // forbid empty names; dead loop otherwise
-      ++I->pos;
-      /* true false null practically don't occur in streams so it makes sense to assume that we get an operator name here.
-         If it happen to be a keyword we could give back those several bytes to the heap but.. heap buffer is tricky enough. */
-      exec = ppscan_exec(I, stack->pheap, c);
-      obj = ppstack_push(stack);
-      switch (exec[0])
-      {
-        case 't':
-          if (exec[1] == 'r' && exec[2] == 'u' && exec[3] == 'e' && exec[4] == '\0')
-          {
-            obj->type = PPBOOL;
-            obj->integer = 1;
-            // todo: drop exec
-            return obj;
-          }
-          break;
-        case 'f':
-          if (exec[1] == 'a' && exec[2] == 'l' && exec[3] == 's' && exec[4] == 'e' && exec[5] == '\0')
-          {
-            obj->type = PPBOOL;
-            obj->integer = 0;
-            // todo: drop exec
-            return obj;
-          }
-          break;
-        case 'n':
-          if (exec[1] == 'u' && exec[2] == 'l' && exec[3] == 'l' && exec[4] == '\0')
-          {
-            obj->type = PPNULL;
-            obj->any = NULL;
-            // todo: drop exec
-            return obj;
-          }
-          break;
-        case 'B':
-           /*
-           Inline images break rules of operand/operator syntax, so 'BI/ID' operators need to be treated as special syntactic keywords.
-
-             BI <keyval pairs> ID<whitechar?><imagedata><whitechar?>EI
-
-           We treat the image as a single syntactic token; BI starts collecting a dict, ID is the beginning of the data. Effectively EI
-           operator obtains two operands - dict and string. It is ok to put three items onto the stack, callers dont't assume there is just one.
-           */
-          if (exec[1] == 'I' && exec[2] == '\0')
-          {
-            ppdict *imagedict;
-            /* key val pairs -> dict */
-            mark = stack->size - 1;
-            obj->type = PPMARK;
-            obj->any = NULL;
-            for (c = ppscan_find(I); ; c = ppscan_find(I))
-            {
-              if ((op = ppscan_psobj(I, stack)) == NULL)
-              {
-                size = stack->size - mark;
-                ppstack_pop(stack, size);
-                return NULL;
-              }
-              if (op->type == PPNAME && ppname_exec(op->name))
-              {
-                if (!ppname_is(op->name, "ID"))
-                { // weird
-                  size = stack->size - mark;
-                  ppstack_pop(stack, size);
-                  return NULL;
-                }
-                break;
-              }
-            }
-            size = stack->size - mark - 1;
-            obj = ppstack_at(stack, mark);
-            obj->type = PPDICT;
-            obj->dict = imagedict = ppdict_create(ppstack_at(stack, mark + 1), size, stack->pheap);
-            ppstack_pop(stack, size);
-            /* put image data string */
-            obj = ppstack_push(stack);
-            obj->type = PPSTRING;
-            obj->string = ppstring_inline(I, imagedict, stack->pheap);;
-            /* put EI operator name */
-            obj = ppstack_push(stack);
-            obj->type = PPNAME;
-            obj->name = ppexec_internal("EI", 2, stack->pheap);
-            return obj;
-          }
-      }
-      obj->type = PPNAME;
-      obj->name = exec;
-      return obj;
-  }
-  return NULL;
-}
-
-/*
-We try to get the exact inline image length from its dict params. If cannot predict the length, we have to scan the input until 'EI'.
-I've checked on may examples that it gives the same results but one can never be sure, as 'EI' might happen to be a part of the data.
-Stripping white char is also very heuristic; \0 is a white char in PDF and very likely to be a data byte.. weak method.
-*/
-
-static size_t inline_image_length (ppdict *dict)
-{
-  ppuint w, h, bpc, colors;
-  ppname cs;
-
-  if (ppdict_get_uint(dict, "W", &w) && ppdict_get_uint(dict, "H", &h) && ppdict_get_uint(dict, "BPC", &bpc) && (cs = ppdict_get_name(dict, "CS")) != NULL)
-  {
-    if (ppname_is(cs, "DeviceGray"))
-      colors = 1;
-    else if (ppname_is(cs, "DeviceRGB"))
-      colors = 3;
-    else if (ppname_is(cs, "DeviceCMYK"))
-      colors = 4;
-    else
-      return PP_LENGTH_UNKNOWN;
-    return (w * h * bpc * colors + 7) >> 3;
-  }
-  return PP_LENGTH_UNKNOWN;
-}
-
-static ppstring ppstring_inline (iof *I, ppdict *imagedict, ppheap **pheap)
-{
-  iof *O;
-  int c, d, e;
-  size_t length, leftin, leftout, bytes;
-
-  O = ppheap_buffer(pheap, sizeof(_ppstring), PPSTRING_INIT);
-  c = iof_char(I);
-  if (ignored_char(c))
-    c = iof_next(I);
-
-  length = inline_image_length(imagedict);
-  if (length != PP_LENGTH_UNKNOWN)
-  {
-    while (length > 0 && iof_readable(I) && iof_writable(O))
-    {
-      leftin = iof_left(I);
-      leftout = iof_left(O);
-      bytes = length;
-      if (bytes > leftin) bytes = leftin;
-      if (bytes > leftout) bytes = leftout;
-      memcpy(O->pos, I->pos, bytes);
-      I->pos += bytes;
-      O->pos += bytes;
-      length -= bytes;
-    }
-    // gobble EI
-    if (ppscan_find(I) == 'E')
-      if (iof_next(I) == 'I')
-        ++I->pos;
-  }
-  else
-  {
-    while (c >= 0)
-    {
-      if (c == 'E')
-      {
-        d = iof_next(I);
-        if (d == 'I')
-        {
-          e = iof_next(I);
-          if (!ppname_byte_lookup[e])
-          { /* strip one newline from the end and stop */
-            if (O->pos - 2 >= O->buf) // sanity
-            {
-              c = *(O->pos - 1);
-              if (ignored_char(c))
-              {
-                if (c == 0x0A && *(O->pos - 2) == 0x0D)
-                  O->pos -= 2;
-                else
-                  O->pos -= 1;
-              }
-            }
-            break;
-          }
-          iof_put2(O, c, d);
-          c = e;
-        }
-        else
-        {
-          iof_put(O, c);
-          c = d;
-        }
-      }
-      else
-      {
-        iof_put(O, c);
-        c = iof_next(I);
-      }
-    }
-  }
-  return ppstring_buffer(O, pheap);
-}
-
-/* input reader */
-
-/*
-PDF input is a pseudo file that either keeps FILE * or data. Reader iof * is a proxy to input
-that provides byte-by-byte interface. Our iof structure is capable to link iof_file *input,
-but t avoid redundant checks on IOF_DATA flag, here we link iof *I directly to FILE * or mem buffer.
-When reading from file we need an internal buffer, which should be kept rather small, as it is
-only used to parse xrefs and objects (no streams). We allocate the buffer from a private heap
-(not static) to avoid conflicts when processing >1 pdfs at once. Besides, the input buffer may be
-needed after loading the document, eg. to access references raw data.
-*/
-
-#define PPDOC_BUFFER 0xFFF // keep that small, it is only used to parse body objects
-
-static void ppdoc_reader_init (ppdoc *pdf, iof_file *input)
-{
-  iof *I;
-  pdf->input = *input;
-  input = &pdf->input;
-  input->refcount = 1;
-  I = &pdf->reader;
-  if (input->flags & IOF_DATA)
-  {
-    pdf->buffer = NULL;            // input iof_file is the buffer
-    iof_string_reader(I, NULL, 0); // gets IOF_DATA flag
-  }
-  else
-  {
-    pdf->buffer = (uint8_t *)ppheap_take(&pdf->heap, PPDOC_BUFFER);
-    iof_setup_file_handle_reader(I, NULL, 0, iof_file_get_fh(input)); // gets IOF_FILE_HANDLE flag and FILE *
-    I->space = PPDOC_BUFFER; // used on refill
-  }
-}
-
-/*
-Whenever we need to read the input file, we fseek the to the given offset and fread to to the private buffer.
-The length we need is not always predictable, in which case PPDOC_BUFFER bytes are read (keep it small).
-I->buf = I->pos is set to the beginning, I->end set to the end (end is the first byte one shouldn't read).
-*/
-
-static iof * ppdoc_reader (ppdoc *pdf, size_t offset, size_t length)
-{
-  iof_file *input;
-  iof *I;
-  input = &pdf->input;
-  I = &pdf->reader;
-  if (iof_file_seek(input, offset, SEEK_SET) != 0)
-    return NULL;
-  I->flags &= ~IOF_STOPPED;
-  if (input->flags & IOF_DATA)
-  {
-    I->buf = I->pos = input->pos;
-    I->end = (length == PP_LENGTH_UNKNOWN || I->pos + length >= input->end) ? input->end : (I->pos + length);
-  }
-  else
-  {
-    I->buf = I->pos = pdf->buffer; // ->buf is actually permanently equal pdf->buffer but we might need some tricks
-    if (length == PP_LENGTH_UNKNOWN || length > PPDOC_BUFFER)
-      length = PPDOC_BUFFER;
-    length = fread(I->buf, 1, length, I->file);
-    I->end = I->buf + length;
-  }
-  return I;
-}
-
-/* The position from the beginning of input
-- for data buffer: (pdf->input.pos - pdf->input.buf) + (I->pos - I->buf)
-  I->buf == pdf->input.pos, so this resolves to (I->pos - pdf->input.buf), independent from I->buf
-- for file buffer: ftell(pdf->input.file) - (I->end - I->pos)
-*/
-
-#define ppdoc_reader_tell(pdf, I) ((size_t)(((pdf)->input.flags & IOF_DATA) ? ((I)->pos - (pdf)->input.buf) : (ftell(iof_file_get_fh(&(pdf)->input)) - ((I)->end - (I)->pos))))
-
-/* pdf */
-
-#define PPDOC_HEADER 10 // "%PDF-?.??\n"
-
-static int ppdoc_header (ppdoc *pdf, uint8_t header[PPDOC_HEADER])
-{
-  size_t i;
-  if (memcmp(header, "%PDF-", 5) != 0)
-    return 0;
-  for (i = 5; i < PPDOC_HEADER - 1 && !ignored_char(header[i]); ++i)
-    pdf->version[i - 5] = header[i];
-  pdf->version[i - 5] = '\0';
-  return 1;
-}
-
-static int ppdoc_tail (ppdoc *pdf, iof_file *input, size_t *pxrefoffset)
-{
-  int c;
-  uint8_t tail[4*10], *p, back, tailbytes;
-
-  if (iof_file_seek(input, 0, SEEK_END) != 0)
-    return 0;
-  pdf->filesize = (size_t)iof_file_tell(input);
-  // simple heuristic to avoif fgetc() / fseek(-2) hiccup: keep seeking back by len(startxref) + 1 == 10
-  // until a letter found (assuming liberal white characters and tail length)
-  for (back = 1, tailbytes = 0; ; ++back)
-  {
-    if (iof_file_seek(input, -10, SEEK_CUR) != 0)
-      return 0;
-    tailbytes += 10;
-    c = iof_file_getc(input);
-    tailbytes -= 1;
-    switch (c)
-    {
-      case IGNORED_CHAR_CASE:
-      case DIGIT_CHAR_CASE:
-      case '%': case 'E': case 'O': case 'F':
-        if (back > 4) // 2 should be enough
-          return 0;
-        continue;
-      case 's': case 't': case 'a': case 'r': case 'x': case 'e': case 'f':
-        if (iof_file_read(tail, 1, tailbytes, input) != tailbytes)
-          return 0;
-        tail[tailbytes] = '\0';
-        for (p = &tail[0]; ; ++p)
-        {
-          if (*p == '\0')
-            return 0;
-          if ((c = base10_value(*p)) >= 0)
-            break;
-        }
-        ppread_uint(p, pxrefoffset);
-        return 1;
-      default:
-        return 0;
-    }
-  }
-  return 0;
-}
-
-/* xref/body */
-
-static int ppscan_start_entry (iof *I, ppref *ref)
-{
-  ppuint u;
-  ppscan_find(I); if (!ppscan_uint(I, &u) || u != ref->number) return 0;
-  ppscan_find(I); if (!ppscan_uint(I, &u) || u != ref->version) return 0;
-  ppscan_find(I); if (!ppscan_key(I, "obj")) return 0;
-  ppscan_find(I);
-  return 1;
-}
-
-static int ppscan_skip_entry (iof *I)
-{
-  size_t u;
-  ppscan_find(I); if (!ppscan_uint(I, &u)) return 0;
-  ppscan_find(I); if (!ppscan_uint(I, &u)) return 0;
-  ppscan_find(I); if (!ppscan_key(I, "obj")) return 0;
-  ppscan_find(I);
-  return 1;
-}
-
-static int ppscan_start_stream (iof *I, ppdoc *pdf, size_t *streamoffset)
-{
-  int c;
-  ppscan_find(I);
-  if (ppscan_key(I, "stream"))
-  { // skip 1 or 2 whites (here we shouldn't just gobble all blanks)
-    c = iof_char(I);
-    if (ignored_char(c))
-    {
-      c = iof_next(I);
-      if (ignored_char(c))
-        ++I->pos;
-    }
-    *streamoffset = ppdoc_reader_tell(pdf, I);
-    return 1;
-  }
-  return 0;
-}
-
-static ppxref * ppxref_load (ppdoc *pdf, size_t xrefoffset);
-static ppxref * ppxref_load_chain (ppdoc *pdf, ppxref *xref);
-
-/* Parsing xref table
-
-  1 10               // first ref number and refs count
-  0000000000 00000 n // 10-digits offset, 5 digits version, type identifier
-  0000000000 00000 n // n states for normal I guess
-  0000000000 00000 f // f states for free (not used)
-  ...
-
-Free entries seem to be a relic of ancient times, completelly useless for us. To avoid parsing xref table twice,
-we waste some space on free entries by allocating one plane of refs for each section. Later on we slice sections,
-so that effectively free entries are not involved in map.
-
-Subsequent refs gets number, version and offset. Other fields initialized when parsing PDF body.
-
-Having xref table loaded, we sort sections for future binary search (xref with objects count == 0 is considered invalid).
-
-Then we have to deal with the trailer dict. In general, to load objects and resolve references we need a complete chain
-of xrefs (not only the top). To load the previous xref, we need its offset, which is given in trailer. So we have to
-parse the trailer ignoring references, which might be unresolvable at this point (objects parser makes a dummy check
-for xref != NULL on refs resolving ppscan_obj(), which irritates me but I don't want a separate parser for trailer..).
-The same applies to xref streams, in which we have parse the trailer not having xref map at all. So the procedure is:
-
-  - load xref map, initialize references, make it ready to search
-  - parse trailer ignoring references
-  - get /Prev xref offset and load older xref (linked list via ->prev)
-  - sort all refs in all xrefs by offset
-  - parse refs in order resolving references in contained objects
-  - fix trailer references
-
-First created xref becomes a pdf->xref (top xref). We link that early to control offsets already read (insane loops?).
-*/
-
-// Every xref table item "0000000000 00000 n" is said to be terminated with 2-byte EOL but we don't like relying on whites.
-#define xref_item_length (10+1+5+1+1)
-
-static ppxref * ppxref_load_table (iof *I, ppdoc *pdf, size_t xrefoffset)
-{
-  ppxref *xref;
-  ppxsec *xrefsection;
-  ppref *ref;
-  ppuint first, count, refindex;
-  uint8_t buffer[xref_item_length + 1];
-  const char *p;
-  const ppobj *obj;
-
-  buffer[xref_item_length] = '\0';
-  xref = ppxref_create(pdf, 0, xrefoffset);
-  if (pdf->xref == NULL) pdf->xref = xref;
-  for (ppscan_find(I); ppscan_uint(I, &first); ppscan_find(I))
-  {
-    ppscan_find(I);
-    if (!ppscan_uint(I, &count))
-      return NULL;
-    if (count == 0) // weird
-      continue;
-    xref->count += count;
-    xrefsection = NULL;
-    ref = (ppref *)ppheap_take(&pdf->heap, count * sizeof(ppref));
-    for (refindex = 0; refindex < count; ++refindex, ++ref)
-    {
-      ref->xref = xref;
-      ref->number = first + refindex;
-      ppscan_find(I);
-      iof_read(I, buffer, xref_item_length);
-      switch (buffer[xref_item_length - 1])
-      {
-        case 'n':
-          if (xrefsection == NULL)
-          {
-            xrefsection = ppxref_push_section(xref, &pdf->heap);
-            xrefsection->first = ref->number;
-            xrefsection->refs = ref;
-          }
-          xrefsection->last = ref->number;
-          for (p = (const char *)buffer; *p == '0'; ++p);
-          p = ppread_uint(p, &ref->offset);
-          for ( ; *p == ' ' || *p == '0'; ++p);
-          p = ppread_uint(p, &ref->version);
-          ref->object.type = PPNONE; // init for sanity
-          ref->object.any = NULL;
-          ref->length = 0;
-          break;
-        case 'f':
-        default:
-          --ref;
-          xrefsection = NULL;
-          --xref->count;
-      }
-    }
-  }
-  /* sort section */
-  if (!ppxref_sort(xref))
-    ; // case of xref->size == 0 handled by ppxref_load_chain()
-  /* get trailer ignoring refs */
-  if (!ppscan_key(I, "trailer"))
-    return NULL;
-  ppscan_find(I);
-  if ((obj = ppscan_obj(I, pdf, NULL)) == NULL)
-    return NULL;
-  ppstack_pop(&pdf->stack, 1);
-  if (obj->type != PPDICT)
-    return NULL;
-  xref->trailer = *obj;
-  return ppxref_load_chain(pdf, xref);
-}
-
-/* Parsing xref stream
-First we load the trailer, ignoring references. Dict defines sections and fields lengths:
-
-  /Size                                  % max ref number plus 1
-  /Index [ first count first count ... ] % a pair of numbers for every section, defaults to [0 Size]
-  /W [w1 w2 w3]                          % fields lengths, 0 states for omitted field
-
-xref stream data is a continuous stream of binary number triplets. First number is a type:
-
-  0 - free entry (as 'f' in xref table)
-  1 - normal entry, followed by offset an version (as 'n' in xref table)
-  2 - compressed entry, followed by parent object stream number and entry index
-
-0 and 1 are handled as 'n' and 'f' entries in xref table. For type 2 we normally initialize
-ref->number and ref->version (the later is implicitly 0). ref->offset is set to 0 (invalid offset),
-which is recognized by objects loader.
-*/
-
-#define XREF_STREAM_MAX_FIELD 4
-
-static ppxref * ppxref_load_stream (iof *I, ppdoc *pdf, size_t xrefoffset)
-{
-  ppxref *xref;
-  ppxsec *xrefsection;
-  ppref *ref;
-  ppobj *obj;
-  ppstream *xrefstream;
-  size_t streamoffset;
-  ppuint w1, w2, w3, w, bufferbytes;
-  uint8_t buffer[3 * XREF_STREAM_MAX_FIELD], *b;
-  ppuint first, count, f1, f2, f3;
-  pparray *fieldwidths, *sectionindices;
-  ppobj sectionmock[2], *sectionfirst, *sectioncount;
-  size_t sections, sectionindex, refindex;
-
-  if (!ppscan_skip_entry(I))
-    return NULL;
-  if ((obj = ppscan_obj(I, pdf, NULL)) == NULL)
-    return NULL;
-  ppstack_pop(&pdf->stack, 1);
-  if (obj->type != PPDICT || !ppscan_start_stream(I, pdf, &streamoffset))
-    return NULL;
-  xrefstream = ppstream_create(pdf, obj->dict, streamoffset);
-  /* All normal streams go through ppstream_info(), but it makes no sense for trailer stream (no crypt allowed, no refs yet).
-     So we just record the length and informative flag. Here we have to expect that /Length and /Filter are not indirects. */
-  if (!ppdict_get_uint(obj->dict, "Length", &xrefstream->length))
-    return NULL;
-  if (ppdict_get_obj(obj->dict, "Filter") != NULL)
-    xrefstream->flags |= PPSTREAM_COMPRESSED;
-  if ((fieldwidths = ppdict_get_array(xrefstream->dict, "W")) != NULL)
-  {
-    if (!pparray_get_uint(fieldwidths, 0, &w1)) w1 = 0;
-    if (!pparray_get_uint(fieldwidths, 1, &w2)) w2 = 0;
-    if (!pparray_get_uint(fieldwidths, 2, &w3)) w3 = 0;
-  }
-  else
-    w1 = w2 = w3 = 0;
-  if (w1 > XREF_STREAM_MAX_FIELD || w2 > XREF_STREAM_MAX_FIELD || w3 > XREF_STREAM_MAX_FIELD)
-    return NULL;
-  bufferbytes = w1 + w2 + w3;
-  if ((sectionindices = ppdict_get_array(xrefstream->dict, "Index")) != NULL)
-  {
-    sections = sectionindices->size >> 1;
-    sectionfirst = sectionindices->data;
-  }
-  else
-  {
-    sections = 1;
-    sectionmock[0].type = PPINT;
-    sectionmock[0].integer = 0;
-    sectionmock[1].type = PPINT;
-    if (!ppdict_get_int(xrefstream->dict, "Size", &sectionmock[1].integer))
-      sectionmock[1].integer = 0;
-    sectionfirst = &sectionmock[0];
-  }
-  if ((I = ppstream_read(xrefstream, 1, 0)) == NULL)
-    return NULL; // we fseek() so original I is useless anyway
-  xref = ppxref_create(pdf, sections, xrefoffset);
-  if (pdf->xref == NULL) pdf->xref = xref;
-  xref->trailer.type = PPSTREAM;
-  xref->trailer.stream = xrefstream;
-  for (sectionindex = 0; sectionindex < sections; ++sectionindex, sectionfirst += 2)
-  {
-    sectioncount = sectionfirst + 1;
-    if (!ppobj_get_uint(sectionfirst, first) || !ppobj_get_uint(sectioncount, count))
-      goto xref_stream_error;
-    if (count == 0)
-      continue;
-    xref->count += count;
-    xrefsection = NULL;
-    ref = (ppref *)ppheap_take(&pdf->heap, count * sizeof(ppref));
-    for (refindex = 0; refindex < count; ++refindex, ++ref)
-    {
-      ref->xref = xref;
-      ref->number = first + refindex;
-      if (iof_read(I, buffer, bufferbytes) != bufferbytes)
-        goto xref_stream_error;
-      b = buffer;
-      if (w1 == 0)
-        f1 = 1; // default type is 1
-      else
-        for (f1 = 0, w = 0; w < w1; f1 = (f1 << 8)|(*b), ++w, ++b);
-      for (f2 = 0, w = 0; w < w2; f2 = (f2 << 8)|(*b), ++w, ++b);
-      for (f3 = 0, w = 0; w < w3; f3 = (f3 << 8)|(*b), ++w, ++b);
-      switch (f1)
-      {
-        case 0:
-          //--ref;
-          xrefsection = NULL;
-          --xref->count;
-          break;
-        case 1:
-          if (xrefsection == NULL)
-          {
-            xrefsection = ppxref_push_section(xref, &pdf->heap);
-            xrefsection->first = ref->number;
-            xrefsection->refs = ref;
-          }
-          xrefsection->last = ref->number;
-          ref->offset = f2;
-          ref->version = f3;
-          ref->object.type = PPNONE;
-          ref->object.any = NULL;
-          ref->length = 0;
-          break;
-        case 2:
-          if (xrefsection == NULL)
-          {
-            xrefsection = ppxref_push_section(xref, &pdf->heap);
-            xrefsection->first = ref->number;
-            xrefsection->refs = ref;
-          }
-          xrefsection->last = ref->number;
-          ref->offset = 0; // f2 is parent objstm, f3 is index in parent, both useless
-          ref->version = 0; // compressed objects has implicit version == 0
-          ref->object.type = PPNONE;
-          ref->object.any = NULL;
-          ref->length = 0;
-          break;
-        default:
-          goto xref_stream_error;
-      }
-    }
-  }
-  /* sort sections */
-  if (!ppxref_sort(xref))
-    ; // case of xref->size == 0 handled by ppxref_load_chain()
-  /* close the stream _before_ loading prev xref */
-  ppstream_done(xrefstream);
-  /* load prev and return */
-  return ppxref_load_chain(pdf, xref);
-xref_stream_error:
-  ppstream_done(xrefstream);
-  return NULL;
-}
-
-/*
-The following procedure loads xref /Prev, links xref->prev and typically returns xref.
-Some docs contain empty xref (one section with zero objects) that is actually a proxy
-to xref stream referred as /XRefStm (genuine concept of xrefs old/new style xrefs in
-the same doc). In case of 0-length xref we ignore the proxy and return the target xref
-(otherwise we would need annoying sanity check for xref->size > 0 on every ref search).
-*/
-
-static ppxref * ppxref_load_chain (ppdoc *pdf, ppxref *xref)
-{
-  ppdict *trailer;
-  ppuint xrefoffset;
-  ppxref *prevxref, *nextxref;
-
-  trailer = ppxref_trailer(xref);
-  if (!ppdict_get_uint(trailer, "Prev", &xrefoffset)) // XRefStm is useless
-    return xref; // missing /Prev is obviously ok
-  for (nextxref = pdf->xref; nextxref != NULL; nextxref = nextxref->prev)
-    if (nextxref->offset == xrefoffset) // insane
-      return NULL;
-  if ((prevxref = ppxref_load(pdf, (size_t)xrefoffset)) == NULL)
-    return NULL;
-  if (xref->size > 0)
-  {
-    xref->prev = prevxref;
-    return xref;
-  }
-  if (pdf->xref == xref)
-    pdf->xref = prevxref;
-  return prevxref;
-}
-
-static ppxref * ppxref_load (ppdoc *pdf, size_t xrefoffset)
-{
-  iof *I;
-  if ((I = ppdoc_reader(pdf, xrefoffset, PP_LENGTH_UNKNOWN)) == NULL)
-    return NULL;
-  ppscan_find(I);
-  if (ppscan_key(I, "xref"))
-    return ppxref_load_table(I, pdf, xrefoffset);
-  return ppxref_load_stream(I, pdf, xrefoffset);
-  // iof_close(I) does nothing here
-}
-
-static void ppoffmap_sort (ppref **left, ppref **right)
-{
-  ppref **l, **r, *t;
-  ppuint pivot;
-  l = left, r = right;
-  pivot = (*(l + ((r - l) / 2)))->offset;
-  do
-  { // don't read from pointer!
-    while ((*l)->offset < pivot) ++l;
-    while ((*r)->offset > pivot) --r;
-    if (l <= r)
-    {
-      t = *l;
-      *l = *r;
-      *r = t;
-      ++l, --r;
-    }
-  } while (l <= r);
-  if (left < r)
-    ppoffmap_sort(left, r);
-  if (l < right)
-    ppoffmap_sort(l, right);
-}
-
-
-static void fix_trailer_references (ppdoc *pdf)
-{
-  ppxref *xref;
-  ppdict *trailer;
-  ppname *pkey;
-  ppobj *obj;
-  ppref *ref;
-  for (xref = pdf->xref; xref != NULL; xref = xref->prev)
-  {
-    if ((trailer = ppxref_trailer(xref)) == NULL)
-      continue;
-    for (ppdict_first(trailer, pkey, obj); *pkey != NULL; ppdict_next(pkey, obj))
-    { // no need to go deeper in structs, all items in trailer except info and root must be direct refs
-      if (obj->type != PPREF)
-        continue;
-      ref = obj->ref;
-      if (ref->offset == 0) // unresolved?
-        if ((ref = ppxref_find(xref, ref->number)) != NULL)
-          obj->ref = ref; // at this moment the reference still points nothing, but should be the one with the proper offset
-    }
-  }
-}
-
-/*
-Here comes a procedure that loads all entries from all document bodies. We resolve references while
-parsing objects and to make resolving correct, we need a complete chain of xref maps, and a knowledge
-about possible linearized dict (first offset). So loading refs sorted by offsets makes sense (not sure
-if it matters nowadays but we also avoid fseek() by large offsets).
-
-Here is the proc:
-
-  - create a list of all refs in all bodies
-  - sort the list by offsets
-  - for every ref from the sorted list:
-    - estimate object length to avoid fread-ing more than necessary (not perfect but enough)
-    - fseek() to the proper offset, fread() entry data or its part
-    - parse the object with ppscan_obj(I, pdf, xref), where xref is not necessarily top pdf->xref
-    - save the actual ref->length (not sure if we need that?)
-    - make a stream if a dict is followed by "stream" keyword, also save the stream offset
-  - free the list
-*/
-
-static int ppdoc_load_objstm (ppstream *stream, ppdoc *pdf, ppxref *xref);
-
-static void ppdoc_load_entries (ppdoc *pdf)
-{
-  size_t objects, sectionindex, refnumber, offindex;
-  ppnum linearized;
-  ppref **offmap, **pref, *ref;
-  ppxref *xref;
-  ppxsec *xsec;
-  ppobj *obj;
-  ppname type;
-  int redundant_indirection = 0;
-  ppcrypt *crypt;
-  ppstream *stream;
-
-  if ((objects = (size_t)ppdoc_objects(pdf)) == 0) // can't happen
-    return;
-  pref = offmap = (ppref **)pp_malloc(objects * sizeof(ppref *));
-  objects = 0; // recount refs with offset > 0
-  for (xref = pdf->xref; xref != NULL; xref = xref->prev)
-    for (sectionindex = 0, xsec = xref->sects; sectionindex < xref->size; ++sectionindex, ++xsec)
-      for (refnumber = xsec->first, ref = xsec->refs; refnumber <= xsec->last; ++refnumber, ++ref)
-        if (ref->offset > 0) // 0 means compressed or insane
-          *pref++ = ref, ++objects;
-  ppoffmap_sort(offmap, offmap + objects - 1);
-
-  crypt = pdf->crypt;
-  for (offindex = 0, pref = offmap; offindex < objects; )
-  {
-    ref = *pref;
-    ++pref;
-    ++offindex;
-    if (ref->object.type != PPNONE) // might be preloaded already (/Encrypt dict, stream filter dicts, stream /Length..)
-    	continue;
-    if (offindex < objects)
-      ref->length = (*pref)->offset - ref->offset;
-    else
-      ref->length = pdf->filesize > ref->offset ? pdf->filesize - ref->offset : 0;
-    if (crypt != NULL)
-    {
-      ppcrypt_start_ref(crypt, ref);
-      obj = ppdoc_load_entry(pdf, ref);
-      ppcrypt_end_ref(crypt);
-    }
-    else
-    {
-      obj = ppdoc_load_entry(pdf, ref);
-    }
-    switch (obj->type)
-    {
-      case PPDICT: /* Check if the object at first offset is linearized dict. We need that to resolve all references properly. */
-        if (offindex == 1 && ppdict_get_num(obj->dict, "Linearized", &linearized)) // /Linearized value is a version number, default 1.0
-          pdf->flags |= PPDOC_LINEARIZED;
-        break;
-      case PPREF:
-        redundant_indirection = 1;
-        break;
-      default:
-        break;
-    }
-    // if pdf->crypt crypt->ref = NULL
-  }
-
-  /* refs pointngs refs? cut. */
-  if (redundant_indirection)
-  {
-    for (offindex = 0, pref = offmap; offindex < objects; ++offindex)
-    {
-      ref = *pref++;
-      if (ref->object.type == PPREF)
-        ref->object = ref->object.ref->object; // doing for all effectively cuts all insane chains
-    }
-  }
-
-  /* now handle streams; update stream info (eg. /Length), load pdf 1.5 object streams
-     we could do earlier but then we would need to struggle with indirects */
-  for (offindex = 0, pref = offmap; offindex < objects; ++offindex)
-  {
-    ref = *pref++;
-    obj = &ref->object;
-    if (obj->type != PPSTREAM)
-      continue;
-    stream = obj->stream;
-    if (crypt != NULL)
-    {
-      ppcrypt_start_ref(crypt, ref);
-      ppstream_info(stream, pdf);
-      ppcrypt_end_ref(crypt);
-    }
-    else
-    {
-      ppstream_info(stream, pdf);
-    }
-    if (ref->xref->trailer.type == PPSTREAM && (type = ppdict_get_name(stream->dict, "Type")) != NULL && ppname_is(type, "ObjStm")) // somewhat dummy..
-      if (!ppdoc_load_objstm(stream, pdf, ref->xref))
-        loggerf("invalid objects stream %s at offset " PPSIZEF, ppref_str(ref->number, ref->version), ref->offset);
-  }
-  pp_free(offmap);
-}
-
-ppobj * ppdoc_load_entry (ppdoc *pdf, ppref *ref)
-{
-  iof *I;
-  size_t length;
-  ppxref *xref;
-  ppobj *obj;
-  ppstack *stack;
-  size_t streamoffset;
-  ppref *refref;
-  ppuint refnumber, refversion;
-
-  length = ref->length > 0 ? ref->length : PP_LENGTH_UNKNOWN; // estimated or unknown
-  if ((I = ppdoc_reader(pdf, ref->offset, length)) == NULL || !ppscan_start_entry(I, ref))
-  {
-    loggerf("invalid %s offset " PPSIZEF, ppref_str(ref->number, ref->version), ref->offset);
-    return &ref->object; // PPNONE
-  }
-  stack = &pdf->stack;
-  xref = ref->xref; // to resolve indirects properly
-  if ((obj = ppscan_obj(I, pdf, xref)) == NULL)
-  {
-    loggerf("invalid %s object at offset " PPSIZEF, ppref_str(ref->number, ref->version), ref->offset);
-    return &ref->object; // PPNONE
-  }
-  ref->object = *obj;
-  ppstack_pop(stack, 1);
-  obj = &ref->object;
-  ref->length = ppdoc_reader_tell(pdf, I) - ref->offset;
-  if (obj->type == PPDICT)
-  {
-    if (ppscan_start_stream(I, pdf, &streamoffset))
-    {
-      obj->type = PPSTREAM;
-      obj->stream = ppstream_create(pdf, obj->dict, streamoffset);
-    }
-  }
-  else if (obj->type == PPINT)
-  {
-    ppscan_find(I);
-    if (ppscan_uint(I, &refversion) && ppscan_find(I) == 'R')
-    {
-      refnumber = (ppuint)obj->integer;
-      if ((refref = ppxref_find(xref, refnumber)) != NULL)
-      {
-        obj->type = PPREF;
-        obj->ref = refref;
-      }
-      else
-      {
-        obj->type = PPNONE; // as ppref_unresolved()
-        obj->any = NULL;
-      }
-    }
-  }
-  return obj;
-}
-
-/* Loading entries from object stream
-
-  /N is the number of contained entries
-  /First is the offset of the first item
-
-The stream consists of N pairs of numbers <objnum> <offset> <objnum> <offset> ...
-Offsets are ascending (relative to the first), but ref numbers order is arbitrary.
-PDF spec says there might be some additional data between objects, so we should obey offsets.
-Which means we should basically load the stream at once (may be needed anyway to grab the stream [...]).
-*/
-
-static int ppdoc_load_objstm (ppstream *stream, ppdoc *pdf, ppxref *xref)
-{
-  ppdict *dict; // stream dict, actually still on stack
-  ppref *ref;
-  ppobj *obj;
-  ppuint items, firstoffset, offset, objnum, i, invalid = 0;
-  iof *I;
-  uint8_t *firstdata, *indexdata;
-  ppstack *stack;
-
-  dict = stream->dict;
-  if (!ppdict_rget_uint(dict, "N", &items) || !ppdict_rget_uint(dict, "First", &firstoffset))
-    return 0;
-  if ((I = ppstream_read(stream, 1, 1)) == NULL)
-    return 0;
-  firstdata = I->pos + firstoffset;
-  if (firstdata >= I->end)
-    goto invalid_objstm;
-  stack = &pdf->stack;
-  //if (pdf->crypt != NULL)
-  //  ppcrypt_end_ref(pdf->crypt); // objects are not encrypted, pdf->crypt->ref ensured NULL
-  for (i = 0; i < items; ++i)
-  {
-    ppscan_find(I);
-    if (!ppscan_uint(I, &objnum))
-      goto invalid_objstm;
-    ppscan_find(I);
-    if (!ppscan_uint(I, &offset))
-      goto invalid_objstm;
-    if ((ref = ppxref_find_local(xref, objnum)) == NULL || ref->object.type != PPNONE)
-    {
-      loggerf("invalid compressed object number " PPUINTF " at position " PPUINTF, objnum, i);
-      ++invalid;
-      continue;
-    }
-    if (firstdata + offset >= I->end)
-    {
-      loggerf("invalid compressed object offset " PPUINTF " at position " PPUINTF, offset, i);
-      ++invalid;
-      continue;
-    }
-    indexdata = I->pos; // save position
-    I->pos = firstdata + offset; // go to the object
-    ppscan_find(I);
-    if ((obj = ppscan_obj(I, pdf, xref)) != NULL)
-    {
-      ref->object = *obj;
-      ppstack_pop(stack, 1);
-      // nothing more needed, as obj can never be indirect ref or stream
-    }
-    else
-    {
-      ++invalid;
-      loggerf("invalid compressed object %s at stream offset " PPUINTF, ppref_str(objnum, 0), offset);
-    }
-    I->pos = indexdata; // restore position and read next from index
-  }
-  ppstream_done(stream);
-  return invalid == 0;
-invalid_objstm:
-  ppstream_done(stream);
-  return 0;
-}
-
-/* main PDF loader proc */
-
-ppcrypt_status ppdoc_crypt_pass (ppdoc *pdf, const void *userpass, size_t userpasslength, const void *ownerpass, size_t ownerpasslength)
-{
-  switch (pdf->cryptstatus)
-  {
-    case PPCRYPT_NONE:
-    case PPCRYPT_DONE:
-    case PPCRYPT_FAIL:
-      break;
-    case PPCRYPT_PASS: // initial status or really needs password
-      pdf->cryptstatus = ppdoc_crypt_init(pdf, userpass, userpasslength, ownerpass, ownerpasslength);
-      switch (pdf->cryptstatus)
-      {
-        case PPCRYPT_NONE:
-        case PPCRYPT_DONE:
-          ppdoc_load_entries(pdf);
-          break;
-        case PPCRYPT_PASS: // user needs to check ppdoc_crypt_status() and recall ppdoc_crypt_pass() with the proper password
-        case PPCRYPT_FAIL: // hopeless..
-          break;
-      }
-      break;
-  }
-  return pdf->cryptstatus;
-}
-
-static ppdoc * ppdoc_read (ppdoc *pdf, iof_file *input)
-{
-  uint8_t header[PPDOC_HEADER];
-  size_t xrefoffset;
-
-  input = &pdf->input;
-  if (iof_file_read(header, 1, PPDOC_HEADER, input) != PPDOC_HEADER || !ppdoc_header(pdf, header))
-    return NULL;
-  if (!ppdoc_tail(pdf, input, &xrefoffset))
-    return NULL;
-  if (ppxref_load(pdf, xrefoffset) == NULL)
-    return NULL;
-  fix_trailer_references(pdf); // after loading xrefs but before accessing trailer refs (/Encrypt might be a reference)
-  // check encryption, if any, try empty password
-  switch (ppdoc_crypt_pass(pdf, "", 0, NULL, 0))
-  {
-    case PPCRYPT_NONE: // no encryption
-    case PPCRYPT_DONE: // encryption with an empty password
-    case PPCRYPT_PASS: // the user needs to check ppdoc_crypt_status() and call ppdoc_crypt_pass()
-      break;
-    case PPCRYPT_FAIL: // hopeless
-      //loggerf("decryption failed");
-      //return NULL;
-      break;
-  }
-  return pdf;
-}
-
-static void ppdoc_pages_init (ppdoc *pdf);
-
-static ppdoc * ppdoc_create (iof_file *input)
-{
-  ppdoc *pdf;
-  ppheap *heap;
-
-  heap = ppheap_new();
-  pdf = (ppdoc *)ppheap_take(&heap, sizeof(ppdoc));
-  pdf->flags = 0;
-  pdf->heap = heap;
-  pdf->xref = NULL;
-  pdf->version[0] = '\0';
-  pdf->crypt = NULL;
-  pdf->cryptstatus = PPCRYPT_PASS; // force encryption check on ppdoc_read() -> ppdoc_crypt_pass()
-  ppstack_init(&pdf->stack, &pdf->heap);
-  ppdoc_reader_init(pdf, input);
-  ppdoc_pages_init(pdf);
-  if (ppdoc_read(pdf, &pdf->input) != NULL)
-    return pdf;
-  ppdoc_free(pdf);
-  return NULL;
-}
-
-ppdoc * ppdoc_load (const char *filename)
-{
-  FILE *file;
-  iof_file input;
-  if ((file = fopen(filename, "rb")) == NULL)
-    return NULL;
-  iof_file_init(&input, file);
-  input.flags |= IOF_CLOSE_FILE;
-  return ppdoc_create(&input);
-}
-
-ppdoc * ppdoc_mem (const void *data, size_t size)
-{
-	iof_file input;
-	iof_file_rdata_init(&input, data, size);
-	input.flags |= IOF_BUFFER_ALLOC; // todo: 3 modes: borrow, take over, copy?
-	return ppdoc_create(&input);
-}
-
-void ppdoc_free (ppdoc *pdf)
-{
-  //iof_file_free(&pdf->input);
-  iof_file_decref(&pdf->input);
-  ppstack_free_buffer(&pdf->stack);
-  ppheap_free(pdf->heap); // last!
-}
-
-ppcrypt_status ppdoc_crypt_status (ppdoc *pdf)
-{
-  return pdf->cryptstatus;
-}
-
-ppint ppdoc_permissions (ppdoc *pdf)
-{
-  return pdf->crypt != NULL ? pdf->crypt->permissions : (ppint)0xFFFFFFFFFFFFFFFF;
-}
-
-/* pages access */
-
-static pparray * pppage_node (ppdict *dict, ppuint *count, ppname *type)
-{
-  ppname *pkey, key;
-  ppobj *obj;
-  pparray *kids = NULL;
-  *count = 0;
-  *type = NULL;
-  for (ppdict_first(dict, pkey, obj); (key = *pkey) != NULL; ppdict_next(pkey, obj))
-  {
-    switch (key[0])
-    {
-      case 'T':
-        if (ppname_is(key, "Type"))
-          *type = ppobj_get_name(obj);
-        break;
-      case 'C':
-        if (ppname_is(key, "Count"))
-          ppobj_get_uint(obj, *count);
-        break;
-      case 'K':
-        if (ppname_is(key, "Kids"))
-          kids = ppobj_rget_array(obj);
-        break;
-    }
-  }
-  return kids;
-}
-
-#define ppname_is_page(type) (type != NULL && ppname_is(type, "Page"))
-
-ppuint ppdoc_page_count (ppdoc *pdf)
-{
-  ppref *ref;
-  ppname type;
-  ppuint count;
-  if ((ref = ppxref_pages(pdf->xref)) == NULL)
-    return 0;
-  if (pppage_node(ref->object.dict, &count, &type) == NULL)
-    return ppname_is_page(type) ? 1 : 0; // acrobat and ghostscript accept documents with root /Pages entry being a reference to a sole /Page object
-  return count;
-}
-
-ppref * ppdoc_page (ppdoc *pdf, ppuint index)
-{
-  ppdict *dict;
-  ppuint count;
-  pparray *kids;
-  size_t size, i;
-  ppobj *r, *o;
-  ppref *ref;
-  ppname type;
-
-
-  if ((ref = ppxref_pages(pdf->xref)) == NULL)
-    return NULL;
-  dict = ref->object.dict;
-  if ((kids = pppage_node(dict, &count, &type)) != NULL)
-  {
-    if (index < 1 || index > count)
-      return NULL;
-  }
-  else
-  {
-    return index == 1 && ppname_is_page(type) ? ref : NULL;
-  }
-scan_array:
-  if (index <= count / 2)
-  { // probably shorter way from the beginning
-    for (i = 0, size = kids->size, r = pparray_at(kids, 0); i < size; ++i, ++r)
-    {
-      if (r->type != PPREF)
-        return NULL;
-      o = &r->ref->object;
-      if (o->type != PPDICT)
-        return NULL;
-      dict = o->dict;
-      if ((kids = pppage_node(dict, &count, &type)) != NULL)
-      {
-        if (index <= count)
-          goto scan_array;
-        index -= count;
-        continue;
-      }
-      if (index == 1 && ppname_is_page(type))
-        return r->ref;
-      --index;
-    }
-  }
-  else if ((size = kids->size) > 0) // for safe (size-1)
-  { // probably shorter way from the end
-    index = count - index + 1;
-    for (i = 0, r = pparray_at(kids, size - 1); i < size; ++i, --r)
-    {
-      if (r->type != PPREF)
-        return NULL;
-      o = &r->ref->object;
-      if (o->type != PPDICT)
-        return NULL;
-      dict = o->dict;
-      if ((kids = pppage_node(dict, &count, &type)) != NULL)
-      {
-        if (index <= count)
-          goto scan_array;
-        index -= count;
-        continue;
-      }
-      if (index == 1 && ppname_is_page(type))
-        return r->ref;
-      --index;
-    }
-  }
-  return NULL;
-}
-
-/*
-Through pages iterator. Iterating over pages tree just on the base of /Kids and /Parent keys
-is ineffective, as to get next pageref we need to take parent, find the pageref in /Kids,
-take next (or go upper).. Annoying. We use a dedicated stack for pages iterator. This could
-actually be done with pdf->stack, but some operations may clear it, so safer to keep it independent
-Besides, its depth is constant (set on first use), so no need for allocs.
-*/
-
-static void ppdoc_pages_init (ppdoc *pdf)
-{
-  pppages *pages;
-  pages = &pdf->pages;
-  pages->root = pages->parent = pages->buffer;
-  pages->depth = 0;
-  pages->space = PPPAGES_STACK_DEPTH;
-}
-
-static ppkids * pppages_push (ppdoc *pdf, pparray *kids)
-{
-  ppkids *newroot, *bounds;
-  pppages *pages;
-  pages = &pdf->pages;
-  if (pages->depth == pages->space)
-  {
-    pages->space <<= 1;
-    newroot = (ppkids *)ppheap_take(&pdf->heap, pages->space * sizeof(ppkids));
-    memcpy(newroot, pages->root, pages->depth * sizeof(ppkids));
-    pages->root = newroot;
-  }
-  bounds = pages->parent = &pages->root[pages->depth++];
-  bounds->current = pparray_at(kids, 0);
-  bounds->sentinel = pparray_at(kids, kids->size);
-  return bounds;
-}
-
-#define pppages_pop(pages) (--((pages)->parent), --((pages)->depth))
-
-static ppref * ppdoc_pages_group_first (ppdoc *pdf, ppref *ref)
-{
-  ppdict *dict;
-  pparray *kids;
-  ppuint count;
-  ppname type;
-
-  dict = ref->object.dict; // typecheck made by callers
-  while ((kids = pppage_node(dict, &count, &type)) != NULL)
-  {
-    if ((ref = pparray_get_ref(kids, 0)) == NULL || ref->object.type != PPDICT)
-      return NULL;
-    pppages_push(pdf, kids);
-    dict = ref->object.dict;
-  }
-  return ppname_is_page(type) ? ref : NULL;
-}
-
-ppref * ppdoc_first_page (ppdoc *pdf)
-{
-  ppref *ref;
-  pppages *pages;
-  if ((ref = ppdoc_pages(pdf)) == NULL)
-    return NULL;
-  pages = &pdf->pages;
-  pages->parent = pages->root;
-  pages->depth = 0;
-  return ppdoc_pages_group_first(pdf, ref);
-}
-
-ppref * ppdoc_next_page (ppdoc *pdf)
-{
-  pppages *pages;
-  ppkids *bounds;
-  ppref *ref;
-  ppobj *obj;
-  pages = &pdf->pages;
-  while (pages->depth > 0)
-  {
-    bounds = pages->parent;
-    obj = ++bounds->current;
-    if (obj < bounds->sentinel)
-    {
-      if (obj->type != PPREF)
-        return NULL;
-      ref = obj->ref;
-      if (ref->object.type != PPDICT)
-        return NULL;
-      return ppdoc_pages_group_first(pdf, ref);
-    }
-    else
-    { // no next node, go upper
-      pppages_pop(pages);
-    }
-  }
-  return NULL;
-}
-
-/* context */
-
-ppcontext * ppcontext_new (void)
-{
-  ppheap *heap;
-  ppcontext *context;
-  heap = ppheap_new();
-  context = (ppcontext *)pp_malloc(sizeof(ppcontext)); // not from priv heap, as we delete it on renew
-  context->heap = heap;
-  ppstack_init(&context->stack, &context->heap);
-  return context;
-}
-
-void ppcontext_done (ppcontext *context)
-{
-  ppheap_renew(context->heap);
-  ppstack_clear(&context->stack);
-}
-
-void ppcontext_free (ppcontext *context)
-{
-  ppstack_free_buffer(&context->stack);
-  ppheap_free(context->heap);
-  pp_free(context);
-}
-
-/* page contents streams */
-
-//#define ppcontents_first_stream(array) pparray_rget_stream(array, 0)
-
-static ppstream * ppcontents_first_stream (pparray *array)
-{
-  size_t i;
-  ppobj *obj;
-  ppref *ref;
-  for (pparray_first(array, i, obj); i < array->size; pparray_next(i, obj))
-    if ((ref = ppobj_get_ref(obj)) != NULL && ref->object.type == PPSTREAM)
-      return ref->object.stream;
-  return NULL;
-}
-
-static ppstream * ppcontents_next_stream (pparray *array, ppstream *stream)
-{
-  size_t i;
-  ppobj *obj;
-  ppref *ref;
-  for (pparray_first(array, i, obj); i < array->size; pparray_next(i, obj))
-    if ((ref = ppobj_get_ref(obj)) != NULL && ref->object.type == PPSTREAM && ref->object.stream == stream)
-      if (++i < array->size && (ref = ppobj_get_ref(obj + 1)) != NULL && ref->object.type == PPSTREAM)
-        return ref->object.stream;
-  return NULL;
-}
-
-ppstream * ppcontents_first (ppdict *dict)
-{
-  ppobj *contentsobj;
-  if ((contentsobj = ppdict_rget_obj(dict, "Contents")) == NULL)
-    return NULL;
-  switch (contentsobj->type)
-  {
-    case PPARRAY:
-      return ppcontents_first_stream(contentsobj->array);
-    case PPSTREAM:
-      return contentsobj->stream;
-    default:
-      break;
-  }
-  return NULL;
-}
-
-ppstream * ppcontents_next (ppdict *dict, ppstream *stream)
-{
-  ppobj *contentsobj;
-  if ((contentsobj = ppdict_rget_obj(dict, "Contents")) == NULL)
-    return NULL;
-  switch (contentsobj->type)
-  {
-    case PPARRAY:
-      return ppcontents_next_stream(contentsobj->array, stream);
-    case PPSTREAM:
-      break;
-    default:
-      break;
-  }
-  return NULL;
-}
-
-static ppobj * ppcontents_op (iof *I, ppstack *stack, size_t *psize, ppname *pname)
-{
-  ppobj *obj;
-  ppstack_clear(stack);
-  do {
-    if (ppscan_find(I) < 0)
-      return NULL;
-    if ((obj = ppscan_psobj(I, stack)) == NULL)
-      return NULL;
-  } while (obj->type != PPNAME || !ppname_exec(obj->name));
-  *pname = obj->name;
-  *psize = stack->size - 1;
-  return stack->buf;
-}
-
-ppobj * ppcontents_first_op (ppcontext *context, ppstream *stream, size_t *psize, ppname *pname)
-{
-  iof *I;
-  if ((I = ppstream_read(stream, 1, 0)) == NULL)
-    return NULL;
-  return ppcontents_op(I, &context->stack, psize, pname);
-}
-
-ppobj * ppcontents_next_op (ppcontext *context, ppstream *stream, size_t *psize, ppname *pname)
-{
-  return ppcontents_op(ppstream_iof(stream), &context->stack, psize, pname);
-}
-
-ppobj * ppcontents_parse (ppcontext *context, ppstream *stream, size_t *psize)
-{
-  iof *I;
-  ppstack *stack;
-  ppobj *obj;
-  stack = &context->stack;
-  ppstack_clear(stack);
-  if ((I = ppstream_read(stream, 1, 0)) == NULL)
-    return NULL;
-  while (ppscan_find(I) >= 0)
-    if ((obj = ppscan_psobj(I, stack)) == NULL)
-      goto error;
-  *psize = stack->size;
-  ppstream_done(stream);
-  return stack->buf;
-error:
-  ppstream_done(stream);
-  return NULL;
-}
-
-/* boxes */
-
-pprect * pparray_to_rect (pparray *array, pprect *rect)
-{
-  ppobj *obj;
-  if (array->size != 4)
-    return NULL;
-  obj = pparray_at(array, 0);
-  if (!ppobj_get_num(obj, rect->lx)) return NULL;
-  obj = pparray_at(array, 1);
-  if (!ppobj_get_num(obj, rect->ly)) return NULL;
-  obj = pparray_at(array, 2);
-  if (!ppobj_get_num(obj, rect->rx)) return NULL;
-  obj = pparray_at(array, 3);
-  if (!ppobj_get_num(obj, rect->ry)) return NULL;
-  return rect;
-}
-
-pprect * ppdict_get_rect (ppdict *dict, const char *name, pprect *rect)
-{
-  pparray *array;
-  return (array = ppdict_rget_array(dict, name)) != NULL ? pparray_to_rect(array, rect) : NULL;
-}
-
-pprect * ppdict_get_box (ppdict *dict, const char *name, pprect *rect)
-{
-  do {
-    if (ppdict_get_rect(dict, name, rect) != NULL)
-      return rect;
-    dict = ppdict_rget_dict(dict, "Parent");
-  } while (dict != NULL);
-  return NULL;
-}
-
-ppmatrix * pparray_to_matrix (pparray *array, ppmatrix *matrix)
-{
-  ppobj *obj;
-  if (array->size != 6)
-    return NULL;
-  obj = pparray_at(array, 0);
-  if (!ppobj_get_num(obj, matrix->xx)) return NULL;
-  obj = pparray_at(array, 1);
-  if (!ppobj_get_num(obj, matrix->xy)) return NULL;
-  obj = pparray_at(array, 2);
-  if (!ppobj_get_num(obj, matrix->yx)) return NULL;
-  obj = pparray_at(array, 3);
-  if (!ppobj_get_num(obj, matrix->yy)) return NULL;
-  obj = pparray_at(array, 4);
-  if (!ppobj_get_num(obj, matrix->x)) return NULL;
-  obj = pparray_at(array, 5);
-  if (!ppobj_get_num(obj, matrix->y)) return NULL;
-  return matrix;
-}
-
-ppmatrix * ppdict_get_matrix (ppdict *dict, const char *name, ppmatrix *matrix)
-{
-  pparray *array;
-  return (array = ppdict_rget_array(dict, name)) != NULL ? pparray_to_matrix(array, matrix) : NULL;
-}
-
-/* logger */
-
-void pplog_callback (pplogger_callback logger, void *alien)
-{
-	logger_callback((logger_function)logger, alien);
-}
-
-int pplog_prefix (const char *prefix)
-{
-	return logger_prefix(prefix);
-}
-
-/* version */
-
-const char * ppdoc_version_string (ppdoc *pdf)
-{
-  return pdf->version;
-}
-
-int ppdoc_version_number (ppdoc *pdf, int *minor)
-{
-  *minor = pdf->version[2] - '0';
-  return pdf->version[0] - '0';
-}
-
-/* doc info */
-
-size_t ppdoc_file_size (ppdoc *pdf)
-{
-  return pdf->filesize;
-}
-
-ppuint ppdoc_objects (ppdoc *pdf)
-{
-  ppuint count;
-  ppxref *xref;
-  for (count = 0, xref = pdf->xref; xref != NULL; xref = xref->prev)
-    count += xref->count;
-  return count;
-}
-
-size_t ppdoc_memory (ppdoc *pdf, size_t *waste)
-{
-  size_t used;
-  ppheap *heap;
-  used = 0, *waste = 0;
-  for (heap = pdf->heap; heap != NULL; heap = heap->prev)
-  {
-    used += heap->space;
-    *waste += heap->size;
-  }
-  return used;
-}
--- texlive-bin.orig/texk/web2c/luatexdir/luapplib/ppload.c-OK
+++ /dev/null
@@ -1,2555 +0,0 @@
-
-#include <utilbasexx.h>
-
-#include "pplib.h"
-
-const char * ppobj_kind[] = { "none", "null", "bool", "integer", "number", "name", "string", "array", "dict", "stream", "ref" };
-
-#define ignored_char(c) (c == 0x20 || c == 0x0A || c == 0x0D || c == 0x09 || c == 0x00)
-#define newline_char(c) (c == 0x0A || c == 0x0D)
-#define IGNORED_CHAR_CASE 0x20: case 0x0A: case 0x0D: case 0x09: case 0x00
-#define NEWLINE_CHAR_CASE 0x0A: case 0x0D
-#define DIGIT_CHAR_CASE '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9'
-#define OCTAL_CHAR_CASE '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7'
-
-#define MAX_INT_DIGITS 32
-
-#define PP_LENGTH_UNKNOWN ((size_t)-1)
-
-static const char * ppref_str (ppuint refnumber, ppuint refversion)
-{
-	static char buffer[MAX_INT_DIGITS + 1 + MAX_INT_DIGITS + 1 + 1 + 1];
-#if defined(MSVC64)|| defined(MINGW64)
-	sprintf(buffer, PPUINTF " " PPUINTF " R", refnumber, refversion);
-#else
-	sprintf(buffer, PPUINTF " " PPUINTF " R", (unsigned long)(refnumber), (unsigned long)(refversion));
-#endif
-	return buffer;
-}
-
-/* name */
-
-// pdf name delimiters: 0..32, ()<>[]{}/%
-// # treated specially
-// .+- are valid part of name; keep in mind names such as -| | |- .notdef ABCDEF+Font etc.
-const char ppname_byte_lookup[] = {
-  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-  0, 1, 1, '#', 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0,
-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1,
-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1,
-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1,
-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
-};
-
-#define PPNAME_INIT (8+1)
-
-#define ppname_flush(O, ghost, siz, flgs) \
-  (iof_put(O, '\0'), \
-   ghost = (_ppname *)ppheap_flush(O, &siz), \
-   ghost->flags = flgs, \
-   ghost->size = siz - sizeof(_ppname) - 1, \
-  (ppname)(ghost + 1))
-
-#define ppname_flush_with_ego(O, ghost, siz, flgs) \
-  (iof_put(O, '\0'), \
-   iof_ensure(O, sizeof(ppname *)), \
-   O->pos += sizeof(ppname *), \
-   ghost = (_ppname *)ppheap_flush(O, &siz), \
-   ghost->flags = flgs, \
-   ghost->size = siz - sizeof(_ppname) - 1 - sizeof(ppname *), \
-  (ppname)(ghost + 1))
-
-#define ppname_set_alter_ego(name, ghost, ego) (*((ppname *)(name + (ghost)->size + 1)) = ego)
-#define ppname_get_alter_ego(name) (*((ppname *)(name + ppname_size(name) + 1)))
-
-static ppname ppscan_name (iof *I, ppheap **pheap)
-{
-  int c, decode;
-  iof *O;
-  _ppname *ghost1, *ghost2;
-  ppname encoded, decoded;
-  size_t size;
-  const char *p, *e;
-  uint8_t v1, v2;
-  O = ppheap_buffer(pheap, sizeof(_ppname), PPNAME_INIT);
-  for (decode = 0, c = iof_char(I); c >= 0 && ppname_byte_lookup[c]; c = iof_next(I))
-  {
-    if (c == '#')
-      decode = 1;
-    iof_put(O, c);
-  }
-  if (!decode)
-    return ppname_flush(O, ghost1, size, 0);
-  encoded = ppname_flush_with_ego(O, ghost1, size, 0|PPNAME_ENCODED);
-  O = ppheap_buffer(pheap, sizeof(_ppname), PPNAME_INIT);
-  for (p = encoded, e = encoded + ghost1->size; p < e; ++p)
-  {
-    if (*p == '#' && p + 2 < e ){
-      v1 = base16_value(p[1]);
-      v2 = base16_value(p[2]);
-      iof_put(O, ((v1<<4)+v2));
-    }else
-      iof_put(O, *p);
-  }
-  decoded = ppname_flush_with_ego(O, ghost2, size, 0|PPNAME_DECODED);
-  ppname_set_alter_ego(encoded, ghost1, decoded);
-  ppname_set_alter_ego(decoded, ghost2, encoded);
-  return encoded;
-}
-
-static ppname ppscan_exec (iof *I, ppheap **pheap, int first)
-{
-  int c, decode;
-  iof *O;
-  _ppname *ghost1, *ghost2;
-  ppname encoded, decoded;
-  size_t size;
-  const char *p, *e;
-  uint8_t v1, v2;
-
-  O = ppheap_buffer(pheap, sizeof(_ppname), PPNAME_INIT);
-  iof_put(O, first);
-  for (decode = 0, c = iof_char(I); c >= 0 && ppname_byte_lookup[c]; c = iof_next(I))
-  {
-    if (c == '#')
-      decode = 1;
-    iof_put(O, c);
-  }
-  if (!decode)
-    return ppname_flush(O, ghost1, size, PPNAME_EXEC);
-  encoded = ppname_flush_with_ego(O, ghost1, size, PPNAME_EXEC|PPNAME_ENCODED);
-  O = ppheap_buffer(pheap, sizeof(_ppname), PPNAME_INIT);
-  for (p = encoded, e = encoded + ghost1->size; p < e; ++p)
-  {
-    if (*p == '#' && p + 2 < e ){
-      v1 = base16_value(p[1]);
-      v2 = base16_value(p[2]);
-      iof_put(O, ((v1<<4)+v2));
-    }else
-      iof_put(O, *p);
-  }
-  decoded = ppname_flush_with_ego(O, ghost2, size, PPNAME_EXEC|PPNAME_DECODED);
-  ppname_set_alter_ego(encoded, ghost1, decoded);
-  ppname_set_alter_ego(decoded, ghost2, encoded);
-  return encoded;
-}
-
-static ppname ppexec_internal (const void *data, size_t size, ppheap **pheap)
-{ // used only for artificial 'EI' operator name
-  iof *O;
-  _ppname *ghost1;
-
-  O = ppheap_buffer(pheap, sizeof(_ppname), size);
-  iof_write(O, data, size);
-  return ppname_flush(O, ghost1, size, PPNAME_EXEC);
-}
-
-ppname ppname_decoded (ppname name)
-{
-  const _ppname *ghost;
-  ghost = _ppname_ghost(name);
-  return (ghost->flags & PPNAME_ENCODED) ? ppname_get_alter_ego(name) : name;
-}
-
-ppname ppname_encoded (ppname name)
-{
-  const _ppname *ghost;
-  ghost = _ppname_ghost(name);
-  return (ghost->flags & PPNAME_DECODED) ? ppname_get_alter_ego(name) : name;
-}
-
-/* string */
-
-#define PPSTRING_INIT (16+1)
-
-#define ppstring_flush(O, ghost, siz, flgs) \
-  (iof_put(O, '\0'), \
-   ghost = (_ppstring *)ppheap_flush(O, &siz), \
-   ghost->flags = flgs, \
-   ghost->size = siz - sizeof(_ppstring) - 1, \
-  (ppstring)(ghost + 1))
-
-#define ppstring_flush_with_ego(O, ghost, siz, flgs) \
-  (iof_put(O, '\0'), \
-   iof_ensure(O, sizeof(ppstring *)), \
-   O->pos += sizeof(ppstring *), \
-   ghost = (_ppstring *)ppheap_flush(O, &siz), \
-   ghost->flags = flgs, \
-   ghost->size = siz - sizeof(_ppstring) - 1 - sizeof(ppstring *), \
-  (ppstring)(ghost + 1))
-
-#define ppstring_utf16be_bom(decoded) (decoded[0] == ((char)0xFE) && decoded[1] == ((char)0xFF) )
-#define ppstring_utf16le_bom(decoded) (decoded[0] == ((char)0xFF) && decoded[1] == ((char)0xFE))
-
-#define ppstring_check_bom(decoded, ghost) ((void)\
-  (ghost->size >= 2 ? (ppstring_utf16be_bom(decoded) ? (ghost->flags |= PPSTRING_UTF16BE) : \
-                      (ppstring_utf16le_bom(decoded) ? (ghost->flags |= PPSTRING_UTF16LE) : 0)) : 0))
-
-#define ppstring_check_bom2(decoded, ghost1, ghost2) ((void)\
-  (ghost2->size >= 2 ? (ppstring_utf16be_bom(decoded) ? ((ghost1->flags |= PPSTRING_UTF16BE), (ghost2->flags |= PPSTRING_UTF16BE)) : \
-                       (ppstring_utf16le_bom(decoded) ? ((ghost1->flags |= PPSTRING_UTF16LE), (ghost2->flags |= PPSTRING_UTF16LE)) : 0)) : 0))
-
-#define ppstring_set_alter_ego(string, ghost, ego) (*((ppstring *)(string + (ghost)->size + 1)) = ego)
-#define ppstring_get_alter_ego(string) (*((ppstring *)(string + ppstring_size(string) + 1)))
-
-static ppstring ppscan_string (iof *I, ppheap **pheap)
-{
-  int c, decode, balance;
-  iof *O;
-  _ppstring *ghost1, *ghost2;
-  uint8_t *p, *e;
-  ppstring encoded, decoded;
-  size_t size;
-  O = ppheap_buffer(pheap, sizeof(_ppstring), PPSTRING_INIT);
-  for (decode = 0, balance = 0, c = iof_char(I); c >= 0; )
-  {
-    switch (c)
-    {
-      case '\\':
-        decode = 1; // unescaping later
-        iof_put(O, '\\');
-        if ((c = iof_next(I)) >= 0)
-        {
-          iof_put(O, c);
-          c = iof_next(I);
-        }
-        break;
-      case '(': // may be unescaped if balanced
-        ++balance;
-        iof_put(O, '(');
-        c = iof_next(I);
-        break;
-      case ')':
-        if (balance == 0)
-        {
-          c = IOFEOF;
-          ++I->pos;
-          break;
-        }
-        --balance;
-        iof_put(O, ')');
-        c = iof_next(I);
-        break;
-      default:
-        iof_put(O, c);
-        c = iof_next(I);
-    }
-  }
-  if (!decode)
-  {
-    encoded = ppstring_flush(O, ghost1, size, 0);
-    ppstring_check_bom(encoded, ghost1); // any bytes can be there
-    return encoded;
-  }
-  encoded = ppstring_flush_with_ego(O, ghost1, size, 0|PPSTRING_ENCODED);
-  O = ppheap_buffer(pheap, sizeof(_ppstring), PPSTRING_INIT);
-  for (p = (uint8_t *)encoded, e = (uint8_t *)encoded + ghost1->size; p < e; ++p)
-  {
-    if (*p == '\\')
-    {
-      if (++p >= e)
-        break;
-      switch (*p)
-      {
-        case OCTAL_CHAR_CASE:
-          c = *p - '0';
-          if (++p < e && *p >= '0' && *p <= '7')
-          {
-            c = (c << 3) + *p - '0';
-            if (++p < e && *p >= '0' && *p <= '7')
-              c = (c << 3) + *p - '0';
-          }
-          iof_put(O, c);
-          break;
-        case 'n':
-          iof_put(O, '\n');
-          break;
-        case 'r':
-          iof_put(O, '\r');
-          break;
-        case 't':
-          iof_put(O, '\t');
-          break;
-        case 'b':
-          iof_put(O, '\b');
-          break;
-        case 'f':
-          iof_put(O, '\f');
-          break;
-        case NEWLINE_CHAR_CASE: // not a part of the string, ignore (pdf spec page 55)
-          break;
-        case '(': case ')': case '\\':
-        default: // for enything else backslash is ignored (pdf spec page 54)
-          iof_put(O, *p);
-          break;
-      }
-    }
-    else
-      iof_put(O, *p);
-  }
-  decoded = ppstring_flush_with_ego(O, ghost2, size, 0|PPSTRING_DECODED);
-  ppstring_check_bom2(decoded, ghost1, ghost2);
-  ppstring_set_alter_ego(encoded, ghost1, decoded);
-  ppstring_set_alter_ego(decoded, ghost2, encoded);
-  return encoded;
-}
-
-/* Hex string may contain white characters. If odd number of digits, the last assumed to be '0' */
-
-static ppstring ppscan_base16 (iof *I, ppheap **pheap)
-{
-  int c, v1, v2;
-  iof *O;
-  _ppstring *ghost1, *ghost2;
-  size_t size;
-  ppstring encoded, decoded;
-  uint8_t *p, *e;
-
-  O = ppheap_buffer(pheap, sizeof(_ppstring), PPSTRING_INIT);
-  for (c = iof_char(I); c >= 0 && (base16_digit(c) || ignored_char(c)); c = iof_next(I))
-    iof_put(O, c);
-  if (c == '>')
-    ++I->pos;
-  encoded = ppstring_flush_with_ego(O, ghost1, size, PPSTRING_BASE16|PPSTRING_ENCODED);
-  O = ppheap_buffer(pheap, sizeof(_ppstring), (ghost1->size >> 1) + 1);
-  for (p = (uint8_t *)encoded, e = (uint8_t *)encoded + ghost1->size; p < e; ++p)
-  {
-    if ((v1 = base16_value(*p)) < 0) // ignored
-      continue;
-    for (v2 = 0, ++p; p < e && (v2 = base16_value(*p)) < 0; ++p);
-    iof_put(O, (v1<<4)|v2);
-  }
-  decoded = ppstring_flush_with_ego(O, ghost2, size, 0|PPSTRING_DECODED);
-  ppstring_check_bom2(decoded, ghost1, ghost2);
-  ppstring_set_alter_ego(encoded, ghost1, decoded);
-  ppstring_set_alter_ego(decoded, ghost2, encoded);
-  return encoded;
-}
-
-/* internal use only; binary string */
-
-static ppstring ppstring_buffer (iof *O, ppheap **pheap)
-{
-   _ppstring *ghost1, *ghost2;
-   ppstring encoded, decoded;
-   uint8_t *p, *e;
-   size_t size;
-
-   decoded = ppstring_flush_with_ego(O, ghost2, size, 0|PPSTRING_DECODED);
-   O = ppheap_buffer(pheap, sizeof(_ppstring), (ghost2->size << 1) + 1);
-   for (p = (uint8_t *)decoded, e = (uint8_t *)decoded + ghost2->size; p < e; ++p)
-     iof_set2(O, base16_uc_alphabet[(*p)>>4], base16_uc_alphabet[(*p)&15]);
-   encoded = ppstring_flush_with_ego(O, ghost1, size, PPSTRING_BASE16|PPSTRING_ENCODED);
-   ppstring_set_alter_ego(encoded, ghost1, decoded);
-   ppstring_set_alter_ego(decoded, ghost2, encoded);
-   return encoded;
-}
-
-ppstring ppstring_internal (const void *data, size_t size, ppheap **pheap)
-{ // so far used only for crypt key
-  iof *O;
-
-  O = ppheap_buffer(pheap, sizeof(_ppstring), size);
-  iof_write(O, data, size);
-  return ppstring_buffer(O, pheap);
-}
-
-/* PDF spec says nothing about base85 strings, but streams might be (afair no leading '<~' but present trailing '~>') */
-
-static ppstring ppscan_base85 (iof *I, ppheap **pheap)
-{ // bawse85 alphabet is 33.117, adobe also hires 'z' and 'y' for compression
-  int c;
-  iof *O, B;
-  _ppstring *ghost1, *ghost2;
-  size_t size;
-  ppstring encoded, decoded;
-  O = ppheap_buffer(pheap, sizeof(_ppstring), PPSTRING_INIT);
-  for (c = iof_char(I); (c >= '!' && c <= 'u') || c == 'z' || c == 'y'; c = iof_next(I))
-    iof_put(O, c);
-  if (c == '~')
-    if ((c = iof_next(I)) == '>')
-      ++I->pos;
-  encoded = ppstring_flush_with_ego(O, ghost1, size, PPSTRING_BASE85|PPSTRING_ENCODED);
-  iof_string_reader(&B, encoded, ghost1->size);
-  O = ppheap_buffer(pheap, sizeof(_ppstring), (ghost1->size * 5 / 4) + 1);
-  base85_decode(&B, O);
-  decoded = ppstring_flush_with_ego(O, ghost2, size, 0|PPSTRING_DECODED);
-  ppstring_check_bom2(decoded, ghost1, ghost2);
-  ppstring_set_alter_ego(encoded, ghost1, decoded);
-  ppstring_set_alter_ego(decoded, ghost2, encoded);
-  return encoded;
-}
-
-/*
-Encrypted strings. In case of encrypted strings, we first need to decode the string (saving original form hardly makes sense),
-then decrypt the string, and encode it again.
-*/
-
-const char ppstring_byte_escape[] = { /* -1 escaped with octal, >0 escaped with \\, 0 left intact*/
- -1,-1,-1,-1,-1,-1,-1,-1,'b','t','n',-1,'f','r',-1,-1,
- -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  0, 0, 0, 0, 0, 0, 0, 0,'(',')', 0, 0, 0, 0, 0, 0,
-  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,'\\', 0, 0, 0,
-  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
- -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
- -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
- -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
- -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
- -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
- -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
- -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
- -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1
-};
-
-
-static ppstring ppscan_crypt_string (iof *I, ppcrypt *crypt, ppheap **pheap)
-{
-  int c, b, balance, encode;
-  iof *O;
-  _ppstring *ghost1, *ghost2;
-  ppstring encoded, decoded;
-  uint8_t *p, *e;
-  size_t size;
-
-  O = ppheap_buffer(pheap, sizeof(_ppstring), PPSTRING_INIT);
-  for (balance = 0, encode = 0, c = iof_char(I); c >= 0; )
-  {
-    switch (c)
-    {
-      case '\\':
-        if ((c = iof_next(I)) < 0)
-          break;
-        encode = 1;
-        switch (c)
-        {
-          case OCTAL_CHAR_CASE:
-            b = c - '0';
-            if ((c = iof_next(I)) >= 0 && c >= '0' && c <= '7')
-            {
-              b = (b << 3) + c - '0';
-              if ((c = iof_next(I)) >= 0 && c >= '0' && c <= '7')
-              {
-                b = (b << 3) + c - '0';
-                c = iof_next(I);
-              }
-            }
-            iof_put(O, b);
-            // c is set to the next char
-            break;
-          case 'n':
-            iof_put(O, '\n');
-            c = iof_next(I);
-            break;
-          case 'r':
-            iof_put(O, '\r');
-            c = iof_next(I);
-            break;
-          case 't':
-            iof_put(O, '\t');
-            c = iof_next(I);
-            break;
-          case 'b':
-            iof_put(O, '\b');
-            c = iof_next(I);
-            break;
-          case 'f':
-            iof_put(O, '\f');
-            c = iof_next(I);
-            break;
-          case NEWLINE_CHAR_CASE: // not a part of the string, ignore (pdf spec page 55)
-            c = iof_next(I);
-            break;
-          case '(': case ')': case '\\':
-          default: // for enything else backslash is ignored (pdf spec page 54)
-            iof_put(O, c);
-            c = iof_next(I);
-            break;
-        }
-        break;
-      case '(':
-        ++balance;
-        encode = 1;
-        iof_put(O, '(');
-        c = iof_next(I);
-        break;
-      case ')':
-        if (balance == 0)
-        {
-          c = IOFEOF;
-          ++I->pos;
-        }
-        else
-        {
-          --balance;
-          //encode = 1;
-          iof_put(O, ')');
-          c = iof_next(I);
-        }
-        break;
-      default:
-        if (ppstring_byte_escape[c] != 0)
-          encode = 1;
-        iof_put(O, c);
-        c = iof_next(I);
-    }
-  }
-  /* decrypt the buffer in place, update size */
-  if (ppstring_decrypt(crypt, O->buf, iof_size(O), O->buf, &size))
-    O->pos = O->buf + size;
-  /* make encoded counterpart */
-  if (!encode)
-  {
-    decoded = ppstring_flush(O, ghost2, size, 0);
-    ppstring_check_bom(decoded, ghost2);
-    return decoded;
-  }
-  decoded = ppstring_flush_with_ego(O, ghost2, size, PPSTRING_DECODED);
-  O = ppheap_buffer(pheap, sizeof(_ppstring), ghost2->size);
-  for (p = (uint8_t *)decoded, e = (uint8_t *)decoded + ghost2->size; p < e; ++p)
-  {
-    switch ((b = ppstring_byte_escape[*p]))
-    {
-      case 0:
-        iof_put(O, *p);
-        break;
-      case -1:
-        iof_put4(O, '\\', (c >> 6) + '0', ((c >> 3) & 7) + '0', (c & 7) + '0');
-        break;
-      default:
-        iof_put2(O, '\\', b);
-        break;
-    }
-  }
-  encoded = ppstring_flush_with_ego(O, ghost1, size, PPSTRING_ENCODED);
-  ppstring_check_bom2(decoded, ghost1, ghost2);
-  ppstring_set_alter_ego(encoded, ghost1, decoded);
-  ppstring_set_alter_ego(decoded, ghost2, encoded);
-  return encoded;
-}
-
-
-static ppstring ppscan_crypt_base16 (iof *I, ppcrypt *crypt, ppheap **pheap)
-{
-  int c, v1, v2;
-  iof *O;
-  _ppstring *ghost1, *ghost2;
-  ppstring encoded, decoded;
-  uint8_t *p, *e;
-  size_t size;
-
-  O = ppheap_buffer(pheap, sizeof(_ppstring), PPSTRING_INIT);
-  // base16_decode(I, O); // no info about the last char..
-  for (c = iof_char(I); c != '>' && c >= 0; )
-  {
-    if ((v1 = base16_value(c)) < 0)
-    {
-      if (ignored_char(c))
-      {
-        c = iof_next(I);
-        continue;
-      }
-      break;
-    }
-    do {
-      c = iof_next(I);
-      if ((v2 = base16_value(c)) >= 0)
-      {
-        c = iof_next(I);
-        break;
-      }
-      if (!ignored_char(c)) // c == '>' || c < 0 or some crap
-      {
-        v2 = 0;
-        break;
-      }
-    } while (1);
-    iof_put(O, (v1 << 4)|v2);
-  }
-  if (c == '>')
-    ++I->pos;
-  /* decrypt the buffer in place, update size */
-  if (ppstring_decrypt(crypt, O->buf, iof_size(O), O->buf, &size))
-    O->pos = O->buf + size;
-  decoded = ppstring_flush_with_ego(O, ghost2, size, PPSTRING_DECODED);
-  /* recreate an encoded form */
-  O = ppheap_buffer(pheap, sizeof(_ppstring), (ghost2->size << 1) + 1);
-  for (p = (uint8_t *)decoded, e = (uint8_t *)decoded + ghost2->size; p < e; ++p)
-    iof_set2(O, base16_uc_alphabet[(*p)>>4], base16_uc_alphabet[(*p)&15]);
-  encoded = ppstring_flush_with_ego(O, ghost1, size, PPSTRING_BASE16|PPSTRING_ENCODED);
-  ppstring_check_bom2(decoded, ghost1, ghost2);
-  ppstring_set_alter_ego(encoded, ghost1, decoded);
-  ppstring_set_alter_ego(decoded, ghost2, encoded);
-  return encoded;
-}
-
-/* ppstring alter ego switcher */
-
-ppstring ppstring_decoded (ppstring string)
-{
-  const _ppstring *ghost;
-  ghost = _ppstring_ghost(string);
-  return (ghost->flags & PPSTRING_ENCODED) ? ppstring_get_alter_ego(string) : string;
-}
-
-ppstring ppstring_encoded (ppstring string)
-{
-  const _ppstring *ghost;
-  ghost = _ppstring_ghost(string);
-  return (ghost->flags & PPSTRING_DECODED) ? ppstring_get_alter_ego(string) : string;
-}
-
-/* scanner stack */
-
-#define PPSTACK_BUFFER 512
-
-static void ppstack_init (ppstack *stack, ppheap **pheap)
-{
-  stack->buf = stack->pos = (ppobj *)pp_malloc(PPSTACK_BUFFER * sizeof(ppobj));
-  stack->size = 0;
-  stack->space = PPSTACK_BUFFER;
-  stack->pheap = pheap;
-}
-
-#define ppstack_free_buffer(stack) (pp_free((stack)->buf))
-
-static void ppstack_resize (ppstack *stack)
-{
-  ppobj *newbuffer;
-  stack->space <<= 1;
-  newbuffer = (ppobj *)pp_malloc(stack->space * sizeof(ppobj));
-  memcpy(newbuffer, stack->buf, stack->size * sizeof(ppobj));
-  ppstack_free_buffer(stack);
-  stack->buf = newbuffer;
-  stack->pos = newbuffer + stack->size;
-}
-
-#define ppstack_push(stack) ((void)((stack)->size < (stack)->space || (ppstack_resize(stack), 0)), ++(stack)->size, (stack)->pos++)
-#define ppstack_pop(stack, n) ((stack)->size -= (n), (stack)->pos -= (n))
-#define ppstack_at(stack, i) ((stack)->buf + i)
-#define ppstack_clear(stack) ((stack)->pos = (stack)->buf, (stack)->size = 0)
-
-/* scanner commons */
-
-#define ppscan_uint(I, u) iof_get_uintlw(I, u)
-#define ppread_uint(s, u) string_to_uintlw((const char *)(s), u)
-
-static ppobj * ppscan_numobj (iof *I, ppobj *obj, int negative)
-{
-  ppint integer;
-  ppnum number;
-  int exponent;
-  int c;
-  c = iof_char(I);
-  iof_scan_integer(I, c, integer);
-  switch(c)
-  {
-    case '.':
-    {
-      number = (ppnum)integer;
-      c = iof_next(I);
-      iof_scan_fraction(I, c, number, exponent);
-      double_negative_exp10(number, exponent);
-      obj->type = PPNUM, obj->number = negative ? -number : number;
-      break;
-    }
-    default:
-      obj->type = PPINT, obj->integer = negative ? -integer : integer;
-      break;
-  }
-  return obj;
-}
-
-static ppobj * ppscan_numobj_frac (iof *I, ppobj *obj, int negative)
-{
-  ppnum number;
-  int c, exponent;
-
-  number = 0.0;
-  c = iof_next(I);
-  iof_scan_fraction(I, c, number, exponent);
-  double_negative_exp10(number, exponent);
-  obj->type = PPNUM, obj->number = negative ? -number : number;
-  return obj;
-}
-
-static int ppscan_find (iof *I)
-{ // skips whitechars and comments
-  int c;
-  for (c = iof_char(I); ; c = iof_next(I))
-  {
-    switch (c)
-    {
-      case IGNORED_CHAR_CASE:
-        break;
-      case '%': {
-        do {
-          if ((c = iof_next(I)) < 0)
-            return c;
-        } while (!newline_char(c));
-        break;
-      }
-      default:
-        return c;
-    }
-  }
-  return c; // never reached
-}
-
-static int ppscan_keyword (iof *I, const char *keyword, size_t size)
-{
-  size_t i;
-  int c;
-  if (iof_left(I) >= size)
-  {
-    if (memcmp(I->pos, keyword, size) != 0)
-      return 0;
-    I->pos += size;
-    return 1;
-  }
-  // sticky case, we can't go back
-  for (i = 0, c = iof_char(I); i < size; ++i, ++keyword, c = iof_next(I))
-    if (i != c)
-      return 0;
-  return 1;
-}
-
-#define ppscan_key(I, literal) ppscan_keyword(I, "" literal, sizeof(literal) - 1)
-
-/* objects parser */
-
-static ppref * ppref_unresolved (ppheap **pheap, ppuint refnumber, ppuint refversion)
-{
-  ppref *ref = (ppref *)ppheap_take(pheap, sizeof(ppref));
-  memset(ref, 0, sizeof(ppref));
-  ref->object.type = PPNONE;
-  ref->number = refnumber;
-  ref->version = refversion;
-  return ref;
-}
-
-#define PPMARK PPNONE
-
-static ppobj * ppscan_obj (iof *I, ppdoc *pdf, ppxref *xref)
-{
-  int c;
-  ppobj *obj;
-  size_t mark, size;
-  ppuint refnumber, refversion;
-  ppref *ref;
-  ppstack *stack;
-  ppcrypt *crypt;
-
-  stack = &pdf->stack;
-  c = iof_char(I);
-  switch (c)
-  {
-    case DIGIT_CHAR_CASE:
-      return ppscan_numobj(I, ppstack_push(stack), 0);
-    case '.':
-      return ppscan_numobj_frac(I, ppstack_push(stack), 0);
-    case '+':
-      ++I->pos;
-      return ppscan_numobj(I, ppstack_push(stack), 0);
-    case '-':
-      ++I->pos;
-      return ppscan_numobj(I, ppstack_push(stack), 1);
-    case '/':
-      ++I->pos;
-      obj = ppstack_push(stack);
-      obj->type = PPNAME;
-      obj->name = ppscan_name(I, &pdf->heap);
-      return obj;
-    case '(':
-      ++I->pos;
-      obj = ppstack_push(stack);
-      obj->type = PPSTRING;
-      if (ppcrypt_ref(pdf, crypt))
-        obj->string = ppscan_crypt_string(I, crypt, &pdf->heap);
-      else
-        obj->string = ppscan_string(I, &pdf->heap);
-      return obj;
-    case '[':
-      mark = stack->size;
-      obj = ppstack_push(stack);
-      obj->type = PPMARK; // ppscan_obj() checks types backward for 'R', so set the type immediatelly (reserved for PPARRAY)
-      obj->any = NULL;
-      ++I->pos;
-      for (c = ppscan_find(I); c != ']'; c = ppscan_find(I))
-      {
-        if (ppscan_obj(I, pdf, xref) == NULL)
-        { // callers assume that NULL returns means nothing pushed
-          size = stack->size - mark; // pop items AND the obj reserved for array
-          ppstack_pop(stack, size);
-          return NULL;
-        }
-      }
-      ++I->pos;
-      size = stack->size - mark - 1;
-      obj = ppstack_at(stack, mark); // stack might have been realocated
-      obj->type = PPARRAY;
-      obj->array = pparray_create(ppstack_at(stack, mark + 1), size, &pdf->heap);
-      ppstack_pop(stack, size); // pop array items, leave the array on top
-      return obj;
-    case '<':
-      if ((c = iof_next(I)) == '<')
-      {
-        mark = stack->size;
-        obj = ppstack_push(stack);
-        obj->type = PPMARK;
-        obj->any = NULL;
-        ++I->pos;
-        for (c = ppscan_find(I); c != '>'; c = ppscan_find(I))
-        {
-          if (ppscan_obj(I, pdf, xref) == NULL)
-          {
-            size = stack->size - mark;
-            ppstack_pop(stack, size);
-            return NULL;
-          }
-        }
-        if (iof_next(I) == '>')
-          ++I->pos;
-        size = stack->size - mark - 1;
-        obj = ppstack_at(stack, mark);
-        obj->type = PPDICT;
-        obj->dict = ppdict_create(ppstack_at(stack, mark + 1), size, &pdf->heap);
-        ppstack_pop(stack, size);
-        return obj;
-      }
-      obj = ppstack_push(stack);
-      obj->type = PPSTRING;
-      if (ppcrypt_ref(pdf, crypt))
-        obj->string = ppscan_crypt_base16(I, crypt, &pdf->heap);
-      else
-        obj->string = ppscan_base16(I, &pdf->heap);
-      return obj;
-    case 'R':
-      if (stack->size >= 2 && stack->pos[-1].type == PPINT && stack->pos[-2].type == PPINT)
-      {
-        ++I->pos;
-        obj = &stack->pos[-2];
-        refnumber = (ppuint)obj->integer;
-        ppstack_pop(stack, 1); // pop version number, retype obj to a reference
-        if (xref == NULL || (ref = ppxref_find(xref, refnumber)) == NULL)
-        { /* pdf spec page 64: unresolvable reference is not an error, should just be treated as a reference to null.
-             we also need this to read trailer, where refs can't be resolved yet */
-          refversion = (obj + 1)->integer;
-          //if (xref != NULL)
-          //  loggerf("unresolved reference %s", ppref_str(refnumber, refversion));
-          ref = ppref_unresolved(stack->pheap, refnumber, refversion);
-        }
-        obj->type = PPREF;
-        obj->ref = ref;
-        return obj;
-      }
-      break;
-    case 't':
-      if (iof_next(I) == 'r' && iof_next(I) == 'u' && iof_next(I) == 'e')
-      {
-        ++I->pos;
-        obj = ppstack_push(stack);
-        obj->type = PPBOOL;
-        obj->integer = 1;
-        return obj;
-      }
-      break;
-    case 'f':
-      if (iof_next(I) == 'a' && iof_next(I) == 'l' && iof_next(I) == 's' && iof_next(I) == 'e')
-      {
-        ++I->pos;
-        obj = ppstack_push(stack);
-        obj->type = PPBOOL;
-        obj->integer = 0;
-        return obj;
-      }
-      break;
-    case 'n':
-      if (iof_next(I) == 'u' && iof_next(I) == 'l' && iof_next(I) == 'l')
-      {
-        ++I->pos;
-        obj = ppstack_push(stack);
-        obj->type = PPNULL;
-        obj->any = NULL;
-        return obj;
-      }
-      break;
-  }
-  return NULL;
-}
-
-/*
-A variant for contents streams (aka postscript); wise of operators, blind to references.
-We are still PDF, so we don't care about postscript specific stuff such as radix numbers
-and scientific numbers notation. It takes ppstack * as context (no ppdoc *) to be able
-to run contents parser beyond the scope of ppdoc heap.
-*/
-
-static ppstring ppstring_inline (iof *I, ppdict *imagedict, ppheap **pheap);
-
-static ppobj * ppscan_psobj (iof *I, ppstack *stack)
-{
-  int c;
-  ppobj *obj, *op;
-  size_t size, mark;
-  ppname exec;
-
-  c = iof_char(I);
-  switch (c)
-  {
-    case DIGIT_CHAR_CASE:
-      return ppscan_numobj(I, ppstack_push(stack), 0);
-    case '.':
-      return ppscan_numobj_frac(I, ppstack_push(stack), 0);
-    case '+':
-      c = iof_next(I);
-      if (base10_digit(c)) // '+.abc' is probably an executable name, but we are not in postscript
-        return ppscan_numobj(I, ppstack_push(stack), 0);
-      else if (c == '.')
-        return ppscan_numobj_frac(I, ppstack_push(stack), 0);
-      obj = ppstack_push(stack);
-      obj->type = PPNAME;
-      obj->name = ppscan_exec(I, stack->pheap, '+');
-      return obj;
-    case '-':
-      c = iof_next(I);
-      if (base10_digit(c)) // ditto, we would handle type1 '-|' '|-' operators though
-        return ppscan_numobj(I, ppstack_push(stack), 1);
-      else if (c == '.')
-        return ppscan_numobj_frac(I, ppstack_push(stack), 1);
-      obj = ppstack_push(stack);
-      obj->type = PPNAME;
-      obj->name = ppscan_exec(I, stack->pheap, '-');
-      return obj;
-    case '/':
-      ++I->pos;
-      obj = ppstack_push(stack);
-      obj->type = PPNAME;
-      obj->name = ppscan_name(I, stack->pheap);
-      return obj;
-    case '(':
-      ++I->pos;
-      obj = ppstack_push(stack);
-      obj->type = PPSTRING;
-      obj->string = ppscan_string(I, stack->pheap);
-      return obj;
-    case '[':
-      mark = stack->size;
-      obj = ppstack_push(stack);
-      obj->type = PPMARK;
-      obj->any = NULL;
-      ++I->pos;
-      for (c = ppscan_find(I); c != ']'; c = ppscan_find(I))
-      {
-        if (ppscan_psobj(I, stack) == NULL)
-        {
-          size = stack->size - mark;
-          ppstack_pop(stack, size);
-          return NULL;
-        }
-      }
-      ++I->pos;
-      size = stack->size - mark - 1;
-      obj = ppstack_at(stack, mark);
-      obj->type = PPARRAY;
-      obj->array = pparray_create(ppstack_at(stack, mark + 1), size, stack->pheap);
-      ppstack_pop(stack, size);
-      return obj;
-    case '<':
-      if ((c = iof_next(I)) == '<')
-      {
-        mark = stack->size;
-        obj = ppstack_push(stack);
-        obj->type = PPMARK;
-        obj->any = NULL;
-        ++I->pos;
-        for (c = ppscan_find(I); c != '>'; c = ppscan_find(I))
-        {
-          if (ppscan_psobj(I, stack) == NULL)
-          {
-            size = stack->size - mark;
-            ppstack_pop(stack, size);
-            return NULL;
-          }
-        }
-        if (iof_next(I) == '>')
-          ++I->pos;
-        size = stack->size - mark - 1;
-        obj = ppstack_at(stack, mark);
-        obj->type = PPDICT;
-        obj->dict = ppdict_create(ppstack_at(stack, mark + 1), size, stack->pheap);
-        ppstack_pop(stack, size);
-        return obj;
-      }
-      obj = ppstack_push(stack);
-      obj->type = PPSTRING;
-      if (c == '~')
-        ++I->pos, obj->string = ppscan_base85(I, stack->pheap);
-      else
-        obj->string = ppscan_base16(I, stack->pheap);
-      return obj;
-    default:
-      if (c < 0 || !ppname_byte_lookup[c])
-        break; // forbid empty names; dead loop otherwise
-      ++I->pos;
-      /* true false null practically don't occur in streams so it makes sense to assume that we get an operator name here.
-         If it happen to be a keyword we could give back those several bytes to the heap but.. heap buffer is tricky enough. */
-      exec = ppscan_exec(I, stack->pheap, c);
-      obj = ppstack_push(stack);
-      switch (exec[0])
-      {
-        case 't':
-          if (exec[1] == 'r' && exec[2] == 'u' && exec[3] == 'e' && exec[4] == '\0')
-          {
-            obj->type = PPBOOL;
-            obj->integer = 1;
-            // todo: drop exec
-            return obj;
-          }
-          break;
-        case 'f':
-          if (exec[1] == 'a' && exec[2] == 'l' && exec[3] == 's' && exec[4] == 'e' && exec[5] == '\0')
-          {
-            obj->type = PPBOOL;
-            obj->integer = 0;
-            // todo: drop exec
-            return obj;
-          }
-          break;
-        case 'n':
-          if (exec[1] == 'u' && exec[2] == 'l' && exec[3] == 'l' && exec[4] == '\0')
-          {
-            obj->type = PPNULL;
-            obj->any = NULL;
-            // todo: drop exec
-            return obj;
-          }
-          break;
-        case 'B':
-           /*
-           Inline images break rules of operand/operator syntax, so 'BI/ID' operators need to be treated as special syntactic keywords.
-
-             BI <keyval pairs> ID<whitechar?><imagedata><whitechar?>EI
-
-           We treat the image as a single syntactic token; BI starts collecting a dict, ID is the beginning of the data. Effectively EI
-           operator obtains two operands - dict and string. It is ok to put three items onto the stack, callers dont't assume there is just one.
-           */
-          if (exec[1] == 'I' && exec[2] == '\0')
-          {
-            ppdict *imagedict;
-            /* key val pairs -> dict */
-            mark = stack->size - 1;
-            obj->type = PPMARK;
-            obj->any = NULL;
-            for (c = ppscan_find(I); ; c = ppscan_find(I))
-            {
-              if ((op = ppscan_psobj(I, stack)) == NULL)
-              {
-                size = stack->size - mark;
-                ppstack_pop(stack, size);
-                return NULL;
-              }
-              if (op->type == PPNAME && ppname_exec(op->name))
-              {
-                if (!ppname_is(op->name, "ID"))
-                { // weird
-                  size = stack->size - mark;
-                  ppstack_pop(stack, size);
-                  return NULL;
-                }
-                break;
-              }
-            }
-            size = stack->size - mark - 1;
-            obj = ppstack_at(stack, mark);
-            obj->type = PPDICT;
-            obj->dict = imagedict = ppdict_create(ppstack_at(stack, mark + 1), size, stack->pheap);
-            ppstack_pop(stack, size);
-            /* put image data string */
-            obj = ppstack_push(stack);
-            obj->type = PPSTRING;
-            obj->string = ppstring_inline(I, imagedict, stack->pheap);;
-            /* put EI operator name */
-            obj = ppstack_push(stack);
-            obj->type = PPNAME;
-            obj->name = ppexec_internal("EI", 2, stack->pheap);
-            return obj;
-          }
-      }
-      obj->type = PPNAME;
-      obj->name = exec;
-      return obj;
-  }
-  return NULL;
-}
-
-/*
-We try to get the exact inline image length from its dict params. If cannot predict the length, we have to scan the input until 'EI'.
-I've checked on may examples that it gives the same results but one can never be sure, as 'EI' might happen to be a part of the data.
-Stripping white char is also very heuristic; \0 is a white char in PDF and very likely to be a data byte.. weak method.
-*/
-
-static size_t inline_image_length (ppdict *dict)
-{
-  ppuint w, h, bpc, colors;
-  ppname cs;
-
-  if (ppdict_get_uint(dict, "W", &w) && ppdict_get_uint(dict, "H", &h) && ppdict_get_uint(dict, "BPC", &bpc) && (cs = ppdict_get_name(dict, "CS")) != NULL)
-  {
-    if (ppname_is(cs, "DeviceGray"))
-      colors = 1;
-    else if (ppname_is(cs, "DeviceRGB"))
-      colors = 3;
-    else if (ppname_is(cs, "DeviceCMYK"))
-      colors = 4;
-    else
-      return PP_LENGTH_UNKNOWN;
-    return (w * h * bpc * colors + 7) >> 3;
-  }
-  return PP_LENGTH_UNKNOWN;
-}
-
-static ppstring ppstring_inline (iof *I, ppdict *imagedict, ppheap **pheap)
-{
-  iof *O;
-  int c, d, e;
-  size_t length, leftin, leftout, bytes;
-
-  O = ppheap_buffer(pheap, sizeof(_ppstring), PPSTRING_INIT);
-  c = iof_char(I);
-  if (ignored_char(c))
-    c = iof_next(I);
-
-  length = inline_image_length(imagedict);
-  if (length != PP_LENGTH_UNKNOWN)
-  {
-    while (length > 0 && iof_readable(I) && iof_writable(O))
-    {
-      leftin = iof_left(I);
-      leftout = iof_left(O);
-      bytes = length;
-      if (bytes > leftin) bytes = leftin;
-      if (bytes > leftout) bytes = leftout;
-      memcpy(O->pos, I->pos, bytes);
-      I->pos += bytes;
-      O->pos += bytes;
-      length -= bytes;
-    }
-    // gobble EI
-    if (ppscan_find(I) == 'E')
-      if (iof_next(I) == 'I')
-        ++I->pos;
-  }
-  else
-  {
-    while (c >= 0)
-    {
-      if (c == 'E')
-      {
-        d = iof_next(I);
-        if (d == 'I')
-        {
-          e = iof_next(I);
-          if (!ppname_byte_lookup[e])
-          { /* strip one newline from the end and stop */
-            if (O->pos - 2 >= O->buf) // sanity
-            {
-              c = *(O->pos - 1);
-              if (ignored_char(c))
-              {
-                if (c == 0x0A && *(O->pos - 2) == 0x0D)
-                  O->pos -= 2;
-                else
-                  O->pos -= 1;
-              }
-            }
-            break;
-          }
-          iof_put2(O, c, d);
-          c = e;
-        }
-        else
-        {
-          iof_put(O, c);
-          c = d;
-        }
-      }
-      else
-      {
-        iof_put(O, c);
-        c = iof_next(I);
-      }
-    }
-  }
-  return ppstring_buffer(O, pheap);
-}
-
-/* input reader */
-
-/*
-PDF input is a pseudo file that either keeps FILE * or data. Reader iof * is a proxy to input
-that provides byte-by-byte interface. Our iof structure is capable to link iof_file *input,
-but t avoid redundant checks on IOF_DATA flag, here we link iof *I directly to FILE * or mem buffer.
-When reading from file we need an internal buffer, which should be kept rather small, as it is
-only used to parse xrefs and objects (no streams). We allocate the buffer from a private heap
-(not static) to avoid conflicts when processing >1 pdfs at once. Besides, the input buffer may be
-needed after loading the document, eg. to access references raw data.
-*/
-
-#define PPDOC_BUFFER 0xFFF // keep that small, it is only used to parse body objects
-
-static void ppdoc_reader_init (ppdoc *pdf, iof_file *input)
-{
-  iof *I;
-  pdf->input = *input;
-  input = &pdf->input;
-  input->refcount = 1;
-  I = &pdf->reader;
-  if (input->flags & IOF_DATA)
-  {
-    pdf->buffer = NULL;            // input iof_file is the buffer
-    iof_string_reader(I, NULL, 0); // gets IOF_DATA flag
-  }
-  else
-  {
-    pdf->buffer = (uint8_t *)ppheap_take(&pdf->heap, PPDOC_BUFFER);
-    iof_setup_file_handle_reader(I, NULL, 0, iof_file_get_fh(input)); // gets IOF_FILE_HANDLE flag and FILE *
-    I->space = PPDOC_BUFFER; // used on refill
-  }
-}
-
-/*
-Whenever we need to read the input file, we fseek the to the given offset and fread to to the private buffer.
-The length we need is not always predictable, in which case PPDOC_BUFFER bytes are read (keep it small).
-I->buf = I->pos is set to the beginning, I->end set to the end (end is the first byte one shouldn't read).
-*/
-
-static iof * ppdoc_reader (ppdoc *pdf, size_t offset, size_t length)
-{
-  iof_file *input;
-  iof *I;
-  input = &pdf->input;
-  I = &pdf->reader;
-  if (iof_file_seek(input, offset, SEEK_SET) != 0)
-    return NULL;
-  I->flags &= ~IOF_STOPPED;
-  if (input->flags & IOF_DATA)
-  {
-    I->buf = I->pos = input->pos;
-    I->end = (length == PP_LENGTH_UNKNOWN || I->pos + length >= input->end) ? input->end : (I->pos + length);
-  }
-  else
-  {
-    I->buf = I->pos = pdf->buffer; // ->buf is actually permanently equal pdf->buffer but we might need some tricks
-    if (length == PP_LENGTH_UNKNOWN || length > PPDOC_BUFFER)
-      length = PPDOC_BUFFER;
-    length = fread(I->buf, 1, length, I->file);
-    I->end = I->buf + length;
-  }
-  return I;
-}
-
-/* The position from the beginning of input
-- for data buffer: (pdf->input.pos - pdf->input.buf) + (I->pos - I->buf)
-  I->buf == pdf->input.pos, so this resolves to (I->pos - pdf->input.buf), independent from I->buf
-- for file buffer: ftell(pdf->input.file) - (I->end - I->pos)
-*/
-
-#define ppdoc_reader_tell(pdf, I) ((size_t)(((pdf)->input.flags & IOF_DATA) ? ((I)->pos - (pdf)->input.buf) : (ftell(iof_file_get_fh(&(pdf)->input)) - ((I)->end - (I)->pos))))
-
-/* pdf */
-
-#define PPDOC_HEADER 10 // "%PDF-?.??\n"
-
-static int ppdoc_header (ppdoc *pdf, uint8_t header[PPDOC_HEADER])
-{
-  size_t i;
-  if (memcmp(header, "%PDF-", 5) != 0)
-    return 0;
-  for (i = 5; i < PPDOC_HEADER - 1 && !ignored_char(header[i]); ++i)
-    pdf->version[i - 5] = header[i];
-  pdf->version[i - 5] = '\0';
-  return 1;
-}
-
-static int ppdoc_tail (ppdoc *pdf, iof_file *input, size_t *pxrefoffset)
-{
-  int c;
-  uint8_t tail[4*10], *p, back, tailbytes;
-
-  if (iof_file_seek(input, 0, SEEK_END) != 0)
-    return 0;
-  pdf->filesize = (size_t)iof_file_tell(input);
-  // simple heuristic to avoif fgetc() / fseek(-2) hiccup: keep seeking back by len(startxref) + 1 == 10
-  // until a letter found (assuming liberal white characters and tail length)
-  for (back = 1, tailbytes = 0; ; ++back)
-  {
-    if (iof_file_seek(input, -10, SEEK_CUR) != 0)
-      return 0;
-    tailbytes += 10;
-    c = iof_file_getc(input);
-    tailbytes -= 1;
-    switch (c)
-    {
-      case IGNORED_CHAR_CASE:
-      case DIGIT_CHAR_CASE:
-      case '%': case 'E': case 'O': case 'F':
-        if (back > 4) // 2 should be enough
-          return 0;
-        continue;
-      case 's': case 't': case 'a': case 'r': case 'x': case 'e': case 'f':
-        if (iof_file_read(tail, 1, tailbytes, input) != tailbytes)
-          return 0;
-        tail[tailbytes] = '\0';
-        for (p = &tail[0]; ; ++p)
-        {
-          if (*p == '\0')
-            return 0;
-          if ((c = base10_value(*p)) >= 0)
-            break;
-        }
-        ppread_uint(p, pxrefoffset);
-        return 1;
-      default:
-        return 0;
-    }
-  }
-  return 0;
-}
-
-/* xref/body */
-
-static int ppscan_start_entry (iof *I, ppref *ref)
-{
-  ppuint u;
-  ppscan_find(I); if (!ppscan_uint(I, &u) || u != ref->number) return 0;
-  ppscan_find(I); if (!ppscan_uint(I, &u) || u != ref->version) return 0;
-  ppscan_find(I); if (!ppscan_key(I, "obj")) return 0;
-  ppscan_find(I);
-  return 1;
-}
-
-static int ppscan_skip_entry (iof *I)
-{
-  size_t u;
-  ppscan_find(I); if (!ppscan_uint(I, &u)) return 0;
-  ppscan_find(I); if (!ppscan_uint(I, &u)) return 0;
-  ppscan_find(I); if (!ppscan_key(I, "obj")) return 0;
-  ppscan_find(I);
-  return 1;
-}
-
-static int ppscan_start_stream (iof *I, ppdoc *pdf, size_t *streamoffset)
-{
-  int c;
-  ppscan_find(I);
-  if (ppscan_key(I, "stream"))
-  { // skip 1 or 2 whites (here we shouldn't just gobble all blanks)
-    c = iof_char(I);
-    if (ignored_char(c))
-    {
-      c = iof_next(I);
-      if (ignored_char(c))
-        ++I->pos;
-    }
-    *streamoffset = ppdoc_reader_tell(pdf, I);
-    return 1;
-  }
-  return 0;
-}
-
-static ppxref * ppxref_load (ppdoc *pdf, size_t xrefoffset);
-static ppxref * ppxref_load_chain (ppdoc *pdf, ppxref *xref);
-
-/* Parsing xref table
-
-  1 10               // first ref number and refs count
-  0000000000 00000 n // 10-digits offset, 5 digits version, type identifier
-  0000000000 00000 n // n states for normal I guess
-  0000000000 00000 f // f states for free (not used)
-  ...
-
-Free entries seem to be a relic of ancient times, completelly useless for us. To avoid parsing xref table twice,
-we waste some space on free entries by allocating one plane of refs for each section. Later on we slice sections,
-so that effectively free entries are not involved in map.
-
-Subsequent refs gets number, version and offset. Other fields initialized when parsing PDF body.
-
-Having xref table loaded, we sort sections for future binary search (xref with objects count == 0 is considered invalid).
-
-Then we have to deal with the trailer dict. In general, to load objects and resolve references we need a complete chain
-of xrefs (not only the top). To load the previous xref, we need its offset, which is given in trailer. So we have to
-parse the trailer ignoring references, which might be unresolvable at this point (objects parser makes a dummy check
-for xref != NULL on refs resolving ppscan_obj(), which irritates me but I don't want a separate parser for trailer..).
-The same applies to xref streams, in which we have parse the trailer not having xref map at all. So the procedure is:
-
-  - load xref map, initialize references, make it ready to search
-  - parse trailer ignoring references
-  - get /Prev xref offset and load older xref (linked list via ->prev)
-  - sort all refs in all xrefs by offset
-  - parse refs in order resolving references in contained objects
-  - fix trailer references
-
-First created xref becomes a pdf->xref (top xref). We link that early to control offsets already read (insane loops?).
-*/
-
-// Every xref table item "0000000000 00000 n" is said to be terminated with 2-byte EOL but we don't like relying on whites.
-#define xref_item_length (10+1+5+1+1)
-
-static ppxref * ppxref_load_table (iof *I, ppdoc *pdf, size_t xrefoffset)
-{
-  ppxref *xref;
-  ppxsec *xrefsection;
-  ppref *ref;
-  ppuint first, count, refindex;
-  uint8_t buffer[xref_item_length + 1];
-  const char *p;
-  const ppobj *obj;
-
-  buffer[xref_item_length] = '\0';
-  xref = ppxref_create(pdf, 0, xrefoffset);
-  if (pdf->xref == NULL) pdf->xref = xref;
-  for (ppscan_find(I); ppscan_uint(I, &first); ppscan_find(I))
-  {
-    ppscan_find(I);
-    if (!ppscan_uint(I, &count))
-      return NULL;
-    if (count == 0) // weird
-      continue;
-    xref->count += count;
-    xrefsection = NULL;
-    ref = (ppref *)ppheap_take(&pdf->heap, count * sizeof(ppref));
-    for (refindex = 0; refindex < count; ++refindex, ++ref)
-    {
-      ref->xref = xref;
-      ref->number = first + refindex;
-      ppscan_find(I);
-      iof_read(I, buffer, xref_item_length);
-      switch (buffer[xref_item_length - 1])
-      {
-        case 'n':
-          if (xrefsection == NULL)
-          {
-            xrefsection = ppxref_push_section(xref, &pdf->heap);
-            xrefsection->first = ref->number;
-            xrefsection->refs = ref;
-          }
-          xrefsection->last = ref->number;
-          for (p = (const char *)buffer; *p == '0'; ++p);
-          p = ppread_uint(p, &ref->offset);
-          for ( ; *p == ' ' || *p == '0'; ++p);
-          p = ppread_uint(p, &ref->version);
-          ref->object.type = PPNONE; // init for sanity
-          ref->object.any = NULL;
-          ref->length = 0;
-          break;
-        case 'f':
-        default:
-          --ref;
-          xrefsection = NULL;
-          --xref->count;
-      }
-    }
-  }
-  /* sort section */
-  if (!ppxref_sort(xref))
-    ; // case of xref->size == 0 handled by ppxref_load_chain()
-  /* get trailer ignoring refs */
-  if (!ppscan_key(I, "trailer"))
-    return NULL;
-  ppscan_find(I);
-  if ((obj = ppscan_obj(I, pdf, NULL)) == NULL)
-    return NULL;
-  ppstack_pop(&pdf->stack, 1);
-  if (obj->type != PPDICT)
-    return NULL;
-  xref->trailer = *obj;
-  return ppxref_load_chain(pdf, xref);
-}
-
-/* Parsing xref stream
-First we load the trailer, ignoring references. Dict defines sections and fields lengths:
-
-  /Size                                  % max ref number plus 1
-  /Index [ first count first count ... ] % a pair of numbers for every section, defaults to [0 Size]
-  /W [w1 w2 w3]                          % fields lengths, 0 states for omitted field
-
-xref stream data is a continuous stream of binary number triplets. First number is a type:
-
-  0 - free entry (as 'f' in xref table)
-  1 - normal entry, followed by offset an version (as 'n' in xref table)
-  2 - compressed entry, followed by parent object stream number and entry index
-
-0 and 1 are handled as 'n' and 'f' entries in xref table. For type 2 we normally initialize
-ref->number and ref->version (the later is implicitly 0). ref->offset is set to 0 (invalid offset),
-which is recognized by objects loader.
-*/
-
-#define XREF_STREAM_MAX_FIELD 4
-
-static ppxref * ppxref_load_stream (iof *I, ppdoc *pdf, size_t xrefoffset)
-{
-  ppxref *xref;
-  ppxsec *xrefsection;
-  ppref *ref;
-  ppobj *obj;
-  ppstream *xrefstream;
-  size_t streamoffset;
-  ppuint w1, w2, w3, w, bufferbytes;
-  uint8_t buffer[3 * XREF_STREAM_MAX_FIELD], *b;
-  ppuint first, count, f1, f2, f3;
-  pparray *fieldwidths, *sectionindices;
-  ppobj sectionmock[2], *sectionfirst, *sectioncount;
-  size_t sections, sectionindex, refindex;
-
-  if (!ppscan_skip_entry(I))
-    return NULL;
-  if ((obj = ppscan_obj(I, pdf, NULL)) == NULL)
-    return NULL;
-  ppstack_pop(&pdf->stack, 1);
-  if (obj->type != PPDICT || !ppscan_start_stream(I, pdf, &streamoffset))
-    return NULL;
-  xrefstream = ppstream_create(pdf, obj->dict, streamoffset);
-  /* All normal streams go through ppstream_info(), but it makes no sense for trailer stream (no crypt allowed, no refs yet).
-     So we just record the length and informative flag. Here we have to expect that /Length and /Filter are not indirects. */
-  if (!ppdict_get_uint(obj->dict, "Length", &xrefstream->length))
-    return NULL;
-  if (ppdict_get_obj(obj->dict, "Filter") != NULL)
-    xrefstream->flags |= PPSTREAM_COMPRESSED;
-  if ((fieldwidths = ppdict_get_array(xrefstream->dict, "W")) != NULL)
-  {
-    if (!pparray_get_uint(fieldwidths, 0, &w1)) w1 = 0;
-    if (!pparray_get_uint(fieldwidths, 1, &w2)) w2 = 0;
-    if (!pparray_get_uint(fieldwidths, 2, &w3)) w3 = 0;
-  }
-  else
-    w1 = w2 = w3 = 0;
-  if (w1 > XREF_STREAM_MAX_FIELD || w2 > XREF_STREAM_MAX_FIELD || w3 > XREF_STREAM_MAX_FIELD)
-    return NULL;
-  bufferbytes = w1 + w2 + w3;
-  if ((sectionindices = ppdict_get_array(xrefstream->dict, "Index")) != NULL)
-  {
-    sections = sectionindices->size >> 1;
-    sectionfirst = sectionindices->data;
-  }
-  else
-  {
-    sections = 1;
-    sectionmock[0].type = PPINT;
-    sectionmock[0].integer = 0;
-    sectionmock[1].type = PPINT;
-    if (!ppdict_get_int(xrefstream->dict, "Size", &sectionmock[1].integer))
-      sectionmock[1].integer = 0;
-    sectionfirst = &sectionmock[0];
-  }
-  if ((I = ppstream_read(xrefstream, 1, 0)) == NULL)
-    return NULL; // we fseek() so original I is useless anyway
-  xref = ppxref_create(pdf, sections, xrefoffset);
-  if (pdf->xref == NULL) pdf->xref = xref;
-  xref->trailer.type = PPSTREAM;
-  xref->trailer.stream = xrefstream;
-  for (sectionindex = 0; sectionindex < sections; ++sectionindex, sectionfirst += 2)
-  {
-    sectioncount = sectionfirst + 1;
-    if (!ppobj_get_uint(sectionfirst, first) || !ppobj_get_uint(sectioncount, count))
-      goto xref_stream_error;
-    if (count == 0)
-      continue;
-    xref->count += count;
-    xrefsection = NULL;
-    ref = (ppref *)ppheap_take(&pdf->heap, count * sizeof(ppref));
-    for (refindex = 0; refindex < count; ++refindex, ++ref)
-    {
-      ref->xref = xref;
-      ref->number = first + refindex;
-      if (iof_read(I, buffer, bufferbytes) != bufferbytes)
-        goto xref_stream_error;
-      b = buffer;
-      if (w1 == 0)
-        f1 = 1; // default type is 1
-      else
-        for (f1 = 0, w = 0; w < w1; f1 = (f1 << 8)|(*b), ++w, ++b);
-      for (f2 = 0, w = 0; w < w2; f2 = (f2 << 8)|(*b), ++w, ++b);
-      for (f3 = 0, w = 0; w < w3; f3 = (f3 << 8)|(*b), ++w, ++b);
-      switch (f1)
-      {
-        case 0:
-          //--ref;
-          xrefsection = NULL;
-          --xref->count;
-          break;
-        case 1:
-          if (xrefsection == NULL)
-          {
-            xrefsection = ppxref_push_section(xref, &pdf->heap);
-            xrefsection->first = ref->number;
-            xrefsection->refs = ref;
-          }
-          xrefsection->last = ref->number;
-          ref->offset = f2;
-          ref->version = f3;
-          ref->object.type = PPNONE;
-          ref->object.any = NULL;
-          ref->length = 0;
-          break;
-        case 2:
-          if (xrefsection == NULL)
-          {
-            xrefsection = ppxref_push_section(xref, &pdf->heap);
-            xrefsection->first = ref->number;
-            xrefsection->refs = ref;
-          }
-          xrefsection->last = ref->number;
-          ref->offset = 0; // f2 is parent objstm, f3 is index in parent, both useless
-          ref->version = 0; // compressed objects has implicit version == 0
-          ref->object.type = PPNONE;
-          ref->object.any = NULL;
-          ref->length = 0;
-          break;
-        default:
-          goto xref_stream_error;
-      }
-    }
-  }
-  /* sort sections */
-  if (!ppxref_sort(xref))
-    ; // case of xref->size == 0 handled by ppxref_load_chain()
-  /* close the stream _before_ loading prev xref */
-  ppstream_done(xrefstream);
-  /* load prev and return */
-  return ppxref_load_chain(pdf, xref);
-xref_stream_error:
-  ppstream_done(xrefstream);
-  return NULL;
-}
-
-/*
-The following procedure loads xref /Prev, links xref->prev and typically returns xref.
-Some docs contain empty xref (one section with zero objects) that is actually a proxy
-to xref stream referred as /XRefStm (genuine concept of xrefs old/new style xrefs in
-the same doc). In case of 0-length xref we ignore the proxy and return the target xref
-(otherwise we would need annoying sanity check for xref->size > 0 on every ref search).
-*/
-
-static ppxref * ppxref_load_chain (ppdoc *pdf, ppxref *xref)
-{
-  ppdict *trailer;
-  ppuint xrefoffset;
-  ppxref *prevxref, *nextxref;
-
-  trailer = ppxref_trailer(xref);
-  if (!ppdict_get_uint(trailer, "Prev", &xrefoffset)) // XRefStm is useless
-    return xref; // missing /Prev is obviously ok
-  for (nextxref = pdf->xref; nextxref != NULL; nextxref = nextxref->prev)
-    if (nextxref->offset == xrefoffset) // insane
-      return NULL;
-  if ((prevxref = ppxref_load(pdf, (size_t)xrefoffset)) == NULL)
-    return NULL;
-  if (xref->size > 0)
-  {
-    xref->prev = prevxref;
-    return xref;
-  }
-  if (pdf->xref == xref)
-    pdf->xref = prevxref;
-  return prevxref;
-}
-
-static ppxref * ppxref_load (ppdoc *pdf, size_t xrefoffset)
-{
-  iof *I;
-  if ((I = ppdoc_reader(pdf, xrefoffset, PP_LENGTH_UNKNOWN)) == NULL)
-    return NULL;
-  ppscan_find(I);
-  if (ppscan_key(I, "xref"))
-    return ppxref_load_table(I, pdf, xrefoffset);
-  return ppxref_load_stream(I, pdf, xrefoffset);
-  // iof_close(I) does nothing here
-}
-
-static void ppoffmap_sort (ppref **left, ppref **right)
-{
-  ppref **l, **r, *t;
-  ppuint pivot;
-  l = left, r = right;
-  pivot = (*(l + ((r - l) / 2)))->offset;
-  do
-  { // don't read from pointer!
-    while ((*l)->offset < pivot) ++l;
-    while ((*r)->offset > pivot) --r;
-    if (l <= r)
-    {
-      t = *l;
-      *l = *r;
-      *r = t;
-      ++l, --r;
-    }
-  } while (l <= r);
-  if (left < r)
-    ppoffmap_sort(left, r);
-  if (l < right)
-    ppoffmap_sort(l, right);
-}
-
-
-static void fix_trailer_references (ppdoc *pdf)
-{
-  ppxref *xref;
-  ppdict *trailer;
-  ppname *pkey;
-  ppobj *obj;
-  ppref *ref;
-  for (xref = pdf->xref; xref != NULL; xref = xref->prev)
-  {
-    if ((trailer = ppxref_trailer(xref)) == NULL)
-      continue;
-    for (ppdict_first(trailer, pkey, obj); *pkey != NULL; ppdict_next(pkey, obj))
-    { // no need to go deeper in structs, all items in trailer except info and root must be direct refs
-      if (obj->type != PPREF)
-        continue;
-      ref = obj->ref;
-      if (ref->offset == 0) // unresolved?
-        if ((ref = ppxref_find(xref, ref->number)) != NULL)
-          obj->ref = ref; // at this moment the reference still points nothing, but should be the one with the proper offset
-    }
-  }
-}
-
-/*
-Here comes a procedure that loads all entries from all document bodies. We resolve references while
-parsing objects and to make resolving correct, we need a complete chain of xref maps, and a knowledge
-about possible linearized dict (first offset). So loading refs sorted by offsets makes sense (not sure
-if it matters nowadays but we also avoid fseek() by large offsets).
-
-Here is the proc:
-
-  - create a list of all refs in all bodies
-  - sort the list by offsets
-  - for every ref from the sorted list:
-    - estimate object length to avoid fread-ing more than necessary (not perfect but enough)
-    - fseek() to the proper offset, fread() entry data or its part
-    - parse the object with ppscan_obj(I, pdf, xref), where xref is not necessarily top pdf->xref
-    - save the actual ref->length (not sure if we need that?)
-    - make a stream if a dict is followed by "stream" keyword, also save the stream offset
-  - free the list
-*/
-
-static int ppdoc_load_objstm (ppstream *stream, ppdoc *pdf, ppxref *xref);
-
-static void ppdoc_load_entries (ppdoc *pdf)
-{
-  size_t objects, sectionindex, refnumber, offindex;
-  ppnum linearized;
-  ppref **offmap, **pref, *ref;
-  ppxref *xref;
-  ppxsec *xsec;
-  ppobj *obj;
-  ppname type;
-  int redundant_indirection = 0;
-  ppcrypt *crypt;
-  ppstream *stream;
-
-  if ((objects = (size_t)ppdoc_objects(pdf)) == 0) // can't happen
-    return;
-  pref = offmap = (ppref **)pp_malloc(objects * sizeof(ppref *));
-  objects = 0; // recount refs with offset > 0
-  for (xref = pdf->xref; xref != NULL; xref = xref->prev)
-    for (sectionindex = 0, xsec = xref->sects; sectionindex < xref->size; ++sectionindex, ++xsec)
-      for (refnumber = xsec->first, ref = xsec->refs; refnumber <= xsec->last; ++refnumber, ++ref)
-        if (ref->offset > 0) // 0 means compressed or insane
-          *pref++ = ref, ++objects;
-  ppoffmap_sort(offmap, offmap + objects - 1);
-
-  crypt = pdf->crypt;
-  for (offindex = 0, pref = offmap; offindex < objects; )
-  {
-    ref = *pref;
-    ++pref;
-    ++offindex;
-    if (ref->object.type != PPNONE) // might be preloaded already (/Encrypt dict, stream filter dicts, stream /Length..)
-    	continue;
-    if (offindex < objects)
-      ref->length = (*pref)->offset - ref->offset;
-    else
-      ref->length = pdf->filesize > ref->offset ? pdf->filesize - ref->offset : 0;
-    if (crypt != NULL)
-    {
-      ppcrypt_start_ref(crypt, ref);
-      obj = ppdoc_load_entry(pdf, ref);
-      ppcrypt_end_ref(crypt);
-    }
-    else
-    {
-      obj = ppdoc_load_entry(pdf, ref);
-    }
-    switch (obj->type)
-    {
-      case PPDICT: /* Check if the object at first offset is linearized dict. We need that to resolve all references properly. */
-        if (offindex == 1 && ppdict_get_num(obj->dict, "Linearized", &linearized)) // /Linearized value is a version number, default 1.0
-          pdf->flags |= PPDOC_LINEARIZED;
-        break;
-      case PPREF:
-        redundant_indirection = 1;
-        break;
-      default:
-        break;
-    }
-    // if pdf->crypt crypt->ref = NULL
-  }
-
-  /* refs pointngs refs? cut. */
-  if (redundant_indirection)
-  {
-    for (offindex = 0, pref = offmap; offindex < objects; ++offindex)
-    {
-      ref = *pref++;
-      if (ref->object.type == PPREF)
-        ref->object = ref->object.ref->object; // doing for all effectively cuts all insane chains
-    }
-  }
-
-  /* now handle streams; update stream info (eg. /Length), load pdf 1.5 object streams
-     we could do earlier but then we would need to struggle with indirects */
-  for (offindex = 0, pref = offmap; offindex < objects; ++offindex)
-  {
-    ref = *pref++;
-    obj = &ref->object;
-    if (obj->type != PPSTREAM)
-      continue;
-    stream = obj->stream;
-    if (crypt != NULL)
-    {
-      ppcrypt_start_ref(crypt, ref);
-      ppstream_info(stream, pdf);
-      ppcrypt_end_ref(crypt);
-    }
-    else
-    {
-      ppstream_info(stream, pdf);
-    }
-    if (ref->xref->trailer.type == PPSTREAM && (type = ppdict_get_name(stream->dict, "Type")) != NULL && ppname_is(type, "ObjStm")) // somewhat dummy..
-      if (!ppdoc_load_objstm(stream, pdf, ref->xref))
-        loggerf("invalid objects stream %s at offset " PPSIZEF, ppref_str(ref->number, ref->version), ref->offset);
-  }
-  pp_free(offmap);
-}
-
-ppobj * ppdoc_load_entry (ppdoc *pdf, ppref *ref)
-{
-  iof *I;
-  size_t length;
-  ppxref *xref;
-  ppobj *obj;
-  ppstack *stack;
-  size_t streamoffset;
-  ppref *refref;
-  ppuint refnumber, refversion;
-
-  length = ref->length > 0 ? ref->length : PP_LENGTH_UNKNOWN; // estimated or unknown
-  if ((I = ppdoc_reader(pdf, ref->offset, length)) == NULL || !ppscan_start_entry(I, ref))
-  {
-    loggerf("invalid %s offset " PPSIZEF, ppref_str(ref->number, ref->version), ref->offset);
-    return &ref->object; // PPNONE
-  }
-  stack = &pdf->stack;
-  xref = ref->xref; // to resolve indirects properly
-  if ((obj = ppscan_obj(I, pdf, xref)) == NULL)
-  {
-    loggerf("invalid %s object at offset " PPSIZEF, ppref_str(ref->number, ref->version), ref->offset);
-    return &ref->object; // PPNONE
-  }
-  ref->object = *obj;
-  ppstack_pop(stack, 1);
-  obj = &ref->object;
-  ref->length = ppdoc_reader_tell(pdf, I) - ref->offset;
-  if (obj->type == PPDICT)
-  {
-    if (ppscan_start_stream(I, pdf, &streamoffset))
-    {
-      obj->type = PPSTREAM;
-      obj->stream = ppstream_create(pdf, obj->dict, streamoffset);
-    }
-  }
-  else if (obj->type == PPINT)
-  {
-    ppscan_find(I);
-    if (ppscan_uint(I, &refversion) && ppscan_find(I) == 'R')
-    {
-      refnumber = (ppuint)obj->integer;
-      if ((refref = ppxref_find(xref, refnumber)) != NULL)
-      {
-        obj->type = PPREF;
-        obj->ref = refref;
-      }
-      else
-      {
-        obj->type = PPNONE; // as ppref_unresolved()
-        obj->any = NULL;
-      }
-    }
-  }
-  return obj;
-}
-
-/* Loading entries from object stream
-
-  /N is the number of contained entries
-  /First is the offset of the first item
-
-The stream consists of N pairs of numbers <objnum> <offset> <objnum> <offset> ...
-Offsets are ascending (relative to the first), but ref numbers order is arbitrary.
-PDF spec says there might be some additional data between objects, so we should obey offsets.
-Which means we should basically load the stream at once (may be needed anyway to grab the stream [...]).
-*/
-
-static int ppdoc_load_objstm (ppstream *stream, ppdoc *pdf, ppxref *xref)
-{
-  ppdict *dict; // stream dict, actually still on stack
-  ppref *ref;
-  ppobj *obj;
-  ppuint items, firstoffset, offset, objnum, i, invalid = 0;
-  iof *I;
-  uint8_t *firstdata, *indexdata;
-  ppstack *stack;
-
-  dict = stream->dict;
-  if (!ppdict_rget_uint(dict, "N", &items) || !ppdict_rget_uint(dict, "First", &firstoffset))
-    return 0;
-  if ((I = ppstream_read(stream, 1, 1)) == NULL)
-    return 0;
-  firstdata = I->pos + firstoffset;
-  if (firstdata >= I->end)
-    goto invalid_objstm;
-  stack = &pdf->stack;
-  //if (pdf->crypt != NULL)
-  //  ppcrypt_end_ref(pdf->crypt); // objects are not encrypted, pdf->crypt->ref ensured NULL
-  for (i = 0; i < items; ++i)
-  {
-    ppscan_find(I);
-    if (!ppscan_uint(I, &objnum))
-      goto invalid_objstm;
-    ppscan_find(I);
-    if (!ppscan_uint(I, &offset))
-      goto invalid_objstm;
-    if ((ref = ppxref_find_local(xref, objnum)) == NULL || ref->object.type != PPNONE)
-    {
-      loggerf("invalid compressed object number " PPUINTF " at position " PPUINTF, objnum, i);
-      ++invalid;
-      continue;
-    }
-    if (firstdata + offset >= I->end)
-    {
-      loggerf("invalid compressed object offset " PPUINTF " at position " PPUINTF, offset, i);
-      ++invalid;
-      continue;
-    }
-    indexdata = I->pos; // save position
-    I->pos = firstdata + offset; // go to the object
-    ppscan_find(I);
-    if ((obj = ppscan_obj(I, pdf, xref)) != NULL)
-    {
-      ref->object = *obj;
-      ppstack_pop(stack, 1);
-      // nothing more needed, as obj can never be indirect ref or stream
-    }
-    else
-    {
-      ++invalid;
-      loggerf("invalid compressed object %s at stream offset " PPUINTF, ppref_str(objnum, 0), offset);
-    }
-    I->pos = indexdata; // restore position and read next from index
-  }
-  ppstream_done(stream);
-  return invalid == 0;
-invalid_objstm:
-  ppstream_done(stream);
-  return 0;
-}
-
-/* main PDF loader proc */
-
-ppcrypt_status ppdoc_crypt_pass (ppdoc *pdf, const void *userpass, size_t userpasslength, const void *ownerpass, size_t ownerpasslength)
-{
-  switch (pdf->cryptstatus)
-  {
-    case PPCRYPT_NONE:
-    case PPCRYPT_DONE:
-    case PPCRYPT_FAIL:
-      break;
-    case PPCRYPT_PASS: // initial status or really needs password
-      pdf->cryptstatus = ppdoc_crypt_init(pdf, userpass, userpasslength, ownerpass, ownerpasslength);
-      switch (pdf->cryptstatus)
-      {
-        case PPCRYPT_NONE:
-        case PPCRYPT_DONE:
-          ppdoc_load_entries(pdf);
-          break;
-        case PPCRYPT_PASS: // user needs to check ppdoc_crypt_status() and recall ppdoc_crypt_pass() with the proper password
-        case PPCRYPT_FAIL: // hopeless..
-          break;
-      }
-      break;
-  }
-  return pdf->cryptstatus;
-}
-
-static ppdoc * ppdoc_read (ppdoc *pdf, iof_file *input)
-{
-  uint8_t header[PPDOC_HEADER];
-  size_t xrefoffset;
-
-  input = &pdf->input;
-  if (iof_file_read(header, 1, PPDOC_HEADER, input) != PPDOC_HEADER || !ppdoc_header(pdf, header))
-    return NULL;
-  if (!ppdoc_tail(pdf, input, &xrefoffset))
-    return NULL;
-  if (ppxref_load(pdf, xrefoffset) == NULL)
-    return NULL;
-  fix_trailer_references(pdf); // after loading xrefs but before accessing trailer refs (/Encrypt might be a reference)
-  // check encryption, if any, try empty password
-  switch (ppdoc_crypt_pass(pdf, "", 0, NULL, 0))
-  {
-    case PPCRYPT_NONE: // no encryption
-    case PPCRYPT_DONE: // encryption with an empty password
-    case PPCRYPT_PASS: // the user needs to check ppdoc_crypt_status() and call ppdoc_crypt_pass()
-      break;
-    case PPCRYPT_FAIL: // hopeless
-      //loggerf("decryption failed");
-      //return NULL;
-      break;
-  }
-  return pdf;
-}
-
-static void ppdoc_pages_init (ppdoc *pdf);
-
-static ppdoc * ppdoc_create (iof_file *input)
-{
-  ppdoc *pdf;
-  ppheap *heap;
-
-  heap = ppheap_new();
-  pdf = (ppdoc *)ppheap_take(&heap, sizeof(ppdoc));
-  pdf->flags = 0;
-  pdf->heap = heap;
-  pdf->xref = NULL;
-  pdf->version[0] = '\0';
-  pdf->crypt = NULL;
-  pdf->cryptstatus = PPCRYPT_PASS; // force encryption check on ppdoc_read() -> ppdoc_crypt_pass()
-  ppstack_init(&pdf->stack, &pdf->heap);
-  ppdoc_reader_init(pdf, input);
-  ppdoc_pages_init(pdf);
-  if (ppdoc_read(pdf, &pdf->input) != NULL)
-    return pdf;
-  ppdoc_free(pdf);
-  return NULL;
-}
-
-ppdoc * ppdoc_load (const char *filename)
-{
-  FILE *file;
-  iof_file input;
-  if ((file = fopen(filename, "rb")) == NULL)
-    return NULL;
-  iof_file_init(&input, file);
-  input.flags |= IOF_CLOSE_FILE;
-  return ppdoc_create(&input);
-}
-
-ppdoc * ppdoc_mem (const void *data, size_t size)
-{
-	iof_file input;
-	iof_file_rdata_init(&input, data, size);
-	input.flags |= IOF_BUFFER_ALLOC; // todo: 3 modes: borrow, take over, copy?
-	return ppdoc_create(&input);
-}
-
-void ppdoc_free (ppdoc *pdf)
-{
-  //iof_file_free(&pdf->input);
-  iof_file_decref(&pdf->input);
-  ppstack_free_buffer(&pdf->stack);
-  ppheap_free(pdf->heap); // last!
-}
-
-ppcrypt_status ppdoc_crypt_status (ppdoc *pdf)
-{
-  return pdf->cryptstatus;
-}
-
-ppint ppdoc_permissions (ppdoc *pdf)
-{
-  return pdf->crypt != NULL ? pdf->crypt->permissions : (ppint)0xFFFFFFFFFFFFFFFF;
-}
-
-/* pages access */
-
-static pparray * pppage_node (ppdict *dict, ppuint *count, ppname *type)
-{
-  ppname *pkey, key;
-  ppobj *obj;
-  pparray *kids = NULL;
-  *count = 0;
-  *type = NULL;
-  for (ppdict_first(dict, pkey, obj); (key = *pkey) != NULL; ppdict_next(pkey, obj))
-  {
-    switch (key[0])
-    {
-      case 'T':
-        if (ppname_is(key, "Type"))
-          *type = ppobj_get_name(obj);
-        break;
-      case 'C':
-        if (ppname_is(key, "Count"))
-          ppobj_get_uint(obj, *count);
-        break;
-      case 'K':
-        if (ppname_is(key, "Kids"))
-          kids = ppobj_rget_array(obj);
-        break;
-    }
-  }
-  return kids;
-}
-
-#define ppname_is_page(type) (type != NULL && ppname_is(type, "Page"))
-
-ppuint ppdoc_page_count (ppdoc *pdf)
-{
-  ppref *ref;
-  ppname type;
-  ppuint count;
-  if ((ref = ppxref_pages(pdf->xref)) == NULL)
-    return 0;
-  if (pppage_node(ref->object.dict, &count, &type) == NULL)
-    return ppname_is_page(type) ? 1 : 0; // acrobat and ghostscript accept documents with root /Pages entry being a reference to a sole /Page object
-  return count;
-}
-
-ppref * ppdoc_page (ppdoc *pdf, ppuint index)
-{
-  ppdict *dict;
-  ppuint count;
-  pparray *kids;
-  size_t size, i;
-  ppobj *r, *o;
-  ppref *ref;
-  ppname type;
-
-
-  if ((ref = ppxref_pages(pdf->xref)) == NULL)
-    return NULL;
-  dict = ref->object.dict;
-  if ((kids = pppage_node(dict, &count, &type)) != NULL)
-  {
-    if (index < 1 || index > count)
-      return NULL;
-  }
-  else
-  {
-    return index == 1 && ppname_is_page(type) ? ref : NULL;
-  }
-scan_array:
-  if (index <= count / 2)
-  { // probably shorter way from the beginning
-    for (i = 0, size = kids->size, r = pparray_at(kids, 0); i < size; ++i, ++r)
-    {
-      if (r->type != PPREF)
-        return NULL;
-      o = &r->ref->object;
-      if (o->type != PPDICT)
-        return NULL;
-      dict = o->dict;
-      if ((kids = pppage_node(dict, &count, &type)) != NULL)
-      {
-        if (index <= count)
-          goto scan_array;
-        index -= count;
-        continue;
-      }
-      if (index == 1 && ppname_is_page(type))
-        return r->ref;
-      --index;
-    }
-  }
-  else if ((size = kids->size) > 0) // for safe (size-1)
-  { // probably shorter way from the end
-    index = count - index + 1;
-    for (i = 0, r = pparray_at(kids, size - 1); i < size; ++i, --r)
-    {
-      if (r->type != PPREF)
-        return NULL;
-      o = &r->ref->object;
-      if (o->type != PPDICT)
-        return NULL;
-      dict = o->dict;
-      if ((kids = pppage_node(dict, &count, &type)) != NULL)
-      {
-        if (index <= count)
-          goto scan_array;
-        index -= count;
-        continue;
-      }
-      if (index == 1 && ppname_is_page(type))
-        return r->ref;
-      --index;
-    }
-  }
-  return NULL;
-}
-
-/*
-Through pages iterator. Iterating over pages tree just on the base of /Kids and /Parent keys
-is ineffective, as to get next pageref we need to take parent, find the pageref in /Kids,
-take next (or go upper).. Annoying. We use a dedicated stack for pages iterator. This could
-actually be done with pdf->stack, but some operations may clear it, so safer to keep it independent
-Besides, its depth is constant (set on first use), so no need for allocs.
-*/
-
-static void ppdoc_pages_init (ppdoc *pdf)
-{
-  pppages *pages;
-  pages = &pdf->pages;
-  pages->root = pages->parent = pages->buffer;
-  pages->depth = 0;
-  pages->space = PPPAGES_STACK_DEPTH;
-}
-
-static ppkids * pppages_push (ppdoc *pdf, pparray *kids)
-{
-  ppkids *newroot, *bounds;
-  pppages *pages;
-  pages = &pdf->pages;
-  if (pages->depth == pages->space)
-  {
-    pages->space <<= 1;
-    newroot = (ppkids *)ppheap_take(&pdf->heap, pages->space * sizeof(ppkids));
-    memcpy(newroot, pages->root, pages->depth * sizeof(ppkids));
-    pages->root = newroot;
-  }
-  bounds = pages->parent = &pages->root[pages->depth++];
-  bounds->current = pparray_at(kids, 0);
-  bounds->sentinel = pparray_at(kids, kids->size);
-  return bounds;
-}
-
-#define pppages_pop(pages) (--((pages)->parent), --((pages)->depth))
-
-static ppref * ppdoc_pages_group_first (ppdoc *pdf, ppref *ref)
-{
-  ppdict *dict;
-  pparray *kids;
-  ppuint count;
-  ppname type;
-
-  dict = ref->object.dict; // typecheck made by callers
-  while ((kids = pppage_node(dict, &count, &type)) != NULL)
-  {
-    if ((ref = pparray_get_ref(kids, 0)) == NULL || ref->object.type != PPDICT)
-      return NULL;
-    pppages_push(pdf, kids);
-    dict = ref->object.dict;
-  }
-  return ppname_is_page(type) ? ref : NULL;
-}
-
-ppref * ppdoc_first_page (ppdoc *pdf)
-{
-  ppref *ref;
-  pppages *pages;
-  if ((ref = ppdoc_pages(pdf)) == NULL)
-    return NULL;
-  pages = &pdf->pages;
-  pages->parent = pages->root;
-  pages->depth = 0;
-  return ppdoc_pages_group_first(pdf, ref);
-}
-
-ppref * ppdoc_next_page (ppdoc *pdf)
-{
-  pppages *pages;
-  ppkids *bounds;
-  ppref *ref;
-  ppobj *obj;
-  pages = &pdf->pages;
-  while (pages->depth > 0)
-  {
-    bounds = pages->parent;
-    obj = ++bounds->current;
-    if (obj < bounds->sentinel)
-    {
-      if (obj->type != PPREF)
-        return NULL;
-      ref = obj->ref;
-      if (ref->object.type != PPDICT)
-        return NULL;
-      return ppdoc_pages_group_first(pdf, ref);
-    }
-    else
-    { // no next node, go upper
-      pppages_pop(pages);
-    }
-  }
-  return NULL;
-}
-
-/* context */
-
-ppcontext * ppcontext_new (void)
-{
-  ppheap *heap;
-  ppcontext *context;
-  heap = ppheap_new();
-  context = (ppcontext *)pp_malloc(sizeof(ppcontext)); // not from priv heap, as we delete it on renew
-  context->heap = heap;
-  ppstack_init(&context->stack, &context->heap);
-  return context;
-}
-
-void ppcontext_done (ppcontext *context)
-{
-  ppheap_renew(context->heap);
-  ppstack_clear(&context->stack);
-}
-
-void ppcontext_free (ppcontext *context)
-{
-  ppstack_free_buffer(&context->stack);
-  ppheap_free(context->heap);
-  pp_free(context);
-}
-
-/* page contents streams */
-
-//#define ppcontents_first_stream(array) pparray_rget_stream(array, 0)
-
-static ppstream * ppcontents_first_stream (pparray *array)
-{
-  size_t i;
-  ppobj *obj;
-  ppref *ref;
-  for (pparray_first(array, i, obj); i < array->size; pparray_next(i, obj))
-    if ((ref = ppobj_get_ref(obj)) != NULL && ref->object.type == PPSTREAM)
-      return ref->object.stream;
-  return NULL;
-}
-
-static ppstream * ppcontents_next_stream (pparray *array, ppstream *stream)
-{
-  size_t i;
-  ppobj *obj;
-  ppref *ref;
-  for (pparray_first(array, i, obj); i < array->size; pparray_next(i, obj))
-    if ((ref = ppobj_get_ref(obj)) != NULL && ref->object.type == PPSTREAM && ref->object.stream == stream)
-      if (++i < array->size && (ref = ppobj_get_ref(obj + 1)) != NULL && ref->object.type == PPSTREAM)
-        return ref->object.stream;
-  return NULL;
-}
-
-ppstream * ppcontents_first (ppdict *dict)
-{
-  ppobj *contentsobj;
-  if ((contentsobj = ppdict_rget_obj(dict, "Contents")) == NULL)
-    return NULL;
-  switch (contentsobj->type)
-  {
-    case PPARRAY:
-      return ppcontents_first_stream(contentsobj->array);
-    case PPSTREAM:
-      return contentsobj->stream;
-    default:
-      break;
-  }
-  return NULL;
-}
-
-ppstream * ppcontents_next (ppdict *dict, ppstream *stream)
-{
-  ppobj *contentsobj;
-  if ((contentsobj = ppdict_rget_obj(dict, "Contents")) == NULL)
-    return NULL;
-  switch (contentsobj->type)
-  {
-    case PPARRAY:
-      return ppcontents_next_stream(contentsobj->array, stream);
-    case PPSTREAM:
-      break;
-    default:
-      break;
-  }
-  return NULL;
-}
-
-static ppobj * ppcontents_op (iof *I, ppstack *stack, size_t *psize, ppname *pname)
-{
-  ppobj *obj;
-  ppstack_clear(stack);
-  do {
-    if (ppscan_find(I) < 0)
-      return NULL;
-    if ((obj = ppscan_psobj(I, stack)) == NULL)
-      return NULL;
-  } while (obj->type != PPNAME || !ppname_exec(obj->name));
-  *pname = obj->name;
-  *psize = stack->size - 1;
-  return stack->buf;
-}
-
-ppobj * ppcontents_first_op (ppcontext *context, ppstream *stream, size_t *psize, ppname *pname)
-{
-  iof *I;
-  if ((I = ppstream_read(stream, 1, 0)) == NULL)
-    return NULL;
-  return ppcontents_op(I, &context->stack, psize, pname);
-}
-
-ppobj * ppcontents_next_op (ppcontext *context, ppstream *stream, size_t *psize, ppname *pname)
-{
-  return ppcontents_op(ppstream_iof(stream), &context->stack, psize, pname);
-}
-
-ppobj * ppcontents_parse (ppcontext *context, ppstream *stream, size_t *psize)
-{
-  iof *I;
-  ppstack *stack;
-  ppobj *obj;
-  stack = &context->stack;
-  ppstack_clear(stack);
-  if ((I = ppstream_read(stream, 1, 0)) == NULL)
-    return NULL;
-  while (ppscan_find(I) >= 0)
-    if ((obj = ppscan_psobj(I, stack)) == NULL)
-      goto error;
-  *psize = stack->size;
-  ppstream_done(stream);
-  return stack->buf;
-error:
-  ppstream_done(stream);
-  return NULL;
-}
-
-/* boxes */
-
-pprect * pparray_to_rect (pparray *array, pprect *rect)
-{
-  ppobj *obj;
-  if (array->size != 4)
-    return NULL;
-  obj = pparray_at(array, 0);
-  if (!ppobj_get_num(obj, rect->lx)) return NULL;
-  obj = pparray_at(array, 1);
-  if (!ppobj_get_num(obj, rect->ly)) return NULL;
-  obj = pparray_at(array, 2);
-  if (!ppobj_get_num(obj, rect->rx)) return NULL;
-  obj = pparray_at(array, 3);
-  if (!ppobj_get_num(obj, rect->ry)) return NULL;
-  return rect;
-}
-
-pprect * ppdict_get_rect (ppdict *dict, const char *name, pprect *rect)
-{
-  pparray *array;
-  return (array = ppdict_rget_array(dict, name)) != NULL ? pparray_to_rect(array, rect) : NULL;
-}
-
-pprect * ppdict_get_box (ppdict *dict, const char *name, pprect *rect)
-{
-  do {
-    if (ppdict_get_rect(dict, name, rect) != NULL)
-      return rect;
-    dict = ppdict_rget_dict(dict, "Parent");
-  } while (dict != NULL);
-  return NULL;
-}
-
-ppmatrix * pparray_to_matrix (pparray *array, ppmatrix *matrix)
-{
-  ppobj *obj;
-  if (array->size != 6)
-    return NULL;
-  obj = pparray_at(array, 0);
-  if (!ppobj_get_num(obj, matrix->xx)) return NULL;
-  obj = pparray_at(array, 1);
-  if (!ppobj_get_num(obj, matrix->xy)) return NULL;
-  obj = pparray_at(array, 2);
-  if (!ppobj_get_num(obj, matrix->yx)) return NULL;
-  obj = pparray_at(array, 3);
-  if (!ppobj_get_num(obj, matrix->yy)) return NULL;
-  obj = pparray_at(array, 4);
-  if (!ppobj_get_num(obj, matrix->x)) return NULL;
-  obj = pparray_at(array, 5);
-  if (!ppobj_get_num(obj, matrix->y)) return NULL;
-  return matrix;
-}
-
-ppmatrix * ppdict_get_matrix (ppdict *dict, const char *name, ppmatrix *matrix)
-{
-  pparray *array;
-  return (array = ppdict_rget_array(dict, name)) != NULL ? pparray_to_matrix(array, matrix) : NULL;
-}
-
-/* logger */
-
-void pplog_callback (pplogger_callback logger, void *alien)
-{
-	logger_callback((logger_function)logger, alien);
-}
-
-int pplog_prefix (const char *prefix)
-{
-	return logger_prefix(prefix);
-}
-
-/* version */
-
-const char * ppdoc_version_string (ppdoc *pdf)
-{
-  return pdf->version;
-}
-
-int ppdoc_version_number (ppdoc *pdf, int *minor)
-{
-  *minor = pdf->version[2] - '0';
-  return pdf->version[0] - '0';
-}
-
-/* doc info */
-
-size_t ppdoc_file_size (ppdoc *pdf)
-{
-  return pdf->filesize;
-}
-
-ppuint ppdoc_objects (ppdoc *pdf)
-{
-  ppuint count;
-  ppxref *xref;
-  for (count = 0, xref = pdf->xref; xref != NULL; xref = xref->prev)
-    count += xref->count;
-  return count;
-}
-
-size_t ppdoc_memory (ppdoc *pdf, size_t *waste)
-{
-  size_t used;
-  ppheap *heap;
-  used = 0, *waste = 0;
-  for (heap = pdf->heap; heap != NULL; heap = heap->prev)
-  {
-    used += heap->space;
-    *waste += heap->size;
-  }
-  return used;
-}
--- texlive-bin.orig/texk/web2c/luatexdir/luapplib/ppload.c.orig
+++ /dev/null
@@ -1,2555 +0,0 @@
-
-#include <utilbasexx.h>
-
-#include "pplib.h"
-
-const char * ppobj_kind[] = { "none", "null", "bool", "integer", "number", "name", "string", "array", "dict", "stream", "ref" };
-
-#define ignored_char(c) (c == 0x20 || c == 0x0A || c == 0x0D || c == 0x09 || c == 0x00)
-#define newline_char(c) (c == 0x0A || c == 0x0D)
-#define IGNORED_CHAR_CASE 0x20: case 0x0A: case 0x0D: case 0x09: case 0x00
-#define NEWLINE_CHAR_CASE 0x0A: case 0x0D
-#define DIGIT_CHAR_CASE '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9'
-#define OCTAL_CHAR_CASE '0': case '1': case '2': case '3': case '4': case '5': case '6': case '7'
-
-#define MAX_INT_DIGITS 32
-
-#define PP_LENGTH_UNKNOWN ((size_t)-1)
-
-static const char * ppref_str (ppuint refnumber, ppuint refversion)
-{
-	static char buffer[MAX_INT_DIGITS + 1 + MAX_INT_DIGITS + 1 + 1 + 1];
-#if defined(MSVC64)|| defined(MINGW64)
-	sprintf(buffer, PPUINTF " " PPUINTF " R", refnumber, refversion);
-#else
-	sprintf(buffer, PPUINTF " " PPUINTF " R", (unsigned long)(refnumber), (unsigned long)(refversion));
-#endif
-	return buffer;
-}
-
-/* name */
-
-// pdf name delimiters: 0..32, ()<>[]{}/%
-// # treated specially
-// .+- are valid part of name; keep in mind names such as -| | |- .notdef ABCDEF+Font etc.
-const char ppname_byte_lookup[] = {
-  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-  0, 1, 1, '#', 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0,
-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1,
-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1,
-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1,
-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
-};
-
-#define PPNAME_INIT (8+1)
-
-#define ppname_flush(O, ghost, siz, flgs) \
-  (iof_put(O, '\0'), \
-   ghost = (_ppname *)ppheap_flush(O, &siz), \
-   ghost->flags = flgs, \
-   ghost->size = siz - sizeof(_ppname) - 1, \
-  (ppname)(ghost + 1))
-
-#define ppname_flush_with_ego(O, ghost, siz, flgs) \
-  (iof_put(O, '\0'), \
-   iof_ensure(O, sizeof(ppname *)), \
-   O->pos += sizeof(ppname *), \
-   ghost = (_ppname *)ppheap_flush(O, &siz), \
-   ghost->flags = flgs, \
-   ghost->size = siz - sizeof(_ppname) - 1 - sizeof(ppname *), \
-  (ppname)(ghost + 1))
-
-#define ppname_set_alter_ego(name, ghost, ego) (*((ppname *)(name + (ghost)->size + 1)) = ego)
-#define ppname_get_alter_ego(name) (*((ppname *)(name + ppname_size(name) + 1)))
-
-static ppname ppscan_name (iof *I, ppheap **pheap)
-{
-  int c, decode;
-  iof *O;
-  _ppname *ghost1, *ghost2;
-  ppname encoded, decoded;
-  size_t size;
-  const char *p, *e;
-  uint8_t v1, v2;
-  O = ppheap_buffer(pheap, sizeof(_ppname), PPNAME_INIT);
-  for (decode = 0, c = iof_char(I); c >= 0 && ppname_byte_lookup[c]; c = iof_next(I))
-  {
-    if (c == '#')
-      decode = 1;
-    iof_put(O, c);
-  }
-  if (!decode)
-    return ppname_flush(O, ghost1, size, 0);
-  encoded = ppname_flush_with_ego(O, ghost1, size, 0|PPNAME_ENCODED);
-  O = ppheap_buffer(pheap, sizeof(_ppname), PPNAME_INIT);
-  for (p = encoded, e = encoded + ghost1->size; p < e; ++p)
-  {
-    if (*p == '#' && p + 2 < e ){
-      v1 = base16_value(p[1]);
-      v2 = base16_value(p[2]);
-      iof_put(O, ((v1<<4)+v2));
-    }else
-      iof_put(O, *p);
-  }
-  decoded = ppname_flush_with_ego(O, ghost2, size, 0|PPNAME_DECODED);
-  ppname_set_alter_ego(encoded, ghost1, decoded);
-  ppname_set_alter_ego(decoded, ghost2, encoded);
-  return encoded;
-}
-
-static ppname ppscan_exec (iof *I, ppheap **pheap, int first)
-{
-  int c, decode;
-  iof *O;
-  _ppname *ghost1, *ghost2;
-  ppname encoded, decoded;
-  size_t size;
-  const char *p, *e;
-  uint8_t v1, v2;
-
-  O = ppheap_buffer(pheap, sizeof(_ppname), PPNAME_INIT);
-  iof_put(O, first);
-  for (decode = 0, c = iof_char(I); c >= 0 && ppname_byte_lookup[c]; c = iof_next(I))
-  {
-    if (c == '#')
-      decode = 1;
-    iof_put(O, c);
-  }
-  if (!decode)
-    return ppname_flush(O, ghost1, size, PPNAME_EXEC);
-  encoded = ppname_flush_with_ego(O, ghost1, size, PPNAME_EXEC|PPNAME_ENCODED);
-  O = ppheap_buffer(pheap, sizeof(_ppname), PPNAME_INIT);
-  for (p = encoded, e = encoded + ghost1->size; p < e; ++p)
-  {
-    if (*p == '#' && p + 2 < e ){
-      v1 = base16_value(p[1]);
-      v2 = base16_value(p[2]);
-      iof_put(O, ((v1<<4)+v2));
-    }else
-      iof_put(O, *p);
-  }
-  decoded = ppname_flush_with_ego(O, ghost2, size, PPNAME_EXEC|PPNAME_DECODED);
-  ppname_set_alter_ego(encoded, ghost1, decoded);
-  ppname_set_alter_ego(decoded, ghost2, encoded);
-  return encoded;
-}
-
-static ppname ppexec_internal (const void *data, size_t size, ppheap **pheap)
-{ // used only for artificial 'EI' operator name
-  iof *O;
-  _ppname *ghost1;
-
-  O = ppheap_buffer(pheap, sizeof(_ppname), size);
-  iof_write(O, data, size);
-  return ppname_flush(O, ghost1, size, PPNAME_EXEC);
-}
-
-ppname ppname_decoded (ppname name)
-{
-  const _ppname *ghost;
-  ghost = _ppname_ghost(name);
-  return (ghost->flags & PPNAME_ENCODED) ? ppname_get_alter_ego(name) : name;
-}
-
-ppname ppname_encoded (ppname name)
-{
-  const _ppname *ghost;
-  ghost = _ppname_ghost(name);
-  return (ghost->flags & PPNAME_DECODED) ? ppname_get_alter_ego(name) : name;
-}
-
-/* string */
-
-#define PPSTRING_INIT (16+1)
-
-#define ppstring_flush(O, ghost, siz, flgs) \
-  (iof_put(O, '\0'), \
-   ghost = (_ppstring *)ppheap_flush(O, &siz), \
-   ghost->flags = flgs, \
-   ghost->size = siz - sizeof(_ppstring) - 1, \
-  (ppstring)(ghost + 1))
-
-#define ppstring_flush_with_ego(O, ghost, siz, flgs) \
-  (iof_put(O, '\0'), \
-   iof_ensure(O, sizeof(ppstring *)), \
-   O->pos += sizeof(ppstring *), \
-   ghost = (_ppstring *)ppheap_flush(O, &siz), \
-   ghost->flags = flgs, \
-   ghost->size = siz - sizeof(_ppstring) - 1 - sizeof(ppstring *), \
-  (ppstring)(ghost + 1))
-
-#define ppstring_utf16be_bom(decoded) (decoded[0] == ((char)0xFE) && decoded[1] == ((char)0xFF) )
-#define ppstring_utf16le_bom(decoded) (decoded[0] == ((char)0xFF) && decoded[1] == ((char)0xFE))
-
-#define ppstring_check_bom(decoded, ghost) ((void)\
-  (ghost->size >= 2 ? (ppstring_utf16be_bom(decoded) ? (ghost->flags |= PPSTRING_UTF16BE) : \
-                      (ppstring_utf16le_bom(decoded) ? (ghost->flags |= PPSTRING_UTF16LE) : 0)) : 0))
-
-#define ppstring_check_bom2(decoded, ghost1, ghost2) ((void)\
-  (ghost2->size >= 2 ? (ppstring_utf16be_bom(decoded) ? ((ghost1->flags |= PPSTRING_UTF16BE), (ghost2->flags |= PPSTRING_UTF16BE)) : \
-                       (ppstring_utf16le_bom(decoded) ? ((ghost1->flags |= PPSTRING_UTF16LE), (ghost2->flags |= PPSTRING_UTF16LE)) : 0)) : 0))
-
-#define ppstring_set_alter_ego(string, ghost, ego) (*((ppstring *)(string + (ghost)->size + 1)) = ego)
-#define ppstring_get_alter_ego(string) (*((ppstring *)(string + ppstring_size(string) + 1)))
-
-static ppstring ppscan_string (iof *I, ppheap **pheap)
-{
-  int c, decode, balance;
-  iof *O;
-  _ppstring *ghost1, *ghost2;
-  uint8_t *p, *e;
-  ppstring encoded, decoded;
-  size_t size;
-  O = ppheap_buffer(pheap, sizeof(_ppstring), PPSTRING_INIT);
-  for (decode = 0, balance = 0, c = iof_char(I); c >= 0; )
-  {
-    switch (c)
-    {
-      case '\\':
-        decode = 1; // unescaping later
-        iof_put(O, '\\');
-        if ((c = iof_next(I)) >= 0)
-        {
-          iof_put(O, c);
-          c = iof_next(I);
-        }
-        break;
-      case '(': // may be unescaped if balanced
-        ++balance;
-        iof_put(O, '(');
-        c = iof_next(I);
-        break;
-      case ')':
-        if (balance == 0)
-        {
-          c = IOFEOF;
-          ++I->pos;
-          break;
-        }
-        --balance;
-        iof_put(O, ')');
-        c = iof_next(I);
-        break;
-      default:
-        iof_put(O, c);
-        c = iof_next(I);
-    }
-  }
-  if (!decode)
-  {
-    encoded = ppstring_flush(O, ghost1, size, 0);
-    ppstring_check_bom(encoded, ghost1); // any bytes can be there
-    return encoded;
-  }
-  encoded = ppstring_flush_with_ego(O, ghost1, size, 0|PPSTRING_ENCODED);
-  O = ppheap_buffer(pheap, sizeof(_ppstring), PPSTRING_INIT);
-  for (p = (uint8_t *)encoded, e = (uint8_t *)encoded + ghost1->size; p < e; ++p)
-  {
-    if (*p == '\\')
-    {
-      if (++p >= e)
-        break;
-      switch (*p)
-      {
-        case OCTAL_CHAR_CASE:
-          c = *p - '0';
-          if (++p < e && *p >= '0' && *p <= '7')
-          {
-            c = (c << 3) + *p - '0';
-            if (++p < e && *p >= '0' && *p <= '7')
-              c = (c << 3) + *p - '0';
-          }
-          iof_put(O, c);
-          break;
-        case 'n':
-          iof_put(O, '\n');
-          break;
-        case 'r':
-          iof_put(O, '\r');
-          break;
-        case 't':
-          iof_put(O, '\t');
-          break;
-        case 'b':
-          iof_put(O, '\b');
-          break;
-        case 'f':
-          iof_put(O, '\f');
-          break;
-        case NEWLINE_CHAR_CASE: // not a part of the string, ignore (pdf spec page 55)
-          break;
-        case '(': case ')': case '\\':
-        default: // for enything else backslash is ignored (pdf spec page 54)
-          iof_put(O, *p);
-          break;
-      }
-    }
-    else
-      iof_put(O, *p);
-  }
-  decoded = ppstring_flush_with_ego(O, ghost2, size, 0|PPSTRING_DECODED);
-  ppstring_check_bom2(decoded, ghost1, ghost2);
-  ppstring_set_alter_ego(encoded, ghost1, decoded);
-  ppstring_set_alter_ego(decoded, ghost2, encoded);
-  return encoded;
-}
-
-/* Hex string may contain white characters. If odd number of digits, the last assumed to be '0' */
-
-static ppstring ppscan_base16 (iof *I, ppheap **pheap)
-{
-  int c, v1, v2;
-  iof *O;
-  _ppstring *ghost1, *ghost2;
-  size_t size;
-  ppstring encoded, decoded;
-  uint8_t *p, *e;
-
-  O = ppheap_buffer(pheap, sizeof(_ppstring), PPSTRING_INIT);
-  for (c = iof_char(I); c >= 0 && (base16_digit(c) || ignored_char(c)); c = iof_next(I))
-    iof_put(O, c);
-  if (c == '>')
-    ++I->pos;
-  encoded = ppstring_flush_with_ego(O, ghost1, size, PPSTRING_BASE16|PPSTRING_ENCODED);
-  O = ppheap_buffer(pheap, sizeof(_ppstring), (ghost1->size >> 1) + 1);
-  for (p = (uint8_t *)encoded, e = (uint8_t *)encoded + ghost1->size; p < e; ++p)
-  {
-    if ((v1 = base16_value(*p)) < 0) // ignored
-      continue;
-    for (v2 = 0, ++p; p < e && (v2 = base16_value(*p)) < 0; ++p);
-    iof_put(O, (v1<<4)|v2);
-  }
-  decoded = ppstring_flush_with_ego(O, ghost2, size, 0|PPSTRING_DECODED);
-  ppstring_check_bom2(decoded, ghost1, ghost2);
-  ppstring_set_alter_ego(encoded, ghost1, decoded);
-  ppstring_set_alter_ego(decoded, ghost2, encoded);
-  return encoded;
-}
-
-/* internal use only; binary string */
-
-static ppstring ppstring_buffer (iof *O, ppheap **pheap)
-{
-   _ppstring *ghost1, *ghost2;
-   ppstring encoded, decoded;
-   uint8_t *p, *e;
-   size_t size;
-
-   decoded = ppstring_flush_with_ego(O, ghost2, size, 0|PPSTRING_DECODED);
-   O = ppheap_buffer(pheap, sizeof(_ppstring), (ghost2->size << 1) + 1);
-   for (p = (uint8_t *)decoded, e = (uint8_t *)decoded + ghost2->size; p < e; ++p)
-     iof_set2(O, base16_uc_alphabet[(*p)>>4], base16_uc_alphabet[(*p)&15]);
-   encoded = ppstring_flush_with_ego(O, ghost1, size, PPSTRING_BASE16|PPSTRING_ENCODED);
-   ppstring_set_alter_ego(encoded, ghost1, decoded);
-   ppstring_set_alter_ego(decoded, ghost2, encoded);
-   return encoded;
-}
-
-ppstring ppstring_internal (const void *data, size_t size, ppheap **pheap)
-{ // so far used only for crypt key
-  iof *O;
-
-  O = ppheap_buffer(pheap, sizeof(_ppstring), size);
-  iof_write(O, data, size);
-  return ppstring_buffer(O, pheap);
-}
-
-/* PDF spec says nothing about base85 strings, but streams might be (afair no leading '<~' but present trailing '~>') */
-
-static ppstring ppscan_base85 (iof *I, ppheap **pheap)
-{ // bawse85 alphabet is 33.117, adobe also hires 'z' and 'y' for compression
-  int c;
-  iof *O, B;
-  _ppstring *ghost1, *ghost2;
-  size_t size;
-  ppstring encoded, decoded;
-  O = ppheap_buffer(pheap, sizeof(_ppstring), PPSTRING_INIT);
-  for (c = iof_char(I); (c >= '!' && c <= 'u') || c == 'z' || c == 'y'; c = iof_next(I))
-    iof_put(O, c);
-  if (c == '~')
-    if ((c = iof_next(I)) == '>')
-      ++I->pos;
-  encoded = ppstring_flush_with_ego(O, ghost1, size, PPSTRING_BASE85|PPSTRING_ENCODED);
-  iof_string_reader(&B, encoded, ghost1->size);
-  O = ppheap_buffer(pheap, sizeof(_ppstring), (ghost1->size * 5 / 4) + 1);
-  base85_decode(&B, O);
-  decoded = ppstring_flush_with_ego(O, ghost2, size, 0|PPSTRING_DECODED);
-  ppstring_check_bom2(decoded, ghost1, ghost2);
-  ppstring_set_alter_ego(encoded, ghost1, decoded);
-  ppstring_set_alter_ego(decoded, ghost2, encoded);
-  return encoded;
-}
-
-/*
-Encrypted strings. In case of encrypted strings, we first need to decode the string (saving original form hardly makes sense),
-then decrypt the string, and encode it again.
-*/
-
-const char ppstring_byte_escape[] = { /* -1 escaped with octal, >0 escaped with \\, 0 left intact*/
- -1,-1,-1,-1,-1,-1,-1,-1,'b','t','n',-1,'f','r',-1,-1,
- -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  0, 0, 0, 0, 0, 0, 0, 0,'(',')', 0, 0, 0, 0, 0, 0,
-  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,'\\', 0, 0, 0,
-  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
- -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
- -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
- -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
- -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
- -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
- -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
- -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
- -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1
-};
-
-
-static ppstring ppscan_crypt_string (iof *I, ppcrypt *crypt, ppheap **pheap)
-{
-  int c, b, balance, encode;
-  iof *O;
-  _ppstring *ghost1, *ghost2;
-  ppstring encoded, decoded;
-  uint8_t *p, *e;
-  size_t size;
-
-  O = ppheap_buffer(pheap, sizeof(_ppstring), PPSTRING_INIT);
-  for (balance = 0, encode = 0, c = iof_char(I); c >= 0; )
-  {
-    switch (c)
-    {
-      case '\\':
-        if ((c = iof_next(I)) < 0)
-          break;
-        encode = 1;
-        switch (c)
-        {
-          case OCTAL_CHAR_CASE:
-            b = c - '0';
-            if ((c = iof_next(I)) >= 0 && c >= '0' && c <= '7')
-            {
-              b = (b << 3) + c - '0';
-              if ((c = iof_next(I)) >= 0 && c >= '0' && c <= '7')
-              {
-                b = (b << 3) + c - '0';
-                c = iof_next(I);
-              }
-            }
-            iof_put(O, b);
-            // c is set to the next char
-            break;
-          case 'n':
-            iof_put(O, '\n');
-            c = iof_next(I);
-            break;
-          case 'r':
-            iof_put(O, '\r');
-            c = iof_next(I);
-            break;
-          case 't':
-            iof_put(O, '\t');
-            c = iof_next(I);
-            break;
-          case 'b':
-            iof_put(O, '\b');
-            c = iof_next(I);
-            break;
-          case 'f':
-            iof_put(O, '\f');
-            c = iof_next(I);
-            break;
-          case NEWLINE_CHAR_CASE: // not a part of the string, ignore (pdf spec page 55)
-            c = iof_next(I);
-            break;
-          case '(': case ')': case '\\':
-          default: // for enything else backslash is ignored (pdf spec page 54)
-            iof_put(O, c);
-            c = iof_next(I);
-            break;
-        }
-        break;
-      case '(':
-        ++balance;
-        encode = 1;
-        iof_put(O, '(');
-        c = iof_next(I);
-        break;
-      case ')':
-        if (balance == 0)
-        {
-          c = IOFEOF;
-          ++I->pos;
-        }
-        else
-        {
-          --balance;
-          //encode = 1;
-          iof_put(O, ')');
-          c = iof_next(I);
-        }
-        break;
-      default:
-        if (ppstring_byte_escape[c] != 0)
-          encode = 1;
-        iof_put(O, c);
-        c = iof_next(I);
-    }
-  }
-  /* decrypt the buffer in place, update size */
-  if (ppstring_decrypt(crypt, O->buf, iof_size(O), O->buf, &size))
-    O->pos = O->buf + size;
-  /* make encoded counterpart */
-  if (!encode)
-  {
-    decoded = ppstring_flush(O, ghost2, size, 0);
-    ppstring_check_bom(decoded, ghost2);
-    return decoded;
-  }
-  decoded = ppstring_flush_with_ego(O, ghost2, size, PPSTRING_DECODED);
-  O = ppheap_buffer(pheap, sizeof(_ppstring), ghost2->size);
-  for (p = (uint8_t *)decoded, e = (uint8_t *)decoded + ghost2->size; p < e; ++p)
-  {
-    switch ((b = ppstring_byte_escape[*p]))
-    {
-      case 0:
-        iof_put(O, *p);
-        break;
-      case -1:
-        iof_put4(O, '\\', (c >> 6) + '0', ((c >> 3) & 7) + '0', (c & 7) + '0');
-        break;
-      default:
-        iof_put2(O, '\\', b);
-        break;
-    }
-  }
-  encoded = ppstring_flush_with_ego(O, ghost1, size, PPSTRING_ENCODED);
-  ppstring_check_bom2(decoded, ghost1, ghost2);
-  ppstring_set_alter_ego(encoded, ghost1, decoded);
-  ppstring_set_alter_ego(decoded, ghost2, encoded);
-  return encoded;
-}
-
-
-static ppstring ppscan_crypt_base16 (iof *I, ppcrypt *crypt, ppheap **pheap)
-{
-  int c, v1, v2;
-  iof *O;
-  _ppstring *ghost1, *ghost2;
-  ppstring encoded, decoded;
-  uint8_t *p, *e;
-  size_t size;
-
-  O = ppheap_buffer(pheap, sizeof(_ppstring), PPSTRING_INIT);
-  // base16_decode(I, O); // no info about the last char..
-  for (c = iof_char(I); c != '>' && c >= 0; )
-  {
-    if ((v1 = base16_value(c)) < 0)
-    {
-      if (ignored_char(c))
-      {
-        c = iof_next(I);
-        continue;
-      }
-      break;
-    }
-    do {
-      c = iof_next(I);
-      if ((v2 = base16_value(c)) >= 0)
-      {
-        c = iof_next(I);
-        break;
-      }
-      if (!ignored_char(c)) // c == '>' || c < 0 or some crap
-      {
-        v2 = 0;
-        break;
-      }
-    } while (1);
-    iof_put(O, (v1 << 4)|v2);
-  }
-  if (c == '>')
-    ++I->pos;
-  /* decrypt the buffer in place, update size */
-  if (ppstring_decrypt(crypt, O->buf, iof_size(O), O->buf, &size))
-    O->pos = O->buf + size;
-  decoded = ppstring_flush_with_ego(O, ghost2, size, PPSTRING_DECODED);
-  /* recreate an encoded form */
-  O = ppheap_buffer(pheap, sizeof(_ppstring), (ghost2->size << 1) + 1);
-  for (p = (uint8_t *)decoded, e = (uint8_t *)decoded + ghost2->size; p < e; ++p)
-    iof_set2(O, base16_uc_alphabet[(*p)>>4], base16_uc_alphabet[(*p)&15]);
-  encoded = ppstring_flush_with_ego(O, ghost1, size, PPSTRING_BASE16|PPSTRING_ENCODED);
-  ppstring_check_bom2(decoded, ghost1, ghost2);
-  ppstring_set_alter_ego(encoded, ghost1, decoded);
-  ppstring_set_alter_ego(decoded, ghost2, encoded);
-  return encoded;
-}
-
-/* ppstring alter ego switcher */
-
-ppstring ppstring_decoded (ppstring string)
-{
-  const _ppstring *ghost;
-  ghost = _ppstring_ghost(string);
-  return (ghost->flags & PPSTRING_ENCODED) ? ppstring_get_alter_ego(string) : string;
-}
-
-ppstring ppstring_encoded (ppstring string)
-{
-  const _ppstring *ghost;
-  ghost = _ppstring_ghost(string);
-  return (ghost->flags & PPSTRING_DECODED) ? ppstring_get_alter_ego(string) : string;
-}
-
-/* scanner stack */
-
-#define PPSTACK_BUFFER 512
-
-static void ppstack_init (ppstack *stack, ppheap **pheap)
-{
-  stack->buf = stack->pos = (ppobj *)pp_malloc(PPSTACK_BUFFER * sizeof(ppobj));
-  stack->size = 0;
-  stack->space = PPSTACK_BUFFER;
-  stack->pheap = pheap;
-}
-
-#define ppstack_free_buffer(stack) (pp_free((stack)->buf))
-
-static void ppstack_resize (ppstack *stack)
-{
-  ppobj *newbuffer;
-  stack->space <<= 1;
-  newbuffer = (ppobj *)pp_malloc(stack->space * sizeof(ppobj));
-  memcpy(newbuffer, stack->buf, stack->size * sizeof(ppobj));
-  ppstack_free_buffer(stack);
-  stack->buf = newbuffer;
-  stack->pos = newbuffer + stack->size;
-}
-
-#define ppstack_push(stack) ((void)((stack)->size < (stack)->space || (ppstack_resize(stack), 0)), ++(stack)->size, (stack)->pos++)
-#define ppstack_pop(stack, n) ((stack)->size -= (n), (stack)->pos -= (n))
-#define ppstack_at(stack, i) ((stack)->buf + i)
-#define ppstack_clear(stack) ((stack)->pos = (stack)->buf, (stack)->size = 0)
-
-/* scanner commons */
-
-#define ppscan_uint(I, u) iof_get_uintlw(I, u)
-#define ppread_uint(s, u) string_to_uintlw((const char *)(s), u)
-
-static ppobj * ppscan_numobj (iof *I, ppobj *obj, int negative)
-{
-  ppint integer;
-  ppnum number;
-  int exponent;
-  int c;
-  c = iof_char(I);
-  iof_scan_integer(I, c, integer);
-  switch(c)
-  {
-    case '.':
-    {
-      number = (ppnum)integer;
-      c = iof_next(I);
-      iof_scan_fraction(I, c, number, exponent);
-      double_negative_exp10(number, exponent);
-      obj->type = PPNUM, obj->number = negative ? -number : number;
-      break;
-    }
-    default:
-      obj->type = PPINT, obj->integer = negative ? -integer : integer;
-      break;
-  }
-  return obj;
-}
-
-static ppobj * ppscan_numobj_frac (iof *I, ppobj *obj, int negative)
-{
-  ppnum number;
-  int c, exponent;
-
-  number = 0.0;
-  c = iof_next(I);
-  iof_scan_fraction(I, c, number, exponent);
-  double_negative_exp10(number, exponent);
-  obj->type = PPNUM, obj->number = negative ? -number : number;
-  return obj;
-}
-
-static int ppscan_find (iof *I)
-{ // skips whitechars and comments
-  int c;
-  for (c = iof_char(I); ; c = iof_next(I))
-  {
-    switch (c)
-    {
-      case IGNORED_CHAR_CASE:
-        break;
-      case '%': {
-        do {
-          if ((c = iof_next(I)) < 0)
-            return c;
-        } while (!newline_char(c));
-        break;
-      }
-      default:
-        return c;
-    }
-  }
-  return c; // never reached
-}
-
-static int ppscan_keyword (iof *I, const char *keyword, size_t size)
-{
-  size_t i;
-  int c;
-  if (iof_left(I) >= size)
-  {
-    if (memcmp(I->pos, keyword, size) != 0)
-      return 0;
-    I->pos += size;
-    return 1;
-  }
-  // sticky case, we can't go back
-  for (i = 0, c = iof_char(I); i < size; ++i, ++keyword, c = iof_next(I))
-    if (i != c)
-      return 0;
-  return 1;
-}
-
-#define ppscan_key(I, literal) ppscan_keyword(I, "" literal, sizeof(literal) - 1)
-
-/* objects parser */
-
-static ppref * ppref_unresolved (ppheap **pheap, ppuint refnumber, ppuint refversion)
-{
-  ppref *ref = (ppref *)ppheap_take(pheap, sizeof(ppref));
-  memset(ref, 0, sizeof(ppref));
-  ref->object.type = PPNONE;
-  ref->number = refnumber;
-  ref->version = refversion;
-  return ref;
-}
-
-#define PPMARK PPNONE
-
-static ppobj * ppscan_obj (iof *I, ppdoc *pdf, ppxref *xref)
-{
-  int c;
-  ppobj *obj;
-  size_t mark, size;
-  ppuint refnumber, refversion;
-  ppref *ref;
-  ppstack *stack;
-  ppcrypt *crypt;
-
-  stack = &pdf->stack;
-  c = iof_char(I);
-  switch (c)
-  {
-    case DIGIT_CHAR_CASE:
-      return ppscan_numobj(I, ppstack_push(stack), 0);
-    case '.':
-      return ppscan_numobj_frac(I, ppstack_push(stack), 0);
-    case '+':
-      ++I->pos;
-      return ppscan_numobj(I, ppstack_push(stack), 0);
-    case '-':
-      ++I->pos;
-      return ppscan_numobj(I, ppstack_push(stack), 1);
-    case '/':
-      ++I->pos;
-      obj = ppstack_push(stack);
-      obj->type = PPNAME;
-      obj->name = ppscan_name(I, &pdf->heap);
-      return obj;
-    case '(':
-      ++I->pos;
-      obj = ppstack_push(stack);
-      obj->type = PPSTRING;
-      if (ppcrypt_ref(pdf, crypt))
-        obj->string = ppscan_crypt_string(I, crypt, &pdf->heap);
-      else
-        obj->string = ppscan_string(I, &pdf->heap);
-      return obj;
-    case '[':
-      mark = stack->size;
-      obj = ppstack_push(stack);
-      obj->type = PPMARK; // ppscan_obj() checks types backward for 'R', so set the type immediatelly (reserved for PPARRAY)
-      obj->any = NULL;
-      ++I->pos;
-      for (c = ppscan_find(I); c != ']'; c = ppscan_find(I))
-      {
-        if (ppscan_obj(I, pdf, xref) == NULL)
-        { // callers assume that NULL returns means nothing pushed
-          size = stack->size - mark; // pop items AND the obj reserved for array
-          ppstack_pop(stack, size);
-          return NULL;
-        }
-      }
-      ++I->pos;
-      size = stack->size - mark - 1;
-      obj = ppstack_at(stack, mark); // stack might have been realocated
-      obj->type = PPARRAY;
-      obj->array = pparray_create(ppstack_at(stack, mark + 1), size, &pdf->heap);
-      ppstack_pop(stack, size); // pop array items, leave the array on top
-      return obj;
-    case '<':
-      if ((c = iof_next(I)) == '<')
-      {
-        mark = stack->size;
-        obj = ppstack_push(stack);
-        obj->type = PPMARK;
-        obj->any = NULL;
-        ++I->pos;
-        for (c = ppscan_find(I); c != '>'; c = ppscan_find(I))
-        {
-          if (ppscan_obj(I, pdf, xref) == NULL)
-          {
-            size = stack->size - mark;
-            ppstack_pop(stack, size);
-            return NULL;
-          }
-        }
-        if (iof_next(I) == '>')
-          ++I->pos;
-        size = stack->size - mark - 1;
-        obj = ppstack_at(stack, mark);
-        obj->type = PPDICT;
-        obj->dict = ppdict_create(ppstack_at(stack, mark + 1), size, &pdf->heap);
-        ppstack_pop(stack, size);
-        return obj;
-      }
-      obj = ppstack_push(stack);
-      obj->type = PPSTRING;
-      if (ppcrypt_ref(pdf, crypt))
-        obj->string = ppscan_crypt_base16(I, crypt, &pdf->heap);
-      else
-        obj->string = ppscan_base16(I, &pdf->heap);
-      return obj;
-    case 'R':
-      if (stack->size >= 2 && stack->pos[-1].type == PPINT && stack->pos[-2].type == PPINT)
-      {
-        ++I->pos;
-        obj = &stack->pos[-2];
-        refnumber = (ppuint)obj->integer;
-        ppstack_pop(stack, 1); // pop version number, retype obj to a reference
-        if (xref == NULL || (ref = ppxref_find(xref, refnumber)) == NULL)
-        { /* pdf spec page 64: unresolvable reference is not an error, should just be treated as a reference to null.
-             we also need this to read trailer, where refs can't be resolved yet */
-          refversion = (obj + 1)->integer;
-          //if (xref != NULL)
-          //  loggerf("unresolved reference %s", ppref_str(refnumber, refversion));
-          ref = ppref_unresolved(stack->pheap, refnumber, refversion);
-        }
-        obj->type = PPREF;
-        obj->ref = ref;
-        return obj;
-      }
-      break;
-    case 't':
-      if (iof_next(I) == 'r' && iof_next(I) == 'u' && iof_next(I) == 'e')
-      {
-        ++I->pos;
-        obj = ppstack_push(stack);
-        obj->type = PPBOOL;
-        obj->integer = 1;
-        return obj;
-      }
-      break;
-    case 'f':
-      if (iof_next(I) == 'a' && iof_next(I) == 'l' && iof_next(I) == 's' && iof_next(I) == 'e')
-      {
-        ++I->pos;
-        obj = ppstack_push(stack);
-        obj->type = PPBOOL;
-        obj->integer = 0;
-        return obj;
-      }
-      break;
-    case 'n':
-      if (iof_next(I) == 'u' && iof_next(I) == 'l' && iof_next(I) == 'l')
-      {
-        ++I->pos;
-        obj = ppstack_push(stack);
-        obj->type = PPNULL;
-        obj->any = NULL;
-        return obj;
-      }
-      break;
-  }
-  return NULL;
-}
-
-/*
-A variant for contents streams (aka postscript); wise of operators, blind to references.
-We are still PDF, so we don't care about postscript specific stuff such as radix numbers
-and scientific numbers notation. It takes ppstack * as context (no ppdoc *) to be able
-to run contents parser beyond the scope of ppdoc heap.
-*/
-
-static ppstring ppstring_inline (iof *I, ppdict *imagedict, ppheap **pheap);
-
-static ppobj * ppscan_psobj (iof *I, ppstack *stack)
-{
-  int c;
-  ppobj *obj, *op;
-  size_t size, mark;
-  ppname exec;
-
-  c = iof_char(I);
-  switch (c)
-  {
-    case DIGIT_CHAR_CASE:
-      return ppscan_numobj(I, ppstack_push(stack), 0);
-    case '.':
-      return ppscan_numobj_frac(I, ppstack_push(stack), 0);
-    case '+':
-      c = iof_next(I);
-      if (base10_digit(c)) // '+.abc' is probably an executable name, but we are not in postscript
-        return ppscan_numobj(I, ppstack_push(stack), 0);
-      else if (c == '.')
-        return ppscan_numobj_frac(I, ppstack_push(stack), 0);
-      obj = ppstack_push(stack);
-      obj->type = PPNAME;
-      obj->name = ppscan_exec(I, stack->pheap, '+');
-      return obj;
-    case '-':
-      c = iof_next(I);
-      if (base10_digit(c)) // ditto, we would handle type1 '-|' '|-' operators though
-        return ppscan_numobj(I, ppstack_push(stack), 1);
-      else if (c == '.')
-        return ppscan_numobj_frac(I, ppstack_push(stack), 1);
-      obj = ppstack_push(stack);
-      obj->type = PPNAME;
-      obj->name = ppscan_exec(I, stack->pheap, '-');
-      return obj;
-    case '/':
-      ++I->pos;
-      obj = ppstack_push(stack);
-      obj->type = PPNAME;
-      obj->name = ppscan_name(I, stack->pheap);
-      return obj;
-    case '(':
-      ++I->pos;
-      obj = ppstack_push(stack);
-      obj->type = PPSTRING;
-      obj->string = ppscan_string(I, stack->pheap);
-      return obj;
-    case '[':
-      mark = stack->size;
-      obj = ppstack_push(stack);
-      obj->type = PPMARK;
-      obj->any = NULL;
-      ++I->pos;
-      for (c = ppscan_find(I); c != ']'; c = ppscan_find(I))
-      {
-        if (ppscan_psobj(I, stack) == NULL)
-        {
-          size = stack->size - mark;
-          ppstack_pop(stack, size);
-          return NULL;
-        }
-      }
-      ++I->pos;
-      size = stack->size - mark - 1;
-      obj = ppstack_at(stack, mark);
-      obj->type = PPARRAY;
-      obj->array = pparray_create(ppstack_at(stack, mark + 1), size, stack->pheap);
-      ppstack_pop(stack, size);
-      return obj;
-    case '<':
-      if ((c = iof_next(I)) == '<')
-      {
-        mark = stack->size;
-        obj = ppstack_push(stack);
-        obj->type = PPMARK;
-        obj->any = NULL;
-        ++I->pos;
-        for (c = ppscan_find(I); c != '>'; c = ppscan_find(I))
-        {
-          if (ppscan_psobj(I, stack) == NULL)
-          {
-            size = stack->size - mark;
-            ppstack_pop(stack, size);
-            return NULL;
-          }
-        }
-        if (iof_next(I) == '>')
-          ++I->pos;
-        size = stack->size - mark - 1;
-        obj = ppstack_at(stack, mark);
-        obj->type = PPDICT;
-        obj->dict = ppdict_create(ppstack_at(stack, mark + 1), size, stack->pheap);
-        ppstack_pop(stack, size);
-        return obj;
-      }
-      obj = ppstack_push(stack);
-      obj->type = PPSTRING;
-      if (c == '~')
-        ++I->pos, obj->string = ppscan_base85(I, stack->pheap);
-      else
-        obj->string = ppscan_base16(I, stack->pheap);
-      return obj;
-    default:
-      if (c < 0 || !ppname_byte_lookup[c])
-        break; // forbid empty names; dead loop otherwise
-      ++I->pos;
-      /* true false null practically don't occur in streams so it makes sense to assume that we get an operator name here.
-         If it happen to be a keyword we could give back those several bytes to the heap but.. heap buffer is tricky enough. */
-      exec = ppscan_exec(I, stack->pheap, c);
-      obj = ppstack_push(stack);
-      switch (exec[0])
-      {
-        case 't':
-          if (exec[1] == 'r' && exec[2] == 'u' && exec[3] == 'e' && exec[4] == '\0')
-          {
-            obj->type = PPBOOL;
-            obj->integer = 1;
-            // todo: drop exec
-            return obj;
-          }
-          break;
-        case 'f':
-          if (exec[1] == 'a' && exec[2] == 'l' && exec[3] == 's' && exec[4] == 'e' && exec[5] == '\0')
-          {
-            obj->type = PPBOOL;
-            obj->integer = 0;
-            // todo: drop exec
-            return obj;
-          }
-          break;
-        case 'n':
-          if (exec[1] == 'u' && exec[2] == 'l' && exec[3] == 'l' && exec[4] == '\0')
-          {
-            obj->type = PPNULL;
-            obj->any = NULL;
-            // todo: drop exec
-            return obj;
-          }
-          break;
-        case 'B':
-           /*
-           Inline images break rules of operand/operator syntax, so 'BI/ID' operators need to be treated as special syntactic keywords.
-
-             BI <keyval pairs> ID<whitechar?><imagedata><whitechar?>EI
-
-           We treat the image as a single syntactic token; BI starts collecting a dict, ID is the beginning of the data. Effectively EI
-           operator obtains two operands - dict and string. It is ok to put three items onto the stack, callers dont't assume there is just one.
-           */
-          if (exec[1] == 'I' && exec[2] == '\0')
-          {
-            ppdict *imagedict;
-            /* key val pairs -> dict */
-            mark = stack->size - 1;
-            obj->type = PPMARK;
-            obj->any = NULL;
-            for (c = ppscan_find(I); ; c = ppscan_find(I))
-            {
-              if ((op = ppscan_psobj(I, stack)) == NULL)
-              {
-                size = stack->size - mark;
-                ppstack_pop(stack, size);
-                return NULL;
-              }
-              if (op->type == PPNAME && ppname_exec(op->name))
-              {
-                if (!ppname_is(op->name, "ID"))
-                { // weird
-                  size = stack->size - mark;
-                  ppstack_pop(stack, size);
-                  return NULL;
-                }
-                break;
-              }
-            }
-            size = stack->size - mark - 1;
-            obj = ppstack_at(stack, mark);
-            obj->type = PPDICT;
-            obj->dict = imagedict = ppdict_create(ppstack_at(stack, mark + 1), size, stack->pheap);
-            ppstack_pop(stack, size);
-            /* put image data string */
-            obj = ppstack_push(stack);
-            obj->type = PPSTRING;
-            obj->string = ppstring_inline(I, imagedict, stack->pheap);;
-            /* put EI operator name */
-            obj = ppstack_push(stack);
-            obj->type = PPNAME;
-            obj->name = ppexec_internal("EI", 2, stack->pheap);
-            return obj;
-          }
-      }
-      obj->type = PPNAME;
-      obj->name = exec;
-      return obj;
-  }
-  return NULL;
-}
-
-/*
-We try to get the exact inline image length from its dict params. If cannot predict the length, we have to scan the input until 'EI'.
-I've checked on may examples that it gives the same results but one can never be sure, as 'EI' might happen to be a part of the data.
-Stripping white char is also very heuristic; \0 is a white char in PDF and very likely to be a data byte.. weak method.
-*/
-
-static size_t inline_image_length (ppdict *dict)
-{
-  ppuint w, h, bpc, colors;
-  ppname cs;
-
-  if (ppdict_get_uint(dict, "W", &w) && ppdict_get_uint(dict, "H", &h) && ppdict_get_uint(dict, "BPC", &bpc) && (cs = ppdict_get_name(dict, "CS")) != NULL)
-  {
-    if (ppname_is(cs, "DeviceGray"))
-      colors = 1;
-    else if (ppname_is(cs, "DeviceRGB"))
-      colors = 3;
-    else if (ppname_is(cs, "DeviceCMYK"))
-      colors = 4;
-    else
-      return PP_LENGTH_UNKNOWN;
-    return (w * h * bpc * colors + 7) >> 3;
-  }
-  return PP_LENGTH_UNKNOWN;
-}
-
-static ppstring ppstring_inline (iof *I, ppdict *imagedict, ppheap **pheap)
-{
-  iof *O;
-  int c, d, e;
-  size_t length, leftin, leftout, bytes;
-
-  O = ppheap_buffer(pheap, sizeof(_ppstring), PPSTRING_INIT);
-  c = iof_char(I);
-  if (ignored_char(c))
-    c = iof_next(I);
-
-  length = inline_image_length(imagedict);
-  if (length != PP_LENGTH_UNKNOWN)
-  {
-    while (length > 0 && iof_readable(I) && iof_writable(O))
-    {
-      leftin = iof_left(I);
-      leftout = iof_left(O);
-      bytes = length;
-      if (bytes > leftin) bytes = leftin;
-      if (bytes > leftout) bytes = leftout;
-      memcpy(O->pos, I->pos, bytes);
-      I->pos += bytes;
-      O->pos += bytes;
-      length -= bytes;
-    }
-    // gobble EI
-    if (ppscan_find(I) == 'E')
-      if (iof_next(I) == 'I')
-        ++I->pos;
-  }
-  else
-  {
-    while (c >= 0)
-    {
-      if (c == 'E')
-      {
-        d = iof_next(I);
-        if (d == 'I')
-        {
-          e = iof_next(I);
-          if (!ppname_byte_lookup[e])
-          { /* strip one newline from the end and stop */
-            if (O->pos - 2 >= O->buf) // sanity
-            {
-              c = *(O->pos - 1);
-              if (ignored_char(c))
-              {
-                if (c == 0x0A && *(O->pos - 2) == 0x0D)
-                  O->pos -= 2;
-                else
-                  O->pos -= 1;
-              }
-            }
-            break;
-          }
-          iof_put2(O, c, d);
-          c = e;
-        }
-        else
-        {
-          iof_put(O, c);
-          c = d;
-        }
-      }
-      else
-      {
-        iof_put(O, c);
-        c = iof_next(I);
-      }
-    }
-  }
-  return ppstring_buffer(O, pheap);
-}
-
-/* input reader */
-
-/*
-PDF input is a pseudo file that either keeps FILE * or data. Reader iof * is a proxy to input
-that provides byte-by-byte interface. Our iof structure is capable to link iof_file *input,
-but t avoid redundant checks on IOF_DATA flag, here we link iof *I directly to FILE * or mem buffer.
-When reading from file we need an internal buffer, which should be kept rather small, as it is
-only used to parse xrefs and objects (no streams). We allocate the buffer from a private heap
-(not static) to avoid conflicts when processing >1 pdfs at once. Besides, the input buffer may be
-needed after loading the document, eg. to access references raw data.
-*/
-
-#define PPDOC_BUFFER 0xFFF // keep that small, it is only used to parse body objects
-
-static void ppdoc_reader_init (ppdoc *pdf, iof_file *input)
-{
-  iof *I;
-  pdf->input = *input;
-  input = &pdf->input;
-  input->refcount = 1;
-  I = &pdf->reader;
-  if (input->flags & IOF_DATA)
-  {
-    pdf->buffer = NULL;            // input iof_file is the buffer
-    iof_string_reader(I, NULL, 0); // gets IOF_DATA flag
-  }
-  else
-  {
-    pdf->buffer = (uint8_t *)ppheap_take(&pdf->heap, PPDOC_BUFFER);
-    iof_setup_file_handle_reader(I, NULL, 0, iof_file_get_fh(input)); // gets IOF_FILE_HANDLE flag and FILE *
-    I->space = PPDOC_BUFFER; // used on refill
-  }
-}
-
-/*
-Whenever we need to read the input file, we fseek the to the given offset and fread to to the private buffer.
-The length we need is not always predictable, in which case PPDOC_BUFFER bytes are read (keep it small).
-I->buf = I->pos is set to the beginning, I->end set to the end (end is the first byte one shouldn't read).
-*/
-
-static iof * ppdoc_reader (ppdoc *pdf, size_t offset, size_t length)
-{
-  iof_file *input;
-  iof *I;
-  input = &pdf->input;
-  I = &pdf->reader;
-  if (iof_file_seek(input, offset, SEEK_SET) != 0)
-    return NULL;
-  I->flags &= ~IOF_STOPPED;
-  if (input->flags & IOF_DATA)
-  {
-    I->buf = I->pos = input->pos;
-    I->end = (length == PP_LENGTH_UNKNOWN || I->pos + length >= input->end) ? input->end : (I->pos + length);
-  }
-  else
-  {
-    I->buf = I->pos = pdf->buffer; // ->buf is actually permanently equal pdf->buffer but we might need some tricks
-    if (length == PP_LENGTH_UNKNOWN || length > PPDOC_BUFFER)
-      length = PPDOC_BUFFER;
-    length = fread(I->buf, 1, length, I->file);
-    I->end = I->buf + length;
-  }
-  return I;
-}
-
-/* The position from the beginning of input
-- for data buffer: (pdf->input.pos - pdf->input.buf) + (I->pos - I->buf)
-  I->buf == pdf->input.pos, so this resolves to (I->pos - pdf->input.buf), independent from I->buf
-- for file buffer: ftell(pdf->input.file) - (I->end - I->pos)
-*/
-
-#define ppdoc_reader_tell(pdf, I) ((size_t)(((pdf)->input.flags & IOF_DATA) ? ((I)->pos - (pdf)->input.buf) : (ftell(iof_file_get_fh(&(pdf)->input)) - ((I)->end - (I)->pos))))
-
-/* pdf */
-
-#define PPDOC_HEADER 10 // "%PDF-?.??\n"
-
-static int ppdoc_header (ppdoc *pdf, uint8_t header[PPDOC_HEADER])
-{
-  size_t i;
-  if (memcmp(header, "%PDF-", 5) != 0)
-    return 0;
-  for (i = 5; i < PPDOC_HEADER - 1 && !ignored_char(header[i]); ++i)
-    pdf->version[i - 5] = header[i];
-  pdf->version[i - 5] = '\0';
-  return 1;
-}
-
-static int ppdoc_tail (ppdoc *pdf, iof_file *input, size_t *pxrefoffset)
-{
-  int c;
-  uint8_t tail[4*10], *p, back, tailbytes;
-
-  if (iof_file_seek(input, 0, SEEK_END) != 0)
-    return 0;
-  pdf->filesize = (size_t)iof_file_tell(input);
-  // simple heuristic to avoif fgetc() / fseek(-2) hiccup: keep seeking back by len(startxref) + 1 == 10
-  // until a letter found (assuming liberal white characters and tail length)
-  for (back = 1, tailbytes = 0; ; ++back)
-  {
-    if (iof_file_seek(input, -10, SEEK_CUR) != 0)
-      return 0;
-    tailbytes += 10;
-    c = iof_file_getc(input);
-    tailbytes -= 1;
-    switch (c)
-    {
-      case IGNORED_CHAR_CASE:
-      case DIGIT_CHAR_CASE:
-      case '%': case 'E': case 'O': case 'F':
-        if (back > 4) // 2 should be enough
-          return 0;
-        continue;
-      case 's': case 't': case 'a': case 'r': case 'x': case 'e': case 'f':
-        if (iof_file_read(tail, 1, tailbytes, input) != tailbytes)
-          return 0;
-        tail[tailbytes] = '\0';
-        for (p = &tail[0]; ; ++p)
-        {
-          if (*p == '\0')
-            return 0;
-          if ((c = base10_value(*p)) >= 0)
-            break;
-        }
-        ppread_uint(p, pxrefoffset);
-        return 1;
-      default:
-        return 0;
-    }
-  }
-  return 0;
-}
-
-/* xref/body */
-
-static int ppscan_start_entry (iof *I, ppref *ref)
-{
-  ppuint u;
-  ppscan_find(I); if (!ppscan_uint(I, &u) || u != ref->number) return 0;
-  ppscan_find(I); if (!ppscan_uint(I, &u) || u != ref->version) return 0;
-  ppscan_find(I); if (!ppscan_key(I, "obj")) return 0;
-  ppscan_find(I);
-  return 1;
-}
-
-static int ppscan_skip_entry (iof *I)
-{
-  size_t u;
-  ppscan_find(I); if (!ppscan_uint(I, &u)) return 0;
-  ppscan_find(I); if (!ppscan_uint(I, &u)) return 0;
-  ppscan_find(I); if (!ppscan_key(I, "obj")) return 0;
-  ppscan_find(I);
-  return 1;
-}
-
-static int ppscan_start_stream (iof *I, ppdoc *pdf, size_t *streamoffset)
-{
-  int c;
-  ppscan_find(I);
-  if (ppscan_key(I, "stream"))
-  { // skip 1 or 2 whites (here we shouldn't just gobble all blanks)
-    c = iof_char(I);
-    if (ignored_char(c))
-    {
-      c = iof_next(I);
-      if (ignored_char(c))
-        ++I->pos;
-    }
-    *streamoffset = ppdoc_reader_tell(pdf, I);
-    return 1;
-  }
-  return 0;
-}
-
-static ppxref * ppxref_load (ppdoc *pdf, size_t xrefoffset);
-static ppxref * ppxref_load_chain (ppdoc *pdf, ppxref *xref);
-
-/* Parsing xref table
-
-  1 10               // first ref number and refs count
-  0000000000 00000 n // 10-digits offset, 5 digits version, type identifier
-  0000000000 00000 n // n states for normal I guess
-  0000000000 00000 f // f states for free (not used)
-  ...
-
-Free entries seem to be a relic of ancient times, completelly useless for us. To avoid parsing xref table twice,
-we waste some space on free entries by allocating one plane of refs for each section. Later on we slice sections,
-so that effectively free entries are not involved in map.
-
-Subsequent refs gets number, version and offset. Other fields initialized when parsing PDF body.
-
-Having xref table loaded, we sort sections for future binary search (xref with objects count == 0 is considered invalid).
-
-Then we have to deal with the trailer dict. In general, to load objects and resolve references we need a complete chain
-of xrefs (not only the top). To load the previous xref, we need its offset, which is given in trailer. So we have to
-parse the trailer ignoring references, which might be unresolvable at this point (objects parser makes a dummy check
-for xref != NULL on refs resolving ppscan_obj(), which irritates me but I don't want a separate parser for trailer..).
-The same applies to xref streams, in which we have parse the trailer not having xref map at all. So the procedure is:
-
-  - load xref map, initialize references, make it ready to search
-  - parse trailer ignoring references
-  - get /Prev xref offset and load older xref (linked list via ->prev)
-  - sort all refs in all xrefs by offset
-  - parse refs in order resolving references in contained objects
-  - fix trailer references
-
-First created xref becomes a pdf->xref (top xref). We link that early to control offsets already read (insane loops?).
-*/
-
-// Every xref table item "0000000000 00000 n" is said to be terminated with 2-byte EOL but we don't like relying on whites.
-#define xref_item_length (10+1+5+1+1)
-
-static ppxref * ppxref_load_table (iof *I, ppdoc *pdf, size_t xrefoffset)
-{
-  ppxref *xref;
-  ppxsec *xrefsection;
-  ppref *ref;
-  ppuint first, count, refindex;
-  uint8_t buffer[xref_item_length + 1];
-  const char *p;
-  const ppobj *obj;
-
-  buffer[xref_item_length] = '\0';
-  xref = ppxref_create(pdf, 0, xrefoffset);
-  if (pdf->xref == NULL) pdf->xref = xref;
-  for (ppscan_find(I); ppscan_uint(I, &first); ppscan_find(I))
-  {
-    ppscan_find(I);
-    if (!ppscan_uint(I, &count))
-      return NULL;
-    if (count == 0) // weird
-      continue;
-    xref->count += count;
-    xrefsection = NULL;
-    ref = (ppref *)ppheap_take(&pdf->heap, count * sizeof(ppref));
-    for (refindex = 0; refindex < count; ++refindex, ++ref)
-    {
-      ref->xref = xref;
-      ref->number = first + refindex;
-      ppscan_find(I);
-      iof_read(I, buffer, xref_item_length);
-      switch (buffer[xref_item_length - 1])
-      {
-        case 'n':
-          if (xrefsection == NULL)
-          {
-            xrefsection = ppxref_push_section(xref, &pdf->heap);
-            xrefsection->first = ref->number;
-            xrefsection->refs = ref;
-          }
-          xrefsection->last = ref->number;
-          for (p = (const char *)buffer; *p == '0'; ++p);
-          p = ppread_uint(p, &ref->offset);
-          for ( ; *p == ' ' || *p == '0'; ++p);
-          p = ppread_uint(p, &ref->version);
-          ref->object.type = PPNONE; // init for sanity
-          ref->object.any = NULL;
-          ref->length = 0;
-          break;
-        case 'f':
-        default:
-          --ref;
-          xrefsection = NULL;
-          --xref->count;
-      }
-    }
-  }
-  /* sort section */
-  if (!ppxref_sort(xref))
-    ; // case of xref->size == 0 handled by ppxref_load_chain()
-  /* get trailer ignoring refs */
-  if (!ppscan_key(I, "trailer"))
-    return NULL;
-  ppscan_find(I);
-  if ((obj = ppscan_obj(I, pdf, NULL)) == NULL)
-    return NULL;
-  ppstack_pop(&pdf->stack, 1);
-  if (obj->type != PPDICT)
-    return NULL;
-  xref->trailer = *obj;
-  return ppxref_load_chain(pdf, xref);
-}
-
-/* Parsing xref stream
-First we load the trailer, ignoring references. Dict defines sections and fields lengths:
-
-  /Size                                  % max ref number plus 1
-  /Index [ first count first count ... ] % a pair of numbers for every section, defaults to [0 Size]
-  /W [w1 w2 w3]                          % fields lengths, 0 states for omitted field
-
-xref stream data is a continuous stream of binary number triplets. First number is a type:
-
-  0 - free entry (as 'f' in xref table)
-  1 - normal entry, followed by offset an version (as 'n' in xref table)
-  2 - compressed entry, followed by parent object stream number and entry index
-
-0 and 1 are handled as 'n' and 'f' entries in xref table. For type 2 we normally initialize
-ref->number and ref->version (the later is implicitly 0). ref->offset is set to 0 (invalid offset),
-which is recognized by objects loader.
-*/
-
-#define XREF_STREAM_MAX_FIELD 4
-
-static ppxref * ppxref_load_stream (iof *I, ppdoc *pdf, size_t xrefoffset)
-{
-  ppxref *xref;
-  ppxsec *xrefsection;
-  ppref *ref;
-  ppobj *obj;
-  ppstream *xrefstream;
-  size_t streamoffset;
-  ppuint w1, w2, w3, w, bufferbytes;
-  uint8_t buffer[3 * XREF_STREAM_MAX_FIELD], *b;
-  ppuint first, count, f1, f2, f3;
-  pparray *fieldwidths, *sectionindices;
-  ppobj sectionmock[2], *sectionfirst, *sectioncount;
-  size_t sections, sectionindex, refindex;
-
-  if (!ppscan_skip_entry(I))
-    return NULL;
-  if ((obj = ppscan_obj(I, pdf, NULL)) == NULL)
-    return NULL;
-  ppstack_pop(&pdf->stack, 1);
-  if (obj->type != PPDICT || !ppscan_start_stream(I, pdf, &streamoffset))
-    return NULL;
-  xrefstream = ppstream_create(pdf, obj->dict, streamoffset);
-  /* All normal streams go through ppstream_info(), but it makes no sense for trailer stream (no crypt allowed, no refs yet).
-     So we just record the length and informative flag. Here we have to expect that /Length and /Filter are not indirects. */
-  if (!ppdict_get_uint(obj->dict, "Length", &xrefstream->length))
-    return NULL;
-  if (ppdict_get_obj(obj->dict, "Filter") != NULL)
-    xrefstream->flags |= PPSTREAM_COMPRESSED;
-  if ((fieldwidths = ppdict_get_array(xrefstream->dict, "W")) != NULL)
-  {
-    if (!pparray_get_uint(fieldwidths, 0, &w1)) w1 = 0;
-    if (!pparray_get_uint(fieldwidths, 1, &w2)) w2 = 0;
-    if (!pparray_get_uint(fieldwidths, 2, &w3)) w3 = 0;
-  }
-  else
-    w1 = w2 = w3 = 0;
-  if (w1 > XREF_STREAM_MAX_FIELD || w2 > XREF_STREAM_MAX_FIELD || w3 > XREF_STREAM_MAX_FIELD)
-    return NULL;
-  bufferbytes = w1 + w2 + w3;
-  if ((sectionindices = ppdict_get_array(xrefstream->dict, "Index")) != NULL)
-  {
-    sections = sectionindices->size >> 1;
-    sectionfirst = sectionindices->data;
-  }
-  else
-  {
-    sections = 1;
-    sectionmock[0].type = PPINT;
-    sectionmock[0].integer = 0;
-    sectionmock[1].type = PPINT;
-    if (!ppdict_get_int(xrefstream->dict, "Size", &sectionmock[1].integer))
-      sectionmock[1].integer = 0;
-    sectionfirst = &sectionmock[0];
-  }
-  if ((I = ppstream_read(xrefstream, 1, 0)) == NULL)
-    return NULL; // we fseek() so original I is useless anyway
-  xref = ppxref_create(pdf, sections, xrefoffset);
-  if (pdf->xref == NULL) pdf->xref = xref;
-  xref->trailer.type = PPSTREAM;
-  xref->trailer.stream = xrefstream;
-  for (sectionindex = 0; sectionindex < sections; ++sectionindex, sectionfirst += 2)
-  {
-    sectioncount = sectionfirst + 1;
-    if (!ppobj_get_uint(sectionfirst, first) || !ppobj_get_uint(sectioncount, count))
-      goto xref_stream_error;
-    if (count == 0)
-      continue;
-    xref->count += count;
-    xrefsection = NULL;
-    ref = (ppref *)ppheap_take(&pdf->heap, count * sizeof(ppref));
-    for (refindex = 0; refindex < count; ++refindex, ++ref)
-    {
-      ref->xref = xref;
-      ref->number = first + refindex;
-      if (iof_read(I, buffer, bufferbytes) != bufferbytes)
-        goto xref_stream_error;
-      b = buffer;
-      if (w1 == 0)
-        f1 = 1; // default type is 1
-      else
-        for (f1 = 0, w = 0; w < w1; f1 = (f1 << 8)|(*b), ++w, ++b);
-      for (f2 = 0, w = 0; w < w2; f2 = (f2 << 8)|(*b), ++w, ++b);
-      for (f3 = 0, w = 0; w < w3; f3 = (f3 << 8)|(*b), ++w, ++b);
-      switch (f1)
-      {
-        case 0:
-          //--ref;
-          xrefsection = NULL;
-          --xref->count;
-          break;
-        case 1:
-          if (xrefsection == NULL)
-          {
-            xrefsection = ppxref_push_section(xref, &pdf->heap);
-            xrefsection->first = ref->number;
-            xrefsection->refs = ref;
-          }
-          xrefsection->last = ref->number;
-          ref->offset = f2;
-          ref->version = f3;
-          ref->object.type = PPNONE;
-          ref->object.any = NULL;
-          ref->length = 0;
-          break;
-        case 2:
-          if (xrefsection == NULL)
-          {
-            xrefsection = ppxref_push_section(xref, &pdf->heap);
-            xrefsection->first = ref->number;
-            xrefsection->refs = ref;
-          }
-          xrefsection->last = ref->number;
-          ref->offset = 0; // f2 is parent objstm, f3 is index in parent, both useless
-          ref->version = 0; // compressed objects has implicit version == 0
-          ref->object.type = PPNONE;
-          ref->object.any = NULL;
-          ref->length = 0;
-          break;
-        default:
-          goto xref_stream_error;
-      }
-    }
-  }
-  /* sort sections */
-  if (!ppxref_sort(xref))
-    ; // case of xref->size == 0 handled by ppxref_load_chain()
-  /* close the stream _before_ loading prev xref */
-  ppstream_done(xrefstream);
-  /* load prev and return */
-  return ppxref_load_chain(pdf, xref);
-xref_stream_error:
-  ppstream_done(xrefstream);
-  return NULL;
-}
-
-/*
-The following procedure loads xref /Prev, links xref->prev and typically returns xref.
-Some docs contain empty xref (one section with zero objects) that is actually a proxy
-to xref stream referred as /XRefStm (genuine concept of xrefs old/new style xrefs in
-the same doc). In case of 0-length xref we ignore the proxy and return the target xref
-(otherwise we would need annoying sanity check for xref->size > 0 on every ref search).
-*/
-
-static ppxref * ppxref_load_chain (ppdoc *pdf, ppxref *xref)
-{
-  ppdict *trailer;
-  ppuint xrefoffset;
-  ppxref *prevxref, *nextxref;
-
-  trailer = ppxref_trailer(xref);
-  if (!ppdict_get_uint(trailer, "Prev", &xrefoffset)) // XRefStm is useless
-    return xref; // missing /Prev is obviously ok
-  for (nextxref = pdf->xref; nextxref != NULL; nextxref = nextxref->prev)
-    if (nextxref->offset == xrefoffset) // insane
-      return NULL;
-  if ((prevxref = ppxref_load(pdf, (size_t)xrefoffset)) == NULL)
-    return NULL;
-  if (xref->size > 0)
-  {
-    xref->prev = prevxref;
-    return xref;
-  }
-  if (pdf->xref == xref)
-    pdf->xref = prevxref;
-  return prevxref;
-}
-
-static ppxref * ppxref_load (ppdoc *pdf, size_t xrefoffset)
-{
-  iof *I;
-  if ((I = ppdoc_reader(pdf, xrefoffset, PP_LENGTH_UNKNOWN)) == NULL)
-    return NULL;
-  ppscan_find(I);
-  if (ppscan_key(I, "xref"))
-    return ppxref_load_table(I, pdf, xrefoffset);
-  return ppxref_load_stream(I, pdf, xrefoffset);
-  // iof_close(I) does nothing here
-}
-
-static void ppoffmap_sort (ppref **left, ppref **right)
-{
-  ppref **l, **r, *t;
-  ppuint pivot;
-  l = left, r = right;
-  pivot = (*(l + ((r - l) / 2)))->offset;
-  do
-  { // don't read from pointer!
-    while ((*l)->offset < pivot) ++l;
-    while ((*r)->offset > pivot) --r;
-    if (l <= r)
-    {
-      t = *l;
-      *l = *r;
-      *r = t;
-      ++l, --r;
-    }
-  } while (l <= r);
-  if (left < r)
-    ppoffmap_sort(left, r);
-  if (l < right)
-    ppoffmap_sort(l, right);
-}
-
-
-static void fix_trailer_references (ppdoc *pdf)
-{
-  ppxref *xref;
-  ppdict *trailer;
-  ppname *pkey;
-  ppobj *obj;
-  ppref *ref;
-  for (xref = pdf->xref; xref != NULL; xref = xref->prev)
-  {
-    if ((trailer = ppxref_trailer(xref)) == NULL)
-      continue;
-    for (ppdict_first(trailer, pkey, obj); *pkey != NULL; ppdict_next(pkey, obj))
-    { // no need to go deeper in structs, all items in trailer except info and root must be direct refs
-      if (obj->type != PPREF)
-        continue;
-      ref = obj->ref;
-      if (ref->offset == 0) // unresolved?
-        if ((ref = ppxref_find(xref, ref->number)) != NULL)
-          obj->ref = ref; // at this moment the reference still points nothing, but should be the one with the proper offset
-    }
-  }
-}
-
-/*
-Here comes a procedure that loads all entries from all document bodies. We resolve references while
-parsing objects and to make resolving correct, we need a complete chain of xref maps, and a knowledge
-about possible linearized dict (first offset). So loading refs sorted by offsets makes sense (not sure
-if it matters nowadays but we also avoid fseek() by large offsets).
-
-Here is the proc:
-
-  - create a list of all refs in all bodies
-  - sort the list by offsets
-  - for every ref from the sorted list:
-    - estimate object length to avoid fread-ing more than necessary (not perfect but enough)
-    - fseek() to the proper offset, fread() entry data or its part
-    - parse the object with ppscan_obj(I, pdf, xref), where xref is not necessarily top pdf->xref
-    - save the actual ref->length (not sure if we need that?)
-    - make a stream if a dict is followed by "stream" keyword, also save the stream offset
-  - free the list
-*/
-
-static int ppdoc_load_objstm (ppstream *stream, ppdoc *pdf, ppxref *xref);
-
-static void ppdoc_load_entries (ppdoc *pdf)
-{
-  size_t objects, sectionindex, refnumber, offindex;
-  ppnum linearized;
-  ppref **offmap, **pref, *ref;
-  ppxref *xref;
-  ppxsec *xsec;
-  ppobj *obj;
-  ppname type;
-  int redundant_indirection = 0;
-  ppcrypt *crypt;
-  ppstream *stream;
-
-  if ((objects = (size_t)ppdoc_objects(pdf)) == 0) // can't happen
-    return;
-  pref = offmap = (ppref **)pp_malloc(objects * sizeof(ppref *));
-  objects = 0; // recount refs with offset > 0
-  for (xref = pdf->xref; xref != NULL; xref = xref->prev)
-    for (sectionindex = 0, xsec = xref->sects; sectionindex < xref->size; ++sectionindex, ++xsec)
-      for (refnumber = xsec->first, ref = xsec->refs; refnumber <= xsec->last; ++refnumber, ++ref)
-        if (ref->offset > 0) // 0 means compressed or insane
-          *pref++ = ref, ++objects;
-  ppoffmap_sort(offmap, offmap + objects - 1);
-
-  crypt = pdf->crypt;
-  for (offindex = 0, pref = offmap; offindex < objects; )
-  {
-    ref = *pref;
-    ++pref;
-    ++offindex;
-    if (ref->object.type != PPNONE) // might be preloaded already (/Encrypt dict, stream filter dicts, stream /Length..)
-    	continue;
-    if (offindex < objects)
-      ref->length = (*pref)->offset - ref->offset;
-    else
-      ref->length = pdf->filesize > ref->offset ? pdf->filesize - ref->offset : 0;
-    if (crypt != NULL)
-    {
-      ppcrypt_start_ref(crypt, ref);
-      obj = ppdoc_load_entry(pdf, ref);
-      ppcrypt_end_ref(crypt);
-    }
-    else
-    {
-      obj = ppdoc_load_entry(pdf, ref);
-    }
-    switch (obj->type)
-    {
-      case PPDICT: /* Check if the object at first offset is linearized dict. We need that to resolve all references properly. */
-        if (offindex == 1 && ppdict_get_num(obj->dict, "Linearized", &linearized)) // /Linearized value is a version number, default 1.0
-          pdf->flags |= PPDOC_LINEARIZED;
-        break;
-      case PPREF:
-        redundant_indirection = 1;
-        break;
-      default:
-        break;
-    }
-    // if pdf->crypt crypt->ref = NULL
-  }
-
-  /* refs pointngs refs? cut. */
-  if (redundant_indirection)
-  {
-    for (offindex = 0, pref = offmap; offindex < objects; ++offindex)
-    {
-      ref = *pref++;
-      if (ref->object.type == PPREF)
-        ref->object = ref->object.ref->object; // doing for all effectively cuts all insane chains
-    }
-  }
-
-  /* now handle streams; update stream info (eg. /Length), load pdf 1.5 object streams
-     we could do earlier but then we would need to struggle with indirects */
-  for (offindex = 0, pref = offmap; offindex < objects; ++offindex)
-  {
-    ref = *pref++;
-    obj = &ref->object;
-    if (obj->type != PPSTREAM)
-      continue;
-    stream = obj->stream;
-    if (crypt != NULL)
-    {
-      ppcrypt_start_ref(crypt, ref);
-      ppstream_info(stream, pdf);
-      ppcrypt_end_ref(crypt);
-    }
-    else
-    {
-      ppstream_info(stream, pdf);
-    }
-    if (ref->xref->trailer.type == PPSTREAM && (type = ppdict_get_name(stream->dict, "Type")) != NULL && ppname_is(type, "ObjStm")) // somewhat dummy..
-      if (!ppdoc_load_objstm(stream, pdf, ref->xref))
-        loggerf("invalid objects stream %s at offset " PPSIZEF, ppref_str(ref->number, ref->version), ref->offset);
-  }
-  pp_free(offmap);
-}
-
-ppobj * ppdoc_load_entry (ppdoc *pdf, ppref *ref)
-{
-  iof *I;
-  size_t length;
-  ppxref *xref;
-  ppobj *obj;
-  ppstack *stack;
-  size_t streamoffset;
-  ppref *refref;
-  ppuint refnumber, refversion;
-
-  length = ref->length > 0 ? ref->length : PP_LENGTH_UNKNOWN; // estimated or unknown
-  if ((I = ppdoc_reader(pdf, ref->offset, length)) == NULL || !ppscan_start_entry(I, ref))
-  {
-    loggerf("invalid %s offset " PPSIZEF, ppref_str(ref->number, ref->version), ref->offset);
-    return &ref->object; // PPNONE
-  }
-  stack = &pdf->stack;
-  xref = ref->xref; // to resolve indirects properly
-  if ((obj = ppscan_obj(I, pdf, xref)) == NULL)
-  {
-    loggerf("invalid %s object at offset " PPSIZEF, ppref_str(ref->number, ref->version), ref->offset);
-    return &ref->object; // PPNONE
-  }
-  ref->object = *obj;
-  ppstack_pop(stack, 1);
-  obj = &ref->object;
-  ref->length = ppdoc_reader_tell(pdf, I) - ref->offset;
-  if (obj->type == PPDICT)
-  {
-    if (ppscan_start_stream(I, pdf, &streamoffset))
-    {
-      obj->type = PPSTREAM;
-      obj->stream = ppstream_create(pdf, obj->dict, streamoffset);
-    }
-  }
-  else if (obj->type == PPINT)
-  {
-    ppscan_find(I);
-    if (ppscan_uint(I, &refversion) && ppscan_find(I) == 'R')
-    {
-      refnumber = (ppuint)obj->integer;
-      if ((refref = ppxref_find(xref, refnumber)) != NULL)
-      {
-        obj->type = PPREF;
-        obj->ref = refref;
-      }
-      else
-      {
-        obj->type = PPNONE; // as ppref_unresolved()
-        obj->any = NULL;
-      }
-    }
-  }
-  return obj;
-}
-
-/* Loading entries from object stream
-
-  /N is the number of contained entries
-  /First is the offset of the first item
-
-The stream consists of N pairs of numbers <objnum> <offset> <objnum> <offset> ...
-Offsets are ascending (relative to the first), but ref numbers order is arbitrary.
-PDF spec says there might be some additional data between objects, so we should obey offsets.
-Which means we should basically load the stream at once (may be needed anyway to grab the stream [...]).
-*/
-
-static int ppdoc_load_objstm (ppstream *stream, ppdoc *pdf, ppxref *xref)
-{
-  ppdict *dict; // stream dict, actually still on stack
-  ppref *ref;
-  ppobj *obj;
-  ppuint items, firstoffset, offset, objnum, i, invalid = 0;
-  iof *I;
-  uint8_t *firstdata, *indexdata;
-  ppstack *stack;
-
-  dict = stream->dict;
-  if (!ppdict_rget_uint(dict, "N", &items) || !ppdict_rget_uint(dict, "First", &firstoffset))
-    return 0;
-  if ((I = ppstream_read(stream, 1, 1)) == NULL)
-    return 0;
-  firstdata = I->pos + firstoffset;
-  if (firstdata >= I->end)
-    goto invalid_objstm;
-  stack = &pdf->stack;
-  //if (pdf->crypt != NULL)
-  //  ppcrypt_end_ref(pdf->crypt); // objects are not encrypted, pdf->crypt->ref ensured NULL
-  for (i = 0; i < items; ++i)
-  {
-    ppscan_find(I);
-    if (!ppscan_uint(I, &objnum))
-      goto invalid_objstm;
-    ppscan_find(I);
-    if (!ppscan_uint(I, &offset))
-      goto invalid_objstm;
-    if ((ref = ppxref_find_local(xref, objnum)) == NULL || ref->object.type != PPNONE)
-    {
-      loggerf("invalid compressed object number " PPUINTF " at position " PPUINTF, objnum, i);
-      ++invalid;
-      continue;
-    }
-    if (firstdata + offset >= I->end)
-    {
-      loggerf("invalid compressed object offset " PPUINTF " at position " PPUINTF, offset, i);
-      ++invalid;
-      continue;
-    }
-    indexdata = I->pos; // save position
-    I->pos = firstdata + offset; // go to the object
-    ppscan_find(I);
-    if ((obj = ppscan_obj(I, pdf, xref)) != NULL)
-    {
-      ref->object = *obj;
-      ppstack_pop(stack, 1);
-      // nothing more needed, as obj can never be indirect ref or stream
-    }
-    else
-    {
-      ++invalid;
-      loggerf("invalid compressed object %s at stream offset " PPUINTF, ppref_str(objnum, 0), offset);
-    }
-    I->pos = indexdata; // restore position and read next from index
-  }
-  ppstream_done(stream);
-  return invalid == 0;
-invalid_objstm:
-  ppstream_done(stream);
-  return 0;
-}
-
-/* main PDF loader proc */
-
-ppcrypt_status ppdoc_crypt_pass (ppdoc *pdf, const void *userpass, size_t userpasslength, const void *ownerpass, size_t ownerpasslength)
-{
-  switch (pdf->cryptstatus)
-  {
-    case PPCRYPT_NONE:
-    case PPCRYPT_DONE:
-    case PPCRYPT_FAIL:
-      break;
-    case PPCRYPT_PASS: // initial status or really needs password
-      pdf->cryptstatus = ppdoc_crypt_init(pdf, userpass, userpasslength, ownerpass, ownerpasslength);
-      switch (pdf->cryptstatus)
-      {
-        case PPCRYPT_NONE:
-        case PPCRYPT_DONE:
-          ppdoc_load_entries(pdf);
-          break;
-        case PPCRYPT_PASS: // user needs to check ppdoc_crypt_status() and recall ppdoc_crypt_pass() with the proper password
-        case PPCRYPT_FAIL: // hopeless..
-          break;
-      }
-      break;
-  }
-  return pdf->cryptstatus;
-}
-
-static ppdoc * ppdoc_read (ppdoc *pdf, iof_file *input)
-{
-  uint8_t header[PPDOC_HEADER];
-  size_t xrefoffset;
-
-  input = &pdf->input;
-  if (iof_file_read(header, 1, PPDOC_HEADER, input) != PPDOC_HEADER || !ppdoc_header(pdf, header))
-    return NULL;
-  if (!ppdoc_tail(pdf, input, &xrefoffset))
-    return NULL;
-  if (ppxref_load(pdf, xrefoffset) == NULL)
-    return NULL;
-  fix_trailer_references(pdf); // after loading xrefs but before accessing trailer refs (/Encrypt might be a reference)
-  // check encryption, if any, try empty password
-  switch (ppdoc_crypt_pass(pdf, "", 0, NULL, 0))
-  {
-    case PPCRYPT_NONE: // no encryption
-    case PPCRYPT_DONE: // encryption with an empty password
-    case PPCRYPT_PASS: // the user needs to check ppdoc_crypt_status() and call ppdoc_crypt_pass()
-      break;
-    case PPCRYPT_FAIL: // hopeless
-      //loggerf("decryption failed");
-      //return NULL;
-      break;
-  }
-  return pdf;
-}
-
-static void ppdoc_pages_init (ppdoc *pdf);
-
-static ppdoc * ppdoc_create (iof_file *input)
-{
-  ppdoc *pdf;
-  ppheap *heap;
-
-  heap = ppheap_new();
-  pdf = (ppdoc *)ppheap_take(&heap, sizeof(ppdoc));
-  pdf->flags = 0;
-  pdf->heap = heap;
-  pdf->xref = NULL;
-  pdf->version[0] = '\0';
-  pdf->crypt = NULL;
-  pdf->cryptstatus = PPCRYPT_PASS; // force encryption check on ppdoc_read() -> ppdoc_crypt_pass()
-  ppstack_init(&pdf->stack, &pdf->heap);
-  ppdoc_reader_init(pdf, input);
-  ppdoc_pages_init(pdf);
-  if (ppdoc_read(pdf, &pdf->input) != NULL)
-    return pdf;
-  ppdoc_free(pdf);
-  return NULL;
-}
-
-ppdoc * ppdoc_load (const char *filename)
-{
-  FILE *file;
-  iof_file input;
-  if ((file = fopen(filename, "rb")) == NULL)
-    return NULL;
-  iof_file_init(&input, file);
-  input.flags |= IOF_CLOSE_FILE;
-  return ppdoc_create(&input);
-}
-
-ppdoc * ppdoc_mem (const void *data, size_t size)
-{
-	iof_file input;
-	iof_file_rdata_init(&input, data, size);
-	input.flags |= IOF_BUFFER_ALLOC; // todo: 3 modes: borrow, take over, copy?
-	return ppdoc_create(&input);
-}
-
-void ppdoc_free (ppdoc *pdf)
-{
-  //iof_file_free(&pdf->input);
-  iof_file_decref(&pdf->input);
-  ppstack_free_buffer(&pdf->stack);
-  ppheap_free(pdf->heap); // last!
-}
-
-ppcrypt_status ppdoc_crypt_status (ppdoc *pdf)
-{
-  return pdf->cryptstatus;
-}
-
-ppint ppdoc_permissions (ppdoc *pdf)
-{
-  return pdf->crypt != NULL ? pdf->crypt->permissions : (ppint)0xFFFFFFFFFFFFFFFF;
-}
-
-/* pages access */
-
-static pparray * pppage_node (ppdict *dict, ppuint *count, ppname *type)
-{
-  ppname *pkey, key;
-  ppobj *obj;
-  pparray *kids = NULL;
-  *count = 0;
-  *type = NULL;
-  for (ppdict_first(dict, pkey, obj); (key = *pkey) != NULL; ppdict_next(pkey, obj))
-  {
-    switch (key[0])
-    {
-      case 'T':
-        if (ppname_is(key, "Type"))
-          *type = ppobj_get_name(obj);
-        break;
-      case 'C':
-        if (ppname_is(key, "Count"))
-          ppobj_get_uint(obj, *count);
-        break;
-      case 'K':
-        if (ppname_is(key, "Kids"))
-          kids = ppobj_rget_array(obj);
-        break;
-    }
-  }
-  return kids;
-}
-
-#define ppname_is_page(type) (type != NULL && ppname_is(type, "Page"))
-
-ppuint ppdoc_page_count (ppdoc *pdf)
-{
-  ppref *ref;
-  ppname type;
-  ppuint count;
-  if ((ref = ppxref_pages(pdf->xref)) == NULL)
-    return 0;
-  if (pppage_node(ref->object.dict, &count, &type) == NULL)
-    return ppname_is_page(type) ? 1 : 0; // acrobat and ghostscript accept documents with root /Pages entry being a reference to a sole /Page object
-  return count;
-}
-
-ppref * ppdoc_page (ppdoc *pdf, ppuint index)
-{
-  ppdict *dict;
-  ppuint count;
-  pparray *kids;
-  size_t size, i;
-  ppobj *r, *o;
-  ppref *ref;
-  ppname type;
-
-
-  if ((ref = ppxref_pages(pdf->xref)) == NULL)
-    return NULL;
-  dict = ref->object.dict;
-  if ((kids = pppage_node(dict, &count, &type)) != NULL)
-  {
-    if (index < 1 || index > count)
-      return NULL;
-  }
-  else
-  {
-    return index == 1 && ppname_is_page(type) ? ref : NULL;
-  }
-scan_array:
-  if (index <= count / 2)
-  { // probably shorter way from the beginning
-    for (i = 0, size = kids->size, r = pparray_at(kids, 0); i < size; ++i, ++r)
-    {
-      if (r->type != PPREF)
-        return NULL;
-      o = &r->ref->object;
-      if (o->type != PPDICT)
-        return NULL;
-      dict = o->dict;
-      if ((kids = pppage_node(dict, &count, &type)) != NULL)
-      {
-        if (index <= count)
-          goto scan_array;
-        index -= count;
-        continue;
-      }
-      if (index == 1 && ppname_is_page(type))
-        return r->ref;
-      --index;
-    }
-  }
-  else if ((size = kids->size) > 0) // for safe (size-1)
-  { // probably shorter way from the end
-    index = count - index + 1;
-    for (i = 0, r = pparray_at(kids, size - 1); i < size; ++i, --r)
-    {
-      if (r->type != PPREF)
-        return NULL;
-      o = &r->ref->object;
-      if (o->type != PPDICT)
-        return NULL;
-      dict = o->dict;
-      if ((kids = pppage_node(dict, &count, &type)) != NULL)
-      {
-        if (index <= count)
-          goto scan_array;
-        index -= count;
-        continue;
-      }
-      if (index == 1 && ppname_is_page(type))
-        return r->ref;
-      --index;
-    }
-  }
-  return NULL;
-}
-
-/*
-Through pages iterator. Iterating over pages tree just on the base of /Kids and /Parent keys
-is ineffective, as to get next pageref we need to take parent, find the pageref in /Kids,
-take next (or go upper).. Annoying. We use a dedicated stack for pages iterator. This could
-actually be done with pdf->stack, but some operations may clear it, so safer to keep it independent
-Besides, its depth is constant (set on first use), so no need for allocs.
-*/
-
-static void ppdoc_pages_init (ppdoc *pdf)
-{
-  pppages *pages;
-  pages = &pdf->pages;
-  pages->root = pages->parent = pages->buffer;
-  pages->depth = 0;
-  pages->space = PPPAGES_STACK_DEPTH;
-}
-
-static ppkids * pppages_push (ppdoc *pdf, pparray *kids)
-{
-  ppkids *newroot, *bounds;
-  pppages *pages;
-  pages = &pdf->pages;
-  if (pages->depth == pages->space)
-  {
-    pages->space <<= 1;
-    newroot = (ppkids *)ppheap_take(&pdf->heap, pages->space * sizeof(ppkids));
-    memcpy(newroot, pages->root, pages->depth * sizeof(ppkids));
-    pages->root = newroot;
-  }
-  bounds = pages->parent = &pages->root[pages->depth++];
-  bounds->current = pparray_at(kids, 0);
-  bounds->sentinel = pparray_at(kids, kids->size);
-  return bounds;
-}
-
-#define pppages_pop(pages) (--((pages)->parent), --((pages)->depth))
-
-static ppref * ppdoc_pages_group_first (ppdoc *pdf, ppref *ref)
-{
-  ppdict *dict;
-  pparray *kids;
-  ppuint count;
-  ppname type;
-
-  dict = ref->object.dict; // typecheck made by callers
-  while ((kids = pppage_node(dict, &count, &type)) != NULL)
-  {
-    if ((ref = pparray_get_ref(kids, 0)) == NULL || ref->object.type != PPDICT)
-      return NULL;
-    pppages_push(pdf, kids);
-    dict = ref->object.dict;
-  }
-  return ppname_is_page(type) ? ref : NULL;
-}
-
-ppref * ppdoc_first_page (ppdoc *pdf)
-{
-  ppref *ref;
-  pppages *pages;
-  if ((ref = ppdoc_pages(pdf)) == NULL)
-    return NULL;
-  pages = &pdf->pages;
-  pages->parent = pages->root;
-  pages->depth = 0;
-  return ppdoc_pages_group_first(pdf, ref);
-}
-
-ppref * ppdoc_next_page (ppdoc *pdf)
-{
-  pppages *pages;
-  ppkids *bounds;
-  ppref *ref;
-  ppobj *obj;
-  pages = &pdf->pages;
-  while (pages->depth > 0)
-  {
-    bounds = pages->parent;
-    obj = ++bounds->current;
-    if (obj < bounds->sentinel)
-    {
-      if (obj->type != PPREF)
-        return NULL;
-      ref = obj->ref;
-      if (ref->object.type != PPDICT)
-        return NULL;
-      return ppdoc_pages_group_first(pdf, ref);
-    }
-    else
-    { // no next node, go upper
-      pppages_pop(pages);
-    }
-  }
-  return NULL;
-}
-
-/* context */
-
-ppcontext * ppcontext_new (void)
-{
-  ppheap *heap;
-  ppcontext *context;
-  heap = ppheap_new();
-  context = (ppcontext *)pp_malloc(sizeof(ppcontext)); // not from priv heap, as we delete it on renew
-  context->heap = heap;
-  ppstack_init(&context->stack, &context->heap);
-  return context;
-}
-
-void ppcontext_done (ppcontext *context)
-{
-  ppheap_renew(context->heap);
-  ppstack_clear(&context->stack);
-}
-
-void ppcontext_free (ppcontext *context)
-{
-  ppstack_free_buffer(&context->stack);
-  ppheap_free(context->heap);
-  pp_free(context);
-}
-
-/* page contents streams */
-
-//#define ppcontents_first_stream(array) pparray_rget_stream(array, 0)
-
-static ppstream * ppcontents_first_stream (pparray *array)
-{
-  size_t i;
-  ppobj *obj;
-  ppref *ref;
-  for (pparray_first(array, i, obj); i < array->size; pparray_next(i, obj))
-    if ((ref = ppobj_get_ref(obj)) != NULL && ref->object.type == PPSTREAM)
-      return ref->object.stream;
-  return NULL;
-}
-
-static ppstream * ppcontents_next_stream (pparray *array, ppstream *stream)
-{
-  size_t i;
-  ppobj *obj;
-  ppref *ref;
-  for (pparray_first(array, i, obj); i < array->size; pparray_next(i, obj))
-    if ((ref = ppobj_get_ref(obj)) != NULL && ref->object.type == PPSTREAM && ref->object.stream == stream)
-      if (++i < array->size && (ref = ppobj_get_ref(obj + 1)) != NULL && ref->object.type == PPSTREAM)
-        return ref->object.stream;
-  return NULL;
-}
-
-ppstream * ppcontents_first (ppdict *dict)
-{
-  ppobj *contentsobj;
-  if ((contentsobj = ppdict_rget_obj(dict, "Contents")) == NULL)
-    return NULL;
-  switch (contentsobj->type)
-  {
-    case PPARRAY:
-      return ppcontents_first_stream(contentsobj->array);
-    case PPSTREAM:
-      return contentsobj->stream;
-    default:
-      break;
-  }
-  return NULL;
-}
-
-ppstream * ppcontents_next (ppdict *dict, ppstream *stream)
-{
-  ppobj *contentsobj;
-  if ((contentsobj = ppdict_rget_obj(dict, "Contents")) == NULL)
-    return NULL;
-  switch (contentsobj->type)
-  {
-    case PPARRAY:
-      return ppcontents_next_stream(contentsobj->array, stream);
-    case PPSTREAM:
-      break;
-    default:
-      break;
-  }
-  return NULL;
-}
-
-static ppobj * ppcontents_op (iof *I, ppstack *stack, size_t *psize, ppname *pname)
-{
-  ppobj *obj;
-  ppstack_clear(stack);
-  do {
-    if (ppscan_find(I) < 0)
-      return NULL;
-    if ((obj = ppscan_psobj(I, stack)) == NULL)
-      return NULL;
-  } while (obj->type != PPNAME || !ppname_exec(obj->name));
-  *pname = obj->name;
-  *psize = stack->size - 1;
-  return stack->buf;
-}
-
-ppobj * ppcontents_first_op (ppcontext *context, ppstream *stream, size_t *psize, ppname *pname)
-{
-  iof *I;
-  if ((I = ppstream_read(stream, 1, 0)) == NULL)
-    return NULL;
-  return ppcontents_op(I, &context->stack, psize, pname);
-}
-
-ppobj * ppcontents_next_op (ppcontext *context, ppstream *stream, size_t *psize, ppname *pname)
-{
-  return ppcontents_op(ppstream_iof(stream), &context->stack, psize, pname);
-}
-
-ppobj * ppcontents_parse (ppcontext *context, ppstream *stream, size_t *psize)
-{
-  iof *I;
-  ppstack *stack;
-  ppobj *obj;
-  stack = &context->stack;
-  ppstack_clear(stack);
-  if ((I = ppstream_read(stream, 1, 0)) == NULL)
-    return NULL;
-  while (ppscan_find(I) >= 0)
-    if ((obj = ppscan_psobj(I, stack)) == NULL)
-      goto error;
-  *psize = stack->size;
-  ppstream_done(stream);
-  return stack->buf;
-error:
-  ppstream_done(stream);
-  return NULL;
-}
-
-/* boxes */
-
-pprect * pparray_to_rect (pparray *array, pprect *rect)
-{
-  ppobj *obj;
-  if (array->size != 4)
-    return NULL;
-  obj = pparray_at(array, 0);
-  if (!ppobj_get_num(obj, rect->lx)) return NULL;
-  obj = pparray_at(array, 1);
-  if (!ppobj_get_num(obj, rect->ly)) return NULL;
-  obj = pparray_at(array, 2);
-  if (!ppobj_get_num(obj, rect->rx)) return NULL;
-  obj = pparray_at(array, 3);
-  if (!ppobj_get_num(obj, rect->ry)) return NULL;
-  return rect;
-}
-
-pprect * ppdict_get_rect (ppdict *dict, const char *name, pprect *rect)
-{
-  pparray *array;
-  return (array = ppdict_rget_array(dict, name)) != NULL ? pparray_to_rect(array, rect) : NULL;
-}
-
-pprect * ppdict_get_box (ppdict *dict, const char *name, pprect *rect)
-{
-  do {
-    if (ppdict_get_rect(dict, name, rect) != NULL)
-      return rect;
-    dict = ppdict_rget_dict(dict, "Parent");
-  } while (dict != NULL);
-  return NULL;
-}
-
-ppmatrix * pparray_to_matrix (pparray *array, ppmatrix *matrix)
-{
-  ppobj *obj;
-  if (array->size != 6)
-    return NULL;
-  obj = pparray_at(array, 0);
-  if (!ppobj_get_num(obj, matrix->xx)) return NULL;
-  obj = pparray_at(array, 1);
-  if (!ppobj_get_num(obj, matrix->xy)) return NULL;
-  obj = pparray_at(array, 2);
-  if (!ppobj_get_num(obj, matrix->yx)) return NULL;
-  obj = pparray_at(array, 3);
-  if (!ppobj_get_num(obj, matrix->yy)) return NULL;
-  obj = pparray_at(array, 4);
-  if (!ppobj_get_num(obj, matrix->x)) return NULL;
-  obj = pparray_at(array, 5);
-  if (!ppobj_get_num(obj, matrix->y)) return NULL;
-  return matrix;
-}
-
-ppmatrix * ppdict_get_matrix (ppdict *dict, const char *name, ppmatrix *matrix)
-{
-  pparray *array;
-  return (array = ppdict_rget_array(dict, name)) != NULL ? pparray_to_matrix(array, matrix) : NULL;
-}
-
-/* logger */
-
-void pplog_callback (pplogger_callback logger, void *alien)
-{
-	logger_callback((logger_function)logger, alien);
-}
-
-int pplog_prefix (const char *prefix)
-{
-	return logger_prefix(prefix);
-}
-
-/* version */
-
-const char * ppdoc_version_string (ppdoc *pdf)
-{
-  return pdf->version;
-}
-
-int ppdoc_version_number (ppdoc *pdf, int *minor)
-{
-  *minor = pdf->version[2] - '0';
-  return pdf->version[0] - '0';
-}
-
-/* doc info */
-
-size_t ppdoc_file_size (ppdoc *pdf)
-{
-  return pdf->filesize;
-}
-
-ppuint ppdoc_objects (ppdoc *pdf)
-{
-  ppuint count;
-  ppxref *xref;
-  for (count = 0, xref = pdf->xref; xref != NULL; xref = xref->prev)
-    count += xref->count;
-  return count;
-}
-
-size_t ppdoc_memory (ppdoc *pdf, size_t *waste)
-{
-  size_t used;
-  ppheap *heap;
-  used = 0, *waste = 0;
-  for (heap = pdf->heap; heap != NULL; heap = heap->prev)
-  {
-    used += heap->space;
-    *waste += heap->size;
-  }
-  return used;
-}
--- texlive-bin.orig/texk/web2c/luatexdir/luapplib/ppload.h
+++ /dev/null
@@ -1,54 +0,0 @@
-
-#ifndef PP_LOAD_H
-#define PP_LOAD_H
-
-typedef struct {
-  ppobj *buf;     // ppobjects buffer (allocated, not from our heap)
-  ppobj *pos;     // current ppobj *
-  size_t size;    // stack size
-  size_t space;   // available space
-  ppheap **pheap; // allocator (parent pdf->stack->pheap or own)
-} ppstack;
-
-typedef struct {
-  ppobj *current;
-  ppobj *sentinel;
-} ppkids;
-
-#define PPPAGES_STACK_DEPTH 4
-
-typedef struct {
-  ppkids buffer[PPPAGES_STACK_DEPTH];
-  ppkids *root;
-  ppkids *parent;
-  ppuint depth;
-  ppuint space;
-} pppages;
-
-struct ppdoc {
-  char version[5];
-  iof_file input;
-  iof reader;
-  uint8_t *buffer;
-  size_t filesize;
-  ppxref *xref;
-  ppheap *heap;
-  ppstack stack;
-  pppages pages;
-  int flags;
-  ppcrypt *crypt;
-  ppcrypt_status cryptstatus;
-};
-
-#define PPDOC_LINEARIZED (1 << 0)
-
-ppobj * ppdoc_load_entry (ppdoc *pdf, ppref *ref);
-#define ppobj_preloaded(pdf, obj) ((obj)->type != PPREF ? (obj) : ((obj)->ref->object.type == PPNONE ? ppdoc_load_entry(pdf, (obj)->ref) : &(obj)->ref->object))
-ppstring ppstring_internal (const void *data, size_t size, ppheap **pheap);
-
-struct ppcontext {
-  ppheap *heap;
-  ppstack stack;
-};
-
-#endif
\ No newline at end of file
--- texlive-bin.orig/texk/web2c/luatexdir/luapplib/ppstream.c
+++ /dev/null
@@ -1,310 +0,0 @@
-
-#include "ppfilter.h"
-#include "pplib.h"
-
-ppstream * ppstream_create (ppdoc *pdf, ppdict *dict, size_t offset)
-{
-	ppstream *stream;
-	stream = (ppstream *)ppheap_take(&pdf->heap, sizeof(ppstream));
-	stream->dict = dict;
-	stream->offset = offset;
-	//if (!ppdict_rget_uint(dict, "Length", &stream->length)) // may be indirect pointing PPNONE at this moment
-	//  stream->length = 0;
-	stream->length = 0;
-	stream->input = &pdf->input;
-	stream->I = NULL;
-	stream->cryptkey = NULL;
-	stream->flags = 0;
-	return stream;
-}
-
-/* codecs */
-
-enum {
-  PPSTREAM_UNKNOWN = -1,
-  PPSTREAM_BASE16 = 0,
-  PPSTREAM_BASE85,
-  PPSTREAM_RUNLENGTH,
-  PPSTREAM_FLATE,
-  PPSTREAM_LZW,
-  PPSTREAM_CCITT,
-  PPSTREAM_DCT,
-  PPSTREAM_JBIG2,
-  PPSTREAM_JPX,
-  PPSTREAM_CRYPT
-};
-
-static int ppstream_codec_type (ppname name)
-{ // one of those places where some hash wuld be nice..
-  switch (name[0])
-  {
-    case 'A':
-      if (ppname_is(name, "ASCIIHexDecode")) return PPSTREAM_BASE16;
-      if (ppname_is(name, "ASCII85Decode")) return PPSTREAM_BASE85;
-      break;
-    case 'R':
-      if (ppname_is(name, "RunLengthDecode")) return PPSTREAM_RUNLENGTH;
-      break;
-    case 'F':
-      if (ppname_is(name, "FlateDecode")) return PPSTREAM_FLATE;
-      break;
-    case 'L':
-      if (ppname_is(name, "LZWDecode")) return PPSTREAM_LZW;
-      break;
-    case 'D':
-      if (ppname_is(name, "DCTDecode")) return PPSTREAM_DCT;
-      break;
-    case 'C':
-      if (ppname_is(name, "CCITTFaxDecode")) return PPSTREAM_CCITT;
-      if (ppname_is(name, "Crypt")) return PPSTREAM_CRYPT;
-      break;
-    case 'J':
-      if (ppname_is(name, "JPXDecode")) return PPSTREAM_JPX;
-      if (ppname_is(name, "JBIG2Decode")) return PPSTREAM_JBIG2;
-      break;
-  }
-  return PPSTREAM_UNKNOWN;
-}
-
-static iof * ppstream_predictor (ppdict *params, iof *N)
-{
-  ppint predictor, rowsamples, components, samplebits;
-
-  if (!ppdict_get_int(params, "Predictor", &predictor) || predictor <= 1)
-    return N;
-  if (!ppdict_get_int(params, "Columns", &rowsamples) || rowsamples == 0) // sanity, filter probably expects >0
-    rowsamples = 1;;
-  if (!ppdict_get_int(params, "Colors", &components) || components == 0) // ditto
-    components = 1;
-  if (!ppdict_get_int(params, "BitsPerComponent", &samplebits) || samplebits == 0)
-    samplebits = 8;
-  return iof_filter_predictor_decoder(N, (int)predictor, (int)rowsamples, (int)components, (int)samplebits);
-}
-
-static iof * ppstream_decoder (ppstream *stream, int codectype, ppdict *params, iof *N)
-{
-  int flags;
-  iof *F, *P;
-  ppint earlychange;
-  ppstring cryptkey;
-
-  switch (codectype)
-  {
-    case PPSTREAM_BASE16:
-      return iof_filter_base16_decoder(N);
-    case PPSTREAM_BASE85:
-      return iof_filter_base85_decoder(N);
-    case PPSTREAM_RUNLENGTH:
-      return iof_filter_runlength_decoder(N);
-    case PPSTREAM_FLATE:
-      if ((F = iof_filter_flate_decoder(N)) != NULL)
-      {
-        if (params != NULL)
-        {
-          if ((P = ppstream_predictor(params, F)) != NULL)
-            return P;
-          iof_close(F);
-          break;
-        }
-        return F;
-      }
-      break;
-    case PPSTREAM_LZW:
-      flags = LZW_DECODER_DEFAULTS;
-      if (params != NULL && ppdict_get_int(params, "EarlyChange", &earlychange) && earlychange == 0) // integer, not boolean
-        flags &= ~LZW_EARLY_INDEX;
-      if ((F = iof_filter_lzw_decoder(N, flags)) != NULL)
-      {
-        if (params != NULL)
-        {
-          if ((P = ppstream_predictor(params, F)) != NULL)
-            return P;
-          iof_close(F);
-          break;
-        }
-        return F;
-      }
-      break;
-    case PPSTREAM_CRYPT:
-      if ((cryptkey = stream->cryptkey) == NULL)
-        return N; // /Identity crypt
-      if (stream->flags & PPSTREAM_ENCRYPTED_AES)
-        return iof_filter_aes_decoder(N, cryptkey, ppstring_size(cryptkey));
-      if (stream->flags & PPSTREAM_ENCRYPTED_RC4)
-        return iof_filter_rc4_decoder(N, cryptkey, ppstring_size(cryptkey));
-      return NULL; // if neither AES or RC4 but cryptkey present, something went wrong; see ppstream_info()
-    case PPSTREAM_CCITT:
-    case PPSTREAM_DCT:
-    case PPSTREAM_JBIG2:
-    case PPSTREAM_JPX:
-    case PPSTREAM_UNKNOWN:
-      break;
-  }
-  return NULL;
-}
-
-#define ppstream_image(type) (type == PPSTREAM_DCT || type == PPSTREAM_JBIG2 || PPSTREAM_JPX)
-
-#define ppstream_source(stream) iof_filter_stream_coreader((iof_file *)((stream)->input), (size_t)((stream)->offset), (size_t)((stream)->length))
-#define ppstream_auxsource(filename) iof_filter_file_reader(filename)
-
-static ppname ppstream_filter_name (ppobj *filterobj, size_t index)
-{
-  if (filterobj->type == PPNAME)
-    return index == 0 ? filterobj->name : NULL;
-  if (filterobj->type == PPARRAY)
-    return pparray_get_name(filterobj->array, index);
-  return NULL;
-}
-
-static ppdict * ppstream_filter_params (ppobj *paramsobj, size_t index)
-{
-  if (paramsobj->type == PPDICT)
-    return index == 0 ? paramsobj->dict : NULL;
-  if (paramsobj->type == PPARRAY)
-    return pparray_rget_dict(paramsobj->array, index);
-  return NULL;
-}
-
-static const char * ppstream_aux_filename (ppobj *filespec)
-{ // mockup, here we should decode the string
-  if (filespec->type == PPSTRING)
-  {
-    return (const char *)(filespec->string);
-  }
-  // else might be a dict - todo
-  return NULL;
-}
-
-iof * ppstream_read (ppstream *stream, int decode, int all)
-{
-  ppdict *dict;
-  iof *I, *F;
-  int codectype, external, owncrypt;
-  ppobj *filterobj, *paramsobj, *filespecobj;
-  ppname filter;
-  ppdict *params;
-  size_t index;
-  const char *filename;
-
-  if (ppstream_iof(stream) != NULL)
-    return NULL; // usage error
-
-  dict = stream->dict;
-  if ((filespecobj = ppdict_rget_obj(dict, "F")) != NULL)
-  {
-    filename = ppstream_aux_filename(filespecobj);
-    I = filename != NULL ? ppstream_auxsource(filename) : NULL;
-    external = 1;
-  }
-  else
-  {
-    I = ppstream_source(stream);
-    external = 0;
-  }
-  if (I == NULL)
-    return NULL;
-  /* If the stream is encrypted, decipher is the first to be applied */
-  owncrypt = (stream->flags & PPSTREAM_ENCRYPTED_OWN) != 0;
-  if (!owncrypt)
-  {
-    if (stream->cryptkey != NULL)
-    { /* implied global crypt */
-      if ((F = ppstream_decoder(stream, PPSTREAM_CRYPT, NULL, I)) == NULL)
-        goto stream_error;
-      I = F;
-    } /* otherwise no crypt at all or /Identity */
-  }
-  if (decode || owncrypt)
-  {
-    filterobj = ppdict_rget_obj(dict, external ? "FFilter" : "Filter");
-    if (filterobj != NULL)
-    {
-      paramsobj = ppdict_rget_obj(dict, external ? "FDecodeParms" : "DecodeParms");
-      for (index = 0, filter = ppstream_filter_name(filterobj, 0); filter != NULL; filter = ppstream_filter_name(filterobj, ++index))
-      {
-        params = paramsobj != NULL ? ppstream_filter_params(paramsobj, index) : NULL;
-        codectype = ppstream_codec_type(filter);
-        if ((F = ppstream_decoder(stream, codectype, params, I)) != NULL)
-        {
-          I = F;
-          if (owncrypt && !decode && codectype == PPSTREAM_CRYPT)
-            break; // /Crypt filter should always be first, so in practise we return decrypted but compressed
-          continue;
-        }
-        if (!ppstream_image(codectype)) // something unexpected
-          goto stream_error;
-        else // just treat image data (jpeg/jbig) as the target data
-          break;
-      }
-    }
-  }
-  if (all)
-    iof_load(I);
-  else
-    iof_input(I);
-  stream->I = I;
-  return I;
-stream_error:
-  iof_close(I);
-  return NULL;
-}
-
-uint8_t * ppstream_first (ppstream *stream, size_t *size, int decode)
-{
-  iof *I;
-  if ((I = ppstream_read(stream, decode, 0)) != NULL)
-  {
-    *size = (size_t)iof_left(I);
-    return I->pos;
-  }
-  *size = 0;
-  return NULL;
-}
-
-uint8_t * ppstream_next (ppstream *stream, size_t *size)
-{
-  iof *I;
-  if ((I = ppstream_iof(stream)) != NULL)
-  {
-    I->pos = I->end;
-    if ((*size = iof_input(I)) > 0)
-      return I->pos;
-  }
-  *size = 0;
-  return NULL;
-}
-
-uint8_t * ppstream_all (ppstream *stream, size_t *size, int decode)
-{
-  iof *I;
-  if ((I = ppstream_read(stream, decode, 1)) != NULL)
-  {
-    *size = (size_t)iof_left(I);
-    return I->pos;
-  }
-  *size = 0;
-  return NULL;
-}
-
-void ppstream_done (ppstream *stream)
-{
-  iof *I;
-  if ((I = ppstream_iof(stream)) != NULL)
-  {
-    iof_close(I);
-    stream->I = NULL;
-  }
-}
-
-/* */
-
-void ppstream_init_buffers (void)
-{
-	iof_filters_init();
-}
-
-void ppstream_free_buffers (void)
-{
-	iof_filters_free();
-}
--- texlive-bin.orig/texk/web2c/luatexdir/luapplib/ppstream.h
+++ /dev/null
@@ -1,9 +0,0 @@
-
-#ifndef PP_STREAM_H
-#define PP_STREAM_H
-
-ppstream * ppstream_create (ppdoc *pdf, ppdict *dict, size_t offset);
-iof * ppstream_read (ppstream *stream, int decode, int all);
-#define ppstream_iof(stream) ((iof *)((stream)->I))
-
-#endif
\ No newline at end of file
--- texlive-bin.orig/texk/web2c/luatexdir/luapplib/pptest1.c
+++ /dev/null
@@ -1,86 +0,0 @@
-
-#include <stdio.h>
-#include "ppapi.h"
-
-static const char * sizenum (size_t s)
-{
-  static char buffer[32];
-  if (s < 1000)
-    sprintf(buffer, "%uB", (unsigned)s);
-  else if (s < 1000000)
-    sprintf(buffer, "%.2fkB", (double)(s) / 1000);
-  else
-    sprintf(buffer, "%.2fMB", (double)(s) / 1000000);
-  return buffer;
-}
-
-static const char * crypt_info (ppdoc *pdf)
-{
-	switch (ppdoc_crypt_status(pdf))
-	{
-		case PPCRYPT_NONE:
-			return "none";
-		case PPCRYPT_DONE:
-			return "empty password";
-		case PPCRYPT_PASS:
-			return "nonempty password";
-		default:
-			break;
-	}
-	return "this shouldn't happen";
-}
-
-static void print_info (ppdoc *pdf)
-{
-  ppdict *info;
-  ppstring creator, producer;
-  size_t memused, memwaste;
-
-  if ((info = ppdoc_info(pdf)) != NULL)
-  {
-    if ((creator = ppdict_rget_string(info, "Creator")) != NULL)
-      printf("  creator: %s\n", ppstring_decoded(creator));
-    if ((producer = ppdict_rget_string(info, "Producer")) != NULL)
-      printf("  producer: %s\n", ppstring_decoded(producer));
-  }
-  printf("  version: %s\n", ppdoc_version_string(pdf));
-  printf("  protection: %s\n", crypt_info(pdf));
-  printf("  filesize: %s\n", sizenum(ppdoc_file_size(pdf)));
-  printf("  objects: " PPUINTF "\n", ppdoc_objects(pdf));
-  printf("  pagecount: " PPUINTF "\n", ppdoc_page_count(pdf));
-  memused = ppdoc_memory(pdf, &memwaste);
-  printf("  memused: %s\n", sizenum(memused));
-  printf("  memwaste: %s\n", sizenum(memwaste));
-}
-
-static int usage (const char *argv0)
-{
-	printf("pplib " pplib_version ", " pplib_author "\n");
-	printf("usage: %s file1.pdf file2.pdf ...\n", argv0);
-	return 0;
-}
-
-int main (int argc, const char **argv)
-{
-  const char *filepath;
-  int a;
-  ppdoc *pdf;
-
-  if (argc < 2)
-    return usage(argv[0]);
-  for (a = 1; a < argc; ++a)
-  {
-    filepath = argv[a];
-    printf("loading %s... ", filepath);
-    pdf = ppdoc_load(filepath);
-    if (pdf == NULL)
-    {
-      printf("failed\n");
-      continue;
-    }
-    printf("done.\n");
-    print_info(pdf);
-    ppdoc_free(pdf);
-  }
-  return 0;
-}
--- texlive-bin.orig/texk/web2c/luatexdir/luapplib/pptest2.c
+++ /dev/null
@@ -1,139 +0,0 @@
-
-#include <stdio.h>
-#include <assert.h>
-#include "ppapi.h"
-
-static const char * get_file_name (const char *path)
-{
-  const char *fn, *p;
-  for (fn = p = path; *p != '\0'; ++p)
-    if (*p == '\\' || *p == '/')
-      fn = p + 1;
-  return fn;
-}
-
-static void box_info (ppdict *pagedict, FILE *fh)
-{
-  const char *boxes[] = {"MediaBox", "CropBox", "BleedBox", "TrimBox", "ArtBox"};
-  pprect rect;
-  size_t i;
-  for (i = 0; i < sizeof(boxes) / sizeof(const char *); ++i)
-    if (ppdict_get_box(pagedict, boxes[i], &rect))
-      fprintf(fh, "%%%% %s [%f %f %f %f]\n", boxes[i], rect.lx, rect.ly, rect.rx, rect.ry);
-}
-
-static int usage (const char *argv0)
-{
-	printf("pplib " pplib_version ", " pplib_author "\n");
-	printf("usage: %s file1.pdf file2.pdf ...\n", argv0);
-	return 0;
-}
-
-#define OUTDIR "."
-
-static void log_callback (const char *message, void *alien)
-{
-	fprintf((FILE *)alien, "\nooops: %s\n", message);
-}
-
-int main (int argc, const char **argv)
-{
-  const char *filepath, *filename;
-  int a;
-  ppdoc *pdf;
-  ppref *pageref;
-  ppdict *pagedict;
-  int pageno;
-  char outname[1024];
-  FILE *fh;
-  ppstream *stream;
-  uint8_t *data;
-  size_t size;
-  ppcontext *context;
-  ppobj *obj;
-  ppname op;
-  size_t operators;
-
-  if (argc < 2)
-    return usage(argv[0]);
-  ppstream_init_buffers();
-  pplog_callback(log_callback, stderr);
-  context = ppcontext_new();
-  for (a = 1; a < argc; ++a)
-  {
-    filepath = argv[a];
-    printf("loading %s... ", filepath);
-    pdf = ppdoc_load(filepath);
-    if (pdf == NULL)
-    {
-      printf("failed\n");
-      continue;
-    }
-    printf("done.\n");
-    switch (ppdoc_crypt_status(pdf))
-    {
-    	case PPCRYPT_NONE:
-    	case PPCRYPT_DONE:
-    		break;
-    	case PPCRYPT_PASS:
-    		if (ppdoc_crypt_pass(pdf, "dummy", 5, NULL, 0) == PPCRYPT_DONE || ppdoc_crypt_pass(pdf, NULL, 0, "dummy", 5) == PPCRYPT_DONE)
-    		  break;
-        printf("sorry, password needed\n");
-        ppdoc_free(pdf);
-        continue;
-    	case PPCRYPT_FAIL:
-    		printf("sorry, encryption failed\n");
-    		ppdoc_free(pdf);
-    		continue;
-    }
-    filename = get_file_name(filepath);
-    sprintf(outname, OUTDIR "/%s.out", filename);
-    fh = fopen(outname, "wb");
-    if (fh == NULL)
-    {
-      printf("can't open %s for writing\n", outname);
-      continue;
-    }
-    for (pageref = ppdoc_first_page(pdf), pageno = 1;
-         pageref != NULL;
-         pageref = ppdoc_next_page(pdf), ++pageno)
-    {
-      pagedict = pageref->object.dict;
-      /* decompress contents data */
-      fprintf(fh, "%%%% PAGE %d\n", pageno);
-      box_info(pagedict, fh);
-      for (stream = ppcontents_first(pagedict);
-           stream != NULL;
-           stream = ppcontents_next(pagedict, stream))
-      {
-        for (data = ppstream_first(stream, &size, 1);
-             data != NULL;
-             data = ppstream_next(stream, &size))
-          fwrite(data, size, 1, fh);
-        ppstream_done(stream);
-      }
-      /* now parse contents */
-      for (stream = ppcontents_first(pagedict);
-           stream != NULL;
-           stream = ppcontents_next(pagedict, stream))
-      {
-        operators = 0;
-        for (obj = ppcontents_first_op(context, stream, &size, &op);
-             obj != NULL;
-             obj = ppcontents_next_op(context, stream, &size, &op))
-          ++operators;
-        fprintf(fh, "%%%% OPERATORS count " PPSIZEF "\n", operators);
-        ppstream_done(stream);
-        //obj = ppcontents_parse(context, stream, &size);
-        //fprintf(fh, "%%%% items count " PPSIZEF "\n", size);
-        fprintf(fh, "\n");
-      }
-      ppcontext_done(context);
-    }
-    fclose(fh);
-    ppdoc_free(pdf);
-  }
-  ppcontext_free(context);
-	ppstream_free_buffers();
-  return 0;
-}
--- texlive-bin.orig/texk/web2c/luatexdir/luapplib/ppxref.c
+++ /dev/null
@@ -1,162 +0,0 @@
-
-#include "pplib.h"
-
-#define PPXREF_MAP_INIT 16 // number of xref sections
-
-ppxref * ppxref_create (ppdoc *pdf, size_t initsize, size_t xrefoffset)
-{
-  ppxref *xref;
-
-  if (initsize == 0) // unknown
-    initsize = PPXREF_MAP_INIT;
-  xref = (ppxref *)ppheap_take(&pdf->heap, sizeof(ppxref) + initsize * sizeof(ppxsec));
-  xref->sects = (ppxsec *)(xref + 1);
-  xref->size = 0;
-  xref->space = initsize;
-  xref->count = 0;
-  xref->trailer.type = PPNONE;
-  xref->trailer.dict = NULL;
-  xref->prev = NULL;
-  xref->pdf = pdf;
-  xref->offset = xrefoffset;
-  //xref->crypt = NULL;
-  return xref;
-}
-
-ppxsec * ppxref_push_section (ppxref *xref, ppheap **pheap)
-{
-  ppxsec *sects;
-  if (xref->size < xref->space)
-    return &xref->sects[xref->size++];
-  xref->space <<= 1;
-  sects = xref->sects;
-  xref->sects = (ppxsec *)ppheap_take(pheap, xref->space * sizeof(ppxsec)); // waste but rare
-  memcpy(xref->sects, sects, xref->size * sizeof(ppxsec));
-  return &xref->sects[xref->size++];
-}
-
-static void ppxref_sort_sects (ppxsec *left, ppxsec *right)
-{
-  ppxsec *l, *r, *m, t;
-  ppuint first, last;
-  l = left, r = right, m = l + ((r - l) / 2);
-  first = m->first, last = m->last;
-  do
-  { // don't take first/last from pointer
-    while (l->first < first) ++l;
-    while (r->first > last) --r;
-    if (l <= r)
-    {
-      t = *l;
-      *l = *r;
-      *r = t;
-      ++l, --r;
-    }
-  } while (l <= r);
-  if (l < right)
-    ppxref_sort_sects(l, right);
-  if (r > left)
-    ppxref_sort_sects(left, r);
-}
-
-int ppxref_sort (ppxref *xref)
-{
-  if (xref->size == 0)
-    return 0;
-  ppxref_sort_sects(xref->sects, xref->sects + xref->size - 1);
-  return 1;
-}
-
-ppref * ppxref_find_local (ppxref *xref, ppuint refnumber)
-{
-  ppxsec *left, *right, *mid;
-  //if (xref->size == 0) // we don't allow that
-  //  return NULL;
-  left = xref->sects;
-  right = xref->sects + xref->size - 1;
-  do
-  {
-    mid = left + ((right - left) / 2);
-    if (refnumber > mid->last)
-      left = mid + 1;
-    else if (refnumber < mid->first)
-      right = mid - 1;
-    else
-      return &mid->refs[refnumber - mid->first];
-  } while (left <= right);
-  return NULL;
-}
-
-ppref * ppxref_find (ppxref *xref, ppuint refnumber)
-{
-  ppref *ref;
-  ppxref *other;
-
-  if ((ref = ppxref_find_local(xref, refnumber)) != NULL)
-    return ref;
-  if (xref->pdf->flags & PPDOC_LINEARIZED)
-  {
-    for (other = xref->pdf->xref; other != NULL; other = other->prev)
-      if (other != xref && (ref = ppxref_find_local(other, refnumber)) != NULL)
-        return ref;
-  }
-  else
-  {
-    for (other = xref->prev; other != NULL; other = other->prev)
-      if ((ref = ppxref_find_local(other, refnumber)) != NULL)
-        return ref;
-    /* This shouldn't happen, but I've met documents that have no linearized dict,
-       but their xrefs are prepared as for linearized; with "older" xrefs referring
-       to "newer". */
-    for (other = xref->pdf->xref; other != NULL && other != xref; other = other->prev)
-      if ((ref = ppxref_find_local(other, refnumber)) != NULL)
-        return ref;
-  }
-  return NULL;
-}
-
-ppdict * ppxref_trailer (ppxref *xref)
-{
-  switch (xref->trailer.type)
-  {
-    case PPDICT:
-      return xref->trailer.dict;
-    case PPSTREAM:
-      return xref->trailer.stream->dict;
-    default:
-      break;
-  }
-  return NULL;
-}
-
-ppxref * ppdoc_xref (ppdoc *pdf)
-{
-	return pdf->xref;
-}
-
-ppxref * ppxref_prev (ppxref *xref)
-{
-	return xref->prev;
-}
-
-ppdict * ppxref_catalog (ppxref *xref)
-{
-	ppdict *trailer;
-	return (trailer = ppxref_trailer(xref)) != NULL ? ppdict_rget_dict(trailer, "Root") : NULL;
-}
-
-ppdict * ppxref_info (ppxref *xref)
-{
-	ppdict *trailer;
-	return (trailer = ppxref_trailer(xref)) != NULL ? ppdict_rget_dict(trailer, "Info") : NULL;
-}
-
-ppref * ppxref_pages (ppxref *xref)
-{
-  ppdict *dict;
-  ppref *ref;
-
-  if ((dict = ppxref_catalog(xref)) == NULL || (ref = ppdict_get_ref(dict, "Pages")) == NULL)
-    return NULL;
-  return ref->object.type == PPDICT ? ref : NULL;
-}
--- texlive-bin.orig/texk/web2c/luatexdir/luapplib/ppxref.h
+++ /dev/null
@@ -1,35 +0,0 @@
-
-#ifndef PP_XREF_H
-#define PP_XREF_H
-
-/*
-What we call xref is actually "xref section" in PDF spec and what we call section is "xref subsection".
-Our ppxref is a list of sections, sorted by xrefsection->first and xrefsection->last bounds. Every section
-keeps a list of ppref *refs, enumerated from xrefsection->first to xrefsection->last. To find a reference
-by number we make a binary search over sections bounds, then jump to the proper ppref *ref.
-*/
-
-typedef struct {
-  ppuint first;     // first reference number in section
-  ppuint last;      // last reference number in section
-  ppref *refs;      // references list
-} ppxsec;
-
-struct ppxref {
-  ppxsec *sects;    // subsections list
-  size_t size;      // actual sections size
-  size_t space;     // available sections space
-  ppobj trailer;    // trailer dict or stream
-  ppuint count;     // count of references in all sections
-  ppxref *prev;     // previous xref
-  ppdoc *pdf;       // parent pdf to access entries in linearized docs
-  size_t offset;    // file offset of xref
-  //ppcrypt *crypt;   // per xref encryption state? 
-};
-
-ppxref * ppxref_create (ppdoc *pdf, size_t initsize, size_t xrefoffset);
-ppxsec * ppxref_push_section (ppxref *xref, ppheap **pheap);
-int ppxref_sort (ppxref *xref);
-ppref * ppxref_find_local (ppxref *xref, ppuint refnumber);
-
-#endif
\ No newline at end of file
--- texlive-bin.orig/texk/web2c/luatexdir/luapplib/util/utilbasexx.c
+++ /dev/null
@@ -1,2108 +0,0 @@
-
-#include "utilnumber.h"
-#include "utilmem.h"
-#include "utilbasexx.h"
-
-/* filters state structs */
-
-struct basexx_state {
-  size_t line, maxline;
-  size_t left;
-  int tail[5];
-  int flush;
-};
-
-struct runlength_state {
-  int run;
-  int flush;
-  int c1, c2;
-  uint8_t *pos;
-};
-
-struct eexec_state {
-  int key;
-  int flush;
-  int binary;
-  int c1;
-  size_t line, maxline; /* ascii encoder only */
-  const char *initbytes;
-};
-
-/* config */
-
-#if defined(BASEXX_PDF)
-#  define ignored(c) (c == 0x20 || c == 0x0A || c == 0x0C || c == 0x0D || c == 0x09 || c == 0x00)
-#  define base16_eof(c) (c == '>' || c < 0)
-#  define base85_eof(c) (c == '~' || c < 0)
-#else
-#  define ignored(c) (c == 0x20 || c == 0x0A || c == 0x0D || c == 0x09)
-#  define base16_eof(c) (c < 0)
-#  define base85_eof(c) (c < 0)
-#endif
-
-#define base64_eof(c) (c == '=' || c < 0)
-
-#define basexx_nl '\x0A'
-#define put_nl(O, line, maxline, n) ((void)((line += n) > maxline && ((line = n), iof_set(O, basexx_nl))))
-
-/* tail macros */
-
-#define set_tail1(state, c1)             (state->left = 1, state->tail[0] = c1)
-#define set_tail2(state, c1, c2)         (state->left = 2, state->tail[0] = c1, state->tail[1] = c2)
-#define set_tail3(state, c1, c2, c3)     (state->left = 3, state->tail[0] = c1, state->tail[1] = c2, state->tail[2] = c3)
-#define set_tail4(state, c1, c2, c3, c4) (state->left = 4, state->tail[0] = c1, state->tail[1] = c2, state->tail[2] = c3, state->tail[3] = c4)
-#define set_tail5(state, c1, c2, c3, c4, c5) \
-  (state->left = 5, state->tail[0] = c1, state->tail[1] = c2, state->tail[2] = c3, state->tail[3] = c4, state->tail[4] = c5)
-
-#define get_tail1(state, c1)             (state->left = 0, c1 = state->tail[0])
-#define get_tail2(state, c1, c2)         (state->left = 0, c1 = state->tail[0], c2 = state->tail[1])
-#define get_tail3(state, c1, c2, c3)     (state->left = 0, c1 = state->tail[0], c2 = state->tail[1], c3 = state->tail[2])
-#define get_tail4(state, c1, c2, c3, c4) (state->left = 0, c1 = state->tail[0], c2 = state->tail[1], c3 = state->tail[2], c4 = state->tail[3])
-
-/* basexx state initialization */
-
-void basexx_state_init_ln (basexx_state *state, size_t line, size_t maxline)
-{
-  state->line = line;
-  state->maxline = maxline;
-  state->left = 0;
-  state->flush = 0;
-}
-
-/* base 16; xxxx|xxxx */
-
-iof_status base16_encoded_uc (const void *data, size_t size, iof *O)
-{
-  const uint8_t *s, *e;
-  for (s = (const uint8_t *)data, e = s + size; s < e; ++s)
-  {
-    if (!iof_ensure(O, 2))
-      return IOFFULL;
-    iof_set_uc_hex(O, *s);
-  }
-  return IOFEOF;
-}
-
-iof_status base16_encoded_lc (const void *data, size_t size, iof *O)
-{
-  const uint8_t *s, *e;
-  for (s = (const uint8_t *)data, e = s + size; s < e; ++s)
-  {
-    if (!iof_ensure(O, 2))
-      return IOFFULL;
-    iof_set_lc_hex(O, *s);
-  }
-  return IOFEOF;
-}
-
-iof_status base16_encoded_uc_ln (const void *data, size_t size, iof *O, size_t line, size_t maxline)
-{
-  const uint8_t *s, *e;
-  for (s = (const uint8_t *)data, e = s + size; s < e; ++s)
-  {
-    if (!iof_ensure(O, 3))
-      return IOFFULL;
-    put_nl(O, line, maxline, 2);
-    iof_set_uc_hex(O, *s);
-  }
-  return IOFFULL;
-}
-
-iof_status base16_encoded_lc_ln (const void *data, size_t size, iof *O, size_t line, size_t maxline)
-{
-  const uint8_t *s, *e;
-  for (s = (const uint8_t *)data, e = s + size; s < e; ++s)
-  {
-    if (!iof_ensure(O, 3))
-      return IOFFULL;
-    put_nl(O, line, maxline, 2);
-    iof_set_lc_hex(O, *s);
-  }
-  return IOFFULL;
-}
-
-iof_status base16_encode_uc (iof *I, iof *O)
-{
-  register int c;
-  while (iof_ensure(O, 2))
-  {
-    if ((c = iof_get(I)) < 0)
-      return IOFEOF;
-    iof_set_uc_hex(O, c);
-  }
-  return IOFFULL;
-}
-
-iof_status base16_encode_state_uc (iof *I, iof *O, basexx_state *state)
-{
-  register int c;
-  while (iof_ensure(O, 2))
-  {
-    if ((c = iof_get(I)) < 0)
-      return (state->flush ? IOFEOF : IOFEMPTY);
-    iof_set_uc_hex(O, c);
-  }
-  return IOFFULL;
-}
-
-iof_status base16_encode_lc (iof *I, iof *O)
-{
-  register int c;
-  while (iof_ensure(O, 2))
-  {
-    if ((c = iof_get(I)) < 0)
-      return IOFEOF;
-    iof_set_lc_hex(O, c);
-  }
-  return IOFFULL;
-}
-
-iof_status base16_encode_state_lc (iof *I, iof *O, basexx_state *state)
-{
-  register int c;
-  while (iof_ensure(O, 2))
-  {
-    if ((c = iof_get(I)) < 0)
-      return (state->flush ? IOFEOF : IOFEMPTY);
-    iof_set_lc_hex(O, c);
-  }
-  return IOFFULL;
-}
-
-iof_status base16_encode_uc_ln (iof *I, iof *O, size_t line, size_t maxline)
-{
-  register int c;
-  while (iof_ensure(O, 3))
-  {
-    if ((c = iof_get(I)) < 0)
-      return IOFEOF;
-    put_nl(O, line, maxline, 2);
-    iof_set_uc_hex(O, c);
-  }
-  return IOFFULL;
-}
-
-iof_status base16_encode_state_uc_ln (iof *I, iof *O, basexx_state *state)
-{
-  register int c;
-  while (iof_ensure(O, 3))
-  {
-    if ((c = iof_get(I)) < 0)
-      return (state->flush ? IOFEOF : IOFEMPTY);
-    put_nl(O, state->line, state->maxline, 2);
-    iof_set_uc_hex(O, c);
-  }
-  return IOFFULL;
-}
-
-iof_status base16_encode_lc_ln (iof *I, iof *O, size_t line, size_t maxline)
-{
-  register int c;
-  while (iof_ensure(O, 3))
-  {
-    if ((c = iof_get(I)) < 0)
-      return IOFEOF;
-    put_nl(O, line, maxline, 2);
-    iof_set_lc_hex(O, c);
-  }
-  return IOFFULL;
-}
-
-iof_status base16_encode_state_lc_ln (iof *I, iof *O, basexx_state *state)
-{
-  register int c;
-  while (iof_ensure(O, 3))
-  {
-    if ((c = iof_get(I)) < 0)
-      return (state->flush ? IOFEOF : IOFEMPTY);
-    put_nl(O, state->line, state->maxline, 2);
-    iof_set_lc_hex(O, c);
-  }
-  return IOFFULL;
-}
-
-int base16_getc (iof *I)
-{
-  register int c1, c2;
-  do { c1 = iof_get(I); } while (ignored(c1));
-  if (base16_eof(c1))
-    return IOFEOF;
-  do { c2 = iof_get(I); } while (ignored(c2));
-  if (base16_eof(c2))
-  {
-    if ((c1 = base16_lookup[c1]) == -1)
-      return IOFERR;
-    return c1<<4;
-  }
-  if ((c1 = base16_lookup[c1]) == -1 || (c2 = base16_lookup[c2]) == -1)
-    return IOFERR;
-  return (c1<<4)|c2;
-}
-
-int base16_lc_putc (iof *O, int c)
-{
-  if (iof_ensure(O, 2))
-    iof_set_lc_hex(O, c);
-  return IOFFULL;
-}
-
-int base16_uc_putc (iof *O, int c)
-{
-  if (iof_ensure(O, 2))
-    iof_set_uc_hex(O, c);
-  return IOFFULL;
-}
-
-
-iof_status base16_decode (iof *I, iof *O)
-{
-  register int c1, c2;
-  while (iof_ensure(O, 1))
-  {
-    do { c1 = iof_get(I); } while (ignored(c1));
-    if (base16_eof(c1))
-      return IOFEOF;
-    do { c2 = iof_get(I); } while (ignored(c2));
-    if (base16_eof(c2))
-    {
-      if ((c1 = base16_lookup[c1]) == -1)
-        return IOFERR;
-      iof_set(O, c1<<4); // c2 := '0'
-      return IOFEOF;
-    }
-    if ((c1 = base16_lookup[c1]) == -1 || (c2 = base16_lookup[c2]) == -1)
-      return IOFERR;
-    iof_set(O, (c1<<4)|c2);
-  }
-  return IOFFULL;
-}
-
-iof_status base16_decode_state (iof *I, iof *O, basexx_state *state)
-{
-  register int c1, c2, d1, d2;
-  if (!(iof_ensure(O, 1)))
-    return IOFFULL;
-  switch(state->left)
-  {
-    case 0: goto byte0;
-    case 1: get_tail1(state, c1); goto byte1;
-  }
-  while (iof_ensure(O, 1))
-  {
-    byte0:
-    do { c1 = iof_get(I); } while (ignored(c1));
-    if (base16_eof(c1))
-      return (state->flush ? IOFEOF : IOFEMPTY);
-    byte1:
-    do { c2 = iof_get(I); } while (ignored(c2));
-    if (base16_eof(c2))
-    {
-      set_tail1(state, c1); /* set tail to let the caller display invalid chars */
-      if (state->flush)
-      {
-        if ((c1 = base16_lookup[c1]) == -1)
-          return IOFERR;
-        iof_set(O, c1<<4); // c2 := '0'
-        return IOFEOF;
-      }
-      return IOFEMPTY;
-    }
-    if ((d1 = base16_lookup[c1]) == -1 || (d2 = base16_lookup[c2]) == -1)
-    {
-      set_tail2(state, c1, c2);
-      return IOFERR;
-    }
-    iof_set(O, (d1<<4)|d2);
-  }
-  return IOFFULL;
-}
-
-/* base 64; xxxxxx|xx xxxx|xxxx xx|xxxxxx */
-
-const char base64_alphabet[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
-
-const int base64_lookup[] = {
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,62,-1,-1,-1,63,
-  52,53,54,55,56,57,58,59,60,61,-1,-1,-1,-1,-1,-1,
-  -1, 0, 1, 2, 3, 4, 5, 6, 7, 8,9 ,10,11,12,13,14,
-  15,16,17,18,19,20,21,22,23,24,25,-1,-1,-1,-1,-1,
-  -1,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,
-  41,42,43,44,45,46,47,48,49,50,51,-1,-1,-1,-1,-1,
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1
-};
-
-#define base64_digit1(c1)     base64_alphabet[c1>>2]
-#define base64_digit2(c1, c2) base64_alphabet[((c1&3)<<4)|(c2>>4)]
-#define base64_digit3(c2, c3) base64_alphabet[((c2&15)<<2)|(c3>>6)]
-#define base64_digit4(c3)     base64_alphabet[c3&63]
-
-#define base64_encode_word(O, c1, c2, c3) \
-  iof_set4(O, base64_digit1(c1), base64_digit2(c1, c2), base64_digit3(c2, c3), base64_digit4(c3))
-
-#define base64_encode_tail2(O, c1, c2) \
-  iof_set3(O, base64_digit1(c1), base64_digit2(c1, c2), base64_digit3(c2, 0))
-
-#define base64_encode_tail1(O, c1) \
-  iof_set2(O, base64_digit1(c1), base64_digit2(c1, 0))
-
-iof_status base64_encoded (const void *data, size_t size, iof *O)
-{
-  const uint8_t *s, *e;
-  uint8_t c1, c2, c3;
-  for (s = (const uint8_t *)data, e = s + size; s + 2 < e; )
-  {
-    if (!iof_ensure(O, 4))
-      return IOFFULL;
-    c1 = *s++;
-    c2 = *s++;
-    c3 = *s++;
-    base64_encode_word(O, c1, c2, c3);
-  }
-  switch (e - s)
-  {
-    case 0:
-      break;
-    case 1:
-      if (!iof_ensure(O, 2))
-        return IOFFULL;
-      c1 = *s;
-      base64_encode_tail1(O, c1);
-      break;
-    case 2:
-      if (!iof_ensure(O, 3))
-        return IOFFULL;
-      c1 = *s++;
-      c2 = *s;
-      base64_encode_tail2(O, c1, c2);
-      break;
-  }
-  return IOFEOF;
-}
-
-iof_status base64_encoded_ln (const void *data, size_t size, iof *O, size_t line, size_t maxline)
-{
-  const uint8_t *s, *e;
-  uint8_t c1, c2, c3;
-  for (s = (const uint8_t *)data, e = s + size; s + 2 < e; )
-  {
-    if (!iof_ensure(O, 5))
-      return IOFFULL;
-    c1 = *s++;
-    c2 = *s++;
-    c3 = *s++;
-    put_nl(O, line, maxline, 4);
-    base64_encode_word(O, c1, c2, c3);
-  }
-  switch (e - s)
-  {
-    case 0:
-      break;
-    case 1:
-      if (!iof_ensure(O, 3))
-        return IOFFULL;
-      c1 = *s;
-      put_nl(O, line, maxline, 2);
-      base64_encode_tail1(O, c1);
-      break;
-    case 2:
-      if (!iof_ensure(O, 4))
-        return IOFFULL;
-      c1 = *s++;
-      c2 = *s;
-      put_nl(O, line, maxline, 3);
-      base64_encode_tail2(O, c1, c2);
-      break;
-  }
-  return IOFEOF;
-}
-
-iof_status base64_encode (iof *I, iof *O)
-{
-  register int c1, c2, c3;
-  while(iof_ensure(O, 4))
-  {
-    if ((c1 = iof_get(I)) < 0)
-      return IOFEOF;
-    if ((c2 = iof_get(I)) < 0)
-    {
-      base64_encode_tail1(O, c1);
-      return IOFEOF;
-    }
-    if ((c3 = iof_get(I)) < 0)
-    {
-      base64_encode_tail2(O, c1, c2);
-      return IOFEOF;
-    }
-    base64_encode_word(O, c1, c2, c3);
-  }
-  return IOFFULL;
-}
-
-iof_status base64_encode_state (iof *I, iof *O, basexx_state *state)
-{
-  register int c1, c2, c3;
-  if (!(iof_ensure(O, 4)))
-    return IOFFULL;
-  switch(state->left)
-  {
-    case 0: goto byte0;
-    case 1: get_tail1(state, c1); goto byte1;
-    case 2: get_tail2(state, c1, c2); goto byte2;
-  }
-  while(iof_ensure(O, 4))
-  {
-    byte0:
-    if ((c1 = iof_get(I)) < 0)
-      return (state->flush ? IOFEOF : IOFEMPTY);
-    byte1:
-    if ((c2 = iof_get(I)) < 0)
-      return (state->flush ? (base64_encode_tail1(O, c1), IOFEOF) : (set_tail1(state, c1), IOFEMPTY));
-    byte2:
-    if ((c3 = iof_get(I)) < 0)
-      return (state->flush ? (base64_encode_tail2(O, c1, c2), IOFEOF) : (set_tail2(state, c1, c2), IOFEMPTY));
-    base64_encode_word(O, c1, c2, c3);
-  }
-  return IOFFULL;
-}
-
-iof_status base64_encode_ln (iof *I, iof *O, size_t line, size_t maxline)
-{
-  register int c1, c2, c3;
-  while(iof_ensure(O, 5))
-  {
-    if ((c1 = iof_get(I)) < 0)
-      return IOFEOF;
-    if ((c2 = iof_get(I)) < 0)
-    {
-      put_nl(O, line, maxline, 2);
-      base64_encode_tail1(O, c1);
-      return IOFEOF;
-    }
-    if ((c3 = iof_get(I)) < 0)
-    {
-      put_nl(O, line, maxline, 3);
-      base64_encode_tail2(O, c1, c2);
-      return IOFEOF;
-    }
-    put_nl(O, line, maxline, 4);
-    base64_encode_word(O, c1, c2, c3);
-  }
-  return IOFFULL;
-}
-
-iof_status base64_encode_state_ln (iof *I, iof *O, basexx_state *state)
-{
-  register int c1, c2, c3;
-  if (!(iof_ensure(O, 5)))
-    return IOFFULL;
-  switch(state->left)
-  {
-    case 0: goto byte0;
-    case 1: get_tail1(state, c1); goto byte1;
-    case 2: get_tail2(state, c1, c2); goto byte2;
-  }
-  while(iof_ensure(O, 5))
-  {
-    byte0:
-    if ((c1 = iof_get(I)) < 0)
-      return (state->flush ? IOFEOF : IOFEMPTY);
-    byte1:
-    if ((c2 = iof_get(I)) < 0)
-      return (state->flush ? (put_nl(O, state->line, state->maxline, 2), base64_encode_tail1(O, c1), IOFEOF) : (set_tail1(state, c1), IOFEMPTY));
-    byte2:
-    if ((c3 = iof_get(I)) < 0)
-      return (state->flush ? (put_nl(O, state->line, state->maxline, 3), base64_encode_tail2(O, c1, c2), IOFEOF) : (set_tail2(state, c1, c2), IOFEMPTY));
-    put_nl(O, state->line, state->maxline, 4);
-    base64_encode_word(O, c1, c2, c3);
-  }
-  return IOFFULL;
-}
-
-// #define base64_code(c1, c2, c3, c4) ((c1<<18)|(c2<<12)|(c3<<6)|c4)
-
-#define base64_decode_word(O, c1, c2, c3, c4) \
-  iof_set3(O, (c1<<2)|(c2>>4), ((c2&15)<<4)|(c3>>2), ((c3&3)<<6)|c4)
-
-#define base64_decode_tail3(O, c1, c2, c3) \
-  iof_set2(O, (c1<<2)|(c2>>4), ((c2&15)<<4)|(c3>>2))
-
-#define base64_decode_tail2(O, c1, c2) \
-  iof_set(O, (c1<<2)|(c2>>4))
-
-iof_status base64_decode (iof *I, iof *O)
-{
-  register int c1, c2, c3, c4;
-  while(iof_ensure(O, 3))
-  {
-    do { c1 = iof_get(I); } while (ignored(c1));
-    if (base64_eof(c1))
-      return IOFEOF;
-    do { c2 = iof_get(I); } while (ignored(c2));
-    if (base64_eof(c2))
-      return IOFERR;
-    do { c3 = iof_get(I); } while (ignored(c3));
-    if (base64_eof(c3))
-    {
-      if ((c1 = base64_lookup[c1]) == -1 || (c2 = base64_lookup[c2]) == -1)
-        return IOFERR;
-      base64_decode_tail2(O, c1, c2);
-      return IOFEOF;
-    }
-    do { c4 = iof_get(I); } while (ignored(c4));
-    if (base64_eof(c4))
-    {
-      if ((c1 = base64_lookup[c1]) == -1 || (c2 = base64_lookup[c2]) == -1 || (c3 = base64_lookup[c3]) == -1)
-        return IOFERR;
-      base64_decode_tail3(O, c1, c2, c3);
-      return IOFEOF;
-    }
-    if ((c1 = base64_lookup[c1]) == -1 || (c2 = base64_lookup[c2]) == -1 ||
-        (c3 = base64_lookup[c3]) == -1 || (c4 = base64_lookup[c4]) == -1)
-          return IOFERR;
-    base64_decode_word(O, c1, c2, c3, c4);
-  }
-  return IOFFULL;
-}
-
-iof_status base64_decode_state (iof *I, iof *O, basexx_state *state)
-{
-  register int c1, c2, c3, c4;
-  register int d1, d2, d3, d4;
-  switch(state->left)
-  {
-    case 0: goto byte0;
-    case 1: get_tail1(state, c1); goto byte1;
-    case 2: get_tail2(state, c1, c2); goto byte2;
-    case 3: get_tail3(state, c1, c2, c3); goto byte3;
-  }
-  while(iof_ensure(O, 3))
-  {
-    byte0:
-    do { c1 = iof_get(I); } while (ignored(c1));
-    if (base64_eof(c1))
-      return (state->flush ? IOFEOF : IOFEMPTY);
-    byte1:
-    do { c2 = iof_get(I); } while (ignored(c2));
-    if (base64_eof(c2))
-    {
-      set_tail1(state, c1); /* set tail to let the caller make padding or display invalid char in case of error */
-      return (state->flush ? IOFERR : IOFEMPTY); /* if state->flush then error; tail must have at least two bytes */
-    }
-    byte2:
-    do { c3 = iof_get(I); } while (ignored(c3));
-    if (base64_eof(c3))
-    {
-      set_tail2(state, c1, c2);
-      if (state->flush)
-      {
-        if ((c1 = base64_lookup[c1]) == -1 || (c2 = base64_lookup[c2]) == -1)
-          return IOFERR;
-        base64_decode_tail2(O, c1, c2);
-        return IOFEOF;
-      }
-      else
-        return IOFEMPTY;
-    }
-    byte3:
-    do { c4 = iof_get(I); } while (ignored(c4));
-    if (base64_eof(c4))
-    {
-      set_tail3(state, c1, c2, c3);
-      if (state->flush)
-      {
-        if ((c1 = base64_lookup[c1]) == -1 || (c2 = base64_lookup[c2]) == -1 || (c3 = base64_lookup[c3]) == -1)
-          return IOFERR;
-        base64_decode_tail3(O, c1, c2, c3);
-        return IOFEOF;
-      }
-      else
-        return IOFEMPTY;
-    }
-    if ((d1 = base64_lookup[c1]) == -1 || (d2 = base64_lookup[c2]) == -1 ||
-        (d3 = base64_lookup[c3]) == -1 || (d4 = base64_lookup[c4]) == -1)
-    {
-      set_tail4(state, c1, c2, c3, c4);
-      return IOFERR;
-    }
-    base64_decode_word(O, d1, d2, d3, d4);
-  }
-  return IOFFULL;
-}
-
-/* base85 */
-
-const char base85_alphabet[] = "!\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstu"; /* for completness, not used below */
-
-const int base85_lookup[] = {
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,
-  15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,
-  31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,
-  47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,
-  63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,
-  79,80,81,82,83,84,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1
-};
-
-#define base85_encode_word(O, code) \
-  (*(O->pos+4) = '!' + code%85, code /= 85, *(O->pos+3) = '!' + code%85, code /= 85, \
-   *(O->pos+2) = '!' + code%85, code /= 85, *(O->pos+1) = '!' + code%85, code /= 85, \
-   *(O->pos)   = '!' + code, \
-   O->pos += 5)
-
-#define base85_encode_tail3(O, code) \
-  (*(O->pos+3) = '!' + code%85, code /= 85, *(O->pos+2) = '!' + code%85, code /= 85, \
-   *(O->pos+1) = '!' + code%85, code /= 85, *(O->pos)   = '!' + code, \
-   O->pos += 4)
-
-#define base85_encode_tail2(O, code) \
-  (*(O->pos+2) = '!' + code%85, code /= 85, *(O->pos+1) = '!' + code%85, code /= 85, \
-   *(O->pos)   = '!' + code, \
-   O->pos += 3)
-
-#define base85_encode_tail1(O, code) \
-  (*(O->pos+1) = '!' + code%85, code /= 85, *(O->pos)   = '!' + code, \
-   O->pos += 2)
-
-iof_status base85_encoded (const void *data, size_t size, iof *O)
-{
-  unsigned int code;
-  const uint8_t *s, *e;
-  uint8_t c1, c2, c3, c4;
-  for (s = (const uint8_t *)data, e = s + size; s + 3 < e; )
-  {
-    if (!iof_ensure(O, 5))
-      return IOFFULL;
-    c1 = *s++;
-    c2 = *s++;
-    c3 = *s++;
-    c4 = *s++;
-    code = (c1<<24)|(c2<<16)|(c3<<8)|c4;
-    if (code == 0)
-    {
-      iof_set(O, 'z');
-      continue;
-    }
-    base85_encode_word(O, code);
-  }
-  switch (e - s)
-  {
-    case 0:
-      break;
-    case 1:
-      if (!iof_ensure(O, 2))
-        return IOFFULL;
-      c1 = *s;
-      code = (c1<<24)/85/85/85;
-      base85_encode_tail1(O, code);
-      break;
-    case 2:
-      if (!iof_ensure(O, 3))
-        return IOFFULL;
-      c1 = *s++;
-      c2 = *s;
-      code = ((c1<<24)|(c2<<16))/85/85;
-      base85_encode_tail2(O, code);
-      break;
-    case 3:
-      if (!iof_ensure(O, 4))
-        return IOFFULL;
-      c1 = *s++;
-      c2 = *s++;
-      c3 = *s;
-      code = ((c1<<24)|(c2<<16)|(c3<<8))/85;
-      base85_encode_tail3(O, code);
-      break;
-  }
-  return IOFEOF;
-}
-
-iof_status base85_encoded_ln (const void *data, size_t size, iof *O, size_t line, size_t maxline)
-{
-  unsigned int code;
-  const uint8_t *s, *e;
-  uint8_t c1, c2, c3, c4;
-  for (s = (const uint8_t *)data, e = s + size; s + 3 < e; )
-  {
-    if (!iof_ensure(O, 6))
-      return IOFFULL;
-    c1 = *s++;
-    c2 = *s++;
-    c3 = *s++;
-    c4 = *s++;
-    code = (c1<<24)|(c2<<16)|(c3<<8)|c4;
-    if (code == 0)
-    {
-      put_nl(O, line, maxline, 1);
-      iof_set(O, 'z');
-      continue;
-    }
-    put_nl(O, line, maxline, 5);
-    base85_encode_word(O, code);
-  }
-  switch (e - s)
-  {
-    case 0:
-      break;
-    case 1:
-      if (!iof_ensure(O, 3))
-        return IOFFULL;
-      c1 = *s;
-      code = (c1<<24)/85/85/85;
-      put_nl(O, line, maxline, 2);
-      base85_encode_tail1(O, code);
-      break;
-    case 2:
-      if (!iof_ensure(O, 4))
-        return IOFFULL;
-      c1 = *s++;
-      c2 = *s;
-      code = ((c1<<24)|(c2<<16))/85/85;
-      put_nl(O, line, maxline, 3);
-      base85_encode_tail2(O, code);
-      break;
-    case 3:
-      if (!iof_ensure(O, 5))
-        return IOFFULL;
-      c1 = *s++;
-      c2 = *s++;
-      c3 = *s;
-      code = ((c1<<24)|(c2<<16)|(c3<<8))/85;
-      put_nl(O, line, maxline, 4);
-      base85_encode_tail3(O, code);
-      break;
-  }
-  return IOFEOF;
-}
-
-iof_status base85_encode (iof *I, iof *O)
-{
-  register int c1, c2, c3, c4;
-  register unsigned int code;
-  while(iof_ensure(O, 5))
-  {
-    if ((c1 = iof_get(I)) < 0)
-      return IOFEOF;
-    if ((c2 = iof_get(I)) < 0)
-    {
-      code = (c1<<24)/85/85/85;
-      base85_encode_tail1(O, code);
-      return IOFEOF;
-    }
-    if ((c3 = iof_get(I)) < 0)
-    {
-      code = ((c1<<24)|(c2<<16))/85/85;
-      base85_encode_tail2(O, code);
-      return IOFEOF;
-    }
-    if ((c4 = iof_get(I)) < 0)
-    {
-      code = ((c1<<24)|(c2<<16)|(c3<<8))/85;
-      base85_encode_tail3(O, code);
-      return IOFEOF;
-    }
-    code = (c1<<24)|(c2<<16)|(c3<<8)|c4;
-    if (code == 0)
-    {
-      iof_set(O, 'z');
-      continue;
-    }
-    /* in btoa 'y' character stays for 0x20202020, but pdf does not support this */
-    /* if (code == 0x20202020)
-    {
-      iof_set(O, 'y');
-      continue;
-    } */
-    base85_encode_word(O, code);
-  }
-  return IOFFULL;
-}
-
-iof_status base85_encode_state (iof *I, iof *O, basexx_state *state)
-{
-  register int c1, c2, c3, c4;
-  register unsigned int code;
-  if (!(iof_ensure(O, 5)))
-    return IOFFULL;
-  switch(state->left)
-  {
-    case 0: goto byte0;
-    case 1: get_tail1(state, c1); goto byte1;
-    case 2: get_tail2(state, c1, c2); goto byte2;
-    case 3: get_tail3(state, c1, c2, c3); goto byte3;
-  }
-  while(iof_ensure(O, 5))
-  {
-    byte0:
-    if ((c1 = iof_get(I)) < 0)
-      return (state->flush ? IOFEOF : IOFEMPTY);
-    byte1:
-    if ((c2 = iof_get(I)) < 0)
-    {
-      set_tail1(state, c1);
-      if (state->flush)
-      {
-        code = (c1<<24)/85/85/85;
-        base85_encode_tail1(O, code);
-        return IOFEOF;
-      }
-      return IOFEMPTY;
-    }
-    byte2:
-    if ((c3 = iof_get(I)) < 0)
-    {
-      set_tail2(state, c1, c2);
-      if (state->flush)
-      {
-        code = ((c1<<24)|(c2<<16))/85/85;
-        base85_encode_tail2(O, code);
-        return IOFEOF;
-      }
-      return IOFEMPTY;
-    }
-    byte3:
-    if ((c4 = iof_get(I)) < 0)
-    {
-      set_tail3(state, c1, c2, c3);
-      if (state->flush)
-      {
-        code = ((c1<<24)|(c2<<16)|(c3<<8))/85;
-        base85_encode_tail3(O, code);
-        return IOFEOF;
-      }
-      return IOFEMPTY;
-    }
-    code = (c1<<24)|(c2<<16)|(c3<<8)|c4;
-    if (code == 0)
-    {
-      iof_set(O, 'z');
-      continue;
-    }
-    base85_encode_word(O, code);
-  }
-  return IOFFULL;
-}
-
-iof_status base85_encode_ln (iof *I, iof *O, size_t line, size_t maxline)
-{
-  register int c1, c2, c3, c4;
-  register unsigned int code;
-  while(iof_ensure(O, 6))
-  {
-    if ((c1 = iof_get(I)) < 0)
-      return IOFEOF;
-    if ((c2 = iof_get(I)) < 0)
-    {
-      code = (c1<<24)/85/85/85;
-      put_nl(O, line, maxline, 2);
-      base85_encode_tail1(O, code);
-      return IOFEOF;
-    }
-    if ((c3 = iof_get(I)) < 0)
-    {
-      code = ((c1<<24)|(c2<<16))/85/85;
-      put_nl(O, line, maxline, 3);
-      base85_encode_tail2(O, code);
-      return IOFEOF;
-    }
-    if ((c4 = iof_get(I)) < 0)
-    {
-      code = ((c1<<24)|(c2<<16)|(c3<<8))/85;
-      put_nl(O, line, maxline, 4);
-      base85_encode_tail3(O, code);
-      return IOFEOF;
-    }
-    code = (c1<<24)|(c2<<16)|(c3<<8)|c4;
-    if (code == 0)
-    {
-      put_nl(O, line, maxline, 1);
-      iof_set(O, 'z');
-      continue;
-    }
-    put_nl(O, line, maxline, 5);
-    base85_encode_word(O, code);
-  }
-  return IOFFULL;
-}
-
-iof_status base85_encode_state_ln (iof *I, iof *O, basexx_state *state)
-{
-  register int c1, c2, c3, c4;
-  register unsigned int code;
-  if (!(iof_ensure(O, 6)))
-    return IOFFULL;
-  switch(state->left)
-  {
-    case 0: goto byte0;
-    case 1: get_tail1(state, c1); goto byte1;
-    case 2: get_tail2(state, c1, c2); goto byte2;
-    case 3: get_tail3(state, c1, c2, c3); goto byte3;
-  }
-  while(iof_ensure(O, 6))
-  {
-    byte0:
-    if ((c1 = iof_get(I)) < 0)
-      return (state->flush ? IOFEOF : IOFEMPTY);
-    byte1:
-    if ((c2 = iof_get(I)) < 0)
-    {
-      set_tail1(state, c1);
-      if (state->flush)
-      {
-        code = (c1<<24)/85/85/85;
-        put_nl(O, state->line, state->maxline, 2);
-        base85_encode_tail1(O, code);
-        return IOFEOF;
-      }
-      return IOFEMPTY;
-    }
-    byte2:
-    if ((c3 = iof_get(I)) < 0)
-    {
-      set_tail2(state, c1, c2);
-      if (state->flush)
-      {
-        code = ((c1<<24)|(c2<<16))/85/85;
-        put_nl(O, state->line, state->maxline, 3);
-        base85_encode_tail2(O, code);
-        return IOFEOF;
-      }
-      return IOFEMPTY;
-    }
-    byte3:
-    if ((c4 = iof_get(I)) < 0)
-    {
-      set_tail3(state, c1, c2, c3);
-      if (state->flush)
-      {
-        code = ((c1<<24)|(c2<<16)|(c3<<8))/85;
-        put_nl(O, state->line, state->maxline, 4);
-        base85_encode_tail3(O, code);
-        return IOFEOF;
-      }
-      return IOFEMPTY;
-    }
-    code = (c1<<24)|(c2<<16)|(c3<<8)|c4;
-    if (code == 0)
-    {
-      put_nl(O, state->line, state->maxline, 1);
-      iof_set(O, 'z');
-      continue;
-    }
-    put_nl(O, state->line, state->maxline, 5);
-    base85_encode_word(O, code);
-  }
-  return IOFFULL;
-}
-
-#define base85_code(c1, c2, c3, c4, c5) ((((c1*85+c2)*85+c3)*85+c4)*85+c5)
-
-iof_status base85_decode (iof *I, iof *O)
-{
-  register int c1, c2, c3, c4, c5;
-  register unsigned int code;
-  while (iof_ensure(O, 4))
-  {
-    do { c1 = iof_get(I); } while (ignored(c1));
-    if (base85_eof(c1))
-      return IOFEOF;
-    switch (c1)
-    {
-      case 'z':
-        iof_set4(O, '\0', '\0', '\0', '\0');
-        continue;
-      case 'y':
-        iof_set4(O, ' ', ' ', ' ', ' ');
-        continue;
-    }
-    do { c2 = iof_get(I); } while (ignored(c2));
-    if (base85_eof(c2))
-      return IOFERR;
-    do { c3 = iof_get(I); } while (ignored(c3));
-    if (base85_eof(c3))
-    {
-      if ((c1 = base85_lookup[c1]) == -1 || (c2 = base85_lookup[c2]) == -1)
-        return IOFERR;
-      code = base85_code(c1, c2, 84, 84, 84); /* padding with 'u' (117); 117-33 = 84 */
-      iof_set(O, code>>24);
-      return IOFEOF;
-    }
-    do { c4 = iof_get(I); } while (ignored(c4));
-    if (base85_eof(c4))
-    {
-      if ((c1 = base85_lookup[c1]) == -1 || (c2 = base85_lookup[c2]) == -1 || (c3 = base85_lookup[c3]) == -1)
-        return IOFERR;
-      code = base85_code(c1, c2, c3, 84, 84);
-      iof_set2(O, code>>24, (code>>16)&255);
-      return IOFEOF;
-    }
-    do { c5 = iof_get(I); } while (ignored(c5));
-    if (base85_eof(c5))
-    {
-      if ((c1 = base85_lookup[c1]) == -1 || (c2 = base85_lookup[c2]) == -1 ||
-          (c3 = base85_lookup[c3]) == -1 || (c4 = base85_lookup[c4]) == -1)
-        return IOFERR;
-      code = base85_code(c1, c2, c3, c4, 84);
-      iof_set3(O, code>>24, (code>>16)&255, (code>>8)&255);
-      return IOFEOF;
-    }
-    if ((c1 = base85_lookup[c1]) == -1 || (c2 = base85_lookup[c2]) == -1 || (c3 = base85_lookup[c3]) == -1 ||
-        (c4 = base85_lookup[c4]) == -1 || (c5 = base85_lookup[c5]) == -1)
-      return IOFERR;
-    code = base85_code(c1, c2, c3, c4, c5);
-    iof_set4(O, code>>24, (code>>16)&255, (code>>8)&255, code&255);
-  }
-  return IOFFULL;
-}
-
-iof_status base85_decode_state (iof *I, iof *O, basexx_state *state)
-{
-  register int c1, c2, c3, c4, c5;
-  register int d1, d2, d3, d4, d5;
-  register unsigned int code;
-  if (!(iof_ensure(O, 4)))
-    return IOFFULL;
-  switch(state->left)
-  {
-    case 0: goto byte0;
-    case 1: get_tail1(state, c1); goto byte1;
-    case 2: get_tail2(state, c1, c2); goto byte2;
-    case 3: get_tail3(state, c1, c2, c3); goto byte3;
-    case 4: get_tail4(state, c1, c2, c3, c4); goto byte4;
-  }
-  while (iof_ensure(O, 4))
-  {
-    byte0:
-    do { c1 = iof_get(I); } while (ignored(c1));
-    if (base85_eof(c1))
-      return (state->flush ? IOFEOF : IOFEMPTY);
-    switch (c1)
-    {
-      case 'z':
-        iof_set4(O, '\0', '\0', '\0', '\0');
-        continue;
-      case 'y':
-        iof_set4(O, ' ', ' ', ' ', ' ');
-        continue;
-    }
-    byte1:
-    do { c2 = iof_get(I); } while (ignored(c2));
-    if (base85_eof(c2))
-    {
-      set_tail1(state, c1);
-      return (state->flush ? IOFERR : IOFEMPTY); /* if state->flush then error; tail must have at least two bytes */
-    }
-    byte2:
-    do { c3 = iof_get(I); } while (ignored(c3));
-    if (base85_eof(c3))
-    {
-      set_tail2(state, c1, c2);
-      if (state->flush)
-      {
-        if ((c1 = base85_lookup[c1]) == -1 || (c2 = base85_lookup[c2]) == -1)
-          return IOFERR;
-        code = base85_code(c1, c2, 84, 84, 84);
-        iof_set(O, code>>24);
-        return IOFEOF;
-      }
-      return IOFEMPTY;
-    }
-    byte3:
-    do { c4 = iof_get(I); } while (ignored(c4));
-    if (base85_eof(c4))
-    {
-      set_tail3(state, c1, c2, c3);
-      if (state->flush)
-      {
-        if ((c1 = base85_lookup[c1]) == -1 || (c2 = base85_lookup[c2]) == -1 || (c3 = base85_lookup[c3]) == -1)
-          return IOFERR;
-        code = base85_code(c1, c2, c3, 84, 84);
-        iof_set2(O, code>>24, (code>>16)&255);
-        return IOFEOF;
-      }
-      return IOFEMPTY;
-    }
-    byte4:
-    do { c5 = iof_get(I); } while (ignored(c5));
-    if (base85_eof(c5))
-    {
-      set_tail4(state, c1, c2, c3, c4);
-      if (state->flush)
-      {
-        if ((c1 = base85_lookup[c1]) == -1 || (c2 = base85_lookup[c2]) == -1 ||
-            (c3 = base85_lookup[c3]) == -1 || (c4 = base85_lookup[c4]) == -1)
-          return IOFERR;
-        code = base85_code(c1, c2, c3, c4, 84);
-        iof_set3(O, code>>24, (code>>16)&255, (code>>8)&255);
-        return IOFEOF;
-      }
-      return IOFEMPTY;
-    }
-    if ((d1 = base85_lookup[c1]) == -1 || (d2 = base85_lookup[c2]) == -1 || (d3 = base85_lookup[c3]) == -1 ||
-        (d4 = base85_lookup[c4]) == -1 || (d5 = base85_lookup[c5]) == -1)
-    {
-      set_tail5(state, c1, c2, c3, c4, c5);
-      return IOFERR;
-    }
-    code = base85_code(d1, d2, d3, d4, d5);
-    iof_set4(O, code>>24, (code>>16)&255, (code>>8)&255, code&255);
-  }
-  return IOFFULL;
-}
-
-/* postscript run length */
-
-void runlength_state_init (runlength_state *state)
-{
-  state->run = -1;
-  state->flush = 0;
-  state->c1 = 0;
-  state->c2 = 0;
-  state->pos = NULL;
-}
-
-iof_status runlength_encode (iof *I, iof *O)
-{
-  register int c1, c2, run = -1;
-  uint8_t *pos;
-  c1 = 0; /* avoid warning */
-  while (iof_ensure(O, 1+128+1))
-  { /* ensured space for single length byte, up to 128 bytes to be copied, possible eod marker */
-    pos = O->pos++;
-    switch (run)
-    {
-      case -1: /* initial state; get first byte */
-        if ((c1 = iof_get(I)) < 0)
-          return (*pos = 128, IOFEOF);
-        run = 0;
-        // fall through
-      case 0: /* `repeat' state; get another byte and compare */
-        if ((c2 = iof_get(I)) < 0)
-          return (*pos = 0, iof_set2(O, c1, 128), IOFEOF);
-        run = (c1 == c2 ? 257-2 : 0);
-        break;
-    }
-    if (run < 128)
-    { /* single length byte, up to 128 bytes to be copied, possible eod marker */
-      iof_set(O, c1);
-      for (c1 = c2, c2 = iof_char(I); c1 != c2 && run < 127; c1 = c2, c2 = iof_next(I))
-      {
-        if (c2 < 0) /* O->pos must not change until next call to calling encoder!!! */
-          return (*pos = (uint8_t)run+1, iof_set2(O, c1, 128), IOFEOF);
-        iof_set(O, c1);
-        ++run;
-      }
-    }
-    else // if run > 128
-    {
-      for (c2 = iof_get(I); c1 == c2 && run > 129; c2 = iof_get(I))
-        --run;
-      if (c2 < 0)
-        return (*pos = (uint8_t)run, iof_set2(O, c1, 128), IOFEOF);
-      iof_set(O, c1);
-    }
-    *pos = (uint8_t)run;
-    c1 = c2;
-    run = 0;
-  }
-  return IOFFULL;
-}
-
-iof_status runlength_encode_state (iof *I, iof *O, runlength_state *state)
-{
-  while (iof_ensure(O, 3)) /* single length byte, the byte to be repeated and eod */
-  {
-    state->pos = O->pos++;
-    switch (state->run)
-    {
-      case -1: /* initial state; get first byte */
-        if ((state->c1 = iof_get(I)) < 0)
-          return (state->flush ? (*state->pos = 128, IOFEOF) : IOFEMPTY);
-        state->run = 0;
-        // fall through
-      case 0: /* `repeat' state; get another byte and compare */
-        if ((state->c2 = iof_get(I)) < 0)
-          return (state->flush ? (*state->pos = 0, iof_set2(O, state->c1, 128), IOFEOF) : IOFEMPTY);
-        state->run = (state->c1 == state->c2 ? 257-2 : 0);
-        break;
-    }
-    if (state->run < 128)
-    { /* ensure space for single length byte, up to 128 bytes to be copied, plus possible eod marker, minus those already copied */
-      if (!iof_ensure(O, 1+128+1-state->run))
-        return IOFFULL;
-      iof_set(O, state->c1);
-      for (state->c1 = state->c2, state->c2 = iof_char(I);
-           state->c1 != state->c2 && state->run < 127;
-           state->c1 = state->c2, state->c2 = iof_next(I))
-      {
-        if (state->c2 < 0) /* O->pos must not change until next call to calling encoder!!! */
-          return (state->flush ? (*state->pos = (uint8_t)state->run+1, iof_set2(O, state->c1, 128), IOFEOF) : IOFEMPTY);
-        iof_set(O, state->c1);
-        ++state->run;
-      }
-    }
-    else // if run > 128
-    {
-      for (state->c2 = iof_get(I); state->c1 == state->c2 && state->run > 129; state->c2 = iof_get(I))
-        --state->run;
-      if (state->c2 < 0)
-        return (state->flush ? (*state->pos = (uint8_t)state->run, iof_set2(O, state->c1, 128), IOFEOF) : IOFEMPTY);
-      iof_set(O, state->c1);
-    }
-    *state->pos = (uint8_t)state->run;
-    state->c1 = state->c2;
-    state->run = 0;
-  }
-  return IOFFULL;
-}
-
-iof_status runlength_decode (iof *I, iof *O)
-{
-  register int c, run = -1;
-  while (1)
-  {
-    if (run == -1) /* initial state */
-    {
-      if ((run = iof_get(I)) < 0)
-      {
-        run = -1; /* don't assume IOFEOF == -1 */
-        return IOFEOF;
-      }
-    }
-    if (run < 128)
-    { /* copy (run + 1) following bytes */
-      while (run > -1)
-      {
-        if (iof_ensure(O, 1))
-        {
-          if ((c = iof_get(I)) < 0)
-            return IOFERR;
-          iof_set(O, c);
-          --run;
-          continue;
-        }
-        return IOFFULL;
-      }
-    }
-    else if (run > 128)
-    { /* replicate the following byte (257 - run) times */
-      if ((c = iof_get(I)) < 0) /* cf. state-wise version; don't change input position until we got this byte */
-        return IOFERR;
-      while (run < 257)
-      {
-        if (iof_ensure(O, 1))
-        {
-          iof_set(O, c);
-          ++run;
-          continue;
-        }
-        return IOFFULL;
-      }
-      run = -1;
-    }
-    else // c == 128
-      return IOFEOF;
-  }
-  // return IOFFULL;
-}
-
-iof_status runlength_decode_state (iof *I, iof *O, runlength_state *state)
-{
-  register int c;
-  while (1)
-  {
-    if (state->run == -1) /* initial state */
-    {
-      if ((state->run = iof_char(I)) < 0)
-      {
-        state->run = -1; /* don't assume IOFEOF == -1 */
-        return (state->flush ? IOFEOF : IOFEMPTY);
-      }
-      ++I->pos;
-    }
-    if (state->run < 128)
-    { /* copy (state->run + 1) following bytes */
-      while (state->run > -1)
-      {
-        if (iof_ensure(O, 1))
-        {
-          if ((c = iof_char(I)) < 0)
-            return (state->flush ? IOFERR : IOFEMPTY);
-          ++I->pos;
-          iof_set(O, c);
-          --state->run;
-          continue;
-        }
-        return IOFFULL;
-      }
-    }
-    else if (state->run > 128)
-    { /* replicate the following byte (257 - state->run) times */
-      if ((c = iof_char(I)) < 0)
-        return (state->flush ? IOFERR : IOFEMPTY);
-      ++I->pos;
-      while (state->run < 257)
-      {
-        if (iof_ensure(O, 1))
-        {
-          iof_set(O, c);
-          ++state->run;
-          continue;
-        }
-        return IOFFULL;
-      }
-      state->run = -1;
-    }
-    else // c == 128
-      return IOFEOF;
-  }
-  // return IOFFULL;
-}
-
-/* eexec stream filter, type1 fonts spec page 63 */
-
-void eexec_state_init_ln (eexec_state *state, size_t line, size_t maxline, const char *initbytes)
-{
-  state->key = -1;
-  state->flush = 0;
-  state->binary = maxline > 0;
-  state->c1 = -1;
-  state->line = line;
-  state->maxline = maxline;
-  state->initbytes = initbytes;
-}
-
-#define eexec_getc(I, c1) if ((c1 = iof_get(I)) < 0) return c1
-#define eexec_key(key, c1) (key = ((((c1) + key)*52845 + 22719) & 65535))
-#define eexec_decipher(key, c1, c) (c = ((c1)^(key>>8)), eexec_key(key, c1))
-#define eexec_encipher(key, c1, c) (c = ((c1)^(key>>8)), eexec_key(key, c))
-
-#ifndef lps_ignored_char
-#  define lps_ignored_char(c) (c == 0x20 || c == 0x0A || c == 0x0C || c == 0x0D || c == 0x09 || c == 0x00)
-#endif
-
-#define eexec_getx_(I, c) \
-  do { c = iof_get(I); } while (lps_ignored_char(c)); \
-  if (c < 0) return IOFEOF; \
-  if ((c = base16_lookup[c]) < 0) return IOFERR
-
-#define eexec_getx(I, c1, c2) eexec_getx_(I, c1); \
-  do { c2 = iof_get(I); } while (lps_ignored_char(c2)); \
-  if (c2 < 0) c2 = 0; else \
-  if ((c2 = base16_lookup[c2]) < 0) return IOFERR
-
-static int eexec_decode_init (iof *I, int *key, int *binary)
-{
-  int c1, c2, c3, c4;
-  *key = 55665;
-  eexec_getc(I, c1);
-  eexec_getc(I, c2);
-  eexec_getc(I, c3);
-  eexec_getc(I, c4); /* four head bytes */
-
-  /* eexec data has no explicit data termination. The caller of eexec_decode() should ensure that either
-  the input iof allows to read no more then necessary, or the output has no more space then 512 bytes,
-  to land safely somewhere in 512 bytes that probably follows eexec */
-
-  *binary = (base16_lookup[c1] < 0 || base16_lookup[c2] < 0 ||
-             base16_lookup[c3] < 0 || base16_lookup[c4] < 0);
-  if (*binary)
-  { /* gobble 4 random bytes keeping decipher key up-to-date */
-    eexec_key(*key, c1); eexec_key(*key, c2);
-    eexec_key(*key, c3); eexec_key(*key, c4);
-  }
-  else /* pfa/postscript only, pdf requires binary eexec form */
-  { /* gobble 4 random bytes (8 hex digits) keeping decipher key up-to-date */
-    c1 = base16_lookup[c1], c2 = base16_lookup[c2], c3 = base16_lookup[c3], c4 = base16_lookup[c4];
-    eexec_key(*key, (c1<<4)|c2); eexec_key(*key, (c3<<4)|c4); /* dummy bytes 1, 2 */
-    eexec_getx(I, c1, c2); eexec_getx(I, c3, c4);
-    eexec_key(*key, (c1<<4)|c2); eexec_key(*key, (c3<<4)|c4); /* dummy bytes 3, 4 */
-  }
-  return 0;
-}
-
-iof_status eexec_decode (iof *I, iof *O)
-{
-  int c, c1, c2, key, binary, status;
-  if ((status = eexec_decode_init(I, &key, &binary)) < 0)
-    return status;
-  if (binary)
-  {
-    while (iof_ensure(O, 1))
-    {
-      eexec_getc(I, c1);
-      eexec_decipher(key, c1, c);
-      iof_set(O, c);
-    }
-  }
-  else
-  {
-    while (iof_ensure(O, 1))
-    {
-      eexec_getx(I, c1, c2);
-      eexec_decipher(key, (c1<<4)|c2, c);
-      iof_set(O, c);
-    }
-  }
-  return IOFFULL;
-}
-
-iof_status eexec_decode_state (iof *I, iof *O, eexec_state *state)
-{
-  register int c, c1, c2, status;
-  if (state->key == -1) /* initial state */
-    if ((status = eexec_decode_init(I, &state->key, &state->binary)) < 0)
-      return status;
-  if (state->binary)
-  {
-    while (iof_ensure(O, 1))
-    {
-      if ((c1 = iof_get(I)) < 0)
-        return (state->flush ? IOFEOF : IOFEMPTY);
-      else if (c1 < 0)
-        return c1;
-      eexec_decipher(state->key, c1, c);
-      iof_set(O, c);
-    }
-  }
-  else
-  {
-    if (state->c1 > -1)
-    {
-      c1 = state->c1;
-      state->c1 = -1;
-      goto byte2;
-    }
-    while (iof_ensure(O, 1))
-    {
-      eexec_getx_(I, c1);
-      byte2:
-      do { c2 = iof_get(I); } while (lps_ignored_char(c2));
-      if (c2 < 0) // odd number of hex bytes? hmm... assume c2 is zero
-      {
-        if (state->flush)
-        {
-          eexec_decipher(state->key, (c1<<4), c);
-          iof_set(O, c);
-          return IOFEOF;
-        }
-        state->c1 = c1;
-        return IOFEMPTY;
-      }
-      else if (c2 < 0)
-        return c2;
-      if ((c2 = base16_lookup[c2]) < 0)
-        return IOFERR;
-      eexec_decipher(state->key, (c1<<4)|c2, c);
-      iof_set(O, c);
-    }
-  }
-  return IOFFULL;
-}
-
-#define EEXEC_INIT_BYTES ""
-
-iof_status eexec_encode (iof *I, iof *O, size_t line, size_t maxline)
-{
-  int c1, c, key;
-  const char *p;
-
-  key = 55665;
-  p = EEXEC_INIT_BYTES;
-  if (maxline == 0)
-  {
-    if (!iof_ensure(O, 4))
-      return IOFFULL;
-    eexec_encipher(key, p[0], c); iof_set(O, c);
-    eexec_encipher(key, p[1], c); iof_set(O, c);
-    eexec_encipher(key, p[2], c); iof_set(O, c);
-    eexec_encipher(key, p[3], c); iof_set(O, c);
-    while (iof_ensure(O, 1))
-    {
-      eexec_getc(I, c1);
-      eexec_encipher(key, c1, c);
-      iof_set(O, c);
-    }
-  }
-  else
-  {
-    if (!iof_ensure(O, 8 + 1))
-      return IOFFULL;
-    eexec_encipher(key, p[0], c); put_nl(O, line, maxline, 2); iof_set_uc_hex(O, c);
-    eexec_encipher(key, p[1], c); put_nl(O, line, maxline, 2); iof_set_uc_hex(O, c);
-    eexec_encipher(key, p[2], c); put_nl(O, line, maxline, 2); iof_set_uc_hex(O, c);
-    eexec_encipher(key, p[3], c); put_nl(O, line, maxline, 2); iof_set_uc_hex(O, c);
-    while (iof_ensure(O, 2 + 1))
-    {
-      eexec_getc(I, c1);
-      eexec_encipher(key, c1, c);
-      put_nl(O, line, maxline, 2);
-      iof_set_uc_hex(O, c);
-    }
-  }
-  return IOFFULL;
-}
-
-iof_status eexec_encode_state (iof *I, iof *O, eexec_state *state)
-{
-  int c, c1;
-  const char *p;
-
-  if (state->key == -1)
-  {
-    p = state->initbytes != NULL ? state->initbytes : EEXEC_INIT_BYTES;
-    if (state->binary)
-    {
-      if (!iof_ensure(O, 4))
-        return IOFFULL;
-      state->key = 55665;
-      eexec_encipher(state->key, p[0], c); iof_set(O, c);
-      eexec_encipher(state->key, p[1], c); iof_set(O, c);
-      eexec_encipher(state->key, p[2], c); iof_set(O, c);
-      eexec_encipher(state->key, p[3], c); iof_set(O, c);
-    }
-    else
-    {
-      if (!iof_ensure(O, 8 + 1))
-        return IOFFULL;
-      state->key = 55665;
-      eexec_encipher(state->key, p[0], c); put_nl(O, state->line, state->maxline, 2); iof_set_uc_hex(O, c);
-      eexec_encipher(state->key, p[1], c); put_nl(O, state->line, state->maxline, 2); iof_set_uc_hex(O, c);
-      eexec_encipher(state->key, p[2], c); put_nl(O, state->line, state->maxline, 2); iof_set_uc_hex(O, c);
-      eexec_encipher(state->key, p[3], c); put_nl(O, state->line, state->maxline, 2); iof_set_uc_hex(O, c);
-    }
-  }
-  if (state->binary)
-  {
-    while (iof_ensure(O, 1))
-    {
-      if ((c1 = iof_get(I)) < 0)
-        return c1 < 0 ? (state->flush ? IOFEOF : IOFEMPTY) : c1;
-      eexec_encipher(state->key, c1, c);
-      iof_set(O, c);
-    }
-  }
-  else
-  {
-    while (iof_ensure(O, 2 + 1))
-    {
-      if ((c1 = iof_get(I)) < 0)
-        return c1 < 0 ? (state->flush ? IOFEOF : IOFEMPTY) : c1;
-      eexec_encipher(state->key, c1, c);
-      put_nl(O, state->line, state->maxline, 2);
-      iof_set_uc_hex(O, c);
-    }
-  }
-  return IOFFULL;
-}
-
-/*
-Type1 charstrings are encoded/decoded in the same way, except that:
-- initial key is 4330
-- initbytes might be other then 4; /lenIV key in Private dict
-Type1 spec page 63. In practise we don't need iof interface here,
-we always apply the codec in place.
-*/
-
-#define type1chstr_key(key, c1) (key = ((((c1) + key)*52845 + 22719) & 65535))
-#define type1chstr_decipher(key, c1, c) (c = ((c1)^(key>>8)), type1chstr_key(key, c1))
-#define type1chstr_encipher(key, c1, c) (c = ((c1)^(key>>8)), type1chstr_key(key, c))
-
-int type1_charstring_decode (void *data, size_t size, void *outdata, uint8_t leniv)
-{ /* data and outdata may be the same, output size is always size - leniv */
-  uint8_t *input = (uint8_t *)data, *output = (uint8_t *)outdata;
-  size_t i;
-  int c, c1, key;
-
-  if (size < 4)
-    return 0;
-  key = 4330;
-  for (i = 0; i < leniv; ++i)
-  {
-    c1 = input[i];
-    type1chstr_key(key, c1);
-  }
-  for ( ; i < size; ++i)
-  {
-    c1 = input[i];
-    type1chstr_decipher(key, c1, c);
-    output[i - leniv] = c;
-  }
-  return 1;
-}
-
-#define TYPE1_CHSTR_INIT_BYTES EEXEC_INIT_BYTES
-
-int type1_charstring_encode (void *data, size_t size, void *outdata, uint8_t leniv)
-{ /* outdata may be data - leniv, output size is always size + leniv */
-  uint8_t *input = (uint8_t *)data, *output = (uint8_t *)outdata;
-  size_t i, j;
-  int c, c1, key;
-
-  key = 4330;
-  for (i = 0, j = 0; i < leniv; ++i)
-  {
-    c1 = TYPE1_CHSTR_INIT_BYTES[j];
-    //type1chstr_key(key, c1);
-    type1chstr_encipher(key, c1, c);
-    if (++j == 4)
-      j = 0;
-    output[i] = c;
-  }
-  for (i = 0; i < size; ++i)
-  {
-    c1 = input[i];
-    type1chstr_encipher(key, c1, c);
-    output[i + leniv] = c;
-  }
-  return 1;
-}
-
-/* filters */
-
-// base16 decoder function
-
-static size_t base16_decoder (iof *F, iof_mode mode)
-{
-  basexx_state *state;
-  iof_status status;
-  size_t tail;
-
-  switch(mode)
-  {
-    case IOFLOAD:
-    case IOFREAD:
-      if (F->flags & IOF_STOPPED)
-        return 0;
-      tail = iof_tail(F);
-      F->pos = F->buf + tail;
-      F->end = F->buf + F->space;
-      state = iof_filter_state(basexx_state *, F);
-      do {
-        status = base16_decode_state(F->next, F, state);
-      } while (mode == IOFLOAD && status == IOFFULL && iof_resize_buffer(F));
-      return iof_decoder_retval(F, "base16", status);
-    case IOFCLOSE:
-      iof_free(F);
-      return 0;
-    default:
-      break;
-  }
-  return 0;
-}
-
-// base16 encoder function
-
-static size_t base16_encoder (iof *F, iof_mode mode)
-{
-  basexx_state *state;
-  iof_status status;
-
-  state = iof_filter_state(basexx_state *, F);
-  switch (mode)
-  {
-    case IOFFLUSH:
-      state->flush = 1;
-      // fall through
-    case IOFWRITE:
-      F->end = F->pos;
-      F->pos = F->buf;
-      status = base16_encode_state_ln(F, F->next, state);
-      return iof_encoder_retval(F, "base16", status);
-    case IOFCLOSE:
-      if (!state->flush)
-        base16_encoder(F, IOFFLUSH);
-      iof_free(F);
-      return 0;
-    default:
-      break;
-  }
-  return 0;
-}
-
-// base64 decoder function
-
-static size_t base64_decoder (iof *F, iof_mode mode)
-{
-  basexx_state *state;
-  iof_status status;
-  size_t tail;
-
-  switch(mode)
-  {
-    case IOFLOAD:
-    case IOFREAD:
-      if (F->flags & IOF_STOPPED)
-        return 0;
-      tail = iof_tail(F);
-      F->pos = F->buf + tail;
-      F->end = F->buf + F->space;
-      state = iof_filter_state(basexx_state *, F);
-      do {
-        status = base64_decode_state(F->next, F, state);
-      } while (mode == IOFLOAD && status == IOFFULL && iof_resize_buffer(F));
-      return iof_decoder_retval(F, "base64", status);
-    case IOFCLOSE:
-      iof_free(F);
-      return 0;
-    default:
-      break;
-  }
-  return 0;
-}
-
-// base64 encoder function
-
-static size_t base64_encoder (iof *F, iof_mode mode)
-{
-  basexx_state *state;
-  iof_status status;
-
-  state = iof_filter_state(basexx_state *, F);
-  switch (mode)
-  {
-    case IOFFLUSH:
-      state->flush = 1;
-      // fall through
-    case IOFWRITE:
-      F->end = F->pos;
-      F->pos = F->buf;
-      status = base64_encode_state_ln(F, F->next, state);
-      return iof_encoder_retval(F, "base64", status);
-    case IOFCLOSE:
-      if (!state->flush)
-        base64_encoder(F, IOFFLUSH);
-      iof_free(F);
-      return 0;
-    default:
-      break;
-  }
-  return 0;
-}
-
-// base85 decoder function
-
-static size_t base85_decoder (iof *F, iof_mode mode)
-{
-  basexx_state *state;
-  iof_status status;
-  size_t tail;
-
-  switch(mode)
-  {
-    case IOFLOAD:
-    case IOFREAD:
-      if (F->flags & IOF_STOPPED)
-        return 0;
-      tail = iof_tail(F);
-      F->pos = F->buf + tail;
-      F->end = F->buf + F->space;
-      state = iof_filter_state(basexx_state *, F);
-      do {
-        status = base85_decode_state(F->next, F, state);
-      } while (mode == IOFLOAD && status == IOFFULL && iof_resize_buffer(F));
-      return iof_decoder_retval(F, "base85", status);
-    case IOFCLOSE:
-      iof_free(F);
-      return 0;
-    default:
-      break;
-  }
-  return 0;
-}
-
-// base85 encoder function
-
-static size_t base85_encoder (iof *F, iof_mode mode)
-{
-  basexx_state *state;
-  iof_status status;
-
-  state = iof_filter_state(basexx_state *, F);
-  switch (mode)
-  {
-    case IOFFLUSH:
-      state->flush = 1;
-      // fall through
-    case IOFWRITE:
-      F->end = F->pos;
-      F->pos = F->buf;
-      status = base85_encode_state_ln(F, F->next, state);
-      return iof_encoder_retval(F, "base85", status);
-    case IOFCLOSE:
-      if (!state->flush)
-        base85_encoder(F, IOFFLUSH);
-      iof_free(F);
-      return 0;
-    default:
-      break;
-  }
-  return 0;
-}
-
-// runlength decoder function
-
-static size_t runlength_decoder (iof *F, iof_mode mode)
-{
-  runlength_state *state;
-  iof_status status;
-  size_t tail;
-
-  switch(mode)
-  {
-    case IOFLOAD:
-    case IOFREAD:
-      if (F->flags & IOF_STOPPED)
-        return 0;
-      tail = iof_tail(F);
-      F->pos = F->buf + tail;
-      F->end = F->buf + F->space;
-      state = iof_filter_state(runlength_state *, F);
-      do {
-        status = runlength_decode_state(F->next, F, state);
-      } while (mode == IOFLOAD && status == IOFFULL && iof_resize_buffer(F));
-      return iof_decoder_retval(F, "runlength", status);
-    case IOFCLOSE:
-      iof_free(F);
-      return 0;
-    default:
-      break;
-  }
-  return 0;
-}
-
-// runlength encoder function
-
-static size_t runlength_encoder (iof *F, iof_mode mode)
-{
-  runlength_state *state;
-  iof_status status;
-
-  state = iof_filter_state(runlength_state *, F);
-  switch (mode)
-  {
-    case IOFFLUSH:
-      state->flush = 1;
-      // fall through
-    case IOFWRITE:
-      F->end = F->pos;
-      F->pos = F->buf;
-      status = runlength_encode_state(F, F->next, state);
-      return iof_encoder_retval(F, "runlength", status);
-    case IOFCLOSE:
-      if (!state->flush)
-        runlength_encoder(F, IOFFLUSH);
-      iof_free(F);
-      return 0;
-    default:
-      break;
-  }
-  return 0;
-}
-
-// eexec decoder function
-
-static size_t eexec_decoder (iof *F, iof_mode mode)
-{
-  eexec_state *state;
-  iof_status status;
-  size_t tail;
-
-  switch(mode)
-  {
-    case IOFLOAD:
-    case IOFREAD:
-      if (F->flags & IOF_STOPPED)
-        return 0;
-      tail = iof_tail(F);
-      F->pos = F->buf + tail;
-      F->end = F->buf + F->space;
-      state = iof_filter_state(eexec_state *, F);
-      do {
-        status = eexec_decode_state(F->next, F, state);
-      } while (mode == IOFLOAD && status == IOFFULL && iof_resize_buffer(F));
-      return iof_decoder_retval(F, "eexec", status);
-    case IOFCLOSE:
-      iof_free(F);
-      return 0;
-    default:
-      break;
-  }
-  return 0;
-}
-
-// eexec encoder function
-
-static size_t eexec_encoder (iof *F, iof_mode mode)
-{
-  eexec_state *state;
-  iof_status status;
-
-  state = iof_filter_state(eexec_state *, F);
-  switch (mode)
-  {
-    case IOFFLUSH:
-      state->flush = 1;
-      // fall through
-    case IOFWRITE:
-      F->end = F->pos;
-      F->pos = F->buf;
-      status = eexec_encode_state(F, F->next, state);
-      return iof_encoder_retval(F, "eexec", status);
-    case IOFCLOSE:
-      if (!state->flush)
-        eexec_encoder(F, IOFFLUSH);
-      iof_free(F);
-      return 0;
-    default:
-      break;
-  }
-  return 0;
-}
-
-//
-
-int iof_filter_basexx_encoder_ln (iof *F, size_t line, size_t maxline)
-{
-  basexx_state *state;
-  if (maxline > 8 && line < maxline)
-  {
-    state = iof_filter_state(basexx_state *, F);
-    state->line = line;
-    state->maxline = maxline;
-    return 1;
-  }
-  return 0;
-}
-
-/* base 16 */
-
-iof * iof_filter_base16_decoder (iof *N)
-{
-  iof *I;
-  basexx_state *state;
-  I = iof_filter_reader(base16_decoder, sizeof(basexx_state), &state);
-  iof_setup_next(I, N);
-  basexx_state_init(state);
-  state->flush = 1; // means N is supposed to be continuous input
-  return I;
-}
-
-iof * iof_filter_base16_encoder (iof *N)
-{
-  iof *O;
-  basexx_state *state;
-  O = iof_filter_writer(base16_encoder, sizeof(basexx_state), &state);
-  iof_setup_next(O, N);
-  basexx_state_init(state);
-  return O;
-}
-
-/* base 64 */
-
-iof * iof_filter_base64_decoder (iof *N)
-{
-  iof *I;
-  basexx_state *state;
-  I = iof_filter_reader(base64_decoder, sizeof(basexx_state), &state);
-  iof_setup_next(I, N);
-  basexx_state_init(state);
-  state->flush = 1;
-  return I;
-}
-
-iof * iof_filter_base64_encoder (iof *N)
-{
-  iof *O;
-  basexx_state *state;
-  O = iof_filter_writer(base64_encoder, sizeof(basexx_state), &state);
-  iof_setup_next(O, N);
-  basexx_state_init(state);
-  return O;
-}
-
-/* base 85 */
-
-iof * iof_filter_base85_decoder (iof *N)
-{
-  iof *I;
-  basexx_state *state;
-  I = iof_filter_reader(base85_decoder, sizeof(basexx_state), &state);
-  iof_setup_next(I, N);
-  basexx_state_init(state);
-  state->flush = 1;
-  return I;
-}
-
-iof * iof_filter_base85_encoder (iof *N)
-{
-  iof *O;
-  basexx_state *state;
-  O = iof_filter_writer(base85_encoder, sizeof(basexx_state), &state);
-  iof_setup_next(O, N);
-  basexx_state_init(state);
-  return O;
-}
-
-/* runlength stream filter */
-
-iof * iof_filter_runlength_decoder (iof *N)
-{
-  iof *I;
-  runlength_state *state;
-  I = iof_filter_reader(runlength_decoder, sizeof(runlength_state), &state);
-  iof_setup_next(I, N);
-  runlength_state_init(state);
-  state->flush = 1;
-  return I;
-}
-
-iof * iof_filter_runlength_encoder (iof *N)
-{
-  iof *O;
-  runlength_state *state;
-  O = iof_filter_writer(runlength_encoder, sizeof(runlength_state), &state);
-  iof_setup_next(O, N);
-  runlength_state_init(state);
-  return O;
-}
-
-/* eexec stream filter, type1 fonts spec p. 63 */
-
-iof * iof_filter_eexec_decoder (iof *N)
-{
-  iof *I;
-  eexec_state *state;
-  I = iof_filter_reader(eexec_decoder, sizeof(eexec_state), &state);
-  iof_setup_next(I, N);
-  eexec_state_init(state);
-  state->flush = 1;
-  return I;
-}
-
-iof * iof_filter_eexec_encoder (iof *N)
-{
-  iof *O;
-  eexec_state *state;
-  O = iof_filter_writer(eexec_encoder, sizeof(eexec_state), &state);
-  iof_setup_next(O, N);
-  eexec_state_init(state);
-  return O;
-}
--- texlive-bin.orig/texk/web2c/luatexdir/luapplib/util/utilbasexx.h
+++ /dev/null
@@ -1,133 +0,0 @@
-
-/* base encodings */
-
-#ifndef UTIL_BASEXX_H
-#define UTIL_BASEXX_H
-
-#include "utiliof.h"
-
-/* base codecs state */
-
-typedef struct basexx_state basexx_state;
-
-#define BASEXX_MAXLINE 80
-#define BASEXX_PDF
-
-void basexx_state_init_ln (basexx_state *state, size_t line, size_t maxline);
-#define basexx_state_init(state) basexx_state_init_ln(state, 0, BASEXX_MAXLINE)
-
-/* base16 */
-
-int base16_getc (iof *I);
-int base16_uc_putc (iof *I, int c);
-int base16_lc_putc (iof *I, int c);
-#define base16_putc base16_uc_putc
-
-iof_status base16_encoded_uc (const void *data, size_t size, iof *O);
-iof_status base16_encoded_lc (const void *data, size_t size, iof *O);
-iof_status base16_encoded_uc_ln (const void *data, size_t size, iof *O, size_t line, size_t maxline);
-iof_status base16_encoded_lc_ln (const void *data, size_t size, iof *O, size_t line, size_t maxline);
-
-iof_status base16_encode_uc (iof *I, iof *O);
-iof_status base16_encode_lc (iof *I, iof *O);
-iof_status base16_encode_uc_ln (iof *I, iof *O, size_t line, size_t maxline);
-iof_status base16_encode_lc_ln (iof *I, iof *O, size_t line, size_t maxline);
-iof_status base16_decode (iof *I, iof *O);
-
-#define base16_encoded base16_encoded_uc
-#define base16_encoded_ln base16_encoded_uc_ln
-#define base16_encode base16_encode_uc
-#define base16_encode_ln base16_encode_uc_ln
-
-iof_status base16_encode_state_uc (iof *I, iof *O, basexx_state *state);
-iof_status base16_encode_state_lc (iof *I, iof *O, basexx_state *state);
-iof_status base16_encode_state_uc_ln (iof *I, iof *O, basexx_state *state);
-iof_status base16_encode_state_lc_ln (iof *I, iof *O, basexx_state *state);
-iof_status base16_decode_state (iof *I, iof *O, basexx_state *state);
-
-#define base16_encode_state base16_encode_state_uc
-#define base16_encode_state_ln base16_encode_state_uc_ln
-
-/* base64 */
-
-extern const char base64_alphabet[];
-extern const int base64_lookup[];
-
-iof_status base64_encoded (const void *data, size_t size, iof *O);
-iof_status base64_encoded_ln (const void *data, size_t size, iof *O, size_t line, size_t maxline);
-
-iof_status base64_encode (iof *I, iof *O);
-iof_status base64_encode_ln (iof *I, iof *O, size_t line, size_t maxline);
-iof_status base64_decode (iof *I, iof *O);
-
-iof_status base64_encode_state (iof *I, iof *O, basexx_state *state);
-iof_status base64_encode_state_ln (iof *I, iof *O, basexx_state *state);
-iof_status base64_decode_state (iof *I, iof *O, basexx_state *state);
-
-/* base85 */
-
-extern const char base85_alphabet[];
-extern const int base85_lookup[];
-
-iof_status base85_encoded (const void *data, size_t size, iof *O);
-iof_status base85_encoded_ln (const void *data, size_t size, iof *O, size_t line, size_t maxline);
-
-iof_status base85_encode (iof *I, iof *O);
-iof_status base85_encode_ln (iof *I, iof *O, size_t line, size_t maxline);
-iof_status base85_decode (iof *I, iof *O);
-
-iof_status base85_encode_state (iof *I, iof *O, basexx_state *state);
-iof_status base85_encode_state_ln (iof *I, iof *O, basexx_state *state);
-iof_status base85_decode_state (iof *I, iof *O, basexx_state *state);
-
-/* run length */
-
-typedef struct runlength_state runlength_state;
-
-void runlength_state_init (runlength_state *state);
-
-iof_status runlength_encode (iof *I, iof *O);
-iof_status runlength_encode_state (iof *I, iof *O, runlength_state *state);
-
-iof_status runlength_decode (iof *I, iof *O);
-iof_status runlength_decode_state (iof *I, iof *O, runlength_state *state);
-
-/* eexec */
-
-typedef struct eexec_state eexec_state;
-
-#define EEXEC_MAXLINE 80
-
-void eexec_state_init_ln (eexec_state *state, size_t line, size_t maxline, const char *initbytes);
-#define eexec_state_init(state) eexec_state_init_ln(state, 0, EEXEC_MAXLINE, NULL)
-
-iof_status eexec_decode (iof *I, iof *O);
-iof_status eexec_decode_state (iof *I, iof *O, eexec_state *state);
-
-iof_status eexec_encode (iof *I, iof *O, size_t line, size_t maxline);
-iof_status eexec_encode_state (iof *I, iof *O, eexec_state *state);
-
-iof_status type1_charstring_decode (void *data, size_t size, void *outdata, uint8_t leniv);
-iof_status type1_charstring_encode (void *data, size_t size, void *outdata, uint8_t leniv);
-
-/* filters */
-
-int iof_filter_basexx_encoder_ln (iof *N, size_t line, size_t maxline);
-
-iof * iof_filter_base16_decoder (iof *N);
-iof * iof_filter_base16_encoder (iof *N);
-
-iof * iof_filter_base64_decoder (iof *N);
-iof * iof_filter_base64_encoder (iof *N);
-
-iof * iof_filter_base85_decoder (iof *N);
-iof * iof_filter_base85_encoder (iof *N);
-
-iof * iof_filter_runlength_decoder (iof *N);
-iof * iof_filter_runlength_encoder (iof *N);
-
-iof * iof_filter_eexec_decoder (iof *N);
-iof * iof_filter_eexec_encoder (iof *N);
-
-
-#endif
--- texlive-bin.orig/texk/web2c/luatexdir/luapplib/util/utilcrypt.c
+++ /dev/null
@@ -1,1191 +0,0 @@
-
-#include "utilmem.h"
-#include "utilcrypt.h"
-#include "utilcryptdef.h"
-#include "utilmd5.h"
-
-/* rc4 */
-
-/*
-Initializer arguments:
-- state - crypt state
-- map - a space for rc4 bytes map; may be left NULL in which case will be allocated
-- vkey - crypt key; may be left NULL iff map is provided and properly initialized
-- keylength - the length of crypt key (from 5 to 16 bytes)
-*/
-
-rc4_state * rc4_state_initialize (rc4_state *state, rc4_map *map, const void *vkey, size_t keylength)
-{
-  int i, j;
-  uint8_t tmp;
-  const uint8_t *key;
-  key = (const uint8_t *)vkey;
-  if (keylength == 0 || keylength > 256)
-    return NULL;
-  state->flags = 0;
-  if (map != NULL)
-  {
-    state->map = map;
-  }
-  else
-  {
-    state->map = (rc4_map *)util_malloc(sizeof(rc4_map));
-    state->flags |= RC4_STATE_ALLOC;
-  }
-
-  if (key != NULL)
-  {
-    for (i = 0; i < 256; ++i)
-      state->smap[i] = (uint8_t)i;
-    for (i = 0, j = 0; i < 256; ++i)
-    {
-      j = (j + state->smap[i] + key[i % keylength]) & 255;
-      tmp = state->smap[i];
-      state->smap[i] = state->smap[j];
-      state->smap[j] = tmp;
-    }
-  }
-  state->i = 0;
-  state->j = 0;
-  state->flush = 0; /* caller is responsible to override if necessary */
-  return state;
-}
-
-void rc4_map_save (rc4_state *state, rc4_map *map)
-{
-  memcpy(map, state->map, sizeof(rc4_map));
-}
-
-void rc4_map_restore (rc4_state *state, rc4_map *map)
-{
-  memcpy(state->map, map, sizeof(rc4_map));
-  //state->flags = 0;
-  //state->flush = 0;
-  state->i = 0;
-  state->j = 0;
-}
-
-static uint8_t rc4_next_random_byte (rc4_state *state)
-{
-  uint8_t tmp;
-  state->i = (state->i + 1) & 255;
-  state->j = (state->j + state->smap[state->i]) & 255;
-  tmp = state->smap[state->i];
-  state->smap[state->i] = state->smap[state->j];
-  state->smap[state->j] = tmp;
-  return state->smap[(state->smap[state->i] + state->smap[state->j]) & 255];
-}
-
-iof_status rc4_crypt_state (iof *I, iof *O, rc4_state *state)
-{
-  uint8_t r;
-  int c;
-  while (iof_ensure(O, 1))
-  {
-    if ((c = iof_get(I)) < 0)
-      return c == IOFERR ? IOFERR : (state->flush ? IOFEOF : IOFEMPTY);
-    r = rc4_next_random_byte(state);
-    //r = r ^ ((uint8_t)c);
-    //iof_set(O, r);
-    iof_set(O, r ^ ((uint8_t)c));
-  }
-  return IOFFULL;
-}
-
-iof_status rc4_crypt (iof *I, iof *O, const void *key, size_t keylength)
-{
-  int ret;
-  rc4_state state;
-  rc4_map map;
-  if (rc4_state_initialize(&state, &map, key, keylength) == NULL)
-    return IOFERR;
-  state.flush = 1;
-  ret = rc4_crypt_state(I, O, &state);
-  rc4_state_close(&state);
-  return ret;
-}
-
-/*
-Variants that operates on c-strings can worn inplace, so output and input can be the same address.
-Variant that takes rc4_state pointer expects the state properly initialized. Keep in mind
-the crypt procedure modifies rc4 bytes map. All returns the size of encrypted/decrypted
-data, which is the same as input data length for rc4.
-*/
-
-size_t rc4_crypt_data (const void *input, size_t length, void *output, const void *key, size_t keylength)
-{
-  rc4_state state;
-  rc4_map map;
-  if (rc4_state_initialize(&state, &map, key, keylength) == NULL)
-    return 0;
-  return rc4_crypt_state_data(&state, input, length, output);
-  // no need to call rc4_state_close()
-}
-
-size_t rc4_crypt_state_data (rc4_state *state, const void *input, size_t length, void *output)
-{ /* state assumed to be initialized and with the proper state of smap */
-  const uint8_t *inp;
-  uint8_t r, *out;
-  size_t size;
-  inp = (const uint8_t *)input;
-  out = (uint8_t *)output;
-  for (size = 0; size < length; ++size, ++inp, ++out)
-  {
-    r = rc4_next_random_byte(state);
-    *out = r ^ *inp;
-  }
-  return length;
-}
-
-void rc4_state_close (rc4_state *state)
-{
-  if (state->smap != NULL && (state->flags & RC4_STATE_ALLOC))
-  {
-    util_free(state->smap);
-    state->smap = NULL;
-  }
-}
-
-/* aes; parts of code excerpted from https://github.com/kokke/tiny-AES128-C */
-
-static const uint8_t sbox[256] =   {
-  0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76,
-  0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0,
-  0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15,
-  0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75,
-  0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84,
-  0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf,
-  0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8,
-  0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2,
-  0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73,
-  0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb,
-  0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79,
-  0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08,
-  0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a,
-  0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e,
-  0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
-  0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 };
-
-static const uint8_t rsbox[256] =
-{ 0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb,
-  0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb,
-  0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e,
-  0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25,
-  0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92,
-  0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84,
-  0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06,
-  0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b,
-  0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73,
-  0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e,
-  0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b,
-  0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4,
-  0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f,
-  0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef,
-  0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
-  0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d };
-
-/*
-The round constant word array, rcon[i], contains the values given by
-x to th e power (i-1) being powers of x (x is denoted as {02}) in the field GF(2^8)
-Note that i starts at 1, not 0).
-*/
-
-static const uint8_t rcon[255] = {
-  0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a,
-  0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39,
-  0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a,
-  0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8,
-  0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef,
-  0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc,
-  0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b,
-  0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3,
-  0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94,
-  0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20,
-  0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35,
-  0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f,
-  0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04,
-  0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63,
-  0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd,
-  0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb  };
-
-/* block copying */
-
-#define aes_copy_block(output, input) memcpy(output, input, 16)
-
-static void aes_copy_cbc (uint8_t *data, const uint8_t *input)
-{
-  uint8_t i;
-  for (i = 0; i < 16; ++i)
-    data[i] ^= input[i];
-}
-
-static void aes_copy_xor (uint8_t *data, const uint8_t *input, const uint8_t *iv)
-{
-  uint8_t i;
-  for (i = 0; i < 16; ++i)
-    data[i] = input[i] ^ iv[i];
-}
-
-/* key expansion */
-
-#define AES_COLUMNS 4 // constant in aes
-
-static void key_expansion (aes_state *state, const uint8_t *key)
-{
-  uint32_t i, j, k;
-  uint8_t t[4];
-  uint8_t *keydata, keywords, columns;
-
-  keywords = (uint8_t)(state->keylength >> 2);
-  keydata = (uint8_t *)state->keyblock;
-
-  /* the first round key is the key itself */
-  for(i = 0; i < keywords; ++i)
-  {
-    keydata[(i * 4) + 0] = key[(i * 4) + 0];
-    keydata[(i * 4) + 1] = key[(i * 4) + 1];
-    keydata[(i * 4) + 2] = key[(i * 4) + 2];
-    keydata[(i * 4) + 3] = key[(i * 4) + 3];
-  }
-
-  /* others derived from the first */
-
-  for(columns = AES_COLUMNS * (state->rounds + 1); i < columns; ++i)
-  {
-    for(j = 0; j < 4; ++j)
-      t[j] = keydata[(i - 1) * 4 + j];
-    if (i % keywords == 0)
-    {
-      /* rotate the 4 bytes in a word to the left once; [a0,a1,a2,a3] becomes [a1,a2,a3,a0] */
-      k = t[0];
-      t[0] = t[1];
-      t[1] = t[2];
-      t[2] = t[3];
-      t[3] = k;
-
-      /* take a four-byte input word and apply the S-box to each of the four bytes to produce an output word */
-      t[0] = sbox[t[0]];
-      t[1] = sbox[t[1]];
-      t[2] = sbox[t[2]];
-      t[3] = sbox[t[3]];
-
-      t[0] =  t[0] ^ rcon[i / keywords];
-    }
-    else if (keywords > 6 && i % keywords == 4)
-    {
-      t[0] = sbox[t[0]];
-      t[1] = sbox[t[1]];
-      t[2] = sbox[t[2]];
-      t[3] = sbox[t[3]];
-    }
-    keydata[i * 4 + 0] = keydata[(i - keywords) * 4 + 0] ^ t[0];
-    keydata[i * 4 + 1] = keydata[(i - keywords) * 4 + 1] ^ t[1];
-    keydata[i * 4 + 2] = keydata[(i - keywords) * 4 + 2] ^ t[2];
-    keydata[i * 4 + 3] = keydata[(i - keywords) * 4 + 3] ^ t[3];
-  }
-
-}
-
-/*
-An original implementation uses no private buffers except a keyblock. We need private buffers to
-keep a CBC vector between calls and to be able to read input data not necessarily in 16-bytes blocks.
-Encrypter would actually require only one such buffer, as CBC vector is applied on input data before
-the actual cipher procedure. And CBC for the next chunk is simply the output from the previous.
-Decrypter, however, applies the cipher first, then applies CBC to the output with a buffered init
-vector, and the vector for the next call is the row input before cipher. Hence we need two 16-bytes
-buffers for decrypter.
-*/
-
-/*
-aes_state * aes_state_initialize_ecb (aes_state *State, uint8_t *keyblock, const uint8_t *key)
-{
-  state->flags = 0;
-
-  state->flags |= AES_ECB_MODE;
-
-  if (keyblock == NULL)
-  {
-    keyblock = util_malloc(sizeof(aes_keyblock));
-    state->flags |= AES_STATE_ALLOC;
-  }
-  state->keyblock = keyblock;
-  key_expansion(state, key);
-  state->flush = 0;
-  return state;
-}
-*/
-
-void aes_pdf_mode (aes_state *state)
-{
-  state->flags |= AES_INLINE_IV;
-  state->flags &= ~AES_NULL_PADDING;
-}
-
-/*
-Initialize arguments:
-- state - crypt state
-- keyblock - a space for aes key expansion; can be left NULL in which case will be allocated
-- key - crypt key; can be left NULL iff keyblock is given and properly initialized
-- keylength - the length of the key (16 or 32 bytes)
-- iv - 16-bytes CBC initialization vector;
-  - if left NULL for encoder, one is generated and stored as state->iv
-  - can also be left NULL for decorer, but then AES_INLINE_IV must be set, as this informs decoder to take
-    an initialization vector from the beginning of the encrypted stream
-
-At the first approach, an initialization vector was copied to state block during initialization and encoders
-assumed that the state block is the current initialization vector. This simplifies encrypting procedure,
-as the output from every 16-bytes chunk encryption is an initialization vector for the next chunk. However,
-it makes api usage cumbersome, as the user has to know that iv may need to be copied to state block
-before each call.
-*/
-
-static int aes_key_length (aes_state *state, size_t keylength)
-{
-  state->keylength = keylength;
-  switch (keylength)
-  {
-    case 16:
-      state->rounds = 10;
-      break;
-    case 24:
-      state->rounds = 12;
-      break;
-    case 32:
-      state->rounds = 14;
-      break;
-    default:
-      return 0;
-  }
-  return 1;
-}
-
-aes_state * aes_encode_initialize (aes_state *state, aes_keyblock *keyblock, const void *key, size_t keylength, const void *iv)
-{
-  state->flags = 0;
-  if (!aes_key_length(state, keylength))
-    return NULL;
-  if (iv != NULL)
-    aes_copy_block(state->iv, iv);
-  else
-    aes_generate_iv(state->iv);
-  state->flags |= AES_HAS_IV;
-
-  if (keyblock == NULL)
-  {
-    keyblock = (aes_keyblock *)util_malloc(sizeof(aes_keyblock));
-    state->flags |= AES_STATE_ALLOC;
-  }
-  state->keyblock = keyblock;
-  if (key != NULL) /* if NULL we assume keyblock is given and already expanded */
-    key_expansion(state, (const uint8_t *)key);
-  state->flush = 0;
-  return state;
-}
-
-aes_state * aes_decode_initialize (aes_state *state, aes_keyblock *keyblock, const void *key, size_t keylength, const void *iv)
-{
-  state->flags = 0;
-  if (!aes_key_length(state, keylength))
-    return NULL;
-  if (iv != NULL)
-  {
-    aes_copy_block(state->iv, iv);
-    state->flags |= AES_HAS_IV;
-  }
-  /* else if AES_INLINE_IV flag is set will be read from input */
-
-  if (keyblock == NULL)
-  {
-    keyblock = (aes_keyblock *)util_malloc(sizeof(aes_keyblock));
-    state->flags |= AES_STATE_ALLOC;
-  }
-  state->keyblock = keyblock;
-  if (key != NULL) /* otherwise keyblock is assumed present and properly initialized */
-    key_expansion(state, (const uint8_t *)key);
-  state->flush = 0;
-  return state;
-}
-
-void aes_state_close (aes_state *state)
-{
-  if (state->keyblock != NULL && (state->flags & AES_STATE_ALLOC))
-    util_free(state->keyblock);
-}
-
-/* add round key */
-
-static void aes_round_key (aes_block block, aes_block keyblock)
-{
-  uint8_t i, j;
-  for(i = 0; i < 4; ++i)
-    for(j = 0; j < 4; ++j)
-      block[i][j] ^= keyblock[i][j];
-}
-
-#define aes_add_key(block, keyblock, round) aes_round_key(block, (*keyblock)[round])
-
-/* substitution */
-
-static void aes_encode_sub (aes_block block)
-{
-  uint8_t i, j, v;
-  for(i = 0; i < 4; ++i)
-    for(j = 0; j < 4; ++j)
-      v = block[i][j], block[i][j] = sbox[v];
-}
-
-/* rows shift; the row index is the shift offset, the first order is not shifted */
-
-static void aes_encode_shift (aes_block block)
-{
-  uint8_t tmp;
-
-  /* 1st row rotated once */
-  tmp = block[0][1];
-  block[0][1] = block[1][1];
-  block[1][1] = block[2][1];
-  block[2][1] = block[3][1];
-  block[3][1] = tmp;
-
-  /* 2nd row rotated twice */
-  tmp = block[0][2];
-  block[0][2] = block[2][2];
-  block[2][2] = tmp;
-  tmp = block[1][2];
-  block[1][2] = block[3][2];
-  block[3][2] = tmp;
-
-  /* 3rd row rotated 3 times */
-  tmp = block[0][3];
-  block[0][3] = block[3][3];
-  block[3][3] = block[2][3];
-  block[2][3] = block[1][3];
-  block[1][3] = tmp;
-}
-
-static uint8_t xtime (uint8_t x)
-{
-  return ((x << 1) ^ (((x >> 7) & 1) * 0x1b));
-}
-
-/* mix columns */
-
-static void aes_encode_mix (aes_block block)
-{
-  uint8_t i, tmp, tm, t;
-
-  for(i = 0; i < 4; ++i)
-  {
-    t   = block[i][0];
-    tmp = block[i][0] ^ block[i][1] ^ block[i][2] ^ block[i][3] ;
-    tm  = block[i][0] ^ block[i][1]; tm = xtime(tm); block[i][0] ^= tm ^ tmp;
-    tm  = block[i][1] ^ block[i][2]; tm = xtime(tm); block[i][1] ^= tm ^ tmp;
-    tm  = block[i][2] ^ block[i][3]; tm = xtime(tm); block[i][2] ^= tm ^ tmp;
-    tm  = block[i][3] ^ t ;          tm = xtime(tm); block[i][3] ^= tm ^ tmp;
-  }
-}
-
-/* multiply is used to multiply numbers in the field GF(2^8) */
-
-#define multiply(x, y)                                \
-      (  ((y & 1) * x) ^                              \
-      ((y>>1 & 1) * xtime(x)) ^                       \
-      ((y>>2 & 1) * xtime(xtime(x))) ^                \
-      ((y>>3 & 1) * xtime(xtime(xtime(x)))) ^         \
-      ((y>>4 & 1) * xtime(xtime(xtime(xtime(x))))))   \
-
-/* mix columns */
-
-static void aes_decode_mix (aes_block block)
-{
-  int i;
-  uint8_t a, b, c, d;
-
-  for(i = 0; i < 4; ++i)
-  {
-    a = block[i][0];
-    b = block[i][1];
-    c = block[i][2];
-    d = block[i][3];
-    block[i][0] = multiply(a, 0x0e) ^ multiply(b, 0x0b) ^ multiply(c, 0x0d) ^ multiply(d, 0x09);
-    block[i][1] = multiply(a, 0x09) ^ multiply(b, 0x0e) ^ multiply(c, 0x0b) ^ multiply(d, 0x0d);
-    block[i][2] = multiply(a, 0x0d) ^ multiply(b, 0x09) ^ multiply(c, 0x0e) ^ multiply(d, 0x0b);
-    block[i][3] = multiply(a, 0x0b) ^ multiply(b, 0x0d) ^ multiply(c, 0x09) ^ multiply(d, 0x0e);
-  }
-}
-
-/* inverse substitution */
-
-static void aes_decode_sub (aes_block block)
-{
-  uint8_t i, j, v;
-  for(i = 0; i < 4; ++i)
-    for(j = 0; j < 4; ++j)
-      v = block[i][j], block[i][j] = rsbox[v];
-}
-
-/* inverse shift rows */
-
-static void aes_decode_shift (aes_block block)
-{
-  uint8_t tmp;
-
-  /* 1st row rotated once right */
-  tmp = block[3][1];
-  block[3][1] = block[2][1];
-  block[2][1] = block[1][1];
-  block[1][1] = block[0][1];
-  block[0][1] = tmp;
-
-  /* 2st row rotated twice right */
-  tmp = block[0][2];
-  block[0][2] = block[2][2];
-  block[2][2] = tmp;
-  tmp = block[1][2];
-  block[1][2] = block[3][2];
-  block[3][2] = tmp;
-
-  /* 3rd row rotated 3 times right */
-  tmp = block[0][3];
-  block[0][3] = block[1][3];
-  block[1][3] = block[2][3];
-  block[2][3] = block[3][3];
-  block[3][3] = tmp;
-}
-
-/* aes block encoder */
-
-static void aes_encode_cipher (aes_state *state)
-{
-  uint8_t round;
-  aes_add_key(state->block, state->keyblock, 0);
-  for (round = 1; round < state->rounds; ++round)
-  {
-    aes_encode_sub(state->block);
-    aes_encode_shift(state->block);
-    aes_encode_mix(state->block);
-    aes_add_key(state->block, state->keyblock, round);
-  }
-  aes_encode_sub(state->block);
-  aes_encode_shift(state->block);
-  aes_add_key(state->block, state->keyblock, state->rounds);
-}
-
-/* aes block decoder */
-
-static void aes_decode_cipher (aes_state *state)
-{
-  uint8_t round;
-  aes_add_key(state->block, state->keyblock, state->rounds);
-  for(round = state->rounds - 1; round > 0; --round)
-  {
-    aes_decode_shift(state->block);
-    aes_decode_sub(state->block);
-    aes_add_key(state->block, state->keyblock, round);
-    aes_decode_mix(state->block);
-  }
-  aes_decode_shift(state->block);
-  aes_decode_sub(state->block);
-  aes_add_key(state->block, state->keyblock, 0);
-}
-
-/* tail block padding; RFC 2898, PKCS #5: Password-Based Cryptography Specification Version 2.0; pdf spec p. 119 */
-
-#define aes_padding(state) ((state->flags & AES_NULL_PADDING) == 0)
-
-static void aes_put_padding (aes_state *state, uint8_t length)
-{
-  uint8_t pad;
-  pad = (aes_padding(state)) ? 16 - length : 0;
-  for (; length < 16; ++length)
-    state->data[length] = state->iv[length] ^ pad;
-}
-
-static int aes_remove_padding (aes_state *state, uint8_t *data, uint8_t *length)
-{
-  uint8_t pad;
-  *length = 16; /* block length 16 means leave intact */
-  if (aes_padding(state))
-  {
-    pad = data[16 - 1];
-    if (pad > 16)
-      return IOFERR;
-    for ( ; *length > 16 - pad; --(*length))
-      if (data[*length - 1] != pad)
-        return IOFERR;
-  }
-  else
-  {
-    for ( ; *length > 0; --(*length))
-      if (data[*length - 1] != '\0')
-        break;
-  }
-  return IOFEOF;
-}
-
-/* aes codec */
-
-/* make the cipher on input xor-ed with iv, save the output as a new iv, write the output */
-#define aes_encode_output(state, output) \
-  (aes_encode_cipher(state), aes_copy_block(state->iv, state->data), aes_copy_block(output, state->data), output += 16)
-
-iof_status aes_encode_state (iof *I, iof *O, aes_state *state)
-{
-  int c;
-
-  if (!(state->flags & AES_HAS_IV)) // weird
-    return IOFERR;
-  if ((state->flags & AES_INLINE_IV) && !(state->flags & AES_CONTINUE))
-  { /* write iv at the beginning of encrypted data */
-    if (!iof_ensure(O, 16))
-      return IOFFULL;
-    aes_copy_block(O->pos, state->iv);
-    O->pos += 16;
-    state->flags |= AES_CONTINUE;
-  }
-  while (iof_ensure(O, 16))
-  {
-    while (state->buffered < 16)
-    {
-      if ((c = iof_get(I)) != IOFEOF)
-      { /* get input byte XORed with iv */
-        state->data[state->buffered] = state->iv[state->buffered] ^ ((uint8_t)c);
-        ++state->buffered;
-      }
-      else
-      {
-        if (state->flush)
-        {
-          if (state->buffered > 0 || aes_padding(state))
-          { /* pad the last input chunk; for input divisable by 16, add 16 bytes 0x0f */
-            aes_put_padding(state, state->buffered);
-            state->buffered = 16;
-            aes_encode_output(state, O->pos);
-          }
-          return IOFEOF;
-        }
-        else
-          return IOFEMPTY;
-      }
-    }
-    aes_encode_output(state, O->pos);
-    state->buffered = 0;
-  }
-  return IOFFULL;
-}
-
-/* write iv to the output, save the raw input just buffered as iv for the next chunk, make the cipher, write out xoring with iv */
-#define aes_decode_output(state, output) \
-  (aes_copy_block(output, state->iv), aes_copy_block(state->iv, state->data), aes_decode_cipher(state), aes_copy_cbc(output, state->data), output += 16)
-
-iof_status aes_decode_state (iof *I, iof *O, aes_state *state)
-{
-  int c, ret;
-  uint8_t lastlength;
-
-  if ((state->flags & AES_INLINE_IV) && !(state->flags & AES_CONTINUE))
-  {
-    while (state->buffered < 16)
-    {
-      if ((c = iof_get(I)) != IOFEOF)
-        state->iv[state->buffered++] = (uint8_t)c;
-      else
-        return state->flush ? IOFERR : IOFEMPTY;
-    }
-    state->flags |= AES_CONTINUE|AES_HAS_IV;
-    state->buffered = 0;
-  }
-  while (iof_ensure(O, 16))
-  {
-    while (state->buffered < 16)
-    {
-      if ((c = iof_get(I)) != IOFEOF)
-        state->data[state->buffered++] = (uint8_t)c;
-      else
-        return state->flush ? IOFERR : IOFEMPTY;
-    }
-    aes_decode_output(state, O->pos);
-    if (state->flush)
-    { /* we have to check for EOF here, to remove eventual padding */
-      if ((c = iof_get(I)) < 0)
-      { /* end of input at 16-bytes boundary; remove padding and quit */
-        ret = aes_remove_padding(state, O->pos - 16, &lastlength);
-        O->pos -= 16 - lastlength;
-        return ret;
-      }
-      else
-      { /* beginning of the next block */
-        state->buffered = 1;
-        state->data[0] = (uint8_t)c;
-      }
-    }
-    else
-      state->buffered = 0;
-  }
-  return IOFFULL;
-}
-
-/* variants that works on c-strings; can work inplace (output==input) except encoder in pdf flavour */
-
-/*
-Codecs operating on c-string can generally work inplace (output==input), except encoder with AES_INLINE_IV flag set,
-which outputs 16 bytes of initialization vector at the beginning of encrypted data. All return the size of encrypted/decrypted
-data. Encoders output is the original length padded to a complete 16 bytes (plus eventual 16 bytes of initialization
-vector, if AES_INLINE_IV is used). Default padding is unambiguously removed during decryption. AES_NULL_PADDING flag
-forces using (ambiguous) NULL-byte padding, only if input length module 16 is greater then zero.
-
-An input data is supposed to be a complete data to be encrypted or decrypted. It is possible, however, to use those
-codecs for scaterred data chunks by manipulating AES_INLINE_IV, AES_NULL_PADDING, AES_CONTINUE flags and data length.
-Caller may assume that c-string codecs do not modify state flags.
-
-Encoder could actually be optimized by writing an initialization vector to a state block once. After every chunk encryption,
-the output is the initialization vector for the next chunk. Since we use c-string codec variants on short strings,
-the gain is neglectable in comparison with the weight of the aes crypt procedure.
-*/
-
-size_t aes_encode_data (const void *input, size_t length, void *output, const void *key, size_t keylength, const void *iv, int flags)
-{
-  aes_state state;
-  aes_keyblock keyblock;
-
-  if (aes_encode_initialize(&state, &keyblock, key, keylength, iv) == NULL)
-    return 0;
-  state.flags |= flags;
-  return aes_encode_state_data(&state, input, length, output);
-  // aes_state_close(&state);
-}
-
-size_t aes_encode_state_data (aes_state *state, const void *input, size_t length, void *output)
-{
-  const uint8_t *inp;
-  uint8_t *out, tail, t;
-  size_t size;
-
-  inp = (const uint8_t *)input;
-  out = (uint8_t *)output;
-
-  if (!(state->flags & AES_HAS_IV))
-      return 0;
-  if ((state->flags & AES_INLINE_IV) && !(state->flags & AES_CONTINUE))
-  {
-    aes_copy_block(out, state->iv);
-    out += 16;
-  }
-  // state->flags |= AES_CONTINUE; // do not modify state flags
-
-  for (size = 0; size + 16 <= length; size += 16)
-  {
-    aes_copy_xor(state->data, inp, state->iv);
-    aes_encode_output(state, out);
-    inp += 16;
-  }
-
-  if ((tail = (length % 16)) > 0 || aes_padding(state))
-  {
-    for (t = 0; t < tail; ++t)
-      state->data[t] = inp[t] ^ state->iv[t];
-    aes_put_padding(state, tail);
-    aes_encode_output(state, out);
-    size += 16;
-  }
-  if (state->flags & AES_INLINE_IV)
-    size += 16; /* iv written at the beginning of encoded data */
-
-  return size;
-}
-
-size_t aes_decode_data (const void *input, size_t length, void *output, const void *key, size_t keylength, const void *iv, int flags)
-{
-  aes_state state;
-  aes_keyblock keyblock;
-
-  if (aes_decode_initialize(&state, &keyblock, key, keylength, iv) == NULL)
-    return 0;
-  state.flags |= flags;
-  return aes_decode_state_data(&state, input, length, output);
-  // aes_state_close(&state);
-}
-
-size_t aes_decode_state_data (aes_state *state, const void *input, size_t length, void *output)
-{
-  const uint8_t *inp;
-  uint8_t *out, lastlength;
-  size_t size;
-
-  inp = (const uint8_t *)input;
-  out = (uint8_t *)output;
-
-  if ((state->flags & AES_INLINE_IV) && !(state->flags & AES_CONTINUE))
-  {
-    aes_copy_block(state->iv, inp);
-    // state->flags |= AES_HAS_IV; // do not modify state flags
-    inp += 16;
-    length = length >= 16 ? length - 16 : 0;
-  }
-  else if (!(state->flags & AES_HAS_IV))
-    return 0;
-  // state->flags |= AES_CONTINUE; // do not modify state flags
-  for (size = 0; size + 16 <= length; size += 16)
-  {
-    aes_copy_block(state->data, inp);
-    aes_decode_output(state, out);
-    inp += 16;
-  }
-
-  if (size >= 16)
-  {
-    aes_remove_padding(state, out - 16, &lastlength);
-    size = size - 16 + lastlength;
-  }
-
-  return size;
-}
-
-/*
-pseudo-random bytes chain exceprted from eexec; not expected to have strong cryptographic properties
-we only expect that it is (reasonably) unique and different for each call (not only function call, but also
-a program call). A current trick with mangling pointer value gives satisfactory results, generally different
-for every function call and a programm call. Note that the pseudo-input bytes starts from some inner address
-bits, as they vary better; without that, the first byte tends to be "lazy".
-*/
-
-void random_bytes (uint8_t *output, size_t size)
-{
-  size_t i;
-  uint8_t p;
-  static uint16_t k = 55665;
-  for (i = 0; i < size; ++i)
-  {
-    p = ((uint8_t *)(&output))[(i + 2) % sizeof(uint8_t *)] ^ (uint8_t)size; // pseudo input byte ;)
-    k = (((p + k) * 52845 + 22719) & 65535); // xor-ed with pseudo-random sequence (kept between calls)
-    output[i] = p ^ (k >> 8);
-  }
-}
-
-void aes_generate_iv (uint8_t output[16])
-{
-  random_bytes(output, 16);
-}
-
-/* filters */
-
-// rc4 decoder function
-
-static size_t rc4_decoder (iof *F, iof_mode mode)
-{
-  rc4_state *state;
-  iof_status status;
-  size_t tail;
-
-  state = iof_filter_state(rc4_state *, F);
-  switch(mode)
-  {
-    case IOFLOAD:
-    case IOFREAD:
-      if (F->flags & IOF_STOPPED)
-        return 0;
-      tail = iof_tail(F);
-      F->pos = F->buf + tail;
-      F->end = F->buf + F->space;
-      do {
-        status = rc4_decode_state(F->next, F, state);
-      } while (mode == IOFLOAD && status == IOFFULL && iof_resize_buffer(F));
-      return iof_decoder_retval(F, "rc4", status);
-    case IOFCLOSE:
-      rc4_state_close(state);
-      iof_free(F);
-      return 0;
-    default:
-      break;
-  }
-  return 0;
-}
-
-// rc4 encoder function
-
-static size_t rc4_encoder (iof *F, iof_mode mode)
-{
-  rc4_state *state;
-  iof_status status;
-
-  state = iof_filter_state(rc4_state *, F);
-  switch (mode)
-  {
-    case IOFFLUSH:
-      state->flush = 1;
-      // fall through
-    case IOFWRITE:
-      F->end = F->pos;
-      F->pos = F->buf;
-      status = rc4_encode_state(F, F->next, state);
-      return iof_encoder_retval(F, "rc4", status);
-    case IOFCLOSE:
-      if (!state->flush)
-        rc4_encoder(F, IOFFLUSH);
-      rc4_state_close(state);
-      iof_free(F);
-      return 0;
-    default:
-      break;
-  }
-  return 0;
-}
-
-// aes decoder function
-
-static size_t aes_decoder (iof *F, iof_mode mode)
-{
-  aes_state *state;
-  iof_status status;
-  size_t tail;
-
-  state = iof_filter_state(aes_state *, F);
-  switch(mode)
-  {
-    case IOFLOAD:
-    case IOFREAD:
-      if (F->flags & IOF_STOPPED)
-        return 0;
-      tail = iof_tail(F);
-      F->pos = F->buf + tail;
-      F->end = F->buf + F->space;
-      do {
-        status = aes_decode_state(F->next, F, state);
-      } while (mode == IOFLOAD && status == IOFFULL && iof_resize_buffer(F));
-      return iof_decoder_retval(F, "aes", status);
-    case IOFCLOSE:
-      aes_state_close(state);
-      iof_free(F);
-      return 0;
-    default:
-      break;
-  }
-  return 0;
-}
-
-// aes encoder function
-
-static size_t aes_encoder (iof *F, iof_mode mode)
-{
-  aes_state *state;
-  iof_status status;
-
-  state = iof_filter_state(aes_state *, F);
-  switch (mode)
-  {
-    case IOFFLUSH:
-      state->flush = 1;
-      // fall through
-    case IOFWRITE:
-      F->end = F->pos;
-      F->pos = F->buf;
-      status = aes_encode_state(F, F->next, state);
-      return iof_encoder_retval(F, "aes", status);
-    case IOFCLOSE:
-      if (!state->flush)
-        aes_encoder(F, IOFFLUSH);
-      aes_state_close(state);
-      iof_free(F);
-      return 0;
-    default:
-      break;
-  }
-  return 0;
-}
-
-iof * iof_filter_rc4_decoder (iof *N, const void *key, size_t keylength)
-{
-  iof *I;
-  rc4_state *state;
-
-  I = iof_filter_reader(rc4_decoder, sizeof(rc4_state), &state);
-  iof_setup_next(I, N);
-  if (rc4_state_init(state, key, keylength) == NULL)
-  {
-    iof_discard(I);
-    return NULL;
-  }
-  state->flush = 1;
-  return I;
-}
-
-iof * iof_filter_rc4_encoder (iof *N, const void *key, size_t keylength)
-{
-  iof *O;
-  rc4_state *state;
-
-  O = iof_filter_writer(rc4_encoder, sizeof(rc4_state), &state);
-  iof_setup_next(O, N);
-  if (rc4_state_init(state, key, keylength) == NULL)
-  {
-    iof_discard(O);
-    return NULL;
-  }
-  // state->flush = 1;
-  return O;
-}
-
-/* aes crypt filters */
-
-iof * iof_filter_aes_decoder (iof *N, const void *key, size_t keylength)
-{
-  iof *I;
-  aes_state *state;
-
-  I = iof_filter_reader(aes_decoder, sizeof(aes_state), &state);
-  iof_setup_next(I, N);
-  if (aes_decode_init(state, key, keylength) == NULL)
-  {
-    iof_discard(I);
-    return NULL;
-  }
-  aes_pdf_mode(state);
-  state->flush = 1;
-  return I;
-}
-
-iof * iof_filter_aes_encoder (iof *N, const void *key, size_t keylength)
-{
-  iof *O;
-  aes_state *state;
-
-  O = iof_filter_writer(aes_encoder, sizeof(aes_state), &state);
-  iof_setup_next(O, N);
-  if (aes_encode_init(state, key, keylength) == NULL)
-  {
-    iof_discard(O);
-    return NULL;
-  }
-  aes_pdf_mode(state);
-  // state->flush = 1;
-  return O;
-}
-
-/* test */
-
-/*
-static void show (void *p, size_t size, uint8_t round, uint8_t sym)
-{
-  uint8_t i;
-  printf("%c%c:", round, sym);
-  for (i = 0; i < size; ++i)
-    printf("%02x", ((uint8_t *)p)[i]);
-  printf("\n");
-}
-
-void aes_test (void)
-{
-  const uint8_t key[] = { 0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c };
-  const uint8_t iv[]  = { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f };
-  const uint8_t inp[] = {
-    0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,
-    0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c, 0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51,
-    0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11, 0xe5, 0xfb, 0xc1, 0x19, 0x1a, 0x0a, 0x52, 0xef,
-    0xf6, 0x9f, 0x24, 0x45, 0xdf, 0x4f, 0x9b, 0x17, 0xad, 0x2b, 0x41, 0x7b, 0xe6, 0x6c, 0x37, 0x10 };
-  const uint8_t out[]  = {
-    0x76, 0x49, 0xab, 0xac, 0x81, 0x19, 0xb2, 0x46, 0xce, 0xe9, 0x8e, 0x9b, 0x12, 0xe9, 0x19, 0x7d,
-    0x50, 0x86, 0xcb, 0x9b, 0x50, 0x72, 0x19, 0xee, 0x95, 0xdb, 0x11, 0x3a, 0x91, 0x76, 0x78, 0xb2,
-    0x73, 0xbe, 0xd6, 0xb8, 0xe3, 0xc1, 0x74, 0x3b, 0x71, 0x16, 0xe6, 0x9e, 0x22, 0x22, 0x95, 0x16,
-    0x3f, 0xf1, 0xca, 0xa1, 0x68, 0x1f, 0xac, 0x09, 0x12, 0x0e, 0xca, 0x30, 0x75, 0x86, 0xe1, 0xa7 };
-
-  uint8_t input[64], output[64];
-  size_t inpsize, outsize;
-  int flags = AES_NULL_PADDING;
-
-	////////////////////////////////////////////////////////////////////////////
-
-//#define ENCODETO output
-#define ENCODETO input // inplace
-
-  inpsize = 64;
-  memcpy(input, inp, inpsize);
-	show(input, inpsize, '>', '>');
-  outsize = aes_encode_data(input, inpsize, ENCODETO, key, 16, iv, flags);
-  show(ENCODETO, outsize, '<', '<');
-  if (outsize == inpsize && memcmp(ENCODETO, out, outsize) == 0)
-    printf("ENCODER SUCCESS\n");
-  else
-    printf("ENCODER FAILURE\n");
-
-	////////////////////////////////////////////////////////////////////////////
-
-//#define DECODETO input
-#define DECODETO output // in place
-
-  outsize = 64;
-  memcpy(output, out, outsize);
-  show(output, outsize, '<', '<');
-	inpsize = aes_decode_data(output, outsize, DECODETO, key, 16, iv, flags);
-  show(DECODETO, inpsize, '>', '>');
-  if (inpsize == outsize && memcmp(DECODETO, inp, inpsize) == 0)
-    printf("DECODER SUCCESS\n");
-  else
-    printf("DECODER FAILURE\n");
-}
-*/
-
-/*
-Some example vectors
-
-================================ AES ECB 128-bit encryption mode ================================
-
-Encryption key: 2b7e151628aed2a6abf7158809cf4f3c
-
-Test vector                      Cipher text
-6bc1bee22e409f96e93d7e117393172a 3ad77bb40d7a3660a89ecaf32466ef97
-ae2d8a571e03ac9c9eb76fac45af8e51 f5d3d58503b9699de785895a96fdbaaf
-30c81c46a35ce411e5fbc1191a0a52ef 43b1cd7f598ece23881b00e3ed030688
-f69f2445df4f9b17ad2b417be66c3710 7b0c785e27e8ad3f8223207104725dd4
-
-
-================================ AES ECB 192-bit encryption mode ================================
-
-Encryption key: 8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b
-
-Test vector                       Cipher text
-6bc1bee22e409f96e93d7e117393172a  bd334f1d6e45f25ff712a214571fa5cc
-ae2d8a571e03ac9c9eb76fac45af8e51  974104846d0ad3ad7734ecb3ecee4eef
-30c81c46a35ce411e5fbc1191a0a52ef  ef7afd2270e2e60adce0ba2face6444e
-f69f2445df4f9b17ad2b417be66c3710  9a4b41ba738d6c72fb16691603c18e0e
-
-
-================================ AES ECB 256-bit encryption mode ================================
-
-Encryption key: 603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4
-
-Test vector                       Cipher text
-6bc1bee22e409f96e93d7e117393172a  f3eed1bdb5d2a03c064b5a7e3db181f8
-ae2d8a571e03ac9c9eb76fac45af8e51  591ccb10d410ed26dc5ba74a31362870
-30c81c46a35ce411e5fbc1191a0a52ef  b6ed21b99ca6f4f9f153e7b1beafed1d
-f69f2445df4f9b17ad2b417be66c3710  23304b7a39f9f3ff067d8d8f9e24ecc7
-
-================================ AES CBC 128-bit encryption mode ================================
-
-Encryption key: 2b7e151628aed2a6abf7158809cf4f3c
-
-Initialization vector             Test vector                       Cipher text
-000102030405060708090A0B0C0D0E0F  6bc1bee22e409f96e93d7e117393172a  7649abac8119b246cee98e9b12e9197d
-7649ABAC8119B246CEE98E9B12E9197D  ae2d8a571e03ac9c9eb76fac45af8e51  5086cb9b507219ee95db113a917678b2
-5086CB9B507219EE95DB113A917678B2  30c81c46a35ce411e5fbc1191a0a52ef  73bed6b8e3c1743b7116e69e22229516
-73BED6B8E3C1743B7116E69E22229516  f69f2445df4f9b17ad2b417be66c3710  3ff1caa1681fac09120eca307586e1a7
-
-================================ AES CBC 192-bit encryption mode ================================
-
-Encryption key: 8e73b0f7da0e6452c810f32b809079e562f8ead2522c6b7b
-
-Initialization vector             Test vector                       Cipher text
-000102030405060708090A0B0C0D0E0F  6bc1bee22e409f96e93d7e117393172a  4f021db243bc633d7178183a9fa071e8
-4F021DB243BC633D7178183A9FA071E8  ae2d8a571e03ac9c9eb76fac45af8e51  b4d9ada9ad7dedf4e5e738763f69145a
-B4D9ADA9AD7DEDF4E5E738763F69145A  30c81c46a35ce411e5fbc1191a0a52ef  571b242012fb7ae07fa9baac3df102e0
-571B242012FB7AE07FA9BAAC3DF102E0  f69f2445df4f9b17ad2b417be66c3710  08b0e27988598881d920a9e64f5615cd
-
-================================ AES CBC 256-bit encryption mode ================================
-
-Encryption key: 603deb1015ca71be2b73aef0857d77811f352c073b6108d72d9810a30914dff4
-
-Initialization vector             Test vector                       Cipher text
-000102030405060708090A0B0C0D0E0F  6bc1bee22e409f96e93d7e117393172a  f58c4c04d6e5f1ba779eabfb5f7bfbd6
-F58C4C04D6E5F1BA779EABFB5F7BFBD6  ae2d8a571e03ac9c9eb76fac45af8e51  9cfc4e967edb808d679f777bc6702c7d
-9CFC4E967EDB808D679F777BC6702C7D  30c81c46a35ce411e5fbc1191a0a52ef  39f23369a9d9bacfa530e26304231461
-39F23369A9D9BACFA530E26304231461  f69f2445df4f9b17ad2b417be66c3710  b2eb05e2c39be9fcda6c19078c6a9d1b
-*/
\ No newline at end of file
--- texlive-bin.orig/texk/web2c/luatexdir/luapplib/util/utilcrypt.h
+++ /dev/null
@@ -1,90 +0,0 @@
-#ifndef UTIL_CRYPT_H
-#define UTIL_CRYPT_H
-
-#include <stdint.h>
-#include <stddef.h>
-#include "utiliof.h"
-
-#ifndef UTIL_CRYPT_TIME
-#  define UTIL_CRYPT_TIME 0
-#endif
-
-/* RC4 */
-
-typedef uint8_t rc4_map[256];
-
-typedef struct rc4_state rc4_state;
-
-#define RC4_STATE_ALLOC (1<<0)
-
-UTILAPI rc4_state * rc4_state_initialize (rc4_state *state, rc4_map *map, const void *vkey, size_t keylength);
-#define rc4_state_init(state, vkey, keylength) rc4_state_initialize(state, NULL, vkey, keylength)
-UTILAPI void rc4_map_save (rc4_state *state, rc4_map *map);
-UTILAPI void rc4_map_restore (rc4_state *state, rc4_map *map);
-
-/* Codecs operating on iof */
-
-UTILAPI iof_status rc4_crypt_state (iof *I, iof *O, rc4_state *state);
-#define rc4_encode_state(I, O, state) rc4_crypt_state(I, O, state)
-#define rc4_decode_state(I, O, state) rc4_crypt_state(I, O, state)
-
-UTILAPI iof_status rc4_crypt (iof *I, iof *O, const void *key, size_t length);
-#define rc4_encode(I, O) rc4_crypt(I, O, key, length)
-#define rc4_decode(I, O) rc4_crypt(I, O, key, length)
-
-UTILAPI size_t rc4_crypt_data (const void *input, size_t length, void *output, const void *key, size_t keylength);
-UTILAPI size_t rc4_crypt_state_data (rc4_state *state, const void *input, size_t length, void *output);
-#define rc4_encode_data(input, length, output, key, keylength) rc4_crypt_data(input, length, output, key, keylength)
-#define rc4_decode_data(input, length, output, key, keylength) rc4_crypt_data(input, length, output, key, keylength)
-#define rc4_encode_state_data(state, input, length, output) rc4_crypt_state_data(state, input, length, output)
-#define rc4_decode_state_data(state, input, length, output) rc4_crypt_state_data(state, input, length, output)
-
-UTILAPI void rc4_state_close (rc4_state *state);
-
-/* AES */
-
-typedef uint8_t aes_block[4][4];
-typedef aes_block aes_keyblock[15]; // aes128 - 10+1, aes192 - 12+1, aes256 - 14+1
-
-typedef struct aes_state aes_state;
-
-#define AES_STATE_ALLOC (1<<0)
-//#define AES_ECB_MODE (1<<2)
-#define AES_HAS_IV (1<<3)
-#define AES_INLINE_IV (1<<4)
-#define AES_CONTINUE (1<<5)
-#define AES_NULL_PADDING (1<<6)
-
-UTILAPI void aes_pdf_mode (aes_state *state);
-//UTILAPI aes_state * aes_state_initialize_ecb (aes_state *State, uint8_t *roundkey, const uint8_t *key);
-UTILAPI aes_state * aes_encode_initialize (aes_state *state, aes_keyblock *keyblock, const void *key, size_t keylength, const void *iv);
-UTILAPI aes_state * aes_decode_initialize (aes_state *state, aes_keyblock *keyblock, const void *key, size_t keylength, const void *iv);
-#define aes_encode_init(state, key, keylength) aes_encode_initialize(state, NULL, key, keylength, NULL)
-#define aes_decode_init(state, key, keylength) aes_decode_initialize(state, NULL, key, keylength, NULL)
-
-UTILAPI void aes_state_close (aes_state *state);
-
-/* Codecs operating on iof */
-
-UTILAPI iof_status aes_encode_state (iof *I, iof *O, aes_state *state);
-UTILAPI iof_status aes_decode_state (iof *I, iof *O, aes_state *state);
-
-UTILAPI size_t aes_encode_data (const void *input, size_t length, void *output, const void *key, size_t keylength, const void *iv, int flags);
-UTILAPI size_t aes_encode_state_data (aes_state *state, const void *input, size_t length, void *output);
-UTILAPI size_t aes_decode_data (const void *input, size_t length, void *output, const void *key, size_t keylength, const void *iv, int flags);
-UTILAPI size_t aes_decode_state_data (aes_state *state, const void *input, size_t length, void *output);
-
-/* random bytes generator */
-
-UTILAPI void random_bytes (uint8_t *output, size_t size);
-UTILAPI void aes_generate_iv (uint8_t output[16]);
-
-/* filters */
-
-iof * iof_filter_rc4_decoder (iof *N, const void *key, size_t keylength);
-iof * iof_filter_rc4_encoder (iof *N, const void *key, size_t keylength);
-
-iof * iof_filter_aes_decoder (iof *N, const void *key, size_t keylength);
-iof * iof_filter_aes_encoder (iof *N, const void *key, size_t keylength);
-
-#endif
\ No newline at end of file
--- texlive-bin.orig/texk/web2c/luatexdir/luapplib/util/utilcryptdef.h
+++ /dev/null
@@ -1,30 +0,0 @@
-
-#ifndef UTIL_CRYPTDEF_H
-#define UTIL_CRYPTDEF_H
-
-struct rc4_state {
-  union {
-    rc4_map *map;
-    uint8_t *smap;
-  };
-  int i, j;
-  int flush;
-  int flags;
-};
-
-struct aes_state {
-  size_t keylength;
-  int rounds;
-  //int keywords;
-  union {
-    aes_block block;
-    uint8_t data[16];
-  };
-  aes_keyblock *keyblock;
-  uint8_t iv[16];
-  uint8_t buffered;
-  int flush;
-  int flags;
-};
-
-#endif
\ No newline at end of file
--- texlive-bin.orig/texk/web2c/luatexdir/luapplib/util/utildecl.h
+++ /dev/null
@@ -1,28 +0,0 @@
-
-#ifndef UTIL_DECL_H
-#define UTIL_DECL_H
-
-/*
-UTILDLL - when building .dll
-UTILEXE - when building .exe to import symbols from .dll
-*/
-
-#if defined (_WIN32) || defined(_WIN64)
-#  ifdef UTILDLL
-#    define UTILAPI __declspec(dllexport)
-#    define UTILDEF __declspec(dllexport) 
-#  else
-#    ifdef UTILEXE
-#      define UTILAPI __declspec(dllimport)
-#      define UTILDEF
-#    else
-#      define UTILAPI
-#      define UTILDEF
-#    endif
-#  endif
-#else
-#  define UTILAPI
-#  define UTILDEF
-#endif
-
-#endif
\ No newline at end of file
--- texlive-bin.orig/texk/web2c/luatexdir/luapplib/util/utilflate.c
+++ /dev/null
@@ -1,319 +0,0 @@
-
-#include "utilmem.h"
-#include "utillog.h"
-#include "utilflate.h"
-#include <zlib.h>
-
-/* flate codec */
-
-/*
-Flate codec example provided at http://www.zlib.net/zpipe.c (http://www.zlib.net/zlib_how.html) uses the following scheme:
-- provide input data buffer
-- keep providing output until codec function uses it
-
-For encoder:
-
-  z->zalloc = z->zfree = z->zopaque = NULL;
-  deflateInit(z, compression_level);
-  do {
-    z->next_in = <input buffer>
-    z->avail_in = <input buffer bytes>
-    do {
-      z->next_out = <output buffer>
-      z->avail_out = <output buffer bytes>
-      deflate(z, flush);
-      // write obtained output from deflate
-    } while (z->avail_out == 0);
-    assert(z->avail_in == 0);
-  } while (flush != Z_FINISH);
-  deflateEnd(z);
-
-'z' is an internal codec state of type z_stream, 'flush' is either Z_NO_FLUSH or Z_FINISH at the end of data.
-deflate() ensures to consume the entire input if there are no obstackles to write an output. The inner loop
-provides an output space as long as it is used by deflate(). When deflate() wrote everything it could,
-it leaves z->avail_out > 0, which breaks the inner loop. At this point z->avail_in should also be zero.
-The example documentation claims that the return codes from deflate() doesn't really need to be checked,
-as checking z->avail_out for zero is enough.
-
-The scheme for decoder is pretty similar, but with substantial differences:
-- the end of stream is automatically found by decoder, so using Z_FINISH flag to indicate an end of stream
-  is not necessary, but if provided, it MUST be given only if the EOF marker actually occurs in the input chunk,
-  and subsequent calls to inflate() must consequently use Z_FINISH
-- calling inflate() as long as it uses the output buffer provided still works for decoder, but inflate()
-  does not ensure to consume the entire input, as it will read until end of stream marker
-- the return code from inflate() must be checked to ensure the proper reaction on invalid data stream and
-  end of stream signals
-- initialization must set an input buffer to NULL or to some existing chunk (the later helps zlib to perform
-  better on inflate(), but inflate() does the research on the first call anyway)
-
-  z->zalloc = z->zfree = z->zopaque = NULL;
-  z->next_in = NULL, z->avail_in = 0;
-  inflateInit(z);
-  do {
-    z->next_in = <input buffer>
-    z->avail_in = <input buffer bytes>
-    do {
-      z->next_out = <output buffer>
-      z->avail_out = <output buffer bytes>
-      status = inflate(z, flush);
-      // check return status
-      // write obtained output from inflate
-    } while (z->avail_out == 0);
-  } while (status != Z_STREAM_END);
-  inflateEnd(z);
-
-Our wrapper generally follows "prepare input, keep pomping output" scheme, but we need to support handler function
-breaks on IOFEMPTY and IOFFULL. For a consistent come back from those on subsequent calls to the handler function,
-we use 3 states:
-- FLATE_IN - get input, when got something then goto FALTE_OUT
-- FLATE_OUT - set z_stream buffers and keep writing output until enything to write, then goto FLATE_IN or FLATE_DONE
-- FLATE_DONE - we are done, no return from that state
-Distinction of FLATE_IN and FLATE_OUT states guarantees that we will not get more input until zlib consumes the stuff
-from the previous feed, possibly interrupted by IOFFULL return on filling the output buffer. This distinction is not
-critical, but makes the filter running according to the scheme described above. Note that we set zlib input buffer
-(z->next_in, z->avail_in) at the beginning of FLATE_OUT state. Also note that we always update our buffers according
-to updated avail_in / avail_out values, just after a call to inflate() / deflate(). So no matter what have happens
-between handler calls, zlib input buffer is in sync with ours.
-*/
-
-struct flate_state {
-  z_stream z;
-  int flush;
-  int status;
-  int level; /* encoder compression level -1..9 */
-};
-
-enum {
-  FLATE_IN,
-  FLATE_OUT,
-  FLATE_DONE
-};
-
-flate_state * flate_decoder_init (flate_state *state)
-{ /* initialize zlib */
-  z_stream *z = &state->z;
-  z->zalloc = Z_NULL;
-  z->zfree = Z_NULL;
-  z->opaque = Z_NULL;
-  z->avail_in = 0;     /* must be initialized before inflateInit() */
-  z->next_in = Z_NULL; /* ditto */
-  if (inflateInit(z) != Z_OK)
-    return NULL;
-  state->status = FLATE_IN;
-  return state;
-}
-
-flate_state * flate_encoder_init (flate_state *state)
-{
-  z_stream *z = &state->z;
-  z->zalloc = Z_NULL;
-  z->zfree = Z_NULL;
-  z->opaque = Z_NULL;
-  z->avail_in = 0;
-  z->next_in = Z_NULL;
-  state->level = Z_DEFAULT_COMPRESSION; // will probably be moved upward
-  if (deflateInit(z, state->level) != Z_OK)
-    return NULL;
-  state->status = FLATE_IN;
-  return state;
-}
-
-static const char * zmess (int zstatus)
-{
-  switch (zstatus)
-  {
-    case Z_OK:            return "ok";
-    case Z_STREAM_END:    return "end of stream";
-    case Z_BUF_ERROR:     return "buffer error";
-    case Z_STREAM_ERROR:  return "stream error";
-    case Z_NEED_DICT:     return "need dict";
-    case Z_DATA_ERROR:    return "data error";
-    case Z_MEM_ERROR:     return "memory error";
-    case Z_VERSION_ERROR: return "version error";
-    case Z_ERRNO:         return "io error";
-    default:
-      break;
-  }
-  return "unknown error";
-}
-
-iof_status flate_decode_state (iof *I, iof *O, flate_state *state)
-{
-  z_stream *z;
-  int zstatus = Z_OK;
-  z = &state->z;
-  while (state->status != FLATE_DONE)
-  {
-    if (state->status == FLATE_IN)
-    {
-      if (!iof_readable(I))
-        return state->flush ? IOFERR : IOFEMPTY;
-      state->status = FLATE_OUT;
-    }
-    z->next_in = (Bytef *)I->pos;
-    z->avail_in = (uInt)iof_left(I);
-    do {
-      if (!iof_writable(O))
-        return IOFFULL;
-      z->next_out = (Bytef *)O->pos;
-      z->avail_out = (uInt)iof_left(O);
-      zstatus = inflate(z, Z_NO_FLUSH);
-      I->pos += iof_left(I) - z->avail_in;
-      O->pos += iof_left(O) - z->avail_out;
-      switch (zstatus)
-      {
-        case Z_OK:
-        case Z_STREAM_END:
-          break;
-        default:
-          loggerf("flate decoder %s (%d)", zmess(zstatus), zstatus);
-          return IOFERR;
-      }
-    } while (z->avail_out == 0);
-    state->status = zstatus == Z_STREAM_END ? FLATE_DONE : FLATE_IN;
-  }
-  return IOFEOF;
-}
-
-iof_status flate_encode_state (iof *I, iof *O, flate_state *state)
-{
-  z_stream *z;
-  int zstatus;
-  z = &state->z;
-  while (state->status != FLATE_DONE)
-  {
-    if (state->status == FLATE_IN)
-    {
-      if (!iof_readable(I))
-        if (!state->flush)
-          return IOFEMPTY;
-      state->status = FLATE_OUT;
-    }
-    z->next_in = (Bytef *)I->pos;
-    z->avail_in = (uInt)iof_left(I);
-    do {
-      if (!iof_writable(O))
-        return IOFFULL;
-      z->next_out = (Bytef *)O->pos;
-      z->avail_out = (uInt)iof_left(O);
-      zstatus = deflate(z, state->flush ? Z_FINISH : Z_NO_FLUSH);
-      I->pos += iof_left(I) - z->avail_in;
-      O->pos += iof_left(O) - z->avail_out;
-      switch (zstatus)
-      {
-        case Z_OK:
-        case Z_STREAM_END:
-          break;
-        default:
-          loggerf("flate encoder %s (%d)", zmess(zstatus), zstatus);
-          return IOFERR;
-      }
-    } while (z->avail_out == 0);
-    state->status = state->flush ? FLATE_DONE : FLATE_IN;
-  }
-  return IOFEOF;
-}
-
-
-void flate_decoder_close (flate_state *state)
-{
-  inflateEnd(&state->z);
-}
-
-void flate_encoder_close (flate_state *state)
-{
-  deflateEnd(&state->z);
-}
-
-/* filter */
-
-// flate decoder function
-
-static size_t flate_decoder (iof *F, iof_mode mode)
-{
-  flate_state *state;
-  iof_status status;
-  size_t tail;
-
-  state = iof_filter_state(flate_state *, F);
-  switch(mode)
-  {
-    case IOFLOAD:
-    case IOFREAD:
-      if (F->flags & IOF_STOPPED)
-        return 0;
-      tail = iof_tail(F);
-      F->pos = F->buf + tail;
-      F->end = F->buf + F->space;
-      do {
-        status = flate_decode_state(F->next, F, state);
-      } while (mode == IOFLOAD && status == IOFFULL && iof_resize_buffer(F));
-      return iof_decoder_retval(F, "flate", status);
-    case IOFCLOSE:
-      flate_decoder_close(state);
-      iof_free(F);
-      return 0;
-    default:
-      break;
-  }
-  return 0;
-}
-
-// flate encoder function
-
-static size_t flate_encoder (iof *F, iof_mode mode)
-{
-  flate_state *state;
-  iof_status status;
-
-  state = iof_filter_state(flate_state *, F);
-  switch (mode)
-  {
-    case IOFFLUSH:
-      state->flush = 1;
-      // fall through
-    case IOFWRITE:
-      F->end = F->pos;
-      F->pos = F->buf;
-      status = flate_encode_state(F, F->next, state);
-      return iof_encoder_retval(F, "flate", status);
-    case IOFCLOSE:
-      if (!state->flush)
-        flate_encoder(F, IOFFLUSH);
-      flate_encoder_close(state);
-      iof_free(F);
-      return 0;
-    default:
-      break;
-  }
-  return 0;
-}
-
-iof * iof_filter_flate_decoder (iof *N)
-{
-  iof *I;
-  flate_state *state;
-  I = iof_filter_reader(flate_decoder, sizeof(flate_state), &state);
-  iof_setup_next(I, N);
-  if (flate_decoder_init(state) == NULL)
-  {
-    iof_discard(I);
-    return NULL;
-  }
-  state->flush = 1;
-  return I;
-}
-
-iof * iof_filter_flate_encoder (iof *N)
-{
-  iof *O;
-  flate_state *state;
-  O = iof_filter_writer(flate_encoder, sizeof(flate_state), &state);
-  iof_setup_next(O, N);
-  if (flate_encoder_init(state) == NULL)
-  {
-    iof_discard(O);
-    return NULL;
-  }
-  return O;
-}
--- texlive-bin.orig/texk/web2c/luatexdir/luapplib/util/utilflate.h
+++ /dev/null
@@ -1,21 +0,0 @@
-#ifndef UTIL_FLATE_H
-#define UTIL_FLATE_H
-
-#include "utiliof.h"
-
-typedef struct flate_state flate_state;
-
-flate_state * flate_decoder_init (flate_state *state);
-flate_state * flate_encoder_init (flate_state *state);
-
-iof_status flate_decode_state (iof *I, iof *O, flate_state *state);
-iof_status flate_encode_state (iof *I, iof *O, flate_state *state);
-
-void flate_decoder_close (flate_state *state);
-void flate_encoder_close (flate_state *state);
-
-iof * iof_filter_flate_decoder (iof *N);
-iof * iof_filter_flate_encoder (iof *N);
-
-
-#endif
\ No newline at end of file
--- texlive-bin.orig/texk/web2c/luatexdir/luapplib/util/utilfpred.c
+++ /dev/null
@@ -1,783 +0,0 @@
-/* predictor filters; common for flate and lzw */
-
-#include "utilmem.h"
-#include "utillog.h"
-#include "utilfpred.h"
-
-/*
-Here we implement predictor filters used with flate and lzw compressions in PDF streams. The main idea of data prediction
-is to compute and output the differences between data records instead of this records. Adjacent pixels in images are usually
-similar, so differences between pixel values tends to be zero. And both Flate and LZW performs better when the input
-is rather smooth. Although a preliminary use of predictors is related to bitmap data, The actual need for predictor filter
-came from the fact that xref streams may also be predicted (usually with PNG up-predictor).
-
-PDF specification allows to use several predictor algorithms, specified by /Predictor key in /DecodeParms dictionary:
-
-   1 - no predictor (default)
-   2 - TIFF horizontal predictor
-  10 - PNG none predictor
-  11 - PNG sub predictor
-  12 - PNG up predictor
-  13 - PNG average predictor
-  14 - PNG paeth predictor
-
-All PNG predictors works on bytes, regardless the image color-depth. While encoding, every input data byte is decreased
-by the appropriate byte of the previous pixel. Even if the pixel does not fit a full byte, PNG predictors use an artificial
-pixel size rounded up to a full byte. PNG predictors utilizes previous (left) pixel, pixel above and previous to above
-pixel. In case of PNG, the type of the predictor is written on a dedicated byte on the beginning of every scanline. It
-means all predictor functions must maintain and information about left, above and left-above pixels.
-
-Despite the same differencing idea, TIFF predictors are different. The prediction process bases on pixel components,
-which are not necessarily bytes (component of a pixel is added/substracted from a relevant component of a previous
-pixel). In TIFF predictor 2, only the previous (the left) pixel is taken into account, there is no need to keep
-an information about other surrounding pixels. Also there is no expicit algorithm marker in data; the same prediction
-method is applied to all input rows.
-
-Not surprisingly, predictor encoders and decoders are pretty similar. Encoders take some input value and the previous
-input value (or 0 at the beginning of the scanline) and output a difference between them. Decoders takes an input value,
-previously decoded value (or zero) and outputs their sum. When encoding, the result is cast to the proper unsigned integer,
-when decoding, modulo 256 (or appropriate) is used, which makes encoding and decoding looseless.
-
-Some extra bits trickery is involved in TIFF predictor function, when components doesn't fit bytes boundary. In that case,
-an input is treated as an bits stream. Every input byte is "buffered" in a larger integer, as its lower bits (from right).
-Every output value is taken from its higher (left) bits. In a special case of bits-per-component equal 1, we buffer all
-pixel bits and use XOR to compute bits difference between pixels. I've excerpted that trick from poppler, but I'm not
-really sure if it works any better, especially when the number of components per pixel is 1. In that case we do a hard
-bit-by-bit work anyway.
-
-Predictor codecs state keeps a notion of surrounding pixels. PNG predictors uses left, up and upleft
-pixel data, while TIFF predictor (2) only needs the previous (left) pixel. Important to note that PNG
-predictors always work on bytes, no matter of color-depth (bits per component), while TIFF predictor
-works on pixel components, which not necessarily fits into a complete byte. However, for PNG predictor
-the size of a pixel still matters, because 'left' and 'upleft' refers to a corresponding pixel byte,
-not necessarily previous byte.
-
-In PNG prediction, we record every pixel byte (in decoded form) in state->rowsave. At the end of a scanline
-we copy state->rowsave to state->rowup, so that in the next scanline we can access up-pixel byte.
-Left pixel byte is accessed as state->rowsave (the byte recently stored or virtual left edge byte \0).
-Up-left pixel byte is accessed via state->rowup, but with state->pixelsize offset (same as left byte, possibly \0
-at the left edge of the row). Both state->rowup and state->rowsave has a safe span of pixelsize bytes on the left,
-that are permanently \0.
-*/
-
-#define predictor_component_t unsigned short
-#define predictor_pixel1b_t unsigned int
-
-typedef struct predictor_state {
-  int default_predictor;                      /* default predictor indicator */
-  int current_predictor;                      /* current predictor, possibly taken from algorithm marker in PNG data */
-  int rowsamples;                             /* number of pixels in a scanline (/DecodeParms << /Columns ... >>) */
-  int compbits;                               /* number of bits per component (/DecodeParms << /BitsPerComponent ... >>) */
-  int components;                             /* number of components (/DecodeParms << /Colors ... >>) */
-  uint8_t *buffer;                            /* temporary private buffer area */
-  uint8_t *rowin;                             /* an input row buffer position */
-  int rowsize;                                /* size of a current scanline in bytes (rounded up) */
-  int rowend;                                 /* an input buffer end position */
-  int rowindex;                               /* an output buffer position */
-  union {
-    struct {                                  /* used by PNG predictor codecs */
-      uint8_t *rowup, *rowsave;               /* previous scanline buffers */
-      int predictorbyte;                      /* flag indicating that algorithm byte is read/written */
-      int pixelsize;                          /* number of bytes per pixel (rounded up) */
-    };
-    struct {                                  /* used by TIFF predictor codecs */
-      union {
-        predictor_component_t *prevcomp;      /* an array of left pixel components */
-        predictor_pixel1b_t *prevpixel;       /* left pixel value stored on a single integer (for 1bit color-depth) */
-      };
-      int compin, compout;                    /* bit stream buffers */
-      int bitsin, bitsout;                    /* bit stream counters */
-      int sampleindex;                        /* pixel counter */
-      int compindex;                          /* component counter */
-      int pixbufsize;                         /* size of pixel buffer in bytes */
-    };
-  };
-  int flush;
-  int status;
-} predictor_state;
-
-enum {
-  STATUS_LAST = 0,
-  STATUS_CONTINUE = 1 // any value different then IOFEOF, IOFERR, ...
-};
-
-predictor_state * predictor_decoder_init (predictor_state *state, int predictor, int rowsamples, int components, int compbits)
-{
-  int rowsize, pixelsize;
-#define storage_pos(b, p, size) ((b = p), (p += size))
-  uint8_t *buffer, *p;
-  size_t buffersize;
-
-  pixelsize = (components * compbits + 7) >> 3; // to bytes, rounded up
-  rowsize = (rowsamples * components * compbits + 7) >> 3;
-
-  state->default_predictor = state->current_predictor = predictor;
-  state->rowsamples = rowsamples;
-  state->components = components;
-  state->compbits = compbits;
-
-  if (predictor == 2)
-  { /* tiff predictor */
-    size_t compbuf, pixbuf;
-    compbuf = state->components * sizeof(predictor_component_t);
-    pixbuf = 1 * sizeof(predictor_pixel1b_t);
-    state->pixbufsize = (int)(compbuf > pixbuf ? compbuf : pixbuf);
-    buffersize = rowsize + state->pixbufsize;
-    buffer = (uint8_t *)util_calloc(buffersize, 1);
-#if defined __arm__ || defined __ARM__ || defined ARM || defined __ARM || defined __arm || defined __ARM_ARCH ||defined __aarch64__ 
-    { /*memory leak */
-      predictor_component_t *c;
-      if (state->pixbufsize%(sizeof(predictor_component_t))) {
-       c = malloc(state->pixbufsize - state->pixbufsize%(sizeof(predictor_component_t)) + sizeof(predictor_component_t) );
-      } else {
-       c = malloc(state->pixbufsize); 
-      }
-      memcpy(c,(state->rowin + rowsize),state->pixbufsize);
-      if (state->prevcomp){
-	free(state->prevcomp);
-      }
-      state->prevcomp = c;
-    }
-#else
-    state->prevcomp = (predictor_component_t *)(state->rowin + rowsize);
-#endif			
-    state->sampleindex = state->compindex = 0;
-    state->bitsin = state->bitsout = 0;
-    state->compin = state->compout = 0;
-  }
-  else
-  { /* png predictors */
-    buffersize = (3 * rowsize + 2 * pixelsize + 1) * sizeof(uint8_t);
-    p = buffer = (uint8_t *)util_calloc(buffersize, 1);
-    storage_pos(state->rowin, p, 1 + rowsize); // one extra byte for prediction algorithm tag
-    p += pixelsize;                            // pixelsize extra bytes for virtual left pixel at the edge, eg. rowup[-1] (permanently \0)
-    storage_pos(state->rowup, p, rowsize);     // actual row byte
-    p += pixelsize;                            // ditto
-    storage_pos(state->rowsave, p, rowsize);
-    state->pixelsize = pixelsize;
-    state->predictorbyte = 0;
-  }
-  state->buffer = buffer;
-  state->rowsize = rowsize;
-  state->rowindex = 0;
-  state->rowend = 0;
-  state->status = STATUS_CONTINUE;
-  return state;
-}
-
-predictor_state * predictor_encoder_init (predictor_state *state, int predictor, int rowsamples, int components, int compbits)
-{
-  return predictor_decoder_init(state, predictor, rowsamples, components, compbits);
-}
-
-void predictor_decoder_close (predictor_state *state)
-{
-  util_free(state->buffer);
-}
-
-void predictor_encoder_close (predictor_state *state)
-{
-  util_free(state->buffer);
-}
-
-/*
-Predictor type identifiers (pdf spec 76). lpdf doesn't hire the codec if predictor is 1. Predictor 15 indicates
-that the type of PNG prediction algorithm may change in subsequent lines. We always check algorithm marker anyway.
-*/
-
-enum predictor_code {
-  NONE_PREDICTOR = 1,
-  TIFF_PREDICTOR = 2,
-  PNG_NONE_PREDICTOR = 10,
-  PNG_SUB_PREDICTOR = 11,
-  PNG_UP_PREDICTOR = 12,
-  PNG_AVERAGE_PREDICTOR = 13,
-  PNG_PAETH_PREDICTOR = 14,
-  PNG_OPTIMUM_PREDICTOR = 15
-};
-
-/*
-All predoctor codecs first read the entire data row into a buffer. This is not crucial for the process,
-but allows to separate read/write states. In particular, there is one place in which codec functions
-may return on EOD.
-*/
-
-#define start_row(state) (state->rowindex = 0, state->rowin = state->buffer)
-
-static int read_scanline (predictor_state *state, iof *I, int size)
-{
-  int rowtail, left;
-  while ((rowtail = size - state->rowend) > 0)
-  {
-    left = (int)iof_left(I);
-    if (left >= rowtail)
-    {
-      memcpy(state->buffer + state->rowend, I->pos, (size_t)rowtail);
-      state->rowend += rowtail;
-      I->pos += rowtail;
-      start_row(state);
-      break;
-    }
-    else
-    {
-      if ((rowtail = left) > 0)
-      {
-        memcpy(state->buffer + state->rowend, I->pos, (size_t)rowtail);
-        state->rowend += rowtail;
-        I->pos += rowtail;
-      }
-      if (iof_input(I) == 0)
-      {
-        if (state->rowend == 0) // no scanline to process, no more input
-          return state->flush ? IOFEOF : IOFEMPTY;
-        /* If we are here, there is an incomplete scanline in buffer:
-           - if there is a chance for more (state->flush == 0), than wait for more
-           - otherwise encode/decode the last incomplete line?
-           pdf spec p. 76 says that "A row occupies a whole number of bytes",
-           so this situation should be considered abnormal (not found so far).
-         */
-        if (!state->flush)
-          return IOFEMPTY;
-        loggerf("incomplete scanline in predictor filter");
-        //return IOFERR;
-        state->status = STATUS_LAST;
-        state->rowsize -= size - state->rowend;
-        start_row(state);
-        break;
-      }
-    }
-  }
-  return STATUS_CONTINUE;
-}
-
-#define read_row(state, I, size, status) if ((status = read_scanline(state, I, size)) != STATUS_CONTINUE) return status
-
-#define ensure_output_bytes(O, n) if (!iof_ensure(O, n)) return IOFFULL
-
-#define tobyte(c) ((unsigned char)(c))
-#define tocomp(c) ((unsigned short)(c))
-
-#define row_byte(state) (state->rowin[state->rowindex])
-
-#define up_pixel_byte(state)     (state->rowup[state->rowindex])
-#define upleft_pixel_byte(state) (state->rowup[state->rowindex - state->pixelsize])
-#define left_pixel_byte(state)   (state->rowsave[state->rowindex - state->pixelsize])
-
-#define save_pixel_byte(state, c) (state->rowsave[state->rowindex] = c)
-
-#define left_pixel_component(state) (state->prevcomp[state->compindex]) // tiff predictor with 2, 4, 8, 16 components
-#define left_pixel_value(state) (state->prevpixel[0])                   // tiff predictor with 1bit components
-
-#define save_pixel_component(state, c) ((void)\
-  ((state->prevcomp[state->compindex] = c), \
-   (++state->compindex < state->components || (state->compindex = 0))))
-
-#define save_pixel_value(state, c) (state->prevpixel[0] = c)
-
-/* Once the codec function is done with the scanline, we set imaginary left pixel data to zero, and reset row counters to
-zero in order to allow buffering another input scanline. */
-
-#define reset_row(state) state->rowend = 0
-
-#define reset_png_row(state) (memcpy(state->rowup, state->rowsave, state->rowsize), state->predictorbyte = 0, reset_row(state))
-
-#define reset_tiff_row(state) \
-  memset(state->prevcomp, 0, state->pixbufsize), \
-  state->bitsin = state->bitsout = 0, \
-  state->compin = state->compout = 0, \
-  reset_row(state), \
-  state->sampleindex = state->compindex = 0
-
-/* PNG paeth predictor function; http://www.libpng.org/pub/png/book/chapter09.html
-Compute the base value p := left + up - upleft, then choose that byte the closest
-(of the smallest absolute difference) to the base value. Left byte has a precedence. */
-
-
-static int paeth (predictor_state *state)
-{
-  int p, p1, p2, p3;
-  p = left_pixel_byte(state) + up_pixel_byte(state) - upleft_pixel_byte(state);
-  p1 = p >= left_pixel_byte(state)   ? (p - left_pixel_byte(state))   : (left_pixel_byte(state) - p);
-  p2 = p >= up_pixel_byte(state)     ? (p - up_pixel_byte(state))     : (up_pixel_byte(state) - p);
-  p3 = p >= upleft_pixel_byte(state) ? (p - upleft_pixel_byte(state)) : (upleft_pixel_byte(state) - p);
-  return (p1 <= p2 && p1 <= p3) ? left_pixel_byte(state) : (p2 <= p3 ? up_pixel_byte(state) : upleft_pixel_byte(state));
-}
-
-/* predictor decoder */
-
-iof_status predictor_decode_state (iof *I, iof *O, predictor_state *state)
-{
-  int status, c, d, outbytes;
-  while (state->status == STATUS_CONTINUE)
-  {
-    if (state->default_predictor >= 10) // PNG predictor?
-    {
-      read_row(state, I, state->rowsize + 1, status);
-      if (state->predictorbyte == 0)
-      { // we could actually check state->rowin <> state->buffer, but we need this flag for encoder anyway
-        state->current_predictor = row_byte(state) + 10;
-        state->predictorbyte = 1;
-        ++state->rowin;
-      }
-    }
-    else
-    {
-      read_row(state, I, state->rowsize, status);
-    }
-    switch (state->current_predictor)
-    {
-      case NONE_PREDICTOR:
-        for ( ; state->rowindex < state->rowsize; ++state->rowindex)
-        {
-          ensure_output_bytes(O, 1);
-          c = row_byte(state);
-          iof_set(O, c);
-        }
-        reset_row(state);
-        break;
-      case TIFF_PREDICTOR:
-        switch (state->compbits)
-        {
-          case 1:
-            outbytes = (state->components + 7) >> 3;
-            for ( ; state->sampleindex < state->rowsamples; ++state->sampleindex)
-            {
-              ensure_output_bytes(O, outbytes);
-              while (state->bitsin < state->components)
-              {
-                state->compin = (state->compin << 8) | row_byte(state);
-                state->bitsin += 8;
-                ++state->rowindex;
-              }
-              state->bitsin -= state->components;
-              d = state->compin >> state->bitsin;
-              state->compin &= (1 << state->bitsin) - 1;
-              c = d ^ left_pixel_value(state);
-              save_pixel_value(state, c);
-              state->compout = (state->compout << state->components) | c;
-              state->bitsout += state->components;
-              while (state->bitsout >= 8)
-              {
-                state->bitsout -= 8;
-                iof_set(O, state->compout >> state->bitsout);
-                state->compout &= (1 << state->bitsout) - 1;
-              }
-            }
-            if (state->bitsout > 0)
-            {
-              ensure_output_bytes(O, 1);
-              iof_set(O, state->compin << (8 - state->bitsout));
-            }
-            break;
-          case 2: case 4:
-            for ( ; state->sampleindex < state->rowsamples; ++state->sampleindex)
-            {
-              for ( ; state->compindex < state->components; ) // state->compindex is ++ed  by save_pixel_component()
-              {
-                ensure_output_bytes(O, 1);
-                if (state->bitsin < state->compbits)
-                {
-                  state->compin = (state->compin << 8) | row_byte(state);
-                  state->bitsin += 8;
-                  ++state->rowindex;
-                }
-                state->bitsin -= state->compbits;
-                d = state->compin >> state->bitsin;
-                state->compin &= (1 << state->bitsin) - 1;
-                c = (d + left_pixel_component(state)) & 0xff;
-                save_pixel_component(state, c);
-                state->compout = (state->compout << state->compbits) | c;
-                state->bitsout += state->compbits;
-                if (state->bitsout >= 8)
-                {
-                  state->bitsout -= 8;
-                  iof_set(O, state->compout >> state->bitsout);
-                  state->compout &= (1 << state->bitsout) - 1;
-                }
-              }
-            }
-            if (state->bitsout > 0)
-            {
-              ensure_output_bytes(O, 1);
-              iof_set(O, state->compin << (8 - state->bitsout));
-            }
-            break;
-          case 8:
-            for ( ; state->rowindex < state->rowsize; ++state->rowindex)
-            {
-              ensure_output_bytes(O, 1);
-              c = (row_byte(state) + left_pixel_component(state)) & 0xff;
-              save_pixel_component(state, c);
-              iof_set(O, c);
-            }
-            break;
-          case 16:
-            for ( ; state->rowindex < state->rowsize - 1; ++state->rowindex)
-            {
-              ensure_output_bytes(O, 2);
-              d = row_byte(state) << 8;
-              ++state->rowindex;
-              d |= row_byte(state);
-              c = (d + left_pixel_component(state)) & 0xff;
-              save_pixel_component(state, c);
-              iof_set2(O, c >> 8, c & 0xff);
-            }
-            break;
-          default:
-            return IOFERR;
-        }
-        reset_tiff_row(state);
-        break;
-      case PNG_NONE_PREDICTOR:
-        for ( ; state->rowindex < state->rowsize; ++state->rowindex)
-        {
-          ensure_output_bytes(O, 1);
-          c = row_byte(state);
-          save_pixel_byte(state, c); // next row may need it
-          iof_set(O, c);
-        }
-        reset_png_row(state);
-        break;
-      case PNG_SUB_PREDICTOR:
-        for ( ; state->rowindex < state->rowsize; ++state->rowindex)
-        {
-          ensure_output_bytes(O, 1);
-          c = (row_byte(state) + left_pixel_byte(state)) & 0xff;
-          save_pixel_byte(state, c);
-          iof_set(O, c);
-        }
-        reset_png_row(state);
-        break;
-      case PNG_UP_PREDICTOR:
-        for ( ; state->rowindex < state->rowsize; ++state->rowindex)
-        {
-          ensure_output_bytes(O, 1);
-          c = (row_byte(state) + up_pixel_byte(state)) & 0xff;
-          save_pixel_byte(state, c);
-          iof_set(O, c);
-        }
-        reset_png_row(state);
-        break;
-      case PNG_AVERAGE_PREDICTOR:
-        for ( ; state->rowindex < state->rowsize; ++state->rowindex)
-        {
-          ensure_output_bytes(O, 1);
-          c = (row_byte(state) + ((up_pixel_byte(state) + left_pixel_byte(state)) / 2)) & 0xff;
-          save_pixel_byte(state, c);
-          iof_set(O, c);
-        }
-        reset_png_row(state);
-        break;
-      case PNG_PAETH_PREDICTOR:
-        for ( ; state->rowindex < state->rowsize; ++state->rowindex)
-        {
-          ensure_output_bytes(O, 1);
-          c = (row_byte(state) + paeth(state)) & 0xff;
-          save_pixel_byte(state, c);
-          iof_set(O, c);
-        }
-        reset_png_row(state);
-        break;
-      //case PNG_OPTIMUM_PREDICTOR: // valid as default_redictor, but not as algorithm identifier byte
-      default:
-        return IOFERR;
-    }
-  }
-  return state->status == STATUS_LAST ? IOFERR : IOFEOF;
-}
-
-/* predictor encoder */
-
-iof_status predictor_encode_state (iof *I, iof *O, predictor_state *state)
-{
-  int status, c, d, outbytes;
-  while (state->status == STATUS_CONTINUE)
-  {
-    read_row(state, I, state->rowsize, status);
-    if (state->current_predictor >= 10 && state->predictorbyte == 0)
-    {
-      ensure_output_bytes(O, 1);
-      iof_set(O, state->current_predictor - 10);
-      state->predictorbyte = 1;
-    }
-    switch (state->current_predictor)
-    {
-      case NONE_PREDICTOR:
-        for ( ; state->rowindex < state->rowsize; ++state->rowindex)
-        {
-          ensure_output_bytes(O, 1);
-          c = row_byte(state);
-          iof_set(O, c);
-        }
-        reset_row(state);
-        break;
-      case TIFF_PREDICTOR:
-        switch (state->compbits)
-        {
-          case 1:
-            outbytes = (state->components + 7) >> 3;
-            for ( ; state->sampleindex < state->rowsamples; ++state->sampleindex)
-            {
-              ensure_output_bytes(O, outbytes);
-              while (state->bitsin < state->components)
-              {
-                state->compin = (state->compin << 8) | row_byte(state);
-                state->bitsin += 8;
-                ++state->rowindex;
-              }
-              state->bitsin -= state->components;
-              c = state->compin >> state->bitsin;
-              state->compin &= (1 << state->bitsin) - 1;
-              d = c ^ left_pixel_value(state);
-              save_pixel_value(state, c);
-              state->compout = (state->compout << state->components) | d;
-              state->bitsout += state->components;
-              while (state->bitsout >= 8)
-              {
-                state->bitsout -= 8;
-                iof_set(O, state->compout >> state->bitsout);
-                state->compout &= (1 << state->bitsout) - 1;
-              }
-            }
-            if (state->bitsout > 0)
-            {
-              ensure_output_bytes(O, 1);
-              iof_set(O, state->compin << (8 - state->bitsout));
-            }
-            break;
-          case 2: case 4:
-            for ( ; state->sampleindex < state->rowsamples; ++state->sampleindex)
-            {
-              for ( ; state->compindex < state->components; )
-              {
-                ensure_output_bytes(O, 1);
-                if (state->bitsin < state->compbits)
-                {
-                  state->compin = (state->compin << 8) | row_byte(state);
-                  state->bitsin += 8;
-                  ++state->rowindex;
-                }
-                state->bitsin -= state->compbits;
-                c = state->compin >> state->bitsin;
-                state->compin &= (1 << state->bitsin) - 1;
-                d = tocomp(c - left_pixel_component(state));
-                save_pixel_component(state, c);
-                state->compout = (state->compout << state->compbits) | d;
-                state->bitsout += state->compbits;
-                if (state->bitsout >= 8)
-                {
-                  state->bitsout -= 8;
-                  iof_set(O, state->compout >> state->bitsout);
-                  state->compout &= (1 << state->bitsout) - 1;
-                }
-              }
-            }
-            if (state->bitsout > 0)
-            {
-              ensure_output_bytes(O, 1);
-              iof_set(O, state->compin << (8 - state->bitsout));
-            }
-            break;
-          case 8:
-            for ( ; state->rowindex < state->rowsize; ++state->rowindex)
-            {
-              ensure_output_bytes(O, 1);
-              c = row_byte(state);
-              d = tobyte(c - left_pixel_component(state));
-              save_pixel_component(state, c);
-              iof_set(O, d);
-            }
-            break;
-          case 16:
-            for ( ; state->rowindex < state->rowsize - 1; ++state->rowindex)
-            {
-              ensure_output_bytes(O, 2);
-              c = row_byte(state) << 8;
-              ++state->rowindex;
-              c |= row_byte(state);
-              d = tocomp(c - left_pixel_component(state));
-              save_pixel_component(state, c);
-              iof_set2(O, d >> 8, d & 0xff);
-            }
-            break;
-          default:
-            return IOFERR;
-        }
-        reset_tiff_row(state);
-        break;
-      case PNG_NONE_PREDICTOR:
-        for ( ; state->rowindex < state->rowsize; ++state->rowindex)
-        {
-          ensure_output_bytes(O, 1);
-          c = row_byte(state);
-          save_pixel_byte(state, c); // next row may need it
-          iof_set(O, c);
-        }
-        reset_png_row(state);
-        break;
-      case PNG_SUB_PREDICTOR:
-        for ( ; state->rowindex < state->rowsize; ++state->rowindex)
-        {
-          ensure_output_bytes(O, 1);
-          c = row_byte(state);
-          d = tobyte(c - left_pixel_byte(state));
-          save_pixel_byte(state, c);
-          iof_set(O, d);
-        }
-        reset_png_row(state);
-        break;
-      case PNG_OPTIMUM_PREDICTOR: // not worthy to perform optimization
-      case PNG_UP_PREDICTOR:
-        for ( ; state->rowindex < state->rowsize; ++state->rowindex)
-        {
-          ensure_output_bytes(O, 1);
-          c = row_byte(state);
-          d = tobyte(c - up_pixel_byte(state));
-          save_pixel_byte(state, c);
-          iof_set(O, d);
-        }
-        reset_png_row(state);
-        break;
-      case PNG_AVERAGE_PREDICTOR:
-        for ( ; state->rowindex < state->rowsize; ++state->rowindex)
-        {
-          ensure_output_bytes(O, 1);
-          c = row_byte(state);
-          d = tobyte(c - ((up_pixel_byte(state) + left_pixel_byte(state)) >> 1));
-          save_pixel_byte(state, c);
-          iof_set(O, d);
-        }
-        reset_png_row(state);
-        break;
-      case PNG_PAETH_PREDICTOR:
-        for ( ; state->rowindex < state->rowsize; ++state->rowindex)
-        {
-          ensure_output_bytes(O, 1);
-          c = row_byte(state);
-          d = tobyte(c - paeth(state));
-          save_pixel_byte(state, c);
-          iof_set(O, d);
-        }
-        reset_png_row(state);
-        break;
-      default:
-        return IOFERR;
-    }
-  }
-  return state->status == STATUS_LAST ? IOFERR : IOFEOF;
-}
-
-iof_status predictor_decode (iof *I, iof *O, int predictor, int rowsamples, int components, int compbits)
-{
-  predictor_state state;
-  int ret;
-  predictor_decoder_init(&state, predictor, rowsamples, components, compbits);
-  state.flush = 1;
-  ret = predictor_decode_state(I, O, &state);
-  predictor_decoder_close(&state);
-  return ret;
-}
-
-iof_status predictor_encode (iof *I, iof *O, int predictor, int rowsamples, int components, int compbits)
-{
-  predictor_state state;
-  int ret;
-  predictor_encoder_init(&state, predictor, rowsamples, components, compbits);
-  state.flush = 1;
-  ret = predictor_encode_state(I, O, &state);
-  predictor_encoder_close(&state);
-  return ret;
-}
-
-/* filters */
-
-// predictor decoder function
-
-static size_t predictor_decoder (iof *F, iof_mode mode)
-{
-  predictor_state *state;
-  iof_status status;
-  size_t tail;
-
-  state = iof_filter_state(predictor_state *, F);
-  switch(mode)
-  {
-    case IOFLOAD:
-    case IOFREAD:
-      if (F->flags & IOF_STOPPED)
-        return 0;
-      tail = iof_tail(F);
-      F->pos = F->buf + tail;
-      F->end = F->buf + F->space;
-      do {
-        status = predictor_decode_state(F->next, F, state);
-      } while (mode == IOFLOAD && status == IOFFULL && iof_resize_buffer(F));
-      return iof_decoder_retval(F, "predictor", status);
-    case IOFCLOSE:
-      predictor_decoder_close(state);
-      iof_free(F);
-      return 0;
-    default:
-      break;
-  }
-  return 0;
-}
-
-// predictor encoder function
-
-static size_t predictor_encoder (iof *F, iof_mode mode)
-{
-  predictor_state *state;
-  iof_status status;
-
-  state = iof_filter_state(predictor_state *, F);
-  switch (mode)
-  {
-    case IOFFLUSH:
-      state->flush = 1;
-      // fall through
-    case IOFWRITE:
-      F->end = F->pos;
-      F->pos = F->buf;
-      status = predictor_encode_state(F, F->next, state);
-      return iof_encoder_retval(F, "predictor", status);
-    case IOFCLOSE:
-      if (!state->flush)
-        predictor_encoder(F, IOFFLUSH);
-      predictor_encoder_close(state);
-      iof_free(F);
-      return 0;
-    default:
-      break;
-  }
-  return 0;
-}
-
-iof * iof_filter_predictor_decoder (iof *N, int predictor, int rowsamples, int components, int compbits)
-{
-  iof *I;
-  predictor_state *state;
-  I = iof_filter_reader(predictor_decoder, sizeof(predictor_state), &state);
-  iof_setup_next(I, N);
-  if (predictor_decoder_init(state, predictor, rowsamples, components, compbits) == NULL)
-  {
-    iof_discard(I);
-    return NULL;
-  }
-  state->flush = 1;
-  return I;
-}
-
-iof * iof_filter_predictor_encoder (iof *N, int predictor, int rowsamples, int components, int compbits)
-{
-  iof *O;
-  predictor_state *state;
-  O = iof_filter_writer(predictor_encoder, sizeof(predictor_state), &state);
-  iof_setup_next(O, N);
-  if (predictor_encoder_init(state, predictor, rowsamples, components, compbits) == NULL)
-  {
-    iof_discard(O);
-    return NULL;
-  }
-  return O;
-}
--- texlive-bin.orig/texk/web2c/luatexdir/luapplib/util/utilfpred.c-OK
+++ /dev/null
@@ -1,767 +0,0 @@
-/* predictor filters; common for flate and lzw */
-
-#include "utilmem.h"
-#include "utillog.h"
-#include "utilfpred.h"
-
-/*
-Here we implement predictor filters used with flate and lzw compressions in PDF streams. The main idea of data prediction
-is to compute and output the differences between data records instead of this records. Adjacent pixels in images are usually
-similar, so differences between pixel values tends to be zero. And both Flate and LZW performs better when the input
-is rather smooth. Although a preliminary use of predictors is related to bitmap data, The actual need for predictor filter
-came from the fact that xref streams may also be predicted (usually with PNG up-predictor).
-
-PDF specification allows to use several predictor algorithms, specified by /Predictor key in /DecodeParms dictionary:
-
-   1 - no predictor (default)
-   2 - TIFF horizontal predictor
-  10 - PNG none predictor
-  11 - PNG sub predictor
-  12 - PNG up predictor
-  13 - PNG average predictor
-  14 - PNG paeth predictor
-
-All PNG predictors works on bytes, regardless the image color-depth. While encoding, every input data byte is decreased
-by the appropriate byte of the previous pixel. Even if the pixel does not fit a full byte, PNG predictors use an artificial
-pixel size rounded up to a full byte. PNG predictors utilizes previous (left) pixel, pixel above and previous to above
-pixel. In case of PNG, the type of the predictor is written on a dedicated byte on the beginning of every scanline. It
-means all predictor functions must maintain and information about left, above and left-above pixels.
-
-Despite the same differencing idea, TIFF predictors are different. The prediction process bases on pixel components,
-which are not necessarily bytes (component of a pixel is added/substracted from a relevant component of a previous
-pixel). In TIFF predictor 2, only the previous (the left) pixel is taken into account, there is no need to keep
-an information about other surrounding pixels. Also there is no expicit algorithm marker in data; the same prediction
-method is applied to all input rows.
-
-Not surprisingly, predictor encoders and decoders are pretty similar. Encoders take some input value and the previous
-input value (or 0 at the beginning of the scanline) and output a difference between them. Decoders takes an input value,
-previously decoded value (or zero) and outputs their sum. When encoding, the result is cast to the proper unsigned integer,
-when decoding, modulo 256 (or appropriate) is used, which makes encoding and decoding looseless.
-
-Some extra bits trickery is involved in TIFF predictor function, when components doesn't fit bytes boundary. In that case,
-an input is treated as an bits stream. Every input byte is "buffered" in a larger integer, as its lower bits (from right).
-Every output value is taken from its higher (left) bits. In a special case of bits-per-component equal 1, we buffer all
-pixel bits and use XOR to compute bits difference between pixels. I've excerpted that trick from poppler, but I'm not
-really sure if it works any better, especially when the number of components per pixel is 1. In that case we do a hard
-bit-by-bit work anyway.
-
-Predictor codecs state keeps a notion of surrounding pixels. PNG predictors uses left, up and upleft
-pixel data, while TIFF predictor (2) only needs the previous (left) pixel. Important to note that PNG
-predictors always work on bytes, no matter of color-depth (bits per component), while TIFF predictor
-works on pixel components, which not necessarily fits into a complete byte. However, for PNG predictor
-the size of a pixel still matters, because 'left' and 'upleft' refers to a corresponding pixel byte,
-not necessarily previous byte.
-
-In PNG prediction, we record every pixel byte (in decoded form) in state->rowsave. At the end of a scanline
-we copy state->rowsave to state->rowup, so that in the next scanline we can access up-pixel byte.
-Left pixel byte is accessed as state->rowsave (the byte recently stored or virtual left edge byte \0).
-Up-left pixel byte is accessed via state->rowup, but with state->pixelsize offset (same as left byte, possibly \0
-at the left edge of the row). Both state->rowup and state->rowsave has a safe span of pixelsize bytes on the left,
-that are permanently \0.
-*/
-
-#define predictor_component_t unsigned short
-#define predictor_pixel1b_t unsigned int
-
-typedef struct predictor_state {
-  int default_predictor;                      /* default predictor indicator */
-  int current_predictor;                      /* current predictor, possibly taken from algorithm marker in PNG data */
-  int rowsamples;                             /* number of pixels in a scanline (/DecodeParms << /Columns ... >>) */
-  int compbits;                               /* number of bits per component (/DecodeParms << /BitsPerComponent ... >>) */
-  int components;                             /* number of components (/DecodeParms << /Colors ... >>) */
-  uint8_t *buffer;                            /* temporary private buffer area */
-  uint8_t *rowin;                             /* an input row buffer position */
-  int rowsize;                                /* size of a current scanline in bytes (rounded up) */
-  int rowend;                                 /* an input buffer end position */
-  int rowindex;                               /* an output buffer position */
-  union {
-    struct {                                  /* used by PNG predictor codecs */
-      uint8_t *rowup, *rowsave;               /* previous scanline buffers */
-      int predictorbyte;                      /* flag indicating that algorithm byte is read/written */
-      int pixelsize;                          /* number of bytes per pixel (rounded up) */
-    };
-    struct {                                  /* used by TIFF predictor codecs */
-      union {
-        predictor_component_t *prevcomp;      /* an array of left pixel components */
-        predictor_pixel1b_t *prevpixel;       /* left pixel value stored on a single integer (for 1bit color-depth) */
-      };
-      int compin, compout;                    /* bit stream buffers */
-      int bitsin, bitsout;                    /* bit stream counters */
-      int sampleindex;                        /* pixel counter */
-      int compindex;                          /* component counter */
-      int pixbufsize;                         /* size of pixel buffer in bytes */
-    };
-  };
-  int flush;
-  int status;
-} predictor_state;
-
-enum {
-  STATUS_LAST = 0,
-  STATUS_CONTINUE = 1 // any value different then IOFEOF, IOFERR, ...
-};
-
-predictor_state * predictor_decoder_init (predictor_state *state, int predictor, int rowsamples, int components, int compbits)
-{
-  int rowsize, pixelsize;
-#define storage_pos(b, p, size) ((b = p), (p += size))
-  uint8_t *buffer, *p;
-  size_t buffersize;
-
-  pixelsize = (components * compbits + 7) >> 3; // to bytes, rounded up
-  rowsize = (rowsamples * components * compbits + 7) >> 3;
-
-  state->default_predictor = state->current_predictor = predictor;
-  state->rowsamples = rowsamples;
-  state->components = components;
-  state->compbits = compbits;
-
-  if (predictor == 2)
-  { /* tiff predictor */
-    size_t compbuf, pixbuf;
-    compbuf = state->components * sizeof(predictor_component_t);
-    pixbuf = 1 * sizeof(predictor_pixel1b_t);
-    state->pixbufsize = (int)(compbuf > pixbuf ? compbuf : pixbuf);
-    buffersize = rowsize + state->pixbufsize;
-    buffer = (uint8_t *)util_calloc(buffersize, 1);
-    state->prevcomp = (predictor_component_t *)(state->rowin + rowsize);
-    state->sampleindex = state->compindex = 0;
-    state->bitsin = state->bitsout = 0;
-    state->compin = state->compout = 0;
-  }
-  else
-  { /* png predictors */
-    buffersize = (3 * rowsize + 2 * pixelsize + 1) * sizeof(uint8_t);
-    p = buffer = (uint8_t *)util_calloc(buffersize, 1);
-    storage_pos(state->rowin, p, 1 + rowsize); // one extra byte for prediction algorithm tag
-    p += pixelsize;                            // pixelsize extra bytes for virtual left pixel at the edge, eg. rowup[-1] (permanently \0)
-    storage_pos(state->rowup, p, rowsize);     // actual row byte
-    p += pixelsize;                            // ditto
-    storage_pos(state->rowsave, p, rowsize);
-    state->pixelsize = pixelsize;
-    state->predictorbyte = 0;
-  }
-  state->buffer = buffer;
-  state->rowsize = rowsize;
-  state->rowindex = 0;
-  state->rowend = 0;
-  state->status = STATUS_CONTINUE;
-  return state;
-}
-
-predictor_state * predictor_encoder_init (predictor_state *state, int predictor, int rowsamples, int components, int compbits)
-{
-  return predictor_decoder_init(state, predictor, rowsamples, components, compbits);
-}
-
-void predictor_decoder_close (predictor_state *state)
-{
-  util_free(state->buffer);
-}
-
-void predictor_encoder_close (predictor_state *state)
-{
-  util_free(state->buffer);
-}
-
-/*
-Predictor type identifiers (pdf spec 76). lpdf doesn't hire the codec if predictor is 1. Predictor 15 indicates
-that the type of PNG prediction algorithm may change in subsequent lines. We always check algorithm marker anyway.
-*/
-
-enum predictor_code {
-  NONE_PREDICTOR = 1,
-  TIFF_PREDICTOR = 2,
-  PNG_NONE_PREDICTOR = 10,
-  PNG_SUB_PREDICTOR = 11,
-  PNG_UP_PREDICTOR = 12,
-  PNG_AVERAGE_PREDICTOR = 13,
-  PNG_PAETH_PREDICTOR = 14,
-  PNG_OPTIMUM_PREDICTOR = 15
-};
-
-/*
-All predoctor codecs first read the entire data row into a buffer. This is not crucial for the process,
-but allows to separate read/write states. In particular, there is one place in which codec functions
-may return on EOD.
-*/
-
-#define start_row(state) (state->rowindex = 0, state->rowin = state->buffer)
-
-static int read_scanline (predictor_state *state, iof *I, int size)
-{
-  int rowtail, left;
-  while ((rowtail = size - state->rowend) > 0)
-  {
-    left = (int)iof_left(I);
-    if (left >= rowtail)
-    {
-      memcpy(state->buffer + state->rowend, I->pos, (size_t)rowtail);
-      state->rowend += rowtail;
-      I->pos += rowtail;
-      start_row(state);
-      break;
-    }
-    else
-    {
-      if ((rowtail = left) > 0)
-      {
-        memcpy(state->buffer + state->rowend, I->pos, (size_t)rowtail);
-        state->rowend += rowtail;
-        I->pos += rowtail;
-      }
-      if (iof_input(I) == 0)
-      {
-        if (state->rowend == 0) // no scanline to process, no more input
-          return state->flush ? IOFEOF : IOFEMPTY;
-        /* If we are here, there is an incomplete scanline in buffer:
-           - if there is a chance for more (state->flush == 0), than wait for more
-           - otherwise encode/decode the last incomplete line?
-           pdf spec p. 76 says that "A row occupies a whole number of bytes",
-           so this situation should be considered abnormal (not found so far).
-         */
-        if (!state->flush)
-          return IOFEMPTY;
-        loggerf("incomplete scanline in predictor filter");
-        //return IOFERR;
-        state->status = STATUS_LAST;
-        state->rowsize -= size - state->rowend;
-        start_row(state);
-        break;
-      }
-    }
-  }
-  return STATUS_CONTINUE;
-}
-
-#define read_row(state, I, size, status) if ((status = read_scanline(state, I, size)) != STATUS_CONTINUE) return status
-
-#define ensure_output_bytes(O, n) if (!iof_ensure(O, n)) return IOFFULL
-
-#define tobyte(c) ((unsigned char)(c))
-#define tocomp(c) ((unsigned short)(c))
-
-#define row_byte(state) (state->rowin[state->rowindex])
-
-#define up_pixel_byte(state)     (state->rowup[state->rowindex])
-#define upleft_pixel_byte(state) (state->rowup[state->rowindex - state->pixelsize])
-#define left_pixel_byte(state)   (state->rowsave[state->rowindex - state->pixelsize])
-
-#define save_pixel_byte(state, c) (state->rowsave[state->rowindex] = c)
-
-#define left_pixel_component(state) (state->prevcomp[state->compindex]) // tiff predictor with 2, 4, 8, 16 components
-#define left_pixel_value(state) (state->prevpixel[0])                   // tiff predictor with 1bit components
-
-#define save_pixel_component(state, c) ((void)\
-  ((state->prevcomp[state->compindex] = c), \
-   (++state->compindex < state->components || (state->compindex = 0))))
-
-#define save_pixel_value(state, c) (state->prevpixel[0] = c)
-
-/* Once the codec function is done with the scanline, we set imaginary left pixel data to zero, and reset row counters to
-zero in order to allow buffering another input scanline. */
-
-#define reset_row(state) state->rowend = 0
-
-#define reset_png_row(state) (memcpy(state->rowup, state->rowsave, state->rowsize), state->predictorbyte = 0, reset_row(state))
-
-#define reset_tiff_row(state) \
-  memset(state->prevcomp, 0, state->pixbufsize), \
-  state->bitsin = state->bitsout = 0, \
-  state->compin = state->compout = 0, \
-  reset_row(state), \
-  state->sampleindex = state->compindex = 0
-
-/* PNG paeth predictor function; http://www.libpng.org/pub/png/book/chapter09.html
-Compute the base value p := left + up - upleft, then choose that byte the closest
-(of the smallest absolute difference) to the base value. Left byte has a precedence. */
-
-
-static int paeth (predictor_state *state)
-{
-  int p, p1, p2, p3;
-  p = left_pixel_byte(state) + up_pixel_byte(state) - upleft_pixel_byte(state);
-  p1 = p >= left_pixel_byte(state)   ? (p - left_pixel_byte(state))   : (left_pixel_byte(state) - p);
-  p2 = p >= up_pixel_byte(state)     ? (p - up_pixel_byte(state))     : (up_pixel_byte(state) - p);
-  p3 = p >= upleft_pixel_byte(state) ? (p - upleft_pixel_byte(state)) : (upleft_pixel_byte(state) - p);
-  return (p1 <= p2 && p1 <= p3) ? left_pixel_byte(state) : (p2 <= p3 ? up_pixel_byte(state) : upleft_pixel_byte(state));
-}
-
-/* predictor decoder */
-
-iof_status predictor_decode_state (iof *I, iof *O, predictor_state *state)
-{
-  int status, c, d, outbytes;
-  while (state->status == STATUS_CONTINUE)
-  {
-    if (state->default_predictor >= 10) // PNG predictor?
-    {
-      read_row(state, I, state->rowsize + 1, status);
-      if (state->predictorbyte == 0)
-      { // we could actually check state->rowin <> state->buffer, but we need this flag for encoder anyway
-        state->current_predictor = row_byte(state) + 10;
-        state->predictorbyte = 1;
-        ++state->rowin;
-      }
-    }
-    else
-    {
-      read_row(state, I, state->rowsize, status);
-    }
-    switch (state->current_predictor)
-    {
-      case NONE_PREDICTOR:
-        for ( ; state->rowindex < state->rowsize; ++state->rowindex)
-        {
-          ensure_output_bytes(O, 1);
-          c = row_byte(state);
-          iof_set(O, c);
-        }
-        reset_row(state);
-        break;
-      case TIFF_PREDICTOR:
-        switch (state->compbits)
-        {
-          case 1:
-            outbytes = (state->components + 7) >> 3;
-            for ( ; state->sampleindex < state->rowsamples; ++state->sampleindex)
-            {
-              ensure_output_bytes(O, outbytes);
-              while (state->bitsin < state->components)
-              {
-                state->compin = (state->compin << 8) | row_byte(state);
-                state->bitsin += 8;
-                ++state->rowindex;
-              }
-              state->bitsin -= state->components;
-              d = state->compin >> state->bitsin;
-              state->compin &= (1 << state->bitsin) - 1;
-              c = d ^ left_pixel_value(state);
-              save_pixel_value(state, c);
-              state->compout = (state->compout << state->components) | c;
-              state->bitsout += state->components;
-              while (state->bitsout >= 8)
-              {
-                state->bitsout -= 8;
-                iof_set(O, state->compout >> state->bitsout);
-                state->compout &= (1 << state->bitsout) - 1;
-              }
-            }
-            if (state->bitsout > 0)
-            {
-              ensure_output_bytes(O, 1);
-              iof_set(O, state->compin << (8 - state->bitsout));
-            }
-            break;
-          case 2: case 4:
-            for ( ; state->sampleindex < state->rowsamples; ++state->sampleindex)
-            {
-              for ( ; state->compindex < state->components; ) // state->compindex is ++ed  by save_pixel_component()
-              {
-                ensure_output_bytes(O, 1);
-                if (state->bitsin < state->compbits)
-                {
-                  state->compin = (state->compin << 8) | row_byte(state);
-                  state->bitsin += 8;
-                  ++state->rowindex;
-                }
-                state->bitsin -= state->compbits;
-                d = state->compin >> state->bitsin;
-                state->compin &= (1 << state->bitsin) - 1;
-                c = (d + left_pixel_component(state)) & 0xff;
-                save_pixel_component(state, c);
-                state->compout = (state->compout << state->compbits) | c;
-                state->bitsout += state->compbits;
-                if (state->bitsout >= 8)
-                {
-                  state->bitsout -= 8;
-                  iof_set(O, state->compout >> state->bitsout);
-                  state->compout &= (1 << state->bitsout) - 1;
-                }
-              }
-            }
-            if (state->bitsout > 0)
-            {
-              ensure_output_bytes(O, 1);
-              iof_set(O, state->compin << (8 - state->bitsout));
-            }
-            break;
-          case 8:
-            for ( ; state->rowindex < state->rowsize; ++state->rowindex)
-            {
-              ensure_output_bytes(O, 1);
-              c = (row_byte(state) + left_pixel_component(state)) & 0xff;
-              save_pixel_component(state, c);
-              iof_set(O, c);
-            }
-            break;
-          case 16:
-            for ( ; state->rowindex < state->rowsize - 1; ++state->rowindex)
-            {
-              ensure_output_bytes(O, 2);
-              d = row_byte(state) << 8;
-              ++state->rowindex;
-              d |= row_byte(state);
-              c = (d + left_pixel_component(state)) & 0xff;
-              save_pixel_component(state, c);
-              iof_set2(O, c >> 8, c & 0xff);
-            }
-            break;
-          default:
-            return IOFERR;
-        }
-        reset_tiff_row(state);
-        break;
-      case PNG_NONE_PREDICTOR:
-        for ( ; state->rowindex < state->rowsize; ++state->rowindex)
-        {
-          ensure_output_bytes(O, 1);
-          c = row_byte(state);
-          save_pixel_byte(state, c); // next row may need it
-          iof_set(O, c);
-        }
-        reset_png_row(state);
-        break;
-      case PNG_SUB_PREDICTOR:
-        for ( ; state->rowindex < state->rowsize; ++state->rowindex)
-        {
-          ensure_output_bytes(O, 1);
-          c = (row_byte(state) + left_pixel_byte(state)) & 0xff;
-          save_pixel_byte(state, c);
-          iof_set(O, c);
-        }
-        reset_png_row(state);
-        break;
-      case PNG_UP_PREDICTOR:
-        for ( ; state->rowindex < state->rowsize; ++state->rowindex)
-        {
-          ensure_output_bytes(O, 1);
-          c = (row_byte(state) + up_pixel_byte(state)) & 0xff;
-          save_pixel_byte(state, c);
-          iof_set(O, c);
-        }
-        reset_png_row(state);
-        break;
-      case PNG_AVERAGE_PREDICTOR:
-        for ( ; state->rowindex < state->rowsize; ++state->rowindex)
-        {
-          ensure_output_bytes(O, 1);
-          c = (row_byte(state) + ((up_pixel_byte(state) + left_pixel_byte(state)) / 2)) & 0xff;
-          save_pixel_byte(state, c);
-          iof_set(O, c);
-        }
-        reset_png_row(state);
-        break;
-      case PNG_PAETH_PREDICTOR:
-        for ( ; state->rowindex < state->rowsize; ++state->rowindex)
-        {
-          ensure_output_bytes(O, 1);
-          c = (row_byte(state) + paeth(state)) & 0xff;
-          save_pixel_byte(state, c);
-          iof_set(O, c);
-        }
-        reset_png_row(state);
-        break;
-      //case PNG_OPTIMUM_PREDICTOR: // valid as default_redictor, but not as algorithm identifier byte
-      default:
-        return IOFERR;
-    }
-  }
-  return state->status == STATUS_LAST ? IOFERR : IOFEOF;
-}
-
-/* predictor encoder */
-
-iof_status predictor_encode_state (iof *I, iof *O, predictor_state *state)
-{
-  int status, c, d, outbytes;
-  while (state->status == STATUS_CONTINUE)
-  {
-    read_row(state, I, state->rowsize, status);
-    if (state->current_predictor >= 10 && state->predictorbyte == 0)
-    {
-      ensure_output_bytes(O, 1);
-      iof_set(O, state->current_predictor - 10);
-      state->predictorbyte = 1;
-    }
-    switch (state->current_predictor)
-    {
-      case NONE_PREDICTOR:
-        for ( ; state->rowindex < state->rowsize; ++state->rowindex)
-        {
-          ensure_output_bytes(O, 1);
-          c = row_byte(state);
-          iof_set(O, c);
-        }
-        reset_row(state);
-        break;
-      case TIFF_PREDICTOR:
-        switch (state->compbits)
-        {
-          case 1:
-            outbytes = (state->components + 7) >> 3;
-            for ( ; state->sampleindex < state->rowsamples; ++state->sampleindex)
-            {
-              ensure_output_bytes(O, outbytes);
-              while (state->bitsin < state->components)
-              {
-                state->compin = (state->compin << 8) | row_byte(state);
-                state->bitsin += 8;
-                ++state->rowindex;
-              }
-              state->bitsin -= state->components;
-              c = state->compin >> state->bitsin;
-              state->compin &= (1 << state->bitsin) - 1;
-              d = c ^ left_pixel_value(state);
-              save_pixel_value(state, c);
-              state->compout = (state->compout << state->components) | d;
-              state->bitsout += state->components;
-              while (state->bitsout >= 8)
-              {
-                state->bitsout -= 8;
-                iof_set(O, state->compout >> state->bitsout);
-                state->compout &= (1 << state->bitsout) - 1;
-              }
-            }
-            if (state->bitsout > 0)
-            {
-              ensure_output_bytes(O, 1);
-              iof_set(O, state->compin << (8 - state->bitsout));
-            }
-            break;
-          case 2: case 4:
-            for ( ; state->sampleindex < state->rowsamples; ++state->sampleindex)
-            {
-              for ( ; state->compindex < state->components; )
-              {
-                ensure_output_bytes(O, 1);
-                if (state->bitsin < state->compbits)
-                {
-                  state->compin = (state->compin << 8) | row_byte(state);
-                  state->bitsin += 8;
-                  ++state->rowindex;
-                }
-                state->bitsin -= state->compbits;
-                c = state->compin >> state->bitsin;
-                state->compin &= (1 << state->bitsin) - 1;
-                d = tocomp(c - left_pixel_component(state));
-                save_pixel_component(state, c);
-                state->compout = (state->compout << state->compbits) | d;
-                state->bitsout += state->compbits;
-                if (state->bitsout >= 8)
-                {
-                  state->bitsout -= 8;
-                  iof_set(O, state->compout >> state->bitsout);
-                  state->compout &= (1 << state->bitsout) - 1;
-                }
-              }
-            }
-            if (state->bitsout > 0)
-            {
-              ensure_output_bytes(O, 1);
-              iof_set(O, state->compin << (8 - state->bitsout));
-            }
-            break;
-          case 8:
-            for ( ; state->rowindex < state->rowsize; ++state->rowindex)
-            {
-              ensure_output_bytes(O, 1);
-              c = row_byte(state);
-              d = tobyte(c - left_pixel_component(state));
-              save_pixel_component(state, c);
-              iof_set(O, d);
-            }
-            break;
-          case 16:
-            for ( ; state->rowindex < state->rowsize - 1; ++state->rowindex)
-            {
-              ensure_output_bytes(O, 2);
-              c = row_byte(state) << 8;
-              ++state->rowindex;
-              c |= row_byte(state);
-              d = tocomp(c - left_pixel_component(state));
-              save_pixel_component(state, c);
-              iof_set2(O, d >> 8, d & 0xff);
-            }
-            break;
-          default:
-            return IOFERR;
-        }
-        reset_tiff_row(state);
-        break;
-      case PNG_NONE_PREDICTOR:
-        for ( ; state->rowindex < state->rowsize; ++state->rowindex)
-        {
-          ensure_output_bytes(O, 1);
-          c = row_byte(state);
-          save_pixel_byte(state, c); // next row may need it
-          iof_set(O, c);
-        }
-        reset_png_row(state);
-        break;
-      case PNG_SUB_PREDICTOR:
-        for ( ; state->rowindex < state->rowsize; ++state->rowindex)
-        {
-          ensure_output_bytes(O, 1);
-          c = row_byte(state);
-          d = tobyte(c - left_pixel_byte(state));
-          save_pixel_byte(state, c);
-          iof_set(O, d);
-        }
-        reset_png_row(state);
-        break;
-      case PNG_OPTIMUM_PREDICTOR: // not worthy to perform optimization
-      case PNG_UP_PREDICTOR:
-        for ( ; state->rowindex < state->rowsize; ++state->rowindex)
-        {
-          ensure_output_bytes(O, 1);
-          c = row_byte(state);
-          d = tobyte(c - up_pixel_byte(state));
-          save_pixel_byte(state, c);
-          iof_set(O, d);
-        }
-        reset_png_row(state);
-        break;
-      case PNG_AVERAGE_PREDICTOR:
-        for ( ; state->rowindex < state->rowsize; ++state->rowindex)
-        {
-          ensure_output_bytes(O, 1);
-          c = row_byte(state);
-          d = tobyte(c - ((up_pixel_byte(state) + left_pixel_byte(state)) >> 1));
-          save_pixel_byte(state, c);
-          iof_set(O, d);
-        }
-        reset_png_row(state);
-        break;
-      case PNG_PAETH_PREDICTOR:
-        for ( ; state->rowindex < state->rowsize; ++state->rowindex)
-        {
-          ensure_output_bytes(O, 1);
-          c = row_byte(state);
-          d = tobyte(c - paeth(state));
-          save_pixel_byte(state, c);
-          iof_set(O, d);
-        }
-        reset_png_row(state);
-        break;
-      default:
-        return IOFERR;
-    }
-  }
-  return state->status == STATUS_LAST ? IOFERR : IOFEOF;
-}
-
-iof_status predictor_decode (iof *I, iof *O, int predictor, int rowsamples, int components, int compbits)
-{
-  predictor_state state;
-  int ret;
-  predictor_decoder_init(&state, predictor, rowsamples, components, compbits);
-  state.flush = 1;
-  ret = predictor_decode_state(I, O, &state);
-  predictor_decoder_close(&state);
-  return ret;
-}
-
-iof_status predictor_encode (iof *I, iof *O, int predictor, int rowsamples, int components, int compbits)
-{
-  predictor_state state;
-  int ret;
-  predictor_encoder_init(&state, predictor, rowsamples, components, compbits);
-  state.flush = 1;
-  ret = predictor_encode_state(I, O, &state);
-  predictor_encoder_close(&state);
-  return ret;
-}
-
-/* filters */
-
-// predictor decoder function
-
-static size_t predictor_decoder (iof *F, iof_mode mode)
-{
-  predictor_state *state;
-  iof_status status;
-  size_t tail;
-
-  state = iof_filter_state(predictor_state *, F);
-  switch(mode)
-  {
-    case IOFLOAD:
-    case IOFREAD:
-      if (F->flags & IOF_STOPPED)
-        return 0;
-      tail = iof_tail(F);
-      F->pos = F->buf + tail;
-      F->end = F->buf + F->space;
-      do {
-        status = predictor_decode_state(F->next, F, state);
-      } while (mode == IOFLOAD && status == IOFFULL && iof_resize_buffer(F));
-      return iof_decoder_retval(F, "predictor", status);
-    case IOFCLOSE:
-      predictor_decoder_close(state);
-      iof_free(F);
-      return 0;
-    default:
-      break;
-  }
-  return 0;
-}
-
-// predictor encoder function
-
-static size_t predictor_encoder (iof *F, iof_mode mode)
-{
-  predictor_state *state;
-  iof_status status;
-
-  state = iof_filter_state(predictor_state *, F);
-  switch (mode)
-  {
-    case IOFFLUSH:
-      state->flush = 1;
-      // fall through
-    case IOFWRITE:
-      F->end = F->pos;
-      F->pos = F->buf;
-      status = predictor_encode_state(F, F->next, state);
-      return iof_encoder_retval(F, "predictor", status);
-    case IOFCLOSE:
-      if (!state->flush)
-        predictor_encoder(F, IOFFLUSH);
-      predictor_encoder_close(state);
-      iof_free(F);
-      return 0;
-    default:
-      break;
-  }
-  return 0;
-}
-
-iof * iof_filter_predictor_decoder (iof *N, int predictor, int rowsamples, int components, int compbits)
-{
-  iof *I;
-  predictor_state *state;
-  I = iof_filter_reader(predictor_decoder, sizeof(predictor_state), &state);
-  iof_setup_next(I, N);
-  if (predictor_decoder_init(state, predictor, rowsamples, components, compbits) == NULL)
-  {
-    iof_discard(I);
-    return NULL;
-  }
-  state->flush = 1;
-  return I;
-}
-
-iof * iof_filter_predictor_encoder (iof *N, int predictor, int rowsamples, int components, int compbits)
-{
-  iof *O;
-  predictor_state *state;
-  O = iof_filter_writer(predictor_encoder, sizeof(predictor_state), &state);
-  iof_setup_next(O, N);
-  if (predictor_encoder_init(state, predictor, rowsamples, components, compbits) == NULL)
-  {
-    iof_discard(O);
-    return NULL;
-  }
-  return O;
-}
--- texlive-bin.orig/texk/web2c/luatexdir/luapplib/util/utilfpred.h
+++ /dev/null
@@ -1,23 +0,0 @@
-#ifndef UTIL_FILTER_PREDICTOR_H
-#define UTIL_FILTER_PREDICTOR_H
-
-#include "utiliof.h"
-
-typedef struct predictor_state predictor_state;
-
-predictor_state * predictor_decoder_init (predictor_state *state, int predictor, int rowsamples, int components, int compbits);
-predictor_state * predictor_encoder_init (predictor_state *state, int predictor, int rowsamples, int components, int compbits);
-
-void predictor_decoder_close (predictor_state *state);
-void predictor_encoder_close (predictor_state *state);
-
-iof_status predictor_decode_state (iof *I, iof *O, predictor_state *state);
-iof_status predictor_encode_state (iof *I, iof *O, predictor_state *state);
-
-iof_status predictor_decode (iof *I, iof *O, int predictor, int rowsamples, int components, int compbits);
-iof_status predictor_encode (iof *I, iof *O, int predictor, int rowsamples, int components, int compbits);
-
-iof * iof_filter_predictor_decoder (iof *N, int predictor, int rowsamples, int components, int compbits);
-iof * iof_filter_predictor_encoder (iof *N, int predictor, int rowsamples, int components, int compbits);
-
-#endif
\ No newline at end of file
--- texlive-bin.orig/texk/web2c/luatexdir/luapplib/util/utiliof.c
+++ /dev/null
@@ -1,2949 +0,0 @@
-/* input/iutput stream */
-
-#include <stdlib.h>
-#include <string.h>
-#include <stdarg.h>
-
-#include "utilmem.h"
-#include "utillog.h"
-#include "utiliof.h"
-
-/* commons */
-
-void * iof_copy_data (const void *data, size_t size)
-{
-  return memcpy(util_malloc(size), data, size);
-}
-
-uint8_t * iof_copy_file_data (const char *filename, size_t *psize)
-{
-  FILE *file;
-  size_t size;
-  uint8_t *data;
-  if ((file = fopen(filename, "rb")) == NULL)
-    return NULL;
-  fseek(file, 0, SEEK_END);
-  size = (size_t)ftell(file);
-  data = (uint8_t *)util_malloc(size);
-  fseek(file, 0, SEEK_SET);
-  if ((*psize = fread(data, 1, size, file)) != size)
-  {
-    util_free(data);
-    data = NULL;
-  }
-  fclose(file);
-  return data;
-}
-
-uint8_t * iof_copy_file_handle_data (FILE *file, size_t *psize)
-{
-  size_t size;
-  uint8_t *data;
-  //long offset = ftell(file); // keep offset intact?
-  fseek(file, 0, SEEK_END);
-  size = (size_t)ftell(file);
-  data = (uint8_t *)util_malloc(size);
-  fseek(file, 0, SEEK_SET);
-  if ((*psize = fread(data, 1, size, file)) != size)
-  {
-    util_free(data);
-    data = NULL;
-  }
-  //fseek(file, offset, SEEK_SET)
-  return data;
-}
-
-FILE * iof_get_file (iof *F)
-{
-  if (F->flags & IOF_FILE)
-    return iof_file_get_file(F->iofile);
-  if (F->flags & IOF_FILE_HANDLE)
-    return F->file;
-  return NULL;
-}
-
-const char * iof_status_kind (iof_status status)
-{
-  switch (status)
-  {
-    case IOFEOF:
-      return "IOFEOF";
-    case IOFERR:
-      return "IOFERR";
-    case IOFEMPTY:
-      return "IOFEMPTY";
-    case IOFFULL:
-      return "IOFFULL";
-    default:
-      break;
-  }
-  return "(unknown)";
-}
-
-/* shared pseudofile */
-
-#define IOF_FILE_DEFAULTS 0
-
-iof_file * iof_file_new (FILE *file)
-{
-  iof_file *iofile = (iof_file *)util_malloc(sizeof(iof_file));
-  iof_file_set_fh(iofile, file);
-  iofile->offset = NULL;
-  iofile->size = 0;
-  iofile->name = NULL;
-  iofile->refcount = 0;
-  iofile->flags = IOF_FILE_DEFAULTS|IOF_ALLOC;
-  return iofile;
-}
-
-iof_file * iof_file_init (iof_file *iofile, FILE *file)
-{
-  iof_file_set_fh(iofile, file);
-  iofile->offset = NULL;
-  iofile->size = 0;
-  iofile->name = NULL;
-  iofile->refcount = 0;
-  iofile->flags = IOF_FILE_DEFAULTS;
-  return iofile;
-}
-
-iof_file * iof_file_rdata (const void *data, size_t size)
-{
-  iof_file *iofile = (iof_file *)util_malloc(sizeof(iof_file));
-  iofile->rbuf = iofile->rpos = (const uint8_t *)data;
-  iofile->rend = iofile->rbuf + size;
-  iofile->offset = NULL;
-  iofile->size = 0;
-  iofile->name = NULL;
-  iofile->refcount = 0;
-  iofile->flags = IOF_FILE_DEFAULTS|IOF_ALLOC|IOF_DATA;
-  return iofile;
-}
-
-iof_file * iof_file_rdata_init (iof_file *iofile, const void *data, size_t size)
-{
-  iofile->rbuf = iofile->rpos = (const uint8_t *)data;
-  iofile->rend = iofile->rbuf + size;
-  iofile->offset = NULL;
-  iofile->size = 0; // letse keep it consequently set to zero (only for user disposal)
-  iofile->name = NULL;
-  iofile->refcount = 0;
-  iofile->flags = IOF_FILE_DEFAULTS|IOF_DATA;
-  return iofile;
-}
-
-iof_file * iof_file_wdata (void *data, size_t size)
-{
-  return iof_file_rdata((const void *)data, size);
-}
-
-iof_file * iof_file_wdata_init (iof_file *iofile, void *data, size_t size)
-{
-  return iof_file_rdata_init(iofile, (const void *)data, size);
-}
-
-/* typical uses so far */
-
-iof_file * iof_file_reader_from_file_handle (iof_file *iofile, const char *filename, FILE *file, int preload, int closefile)
-{
-  uint8_t *data;
-  size_t size;
-
-  if (preload)
-  {
-    if ((data = iof_copy_file_handle_data(file, &size)) == NULL)
-    {
-      if (closefile)
-        fclose(file);
-      return NULL;
-    }
-    if (iofile == NULL)
-      iofile = iof_file_rdata(data, size);
-    else
-      iof_file_rdata_init(iofile, data, size);
-    iofile->flags |= IOF_BUFFER_ALLOC;
-    if (closefile)
-      fclose(file);
-  }
-  else
-  {
-    if (iofile == NULL)
-      iofile = iof_file_new(file);
-    else
-      iof_file_init(iofile, file);
-    if (closefile)
-      iofile->flags |= IOF_CLOSE_FILE;
-  }
-  if (filename != NULL)
-    iof_file_set_name(iofile, filename);
-  return iofile;
-}
-
-iof_file * iof_file_reader_from_file (iof_file *iofile, const char *filename, int preload)
-{
-  FILE *file;
-  if ((file = fopen(filename, "rb")) == NULL)
-    return NULL;
-  return iof_file_reader_from_file_handle(iofile, filename, file, preload, 1);
-}
-
-iof_file * iof_file_reader_from_data (iof_file *iofile, const void *data, size_t size, int preload, int freedata)
-{
-  void *newdata;
-  if (data == NULL)
-    return NULL;
-  if (preload)
-  {
-    newdata = iof_copy_data(data, size);
-    if (iofile == NULL)
-      iofile = iof_file_rdata(newdata, size);
-    else
-      iof_file_rdata_init(iofile, newdata, size);
-    iofile->flags |= IOF_BUFFER_ALLOC;
-    //if (freedata) // hardly makes sense...  we can't free const void *
-    //  util_free((void *)data);
-  }
-  else
-  {
-    if (iofile == NULL)
-      iofile = iof_file_rdata(data, size);
-    else
-      iof_file_rdata_init(iofile, data, size);
-    if (freedata)
-      iofile->flags |= IOF_BUFFER_ALLOC;
-  }
-  return iofile;
-}
-
-/*
-iof_file * iof_file_writer_from_file (iof_file *iofile, const char *filename)
-{
-  FILE *file;
-  if ((file = fopen(filename, "wb")) == NULL)
-    return NULL;
-  if (iofile == NULL)
-    iofile = iof_file_new(file);
-  else
-    iof_file_init(iofile, file);
-  iofile->flags |= IOF_CLOSE_FILE;
-  iof_file_set_name(iofile, filename);
-  return iofile;
-}
-*/
-
-/*
-Because of limited number of FILE* handles available, we may need to close contained handle
-between accessing it. In applications so far (fonts, images) we typically need the source
-to parse the file on creation and to rewrite or reload the data on dump. All iof_file api
-functions assume that iofile has FILE* opened. Reopening it on every access (ftell, fseek,
-read/write) makes no sense, as we would effectively loose control. If the caller invalidates
-iofile by closing and nulling its file handle, it is also responsible to reopen when necessary.
-*/
-
-int iof_file_close_input (iof_file *iofile)
-{
-  FILE *file;
-  if (iofile->flags & IOF_DATA)
-    return 0;
-  if ((file = iof_file_get_fh(iofile)) == NULL)
-    return 0;
-  fclose(file);
-  iof_file_set_fh(iofile, NULL);
-  iofile->flags &= ~IOF_RECLOSE_FILE;
-  iofile->flags |= IOF_REOPEN_FILE;
-  return 1;
-}
-
-int iof_file_reopen_input (iof_file *iofile)
-{ // returns true if iofile readable
-  FILE *file;
-  const char *filename;
-  if (iofile->flags & IOF_DATA)
-    return 1;
-  if ((file = iof_file_get_fh(iofile)) != NULL)
-    return 1; // if present, assumed readable
-  if ((filename = iofile->name) == NULL || (file = fopen(filename, "rb")) == NULL)
-    return 0;
-  iof_file_set_fh(iofile, file);
-  iofile->flags &= ~IOF_REOPEN_FILE;
-  iofile->flags |= IOF_RECLOSE_FILE;
-  return 1;
-}
-
-/* freeing iof_file */
-
-void iof_file_free (iof_file *iofile)
-{
-  FILE *file;
-  if (iofile->flags & IOF_DATA)
-  {
-    if (iofile->flags & IOF_BUFFER_ALLOC)
-    {
-      iofile->flags &= ~IOF_BUFFER_ALLOC;
-      if (iofile->buf != NULL)
-      {
-        util_free(iofile->buf);
-        iofile->buf = iofile->pos = iofile->end = NULL;
-      }
-    }
-  }
-  else if ((file = iof_file_get_fh(iofile)) != NULL)
-  {
-    if (iofile->flags & IOF_CLOSE_FILE)
-     	fclose(file);
-    iof_file_set_fh(iofile, NULL);
-  }
-  iof_file_set_name(iofile, NULL);
-  if (iofile->flags & IOF_ALLOC)
-    util_free(iofile);
-}
-
-/* set filename for reopen */
-
-void iof_file_set_name (iof_file *iofile, const char *name)
-{
-  if (iofile->name != NULL)
-    util_free(iofile->name);
-  if (name != NULL)
-    iofile->name = iof_copy_data(name, strlen(name) + 1);
-  else
-    iofile->name = NULL;
-}
-
-/* seek */
-
-int iof_file_seek (iof_file *iofile, long offset, int whence)
-{
-  if (iofile->flags & IOF_DATA)
-  {
-    switch (whence)
-    {
-      case SEEK_SET:
-        if (offset >= 0 && iofile->buf + offset <= iofile->end)
-        {
-          iofile->pos = iofile->buf + offset;
-          return 0;
-        }
-        return -1;
-      case SEEK_CUR:
-        if ((offset >= 0 && iofile->pos + offset <= iofile->end) || (offset < 0 && iofile->pos + offset >= iofile->buf))
-        {
-          iofile->pos += offset;
-          return 0;
-        }
-        return -1;
-      case SEEK_END:
-        if (offset <= 0 && iofile->end + offset >= iofile->buf)
-        {
-          iofile->pos = iofile->end + offset;
-          return 0;
-        }
-        return -1;
-    }
-    return -1;
-  }
-  return fseek(iof_file_get_fh(iofile), offset, whence);
-}
-
-/* */
-
-long iof_file_tell (iof_file *iofile)
-{
-  return (iofile->flags & IOF_DATA) ? (long)(iofile->pos - iofile->buf) : ftell(iof_file_get_fh(iofile));
-}
-
-size_t iof_file_size (iof_file *iofile)
-{ 
-  long pos, size;
-  FILE *file;
-  if (iofile->flags & IOF_DATA)
-    return (size_t)iof_space(iofile);
-  file = iof_file_get_fh(iofile);
-  pos = ftell(file);
-  fseek(file, 0, SEEK_END);
-  size = ftell(file);
-  fseek(file, pos, SEEK_SET);
-  return size;
-}
-
-int iof_file_eof (iof_file *iofile)
-{
-  if (iofile->flags & IOF_DATA)
-    return iofile->pos == iofile->end ? -1 : 0;
-  return feof(iof_file_get_fh(iofile));
-}
-
-int iof_file_flush (iof_file *iofile)
-{
-  if (iofile->flags & IOF_DATA)
-    return 0;
-  return fflush(iof_file_get_fh(iofile));
-}
-
-size_t iof_file_read (void *ptr, size_t size, size_t items, iof_file *iofile)
-{
-  if (iofile->flags & IOF_DATA)
-  {
-    size_t bytes = size * items;
-    if (bytes > (size_t)iof_left(iofile))
-      bytes = (size_t)iof_left(iofile);
-    memcpy(ptr, iofile->pos, bytes);
-    iofile->pos += bytes;
-    return bytes / size; // number of elements read
-  }
-  return fread(ptr, size, items, iof_file_get_fh(iofile));
-}
-
-static size_t iof_file_data_resizeto (iof_file *iofile, size_t space)
-{
-  uint8_t *newbuf;
-  size_t size;
-  size = iof_size(iofile);
-  if (iofile->flags & IOF_BUFFER_ALLOC)
-  {
-    newbuf = (uint8_t *)util_realloc(iofile->buf, space);
-  }
-  else
-  {
-    newbuf = (uint8_t *)util_malloc(space);
-    if (size > 0)
-      memcpy(newbuf, iofile->buf, size);
-    iofile->flags |= IOF_BUFFER_ALLOC;
-  }
-  iofile->buf = newbuf;
-  iofile->pos = newbuf + size;
-  iofile->end = newbuf + space;
-  return space - size;
-}
-
-#define iof_file_data_resize(iofile) iof_file_data_resizeto(iofile, iof_space(iofile) << 1)
-
-size_t iof_file_write (const void *ptr, size_t size, size_t items, iof_file *iofile)
-{
-  if (iofile->flags & IOF_DATA)
-  {
-    size_t space, sizesofar, bytes;
-    bytes = size * items;
-    if (bytes > (size_t)iof_left(iofile))
-    {      
-      if ((space = iof_space(iofile)) == 0) // allow iofile->buf/end initially NULL
-        space = BUFSIZ;
-      for (sizesofar = iof_size(iofile), space <<= 1; sizesofar + bytes > space; space <<= 1)
-        ;
-      if (iof_file_data_resizeto(iofile, space) == 0)
-        return 0;
-    }
-    memcpy(iofile->pos, ptr, bytes);
-    iofile->pos += bytes;
-    return bytes / size;
-  }
-  return fwrite(ptr, size, items, iof_file_get_fh(iofile));
-}
-
-size_t iof_file_ensure (iof_file *iofile, size_t bytes)
-{
-  if (iofile->flags & IOF_DATA)
-  {
-    size_t space, sizesofar, left;
-    left = (size_t)iof_left(iofile);
-    if (bytes > left)
-    {      
-      if ((space = iof_space(iofile)) == 0) // allow iofile->buf/end initially NULL
-        space = BUFSIZ;
-      for (sizesofar = iof_size(iofile), space <<= 1; sizesofar + bytes > space; space <<= 1);
-      return iof_file_data_resizeto(iofile, space);
-    }
-    return left;  
-  }
-  return 0;
-}
-
-int iof_file_getc (iof_file *iofile)
-{
-  if (iofile->flags & IOF_DATA)
-    return iofile->pos < iofile->end ? *iofile->pos++ : IOFEOF;
-  return fgetc(iof_file_get_fh(iofile));
-}
-
-int iof_file_putc (iof_file *iofile, int c)
-{
-  if (iofile->flags & IOF_DATA)
-  {
-    if (iofile->pos >= iofile->end)
-      if (iof_file_data_resize(iofile) == 0)
-        return IOFEOF;
-    *iofile->pos++ = (uint8_t)c;
-    return c;
-  }
-  return fputc(c, iof_file_get_fh(iofile));
-}
-
-static int iof_file_sync (iof_file *iofile, size_t *offset)
-{
-  if (iofile->offset != offset)
-  {
-    if (iofile->offset != NULL)
-      *iofile->offset = iof_file_tell(iofile);
-    iofile->offset = offset;
-    if (offset) // let offset be NULL
-      return iof_file_seek(iofile, (long)*offset, SEEK_SET);
-  }
-  return 0;
-}
-
-//#define iof_file_unsync(iofile, poffset) (void)((iofile)->offset == poffset && (((iofile)->offset = NULL), 0))
-#define iof_file_unsync(iofile, poffset) ((void)poffset, (iofile)->offset = NULL)
-
-/* iof seek */
-
-#define iof_reader_reset(I) ((I)->pos = (I)->end = (I)->buf)
-#define iof_reader_reseek_file(I, offset, whence) (fseek((I)->file, offset, whence) == 0 ? (iof_reader_reset(I), 0) : -1)
-#define iof_reader_reseek_iofile(I, offset, whence) (iof_file_seek((I)->iofile, offset, whence) == 0 ? (iof_reader_reset(I), 0) : -1)
-
-#define iof_writer_reset(O) ((O)->pos = (O)->buf)
-#define iof_writer_reseek_file(O, offset, whence) (iof_flush(O), (fseek((O)->file, offset, whence) == 0 ? (iof_writer_reset(O), 0) : -1))
-#define iof_writer_reseek_iofile(O, offset, whence) (iof_flush(O), (iof_file_seek((O)->iofile, offset, whence) == 0 ? (iof_writer_reset(O), 0) : -1))
-
-static int iof_reader_seek_data (iof *I, long offset, int whence)
-{
-  switch (whence)
-  {
-    case SEEK_SET:
-      if (offset >= 0 && I->buf + offset <= I->end)
-      {
-        I->pos = I->buf + offset;
-        return 0;
-      }
-      return -1;
-    case SEEK_CUR:
-      if ((offset >= 0 && I->pos + offset <= I->end) || (offset < 0 && I->pos + offset >= I->buf))
-      {
-        I->pos += offset;
-        return 0;
-      }
-      return -1;
-    case SEEK_END:
-      if (offset <= 0 && I->end + offset >= I->buf)
-      {
-        I->pos = I->end + offset;
-        return 0;
-      }
-      return -1;
-  }
-  return -1;
-}
-
-static int iof_reader_seek_iofile (iof *I, long offset, int whence)
-{
-  long fileoffset;
-  switch (whence)
-  {
-    case SEEK_SET:
-      fileoffset = iof_file_tell(I->iofile);
-      if (offset <= fileoffset && offset >= fileoffset - iof_space(I))
-      {
-        I->pos = I->end - (fileoffset - offset);
-        return 0;
-      }
-      return iof_reader_reseek_iofile(I, offset, SEEK_SET);
-    case SEEK_CUR:
-      if ((offset >= 0 && I->pos + offset <= I->end) || (offset < 0 && I->pos + offset >= I->buf))
-      {
-        I->pos += offset;
-        return 0;
-      }
-      return iof_reader_reseek_iofile(I, offset, SEEK_CUR);
-    case SEEK_END:
-      return iof_reader_reseek_iofile(I, offset, SEEK_END); // can we do better?
-  }
-  return -1;
-}
-
-static int iof_reader_seek_file (iof *I, long offset, int whence)
-{
-  long fileoffset;
-  switch (whence)
-  {
-    case SEEK_SET:
-      fileoffset = ftell(I->file);
-      if (offset <= fileoffset && offset >= fileoffset - iof_space(I))
-      {
-        I->pos = I->end - (fileoffset - offset);
-        return 0;
-      }
-      return iof_reader_reseek_file(I, offset, SEEK_SET);
-    case SEEK_CUR:
-      if ((offset >= 0 && I->pos + offset <= I->end) || (offset < 0 && I->pos + offset >= I->buf))
-      {
-        I->pos += offset;
-        return 0;
-      }
-      return iof_reader_reseek_file(I, offset, SEEK_CUR);
-    case SEEK_END:
-      return iof_reader_reseek_file(I, offset, SEEK_END); // can we do better?
-  }
-  return -1;
-}
-
-int iof_reader_seek (iof *I, long offset, int whence)
-{
-  I->flags &= ~IOF_STOPPED;
-  if (I->flags & IOF_FILE)
-    return iof_reader_seek_iofile(I, offset, whence);
-  if (I->flags & IOF_FILE_HANDLE)
-    return iof_reader_seek_file(I, offset, whence);
-  if (I->flags & IOF_DATA)
-    return iof_reader_seek_data(I, offset, whence);
-  return -1;
-}
-
-int iof_reader_reseek (iof *I, long offset, int whence)
-{
-  I->flags &= ~IOF_STOPPED;
-  if (I->flags & IOF_FILE)
-    return iof_reader_reseek_iofile(I, offset, whence);
-  if (I->flags & IOF_FILE_HANDLE)
-    return iof_reader_reseek_file(I, offset, whence);
-  if (I->flags & IOF_DATA)
-    return iof_reader_seek_data(I, offset, whence);
-  return -1;
-}
-
-static int iof_writer_seek_data (iof *O, long offset, int whence)
-{
-  /*
-  fseek() allows to seek after the end of file. Seeking does not increase the output file.
-  No byte is written before fwirte(). It seems to fill the gap with zeros. Until we really need that,
-  no seeking out of bounds for writers.
-  */
-  O->flags &= ~IOF_STOPPED;
-  return iof_reader_seek_data(O, offset, whence);
-}
-
-static int iof_writer_seek_iofile (iof *O, long offset, int whence)
-{
-  long fileoffset;
-  switch (whence)
-  {
-    case SEEK_SET:
-      fileoffset = iof_file_tell(O->iofile);
-      if (offset >= fileoffset && offset <= fileoffset + iof_space(O))
-      {
-        O->pos = O->buf + (offset - fileoffset);
-        return 0;
-      }
-      return iof_writer_reseek_iofile(O, offset, SEEK_SET);
-    case SEEK_CUR:
-      if ((offset >=0 && O->pos + offset <= O->end) || (offset < 0 && O->pos + offset >= O->buf))
-      {
-        O->pos += offset;
-        return 0;
-      }
-      return iof_writer_reseek_iofile(O, offset, SEEK_CUR);
-    case SEEK_END:
-      return iof_writer_reseek_iofile(O, offset, SEEK_END);
-  }
-  return -1;
-}
-
-static int iof_writer_seek_file (iof *O, long offset, int whence)
-{
-  long fileoffset;
-  switch (whence)
-  {
-    case SEEK_SET:
-      fileoffset = ftell(O->file);
-      if (offset >= fileoffset && offset <= fileoffset + iof_space(O))
-      {
-        O->pos = O->buf + (offset - fileoffset);
-        return 0;
-      }
-      return iof_writer_reseek_file(O, offset, SEEK_SET);
-    case SEEK_CUR:
-      if ((offset >=0 && O->pos + offset <= O->end) || (offset < 0 && O->pos + offset >= O->buf))
-      {
-        O->pos += offset;
-        return 0;
-      }
-      return iof_writer_reseek_file(O, offset, SEEK_CUR);
-    case SEEK_END:
-      return iof_writer_reseek_file(O, offset, SEEK_END);
-  }
-  return -1;
-}
-
-int iof_writer_seek (iof *I, long offset, int whence)
-{
-  I->flags &= ~IOF_STOPPED;
-  if (I->flags & IOF_FILE)
-    return iof_writer_seek_iofile(I, offset, whence);
-  if (I->flags & IOF_FILE_HANDLE)
-    return iof_writer_seek_file(I, offset, whence);
-  if (I->flags & IOF_DATA)
-    return iof_writer_seek_data(I, offset, whence);
-  return -1;
-}
-
-int iof_writer_reseek (iof *I, long offset, int whence)
-{
-  I->flags &= ~IOF_STOPPED;
-  if (I->flags & IOF_FILE)
-    return iof_writer_reseek_iofile(I, offset, whence);
-  if (I->flags & IOF_FILE_HANDLE)
-    return iof_writer_reseek_file(I, offset, whence);
-  if (I->flags & IOF_DATA)
-    return iof_writer_seek_data(I, offset, whence);
-  return -1;
-}
-
-int iof_seek (iof *F, long offset, int whence)
-{
-  return (F->flags & IOF_WRITER) ? iof_writer_seek(F, offset, whence) : iof_reader_seek(F, offset, whence);
-}
-
-int iof_reseek (iof *F, long offset, int whence)
-{
-  return (F->flags & IOF_WRITER) ? iof_writer_reseek(F, offset, whence) : iof_reader_reseek(F, offset, whence);
-}
-
-/* tell */
-
-long iof_reader_tell (iof *I)
-{
-  if (I->flags & IOF_FILE)
-    return iof_file_tell(I->iofile) - (long)iof_left(I);
-  if (I->flags & IOF_FILE_HANDLE)
-    return ftell(I->file) - (long)iof_left(I);
-  //if (I->flags & IOF_DATA)
-  return (long)iof_size(I);
-}
-
-long iof_writer_tell (iof *O)
-{
-  if (O->flags & IOF_FILE)
-    return iof_file_tell(O->iofile) + (long)iof_size(O);
-  if (O->flags & IOF_FILE_HANDLE)
-    return ftell(O->file) + (long)iof_size(O);
-  //if (I->flags & IOF_DATA)
-  return (long)iof_size(O);
-}
-
-long iof_tell (iof *I)
-{
-  return (I->flags & IOF_WRITER) ? iof_writer_tell(I) : iof_reader_tell(I);
-}
-
-size_t iof_fsize (iof *I)
-{
-  size_t pos, size;
-  if (I->flags & IOF_FILE)
-    return iof_file_size(I->iofile);
-  if (I->flags & IOF_FILE_HANDLE)
-  {
-    pos = (size_t)ftell(I->file);
-    fseek(I->file, 0, SEEK_END);
-    size = (size_t)ftell(I->file);
-    fseek(I->file, (long)pos, SEEK_SET);
-    return size;
-  }
-  //if (I->flags & IOF_DATA)
-  return (size_t)iof_space(I);
-}
-
-/* save reader tail */
-
-size_t iof_save_tail (iof *I)
-{
-  size_t size, left;
-  size = iof_size(I);
-  left = iof_left(I);
-  if (size >= left)
-    memcpy(I->buf, I->pos, left);
-  else
-    memmove(I->buf, I->pos, left);
-  return left;
-}
-
-size_t iof_input_save_tail (iof *I, size_t back)
-{
-  size_t size;
-  I->flags |= IOF_TAIL;
-  I->pos -= back;
-  size = iof_input(I);
-  I->pos += back;
-  I->flags &= ~IOF_TAIL;
-  return size; // + back - back
-}
-
-/* read from file */
-
-/* iof free*/
-
-static size_t file_read (iof *I);
-static size_t file_load (iof *I);
-
-static size_t file_reader (iof *I, iof_mode mode)
-{
-  switch (mode)
-  {
-    case IOFREAD:
-      return file_read(I);
-    case IOFLOAD:
-      return file_load(I);
-    case IOFCLOSE:
-      iof_free(I);
-      return 0;
-    default:
-      return 0;
-  }
-}
-
-iof * iof_setup_file_handle_reader (iof *I, void *buffer, size_t space, FILE *f)
-{
-  if (I == NULL)
-    iof_setup_reader(I, buffer, space);
-  else
-    iof_reader_buffer(I, buffer, space);
-  iof_setup_file(I, f);
-  I->more = file_reader;
-  return I;
-}
-
-iof * iof_setup_file_reader (iof *I, void *buffer, size_t space, const char *filename)
-{
-  FILE *f;
-  if ((f = fopen(filename, "rb")) == NULL)
-    return NULL;
-  if (I == NULL)
-    iof_setup_reader(I, buffer, space);
-  else
-    iof_reader_buffer(I, buffer, space);
-  iof_setup_file(I, f);
-  I->flags |= IOF_CLOSE_FILE;
-  I->more = file_reader;
-  return I;
-}
-
-/* write to file */
-
-static size_t file_write (iof *O, int flush);
-
-static size_t file_writer (iof *O, iof_mode mode)
-{
-  switch (mode)
-  {
-    case IOFWRITE:
-      return file_write(O, 0);
-    case IOFFLUSH:
-      return file_write(O, 1);
-    case IOFCLOSE:
-      file_write(O, 1);
-      iof_free(O);
-      return 0;
-    default:
-      return 0;
-  }
-}
-
-iof * iof_setup_file_handle_writer (iof *O, void *buffer, size_t space, FILE *f)
-{
-  if (O == NULL)
-    iof_setup_writer(O, buffer, space);
-  else
-    iof_writer_buffer(O, buffer, space);
-  iof_setup_file(O, f);
-  O->more = file_writer;
-  return O;
-}
-
-iof * iof_setup_file_writer (iof *O, void *buffer, size_t space, const char *filename)
-{
-  FILE *f;
-  if ((f = fopen(filename, "wb")) == NULL)
-    return NULL;
-  if (O == NULL)
-    iof_setup_writer(O, buffer, space);
-  else
-    iof_writer_buffer(O, buffer, space);
-  iof_setup_file(O, f);
-  O->flags |= IOF_CLOSE_FILE;
-  O->more = file_writer;
-  return O;
-}
-
-/* a dedicated handler for stdout/stderr */
-
-static size_t stdout_writer (iof *O, iof_mode mode)
-{
-  switch(mode)
-  {
-    case IOFWRITE:
-    {
-      fwrite(O->buf, sizeof(uint8_t), iof_size(O), stdout);
-      O->pos = O->buf;
-      return O->space;
-    }
-    case IOFCLOSE:
-    case IOFFLUSH:
-    {
-      fwrite(O->buf, sizeof(uint8_t), iof_size(O), stdout);
-      fflush(stdout);
-      O->pos = O->buf;
-      return 0;
-    }
-    default:
-      break;
-  }
-  return 0;
-}
-
-static size_t stderr_writer (iof *O, iof_mode mode)
-{
-  switch(mode)
-  {
-    case IOFWRITE:
-    {
-      fwrite(O->buf, sizeof(uint8_t), iof_size(O), stderr);
-      O->pos = O->buf;
-      return O->space;
-    }
-    case IOFCLOSE:
-    case IOFFLUSH:
-    {
-      fwrite(O->buf, sizeof(uint8_t), iof_size(O), stderr);
-      fflush(stderr);
-      O->pos = O->buf;
-      return 0;
-    }
-    default:
-      break;
-  }
-  return 0;
-}
-
-static uint8_t iof_stdout_buffer[BUFSIZ];
-iof iof_stdout = IOF_WRITER_STRUCT(stdout_writer, NULL, iof_stdout_buffer, BUFSIZ, 0);
-
-static uint8_t iof_stderr_buffer[BUFSIZ];
-iof iof_stderr = IOF_WRITER_STRUCT(stderr_writer, NULL, iof_stderr_buffer, BUFSIZ, 0);
-
-/* read from somewhere */
-
-iof * iof_reader (iof *I, void *link, iof_handler reader, const void *m, size_t bytes)
-{
-  I->space = 0;
-  I->link = link;
-  I->more = reader;
-  I->flags = 0;
-  I->refcount = 0;
-  if (m != NULL)
-  {
-    I->rbuf = I->rpos = (const uint8_t *)m;
-    I->rend = (const uint8_t *)m + bytes;
-    return I;
-  }
-  return NULL;
-}
-
-iof * iof_string_reader (iof *I, const void *s, size_t bytes)
-{
-  I->space = 0;
-  I->link = NULL;
-  I->more = NULL;
-  I->flags = 0; // iof_string() sets IOF_DATA
-  I->refcount = 0;
-  if (s != NULL)
-    return iof_string(I, s, bytes);
-  return NULL;
-}
-
-/* write somewhere */
-
-iof * iof_writer (iof *O, void *link, iof_handler writer, void *m, size_t bytes)
-{
-  O->space = 0;
-  O->link = link;
-  O->more = writer;
-  O->flags = 0;
-  O->refcount = 0;
-  if (m != NULL && bytes > 0)
-  {
-    O->buf = O->pos = (uint8_t *)m;
-    O->end = (uint8_t *)m + bytes;
-    return O;
-  }
-  // return iof_null(O);
-  return NULL;
-}
-
-/* write to growing bytes buffer */
-
-static size_t iof_mem_handler (iof *O, iof_mode mode)
-{
-  switch(mode)
-  {
-    case IOFWRITE:
-      return iof_resize_buffer(O);
-    case IOFCLOSE:
-      iof_free(O);
-      return 0;
-    default:
-      return 0;
-  }
-}
-
-iof * iof_setup_buffer (iof *O, void *buffer, size_t space)
-{
-  if (O == NULL)
-    iof_setup_writer(O, buffer, space);
-  else
-    iof_writer_buffer(O, buffer, space);
-  O->link = NULL;
-  O->flags |= IOF_DATA;
-  O->more = iof_mem_handler;
-  return O;
-}
-
-iof * iof_setup_buffermin (iof *O, void *buffer, size_t space, size_t min)
-{
-  if ((O = iof_setup_buffer(O, buffer, space)) != NULL && space < min) // just allocate min now to avoid further rewriting
-  {
-    O->buf = O->pos = (uint8_t *)util_malloc(min);
-    O->flags |= IOF_BUFFER_ALLOC;
-    O->end = O->buf + min;
-  }
-  return O;
-}
-
-iof * iof_buffer_create (size_t space)
-{
-  uint8_t *buffer;
-  iof *O;
-  space += sizeof(iof);
-  buffer = util_malloc(space);
-  if ((O = iof_setup_buffer(NULL, buffer, space)) != NULL)
-    O->flags |= IOF_ALLOC;
-  return O;
-}
-
-/* set/get */
-
-int iof_getc (iof *I)
-{
-  if (iof_readable(I))
-    return *I->pos++;
-  return IOFEOF;
-}
-
-int iof_putc (iof *O, int u)
-{
-  if (iof_writable(O))
-  {
-    iof_set(O, u);
-    return (uint8_t)u;
-  }
-  return IOFFULL;
-}
-
-size_t iof_skip (iof *I, size_t bytes)
-{
-  while (bytes)
-  {
-    if (iof_readable(I))
-      ++I->pos;
-    else
-      break;
-    --bytes;
-  }
-  return bytes;
-}
-
-/* from iof to iof */
-
-iof_status iof_pass (iof *I, iof *O)
-{
-  size_t leftin, leftout;
-  if ((leftin = iof_left(I)) == 0)
-    leftin = iof_input(I);
-  while (leftin)
-  {
-    if ((leftout = iof_left(O)) == 0)
-      if ((leftout = iof_output(O)) == 0)
-        return IOFFULL;
-    while (leftin > leftout)
-    {
-      memcpy(O->pos, I->pos, leftout);
-      I->pos += leftout;
-      O->pos = O->end; /* eq. += leftout */
-      leftin -= leftout;
-      if ((leftout = iof_output(O)) == 0)
-        return IOFFULL;
-    }
-    if (leftin)
-    {
-      memcpy(O->pos, I->pos, leftin);
-      I->pos = I->end; /* eq. += leftin */
-      O->pos += leftin;
-    }
-    leftin = iof_input(I);
-  }
-  return IOFEOF;
-}
-
-/* read n-bytes */
-
-size_t iof_read (iof *I, void *to, size_t size)
-{
-  size_t leftin, done = 0;
-  char *s = (char *)to;
-  
-  if ((leftin = iof_left(I)) == 0)
-    if ((leftin = iof_input(I)) == 0)
-      return done;
-  while (size > leftin)
-  {
-    memcpy(s, I->pos, leftin * sizeof(uint8_t));
-    size -= leftin;
-    done += leftin;
-    s += leftin;
-    I->pos = I->end;
-    if ((leftin = iof_input(I)) == 0)
-      return done;
-  }
-  if (size)
-  {
-    memcpy(s, I->pos, size * sizeof(uint8_t));
-    I->pos += size;
-    done += size;
-  }
-  return done;
-}
-
-/* rewrite FILE content (use fseek if needed) */
-
-size_t iof_write_file_handle (iof *O, FILE *file)
-{
-  size_t leftout, size, readout;
-  if ((leftout = iof_left(O)) == 0)
-    if ((leftout = iof_output(O)) == 0)
-      return 0;
-  size = 0;
-  do {
-    readout = fread(O->pos, 1, leftout, file);    
-    O->pos += readout;
-    size += readout;
-  } while(readout == leftout && (leftout = iof_output(O)) > 0);
-  return size;
-}
-
-size_t iof_write_file (iof *O, const char *filename)
-{
-  FILE *file;
-  size_t size;
-  if ((file = fopen(filename, "rb")) == NULL)
-    return 0;
-  size = iof_write_file_handle(O, file);
-  fclose(file);
-  return size;
-}
-
-size_t iof_write_iofile (iof *O, iof_file *iofile, int savepos)
-{
-  long offset;
-  size_t size;
-  FILE *file;
-  if (iofile->flags & IOF_DATA)
-    return iof_write(O, iofile->pos, (size_t)(iofile->end - iofile->pos));
-  file = iof_file_get_fh(iofile);
-  if (savepos)
-  {
-    offset = ftell(file);  
-    size = iof_write_file_handle(O, file);
-    fseek(file, offset, SEEK_SET);
-    return size;
-  }
-  return iof_write_file_handle(O, file);
-}
-
-/* write n-bytes */
-
-size_t iof_write (iof *O, const void *data, size_t size)
-{
-  size_t leftout, done = 0;
-  const char *s = (const char *)data;
-  if ((leftout = iof_left(O)) == 0)
-    if ((leftout = iof_output(O)) == 0)
-      return done;
-  while (size > leftout)
-  {
-    memcpy(O->pos, s, leftout * sizeof(uint8_t));
-    size -= leftout;
-    done += leftout;
-    s += leftout;
-    O->pos = O->end;
-    if ((leftout = iof_output(O)) == 0)
-      return done;
-  }
-  if (size)
-  {
-    memcpy(O->pos, s, size * sizeof(uint8_t));
-    O->pos += size;
-    done += size;
-  }
-  return done;
-}
-
-/* write '\0'-terminated string */
-
-iof_status iof_puts (iof *O, const void *data)
-{
-  const char *s = (const char *)data;
-  while (*s)
-  {
-    if (iof_writable(O))
-      iof_set(O, *s++);
-    else
-      return IOFFULL;
-  }
-  return IOFEOF; // ?
-}
-
-size_t iof_put_string (iof *O, const void *data)
-{
-  const char *p, *s = (const char *)data;
-  for (p = s; *p != '\0' && iof_writable(O); iof_set(O, *p++));
-  return p - s;
-}
-
-/* write byte n-times */
-
-/*
-iof_status iof_repc (iof *O, char c, size_t bytes)
-{
-  while (bytes)
-  {
-    if (iof_writable(O))
-      iof_set(O, c);
-    else
-      return IOFFULL;
-    --bytes;
-  }
-  return IOFEOF; // ?
-}
-*/
-
-size_t iof_repc (iof *O, char c, size_t bytes)
-{
-  size_t leftout, todo = bytes;
-  if ((leftout = iof_left(O)) == 0)
-    if ((leftout = iof_output(O)) == 0)
-      return 0;
-  while (bytes > leftout)
-  {
-    memset(O->pos, c, leftout);
-    bytes -= leftout;
-    O->pos = O->end;
-    if ((leftout = iof_output(O)) == 0)
-      return todo - bytes;
-  }
-  if (bytes)
-  {
-    memset(O->pos, c, bytes);
-    O->pos += bytes;
-  }
-  return todo;
-}
-
-/* putfs */
-
-#define IOF_FMT_SIZE 1024
-
-size_t iof_putfs (iof *O, const char *format, ...)
-{
-  static char buffer[IOF_FMT_SIZE];
-  va_list args;
-  va_start(args, format);
-  if (vsnprintf(buffer, IOF_FMT_SIZE, format, args) > 0)
-  {
-    va_end(args);
-    return iof_put_string(O, buffer);
-  }
-  else
-  {
-    va_end(args);
-    return iof_write(O, buffer, IOF_FMT_SIZE);
-  }
-}
-
-/* integer from iof; return 1 on success, 0 otherwise */
-
-int iof_get_int32 (iof *I, int32_t *number)
-{
-  int sign, c = iof_char(I);
-  iof_scan_sign(I, c, sign);
-  if (!base10_digit(c)) return 0;
-  iof_read_integer(I, c, *number);
-  if (sign) *number = -*number;
-  return 1;
-}
-
-int iof_get_intlw (iof *I, intlw_t *number)
-{
-  int sign, c = iof_char(I);
-  iof_scan_sign(I, c, sign);
-  if (!base10_digit(c)) return 0;
-  iof_read_integer(I, c, *number);
-  if (sign) *number = -*number;
-  return 1;
-}
-
-int iof_get_int64 (iof *I, int64_t *number)
-{
-  int sign, c = iof_char(I);
-  iof_scan_sign(I, c, sign);
-  if (!base10_digit(c)) return 0;
-  iof_read_integer(I, c, *number);
-  if (sign) *number = -*number;
-  return 1;
-}
-
-int iof_get_uint32 (iof *I, uint32_t *number)
-{
-  int c = iof_char(I);
-  if (!base10_digit(c)) return 0;
-  iof_read_integer(I, c, *number);
-  return 1;
-}
-
-int iof_get_uintlw (iof *I, uintlw_t *number)
-{
-  int c = iof_char(I);
-  if (!base10_digit(c)) return 0;
-  iof_read_integer(I, c, *number);
-  return 1;
-}
-
-int iof_get_uint64 (iof *I, uint64_t *number)
-{
-  int c = iof_char(I);
-  if (!base10_digit(c)) return 0;
-  iof_read_integer(I, c, *number);
-  return 1;
-}
-
-int iof_get_int32_radix (iof *I, int32_t *number, int radix)
-{
-  int sign, c = iof_char(I);
-  iof_scan_sign(I, c, sign);
-  if (!base10_digit(c)) return 0;
-  iof_read_radix(I, c, *number, radix);
-  if (sign) *number = -*number;
-  return 1;
-
-}
-
-int iof_get_intlw_radix (iof *I, intlw_t *number, int radix)
-{
-  int sign, c = iof_char(I);
-  iof_scan_sign(I, c, sign);
-  if (!base10_digit(c)) return 0;
-  iof_read_radix(I, c, *number, radix);
-  if (sign) *number = -*number;
-  return 1;
-}
-
-int iof_get_int64_radix (iof *I, int64_t *number, int radix)
-{
-  int sign, c = iof_char(I);
-  iof_scan_sign(I, c, sign);
-  if (!base10_digit(c)) return 0;
-  iof_read_radix(I, c, *number, radix);
-  if (sign) *number = -*number;
-  return 1;
-}
-
-int iof_get_uint32_radix (iof *I, uint32_t *number, int radix)
-{
-  int c = iof_char(I);
-  if (!base10_digit(c)) return 0;
-  iof_read_radix(I, c, *number, radix);
-  return 1;
-}
-
-int iof_get_uintlw_radix (iof *I, uintlw_t *number, int radix)
-{
-  int c = iof_char(I);
-  if (!base10_digit(c)) return 0;
-  iof_read_radix(I, c, *number, radix);
-  return 1;
-}
-
-int iof_get_uint64_radix (iof *I, uint64_t *number, int radix)
-{
-  int c = iof_char(I);
-  if (!base10_digit(c)) return 0;
-  iof_read_radix(I, c, *number, radix);
-  return 1;
-}
-
-/* get roman to uint16_t, cf. roman_to_uint16() from utilnumber.c*/
-
-/* todo: some trick in place of this macro horror? */
-
-#define roman1000(c) (c == 'M' || c == 'm')
-#define roman500(c)  (c == 'D' || c == 'd')
-#define roman100(c)  (c == 'C' || c == 'c')
-#define roman50(c)   (c == 'L' || c == 'l')
-#define roman10(c)   (c == 'X' || c == 'x')
-#define roman5(c)    (c == 'V' || c == 'v')
-#define roman1(c)    (c == 'I' || c == 'i')
-
-#define roman100s(I, c) \
-  (roman100(c) ? (100 + ((c = iof_next(I), roman100(c)) ? (100 + ((c = iof_next(I), roman100(c)) ? (c = iof_next(I), 100) : 0)) : 0)) : 0)
-#define roman10s(I, c) \
-  (roman10(c) ? (10 + ((c = iof_next(I), roman10(c)) ? (10 + ((c = iof_next(I), roman10(c)) ? (c = iof_next(I), 10) : 0)) : 0)) : 0)
-#define roman1s(I, c) \
-  (roman1(c) ? (1 + ((c = iof_next(I), roman1(c)) ? (1 + ((c = iof_next(I), roman1(c)) ? (c = iof_next(I), 1) : 0)) : 0)) : 0)
-
-int iof_get_roman (iof *I, uint16_t *number)
-{
-  int c;
-  /* M */
-  for (*number = 0, c = iof_char(I); roman1000(c); *number += 1000, c = iof_next(I));
-  /* D C */
-  if (roman500(c))
-  {
-    c = iof_next(I);
-    *number += 500 + roman100s(I, c);
-  }
-  else if (roman100(c))
-  {
-    c = iof_next(I);
-    if (roman1000(c))
-    {
-      c = iof_next(I);
-      *number += 900;
-    }
-    else if (roman500(c))
-    {
-      c = iof_next(I);
-      *number += 400;
-    }
-    else
-      *number += 100 + roman100s(I, c);
-  }
-  /* L X */
-  if (roman50(c))
-  {
-    c = iof_next(I);
-    *number += 50 + roman10s(I, c);
-  }
-  else if (roman10(c))
-  {
-    c = iof_next(I);
-    if (roman100(c))
-    {
-      c = iof_next(I);
-      *number += 90;
-    }
-    else if (roman50(c))
-    {
-      c = iof_next(I);
-      *number += 40;
-    }
-    else
-      *number += 10 + roman10s(I, c);
-  }
-  /* V I */
-  if (roman5(c))
-  {
-    c = iof_next(I);
-    *number += 5 + roman1s(I, c);
-  }
-  else if (roman1(c))
-  {
-    c = iof_next(I);
-    if (roman10(c))
-    {
-      c = iof_next(I);
-      *number += 9;
-    }
-    else if (roman5(c))
-    {
-      c = iof_next(I);
-      *number += 4;
-    }
-    else
-      *number += 1 + roman1s(I, c);
-  }
-  return 1;
-}
-
-/* double from iof; return 1 on success */
-
-int iof_get_double (iof *I, double *number) // cf. string_to_double()
-{
-  int sign, exponent10, c = iof_char(I);
-  iof_scan_sign(I, c, sign);
-  iof_scan_decimal(I, c, *number);
-  if (c == '.')
-  {
-    c = iof_next(I);
-    iof_scan_fraction(I, c, *number, exponent10);
-  }
-  else
-    exponent10 = 0;
-  if (c == 'e' || c == 'E')
-  {
-    c = iof_next(I);
-    iof_scan_exponent10(I, c, exponent10);
-  }
-  double_exp10(*number, exponent10);
-  if (sign) *number = -*number;
-  return 1;
-}
-
-int iof_get_float (iof *I, float *number) // cf. string_to_float() in utilnumber.c
-{
-  int sign, exponent10, c = iof_char(I);
-  iof_scan_sign(I, c, sign);
-  iof_scan_decimal(I, c, *number);
-  if (c == '.')
-  {
-    c = iof_next(I);
-    iof_scan_fraction(I, c, *number, exponent10);
-  }
-  else
-    exponent10 = 0;
-  if (c == 'e' || c == 'E')
-  {
-    c = iof_next(I);
-    iof_scan_exponent10(I, c, exponent10);
-  }
-  float_exp10(*number, exponent10);
-  if (sign) *number = -*number;
-  return 1;
-}
-
-int iof_conv_double (iof *I, double *number) // cf. convert_to_double() in utilnumber.c
-{
-  int sign, exponent10, c = iof_char(I);
-  iof_scan_sign(I, c, sign);
-  iof_scan_decimal(I, c, *number);
-  if (c == '.' || c == ',')
-  {
-    c = iof_next(I);
-    iof_scan_fraction(I, c, *number, exponent10);
-    if (exponent10 < 0)
-      double_negative_exp10(*number, exponent10);
-  }
-  if (sign) *number = -*number;
-  return 1;
-}
-
-int iof_conv_float (iof *I, float *number) // cf. convert_to_float()
-{
-  int sign, exponent10, c = iof_char(I);
-  iof_scan_sign(I, c, sign);
-  iof_scan_decimal(I, c, *number);
-  if (c == '.' || c == ',')
-  {
-    c = iof_next(I);
-    iof_scan_fraction(I, c, *number, exponent10);
-    if (exponent10 < 0)
-      float_negative_exp10(*number, exponent10);
-  }
-  if (sign) *number = -*number;
-  return 1;
-}
-
-/* integer to iof; return a number of written bytes */
-
-#define iof_copy_number_buffer(O, s, p) for (p = s; *p && iof_writable(O); iof_set(O, *p), ++p)
-
-size_t iof_put_int32 (iof *O, int32_t number)
-{
-  const char *s, *p;
-  s = int32_to_string(number);
-  iof_copy_number_buffer(O, s, p);
-  return p - s;
-}
-
-size_t iof_put_intlw (iof *O, intlw_t number)
-{
-  const char *s, *p;
-  s = intlw_to_string(number);
-  iof_copy_number_buffer(O, s, p);
-  return p - s;
-}
-
-size_t iof_put_int64 (iof *O, int64_t number)
-{
-  const char *s, *p;
-  s = int64_to_string(number);
-  iof_copy_number_buffer(O, s, p);
-  return p - s;
-}
-
-size_t iof_put_uint32 (iof *O, uint32_t number)
-{
-  const char *s, *p;
-  s = uint32_to_string(number);
-  iof_copy_number_buffer(O, s, p);
-  return p - s;
-}
-
-size_t iof_put_uintlw (iof *O, uintlw_t number)
-{
-  const char *s, *p;
-  s = uintlw_to_string(number);
-  iof_copy_number_buffer(O, s, p);
-  return p - s;
-}
-
-size_t iof_put_uint64 (iof *O, uint64_t number)
-{
-  const char *s, *p;
-  s = uint64_to_string(number);
-  iof_copy_number_buffer(O, s, p);
-  return p - s;
-}
-
-size_t iof_put_int32_radix (iof *O, int32_t number, int radix)
-{
-  const char *s, *p;
-  s = int32_to_radix(number, radix);
-  iof_copy_number_buffer(O, s, p);
-  return p - s;
-}
-
-size_t iof_put_intlw_radix (iof *O, intlw_t number, int radix)
-{
-  const char *s, *p;
-  s = intlw_to_radix(number, radix);
-  iof_copy_number_buffer(O, s, p);
-  return p - s;
-}
-
-size_t iof_put_int64_radix (iof *O, int64_t number, int radix)
-{
-  const char *s, *p;
-  s = int64_to_radix(number, radix);
-  iof_copy_number_buffer(O, s, p);
-  return p - s;
-}
-
-size_t iof_put_uint32_radix (iof *O, uint32_t number, int radix)
-{
-  const char *s, *p;
-  s = uint32_to_radix(number, radix);
-  iof_copy_number_buffer(O, s, p);
-  return p - s;
-}
-
-size_t iof_put_uintlw_radix (iof *O, uintlw_t number, int radix)
-{
-  const char *s, *p;
-  s = uintlw_to_radix(number, radix);
-  iof_copy_number_buffer(O, s, p);
-  return p - s;
-}
-
-size_t iof_put_uint64_radix (iof *O, uint64_t number, int radix)
-{
-  const char *s, *p;
-  s = uint64_to_radix(number, radix);
-  iof_copy_number_buffer(O, s, p);
-  return p - s;
-}
-
-/* roman numerals */
-
-size_t iof_put_roman_uc (iof *O, uint16_t number)
-{
-  const char *s, *p;
-  s = uint16_to_roman_uc(number);
-  iof_copy_number_buffer(O, s, p);
-  return p - s;
-}
-
-size_t iof_put_roman_lc (iof *O, uint16_t number)
-{
-  const char *s, *p;
-  s = uint16_to_roman_lc(number);
-  iof_copy_number_buffer(O, s, p);
-  return p - s;
-}
-
-/* double/float to iof; return the number of written bytes */
-
-size_t iof_put_double (iof *O, double number, int digits)
-{
-  const char *s, *p;
-  s = double_to_string(number, digits);
-  iof_copy_number_buffer(O, s, p);
-  return p - s;
-}
-
-size_t iof_put_float (iof *O, float number, int digits)
-{
-  const char *s, *p;
-  s = float_to_string(number, digits);
-  iof_copy_number_buffer(O, s, p);
-  return p - s;
-}
-
-/* iof to binary integer; pretty common */
-
-int iof_get_be_uint2 (iof *I, uint32_t *pnumber)
-{
-  int c1, c2;
-  if ((c1 = iof_get(I)) < 0 || (c2 = iof_get(I)) < 0)
-    return 0;
-  *pnumber = (c1<<8)|c2;
-  return 1;
-}
-
-int iof_get_be_uint3 (iof *I, uint32_t *pnumber)
-{
-  int c1, c2, c3;
-  if ((c1 = iof_get(I)) < 0 || (c2 = iof_get(I)) < 0 || (c3 = iof_get(I)) < 0)
-    return 0;
-  *pnumber = (c1<<16)|(c2<<8)|c3;
-  return 1;
-}
-
-int iof_get_be_uint4 (iof *I, uint32_t *pnumber)
-{
-  int c1, c2, c3, c4;
-  if ((c1 = iof_get(I)) < 0 || (c2 = iof_get(I)) < 0 || (c3 = iof_get(I)) < 0 || (c4 = iof_get(I)) < 0)
-    return 0;
-  *pnumber = (c1<<24)|(c2<<16)|(c3<<8)|c4;
-  return 1;
-}
-
-int iof_get_le_uint2 (iof *I, uint32_t *pnumber)
-{
-  int c1, c2;
-  if ((c1 = iof_get(I)) < 0 || (c2 = iof_get(I)) < 0)
-    return 0;
-  *pnumber = (c2<<8)|c1;
-  return 1;
-}
-
-int iof_get_le_uint3 (iof *I, uint32_t *pnumber)
-{
-  int c1, c2, c3;
-  if ((c1 = iof_get(I)) < 0 || (c2 = iof_get(I)) < 0 || (c3 = iof_get(I)) < 0)
-    return 0;
-  *pnumber = (c3<<16)|(c2<<8)|c1;
-  return 1;
-}
-
-int iof_get_le_uint4 (iof *I, uint32_t *pnumber)
-{
-  int c1, c2, c3, c4;
-  if ((c1 = iof_get(I)) < 0 || (c2 = iof_get(I)) < 0 || (c3 = iof_get(I)) < 0 || (c4 = iof_get(I)) < 0)
-    return 0;
-  *pnumber = (c4<<24)|(c3<<16)|(c2<<8)|c1;
-  return 1;
-}
-
-/* iof input data */
-
-uint8_t * iof_file_input_data (iof_file *iofile, size_t *psize, int *isnew)
-{
-  uint8_t *data;
-  if (iofile->flags & IOF_DATA)
-  {
-    data = iofile->buf;
-    *psize = iofile->end - iofile->buf;
-    *isnew = 0;
-    return data;
-  }
-  if (iof_file_reopen(iofile))
-  {
-    data = iof_copy_file_handle_data(iof_file_get_fh(iofile), psize);
-    *isnew = 1;
-    iof_file_reclose(iofile);
-    return data;
-  }
-  return NULL;
-}
-
-/*
-uint8_t * iof_file_reader_data (iof_file *iofile, size_t *size)
-{
-  uint8_t *data;
-  if (!(iofile->flags & IOF_DATA) || iofile->pos == NULL || (*size = (size_t)iof_left(iofile)) == 0)
-    return NULL;  
-  if (iofile->flags & IOF_BUFFER_ALLOC)
-  {
-    data = iofile->buf; // iofile->pos; // returned must be freeable, makes sense when ->buf == ->pos
-    iofile->flags &= ~IOF_BUFFER_ALLOC;
-    iofile->buf = iofile->pos = iofile->end = NULL;
-    return data;
-  }
-  data = (uint8_t *)util_malloc(*size);
-  memcpy(data, iofile->buf, *size);
-  return data;
-}
-
-uint8_t * iof_file_writer_data (iof_file *iofile, size_t *size)
-{
-  uint8_t *data;
-  if (!(iofile->flags & IOF_DATA) || iofile->buf == NULL || (*size = (size_t)iof_size(iofile)) == 0)
-    return NULL;  
-  if (iofile->flags & IOF_BUFFER_ALLOC)
-  {
-    iofile->flags &= ~IOF_BUFFER_ALLOC;
-    data = iofile->buf;
-    iofile->buf = iofile->pos = iofile->end = NULL;
-    return data;
-  }
-  data = (uint8_t *)util_malloc(*size);
-  memcpy(data, iofile->buf, *size);
-  return data;
-}
-*/
-
-uint8_t * iof_reader_data (iof *I, size_t *psize)
-{
-  uint8_t *data;
-  *psize = (size_t)iof_left(I);
-  if (I->flags & IOF_BUFFER_ALLOC)
-  {
-    data = I->buf; // actually I->pos, but we have to return something freeable
-    I->flags &= ~IOF_BUFFER_ALLOC;
-    I->buf = NULL;
-  }
-  else
-  {
-    data = util_malloc(*psize);
-    memcpy(data, I->pos, *psize);
-  }
-  iof_close(I);
-  return data;
-}
-
-
-uint8_t * iof_writer_data (iof *O, size_t *psize)
-{
-  uint8_t *data;
-  *psize = (size_t)iof_size(O);
-  if (O->flags & IOF_BUFFER_ALLOC)
-  {
-    data = O->buf;
-    O->flags &= ~IOF_BUFFER_ALLOC;
-    O->buf = NULL;
-  }
-  else
-  {
-    data = util_malloc(*psize);
-    memcpy(data, O->buf, *psize);
-  }
-  iof_close(O);
-  return data;
-}
-
-size_t iof_reader_to_file_handle (iof *I, FILE *file)
-{
-  size_t size;
-  for (size = 0; iof_readable(I); I->pos = I->end)
-    size += fwrite(I->buf, sizeof(uint8_t), iof_left(I), file);
-  return size;
-}
-
-size_t iof_reader_to_file (iof *I, const char *filename)
-{
-  FILE *file;
-  size_t size;
-  if ((file = fopen(filename, "wb")) == NULL)
-    return 0;
-  for (size = 0; iof_readable(I); I->pos = I->end)
-    size += fwrite(I->buf, sizeof(uint8_t), iof_left(I), file);
-  fclose(file);
-  return size;
-}
-
-/* debug */
-
-size_t iof_data_to_file (const void *data, size_t size, const char *filename)
-{
-  FILE *fh;
-  if ((fh = fopen(filename, "wb")) == NULL)
-    return 0;
-  // size = fwrite(data, size, sizeof(uint8_t), fh); // WRONG, this always returns 1, as fwrite returns the number of elements successfully written out
-  size = fwrite(data, sizeof(uint8_t), size, fh);
-  fclose(fh);
-  return size;
-}
-
-size_t iof_result_to_file_handle (iof *F, FILE *file)
-{
-  const void *data;
-  size_t size;
-  data = iof_result(F, size);
-	return iof_data_to_file_handle(data, size, file);
-}
-
-size_t iof_result_to_file (iof *F, const char *filename)
-{
-  const void *data;
-  size_t size;
-  data = iof_result(F, size);
-  return iof_data_to_file(data, size, filename);
-}
-
-void iof_debug (iof *I, const char *filename)
-{
-  FILE *file = fopen(filename, "wb");
-  if (file != NULL)
-  {
-    fprintf(file, ">>> buf %p <<<\n", I->buf);
-    fwrite(I->buf, sizeof(uint8_t), iof_size(I), file);
-    fprintf(file, "\n>>> pos %p (%ld) <<<\n", I->pos, (long)iof_size(I));
-    fwrite(I->pos, sizeof(uint8_t), iof_left(I), file);
-    fprintf(file, "\n>>> end %p (%ld) <<<\n", I->end, (long)iof_left(I));
-    fwrite(I->end, sizeof(uint8_t), I->space - iof_space(I), file);
-    fprintf(file, "\n>>> end of buffer %p (%ld) <<<\n", I->buf + I->space, (long)(I->buf + I->space - I->end));
-    fclose(file);
-  }
-}
-
-/* common filters api */
-
-/* sizes of filter states on x64
-size of iof_filter: 640 (no longer used; sizeof(iof) + sizeof larger state)
-size of file_state: 16
-size of stream_state: 16
-size of flate_state: 104
-size of lzw_state: 56
-size of predictor_state: 104
-size of basexx_state: 48
-size of basexx_state: 48
-size of basexx_state: 48
-size of eexec_state: 40
-size of runlength_state: 24
-size of rc4_state: 24
-size of aes_state: 72
-size of img_state: 576
-size of img: 496
-*/
-
-typedef struct iof_heap iof_heap;
-
-struct iof_heap {
-  uint8_t *data, *pos;
-  size_t size, space;
-  iof_heap *next, *prev;
-  int refcount;
-};
-
-typedef struct {
-  iof_heap *heap;
-} iof_heap_ghost;
-
-static iof_heap * iof_buffers_heap = NULL;
-static iof_heap * iof_filters_heap = NULL;
-
-#define IOF_HEAP_FILTERS_COUNT 4
-#define IOF_BUFFER_SIZE 262144 // (1<<18)
-#define IOF_FILTER_SIZE 1024
-// sizeof(iof_filter) on x64 is now 640, img_state 576, img 496, others 16-104
-#define IOF_BUFFER_HEAP_SIZE (IOF_HEAP_FILTERS_COUNT * (IOF_BUFFER_SIZE + sizeof(iof_heap_ghost)))
-#define IOF_FILTER_HEAP_SIZE (IOF_HEAP_FILTERS_COUNT * (IOF_FILTER_SIZE + sizeof(iof_heap_ghost)))
-
-static iof_heap * iof_heap_new (size_t space)
-{
-  iof_heap *iofheap;
-  iofheap = (iof_heap *)util_malloc(sizeof(iof_heap) + space);
-  iofheap->data = iofheap->pos = (uint8_t *)(iofheap + 1);
-  iofheap->size = iofheap->space = space;
-  iofheap->next = NULL;
-  iofheap->prev = NULL;
-  iofheap->refcount = 0;
-  return iofheap;
-}
-
-#define iof_heap_free(iofheap) util_free(iofheap)
-
-void iof_filters_init (void)
-{
-  if (iof_buffers_heap == NULL)
-    iof_buffers_heap = iof_heap_new(IOF_BUFFER_HEAP_SIZE);
-  if (iof_filters_heap == NULL)
-    iof_filters_heap = iof_heap_new(IOF_FILTER_HEAP_SIZE);
-}
-
-void iof_filters_free (void)
-{
-  iof_heap *heap, *next;
-  for (heap = iof_buffers_heap; heap != NULL; heap = next)
-  {
-    next = heap->next;
-    if (heap->refcount != 0)
-      loggerf("not closed iof filters left (%d)", heap->refcount);
-    if (next != NULL)
-      loggerf("iof filters heap left");
-    iof_heap_free(heap);
-  }
-  iof_buffers_heap = NULL;
-  for (heap = iof_filters_heap; heap != NULL; heap = next)
-  {
-    next = heap->next;
-    if (heap->refcount != 0)
-      loggerf("not closed iof buffers left (%d)", heap->refcount);
-    if (next != NULL)
-      loggerf("iof buffers heap left");
-    iof_heap_free(heap);
-  }
-  iof_filters_heap = NULL;
-}
-
-#if defined __arm__ || defined __ARM__ || defined ARM || defined __ARM || defined __arm || defined __ARM_ARCH ||defined __aarch64__ 
-#define iof_heap_get(hp, ghost, data, siz) \
- (ghost = (iof_heap_ghost *)((void*)((hp)->pos)), \
-  ghost->heap = hp, \
-  data = (uint8_t *)(ghost + 1), \
-  (hp)->pos += siz, \
-  (hp)->size -= siz, \
-  ++(hp)->refcount)
-#else
-#define iof_heap_get(hp, ghost, data, siz) \
- (ghost = (iof_heap_ghost *)((hp)->pos), \
-  ghost->heap = hp, \
-  data = (uint8_t *)(ghost + 1), \
-  (hp)->pos += siz, \
-  (hp)->size -= siz, \
-  ++(hp)->refcount)
-
-#endif
-
-
-static void * iof_heap_take (iof_heap **pheap, size_t size)
-{
-  uint8_t *data;
-  iof_heap_ghost *ghost;
-  iof_heap *heap, *newheap, *next;
-
-  heap = *pheap;
-  size += sizeof(iof_heap_ghost);
-  if (heap->size >= size)
-  { /* take cheap mem from main heap */
-    iof_heap_get(heap, ghost, data, size);
-    return data;
-  }
-  if (size <= heap->space >> 1)
-  { /* make new cheap heap, make it front */
-    *pheap = newheap = iof_heap_new(heap->space);
-    newheap->next = heap;
-    heap->prev = newheap;
-    iof_heap_get(newheap, ghost, data, size);
-    return data;
-  }
-  /* size much larger than expected? should not happen.
-     make a single-item heap, keep the front heap intact. */
-  newheap = iof_heap_new(size);
-  if ((next = heap->next) != NULL)
-  {
-    newheap->next = next;
-    next->prev = newheap;
-  }
-  heap->next = newheap;
-  newheap->prev = heap;
-  iof_heap_get(newheap, ghost, data, size);
-  return data;
-}
-
-void iof_heap_back (void *data)
-{
-  iof_heap_ghost *ghost;
-  iof_heap *heap, *next, *prev;
-
-  ghost = ((iof_heap_ghost *)data) - 1;
-  heap = ghost->heap;
-  if (heap->refcount == 0)
-    loggerf("invalid use of iof heap, refcount < 0");
-  if (--heap->refcount <= 0)
-  {
-    if ((prev = heap->prev) != NULL)
-    { /* free the heap */
-      if ((next = heap->next) != NULL)
-        prev->next = next, next->prev = prev;
-      else
-        prev->next = NULL;
-      iof_heap_free(heap);
-    }
-    else
-    { /* this is the front heap, just reset */
-      heap->pos = heap->data;
-      heap->size = heap->space;
-    }
-  }
-}
-
-void * iof_filter_new (size_t size)
-{ // to be removed
-  void *data;
-
-  iof_filters_init();
-  data = iof_heap_take(&iof_filters_heap, size);
-  return memset(data, 0, size);
-}
-
-static uint8_t * iof_filter_buffer_new (size_t *psize)
-{
-  iof_filters_init();
-  *psize = IOF_BUFFER_SIZE;
-  return iof_heap_take(&iof_buffers_heap, IOF_BUFFER_SIZE);
-}
-
-iof * iof_filter_reader_new (iof_handler handler, size_t statesize, void **pstate)
-{
-  iof *F;
-  void *filter;
-  uint8_t *buffer;
-  size_t buffersize;
-
-  iof_filters_init();
-  filter = iof_heap_take(&iof_filters_heap, sizeof(iof) + statesize);
-  F = (iof *)memset(filter, 0, sizeof(iof) + statesize);
-  buffer = iof_filter_buffer_new(&buffersize);
-  iof_reader_buffer(F, buffer, buffersize);
-  F->flags |= IOF_HEAP|IOF_BUFFER_HEAP;
-  F->more = handler;
-  *pstate = (F + 1);
-  return F;
-}
-
-iof * iof_filter_reader_with_buffer_new (iof_handler handler, size_t statesize, void **pstate, void *buffer, size_t buffersize)
-{ // for filters that has own buffer (string, some image filters)
-  iof *F;
-  void *filter;
-  iof_filters_init();
-  filter = iof_heap_take(&iof_filters_heap, sizeof(iof) + statesize);
-  F = (iof *)memset(filter, 0, sizeof(iof) + statesize);
-  iof_reader_buffer(F, buffer, buffersize);
-  F->flags |= IOF_HEAP;
-  F->more = handler;
-  *pstate = (F + 1);
-  return F;
-}
-
-iof * iof_filter_writer_new (iof_handler handler, size_t statesize, void **pstate)
-{
-  iof *F;
-  void *filter;
-  uint8_t *buffer;
-  size_t buffersize;
-
-  iof_filters_init();
-  filter = iof_heap_take(&iof_filters_heap, sizeof(iof) + statesize);
-  F = (iof *)memset(filter, 0, sizeof(iof) + statesize);
-  buffer = iof_filter_buffer_new(&buffersize);
-  iof_writer_buffer(F, buffer, buffersize);
-  F->flags |= IOF_HEAP|IOF_BUFFER_HEAP;
-  F->more = handler;
-  *pstate = (F + 1);
-  return F;
-}
-
-iof * iof_filter_writer_with_buffer_new (iof_handler handler, size_t statesize, void **pstate, void *buffer, size_t size)
-{
-  iof *F;
-  void *filter;
-  size_t buffersize;
-
-  iof_filters_init();
-  filter = iof_heap_take(&iof_filters_heap, sizeof(iof) + statesize);
-  F = (iof *)memset(filter, 0, sizeof(iof) + statesize);
-  buffer = iof_filter_buffer_new(&buffersize);
-  iof_writer_buffer(F, buffer, buffersize);
-  F->flags |= IOF_HEAP;
-  F->more = handler;
-  *pstate = (F + 1);
-  return F;
-}
-
-/* close */
-
-#define iof_close_next(F) ((void)(iof_decref((F)->next), (F)->next = NULL, 0))
-/* when filter creation fails, we should take care to destroy the filter but leave ->next intact */
-#define iof_clear_next(F) ((void)(iof_unref((F)->next), (F)->next = NULL, 0))
-
-#define iof_close_buffer(F) ((void)\
-  ((F)->buf != NULL ? \
-      ((F->flags & IOF_BUFFER_ALLOC) ? (util_free((F)->buf), (F)->buf = NULL, 0) : \
-      ((F->flags & IOF_BUFFER_HEAP) ? (iof_filter_buffer_free((F)->buf), (F)->buf = NULL, 0) : ((F)->buf = NULL, 0))) : 0))
-
-/* closing underlying file handle */
-
-static void iof_close_file (iof *F)
-{
-  FILE *file;
-  //if (F->flags & IOF_FILE_HANDLE)
-  //{
-    if ((file = F->file) != NULL)
-    {
-      if (F->flags & IOF_CLOSE_FILE)
-        fclose(F->file);
-      F->file = NULL;
-    }
-  //}
-}
-
-/* a very special variant for reader filters initiated with iof_file_reopen(). It also calls
-   iof_file_reclose(), which takes an effect only if previously reopened, but better to keep
-   all this thin ice separated. Used in filters: iofile_reader, iofile_stream_reader, image
-   decoders. */
-
-static void iof_close_iofile (iof *F)
-{
-  iof_file *iofile;
-  //if (F->flags & IOF_FILE)
-  //{
-    if ((iofile = F->iofile) != NULL)
-    {
-      iof_file_unsync(iofile, NULL);
-      iof_file_reclose(iofile); // takes an effect iff prevoiusly reopened
-      iof_file_decref(iofile);
-      F->iofile = NULL;
-    }
-  //}
-}
-
-void iof_free (iof *F)
-{
-  if (F->flags & IOF_FILE_HANDLE)
-    iof_close_file(F);
-  else if (F->flags & IOF_FILE)
-    iof_close_iofile(F);
-  else if (F->flags & IOF_NEXT)
-    iof_close_next(F);
-  iof_close_buffer(F);
-  if (F->flags & IOF_HEAP)
-    iof_filter_free(F);
-  else if (F->flags & IOF_ALLOC)
-    util_free(F);
-}
-
-void iof_discard (iof *F)
-{ // so far used only on failed filters creation; as iof_free() but don't dare to release ->next
-  if (F->flags & IOF_FILE_HANDLE)
-    iof_close_file(F);
-  else if (F->flags & IOF_FILE)
-    iof_close_iofile(F);
-  else if (F->flags & IOF_NEXT)
-    iof_close_next(F);
-  iof_close_buffer(F);
-  if (F->flags & IOF_HEAP)
-    iof_filter_free(F);
-  else if (F->flags & IOF_ALLOC)
-    util_free(F);
-}
-
-/* resizing buffer */
-
-size_t iof_resize_buffer_to (iof *O, size_t space)
-{
-  uint8_t *buf;
-
-  if (O->flags & IOF_BUFFER_ALLOC)
-  {
-    buf = (uint8_t *)util_realloc(O->buf, space);
-  }
-  else
-  {
-    buf = (uint8_t *)util_malloc(space);
-    memcpy(buf, O->buf, iof_size(O));
-    if (O->flags & IOF_BUFFER_HEAP)
-    {
-      iof_filter_buffer_free(O->buf);
-      O->flags &= ~IOF_BUFFER_HEAP;
-    }
-    O->flags |= IOF_BUFFER_ALLOC;
-
-  }
-  O->pos = buf + iof_size(O);
-  O->end = buf + space;
-  O->buf = buf;
-  O->space = space;
-  return iof_left(O);
-}
-
-/* */
-
-size_t iof_decoder_retval (iof *I, const char *type, iof_status status)
-{
-  switch (status)
-  {
-    case IOFERR:
-    case IOFEMPTY:             // should never happen as we set state.flush = 1 on decoders init
-      loggerf("%s decoder error (%d, %s)", type, status, iof_status_kind(status));
-      I->flags |= IOF_STOPPED;
-      return 0;
-    case IOFEOF:               // this is the last chunk,
-      I->flags |= IOF_STOPPED; // so stop it and fall
-    case IOFFULL:              // prepare pointers to read from I->buf
-      I->end = I->pos;
-      I->pos = I->buf;
-      return I->end - I->buf;
-  }
-  loggerf("%s decoder bug, invalid retval %d", type, status);
-  return 0;
-}
-
-size_t iof_encoder_retval (iof *O, const char *type, iof_status status)
-{
-  switch (status)
-  {
-    case IOFERR:
-    case IOFFULL:
-      loggerf("%s encoder error (%d, %s)", type, status, iof_status_kind(status));
-      return 0;
-    case IOFEMPTY:
-      O->pos = O->buf;
-      O->end = O->buf + O->space;
-      return O->space;
-    case IOFEOF:
-      return 0;
-  }
-  loggerf("%s encoder bug, invalid retval %d", type, status);
-  return 0;
-}
-
-/* file/stream state */
-
-typedef struct {
-  size_t length;
-  size_t offset;
-} file_state;
-
-
-#define file_state_init(state, off, len) ((state)->offset = off, (state)->length = len)
-
-typedef struct {
-  size_t length;
-  size_t offset;
-} stream_state;
-
-#define stream_state_init(state, off, len) ((state)->offset = off, (state)->length = len)
-
-static size_t file_read (iof *I)
-{
-  size_t bytes, tail;
-  if (I->flags & IOF_STOPPED)
-    return 0;
-  tail = iof_tail(I);
-  if ((bytes = tail + fread(I->buf + tail, sizeof(uint8_t), I->space - tail, I->file)) < I->space)
-    I->flags |= IOF_STOPPED;
-  I->pos = I->buf;
-  I->end = I->buf + bytes;
-  return bytes;
-}
-
-static size_t iofile_read (iof *I, size_t *poffset)
-{
-  size_t bytes, tail;
-  if (I->flags & IOF_STOPPED)
-    return 0;
-  iof_file_sync(I->iofile, poffset);
-  tail = iof_tail(I);
-  if ((bytes = tail + iof_file_read(I->buf + tail, sizeof(uint8_t), I->space - tail, I->iofile)) < I->space)
-  {
-    I->flags |= IOF_STOPPED;
-    iof_file_unsync(I->iofile, poffset);
-  }
-  I->pos = I->buf;
-  I->end = I->buf + bytes;
-  return bytes;
-}
-
-static size_t file_load (iof *I)
-{
-  size_t bytes, left, tail;
-  if (I->flags & IOF_STOPPED)
-    return 0;
-  tail = iof_tail(I);
-  I->pos = I->buf + tail;
-  I->end = I->buf + I->space; /* don't assume its done when initializing the filter */
-  left = I->space - tail;
-  do {
-    bytes = fread(I->pos, sizeof(uint8_t), left, I->file);
-    I->pos += bytes;
-  } while (bytes == left && (left = iof_resize_buffer(I)) > 0);
-  I->flags |= IOF_STOPPED;
-  return iof_loaded(I);
-}
-
-static size_t iofile_load (iof *I, size_t *poffset)
-{
-  size_t bytes, left, tail;
-  if (I->flags & IOF_STOPPED)
-    return 0;
-  tail = iof_tail(I);
-  I->pos = I->buf + tail;
-  I->end = I->buf + I->space; /* don't assume its done when initializing the filter */
-  left = I->space - tail;
-  iof_file_sync(I->iofile, poffset);
-  do {
-    bytes = iof_file_read(I->pos, sizeof(uint8_t), left, I->iofile);
-    I->pos += bytes;
-  } while (bytes == left && (left = iof_resize_buffer(I)) > 0);
-  I->flags |= IOF_STOPPED;
-  iof_file_unsync(I->iofile, poffset);
-  return iof_loaded(I);
-}
-
-static size_t filter_file_reader (iof *I, iof_mode mode)
-{
-  switch (mode)
-  {
-    case IOFREAD:
-      return file_read(I);
-    case IOFLOAD:
-      return file_load(I);
-    case IOFCLOSE:
-      iof_free(I);
-      return 0;
-    default:
-      return 0;
-  }
-}
-
-static size_t filter_iofile_reader (iof *I, iof_mode mode)
-{
-  file_state *state;
-  state = iof_filter_state(file_state *, I);
-  switch (mode)
-  {
-    case IOFREAD:
-      return iofile_read(I, &state->offset);
-    case IOFLOAD:
-      return iofile_load(I, &state->offset);
-    case IOFCLOSE:
-      iof_free(I);
-      return 0;
-    default:
-      return 0;
-  }
-}
-
-static size_t file_write (iof *O, int flush)
-{
-  size_t bytes;
-  if ((bytes = iof_size(O)) > 0)
-    if (bytes != fwrite(O->buf, sizeof(uint8_t), bytes, O->file))
-      return 0;
-  if (flush)
-    fflush(O->file);
-  O->end = O->buf + O->space; // remains intact actually
-  O->pos = O->buf;
-  return O->space;
-}
-
-static size_t iofile_write (iof *O, size_t *poffset, int flush)
-{
-  size_t bytes;
-  iof_file_sync(O->iofile, poffset);
-  if ((bytes = iof_size(O)) > 0)
-  {
-    if (bytes != iof_file_write(O->buf, sizeof(uint8_t), bytes, O->iofile))
-    {
-      iof_file_unsync(O->iofile, poffset);
-      return 0;
-    }
-  }
-  if (flush)
-    iof_file_flush(O->iofile);
-  O->end = O->buf + O->space; // remains intact actually
-  O->pos = O->buf;
-  return O->space;
-}
-
-static size_t filter_file_writer (iof *O, iof_mode mode)
-{
-  switch (mode)
-  {
-    case IOFWRITE:
-      return file_write(O, 0);
-    case IOFFLUSH:
-      return file_write(O, 1);
-    case IOFCLOSE:
-      file_write(O, 1);
-      iof_free(O);
-      return 0;
-    default:
-      return 0;
-  }
-}
-
-static size_t filter_iofile_writer (iof *O, iof_mode mode)
-{
-  file_state *state;
-  state = iof_filter_state(file_state *, O);
-  switch (mode)
-  {
-    case IOFWRITE:
-      return iofile_write(O, &state->offset, 0);
-    case IOFFLUSH:
-      return iofile_write(O, &state->offset, 1);
-    case IOFCLOSE:
-      iofile_write(O, &state->offset, 1);
-      iof_free(O);
-      return 0;
-    default:
-      return 0;
-  }
-}
-
-/* filter from FILE* */
-
-iof * iof_filter_file_handle_reader (FILE *file)
-{
-  iof *I;
-  file_state *state;
-  if (file == NULL)
-    return NULL;
-  I = iof_filter_reader(filter_file_reader, sizeof(file_state), &state);
-  iof_setup_file(I, file);
-  file_state_init(state, 0, 0);
-  return I;
-}
-
-iof * iof_filter_file_handle_writer (FILE *file)
-{
-  iof *O;
-  file_state *state;
-  if (file == NULL)
-    return NULL;
-  O = iof_filter_writer(filter_file_writer, sizeof(file_state), &state);
-  iof_setup_file(O, file);
-  file_state_init(state, 0, 0);
-  return O;
-}
-
-/* filter from iof_file * */
-
-iof * iof_filter_iofile_reader (iof_file *iofile, size_t offset)
-{
-  iof *I;
-  file_state *state;
-  if (!iof_file_reopen(iofile))
-    return NULL;
-  I = iof_filter_reader(filter_iofile_reader, sizeof(file_state), &state);
-  iof_setup_iofile(I, iofile);
-  file_state_init(state, offset, 0);
-  return I;
-}
-
-iof * iof_filter_iofile_writer (iof_file *iofile, size_t offset)
-{
-  iof *O;
-  file_state *state;
-  O = iof_filter_writer(filter_iofile_writer, sizeof(file_state), &state);
-  iof_setup_iofile(O, iofile);
-  file_state_init(state, offset, 0);
-  return O;
-}
-
-/* filter from filename */
-
-iof * iof_filter_file_reader (const char *filename)
-{
-  iof *I;
-  file_state *state;
-  FILE *file;
-  if ((file = fopen(filename, "rb")) == NULL)
-    return NULL;
-  I = iof_filter_reader(filter_file_reader, sizeof(file_state), &state);
-  iof_setup_file(I, file);
-  file_state_init(state, 0, 0);
-  I->flags |= IOF_CLOSE_FILE;
-  return I;
-}
-
-iof * iof_filter_file_writer (const char *filename)
-{
-  iof *O;
-  file_state *state;
-  FILE *file;
-  if ((file = fopen(filename, "wb")) == NULL)
-    return NULL;
-  O = iof_filter_writer(filter_file_writer, sizeof(file_state), &state);
-  iof_setup_file(O, file);
-  file_state_init(state, 0, 0);
-  O->flags |= IOF_CLOSE_FILE;
-  return O;
-}
-
-/* from string */
-
-static size_t dummy_handler (iof *I, iof_mode mode)
-{
-  switch (mode)
-  {
-    case IOFCLOSE:
-      iof_free(I);
-      return 0;
-    default:
-      return 0;
-  }
-}
-
-iof * iof_filter_string_reader (const void *s, size_t length)
-{
-  iof *I;
-  void *dummy;
-  I = iof_filter_reader_with_buffer(dummy_handler, 0, &dummy, NULL, 0);
-  I->rbuf = I->rpos = (const uint8_t *)s;
-  I->rend = (const uint8_t *)s + length;
-  // I->space = length;
-  return I;
-}
-
-iof * iof_filter_string_writer (const void *s, size_t length)
-{
-  iof *O;
-  void *dummy;
-  O = iof_filter_reader_with_buffer(dummy_handler, 0, &dummy, NULL, 0);
-  O->rbuf = O->rpos = (const uint8_t *)s;
-  O->rend = (const uint8_t *)s + length;
-  // O->space = length;
-  return O;
-}
-
-iof * iof_filter_buffer_writer (size_t size)
-{ // filter alternative of iof_buffer_create()
-  iof *O;
-  void *dummy;
-  uint8_t *buffer;
-  if (size > IOF_BUFFER_SIZE)
-  {
-    buffer = (uint8_t *)util_malloc(size);
-    O = iof_filter_writer_with_buffer(iof_mem_handler, 0, &dummy, buffer, size);
-    O->flags |= IOF_BUFFER_ALLOC;
-    return O;
-  }
-	return iof_filter_writer(iof_mem_handler, 0, &dummy);
-}
-
-/* stream */
-
-static size_t file_stream_read (iof *I, size_t *plength)
-{
-  size_t bytes, tail;
-  if (I->flags & IOF_STOPPED || *plength == 0)
-    return 0;
-  tail = iof_tail(I);
-  if (I->space - tail >= *plength)
-  {
-    bytes = tail + fread(I->buf + tail, sizeof(uint8_t), *plength, I->file);
-    I->flags |= IOF_STOPPED;
-    *plength = 0;
-  }
-  else
-  {
-    bytes = tail + fread(I->buf + tail, sizeof(uint8_t), I->space - tail, I->file);
-    *plength -= bytes - tail;
-  }
-  I->pos = I->buf;
-  I->end = I->buf + bytes;
-  return bytes;
-}
-
-static size_t iofile_stream_read (iof *I, size_t *plength, size_t *poffset)
-{
-  size_t bytes, tail;
-  if (I->flags & IOF_STOPPED || *plength == 0)
-    return 0;
-  tail = iof_tail(I);
-  iof_file_sync(I->iofile, poffset);
-  if (I->space - tail >= *plength)
-  {
-    bytes = tail + iof_file_read(I->buf + tail, sizeof(uint8_t), *plength, I->iofile);
-    iof_file_unsync(I->iofile, poffset);
-    I->flags |= IOF_STOPPED;
-    *plength = 0;
-  }
-  else
-  {
-    bytes = tail + iof_file_read(I->buf + tail, sizeof(uint8_t), I->space - tail, I->iofile);
-    *plength -= bytes - tail;
-  }
-  I->pos = I->buf;
-  I->end = I->buf + bytes;
-  return bytes;
-}
-
-static size_t file_stream_load (iof *I, size_t *plength)
-{
-  size_t bytes, tail;
-  if (I->flags & IOF_STOPPED || *plength == 0)
-    return 0;
-  tail = iof_tail(I);
-  if (I->space - tail < *plength)
-    if (iof_resize_buffer_to(I, tail + *plength) == 0)
-      return 0;
-  bytes = tail + fread(I->buf + tail, sizeof(uint8_t), *plength, I->file);
-  I->flags |= IOF_STOPPED;
-  *plength = 0;
-  I->pos = I->buf;
-  I->end = I->buf + bytes;
-  return bytes;
-}
-
-static size_t iofile_stream_load (iof *I, size_t *plength, size_t *poffset)
-{
-  size_t bytes, tail;
-  if (I->flags & IOF_STOPPED || *plength == 0)
-    return 0;
-  iof_file_sync(I->iofile, poffset);
-  tail = iof_tail(I);
-  if (I->space - tail < *plength)
-    if (iof_resize_buffer_to(I, tail + *plength) == 0)
-      return 0;
-  bytes = tail + iof_file_read(I->buf + tail, sizeof(uint8_t), *plength, I->iofile);
-  iof_file_unsync(I->iofile, poffset);
-  I->flags |= IOF_STOPPED;
-  *plength = 0;
-  I->pos = I->buf;
-  I->end = I->buf + bytes;
-  return bytes;
-}
-
-static size_t filter_file_stream_reader (iof *I, iof_mode mode)
-{
-  stream_state *state;
-  state = iof_filter_state(stream_state *, I);
-  switch(mode)
-  {
-    case IOFREAD:
-      return file_stream_read(I, &state->length);
-    case IOFLOAD:
-      return file_stream_load(I, &state->length);
-    case IOFCLOSE:
-      iof_free(I);
-      return 0;
-    default:
-      return 0;
-  }
-}
-
-static size_t filter_iofile_stream_reader (iof *I, iof_mode mode)
-{
-  stream_state *state;
-  state = iof_filter_state(stream_state *, I);
-  switch(mode)
-  {
-    case IOFREAD:
-      return iofile_stream_read(I, &state->length, &state->offset);
-    case IOFLOAD:
-      return iofile_stream_load(I, &state->length, &state->offset);
-    case IOFCLOSE:
-      iof_free(I);
-      return 0;
-    default:
-      return 0;
-  }
-}
-
-iof * iof_filter_stream_reader (FILE *file, size_t offset, size_t length)
-{
-  iof *I;
-  stream_state *state;
-  I = iof_filter_reader(filter_file_stream_reader, sizeof(stream_state), &state);
-  iof_setup_file(I, file);
-  stream_state_init(state, offset, length);
-  fseek(file, (long)offset, SEEK_SET); // or perhaps it should be call in file_stream_read(), like iof_file_sync()?
-  return I;
-}
-
-iof * iof_filter_stream_coreader (iof_file *iofile, size_t offset, size_t length)
-{
-  iof *I;
-  stream_state *state;
-  if (!iof_file_reopen(iofile))
-    return NULL;
-  I = iof_filter_reader(filter_iofile_stream_reader, sizeof(stream_state), &state);
-  iof_setup_iofile(I, iofile);
-  stream_state_init(state, offset, length);
-  return I;
-}
-
-static size_t file_stream_write (iof *O, size_t *plength, int flush)
-{
-  size_t bytes;
-  if ((bytes = iof_size(O)) > 0)
-  {
-    if (bytes != fwrite(O->buf, sizeof(uint8_t), bytes, O->file))
-    {
-      *plength += bytes;
-      return 0;
-    }
-  }
-  if (flush)
-    fflush(O->file);
-  *plength += bytes;
-  O->end = O->buf + O->space; // remains intact
-  O->pos = O->buf;
-  return O->space;
-}
-
-static size_t iofile_stream_write (iof *O, size_t *plength, size_t *poffset, int flush)
-{
-  size_t bytes;
-  if ((bytes = iof_size(O)) > 0)
-  {
-    iof_file_sync(O->iofile, poffset);
-    if (bytes != iof_file_write(O->buf, sizeof(uint8_t), bytes, O->iofile))
-    {
-      *plength += bytes;
-      iof_file_unsync(O->iofile, poffset);
-      return 0;
-    }
-  }
-  if (flush)
-    iof_file_flush(O->iofile);
-  *plength += bytes;
-  O->end = O->buf + O->space; // remains intact
-  O->pos = O->buf;
-  return O->space;
-}
-
-static size_t filter_file_stream_writer (iof *O, iof_mode mode)
-{
-  stream_state *state;
-  state = iof_filter_state(stream_state *, O);
-  switch (mode)
-  {
-    case IOFWRITE:
-      return file_stream_write(O, &state->length, 0);
-    case IOFFLUSH:
-      return file_stream_write(O, &state->length, 1);
-    case IOFCLOSE:
-      file_stream_write(O, &state->length, 1);
-      iof_free(O);
-      return 0;
-    default:
-      return 0;
-  }
-}
-
-static size_t filter_iofile_stream_writer (iof *O, iof_mode mode)
-{
-  stream_state *state;
-  state = iof_filter_state(stream_state *, O);
-  switch (mode)
-  {
-    case IOFWRITE:
-      return iofile_stream_write(O, &state->length, &state->offset, 0);
-    case IOFFLUSH:
-      return iofile_stream_write(O, &state->length, &state->offset, 1);
-    case IOFCLOSE:
-      iofile_stream_write(O, &state->length, &state->offset, 1);
-      iof_free(O);
-      return 0;
-    default:
-      return 0;
-  }
-}
-
-iof * iof_filter_stream_writer (FILE *file)
-{
-  iof *O;
-  stream_state *state;
-  O = iof_filter_writer(filter_file_stream_writer, sizeof(stream_state), &state);
-  iof_setup_file(O, file);
-  stream_state_init(state, 0, 0);
-  return O;
-}
-
-iof * iof_filter_stream_cowriter (iof_file *iofile, size_t offset)
-{
-  iof *O;
-  stream_state *state;
-  O = iof_filter_writer(filter_iofile_stream_writer, sizeof(stream_state), &state);
-  iof_setup_iofile(O, iofile);
-  stream_state_init(state, offset, 0);
-  return O;
-}
-
-/* very specific for images; get input from already created strem filter, exchange the filter but keep the buffer */
-
-FILE * iof_filter_file_reader_source (iof *I, size_t *poffset, size_t *plength)
-{
-  stream_state *sstate;
-  file_state *fstate;
-  if (I->more == filter_file_stream_reader) // I is the result of iof_filter_stream_reader()
-  {
-    sstate = iof_filter_state(stream_state *, I);
-    *poffset = sstate->offset;
-    *plength = sstate->length; // might be 0 but it is ok for file readers
-    return I->file;
-  }
-  if (I->more == filter_file_reader)
-  {
-    fstate = iof_filter_state(file_state *, I);
-    *poffset = fstate->offset;
-    *plength = fstate->length; // might be 0 but it is ok for file readers
-    return I->file;
-  }
-  return NULL;
-}
-
-iof_file * iof_filter_file_coreader_source (iof *I, size_t *poffset, size_t *plength)
-{
-  stream_state *sstate;
-  file_state *fstate;
-  if (I->more == filter_iofile_stream_reader) // I is the result of iof_filter_stream_coreader()
-  {
-    sstate = iof_filter_state(stream_state *, I);
-    *poffset = sstate->offset;
-    *plength = sstate->length;
-    return I->iofile;
-  }
-  if (I->more == filter_iofile_reader)
-  {
-    fstate = iof_filter_state(file_state *, I);
-    *poffset = fstate->offset;
-    *plength = fstate->length;
-    return I->iofile;
-  }
-  return NULL;
-}
-
-iof * iof_filter_reader_replacement (iof *P, iof_handler handler, size_t statesize, void **pstate)
-{ // called after iof_filter_file_reader_source(), no need to check if F is filter from iof heap and if has buffer from iof heap
-  iof *F;
-  F = iof_filter_reader_with_buffer(handler, statesize, pstate, P->buf, P->space);
-  F->flags |= IOF_BUFFER_HEAP;
-  //iof_reader_buffer(P, NULL, 0);
-  //P->flags &= ~IOF_BUFFER_HEAP;
-  iof_filter_free(P);
-  return F;
-}
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
--- texlive-bin.orig/texk/web2c/luatexdir/luapplib/util/utiliof.c-OK
+++ /dev/null
@@ -1,2938 +0,0 @@
-/* input/iutput stream */
-
-#include <stdlib.h>
-#include <string.h>
-#include <stdarg.h>
-
-#include "utilmem.h"
-#include "utillog.h"
-#include "utiliof.h"
-
-/* commons */
-
-void * iof_copy_data (const void *data, size_t size)
-{
-  return memcpy(util_malloc(size), data, size);
-}
-
-uint8_t * iof_copy_file_data (const char *filename, size_t *psize)
-{
-  FILE *file;
-  size_t size;
-  uint8_t *data;
-  if ((file = fopen(filename, "rb")) == NULL)
-    return NULL;
-  fseek(file, 0, SEEK_END);
-  size = (size_t)ftell(file);
-  data = (uint8_t *)util_malloc(size);
-  fseek(file, 0, SEEK_SET);
-  if ((*psize = fread(data, 1, size, file)) != size)
-  {
-    util_free(data);
-    data = NULL;
-  }
-  fclose(file);
-  return data;
-}
-
-uint8_t * iof_copy_file_handle_data (FILE *file, size_t *psize)
-{
-  size_t size;
-  uint8_t *data;
-  //long offset = ftell(file); // keep offset intact?
-  fseek(file, 0, SEEK_END);
-  size = (size_t)ftell(file);
-  data = (uint8_t *)util_malloc(size);
-  fseek(file, 0, SEEK_SET);
-  if ((*psize = fread(data, 1, size, file)) != size)
-  {
-    util_free(data);
-    data = NULL;
-  }
-  //fseek(file, offset, SEEK_SET)
-  return data;
-}
-
-FILE * iof_get_file (iof *F)
-{
-  if (F->flags & IOF_FILE)
-    return iof_file_get_file(F->iofile);
-  if (F->flags & IOF_FILE_HANDLE)
-    return F->file;
-  return NULL;
-}
-
-const char * iof_status_kind (iof_status status)
-{
-  switch (status)
-  {
-    case IOFEOF:
-      return "IOFEOF";
-    case IOFERR:
-      return "IOFERR";
-    case IOFEMPTY:
-      return "IOFEMPTY";
-    case IOFFULL:
-      return "IOFFULL";
-    default:
-      break;
-  }
-  return "(unknown)";
-}
-
-/* shared pseudofile */
-
-#define IOF_FILE_DEFAULTS 0
-
-iof_file * iof_file_new (FILE *file)
-{
-  iof_file *iofile = (iof_file *)util_malloc(sizeof(iof_file));
-  iof_file_set_fh(iofile, file);
-  iofile->offset = NULL;
-  iofile->size = 0;
-  iofile->name = NULL;
-  iofile->refcount = 0;
-  iofile->flags = IOF_FILE_DEFAULTS|IOF_ALLOC;
-  return iofile;
-}
-
-iof_file * iof_file_init (iof_file *iofile, FILE *file)
-{
-  iof_file_set_fh(iofile, file);
-  iofile->offset = NULL;
-  iofile->size = 0;
-  iofile->name = NULL;
-  iofile->refcount = 0;
-  iofile->flags = IOF_FILE_DEFAULTS;
-  return iofile;
-}
-
-iof_file * iof_file_rdata (const void *data, size_t size)
-{
-  iof_file *iofile = (iof_file *)util_malloc(sizeof(iof_file));
-  iofile->rbuf = iofile->rpos = (const uint8_t *)data;
-  iofile->rend = iofile->rbuf + size;
-  iofile->offset = NULL;
-  iofile->size = 0;
-  iofile->name = NULL;
-  iofile->refcount = 0;
-  iofile->flags = IOF_FILE_DEFAULTS|IOF_ALLOC|IOF_DATA;
-  return iofile;
-}
-
-iof_file * iof_file_rdata_init (iof_file *iofile, const void *data, size_t size)
-{
-  iofile->rbuf = iofile->rpos = (const uint8_t *)data;
-  iofile->rend = iofile->rbuf + size;
-  iofile->offset = NULL;
-  iofile->size = 0; // letse keep it consequently set to zero (only for user disposal)
-  iofile->name = NULL;
-  iofile->refcount = 0;
-  iofile->flags = IOF_FILE_DEFAULTS|IOF_DATA;
-  return iofile;
-}
-
-iof_file * iof_file_wdata (void *data, size_t size)
-{
-  return iof_file_rdata((const void *)data, size);
-}
-
-iof_file * iof_file_wdata_init (iof_file *iofile, void *data, size_t size)
-{
-  return iof_file_rdata_init(iofile, (const void *)data, size);
-}
-
-/* typical uses so far */
-
-iof_file * iof_file_reader_from_file_handle (iof_file *iofile, const char *filename, FILE *file, int preload, int closefile)
-{
-  uint8_t *data;
-  size_t size;
-
-  if (preload)
-  {
-    if ((data = iof_copy_file_handle_data(file, &size)) == NULL)
-    {
-      if (closefile)
-        fclose(file);
-      return NULL;
-    }
-    if (iofile == NULL)
-      iofile = iof_file_rdata(data, size);
-    else
-      iof_file_rdata_init(iofile, data, size);
-    iofile->flags |= IOF_BUFFER_ALLOC;
-    if (closefile)
-      fclose(file);
-  }
-  else
-  {
-    if (iofile == NULL)
-      iofile = iof_file_new(file);
-    else
-      iof_file_init(iofile, file);
-    if (closefile)
-      iofile->flags |= IOF_CLOSE_FILE;
-  }
-  if (filename != NULL)
-    iof_file_set_name(iofile, filename);
-  return iofile;
-}
-
-iof_file * iof_file_reader_from_file (iof_file *iofile, const char *filename, int preload)
-{
-  FILE *file;
-  if ((file = fopen(filename, "rb")) == NULL)
-    return NULL;
-  return iof_file_reader_from_file_handle(iofile, filename, file, preload, 1);
-}
-
-iof_file * iof_file_reader_from_data (iof_file *iofile, const void *data, size_t size, int preload, int freedata)
-{
-  void *newdata;
-  if (data == NULL)
-    return NULL;
-  if (preload)
-  {
-    newdata = iof_copy_data(data, size);
-    if (iofile == NULL)
-      iofile = iof_file_rdata(newdata, size);
-    else
-      iof_file_rdata_init(iofile, newdata, size);
-    iofile->flags |= IOF_BUFFER_ALLOC;
-    //if (freedata) // hardly makes sense...  we can't free const void *
-    //  util_free((void *)data);
-  }
-  else
-  {
-    if (iofile == NULL)
-      iofile = iof_file_rdata(data, size);
-    else
-      iof_file_rdata_init(iofile, data, size);
-    if (freedata)
-      iofile->flags |= IOF_BUFFER_ALLOC;
-  }
-  return iofile;
-}
-
-/*
-iof_file * iof_file_writer_from_file (iof_file *iofile, const char *filename)
-{
-  FILE *file;
-  if ((file = fopen(filename, "wb")) == NULL)
-    return NULL;
-  if (iofile == NULL)
-    iofile = iof_file_new(file);
-  else
-    iof_file_init(iofile, file);
-  iofile->flags |= IOF_CLOSE_FILE;
-  iof_file_set_name(iofile, filename);
-  return iofile;
-}
-*/
-
-/*
-Because of limited number of FILE* handles available, we may need to close contained handle
-between accessing it. In applications so far (fonts, images) we typically need the source
-to parse the file on creation and to rewrite or reload the data on dump. All iof_file api
-functions assume that iofile has FILE* opened. Reopening it on every access (ftell, fseek,
-read/write) makes no sense, as we would effectively loose control. If the caller invalidates
-iofile by closing and nulling its file handle, it is also responsible to reopen when necessary.
-*/
-
-int iof_file_close_input (iof_file *iofile)
-{
-  FILE *file;
-  if (iofile->flags & IOF_DATA)
-    return 0;
-  if ((file = iof_file_get_fh(iofile)) == NULL)
-    return 0;
-  fclose(file);
-  iof_file_set_fh(iofile, NULL);
-  iofile->flags &= ~IOF_RECLOSE_FILE;
-  iofile->flags |= IOF_REOPEN_FILE;
-  return 1;
-}
-
-int iof_file_reopen_input (iof_file *iofile)
-{ // returns true if iofile readable
-  FILE *file;
-  const char *filename;
-  if (iofile->flags & IOF_DATA)
-    return 1;
-  if ((file = iof_file_get_fh(iofile)) != NULL)
-    return 1; // if present, assumed readable
-  if ((filename = iofile->name) == NULL || (file = fopen(filename, "rb")) == NULL)
-    return 0;
-  iof_file_set_fh(iofile, file);
-  iofile->flags &= ~IOF_REOPEN_FILE;
-  iofile->flags |= IOF_RECLOSE_FILE;
-  return 1;
-}
-
-/* freeing iof_file */
-
-void iof_file_free (iof_file *iofile)
-{
-  FILE *file;
-  if (iofile->flags & IOF_DATA)
-  {
-    if (iofile->flags & IOF_BUFFER_ALLOC)
-    {
-      iofile->flags &= ~IOF_BUFFER_ALLOC;
-      if (iofile->buf != NULL)
-      {
-        util_free(iofile->buf);
-        iofile->buf = iofile->pos = iofile->end = NULL;
-      }
-    }
-  }
-  else if ((file = iof_file_get_fh(iofile)) != NULL)
-  {
-    if (iofile->flags & IOF_CLOSE_FILE)
-     	fclose(file);
-    iof_file_set_fh(iofile, NULL);
-  }
-  iof_file_set_name(iofile, NULL);
-  if (iofile->flags & IOF_ALLOC)
-    util_free(iofile);
-}
-
-/* set filename for reopen */
-
-void iof_file_set_name (iof_file *iofile, const char *name)
-{
-  if (iofile->name != NULL)
-    util_free(iofile->name);
-  if (name != NULL)
-    iofile->name = iof_copy_data(name, strlen(name) + 1);
-  else
-    iofile->name = NULL;
-}
-
-/* seek */
-
-int iof_file_seek (iof_file *iofile, long offset, int whence)
-{
-  if (iofile->flags & IOF_DATA)
-  {
-    switch (whence)
-    {
-      case SEEK_SET:
-        if (offset >= 0 && iofile->buf + offset <= iofile->end)
-        {
-          iofile->pos = iofile->buf + offset;
-          return 0;
-        }
-        return -1;
-      case SEEK_CUR:
-        if ((offset >= 0 && iofile->pos + offset <= iofile->end) || (offset < 0 && iofile->pos + offset >= iofile->buf))
-        {
-          iofile->pos += offset;
-          return 0;
-        }
-        return -1;
-      case SEEK_END:
-        if (offset <= 0 && iofile->end + offset >= iofile->buf)
-        {
-          iofile->pos = iofile->end + offset;
-          return 0;
-        }
-        return -1;
-    }
-    return -1;
-  }
-  return fseek(iof_file_get_fh(iofile), offset, whence);
-}
-
-/* */
-
-long iof_file_tell (iof_file *iofile)
-{
-  return (iofile->flags & IOF_DATA) ? (long)(iofile->pos - iofile->buf) : ftell(iof_file_get_fh(iofile));
-}
-
-size_t iof_file_size (iof_file *iofile)
-{ 
-  long pos, size;
-  FILE *file;
-  if (iofile->flags & IOF_DATA)
-    return (size_t)iof_space(iofile);
-  file = iof_file_get_fh(iofile);
-  pos = ftell(file);
-  fseek(file, 0, SEEK_END);
-  size = ftell(file);
-  fseek(file, pos, SEEK_SET);
-  return size;
-}
-
-int iof_file_eof (iof_file *iofile)
-{
-  if (iofile->flags & IOF_DATA)
-    return iofile->pos == iofile->end ? -1 : 0;
-  return feof(iof_file_get_fh(iofile));
-}
-
-int iof_file_flush (iof_file *iofile)
-{
-  if (iofile->flags & IOF_DATA)
-    return 0;
-  return fflush(iof_file_get_fh(iofile));
-}
-
-size_t iof_file_read (void *ptr, size_t size, size_t items, iof_file *iofile)
-{
-  if (iofile->flags & IOF_DATA)
-  {
-    size_t bytes = size * items;
-    if (bytes > (size_t)iof_left(iofile))
-      bytes = (size_t)iof_left(iofile);
-    memcpy(ptr, iofile->pos, bytes);
-    iofile->pos += bytes;
-    return bytes / size; // number of elements read
-  }
-  return fread(ptr, size, items, iof_file_get_fh(iofile));
-}
-
-static size_t iof_file_data_resizeto (iof_file *iofile, size_t space)
-{
-  uint8_t *newbuf;
-  size_t size;
-  size = iof_size(iofile);
-  if (iofile->flags & IOF_BUFFER_ALLOC)
-  {
-    newbuf = (uint8_t *)util_realloc(iofile->buf, space);
-  }
-  else
-  {
-    newbuf = (uint8_t *)util_malloc(space);
-    if (size > 0)
-      memcpy(newbuf, iofile->buf, size);
-    iofile->flags |= IOF_BUFFER_ALLOC;
-  }
-  iofile->buf = newbuf;
-  iofile->pos = newbuf + size;
-  iofile->end = newbuf + space;
-  return space - size;
-}
-
-#define iof_file_data_resize(iofile) iof_file_data_resizeto(iofile, iof_space(iofile) << 1)
-
-size_t iof_file_write (const void *ptr, size_t size, size_t items, iof_file *iofile)
-{
-  if (iofile->flags & IOF_DATA)
-  {
-    size_t space, sizesofar, bytes;
-    bytes = size * items;
-    if (bytes > (size_t)iof_left(iofile))
-    {      
-      if ((space = iof_space(iofile)) == 0) // allow iofile->buf/end initially NULL
-        space = BUFSIZ;
-      for (sizesofar = iof_size(iofile), space <<= 1; sizesofar + bytes > space; space <<= 1)
-        ;
-      if (iof_file_data_resizeto(iofile, space) == 0)
-        return 0;
-    }
-    memcpy(iofile->pos, ptr, bytes);
-    iofile->pos += bytes;
-    return bytes / size;
-  }
-  return fwrite(ptr, size, items, iof_file_get_fh(iofile));
-}
-
-size_t iof_file_ensure (iof_file *iofile, size_t bytes)
-{
-  if (iofile->flags & IOF_DATA)
-  {
-    size_t space, sizesofar, left;
-    left = (size_t)iof_left(iofile);
-    if (bytes > left)
-    {      
-      if ((space = iof_space(iofile)) == 0) // allow iofile->buf/end initially NULL
-        space = BUFSIZ;
-      for (sizesofar = iof_size(iofile), space <<= 1; sizesofar + bytes > space; space <<= 1);
-      return iof_file_data_resizeto(iofile, space);
-    }
-    return left;  
-  }
-  return 0;
-}
-
-int iof_file_getc (iof_file *iofile)
-{
-  if (iofile->flags & IOF_DATA)
-    return iofile->pos < iofile->end ? *iofile->pos++ : IOFEOF;
-  return fgetc(iof_file_get_fh(iofile));
-}
-
-int iof_file_putc (iof_file *iofile, int c)
-{
-  if (iofile->flags & IOF_DATA)
-  {
-    if (iofile->pos >= iofile->end)
-      if (iof_file_data_resize(iofile) == 0)
-        return IOFEOF;
-    *iofile->pos++ = (uint8_t)c;
-    return c;
-  }
-  return fputc(c, iof_file_get_fh(iofile));
-}
-
-static int iof_file_sync (iof_file *iofile, size_t *offset)
-{
-  if (iofile->offset != offset)
-  {
-    if (iofile->offset != NULL)
-      *iofile->offset = iof_file_tell(iofile);
-    iofile->offset = offset;
-    if (offset) // let offset be NULL
-      return iof_file_seek(iofile, (long)*offset, SEEK_SET);
-  }
-  return 0;
-}
-
-//#define iof_file_unsync(iofile, poffset) (void)((iofile)->offset == poffset && (((iofile)->offset = NULL), 0))
-#define iof_file_unsync(iofile, poffset) ((void)poffset, (iofile)->offset = NULL)
-
-/* iof seek */
-
-#define iof_reader_reset(I) ((I)->pos = (I)->end = (I)->buf)
-#define iof_reader_reseek_file(I, offset, whence) (fseek((I)->file, offset, whence) == 0 ? (iof_reader_reset(I), 0) : -1)
-#define iof_reader_reseek_iofile(I, offset, whence) (iof_file_seek((I)->iofile, offset, whence) == 0 ? (iof_reader_reset(I), 0) : -1)
-
-#define iof_writer_reset(O) ((O)->pos = (O)->buf)
-#define iof_writer_reseek_file(O, offset, whence) (iof_flush(O), (fseek((O)->file, offset, whence) == 0 ? (iof_writer_reset(O), 0) : -1))
-#define iof_writer_reseek_iofile(O, offset, whence) (iof_flush(O), (iof_file_seek((O)->iofile, offset, whence) == 0 ? (iof_writer_reset(O), 0) : -1))
-
-static int iof_reader_seek_data (iof *I, long offset, int whence)
-{
-  switch (whence)
-  {
-    case SEEK_SET:
-      if (offset >= 0 && I->buf + offset <= I->end)
-      {
-        I->pos = I->buf + offset;
-        return 0;
-      }
-      return -1;
-    case SEEK_CUR:
-      if ((offset >= 0 && I->pos + offset <= I->end) || (offset < 0 && I->pos + offset >= I->buf))
-      {
-        I->pos += offset;
-        return 0;
-      }
-      return -1;
-    case SEEK_END:
-      if (offset <= 0 && I->end + offset >= I->buf)
-      {
-        I->pos = I->end + offset;
-        return 0;
-      }
-      return -1;
-  }
-  return -1;
-}
-
-static int iof_reader_seek_iofile (iof *I, long offset, int whence)
-{
-  long fileoffset;
-  switch (whence)
-  {
-    case SEEK_SET:
-      fileoffset = iof_file_tell(I->iofile);
-      if (offset <= fileoffset && offset >= fileoffset - iof_space(I))
-      {
-        I->pos = I->end - (fileoffset - offset);
-        return 0;
-      }
-      return iof_reader_reseek_iofile(I, offset, SEEK_SET);
-    case SEEK_CUR:
-      if ((offset >= 0 && I->pos + offset <= I->end) || (offset < 0 && I->pos + offset >= I->buf))
-      {
-        I->pos += offset;
-        return 0;
-      }
-      return iof_reader_reseek_iofile(I, offset, SEEK_CUR);
-    case SEEK_END:
-      return iof_reader_reseek_iofile(I, offset, SEEK_END); // can we do better?
-  }
-  return -1;
-}
-
-static int iof_reader_seek_file (iof *I, long offset, int whence)
-{
-  long fileoffset;
-  switch (whence)
-  {
-    case SEEK_SET:
-      fileoffset = ftell(I->file);
-      if (offset <= fileoffset && offset >= fileoffset - iof_space(I))
-      {
-        I->pos = I->end - (fileoffset - offset);
-        return 0;
-      }
-      return iof_reader_reseek_file(I, offset, SEEK_SET);
-    case SEEK_CUR:
-      if ((offset >= 0 && I->pos + offset <= I->end) || (offset < 0 && I->pos + offset >= I->buf))
-      {
-        I->pos += offset;
-        return 0;
-      }
-      return iof_reader_reseek_file(I, offset, SEEK_CUR);
-    case SEEK_END:
-      return iof_reader_reseek_file(I, offset, SEEK_END); // can we do better?
-  }
-  return -1;
-}
-
-int iof_reader_seek (iof *I, long offset, int whence)
-{
-  I->flags &= ~IOF_STOPPED;
-  if (I->flags & IOF_FILE)
-    return iof_reader_seek_iofile(I, offset, whence);
-  if (I->flags & IOF_FILE_HANDLE)
-    return iof_reader_seek_file(I, offset, whence);
-  if (I->flags & IOF_DATA)
-    return iof_reader_seek_data(I, offset, whence);
-  return -1;
-}
-
-int iof_reader_reseek (iof *I, long offset, int whence)
-{
-  I->flags &= ~IOF_STOPPED;
-  if (I->flags & IOF_FILE)
-    return iof_reader_reseek_iofile(I, offset, whence);
-  if (I->flags & IOF_FILE_HANDLE)
-    return iof_reader_reseek_file(I, offset, whence);
-  if (I->flags & IOF_DATA)
-    return iof_reader_seek_data(I, offset, whence);
-  return -1;
-}
-
-static int iof_writer_seek_data (iof *O, long offset, int whence)
-{
-  /*
-  fseek() allows to seek after the end of file. Seeking does not increase the output file.
-  No byte is written before fwirte(). It seems to fill the gap with zeros. Until we really need that,
-  no seeking out of bounds for writers.
-  */
-  O->flags &= ~IOF_STOPPED;
-  return iof_reader_seek_data(O, offset, whence);
-}
-
-static int iof_writer_seek_iofile (iof *O, long offset, int whence)
-{
-  long fileoffset;
-  switch (whence)
-  {
-    case SEEK_SET:
-      fileoffset = iof_file_tell(O->iofile);
-      if (offset >= fileoffset && offset <= fileoffset + iof_space(O))
-      {
-        O->pos = O->buf + (offset - fileoffset);
-        return 0;
-      }
-      return iof_writer_reseek_iofile(O, offset, SEEK_SET);
-    case SEEK_CUR:
-      if ((offset >=0 && O->pos + offset <= O->end) || (offset < 0 && O->pos + offset >= O->buf))
-      {
-        O->pos += offset;
-        return 0;
-      }
-      return iof_writer_reseek_iofile(O, offset, SEEK_CUR);
-    case SEEK_END:
-      return iof_writer_reseek_iofile(O, offset, SEEK_END);
-  }
-  return -1;
-}
-
-static int iof_writer_seek_file (iof *O, long offset, int whence)
-{
-  long fileoffset;
-  switch (whence)
-  {
-    case SEEK_SET:
-      fileoffset = ftell(O->file);
-      if (offset >= fileoffset && offset <= fileoffset + iof_space(O))
-      {
-        O->pos = O->buf + (offset - fileoffset);
-        return 0;
-      }
-      return iof_writer_reseek_file(O, offset, SEEK_SET);
-    case SEEK_CUR:
-      if ((offset >=0 && O->pos + offset <= O->end) || (offset < 0 && O->pos + offset >= O->buf))
-      {
-        O->pos += offset;
-        return 0;
-      }
-      return iof_writer_reseek_file(O, offset, SEEK_CUR);
-    case SEEK_END:
-      return iof_writer_reseek_file(O, offset, SEEK_END);
-  }
-  return -1;
-}
-
-int iof_writer_seek (iof *I, long offset, int whence)
-{
-  I->flags &= ~IOF_STOPPED;
-  if (I->flags & IOF_FILE)
-    return iof_writer_seek_iofile(I, offset, whence);
-  if (I->flags & IOF_FILE_HANDLE)
-    return iof_writer_seek_file(I, offset, whence);
-  if (I->flags & IOF_DATA)
-    return iof_writer_seek_data(I, offset, whence);
-  return -1;
-}
-
-int iof_writer_reseek (iof *I, long offset, int whence)
-{
-  I->flags &= ~IOF_STOPPED;
-  if (I->flags & IOF_FILE)
-    return iof_writer_reseek_iofile(I, offset, whence);
-  if (I->flags & IOF_FILE_HANDLE)
-    return iof_writer_reseek_file(I, offset, whence);
-  if (I->flags & IOF_DATA)
-    return iof_writer_seek_data(I, offset, whence);
-  return -1;
-}
-
-int iof_seek (iof *F, long offset, int whence)
-{
-  return (F->flags & IOF_WRITER) ? iof_writer_seek(F, offset, whence) : iof_reader_seek(F, offset, whence);
-}
-
-int iof_reseek (iof *F, long offset, int whence)
-{
-  return (F->flags & IOF_WRITER) ? iof_writer_reseek(F, offset, whence) : iof_reader_reseek(F, offset, whence);
-}
-
-/* tell */
-
-long iof_reader_tell (iof *I)
-{
-  if (I->flags & IOF_FILE)
-    return iof_file_tell(I->iofile) - (long)iof_left(I);
-  if (I->flags & IOF_FILE_HANDLE)
-    return ftell(I->file) - (long)iof_left(I);
-  //if (I->flags & IOF_DATA)
-  return (long)iof_size(I);
-}
-
-long iof_writer_tell (iof *O)
-{
-  if (O->flags & IOF_FILE)
-    return iof_file_tell(O->iofile) + (long)iof_size(O);
-  if (O->flags & IOF_FILE_HANDLE)
-    return ftell(O->file) + (long)iof_size(O);
-  //if (I->flags & IOF_DATA)
-  return (long)iof_size(O);
-}
-
-long iof_tell (iof *I)
-{
-  return (I->flags & IOF_WRITER) ? iof_writer_tell(I) : iof_reader_tell(I);
-}
-
-size_t iof_fsize (iof *I)
-{
-  size_t pos, size;
-  if (I->flags & IOF_FILE)
-    return iof_file_size(I->iofile);
-  if (I->flags & IOF_FILE_HANDLE)
-  {
-    pos = (size_t)ftell(I->file);
-    fseek(I->file, 0, SEEK_END);
-    size = (size_t)ftell(I->file);
-    fseek(I->file, (long)pos, SEEK_SET);
-    return size;
-  }
-  //if (I->flags & IOF_DATA)
-  return (size_t)iof_space(I);
-}
-
-/* save reader tail */
-
-size_t iof_save_tail (iof *I)
-{
-  size_t size, left;
-  size = iof_size(I);
-  left = iof_left(I);
-  if (size >= left)
-    memcpy(I->buf, I->pos, left);
-  else
-    memmove(I->buf, I->pos, left);
-  return left;
-}
-
-size_t iof_input_save_tail (iof *I, size_t back)
-{
-  size_t size;
-  I->flags |= IOF_TAIL;
-  I->pos -= back;
-  size = iof_input(I);
-  I->pos += back;
-  I->flags &= ~IOF_TAIL;
-  return size; // + back - back
-}
-
-/* read from file */
-
-/* iof free*/
-
-static size_t file_read (iof *I);
-static size_t file_load (iof *I);
-
-static size_t file_reader (iof *I, iof_mode mode)
-{
-  switch (mode)
-  {
-    case IOFREAD:
-      return file_read(I);
-    case IOFLOAD:
-      return file_load(I);
-    case IOFCLOSE:
-      iof_free(I);
-      return 0;
-    default:
-      return 0;
-  }
-}
-
-iof * iof_setup_file_handle_reader (iof *I, void *buffer, size_t space, FILE *f)
-{
-  if (I == NULL)
-    iof_setup_reader(I, buffer, space);
-  else
-    iof_reader_buffer(I, buffer, space);
-  iof_setup_file(I, f);
-  I->more = file_reader;
-  return I;
-}
-
-iof * iof_setup_file_reader (iof *I, void *buffer, size_t space, const char *filename)
-{
-  FILE *f;
-  if ((f = fopen(filename, "rb")) == NULL)
-    return NULL;
-  if (I == NULL)
-    iof_setup_reader(I, buffer, space);
-  else
-    iof_reader_buffer(I, buffer, space);
-  iof_setup_file(I, f);
-  I->flags |= IOF_CLOSE_FILE;
-  I->more = file_reader;
-  return I;
-}
-
-/* write to file */
-
-static size_t file_write (iof *O, int flush);
-
-static size_t file_writer (iof *O, iof_mode mode)
-{
-  switch (mode)
-  {
-    case IOFWRITE:
-      return file_write(O, 0);
-    case IOFFLUSH:
-      return file_write(O, 1);
-    case IOFCLOSE:
-      file_write(O, 1);
-      iof_free(O);
-      return 0;
-    default:
-      return 0;
-  }
-}
-
-iof * iof_setup_file_handle_writer (iof *O, void *buffer, size_t space, FILE *f)
-{
-  if (O == NULL)
-    iof_setup_writer(O, buffer, space);
-  else
-    iof_writer_buffer(O, buffer, space);
-  iof_setup_file(O, f);
-  O->more = file_writer;
-  return O;
-}
-
-iof * iof_setup_file_writer (iof *O, void *buffer, size_t space, const char *filename)
-{
-  FILE *f;
-  if ((f = fopen(filename, "wb")) == NULL)
-    return NULL;
-  if (O == NULL)
-    iof_setup_writer(O, buffer, space);
-  else
-    iof_writer_buffer(O, buffer, space);
-  iof_setup_file(O, f);
-  O->flags |= IOF_CLOSE_FILE;
-  O->more = file_writer;
-  return O;
-}
-
-/* a dedicated handler for stdout/stderr */
-
-static size_t stdout_writer (iof *O, iof_mode mode)
-{
-  switch(mode)
-  {
-    case IOFWRITE:
-    {
-      fwrite(O->buf, sizeof(uint8_t), iof_size(O), stdout);
-      O->pos = O->buf;
-      return O->space;
-    }
-    case IOFCLOSE:
-    case IOFFLUSH:
-    {
-      fwrite(O->buf, sizeof(uint8_t), iof_size(O), stdout);
-      fflush(stdout);
-      O->pos = O->buf;
-      return 0;
-    }
-    default:
-      break;
-  }
-  return 0;
-}
-
-static size_t stderr_writer (iof *O, iof_mode mode)
-{
-  switch(mode)
-  {
-    case IOFWRITE:
-    {
-      fwrite(O->buf, sizeof(uint8_t), iof_size(O), stderr);
-      O->pos = O->buf;
-      return O->space;
-    }
-    case IOFCLOSE:
-    case IOFFLUSH:
-    {
-      fwrite(O->buf, sizeof(uint8_t), iof_size(O), stderr);
-      fflush(stderr);
-      O->pos = O->buf;
-      return 0;
-    }
-    default:
-      break;
-  }
-  return 0;
-}
-
-static uint8_t iof_stdout_buffer[BUFSIZ];
-iof iof_stdout = IOF_WRITER_STRUCT(stdout_writer, NULL, iof_stdout_buffer, BUFSIZ, 0);
-
-static uint8_t iof_stderr_buffer[BUFSIZ];
-iof iof_stderr = IOF_WRITER_STRUCT(stderr_writer, NULL, iof_stderr_buffer, BUFSIZ, 0);
-
-/* read from somewhere */
-
-iof * iof_reader (iof *I, void *link, iof_handler reader, const void *m, size_t bytes)
-{
-  I->space = 0;
-  I->link = link;
-  I->more = reader;
-  I->flags = 0;
-  I->refcount = 0;
-  if (m != NULL)
-  {
-    I->rbuf = I->rpos = (const uint8_t *)m;
-    I->rend = (const uint8_t *)m + bytes;
-    return I;
-  }
-  return NULL;
-}
-
-iof * iof_string_reader (iof *I, const void *s, size_t bytes)
-{
-  I->space = 0;
-  I->link = NULL;
-  I->more = NULL;
-  I->flags = 0; // iof_string() sets IOF_DATA
-  I->refcount = 0;
-  if (s != NULL)
-    return iof_string(I, s, bytes);
-  return NULL;
-}
-
-/* write somewhere */
-
-iof * iof_writer (iof *O, void *link, iof_handler writer, void *m, size_t bytes)
-{
-  O->space = 0;
-  O->link = link;
-  O->more = writer;
-  O->flags = 0;
-  O->refcount = 0;
-  if (m != NULL && bytes > 0)
-  {
-    O->buf = O->pos = (uint8_t *)m;
-    O->end = (uint8_t *)m + bytes;
-    return O;
-  }
-  // return iof_null(O);
-  return NULL;
-}
-
-/* write to growing bytes buffer */
-
-static size_t iof_mem_handler (iof *O, iof_mode mode)
-{
-  switch(mode)
-  {
-    case IOFWRITE:
-      return iof_resize_buffer(O);
-    case IOFCLOSE:
-      iof_free(O);
-      return 0;
-    default:
-      return 0;
-  }
-}
-
-iof * iof_setup_buffer (iof *O, void *buffer, size_t space)
-{
-  if (O == NULL)
-    iof_setup_writer(O, buffer, space);
-  else
-    iof_writer_buffer(O, buffer, space);
-  O->link = NULL;
-  O->flags |= IOF_DATA;
-  O->more = iof_mem_handler;
-  return O;
-}
-
-iof * iof_setup_buffermin (iof *O, void *buffer, size_t space, size_t min)
-{
-  if ((O = iof_setup_buffer(O, buffer, space)) != NULL && space < min) // just allocate min now to avoid further rewriting
-  {
-    O->buf = O->pos = (uint8_t *)util_malloc(min);
-    O->flags |= IOF_BUFFER_ALLOC;
-    O->end = O->buf + min;
-  }
-  return O;
-}
-
-iof * iof_buffer_create (size_t space)
-{
-  uint8_t *buffer;
-  iof *O;
-  space += sizeof(iof);
-  buffer = util_malloc(space);
-  if ((O = iof_setup_buffer(NULL, buffer, space)) != NULL)
-    O->flags |= IOF_ALLOC;
-  return O;
-}
-
-/* set/get */
-
-int iof_getc (iof *I)
-{
-  if (iof_readable(I))
-    return *I->pos++;
-  return IOFEOF;
-}
-
-int iof_putc (iof *O, int u)
-{
-  if (iof_writable(O))
-  {
-    iof_set(O, u);
-    return (uint8_t)u;
-  }
-  return IOFFULL;
-}
-
-size_t iof_skip (iof *I, size_t bytes)
-{
-  while (bytes)
-  {
-    if (iof_readable(I))
-      ++I->pos;
-    else
-      break;
-    --bytes;
-  }
-  return bytes;
-}
-
-/* from iof to iof */
-
-iof_status iof_pass (iof *I, iof *O)
-{
-  size_t leftin, leftout;
-  if ((leftin = iof_left(I)) == 0)
-    leftin = iof_input(I);
-  while (leftin)
-  {
-    if ((leftout = iof_left(O)) == 0)
-      if ((leftout = iof_output(O)) == 0)
-        return IOFFULL;
-    while (leftin > leftout)
-    {
-      memcpy(O->pos, I->pos, leftout);
-      I->pos += leftout;
-      O->pos = O->end; /* eq. += leftout */
-      leftin -= leftout;
-      if ((leftout = iof_output(O)) == 0)
-        return IOFFULL;
-    }
-    if (leftin)
-    {
-      memcpy(O->pos, I->pos, leftin);
-      I->pos = I->end; /* eq. += leftin */
-      O->pos += leftin;
-    }
-    leftin = iof_input(I);
-  }
-  return IOFEOF;
-}
-
-/* read n-bytes */
-
-size_t iof_read (iof *I, void *to, size_t size)
-{
-  size_t leftin, done = 0;
-  char *s = (char *)to;
-  
-  if ((leftin = iof_left(I)) == 0)
-    if ((leftin = iof_input(I)) == 0)
-      return done;
-  while (size > leftin)
-  {
-    memcpy(s, I->pos, leftin * sizeof(uint8_t));
-    size -= leftin;
-    done += leftin;
-    s += leftin;
-    I->pos = I->end;
-    if ((leftin = iof_input(I)) == 0)
-      return done;
-  }
-  if (size)
-  {
-    memcpy(s, I->pos, size * sizeof(uint8_t));
-    I->pos += size;
-    done += size;
-  }
-  return done;
-}
-
-/* rewrite FILE content (use fseek if needed) */
-
-size_t iof_write_file_handle (iof *O, FILE *file)
-{
-  size_t leftout, size, readout;
-  if ((leftout = iof_left(O)) == 0)
-    if ((leftout = iof_output(O)) == 0)
-      return 0;
-  size = 0;
-  do {
-    readout = fread(O->pos, 1, leftout, file);    
-    O->pos += readout;
-    size += readout;
-  } while(readout == leftout && (leftout = iof_output(O)) > 0);
-  return size;
-}
-
-size_t iof_write_file (iof *O, const char *filename)
-{
-  FILE *file;
-  size_t size;
-  if ((file = fopen(filename, "rb")) == NULL)
-    return 0;
-  size = iof_write_file_handle(O, file);
-  fclose(file);
-  return size;
-}
-
-size_t iof_write_iofile (iof *O, iof_file *iofile, int savepos)
-{
-  long offset;
-  size_t size;
-  FILE *file;
-  if (iofile->flags & IOF_DATA)
-    return iof_write(O, iofile->pos, (size_t)(iofile->end - iofile->pos));
-  file = iof_file_get_fh(iofile);
-  if (savepos)
-  {
-    offset = ftell(file);  
-    size = iof_write_file_handle(O, file);
-    fseek(file, offset, SEEK_SET);
-    return size;
-  }
-  return iof_write_file_handle(O, file);
-}
-
-/* write n-bytes */
-
-size_t iof_write (iof *O, const void *data, size_t size)
-{
-  size_t leftout, done = 0;
-  const char *s = (const char *)data;
-  if ((leftout = iof_left(O)) == 0)
-    if ((leftout = iof_output(O)) == 0)
-      return done;
-  while (size > leftout)
-  {
-    memcpy(O->pos, s, leftout * sizeof(uint8_t));
-    size -= leftout;
-    done += leftout;
-    s += leftout;
-    O->pos = O->end;
-    if ((leftout = iof_output(O)) == 0)
-      return done;
-  }
-  if (size)
-  {
-    memcpy(O->pos, s, size * sizeof(uint8_t));
-    O->pos += size;
-    done += size;
-  }
-  return done;
-}
-
-/* write '\0'-terminated string */
-
-iof_status iof_puts (iof *O, const void *data)
-{
-  const char *s = (const char *)data;
-  while (*s)
-  {
-    if (iof_writable(O))
-      iof_set(O, *s++);
-    else
-      return IOFFULL;
-  }
-  return IOFEOF; // ?
-}
-
-size_t iof_put_string (iof *O, const void *data)
-{
-  const char *p, *s = (const char *)data;
-  for (p = s; *p != '\0' && iof_writable(O); iof_set(O, *p++));
-  return p - s;
-}
-
-/* write byte n-times */
-
-/*
-iof_status iof_repc (iof *O, char c, size_t bytes)
-{
-  while (bytes)
-  {
-    if (iof_writable(O))
-      iof_set(O, c);
-    else
-      return IOFFULL;
-    --bytes;
-  }
-  return IOFEOF; // ?
-}
-*/
-
-size_t iof_repc (iof *O, char c, size_t bytes)
-{
-  size_t leftout, todo = bytes;
-  if ((leftout = iof_left(O)) == 0)
-    if ((leftout = iof_output(O)) == 0)
-      return 0;
-  while (bytes > leftout)
-  {
-    memset(O->pos, c, leftout);
-    bytes -= leftout;
-    O->pos = O->end;
-    if ((leftout = iof_output(O)) == 0)
-      return todo - bytes;
-  }
-  if (bytes)
-  {
-    memset(O->pos, c, bytes);
-    O->pos += bytes;
-  }
-  return todo;
-}
-
-/* putfs */
-
-#define IOF_FMT_SIZE 1024
-
-size_t iof_putfs (iof *O, const char *format, ...)
-{
-  static char buffer[IOF_FMT_SIZE];
-  va_list args;
-  va_start(args, format);
-  if (vsnprintf(buffer, IOF_FMT_SIZE, format, args) > 0)
-  {
-    va_end(args);
-    return iof_put_string(O, buffer);
-  }
-  else
-  {
-    va_end(args);
-    return iof_write(O, buffer, IOF_FMT_SIZE);
-  }
-}
-
-/* integer from iof; return 1 on success, 0 otherwise */
-
-int iof_get_int32 (iof *I, int32_t *number)
-{
-  int sign, c = iof_char(I);
-  iof_scan_sign(I, c, sign);
-  if (!base10_digit(c)) return 0;
-  iof_read_integer(I, c, *number);
-  if (sign) *number = -*number;
-  return 1;
-}
-
-int iof_get_intlw (iof *I, intlw_t *number)
-{
-  int sign, c = iof_char(I);
-  iof_scan_sign(I, c, sign);
-  if (!base10_digit(c)) return 0;
-  iof_read_integer(I, c, *number);
-  if (sign) *number = -*number;
-  return 1;
-}
-
-int iof_get_int64 (iof *I, int64_t *number)
-{
-  int sign, c = iof_char(I);
-  iof_scan_sign(I, c, sign);
-  if (!base10_digit(c)) return 0;
-  iof_read_integer(I, c, *number);
-  if (sign) *number = -*number;
-  return 1;
-}
-
-int iof_get_uint32 (iof *I, uint32_t *number)
-{
-  int c = iof_char(I);
-  if (!base10_digit(c)) return 0;
-  iof_read_integer(I, c, *number);
-  return 1;
-}
-
-int iof_get_uintlw (iof *I, uintlw_t *number)
-{
-  int c = iof_char(I);
-  if (!base10_digit(c)) return 0;
-  iof_read_integer(I, c, *number);
-  return 1;
-}
-
-int iof_get_uint64 (iof *I, uint64_t *number)
-{
-  int c = iof_char(I);
-  if (!base10_digit(c)) return 0;
-  iof_read_integer(I, c, *number);
-  return 1;
-}
-
-int iof_get_int32_radix (iof *I, int32_t *number, int radix)
-{
-  int sign, c = iof_char(I);
-  iof_scan_sign(I, c, sign);
-  if (!base10_digit(c)) return 0;
-  iof_read_radix(I, c, *number, radix);
-  if (sign) *number = -*number;
-  return 1;
-
-}
-
-int iof_get_intlw_radix (iof *I, intlw_t *number, int radix)
-{
-  int sign, c = iof_char(I);
-  iof_scan_sign(I, c, sign);
-  if (!base10_digit(c)) return 0;
-  iof_read_radix(I, c, *number, radix);
-  if (sign) *number = -*number;
-  return 1;
-}
-
-int iof_get_int64_radix (iof *I, int64_t *number, int radix)
-{
-  int sign, c = iof_char(I);
-  iof_scan_sign(I, c, sign);
-  if (!base10_digit(c)) return 0;
-  iof_read_radix(I, c, *number, radix);
-  if (sign) *number = -*number;
-  return 1;
-}
-
-int iof_get_uint32_radix (iof *I, uint32_t *number, int radix)
-{
-  int c = iof_char(I);
-  if (!base10_digit(c)) return 0;
-  iof_read_radix(I, c, *number, radix);
-  return 1;
-}
-
-int iof_get_uintlw_radix (iof *I, uintlw_t *number, int radix)
-{
-  int c = iof_char(I);
-  if (!base10_digit(c)) return 0;
-  iof_read_radix(I, c, *number, radix);
-  return 1;
-}
-
-int iof_get_uint64_radix (iof *I, uint64_t *number, int radix)
-{
-  int c = iof_char(I);
-  if (!base10_digit(c)) return 0;
-  iof_read_radix(I, c, *number, radix);
-  return 1;
-}
-
-/* get roman to uint16_t, cf. roman_to_uint16() from utilnumber.c*/
-
-/* todo: some trick in place of this macro horror? */
-
-#define roman1000(c) (c == 'M' || c == 'm')
-#define roman500(c)  (c == 'D' || c == 'd')
-#define roman100(c)  (c == 'C' || c == 'c')
-#define roman50(c)   (c == 'L' || c == 'l')
-#define roman10(c)   (c == 'X' || c == 'x')
-#define roman5(c)    (c == 'V' || c == 'v')
-#define roman1(c)    (c == 'I' || c == 'i')
-
-#define roman100s(I, c) \
-  (roman100(c) ? (100 + ((c = iof_next(I), roman100(c)) ? (100 + ((c = iof_next(I), roman100(c)) ? (c = iof_next(I), 100) : 0)) : 0)) : 0)
-#define roman10s(I, c) \
-  (roman10(c) ? (10 + ((c = iof_next(I), roman10(c)) ? (10 + ((c = iof_next(I), roman10(c)) ? (c = iof_next(I), 10) : 0)) : 0)) : 0)
-#define roman1s(I, c) \
-  (roman1(c) ? (1 + ((c = iof_next(I), roman1(c)) ? (1 + ((c = iof_next(I), roman1(c)) ? (c = iof_next(I), 1) : 0)) : 0)) : 0)
-
-int iof_get_roman (iof *I, uint16_t *number)
-{
-  int c;
-  /* M */
-  for (*number = 0, c = iof_char(I); roman1000(c); *number += 1000, c = iof_next(I));
-  /* D C */
-  if (roman500(c))
-  {
-    c = iof_next(I);
-    *number += 500 + roman100s(I, c);
-  }
-  else if (roman100(c))
-  {
-    c = iof_next(I);
-    if (roman1000(c))
-    {
-      c = iof_next(I);
-      *number += 900;
-    }
-    else if (roman500(c))
-    {
-      c = iof_next(I);
-      *number += 400;
-    }
-    else
-      *number += 100 + roman100s(I, c);
-  }
-  /* L X */
-  if (roman50(c))
-  {
-    c = iof_next(I);
-    *number += 50 + roman10s(I, c);
-  }
-  else if (roman10(c))
-  {
-    c = iof_next(I);
-    if (roman100(c))
-    {
-      c = iof_next(I);
-      *number += 90;
-    }
-    else if (roman50(c))
-    {
-      c = iof_next(I);
-      *number += 40;
-    }
-    else
-      *number += 10 + roman10s(I, c);
-  }
-  /* V I */
-  if (roman5(c))
-  {
-    c = iof_next(I);
-    *number += 5 + roman1s(I, c);
-  }
-  else if (roman1(c))
-  {
-    c = iof_next(I);
-    if (roman10(c))
-    {
-      c = iof_next(I);
-      *number += 9;
-    }
-    else if (roman5(c))
-    {
-      c = iof_next(I);
-      *number += 4;
-    }
-    else
-      *number += 1 + roman1s(I, c);
-  }
-  return 1;
-}
-
-/* double from iof; return 1 on success */
-
-int iof_get_double (iof *I, double *number) // cf. string_to_double()
-{
-  int sign, exponent10, c = iof_char(I);
-  iof_scan_sign(I, c, sign);
-  iof_scan_decimal(I, c, *number);
-  if (c == '.')
-  {
-    c = iof_next(I);
-    iof_scan_fraction(I, c, *number, exponent10);
-  }
-  else
-    exponent10 = 0;
-  if (c == 'e' || c == 'E')
-  {
-    c = iof_next(I);
-    iof_scan_exponent10(I, c, exponent10);
-  }
-  double_exp10(*number, exponent10);
-  if (sign) *number = -*number;
-  return 1;
-}
-
-int iof_get_float (iof *I, float *number) // cf. string_to_float() in utilnumber.c
-{
-  int sign, exponent10, c = iof_char(I);
-  iof_scan_sign(I, c, sign);
-  iof_scan_decimal(I, c, *number);
-  if (c == '.')
-  {
-    c = iof_next(I);
-    iof_scan_fraction(I, c, *number, exponent10);
-  }
-  else
-    exponent10 = 0;
-  if (c == 'e' || c == 'E')
-  {
-    c = iof_next(I);
-    iof_scan_exponent10(I, c, exponent10);
-  }
-  float_exp10(*number, exponent10);
-  if (sign) *number = -*number;
-  return 1;
-}
-
-int iof_conv_double (iof *I, double *number) // cf. convert_to_double() in utilnumber.c
-{
-  int sign, exponent10, c = iof_char(I);
-  iof_scan_sign(I, c, sign);
-  iof_scan_decimal(I, c, *number);
-  if (c == '.' || c == ',')
-  {
-    c = iof_next(I);
-    iof_scan_fraction(I, c, *number, exponent10);
-    if (exponent10 < 0)
-      double_negative_exp10(*number, exponent10);
-  }
-  if (sign) *number = -*number;
-  return 1;
-}
-
-int iof_conv_float (iof *I, float *number) // cf. convert_to_float()
-{
-  int sign, exponent10, c = iof_char(I);
-  iof_scan_sign(I, c, sign);
-  iof_scan_decimal(I, c, *number);
-  if (c == '.' || c == ',')
-  {
-    c = iof_next(I);
-    iof_scan_fraction(I, c, *number, exponent10);
-    if (exponent10 < 0)
-      float_negative_exp10(*number, exponent10);
-  }
-  if (sign) *number = -*number;
-  return 1;
-}
-
-/* integer to iof; return a number of written bytes */
-
-#define iof_copy_number_buffer(O, s, p) for (p = s; *p && iof_writable(O); iof_set(O, *p), ++p)
-
-size_t iof_put_int32 (iof *O, int32_t number)
-{
-  const char *s, *p;
-  s = int32_to_string(number);
-  iof_copy_number_buffer(O, s, p);
-  return p - s;
-}
-
-size_t iof_put_intlw (iof *O, intlw_t number)
-{
-  const char *s, *p;
-  s = intlw_to_string(number);
-  iof_copy_number_buffer(O, s, p);
-  return p - s;
-}
-
-size_t iof_put_int64 (iof *O, int64_t number)
-{
-  const char *s, *p;
-  s = int64_to_string(number);
-  iof_copy_number_buffer(O, s, p);
-  return p - s;
-}
-
-size_t iof_put_uint32 (iof *O, uint32_t number)
-{
-  const char *s, *p;
-  s = uint32_to_string(number);
-  iof_copy_number_buffer(O, s, p);
-  return p - s;
-}
-
-size_t iof_put_uintlw (iof *O, uintlw_t number)
-{
-  const char *s, *p;
-  s = uintlw_to_string(number);
-  iof_copy_number_buffer(O, s, p);
-  return p - s;
-}
-
-size_t iof_put_uint64 (iof *O, uint64_t number)
-{
-  const char *s, *p;
-  s = uint64_to_string(number);
-  iof_copy_number_buffer(O, s, p);
-  return p - s;
-}
-
-size_t iof_put_int32_radix (iof *O, int32_t number, int radix)
-{
-  const char *s, *p;
-  s = int32_to_radix(number, radix);
-  iof_copy_number_buffer(O, s, p);
-  return p - s;
-}
-
-size_t iof_put_intlw_radix (iof *O, intlw_t number, int radix)
-{
-  const char *s, *p;
-  s = intlw_to_radix(number, radix);
-  iof_copy_number_buffer(O, s, p);
-  return p - s;
-}
-
-size_t iof_put_int64_radix (iof *O, int64_t number, int radix)
-{
-  const char *s, *p;
-  s = int64_to_radix(number, radix);
-  iof_copy_number_buffer(O, s, p);
-  return p - s;
-}
-
-size_t iof_put_uint32_radix (iof *O, uint32_t number, int radix)
-{
-  const char *s, *p;
-  s = uint32_to_radix(number, radix);
-  iof_copy_number_buffer(O, s, p);
-  return p - s;
-}
-
-size_t iof_put_uintlw_radix (iof *O, uintlw_t number, int radix)
-{
-  const char *s, *p;
-  s = uintlw_to_radix(number, radix);
-  iof_copy_number_buffer(O, s, p);
-  return p - s;
-}
-
-size_t iof_put_uint64_radix (iof *O, uint64_t number, int radix)
-{
-  const char *s, *p;
-  s = uint64_to_radix(number, radix);
-  iof_copy_number_buffer(O, s, p);
-  return p - s;
-}
-
-/* roman numerals */
-
-size_t iof_put_roman_uc (iof *O, uint16_t number)
-{
-  const char *s, *p;
-  s = uint16_to_roman_uc(number);
-  iof_copy_number_buffer(O, s, p);
-  return p - s;
-}
-
-size_t iof_put_roman_lc (iof *O, uint16_t number)
-{
-  const char *s, *p;
-  s = uint16_to_roman_lc(number);
-  iof_copy_number_buffer(O, s, p);
-  return p - s;
-}
-
-/* double/float to iof; return the number of written bytes */
-
-size_t iof_put_double (iof *O, double number, int digits)
-{
-  const char *s, *p;
-  s = double_to_string(number, digits);
-  iof_copy_number_buffer(O, s, p);
-  return p - s;
-}
-
-size_t iof_put_float (iof *O, float number, int digits)
-{
-  const char *s, *p;
-  s = float_to_string(number, digits);
-  iof_copy_number_buffer(O, s, p);
-  return p - s;
-}
-
-/* iof to binary integer; pretty common */
-
-int iof_get_be_uint2 (iof *I, uint32_t *pnumber)
-{
-  int c1, c2;
-  if ((c1 = iof_get(I)) < 0 || (c2 = iof_get(I)) < 0)
-    return 0;
-  *pnumber = (c1<<8)|c2;
-  return 1;
-}
-
-int iof_get_be_uint3 (iof *I, uint32_t *pnumber)
-{
-  int c1, c2, c3;
-  if ((c1 = iof_get(I)) < 0 || (c2 = iof_get(I)) < 0 || (c3 = iof_get(I)) < 0)
-    return 0;
-  *pnumber = (c1<<16)|(c2<<8)|c3;
-  return 1;
-}
-
-int iof_get_be_uint4 (iof *I, uint32_t *pnumber)
-{
-  int c1, c2, c3, c4;
-  if ((c1 = iof_get(I)) < 0 || (c2 = iof_get(I)) < 0 || (c3 = iof_get(I)) < 0 || (c4 = iof_get(I)) < 0)
-    return 0;
-  *pnumber = (c1<<24)|(c2<<16)|(c3<<8)|c4;
-  return 1;
-}
-
-int iof_get_le_uint2 (iof *I, uint32_t *pnumber)
-{
-  int c1, c2;
-  if ((c1 = iof_get(I)) < 0 || (c2 = iof_get(I)) < 0)
-    return 0;
-  *pnumber = (c2<<8)|c1;
-  return 1;
-}
-
-int iof_get_le_uint3 (iof *I, uint32_t *pnumber)
-{
-  int c1, c2, c3;
-  if ((c1 = iof_get(I)) < 0 || (c2 = iof_get(I)) < 0 || (c3 = iof_get(I)) < 0)
-    return 0;
-  *pnumber = (c3<<16)|(c2<<8)|c1;
-  return 1;
-}
-
-int iof_get_le_uint4 (iof *I, uint32_t *pnumber)
-{
-  int c1, c2, c3, c4;
-  if ((c1 = iof_get(I)) < 0 || (c2 = iof_get(I)) < 0 || (c3 = iof_get(I)) < 0 || (c4 = iof_get(I)) < 0)
-    return 0;
-  *pnumber = (c4<<24)|(c3<<16)|(c2<<8)|c1;
-  return 1;
-}
-
-/* iof input data */
-
-uint8_t * iof_file_input_data (iof_file *iofile, size_t *psize, int *isnew)
-{
-  uint8_t *data;
-  if (iofile->flags & IOF_DATA)
-  {
-    data = iofile->buf;
-    *psize = iofile->end - iofile->buf;
-    *isnew = 0;
-    return data;
-  }
-  if (iof_file_reopen(iofile))
-  {
-    data = iof_copy_file_handle_data(iof_file_get_fh(iofile), psize);
-    *isnew = 1;
-    iof_file_reclose(iofile);
-    return data;
-  }
-  return NULL;
-}
-
-/*
-uint8_t * iof_file_reader_data (iof_file *iofile, size_t *size)
-{
-  uint8_t *data;
-  if (!(iofile->flags & IOF_DATA) || iofile->pos == NULL || (*size = (size_t)iof_left(iofile)) == 0)
-    return NULL;  
-  if (iofile->flags & IOF_BUFFER_ALLOC)
-  {
-    data = iofile->buf; // iofile->pos; // returned must be freeable, makes sense when ->buf == ->pos
-    iofile->flags &= ~IOF_BUFFER_ALLOC;
-    iofile->buf = iofile->pos = iofile->end = NULL;
-    return data;
-  }
-  data = (uint8_t *)util_malloc(*size);
-  memcpy(data, iofile->buf, *size);
-  return data;
-}
-
-uint8_t * iof_file_writer_data (iof_file *iofile, size_t *size)
-{
-  uint8_t *data;
-  if (!(iofile->flags & IOF_DATA) || iofile->buf == NULL || (*size = (size_t)iof_size(iofile)) == 0)
-    return NULL;  
-  if (iofile->flags & IOF_BUFFER_ALLOC)
-  {
-    iofile->flags &= ~IOF_BUFFER_ALLOC;
-    data = iofile->buf;
-    iofile->buf = iofile->pos = iofile->end = NULL;
-    return data;
-  }
-  data = (uint8_t *)util_malloc(*size);
-  memcpy(data, iofile->buf, *size);
-  return data;
-}
-*/
-
-uint8_t * iof_reader_data (iof *I, size_t *psize)
-{
-  uint8_t *data;
-  *psize = (size_t)iof_left(I);
-  if (I->flags & IOF_BUFFER_ALLOC)
-  {
-    data = I->buf; // actually I->pos, but we have to return something freeable
-    I->flags &= ~IOF_BUFFER_ALLOC;
-    I->buf = NULL;
-  }
-  else
-  {
-    data = util_malloc(*psize);
-    memcpy(data, I->pos, *psize);
-  }
-  iof_close(I);
-  return data;
-}
-
-
-uint8_t * iof_writer_data (iof *O, size_t *psize)
-{
-  uint8_t *data;
-  *psize = (size_t)iof_size(O);
-  if (O->flags & IOF_BUFFER_ALLOC)
-  {
-    data = O->buf;
-    O->flags &= ~IOF_BUFFER_ALLOC;
-    O->buf = NULL;
-  }
-  else
-  {
-    data = util_malloc(*psize);
-    memcpy(data, O->buf, *psize);
-  }
-  iof_close(O);
-  return data;
-}
-
-size_t iof_reader_to_file_handle (iof *I, FILE *file)
-{
-  size_t size;
-  for (size = 0; iof_readable(I); I->pos = I->end)
-    size += fwrite(I->buf, sizeof(uint8_t), iof_left(I), file);
-  return size;
-}
-
-size_t iof_reader_to_file (iof *I, const char *filename)
-{
-  FILE *file;
-  size_t size;
-  if ((file = fopen(filename, "wb")) == NULL)
-    return 0;
-  for (size = 0; iof_readable(I); I->pos = I->end)
-    size += fwrite(I->buf, sizeof(uint8_t), iof_left(I), file);
-  fclose(file);
-  return size;
-}
-
-/* debug */
-
-size_t iof_data_to_file (const void *data, size_t size, const char *filename)
-{
-  FILE *fh;
-  if ((fh = fopen(filename, "wb")) == NULL)
-    return 0;
-  // size = fwrite(data, size, sizeof(uint8_t), fh); // WRONG, this always returns 1, as fwrite returns the number of elements successfully written out
-  size = fwrite(data, sizeof(uint8_t), size, fh);
-  fclose(fh);
-  return size;
-}
-
-size_t iof_result_to_file_handle (iof *F, FILE *file)
-{
-  const void *data;
-  size_t size;
-  data = iof_result(F, size);
-	return iof_data_to_file_handle(data, size, file);
-}
-
-size_t iof_result_to_file (iof *F, const char *filename)
-{
-  const void *data;
-  size_t size;
-  data = iof_result(F, size);
-  return iof_data_to_file(data, size, filename);
-}
-
-void iof_debug (iof *I, const char *filename)
-{
-  FILE *file = fopen(filename, "wb");
-  if (file != NULL)
-  {
-    fprintf(file, ">>> buf %p <<<\n", I->buf);
-    fwrite(I->buf, sizeof(uint8_t), iof_size(I), file);
-    fprintf(file, "\n>>> pos %p (%ld) <<<\n", I->pos, (long)iof_size(I));
-    fwrite(I->pos, sizeof(uint8_t), iof_left(I), file);
-    fprintf(file, "\n>>> end %p (%ld) <<<\n", I->end, (long)iof_left(I));
-    fwrite(I->end, sizeof(uint8_t), I->space - iof_space(I), file);
-    fprintf(file, "\n>>> end of buffer %p (%ld) <<<\n", I->buf + I->space, (long)(I->buf + I->space - I->end));
-    fclose(file);
-  }
-}
-
-/* common filters api */
-
-/* sizes of filter states on x64
-size of iof_filter: 640 (no longer used; sizeof(iof) + sizeof larger state)
-size of file_state: 16
-size of stream_state: 16
-size of flate_state: 104
-size of lzw_state: 56
-size of predictor_state: 104
-size of basexx_state: 48
-size of basexx_state: 48
-size of basexx_state: 48
-size of eexec_state: 40
-size of runlength_state: 24
-size of rc4_state: 24
-size of aes_state: 72
-size of img_state: 576
-size of img: 496
-*/
-
-typedef struct iof_heap iof_heap;
-
-struct iof_heap {
-  uint8_t *data, *pos;
-  size_t size, space;
-  iof_heap *next, *prev;
-  int refcount;
-};
-
-typedef struct {
-  iof_heap *heap;
-} iof_heap_ghost;
-
-static iof_heap * iof_buffers_heap = NULL;
-static iof_heap * iof_filters_heap = NULL;
-
-#define IOF_HEAP_FILTERS_COUNT 4
-#define IOF_BUFFER_SIZE 262144 // (1<<18)
-#define IOF_FILTER_SIZE 1024
-// sizeof(iof_filter) on x64 is now 640, img_state 576, img 496, others 16-104
-#define IOF_BUFFER_HEAP_SIZE (IOF_HEAP_FILTERS_COUNT * (IOF_BUFFER_SIZE + sizeof(iof_heap_ghost)))
-#define IOF_FILTER_HEAP_SIZE (IOF_HEAP_FILTERS_COUNT * (IOF_FILTER_SIZE + sizeof(iof_heap_ghost)))
-
-static iof_heap * iof_heap_new (size_t space)
-{
-  iof_heap *iofheap;
-  iofheap = (iof_heap *)util_malloc(sizeof(iof_heap) + space);
-  iofheap->data = iofheap->pos = (uint8_t *)(iofheap + 1);
-  iofheap->size = iofheap->space = space;
-  iofheap->next = NULL;
-  iofheap->prev = NULL;
-  iofheap->refcount = 0;
-  return iofheap;
-}
-
-#define iof_heap_free(iofheap) util_free(iofheap)
-
-void iof_filters_init (void)
-{
-  if (iof_buffers_heap == NULL)
-    iof_buffers_heap = iof_heap_new(IOF_BUFFER_HEAP_SIZE);
-  if (iof_filters_heap == NULL)
-    iof_filters_heap = iof_heap_new(IOF_FILTER_HEAP_SIZE);
-}
-
-void iof_filters_free (void)
-{
-  iof_heap *heap, *next;
-  for (heap = iof_buffers_heap; heap != NULL; heap = next)
-  {
-    next = heap->next;
-    if (heap->refcount != 0)
-      loggerf("not closed iof filters left (%d)", heap->refcount);
-    if (next != NULL)
-      loggerf("iof filters heap left");
-    iof_heap_free(heap);
-  }
-  iof_buffers_heap = NULL;
-  for (heap = iof_filters_heap; heap != NULL; heap = next)
-  {
-    next = heap->next;
-    if (heap->refcount != 0)
-      loggerf("not closed iof buffers left (%d)", heap->refcount);
-    if (next != NULL)
-      loggerf("iof buffers heap left");
-    iof_heap_free(heap);
-  }
-  iof_filters_heap = NULL;
-}
-
-#define iof_heap_get(hp, ghost, data, siz) \
- (ghost = (iof_heap_ghost *)((hp)->pos), \
-  ghost->heap = hp, \
-  data = (uint8_t *)(ghost + 1), \
-  (hp)->pos += siz, \
-  (hp)->size -= siz, \
-  ++(hp)->refcount)
-
-
-static void * iof_heap_take (iof_heap **pheap, size_t size)
-{
-  uint8_t *data;
-  iof_heap_ghost *ghost;
-  iof_heap *heap, *newheap, *next;
-
-  heap = *pheap;
-  size += sizeof(iof_heap_ghost);
-  if (heap->size >= size)
-  { /* take cheap mem from main heap */
-    iof_heap_get(heap, ghost, data, size);
-    return data;
-  }
-  if (size <= heap->space >> 1)
-  { /* make new cheap heap, make it front */
-    *pheap = newheap = iof_heap_new(heap->space);
-    newheap->next = heap;
-    heap->prev = newheap;
-    iof_heap_get(newheap, ghost, data, size);
-    return data;
-  }
-  /* size much larger than expected? should not happen.
-     make a single-item heap, keep the front heap intact. */
-  newheap = iof_heap_new(size);
-  if ((next = heap->next) != NULL)
-  {
-    newheap->next = next;
-    next->prev = newheap;
-  }
-  heap->next = newheap;
-  newheap->prev = heap;
-  iof_heap_get(newheap, ghost, data, size);
-  return data;
-}
-
-void iof_heap_back (void *data)
-{
-  iof_heap_ghost *ghost;
-  iof_heap *heap, *next, *prev;
-
-  ghost = ((iof_heap_ghost *)data) - 1;
-  heap = ghost->heap;
-  if (heap->refcount == 0)
-    loggerf("invalid use of iof heap, refcount < 0");
-  if (--heap->refcount <= 0)
-  {
-    if ((prev = heap->prev) != NULL)
-    { /* free the heap */
-      if ((next = heap->next) != NULL)
-        prev->next = next, next->prev = prev;
-      else
-        prev->next = NULL;
-      iof_heap_free(heap);
-    }
-    else
-    { /* this is the front heap, just reset */
-      heap->pos = heap->data;
-      heap->size = heap->space;
-    }
-  }
-}
-
-void * iof_filter_new (size_t size)
-{ // to be removed
-  void *data;
-
-  iof_filters_init();
-  data = iof_heap_take(&iof_filters_heap, size);
-  return memset(data, 0, size);
-}
-
-static uint8_t * iof_filter_buffer_new (size_t *psize)
-{
-  iof_filters_init();
-  *psize = IOF_BUFFER_SIZE;
-  return iof_heap_take(&iof_buffers_heap, IOF_BUFFER_SIZE);
-}
-
-iof * iof_filter_reader_new (iof_handler handler, size_t statesize, void **pstate)
-{
-  iof *F;
-  void *filter;
-  uint8_t *buffer;
-  size_t buffersize;
-
-  iof_filters_init();
-  filter = iof_heap_take(&iof_filters_heap, sizeof(iof) + statesize);
-  F = (iof *)memset(filter, 0, sizeof(iof) + statesize);
-  buffer = iof_filter_buffer_new(&buffersize);
-  iof_reader_buffer(F, buffer, buffersize);
-  F->flags |= IOF_HEAP|IOF_BUFFER_HEAP;
-  F->more = handler;
-  *pstate = (F + 1);
-  return F;
-}
-
-iof * iof_filter_reader_with_buffer_new (iof_handler handler, size_t statesize, void **pstate, void *buffer, size_t buffersize)
-{ // for filters that has own buffer (string, some image filters)
-  iof *F;
-  void *filter;
-  iof_filters_init();
-  filter = iof_heap_take(&iof_filters_heap, sizeof(iof) + statesize);
-  F = (iof *)memset(filter, 0, sizeof(iof) + statesize);
-  iof_reader_buffer(F, buffer, buffersize);
-  F->flags |= IOF_HEAP;
-  F->more = handler;
-  *pstate = (F + 1);
-  return F;
-}
-
-iof * iof_filter_writer_new (iof_handler handler, size_t statesize, void **pstate)
-{
-  iof *F;
-  void *filter;
-  uint8_t *buffer;
-  size_t buffersize;
-
-  iof_filters_init();
-  filter = iof_heap_take(&iof_filters_heap, sizeof(iof) + statesize);
-  F = (iof *)memset(filter, 0, sizeof(iof) + statesize);
-  buffer = iof_filter_buffer_new(&buffersize);
-  iof_writer_buffer(F, buffer, buffersize);
-  F->flags |= IOF_HEAP|IOF_BUFFER_HEAP;
-  F->more = handler;
-  *pstate = (F + 1);
-  return F;
-}
-
-iof * iof_filter_writer_with_buffer_new (iof_handler handler, size_t statesize, void **pstate, void *buffer, size_t size)
-{
-  iof *F;
-  void *filter;
-  size_t buffersize;
-
-  iof_filters_init();
-  filter = iof_heap_take(&iof_filters_heap, sizeof(iof) + statesize);
-  F = (iof *)memset(filter, 0, sizeof(iof) + statesize);
-  buffer = iof_filter_buffer_new(&buffersize);
-  iof_writer_buffer(F, buffer, buffersize);
-  F->flags |= IOF_HEAP;
-  F->more = handler;
-  *pstate = (F + 1);
-  return F;
-}
-
-/* close */
-
-#define iof_close_next(F) ((void)(iof_decref((F)->next), (F)->next = NULL, 0))
-/* when filter creation fails, we should take care to destroy the filter but leave ->next intact */
-#define iof_clear_next(F) ((void)(iof_unref((F)->next), (F)->next = NULL, 0))
-
-#define iof_close_buffer(F) ((void)\
-  ((F)->buf != NULL ? \
-      ((F->flags & IOF_BUFFER_ALLOC) ? (util_free((F)->buf), (F)->buf = NULL, 0) : \
-      ((F->flags & IOF_BUFFER_HEAP) ? (iof_filter_buffer_free((F)->buf), (F)->buf = NULL, 0) : ((F)->buf = NULL, 0))) : 0))
-
-/* closing underlying file handle */
-
-static void iof_close_file (iof *F)
-{
-  FILE *file;
-  //if (F->flags & IOF_FILE_HANDLE)
-  //{
-    if ((file = F->file) != NULL)
-    {
-      if (F->flags & IOF_CLOSE_FILE)
-        fclose(F->file);
-      F->file = NULL;
-    }
-  //}
-}
-
-/* a very special variant for reader filters initiated with iof_file_reopen(). It also calls
-   iof_file_reclose(), which takes an effect only if previously reopened, but better to keep
-   all this thin ice separated. Used in filters: iofile_reader, iofile_stream_reader, image
-   decoders. */
-
-static void iof_close_iofile (iof *F)
-{
-  iof_file *iofile;
-  //if (F->flags & IOF_FILE)
-  //{
-    if ((iofile = F->iofile) != NULL)
-    {
-      iof_file_unsync(iofile, NULL);
-      iof_file_reclose(iofile); // takes an effect iff prevoiusly reopened
-      iof_file_decref(iofile);
-      F->iofile = NULL;
-    }
-  //}
-}
-
-void iof_free (iof *F)
-{
-  if (F->flags & IOF_FILE_HANDLE)
-    iof_close_file(F);
-  else if (F->flags & IOF_FILE)
-    iof_close_iofile(F);
-  else if (F->flags & IOF_NEXT)
-    iof_close_next(F);
-  iof_close_buffer(F);
-  if (F->flags & IOF_HEAP)
-    iof_filter_free(F);
-  else if (F->flags & IOF_ALLOC)
-    util_free(F);
-}
-
-void iof_discard (iof *F)
-{ // so far used only on failed filters creation; as iof_free() but don't dare to release ->next
-  if (F->flags & IOF_FILE_HANDLE)
-    iof_close_file(F);
-  else if (F->flags & IOF_FILE)
-    iof_close_iofile(F);
-  else if (F->flags & IOF_NEXT)
-    iof_close_next(F);
-  iof_close_buffer(F);
-  if (F->flags & IOF_HEAP)
-    iof_filter_free(F);
-  else if (F->flags & IOF_ALLOC)
-    util_free(F);
-}
-
-/* resizing buffer */
-
-size_t iof_resize_buffer_to (iof *O, size_t space)
-{
-  uint8_t *buf;
-
-  if (O->flags & IOF_BUFFER_ALLOC)
-  {
-    buf = (uint8_t *)util_realloc(O->buf, space);
-  }
-  else
-  {
-    buf = (uint8_t *)util_malloc(space);
-    memcpy(buf, O->buf, iof_size(O));
-    if (O->flags & IOF_BUFFER_HEAP)
-    {
-      iof_filter_buffer_free(O->buf);
-      O->flags &= ~IOF_BUFFER_HEAP;
-    }
-    O->flags |= IOF_BUFFER_ALLOC;
-
-  }
-  O->pos = buf + iof_size(O);
-  O->end = buf + space;
-  O->buf = buf;
-  O->space = space;
-  return iof_left(O);
-}
-
-/* */
-
-size_t iof_decoder_retval (iof *I, const char *type, iof_status status)
-{
-  switch (status)
-  {
-    case IOFERR:
-    case IOFEMPTY:             // should never happen as we set state.flush = 1 on decoders init
-      loggerf("%s decoder error (%d, %s)", type, status, iof_status_kind(status));
-      I->flags |= IOF_STOPPED;
-      return 0;
-    case IOFEOF:               // this is the last chunk,
-      I->flags |= IOF_STOPPED; // so stop it and fall
-    case IOFFULL:              // prepare pointers to read from I->buf
-      I->end = I->pos;
-      I->pos = I->buf;
-      return I->end - I->buf;
-  }
-  loggerf("%s decoder bug, invalid retval %d", type, status);
-  return 0;
-}
-
-size_t iof_encoder_retval (iof *O, const char *type, iof_status status)
-{
-  switch (status)
-  {
-    case IOFERR:
-    case IOFFULL:
-      loggerf("%s encoder error (%d, %s)", type, status, iof_status_kind(status));
-      return 0;
-    case IOFEMPTY:
-      O->pos = O->buf;
-      O->end = O->buf + O->space;
-      return O->space;
-    case IOFEOF:
-      return 0;
-  }
-  loggerf("%s encoder bug, invalid retval %d", type, status);
-  return 0;
-}
-
-/* file/stream state */
-
-typedef struct {
-  size_t length;
-  size_t offset;
-} file_state;
-
-
-#define file_state_init(state, off, len) ((state)->offset = off, (state)->length = len)
-
-typedef struct {
-  size_t length;
-  size_t offset;
-} stream_state;
-
-#define stream_state_init(state, off, len) ((state)->offset = off, (state)->length = len)
-
-static size_t file_read (iof *I)
-{
-  size_t bytes, tail;
-  if (I->flags & IOF_STOPPED)
-    return 0;
-  tail = iof_tail(I);
-  if ((bytes = tail + fread(I->buf + tail, sizeof(uint8_t), I->space - tail, I->file)) < I->space)
-    I->flags |= IOF_STOPPED;
-  I->pos = I->buf;
-  I->end = I->buf + bytes;
-  return bytes;
-}
-
-static size_t iofile_read (iof *I, size_t *poffset)
-{
-  size_t bytes, tail;
-  if (I->flags & IOF_STOPPED)
-    return 0;
-  iof_file_sync(I->iofile, poffset);
-  tail = iof_tail(I);
-  if ((bytes = tail + iof_file_read(I->buf + tail, sizeof(uint8_t), I->space - tail, I->iofile)) < I->space)
-  {
-    I->flags |= IOF_STOPPED;
-    iof_file_unsync(I->iofile, poffset);
-  }
-  I->pos = I->buf;
-  I->end = I->buf + bytes;
-  return bytes;
-}
-
-static size_t file_load (iof *I)
-{
-  size_t bytes, left, tail;
-  if (I->flags & IOF_STOPPED)
-    return 0;
-  tail = iof_tail(I);
-  I->pos = I->buf + tail;
-  I->end = I->buf + I->space; /* don't assume its done when initializing the filter */
-  left = I->space - tail;
-  do {
-    bytes = fread(I->pos, sizeof(uint8_t), left, I->file);
-    I->pos += bytes;
-  } while (bytes == left && (left = iof_resize_buffer(I)) > 0);
-  I->flags |= IOF_STOPPED;
-  return iof_loaded(I);
-}
-
-static size_t iofile_load (iof *I, size_t *poffset)
-{
-  size_t bytes, left, tail;
-  if (I->flags & IOF_STOPPED)
-    return 0;
-  tail = iof_tail(I);
-  I->pos = I->buf + tail;
-  I->end = I->buf + I->space; /* don't assume its done when initializing the filter */
-  left = I->space - tail;
-  iof_file_sync(I->iofile, poffset);
-  do {
-    bytes = iof_file_read(I->pos, sizeof(uint8_t), left, I->iofile);
-    I->pos += bytes;
-  } while (bytes == left && (left = iof_resize_buffer(I)) > 0);
-  I->flags |= IOF_STOPPED;
-  iof_file_unsync(I->iofile, poffset);
-  return iof_loaded(I);
-}
-
-static size_t filter_file_reader (iof *I, iof_mode mode)
-{
-  switch (mode)
-  {
-    case IOFREAD:
-      return file_read(I);
-    case IOFLOAD:
-      return file_load(I);
-    case IOFCLOSE:
-      iof_free(I);
-      return 0;
-    default:
-      return 0;
-  }
-}
-
-static size_t filter_iofile_reader (iof *I, iof_mode mode)
-{
-  file_state *state;
-  state = iof_filter_state(file_state *, I);
-  switch (mode)
-  {
-    case IOFREAD:
-      return iofile_read(I, &state->offset);
-    case IOFLOAD:
-      return iofile_load(I, &state->offset);
-    case IOFCLOSE:
-      iof_free(I);
-      return 0;
-    default:
-      return 0;
-  }
-}
-
-static size_t file_write (iof *O, int flush)
-{
-  size_t bytes;
-  if ((bytes = iof_size(O)) > 0)
-    if (bytes != fwrite(O->buf, sizeof(uint8_t), bytes, O->file))
-      return 0;
-  if (flush)
-    fflush(O->file);
-  O->end = O->buf + O->space; // remains intact actually
-  O->pos = O->buf;
-  return O->space;
-}
-
-static size_t iofile_write (iof *O, size_t *poffset, int flush)
-{
-  size_t bytes;
-  iof_file_sync(O->iofile, poffset);
-  if ((bytes = iof_size(O)) > 0)
-  {
-    if (bytes != iof_file_write(O->buf, sizeof(uint8_t), bytes, O->iofile))
-    {
-      iof_file_unsync(O->iofile, poffset);
-      return 0;
-    }
-  }
-  if (flush)
-    iof_file_flush(O->iofile);
-  O->end = O->buf + O->space; // remains intact actually
-  O->pos = O->buf;
-  return O->space;
-}
-
-static size_t filter_file_writer (iof *O, iof_mode mode)
-{
-  switch (mode)
-  {
-    case IOFWRITE:
-      return file_write(O, 0);
-    case IOFFLUSH:
-      return file_write(O, 1);
-    case IOFCLOSE:
-      file_write(O, 1);
-      iof_free(O);
-      return 0;
-    default:
-      return 0;
-  }
-}
-
-static size_t filter_iofile_writer (iof *O, iof_mode mode)
-{
-  file_state *state;
-  state = iof_filter_state(file_state *, O);
-  switch (mode)
-  {
-    case IOFWRITE:
-      return iofile_write(O, &state->offset, 0);
-    case IOFFLUSH:
-      return iofile_write(O, &state->offset, 1);
-    case IOFCLOSE:
-      iofile_write(O, &state->offset, 1);
-      iof_free(O);
-      return 0;
-    default:
-      return 0;
-  }
-}
-
-/* filter from FILE* */
-
-iof * iof_filter_file_handle_reader (FILE *file)
-{
-  iof *I;
-  file_state *state;
-  if (file == NULL)
-    return NULL;
-  I = iof_filter_reader(filter_file_reader, sizeof(file_state), &state);
-  iof_setup_file(I, file);
-  file_state_init(state, 0, 0);
-  return I;
-}
-
-iof * iof_filter_file_handle_writer (FILE *file)
-{
-  iof *O;
-  file_state *state;
-  if (file == NULL)
-    return NULL;
-  O = iof_filter_writer(filter_file_writer, sizeof(file_state), &state);
-  iof_setup_file(O, file);
-  file_state_init(state, 0, 0);
-  return O;
-}
-
-/* filter from iof_file * */
-
-iof * iof_filter_iofile_reader (iof_file *iofile, size_t offset)
-{
-  iof *I;
-  file_state *state;
-  if (!iof_file_reopen(iofile))
-    return NULL;
-  I = iof_filter_reader(filter_iofile_reader, sizeof(file_state), &state);
-  iof_setup_iofile(I, iofile);
-  file_state_init(state, offset, 0);
-  return I;
-}
-
-iof * iof_filter_iofile_writer (iof_file *iofile, size_t offset)
-{
-  iof *O;
-  file_state *state;
-  O = iof_filter_writer(filter_iofile_writer, sizeof(file_state), &state);
-  iof_setup_iofile(O, iofile);
-  file_state_init(state, offset, 0);
-  return O;
-}
-
-/* filter from filename */
-
-iof * iof_filter_file_reader (const char *filename)
-{
-  iof *I;
-  file_state *state;
-  FILE *file;
-  if ((file = fopen(filename, "rb")) == NULL)
-    return NULL;
-  I = iof_filter_reader(filter_file_reader, sizeof(file_state), &state);
-  iof_setup_file(I, file);
-  file_state_init(state, 0, 0);
-  I->flags |= IOF_CLOSE_FILE;
-  return I;
-}
-
-iof * iof_filter_file_writer (const char *filename)
-{
-  iof *O;
-  file_state *state;
-  FILE *file;
-  if ((file = fopen(filename, "wb")) == NULL)
-    return NULL;
-  O = iof_filter_writer(filter_file_writer, sizeof(file_state), &state);
-  iof_setup_file(O, file);
-  file_state_init(state, 0, 0);
-  O->flags |= IOF_CLOSE_FILE;
-  return O;
-}
-
-/* from string */
-
-static size_t dummy_handler (iof *I, iof_mode mode)
-{
-  switch (mode)
-  {
-    case IOFCLOSE:
-      iof_free(I);
-      return 0;
-    default:
-      return 0;
-  }
-}
-
-iof * iof_filter_string_reader (const void *s, size_t length)
-{
-  iof *I;
-  void *dummy;
-  I = iof_filter_reader_with_buffer(dummy_handler, 0, &dummy, NULL, 0);
-  I->rbuf = I->rpos = (const uint8_t *)s;
-  I->rend = (const uint8_t *)s + length;
-  // I->space = length;
-  return I;
-}
-
-iof * iof_filter_string_writer (const void *s, size_t length)
-{
-  iof *O;
-  void *dummy;
-  O = iof_filter_reader_with_buffer(dummy_handler, 0, &dummy, NULL, 0);
-  O->rbuf = O->rpos = (const uint8_t *)s;
-  O->rend = (const uint8_t *)s + length;
-  // O->space = length;
-  return O;
-}
-
-iof * iof_filter_buffer_writer (size_t size)
-{ // filter alternative of iof_buffer_create()
-  iof *O;
-  void *dummy;
-  uint8_t *buffer;
-  if (size > IOF_BUFFER_SIZE)
-  {
-    buffer = (uint8_t *)util_malloc(size);
-    O = iof_filter_writer_with_buffer(iof_mem_handler, 0, &dummy, buffer, size);
-    O->flags |= IOF_BUFFER_ALLOC;
-    return O;
-  }
-	return iof_filter_writer(iof_mem_handler, 0, &dummy);
-}
-
-/* stream */
-
-static size_t file_stream_read (iof *I, size_t *plength)
-{
-  size_t bytes, tail;
-  if (I->flags & IOF_STOPPED || *plength == 0)
-    return 0;
-  tail = iof_tail(I);
-  if (I->space - tail >= *plength)
-  {
-    bytes = tail + fread(I->buf + tail, sizeof(uint8_t), *plength, I->file);
-    I->flags |= IOF_STOPPED;
-    *plength = 0;
-  }
-  else
-  {
-    bytes = tail + fread(I->buf + tail, sizeof(uint8_t), I->space - tail, I->file);
-    *plength -= bytes - tail;
-  }
-  I->pos = I->buf;
-  I->end = I->buf + bytes;
-  return bytes;
-}
-
-static size_t iofile_stream_read (iof *I, size_t *plength, size_t *poffset)
-{
-  size_t bytes, tail;
-  if (I->flags & IOF_STOPPED || *plength == 0)
-    return 0;
-  tail = iof_tail(I);
-  iof_file_sync(I->iofile, poffset);
-  if (I->space - tail >= *plength)
-  {
-    bytes = tail + iof_file_read(I->buf + tail, sizeof(uint8_t), *plength, I->iofile);
-    iof_file_unsync(I->iofile, poffset);
-    I->flags |= IOF_STOPPED;
-    *plength = 0;
-  }
-  else
-  {
-    bytes = tail + iof_file_read(I->buf + tail, sizeof(uint8_t), I->space - tail, I->iofile);
-    *plength -= bytes - tail;
-  }
-  I->pos = I->buf;
-  I->end = I->buf + bytes;
-  return bytes;
-}
-
-static size_t file_stream_load (iof *I, size_t *plength)
-{
-  size_t bytes, tail;
-  if (I->flags & IOF_STOPPED || *plength == 0)
-    return 0;
-  tail = iof_tail(I);
-  if (I->space - tail < *plength)
-    if (iof_resize_buffer_to(I, tail + *plength) == 0)
-      return 0;
-  bytes = tail + fread(I->buf + tail, sizeof(uint8_t), *plength, I->file);
-  I->flags |= IOF_STOPPED;
-  *plength = 0;
-  I->pos = I->buf;
-  I->end = I->buf + bytes;
-  return bytes;
-}
-
-static size_t iofile_stream_load (iof *I, size_t *plength, size_t *poffset)
-{
-  size_t bytes, tail;
-  if (I->flags & IOF_STOPPED || *plength == 0)
-    return 0;
-  iof_file_sync(I->iofile, poffset);
-  tail = iof_tail(I);
-  if (I->space - tail < *plength)
-    if (iof_resize_buffer_to(I, tail + *plength) == 0)
-      return 0;
-  bytes = tail + iof_file_read(I->buf + tail, sizeof(uint8_t), *plength, I->iofile);
-  iof_file_unsync(I->iofile, poffset);
-  I->flags |= IOF_STOPPED;
-  *plength = 0;
-  I->pos = I->buf;
-  I->end = I->buf + bytes;
-  return bytes;
-}
-
-static size_t filter_file_stream_reader (iof *I, iof_mode mode)
-{
-  stream_state *state;
-  state = iof_filter_state(stream_state *, I);
-  switch(mode)
-  {
-    case IOFREAD:
-      return file_stream_read(I, &state->length);
-    case IOFLOAD:
-      return file_stream_load(I, &state->length);
-    case IOFCLOSE:
-      iof_free(I);
-      return 0;
-    default:
-      return 0;
-  }
-}
-
-static size_t filter_iofile_stream_reader (iof *I, iof_mode mode)
-{
-  stream_state *state;
-  state = iof_filter_state(stream_state *, I);
-  switch(mode)
-  {
-    case IOFREAD:
-      return iofile_stream_read(I, &state->length, &state->offset);
-    case IOFLOAD:
-      return iofile_stream_load(I, &state->length, &state->offset);
-    case IOFCLOSE:
-      iof_free(I);
-      return 0;
-    default:
-      return 0;
-  }
-}
-
-iof * iof_filter_stream_reader (FILE *file, size_t offset, size_t length)
-{
-  iof *I;
-  stream_state *state;
-  I = iof_filter_reader(filter_file_stream_reader, sizeof(stream_state), &state);
-  iof_setup_file(I, file);
-  stream_state_init(state, offset, length);
-  fseek(file, (long)offset, SEEK_SET); // or perhaps it should be call in file_stream_read(), like iof_file_sync()?
-  return I;
-}
-
-iof * iof_filter_stream_coreader (iof_file *iofile, size_t offset, size_t length)
-{
-  iof *I;
-  stream_state *state;
-  if (!iof_file_reopen(iofile))
-    return NULL;
-  I = iof_filter_reader(filter_iofile_stream_reader, sizeof(stream_state), &state);
-  iof_setup_iofile(I, iofile);
-  stream_state_init(state, offset, length);
-  return I;
-}
-
-static size_t file_stream_write (iof *O, size_t *plength, int flush)
-{
-  size_t bytes;
-  if ((bytes = iof_size(O)) > 0)
-  {
-    if (bytes != fwrite(O->buf, sizeof(uint8_t), bytes, O->file))
-    {
-      *plength += bytes;
-      return 0;
-    }
-  }
-  if (flush)
-    fflush(O->file);
-  *plength += bytes;
-  O->end = O->buf + O->space; // remains intact
-  O->pos = O->buf;
-  return O->space;
-}
-
-static size_t iofile_stream_write (iof *O, size_t *plength, size_t *poffset, int flush)
-{
-  size_t bytes;
-  if ((bytes = iof_size(O)) > 0)
-  {
-    iof_file_sync(O->iofile, poffset);
-    if (bytes != iof_file_write(O->buf, sizeof(uint8_t), bytes, O->iofile))
-    {
-      *plength += bytes;
-      iof_file_unsync(O->iofile, poffset);
-      return 0;
-    }
-  }
-  if (flush)
-    iof_file_flush(O->iofile);
-  *plength += bytes;
-  O->end = O->buf + O->space; // remains intact
-  O->pos = O->buf;
-  return O->space;
-}
-
-static size_t filter_file_stream_writer (iof *O, iof_mode mode)
-{
-  stream_state *state;
-  state = iof_filter_state(stream_state *, O);
-  switch (mode)
-  {
-    case IOFWRITE:
-      return file_stream_write(O, &state->length, 0);
-    case IOFFLUSH:
-      return file_stream_write(O, &state->length, 1);
-    case IOFCLOSE:
-      file_stream_write(O, &state->length, 1);
-      iof_free(O);
-      return 0;
-    default:
-      return 0;
-  }
-}
-
-static size_t filter_iofile_stream_writer (iof *O, iof_mode mode)
-{
-  stream_state *state;
-  state = iof_filter_state(stream_state *, O);
-  switch (mode)
-  {
-    case IOFWRITE:
-      return iofile_stream_write(O, &state->length, &state->offset, 0);
-    case IOFFLUSH:
-      return iofile_stream_write(O, &state->length, &state->offset, 1);
-    case IOFCLOSE:
-      iofile_stream_write(O, &state->length, &state->offset, 1);
-      iof_free(O);
-      return 0;
-    default:
-      return 0;
-  }
-}
-
-iof * iof_filter_stream_writer (FILE *file)
-{
-  iof *O;
-  stream_state *state;
-  O = iof_filter_writer(filter_file_stream_writer, sizeof(stream_state), &state);
-  iof_setup_file(O, file);
-  stream_state_init(state, 0, 0);
-  return O;
-}
-
-iof * iof_filter_stream_cowriter (iof_file *iofile, size_t offset)
-{
-  iof *O;
-  stream_state *state;
-  O = iof_filter_writer(filter_iofile_stream_writer, sizeof(stream_state), &state);
-  iof_setup_iofile(O, iofile);
-  stream_state_init(state, offset, 0);
-  return O;
-}
-
-/* very specific for images; get input from already created strem filter, exchange the filter but keep the buffer */
-
-FILE * iof_filter_file_reader_source (iof *I, size_t *poffset, size_t *plength)
-{
-  stream_state *sstate;
-  file_state *fstate;
-  if (I->more == filter_file_stream_reader) // I is the result of iof_filter_stream_reader()
-  {
-    sstate = iof_filter_state(stream_state *, I);
-    *poffset = sstate->offset;
-    *plength = sstate->length; // might be 0 but it is ok for file readers
-    return I->file;
-  }
-  if (I->more == filter_file_reader)
-  {
-    fstate = iof_filter_state(file_state *, I);
-    *poffset = fstate->offset;
-    *plength = fstate->length; // might be 0 but it is ok for file readers
-    return I->file;
-  }
-  return NULL;
-}
-
-iof_file * iof_filter_file_coreader_source (iof *I, size_t *poffset, size_t *plength)
-{
-  stream_state *sstate;
-  file_state *fstate;
-  if (I->more == filter_iofile_stream_reader) // I is the result of iof_filter_stream_coreader()
-  {
-    sstate = iof_filter_state(stream_state *, I);
-    *poffset = sstate->offset;
-    *plength = sstate->length;
-    return I->iofile;
-  }
-  if (I->more == filter_iofile_reader)
-  {
-    fstate = iof_filter_state(file_state *, I);
-    *poffset = fstate->offset;
-    *plength = fstate->length;
-    return I->iofile;
-  }
-  return NULL;
-}
-
-iof * iof_filter_reader_replacement (iof *P, iof_handler handler, size_t statesize, void **pstate)
-{ // called after iof_filter_file_reader_source(), no need to check if F is filter from iof heap and if has buffer from iof heap
-  iof *F;
-  F = iof_filter_reader_with_buffer(handler, statesize, pstate, P->buf, P->space);
-  F->flags |= IOF_BUFFER_HEAP;
-  //iof_reader_buffer(P, NULL, 0);
-  //P->flags &= ~IOF_BUFFER_HEAP;
-  iof_filter_free(P);
-  return F;
-}
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
--- texlive-bin.orig/texk/web2c/luatexdir/luapplib/util/utiliof.h
+++ /dev/null
@@ -1,669 +0,0 @@
-
-#ifndef UTIL_IOF_H
-#define UTIL_IOF_H
-
-#include <stdio.h>  // for FILE *
-#include <errno.h>  // for errno
-#include <string.h> // for strerror()
-#include <stdint.h> // for uintN_t
-
-#include "utildecl.h"
-#include "utilnumber.h"
-
-/* handler call modes */
-
-typedef enum {
-  IOFREAD  = 0, /* read to buffer */
-  IOFLOAD  = 1, /* read all to buffer */
-  IOFWRITE = 2, /* write buffer to the output */
-  IOFFLUSH = 3, /* flush buffer to the output */
-  IOFCLOSE = 4  /* (flush and) close */
-} iof_mode;
-
-/* return statuses */
-
-typedef enum {
-  IOFEOF   = -1, /* end of input */
-  IOFEMPTY = -2, /* end of input buffer*/
-  IOFFULL  = -3, /* end of output buffer */
-  IOFERR   = -4  /* error */
-} iof_status;
-
-const char * iof_status_kind (iof_status status);
-
-/* iof_file */
-
-typedef struct iof_file {
-  union {
-    FILE *iofh; // access via iof_file_get_fh / iof_file_set_fh (below)
-    union {
-    	struct { uint8_t *buf, *pos, *end; };
-    	struct { const uint8_t *rbuf, *rpos, *rend; }; // to trick compiler warnings about cast discarding const
-    };
-  };
-  size_t *offset;
-  char *name;
-  size_t size;
-  int refcount;
-  int flags;
-} iof_file;
-
-/* iof handler function */
-
-typedef struct iof iof;
-typedef size_t (*iof_handler) (iof *I, iof_mode mode);
-
-/* iof structure */
-
-#define IOF_MEMBERS \
-  union { \
-    struct { uint8_t *buf, *pos, *end; }; \
-    struct { uint16_t *hbuf, *hpos, *hend; }; \
-    struct { uint32_t *ibuf, *ipos, *iend; }; \
-    struct { const uint8_t *rbuf, *rpos, *rend; }; \
-  }; \
-  size_t space; \
-  iof_handler more; \
-  union { iof *next; FILE *file; iof_file *iofile; void *link; }; \
-  int flags; \
-  int refcount
-
-/*
-  buf -- the beginning of buffer
-  pos -- the current position
-  end -- the end of buffer
-  space -- private space size, not always eq. (end - buf)
-  more -- handler function
-  next/file/iofile/link -- reader source or writer target
-  source -- source filter
-  flags -- private filter info
-  refcount -- refcount
-*/
-
-struct iof {
-  IOF_MEMBERS;
-};
-
-typedef void (*iof_dump_function) (const void *value, iof *O);
-
-/* flags */
-
-#define IOF_ALLOC          (1<<0) // iof is allocated
-#define IOF_HEAP           (1<<1) // iof taken from iof heap
-#define IOF_BUFFER_ALLOC   (1<<2) // buffer allocated
-#define IOF_BUFFER_HEAP    (1<<3) // buffer taken from iof heap
-
-#define IOF_SHORT          (1<<4) // buffer uses 16bit integers
-#define IOF_LONG           (1<<5) // buffer uses 32bit integers
-
-#define IOF_TAIL           (1<<6) // preserve reader tail
-#define IOF_READER         (1<<7) // is reader
-#define IOF_WRITER         (1<<8) // is writer
-
-#define IOF_DATA           (1<<9)  // binds some memory
-#define IOF_FILE_HANDLE    (1<<10) // links FILE *
-#define IOF_FILE           (1<<11) // links iof_file *
-#define IOF_NEXT           (1<<12) // links next iof *
-#define IOF_CLOSE_FILE     (1<<13) // close FILE * on free
-#define IOF_REOPEN_FILE    (1<<14) // close/reopen mode for iof_file
-#define IOF_RECLOSE_FILE   (1<<15) // ditto
-
-#define IOF_STOPPED        (1<<16) // stopped
-
-// #define IOF_CUSTOM         (1<<17) // first custom flag
-
-#define IOF_BUFSIZ (sizeof(iof) + BUFSIZ*sizeof(uint8_t))
-
-/*
-reading buffer -- all of buf, pos, end pointers are initialized to the beginning of the private buffer,
-  next call to a handler function moves the end pointer to bufer+space
-writer -- buf and pos pointers initialized to the beginning of the buffer, end initialized to bufer+space
-
-Every call to handler returns size_t number of bytes
-available (to write/read) or 0 if there is no more space.
-
-We usually align the data buffer just after the iof structure.
-This is convenient, especially when a memory for the structure
-and its buffer is to be allocated. In the case of growing output
-buffers we used to check if the memory of the buffer is allocated
-by the handler function using test (O->buf != (O+1)). We don't use
-it any longer not to rely on little secrets. Now there is an explicit
-IOF_BUFFER_ALLOC flag for that. IOF_ALLOC tells if the structure
-itself is taken from malloc (not used so far). Assuming the buffer size
-is way larger the sizeof(iof)
-*/
-
-/* initializers */
-
-#define IOF_READER_STRUCT(handler, file, buffer, size, flags) \
-  { {{ (uint8_t *)(buffer), (uint8_t *)(buffer), (uint8_t *)(buffer) }}, size, handler, { file }, flags|IOF_READER, 0 }
-
-#define IOF_WRITER_STRUCT(handler, file, buffer, size, flags) \
-  { {{ (uint8_t *)(buffer), (uint8_t *)(buffer), (uint8_t *)(buffer) + size }}, size, handler, { file }, flags|IOF_WRITER, 0 }
-
-#define IOF_STRING_STRUCT(buffer, size) \
-  { {{ (uint8_t *)(buffer), (uint8_t *)(buffer), (uint8_t *)(buffer) + size }}, size, NULL, { NULL }, 0|IOF_READER|IOF_DATA, 0 }
-
-#define IOF_STRING() IOF_STRING_STRUCT(0, 0)
-
-/* refcount */
-
-#define iof_incref(I) (++(I)->refcount)
-#define iof_decref(I) ((void)(--(I)->refcount <= 0 && iof_close(I)))
-#define iof_unref(I) (--(I)->refcount)
-
-/* setting up iof and buffer from mem buffer of a given size */
-
-#define iof_setup_reader(I, buffer, size) \
-  ((I) = (iof *)(buffer), iof_reader_buffer(I, (I)+1, size - sizeof(iof)))
-
-#define iof_setup_writer(O, buffer, size) \
-  ((O) = (iof *)buffer, iof_writer_buffer(O, (O)+1, size - sizeof(iof)))
-
-/* binding buffer of a given size */
-
-#define iof_reader_buffer(I, buffer, size) \
-  ((I)->buf = (I)->pos = (I)->end = (uint8_t *)(buffer), \
-   (I)->space = size, (I)->flags = 0|IOF_READER, (I)->refcount = 0)
-
-#define iof_writer_buffer(O, buffer, size) \
-  ((O)->buf = (O)->pos = (uint8_t *)(buffer), \
-   (O)->end = (uint8_t *)(buffer) + size, \
-   (O)->space = size, (O)->flags = 0|IOF_WRITER, (O)->refcount = 0)
-
-/* basics */
-
-#define iof_space(I) ((I)->end - (I)->buf)
-#define iof_left(I)  ((I)->end - (I)->pos)
-#define iof_size(I)  ((I)->pos - (I)->buf)
-
-#define iof_input(I)  ((I)->more ? (I)->more((I), IOFREAD) : 0lu)
-#define iof_load(I)   ((I)->more ? (I)->more((I), IOFLOAD) : 0lu)
-
-#define iof_output(O) ((O)->more ? (O)->more((O), IOFWRITE) : 0lu)
-//#define iof_flush(O)  ((O)->pos > (O)->buf && (O)->more ? (O)->more(O, IOFFLUSH) : 0lu)
-// flush should be unconditional, because encoders emits EOD markers only on flush
-#define iof_flush(O) ((O)->more ? (O)->more(O, IOFFLUSH) : 0lu)
-#define iof_close(O)  ((O)->more ? (O)->more(O, IOFCLOSE) : 0lu)
-
-#define iof_stop(F) ((void)(F->pos = F->end = F->buf, F->flags |= IOF_STOPPED))
-
-/*
-Rewriting reader tail to the beginning of new data portion; readers reacting on IOFREAD
-mode must be aware of some not yet read data, but treat it necessary only if IOF_TAIL flag is set.
-Parsers using iof input may protect not yet read data when there may be a need to put bytes
-back to the stream. This is trivial when I->pos > I->buf, as we can make a move by --I->pos.
-But when there is a need to put back more then one byte, we can protect the data tail, so that
-realoder will rewrite it to the beginning of new data chunk. 
-
-  iof_tail(I) - internal, used by iof handlers at IOFREAD mode
-  iof_protect_tail(I) - used by parsers to ensure some bytes chunk in one piece
-
-*/
-
-size_t iof_save_tail (iof *I);
-#define iof_tail(I) (((I)->flags & IOF_TAIL) && (I)->pos < (I)->end ? iof_save_tail(I) : 0)
-
-size_t iof_input_save_tail (iof *I, size_t back);
-#define iof_protect_tail(I, back, length) ((iof_left(I) >= (length) - (back)) ? 1 : (iof_input_save_tail(I, back) >= length - back))
-
-//uint8_t * iof_tail_data (iof *I, size_t *ptail);
-//#define iof_tail_free(data) util_free(data)
-
-/* panic */
-
-// #define iof_panic(mess) return 0
-#ifndef iof_panic
-  #define iof_panic(mess) (fputs(mess, stderr), abort())
-#endif
-//#define iof_memory_error() iof_panic(strerror(errno))
-#define iof_fwrite_error() iof_panic(strerror(errno))
-
-/* generic helpers */
-
-UTILAPI uint8_t * iof_copy_file_data (const char *filename, size_t *psize);
-UTILAPI uint8_t * iof_copy_file_handle_data (FILE *file, size_t *psize);
-
-/* In the future we may need releasing file handle and restoring it from iofile->name, so access file handle via macros */
-
-#define iof_file_get_fh(iofile) ((iofile)->iofh)
-#define iof_file_set_fh(iofile, fh) ((iofile)->iofh = fh)
-#define iof_file_get_file(iofile) (((iofile)->flags & IOF_DATA) ? NULL : iof_file_get_fh(iofile))
-FILE * iof_get_file (iof *F);
-
-/* basic iof_file interface */
-
-iof_file * iof_file_new (FILE *file);
-iof_file * iof_file_init (iof_file *iofile, FILE *file);
-
-iof_file * iof_file_rdata (const void *data, size_t size);
-iof_file * iof_file_wdata (void *data, size_t size);
-
-iof_file * iof_file_rdata_init (iof_file *iofile, const void *data, size_t size);
-iof_file * iof_file_wdata_init (iof_file *iofile, void *data, size_t size);
-
-iof_file * iof_file_reader_from_file_handle (iof_file *iofile, const char *filename, FILE *file, int preload, int closefile);
-iof_file * iof_file_reader_from_file (iof_file *iofile, const char *filename, int preload);
-iof_file * iof_file_reader_from_data (iof_file *iofile, const void *data, size_t size, int preload, int freedata);
-//iof_file * iof_file_writer_from_file (iof_file *iofile, const char *filename);
-
-void * iof_copy_data (const void *data, size_t size);
-#define iof_data_free(data) util_free(data)
-#define iof_file_wdata_copy(data, size) iof_file_wdata(iof_copy_data(data, size), size)
-#define iof_file_rdata_copy(data, size) iof_file_rdata(iof_copy_data(data, size), size)
-
-void iof_file_free (iof_file *iofile);
-
-#define iof_file_get_name(iofile) ((iofile)->name)
-void iof_file_set_name (iof_file *iofile, const char *name);
-
-#define iof_file_incref(iofile) (++(iofile)->refcount)
-#define iof_file_decref(iofile) ((void)(--(iofile)->refcount <= 0 && (iof_file_free(iofile), 0)))
-
-int iof_file_seek (iof_file *iofile, long offset, int whence);
-long iof_file_tell (iof_file *iofile);
-size_t iof_file_size (iof_file *iofile);
-int iof_file_eof (iof_file *iofile);
-
-size_t iof_file_read (void *ptr, size_t size, size_t items, iof_file *iofile);
-size_t iof_file_write (const void *ptr, size_t size, size_t items, iof_file *iofile);
-size_t iof_file_ensure (iof_file *iofile, size_t bytes);
-int iof_file_flush (iof_file *iofile);
-
-int iof_file_getc (iof_file *iofile);
-int iof_file_putc (iof_file *iofile, int c);
-
-int iof_file_close_input (iof_file *iofile);
-int iof_file_reopen_input (iof_file *iofile);
-
-#define iof_file_reopen(iofile) (((iofile)->flags & IOF_REOPEN_FILE) ? iof_file_reopen_input(iofile) : 1)
-#define iof_file_reclose(iofile) (void)(((iofile)->flags & IOF_RECLOSE_FILE) ? iof_file_close_input(iofile) : 0)
-
-/* wrappers of basic operations for iof */
-
-int iof_reader_seek (iof *I, long offset, int whence);
-int iof_reader_reseek (iof *I, long offset, int whence);
-int iof_writer_seek (iof *I, long offset, int whence);
-int iof_writer_reseek (iof *I, long offset, int whence);
-
-int iof_seek (iof *I, long offset, int whence);
-int iof_reseek (iof *I, long offset, int whence);
-
-long iof_reader_tell (iof *I);
-long iof_writer_tell (iof *I);
-long iof_tell (iof *I);
-size_t iof_fsize (iof *I);
-
-#define iof_setup_iofile(I, f) (iof_file_incref(f), (I)->iofile = f, (I)->flags |= IOF_FILE)
-#define iof_setup_file(I, fh) ((I)->file = fh, (I)->flags |= IOF_FILE_HANDLE)
-#define iof_setup_next(I, N) ((I)->next = N, iof_incref(N), (I)->flags |= IOF_NEXT)
-
-/* file handler reader and writer */
-
-UTILAPI iof * iof_setup_file_handle_reader (iof *I, void *buffer, size_t space, FILE *f);
-UTILAPI iof * iof_setup_file_handle_writer (iof *O, void *buffer, size_t space, FILE *f);
-
-#define iof_get_file_handle_reader(buffer, space, fh) iof_setup_file_handle_reader(NULL, buffer, space, fh)
-#define iof_get_file_handle_writer(buffer, space, fh) iof_setup_file_handle_writer(NULL, buffer, space, fh)
-
-/* file reader and writer */
-
-UTILAPI iof * iof_setup_file_reader (iof *I, void *buffer, size_t space, const char *filename);
-UTILAPI iof * iof_setup_file_writer (iof *O, void *buffer, size_t space, const char *filename);
-
-#define iof_get_file_reader(buffer, space, filename) iof_setup_file_reader(NULL, buffer, space, filename)
-#define iof_get_file_writer(buffer, space, filename) iof_setup_file_writer(NULL, buffer, space, filename)
-
-/* mem writer */
-
-UTILAPI iof * iof_setup_buffer (iof *O, void *buffer, size_t space);
-UTILAPI iof * iof_setup_buffermin (iof *O, void *buffer, size_t space, size_t min);
-
-#define iof_buffer(buffer, space) iof_setup_buffer(NULL, buffer, space)
-#define iof_buffermin(buffer, space, min) iof_setup_buffermin(NULL, buffer, space, min)
-
-UTILAPI iof * iof_buffer_create (size_t space);
-#define iof_buffer_new() iof_buffer_create(BUFSIZ)
-
-/* custom handler */
-
-UTILAPI iof * iof_reader (iof *I, void *link, iof_handler reader, const void *s, size_t bytes);
-UTILAPI iof * iof_writer (iof *O, void *link, iof_handler writer,       void *s, size_t bytes);
-
-/* stdout wrapper */
-
-extern UTILAPI iof iof_stdout;
-extern UTILAPI iof iof_stderr;
-
-/* simple string reader */
-
-UTILAPI iof * iof_string_reader (iof *I, const void *s, size_t bytes);
-
-#define iof_string(I, s, bytes) \
-  (((I)->rbuf = (I)->rpos = (const uint8_t *)s), ((I)->rend = (I)->rbuf + (bytes)), ((I)->flags |= IOF_DATA), (I))
-
-/* dummies */
-
-UTILAPI iof * iof_dummy (void *buffer, size_t space);
-UTILAPI iof * iof_null (void *buffer, size_t space);
-
-/* checking available space */
-
-#define iof_loadable(I) ((I)->pos < (I)->end || iof_load(I))
-#define iof_readable(I) ((I)->pos < (I)->end || iof_input(I))
-#define iof_writable(O) ((O)->pos < (O)->end || iof_output(O))
-
-#define iof_hloadable iof_loadable
-#define iof_iloadable iof_loadable
-
-#define iof_hreadable iof_readable
-#define iof_ireadable iof_readable
-
-#define iof_hwritable iof_writable
-#define iof_iwritable iof_writable
-
-/* ensure space to write several bytes (several means less then I->space) */
-
-#define iof_ensure(O, n) ((O)->pos+(n)-1 < (O)->end || iof_output(O)) // iof_ensure(O, 1) eq iof_writable(O)
-#define iof_hensure(O, n) ((O)->hpos+(n)-1 < (O)->hend || iof_output(O))
-#define iof_iensure(O, n) ((O)->ipos+(n)-1 < (O)->iend || iof_output(O))
-
-/* reading */
-
-UTILAPI int iof_getc (iof *I);
-UTILAPI int iof_hgetc (iof *I);
-UTILAPI int iof_igetc (iof *I);
-
-// UTILAPI int iof_cmp (iof *I, const char *s);
-// UTILAPI int iof_cmpn (iof *I, const char *s, size_t bytes);
-
-UTILAPI iof_status iof_pass (iof *I, iof *O);
-#define iof_hpass iof_pass
-#define iof_ipass iof_pass
-
-/* readers helpers */
-
-UTILAPI size_t iof_read (iof *I, void *s, size_t bytes);
-UTILAPI size_t iof_hread (iof *I, void *s, size_t bytes);
-UTILAPI size_t iof_iread (iof *I, void *s, size_t bytes);
-
-UTILAPI size_t iof_skip (iof *I, size_t bytes);
-UTILAPI size_t iof_hskip (iof *I, size_t bytes);
-UTILAPI size_t iof_iskip (iof *I, size_t bytes);
-
-/* get */
-
-#define iof_pos(I)  (*(I)->pos++)
-#define iof_hpos(I) (*(I)->hpos++)
-#define iof_ipos(I) (*(I)->ipos++)
-
-#define iof_get(I)  (iof_readable(I)  ? (int)(*(I)->pos++)  : IOFEOF)
-#define iof_hget(I) (iof_hreadable(I) ? (int)(*(I)->hpos++) : IOFEOF)
-#define iof_iget(I) (iof_ireadable(I) ? (int)(*(I)->ipos++) : IOFEOF)
-
-#define iof_char(I)  (iof_readable(I)  ? (int)(*(I)->pos) : IOFEOF)
-#define iof_hcurr(I) (iof_hreadable(I) ? (int)(*(I)->hpos) : IOFEOF)
-#define iof_icurr(I) (iof_ireadable(I) ? (int)(*(I)->ipos) : IOFEOF)
-
-#define iof_next(I)  (++(I)->pos, iof_char(I))
-#define iof_hnext(I) (++(I)->hpos, iof_hcurr(I))
-#define iof_inext(I) (++(I)->ipos, iof_icurr(I))
-
-/* unget */
-
-/*
-If possible, we just move the position backward. If it is not possible to
-move backward, we call iof_backup(I, c) that sets all pointers to the end of
-a private backup space, then moves buf AND pos pointers backward and set c at
-pos (==buf). We can backup characters as long as there is a private space. If
-several calls to iof_backup() are followed by iof_get(), pos pointer
-increases in normal way and so the use of another iof_unget() works just fine
-by moving the position. Once we swallow all backup characters (when
-pos==end), backup handler restores the previous pointers.
-
-Obviously we assume that the character provided to iof_unget() is always the
-character just obtained from iof_get(). We CAN'T just overwrite the character
-at a given position as the space we read may not be writable.
-
-When backup is in use, we can only get bytes until automatically restored.
-*/
-
-/* backup */
-
-/*
-#define iof_uses_backup(I) ((I)->more == iof_unget_handler)
-
-#define iof_save(I, B) \
-  ((B)->buf = (I)->buf, (B)->pos = (I)->pos, (B)->end = (I)->end, (B)->space = (I)->space, \
-   (B)->link = I->link, (B)->more = (I)->more, (B)->flags = (I)->flags)
-#define iof_restore(B, I) iof_save(I, B)
-
-#define iof_unget(I, c) \
-  ((void)(c == (uint8_t)c ? ((I)->pos > (I)->buf ? --(I)->pos : iof_backup(I, c)) : 0)
-int iof_backup (iof *I, int c);
-*/
-
-/* writing */
-
-UTILAPI size_t iof_write_file_handle (iof *O, FILE *file);
-UTILAPI size_t iof_write_file (iof *O, const char *filename);
-UTILAPI size_t iof_write_iofile (iof *O, iof_file *iofile, int savepos);
-
-UTILAPI int iof_putc (iof *O, int u);
-UTILAPI int iof_hputc (iof *O, int u);
-UTILAPI int iof_iputc (iof *O, int u);
-
-UTILAPI size_t iof_write (iof *O, const void *data, size_t size);
-UTILAPI size_t iof_hwrite (iof *O, const void *data, size_t size);
-UTILAPI size_t iof_iwrite (iof *O, const void *data, size_t size);
-
-UTILAPI iof_status iof_puts (iof *O, const void *data);
-UTILAPI size_t iof_put_string (iof *O, const void *data);
-UTILAPI size_t iof_putfs (iof *O, const char *format, ...);
-UTILAPI size_t iof_repc (iof *O, char c, size_t bytes);
-
-#define iof_putl(O, s) iof_write(O, "" s, sizeof(s)-1)
-//#define iof_putl iof_puts
-
-#define iof_set(O, c)               (*(O)->pos++ = (uint8_t)(c))
-#define iof_set2(O, c1, c2)         (iof_set(O, c1), iof_set(O, c2))
-#define iof_set3(O, c1, c2, c3)     (iof_set(O, c1), iof_set(O, c2), iof_set(O, c3))
-#define iof_set4(O, c1, c2, c3, c4) (iof_set(O, c1), iof_set(O, c2), iof_set(O, c3), iof_set(O, c4))
-#define iof_set5(O, c1, c2, c3, c4, c5) (iof_set(O, c1), iof_set(O, c2), iof_set(O, c3), iof_set(O, c4), iof_set(O, c5))
-
-#define iof_hset(O, c)              (*(O)->hpos++ = (uint16_t)(c))
-#define iof_iset(O, c)              (*(O)->ipos++ = (uint32_t)(c))
-
-#define iof_put(O, c)               ((void)iof_ensure(O, 1), iof_set(O, c))
-#define iof_put2(O, c1, c2)         ((void)iof_ensure(O, 2), iof_set2(O, c1, c2))
-#define iof_put3(O, c1, c2, c3)     ((void)iof_ensure(O, 3), iof_set3(O, c1, c2, c3))
-#define iof_put4(O, c1, c2, c3, c4) ((void)iof_ensure(O, 4), iof_set4(O, c1, c2, c3, c4))
-#define iof_put5(O, c1, c2, c3, c4, c5) ((void)iof_ensure(O, 5), iof_set5(O, c1, c2, c3, c4, c5))
-
-#define iof_hput(O, c)               ((void)iof_hensure(O, 1), iof_hset(O, c))
-#define iof_iput(O, c)               ((void)iof_iensure(O, 1), iof_iset(O, c))
-
-#define iof_put_uc_hex(O, c) iof_put2(O, base16_uc_digit1(c), base16_uc_digit2(c))
-#define iof_put_lc_hex(O, c) iof_put2(O, base16_lc_digit1(c), base16_lc_digit2(c))
-#define iof_set_uc_hex(O, c) iof_set2(O, base16_uc_digit1(c), base16_uc_digit2(c))
-#define iof_set_lc_hex(O, c) iof_set2(O, base16_lc_digit1(c), base16_lc_digit2(c))
-#define iof_put_hex iof_put_uc_hex
-#define iof_set_hex iof_set_uc_hex
-
-/* number from iof; return 1 on success, 0 otherwise */
-
-#define iof_scan_sign(I, c, sign) _scan_sign(c, sign, iof_next(I))
-#define iof_scan_integer(I, c, number) _scan_integer(c, number, iof_next(I))
-#define iof_scan_radix(I, c, number, radix) _scan_radix(c, number, radix, iof_next(I))
-#define iof_read_integer(I, c, number) _read_integer(c, number, iof_next(I))
-#define iof_read_radix(I, c, number, radix) _read_radix(c, number, radix, iof_next(I))
-
-#define iof_scan_decimal(I, c, number) _scan_decimal(c, number, iof_next(I))
-#define iof_scan_fraction(I, c, number, exponent10) _scan_fraction(c, number, exponent10, iof_next(I))
-#define iof_scan_exponent10(I, c, exponent10) _scan_exponent10(c, exponent10, iof_next(I))
-
-UTILAPI int iof_get_int32 (iof *I, int32_t *number);
-UTILAPI int iof_get_intlw (iof *I, intlw_t *number);
-UTILAPI int iof_get_int64 (iof *I, int64_t *number);
-
-UTILAPI int iof_get_uint32 (iof *I, uint32_t *number);
-UTILAPI int iof_get_uintlw (iof *I, uintlw_t *number);
-UTILAPI int iof_get_uint64 (iof *I, uint64_t *number);
-
-UTILAPI int iof_get_int32_radix (iof *I, int32_t *number, int radix);
-UTILAPI int iof_get_intlw_radix (iof *I, intlw_t *number, int radix);
-UTILAPI int iof_get_int64_radix (iof *I, int64_t *number, int radix);
-
-UTILAPI int iof_get_uint32_radix (iof *I, uint32_t *number, int radix);
-UTILAPI int iof_get_uintlw_radix (iof *I, uintlw_t *number, int radix);
-UTILAPI int iof_get_uint64_radix (iof *I, uint64_t *number, int radix);
-
-UTILAPI int iof_get_roman (iof *I, unsigned short int *number);
-
-UTILAPI int iof_get_double (iof *I, double *number);
-UTILAPI int iof_get_float (iof *I, float *number);
-
-UTILAPI int iof_conv_double (iof *I, double *number);
-UTILAPI int iof_conv_float (iof *I, float *number);
-
-/* number to iof; return a number of written bytes */
-
-UTILAPI size_t iof_put_int32 (iof *O, int32_t number);
-UTILAPI size_t iof_put_intlw (iof *O, intlw_t number);
-UTILAPI size_t iof_put_int64 (iof *O, int64_t number);
-
-UTILAPI size_t iof_put_uint32 (iof *O, uint32_t number);
-UTILAPI size_t iof_put_uintlw (iof *O, uintlw_t number);
-UTILAPI size_t iof_put_uint64 (iof *O, uint64_t number);
-
-UTILAPI size_t iof_put_int32_radix (iof *O, int32_t number, int radix);
-UTILAPI size_t iof_put_intlw_radix (iof *O, intlw_t number, int radix);
-UTILAPI size_t iof_put_int64_radix (iof *O, int64_t number, int radix);
-
-UTILAPI size_t iof_put_uint32_radix (iof *O, uint32_t number, int radix);
-UTILAPI size_t iof_put_uintlw_radix (iof *O, uintlw_t number, int radix);
-UTILAPI size_t iof_put_uint64_radix (iof *O, uint64_t number, int radix);
-
-UTILAPI size_t iof_put_roman_uc (iof *O, uint16_t number);
-UTILAPI size_t iof_put_roman_lc (iof *O, uint16_t number);
-#define iof_put_roman(I, number) iof_put_roman_uc(I, number)
-
-UTILAPI size_t iof_put_double(iof *O, double number, int digits);
-UTILAPI size_t iof_put_float(iof *O, float number, int digits);
-
-/* common stuff for binary integers */
-
-UTILAPI int iof_get_be_uint2 (iof *I, uint32_t *pnumber);
-UTILAPI int iof_get_be_uint3 (iof *I, uint32_t *pnumber);
-UTILAPI int iof_get_be_uint4 (iof *I, uint32_t *pnumber);
-
-UTILAPI int iof_get_le_uint2 (iof *I, uint32_t *pnumber);
-UTILAPI int iof_get_le_uint3 (iof *I, uint32_t *pnumber);
-UTILAPI int iof_get_le_uint4 (iof *I, uint32_t *pnumber);
-
-// iof_set() and iof_put() suite casts arguments to uint8_t, so we don't need &0xff mask
-
-#define iof_set_be_uint1(O, u) iof_set(O, u)
-#define iof_set_be_uint2(O, u) iof_set2(O, (u)>>8, u)
-#define iof_set_be_uint3(O, u) iof_set3(O, (u)>>16, (u)>>8, u)
-#define iof_set_be_uint4(O, u) iof_set4(O, (u)>>24, (u)>>16, (u)>>8, u)
-
-#define iof_set_le_uint1(O, u) iof_set(O, u)
-#define iof_set_le_uint2(O, u) iof_set2(O, u, (u)>>8)
-#define iof_set_le_uint3(O, u) iof_set3(O, u, (u)>>8, (u)>>16)
-#define iof_set_le_uint4(O, u) iof_set4(O, u, (u)>>8, (u)>>16, (u)>>24)
-
-#define iof_put_be_uint1(O, u) iof_put(O, u)
-#define iof_put_be_uint2(O, u) iof_put2(O, (u)>>8, u)
-#define iof_put_be_uint3(O, u) iof_put3(O, (u)>>16, (u)>>8, u)
-#define iof_put_be_uint4(O, u) iof_put4(O, (u)>>24, (u)>>16, (u)>>8, u)
-
-#define iof_put_le_uint1(O, u) iof_put(O, u)
-#define iof_put_le_uint2(O, u) iof_put2(O, u, (u)>>8)
-#define iof_put_le_uint3(O, u) iof_put3(O, u, (u)>>8, (u)>>16)
-#define iof_put_le_uint4(O, u) iof_put4(O, u, (u)>>8, (u)>>16, (u)>>24)
-
-/* buffer results */
-
-#define iof_reader_result(I, size) ((size = iof_left(I)), (I)->pos)
-#define iof_writer_result(I, size) ((size = iof_size(I)), (I)->buf)
-#define iof_result(I, size) (((I)->flags & IOF_READER) ? iof_reader_result(I, size) : iof_writer_result(I, size))
-
-uint8_t * iof_file_input_data (iof_file *iofile, size_t *psize, int *isnew);
-//uint8_t * iof_file_reader_data (iof_file *iofile, size_t *size);
-//uint8_t * iof_file_writer_data (iof_file *iofile, size_t *size);
-
-uint8_t * iof_reader_data (iof *I, size_t *psize);
-uint8_t * iof_writer_data (iof *O, size_t *psize);
-size_t iof_reader_to_file_handle (iof *I, FILE *file);
-size_t iof_reader_to_file (iof *I, const char *filename);
-
-#define iof_loaded(I) ((I)->end = (I)->pos, (I)->pos = (I)->buf, iof_left(I))
-
-#define iof_data_to_file_handle(data, size, file) fwrite(data, sizeof(uint8_t), size, file)
-UTILAPI size_t iof_data_to_file (const void *data, size_t size, const char *filename);
-
-UTILAPI size_t iof_result_to_file_handle (iof *F, FILE *file);
-UTILAPI size_t iof_result_to_file (iof *F, const char *filename);
-UTILAPI void iof_debug (iof *I, const char *filename);
-
-/* common filters allocator */
-
-void iof_filters_init (void);
-void iof_filters_free (void);
-
-void * iof_filter_new (size_t size);
-void iof_heap_back (void *data);
-#define iof_filter_free(F) iof_heap_back(F)
-#define iof_filter_buffer_free(data) iof_heap_back(data)
-
-// &((void *)pstate
-
-iof * iof_filter_reader_new (iof_handler handler, size_t statesize, void **pstate);
-#define iof_filter_reader(handler, statesize, pstate) iof_filter_reader_new(handler, statesize, (void **)(pstate))
-iof * iof_filter_reader_with_buffer_new (iof_handler handler, size_t statesize, void **pstate, void *buffer, size_t buffersize);
-#define iof_filter_reader_with_buffer(handler, statesize, pstate, buffer, buffersize) iof_filter_reader_with_buffer_new(handler, statesize, (void **)(pstate), buffer, buffersize)
-iof * iof_filter_writer_new (iof_handler handler, size_t statesize, void **pstate);
-#define iof_filter_writer(handler, statesize, pstate) iof_filter_writer_new(handler, statesize, (void **)(pstate))
-iof * iof_filter_writer_with_buffer_new (iof_handler handler, size_t statesize, void **pstate, void *buffer, size_t buffersize);
-#define iof_filter_writer_with_buffer(handler, statesize, pstate, buffer, buffersize) iof_filter_writer_with_buffer_new(handler, statesize, (void **)(pstate), buffer, buffersize)
-
-#define iof_filter_state(statetype, F) (statetype)((F) + 1)
-
-void iof_free (iof *F);
-void iof_discard (iof *F);
-
-size_t iof_resize_buffer_to (iof *O, size_t space);
-#define iof_resize_buffer(O) iof_resize_buffer_to(O, (O)->space << 1)
-
-size_t iof_decoder_retval (iof *I, const char *type, iof_status status);
-size_t iof_encoder_retval (iof *O, const char *type, iof_status status);
-
-/* filters */
-
-iof * iof_filter_file_handle_reader (FILE *file);
-iof * iof_filter_file_handle_writer (FILE *file);
-
-iof * iof_filter_iofile_reader (iof_file *iofile, size_t offset);
-iof * iof_filter_iofile_writer (iof_file *iofile, size_t offset);
-
-iof * iof_filter_file_reader (const char *filename);
-iof * iof_filter_file_writer (const char *filename);
-
-iof * iof_filter_string_reader (const void *s, size_t length);
-iof * iof_filter_string_writer (const void *s, size_t length);
-
-iof * iof_filter_buffer_writer (size_t size);
-
-iof * iof_filter_stream_reader (FILE *file, size_t offset, size_t length);
-iof * iof_filter_stream_coreader (iof_file *iofile, size_t offset, size_t length);
-
-iof * iof_filter_stream_writer (FILE *file);
-iof * iof_filter_stream_cowriter (iof_file *iofile, size_t offset);
-
-FILE * iof_filter_file_reader_source (iof *I, size_t *poffset, size_t *plength);
-iof_file * iof_filter_file_coreader_source (iof *I, size_t *poffset, size_t *plength);
-iof * iof_filter_reader_replacement (iof *P, iof_handler handler, size_t statesize, void **pstate);
-#define iof_filter_reader_replace(P, handler, statesize, pstate) iof_filter_reader_replacement(P, handler, statesize, (void **)(pstate))
-
-#endif
\ No newline at end of file
--- texlive-bin.orig/texk/web2c/luatexdir/luapplib/util/utillog.c
+++ /dev/null
@@ -1,60 +0,0 @@
-
-#include <stdio.h>
-#include <string.h> // strlen
-#include <stdarg.h>
-#include "utillog.h"
-
-#define LOGGER_BUFFER_SIZE 256
-#define LOGGER_PREFIX_SIZE 32
-
-typedef struct {
-  logger_function callback;
-  void *context;
-  size_t pfxlen;
-} logger_struct;
-
-static logger_struct logger = { 0, NULL, 0 };
-
-static char logger_buffer[LOGGER_BUFFER_SIZE+LOGGER_PREFIX_SIZE];
-
-void loggerf (const char *format, ...)
-{
-  va_list args;
-  int length;
-  
-  va_start(args, format);  
-  length = vsnprintf(logger_buffer + logger.pfxlen, LOGGER_BUFFER_SIZE, format, args);
-	if (length > 0)
-	{
-		if (length > LOGGER_BUFFER_SIZE)
-			length = LOGGER_BUFFER_SIZE;
-	}
-	else
-	{
-		loggerf("logger encoding error '%s'", format);
-		length = (int)strlen(logger_buffer);
-	}
-	length += (int)logger.pfxlen;
-	if (logger.callback)
-		logger.callback(logger_buffer, logger.context);
-  else
-		printf("\n%s\n", logger_buffer);
-	va_end(args);
-}
-
-void logger_callback (logger_function callback, void *context)
-{
-	logger.callback = callback;
-	logger.context = context;
-}
-
-int logger_prefix (const char *prefix)
-{
-	size_t pfxlen;
-	pfxlen = strlen(prefix);
-	if (pfxlen > LOGGER_PREFIX_SIZE)
-		return 0;
-	memcpy(logger_buffer, prefix, pfxlen);
-	logger.pfxlen = pfxlen;
-	return 1;
-}
--- texlive-bin.orig/texk/web2c/luatexdir/luapplib/util/utillog.h
+++ /dev/null
@@ -1,10 +0,0 @@
-
-#ifndef UTIL_LOG_H
-#define UTIL_LOG_H
-
-typedef void (*logger_function) (const char *message, void *alien);
-void loggerf (const char *format, ...);
-void logger_callback (logger_function callback, void *context);
-int logger_prefix (const char *prefix);
-
-#endif
\ No newline at end of file
--- texlive-bin.orig/texk/web2c/luatexdir/luapplib/util/utillzw.c
+++ /dev/null
@@ -1,701 +0,0 @@
-/* lzw implementation for postscript/pdf filters
-# Notes on LZW
-
-# Encoder
-
-Initially the table contains 256 entires for single bytes. Encoder consumes
-input bytes trying to find the longest sequence stored so far in the table.
-Once it finds a sequence that is not present in the table, it outputs the table
-index of the longest sequence found (accumulated bytes except the last
-consumed) and pushes the new sequence (accumulated bytes including the last
-one) on the top of the table. The last taken byte is not yet written to the
-output, it becomes the beginning of the new sequence to accumulate. Initially,
-encoder outputs 9-bit codes. While the table grows, the number of bits for each
-code increases up to 12. In example, after adding a table entry of index 511 it
-is high time to switch to 10-bit bytes. /EarlyChange=true parameter in stream
-dictionary (both postscript and pdf) informs to increase the number of bits one
-code earlier then necessary. Looks pretty much like an early days bug that
-became a specification :) I have never found a PDF having /EarlyChange key
-specified anyway.
-
-Once the table becomes full (or when encoder decides it is worthy),
-a clear-table marker (code 256) purges the table and restores codes length to
-9. End-of-data marker (code 257) ends the stream. Conventionally, the beginning
-of the stream starts with clear-table marker.
-
-Postscript allows to provide a /UnitLength which determines the bit length of
-codes. The above description assumes UnitLength=8 (default). Allowed values are
-from 3 to 8. Different UnitLength also affects markers; clear-table is then
-2^UnitLength and end-of-data marker is 2^UnitLenth+1.
-
-Encoder outputs 9-12bit codes that are packed into bytes using high-bits-first
-scheme (default) or low-bits-scheme.
-
-PDF spec p. 73 (PS spec p. 135 gives an mistaken output sequence and so
-mistaken output bytes)
-
-Input character sequence (decimal)
-45 45 45 45 45 65 45 45 45 66
-
-Output 9bit codes (decimal)
-256 45 258 258 65 259 66 257
-
-Output 9bit codes (binary)
-100000000 000101101 100000010 100000010 001000001 100000011 001000010 100000001
-
-Output bytes (LowBitsFirst=false); eight high-order bits of code becomes
-the first byte, remaining low-order bit of code becomes the high-order bit of the
-next byte;
-10000000 00001011 01100000 01010000 00100010 00001100 00001100 10000101 00000001
--> 80 0B 60 50 22 0C 0C 85 01
-
-Output bytes (binary, LowBitsFirst=true); eight low-order bits of code becomes
-the first byte, remaining high-order bit of code becomes low-order bit of the
-next byte;
-00000000 01011011 00001000 00010100 00011000 01100100 10100000 10000000 10010000
--> 00 5B 08 14 18 64 A0 80 90
-
-# Decoder
-
-Decoder consumes input bytes transforming them to 9 to 12 bit codes. Initially
-it starts with 9bit codes and the table of 258 fixed codes (same as encoder).
-Basically, it interprets incoming codes as table indices (except 256 and 257
-markers) and it outputs byte sequences stored at given indices. It also
-upbuilds the table and changes the number of bits of codes when necessary. The
-key point on lzw is that both encoder and decoder builds the table
-synchronously.
-
-However, decoder needs some "knowledge" about how encoder works to be able to
-interpret a table index that it doesn't have so far. Look that the output from
-encoder in the example above. The first output code is conventional clear-table
-(256). Then comes a code 45. So far so good, decoder interprets code 45 as
-a (fixed) entry of the table, emitting byte 45. The next code is 258, which is
-should be interpreted as an index in the table. Oops, encoder doesn't have one
-yet. If that occurs, it means that encoder was able to output the new entry
-code just after adding it to a table. It means that
-
-  sequence_before + next_byte == next_byte + sequence_after
-
-This may happen not only for sequences like 45 45 45, but also symmetric series
-such as abcbabcba; abcb + a == a + bcba. Decoder must be aware of that and if
-it gets a code one larger than the top table index, it should create one on-fly
-by appending last entry sequence by the first by of the last entry.
-
-# UnitLength
-
-Postscript specification mentions about UnitLength parameter that can be used
-in LZW decoder (not allowed in encoder), with possible values from 3 to 8. This
-parameter determines the number of bits per code; form UnitLength + 1 to 12. It
-also determines which codes are used for clear-table marker (2^UnitLength) and
-end-of-data marker ((2^UnitLength)+1). Postscript specification says (page 134):
-
-"Initially, the code length is (UnitLength + 1) bits and the table contains only
-entries for the (2^UnitLength + 2) fixed codes. As encoding proceeds, entries are
-appended to the table, associating new codes with longer and longer input character
-sequences. The encoding and decoding filters maintain identical copies of
-this table."
-
-Later on page 136 Postscript specification says:
-
-"Data that has been LZW-encoded with a UnitLength less than 8 consists only of
-codes in the range 0 to 2^UnitLength - 1; consequently, the LZWDecode filter produces
-only codes in that range when read. UnitLength also affects the encoded
-representation, as described above."
-
-UnitLength (Postscript only) and LowBitsFirst are used only by decoder.
-EarlyChange should obviously be respected by both encoder and decoder. When
-table index reaches current bit length boundary (511, 1023, ...) it must react
-by increasing the number of bits of input code. But if the index reaches it
-maximum value (when the table is full), decoder is NOT supposed to clear the
-table. When the table is full, encoder must emit clear-table marker and it
-emits this code using 12 bits and reinitialize code bits after that. It means
-that, when the table is full, decoder should get one more 12-bit code (which
-should be clear-table marker) and actually clear the table and reinitialize
-code bits after that.
-
-# Clear-table vs last entry track (after tries and checks)
-
-It is also not quite clear what should actually happen when encoder gets a full
-table and it is supposed to emit clear-table marker. When it gets full, it
-means that it has just appended another entry to the table. And that happens
-only the input sequence collected so far plus the last byte is not present in
-the table. Encoder is supposed to output the table index of the present
-sequence and set the recent byte as a starting index of the new sequence to be
-collected. Even if it is time to clear the table, encoder is still supposed to
-keep the track of the last table entry. Decoder, however, must drop the track of the
-last code on clear-table.
-
-# Decoder table vs encoder table
-
-While decoding we need query lzw table by (subsequent) numeric codes and output
-character sequences stored in the table. While encoding we need to query the
-table on every input byte and fetch indices pointing to character sequences.
-Note that we never need to query the entire table for the longest sequence
-found so far. The encoder table do not need to access the longest character
-sequence at one piece. It is enough to keep the track of the current table
-index and the very next byte. We organize an encoder table into a search tree,
-where every node contains its table index (value) and last byte (key). Except
-initial tree content, every node is created on the base of the previous node
-and it conceptually point the sequence represented by that nodo consists of the
-previous node sequence plus the next byte.
-
-Every new node is a descendant of the node it has been derived from. Every node
-has a map (a search subtree) indexed by suffix byte value, pointing to
-descendants nodes. Every node also has binary tentackles (left/right fields)
-necessary to search the map (except initials, every node lives in a map of some
-ancestor node). The key point is that on every input byte we don't search the
-entire tree, but only the map of the current node children. The map tree is
-a simple binary tree with no balancing mechanism (not worthy to optimize an
-ephemeric structure that may be upbuilt more often then queried).
-
-In our implementation, decoder table requires  4069 entries (topmost index 4095).
-Encoder table, however, needs 4097 entries to handle the case when EarlyIndex
-parameter is 0 (I have never a chance to test that in practise). The node of index
-4096 might be added to a search tree, but its code is never emitted; the lookup
-is purged just after adding that node.
-
-todo:
-- support for LowBitsFirst encoding
-*/
-
-#include "utilmem.h"
-#include "utillzw.h"
-
-/* filter state struct */
-
-typedef struct lzw_entry {
-  union {
-    const char *rdata; // to be able to init with string literal
-    char *data;
-  };
-  int size;
-} lzw_entry;
-
-#define lzw_index short
-
-typedef struct lzw_node lzw_node;
-
-struct lzw_node {
-  lzw_index index;
-  unsigned char suffix;
-  lzw_node *left;
-  lzw_node *right;
-  lzw_node *map;
-};
-
-struct lzw_state {
-  union {
-    lzw_node *lookup;                 /* encoder table */
-    lzw_entry *table;                 /* decoder table */
-  };
-  lzw_index index;                    /* table index */
-  union {
-    lzw_node *lastnode;               /* previous encoder table node */
-    struct {
-      lzw_entry *lastentry;           /* previous decoder table entry */
-      int tailbytes;                  /* num of bytes of lastentry not yet written out */
-    };
-  };
-  int basebits;                       /* /UnitLength parameter (8) */
-  int codebits;                       /* current code bits */
-  int lastbyte;                       /* previosly read byte */
-  int tailbits;                       /* lastbyte bits not yet consumed */
-  int flush;                          /* encoder */
-  int flags;                          /* options */
-};
-
-/* macros */
-
-#define LZW_MIN_BITS 3
-#define LZW_MAX_BITS 12
-#define LZW_TABLE_SIZE (1 << LZW_MAX_BITS)
-#define LZW_LOOKUP_SIZE (LZW_TABLE_SIZE + 1)
-
-#define lzw_bit_range(bits) (bits >= LZW_MIN_BITS && bits <= LZW_BASE_BITS)
-#define lzw_base_bits(flags) (flags & ((1 << 4) - 1)) // 4 low bits of flags is basebits (UnitLength)
-
-#define lzw_initial_codes(state) (1 << state->basebits)
-#define lzw_clear_code(state)    lzw_initial_codes(state)
-#define lzw_eod_code(state)      (lzw_initial_codes(state) + 1)
-#define lzw_initial_index(state) (lzw_initial_codes(state) + 2)
-
-#define lzw_max_index(state) ((1 << state->codebits) - ((state->flags & LZW_EARLY_INDEX) ? 1 : 0))
-#define lzw_check_bits(state) ((void)(state->index == lzw_max_index(state) && state->codebits < LZW_MAX_BITS && ++state->codebits))
-
-#define lzw_malloc util_malloc
-#define lzw_free util_free
-
-/* decoder */
-
-static struct lzw_entry lzw_initial_table[] = {
-  {{"\x00"}, 1}, {{"\x01"}, 1}, {{"\x02"}, 1}, {{"\x03"}, 1}, {{"\x04"}, 1}, {{"\x05"}, 1}, {{"\x06"}, 1}, {{"\x07"}, 1}, {{"\x08"}, 1}, {{"\x09"}, 1}, {{"\x0A"}, 1}, {{"\x0B"}, 1}, {{"\x0C"}, 1}, {{"\x0D"}, 1}, {{"\x0E"}, 1}, {{"\x0F"}, 1},
-  {{"\x10"}, 1}, {{"\x11"}, 1}, {{"\x12"}, 1}, {{"\x13"}, 1}, {{"\x14"}, 1}, {{"\x15"}, 1}, {{"\x16"}, 1}, {{"\x17"}, 1}, {{"\x18"}, 1}, {{"\x19"}, 1}, {{"\x1A"}, 1}, {{"\x1B"}, 1}, {{"\x1C"}, 1}, {{"\x1D"}, 1}, {{"\x1E"}, 1}, {{"\x1F"}, 1},
-  {{"\x20"}, 1}, {{"\x21"}, 1}, {{"\x22"}, 1}, {{"\x23"}, 1}, {{"\x24"}, 1}, {{"\x25"}, 1}, {{"\x26"}, 1}, {{"\x27"}, 1}, {{"\x28"}, 1}, {{"\x29"}, 1}, {{"\x2A"}, 1}, {{"\x2B"}, 1}, {{"\x2C"}, 1}, {{"\x2D"}, 1}, {{"\x2E"}, 1}, {{"\x2F"}, 1},
-  {{"\x30"}, 1}, {{"\x31"}, 1}, {{"\x32"}, 1}, {{"\x33"}, 1}, {{"\x34"}, 1}, {{"\x35"}, 1}, {{"\x36"}, 1}, {{"\x37"}, 1}, {{"\x38"}, 1}, {{"\x39"}, 1}, {{"\x3A"}, 1}, {{"\x3B"}, 1}, {{"\x3C"}, 1}, {{"\x3D"}, 1}, {{"\x3E"}, 1}, {{"\x3F"}, 1},
-  {{"\x40"}, 1}, {{"\x41"}, 1}, {{"\x42"}, 1}, {{"\x43"}, 1}, {{"\x44"}, 1}, {{"\x45"}, 1}, {{"\x46"}, 1}, {{"\x47"}, 1}, {{"\x48"}, 1}, {{"\x49"}, 1}, {{"\x4A"}, 1}, {{"\x4B"}, 1}, {{"\x4C"}, 1}, {{"\x4D"}, 1}, {{"\x4E"}, 1}, {{"\x4F"}, 1},
-  {{"\x50"}, 1}, {{"\x51"}, 1}, {{"\x52"}, 1}, {{"\x53"}, 1}, {{"\x54"}, 1}, {{"\x55"}, 1}, {{"\x56"}, 1}, {{"\x57"}, 1}, {{"\x58"}, 1}, {{"\x59"}, 1}, {{"\x5A"}, 1}, {{"\x5B"}, 1}, {{"\x5C"}, 1}, {{"\x5D"}, 1}, {{"\x5E"}, 1}, {{"\x5F"}, 1},
-  {{"\x60"}, 1}, {{"\x61"}, 1}, {{"\x62"}, 1}, {{"\x63"}, 1}, {{"\x64"}, 1}, {{"\x65"}, 1}, {{"\x66"}, 1}, {{"\x67"}, 1}, {{"\x68"}, 1}, {{"\x69"}, 1}, {{"\x6A"}, 1}, {{"\x6B"}, 1}, {{"\x6C"}, 1}, {{"\x6D"}, 1}, {{"\x6E"}, 1}, {{"\x6F"}, 1},
-  {{"\x70"}, 1}, {{"\x71"}, 1}, {{"\x72"}, 1}, {{"\x73"}, 1}, {{"\x74"}, 1}, {{"\x75"}, 1}, {{"\x76"}, 1}, {{"\x77"}, 1}, {{"\x78"}, 1}, {{"\x79"}, 1}, {{"\x7A"}, 1}, {{"\x7B"}, 1}, {{"\x7C"}, 1}, {{"\x7D"}, 1}, {{"\x7E"}, 1}, {{"\x7F"}, 1},
-  {{"\x80"}, 1}, {{"\x81"}, 1}, {{"\x82"}, 1}, {{"\x83"}, 1}, {{"\x84"}, 1}, {{"\x85"}, 1}, {{"\x86"}, 1}, {{"\x87"}, 1}, {{"\x88"}, 1}, {{"\x89"}, 1}, {{"\x8A"}, 1}, {{"\x8B"}, 1}, {{"\x8C"}, 1}, {{"\x8D"}, 1}, {{"\x8E"}, 1}, {{"\x8F"}, 1},
-  {{"\x90"}, 1}, {{"\x91"}, 1}, {{"\x92"}, 1}, {{"\x93"}, 1}, {{"\x94"}, 1}, {{"\x95"}, 1}, {{"\x96"}, 1}, {{"\x97"}, 1}, {{"\x98"}, 1}, {{"\x99"}, 1}, {{"\x9A"}, 1}, {{"\x9B"}, 1}, {{"\x9C"}, 1}, {{"\x9D"}, 1}, {{"\x9E"}, 1}, {{"\x9F"}, 1},
-  {{"\xA0"}, 1}, {{"\xA1"}, 1}, {{"\xA2"}, 1}, {{"\xA3"}, 1}, {{"\xA4"}, 1}, {{"\xA5"}, 1}, {{"\xA6"}, 1}, {{"\xA7"}, 1}, {{"\xA8"}, 1}, {{"\xA9"}, 1}, {{"\xAA"}, 1}, {{"\xAB"}, 1}, {{"\xAC"}, 1}, {{"\xAD"}, 1}, {{"\xAE"}, 1}, {{"\xAF"}, 1},
-  {{"\xB0"}, 1}, {{"\xB1"}, 1}, {{"\xB2"}, 1}, {{"\xB3"}, 1}, {{"\xB4"}, 1}, {{"\xB5"}, 1}, {{"\xB6"}, 1}, {{"\xB7"}, 1}, {{"\xB8"}, 1}, {{"\xB9"}, 1}, {{"\xBA"}, 1}, {{"\xBB"}, 1}, {{"\xBC"}, 1}, {{"\xBD"}, 1}, {{"\xBE"}, 1}, {{"\xBF"}, 1},
-  {{"\xC0"}, 1}, {{"\xC1"}, 1}, {{"\xC2"}, 1}, {{"\xC3"}, 1}, {{"\xC4"}, 1}, {{"\xC5"}, 1}, {{"\xC6"}, 1}, {{"\xC7"}, 1}, {{"\xC8"}, 1}, {{"\xC9"}, 1}, {{"\xCA"}, 1}, {{"\xCB"}, 1}, {{"\xCC"}, 1}, {{"\xCD"}, 1}, {{"\xCE"}, 1}, {{"\xCF"}, 1},
-  {{"\xD0"}, 1}, {{"\xD1"}, 1}, {{"\xD2"}, 1}, {{"\xD3"}, 1}, {{"\xD4"}, 1}, {{"\xD5"}, 1}, {{"\xD6"}, 1}, {{"\xD7"}, 1}, {{"\xD8"}, 1}, {{"\xD9"}, 1}, {{"\xDA"}, 1}, {{"\xDB"}, 1}, {{"\xDC"}, 1}, {{"\xDD"}, 1}, {{"\xDE"}, 1}, {{"\xDF"}, 1},
-  {{"\xE0"}, 1}, {{"\xE1"}, 1}, {{"\xE2"}, 1}, {{"\xE3"}, 1}, {{"\xE4"}, 1}, {{"\xE5"}, 1}, {{"\xE6"}, 1}, {{"\xE7"}, 1}, {{"\xE8"}, 1}, {{"\xE9"}, 1}, {{"\xEA"}, 1}, {{"\xEB"}, 1}, {{"\xEC"}, 1}, {{"\xED"}, 1}, {{"\xEE"}, 1}, {{"\xEF"}, 1},
-  {{"\xF0"}, 1}, {{"\xF1"}, 1}, {{"\xF2"}, 1}, {{"\xF3"}, 1}, {{"\xF4"}, 1}, {{"\xF5"}, 1}, {{"\xF6"}, 1}, {{"\xF7"}, 1}, {{"\xF8"}, 1}, {{"\xF9"}, 1}, {{"\xFA"}, 1}, {{"\xFB"}, 1}, {{"\xFC"}, 1}, {{"\xFD"}, 1}, {{"\xFE"}, 1}, {{"\xFF"}, 1}
-};
-
-#define lzw_entry_at(state, index) (&state->table[index])
-
-static lzw_state * lzw_decoder_init_table (lzw_state *state, lzw_entry *table, int flags)
-{
-  state->basebits = lzw_base_bits(flags); // first four bits or flags
-  if (!lzw_bit_range(state->basebits))
-    return NULL;
-  state->flags = flags;
-  if ((state->table = table) == NULL)
-  {
-    state->table = (lzw_entry *)lzw_malloc(LZW_TABLE_SIZE * sizeof(lzw_entry));
-    state->flags |= LZW_TABLE_ALLOC;
-  }
-  memcpy(state->table, lzw_initial_table, (size_t)lzw_initial_codes(state)*sizeof(lzw_entry));
-  // memset(&state->table[lzw_initial_codes(state)], 0, 2*sizeof(lzw_entry)); // eod and clear entries never accessed
-  state->codebits = state->basebits + 1;
-  state->index = lzw_initial_index(state);
-  state->lastentry = NULL;
-  state->tailbytes = 0;
-  state->lastbyte = 0;
-  state->tailbits = 0;
-  return state;
-}
-
-lzw_state * lzw_decoder_init (lzw_state *state, int flags)
-{
-  return lzw_decoder_init_table(state, NULL, flags);
-}
-
-static void lzw_decoder_clear (lzw_state *state)
-{
-  lzw_entry *entry;
-  lzw_index initindex = lzw_initial_index(state);
-  while (state->index > initindex)
-  {
-    entry = lzw_entry_at(state, --state->index);
-    lzw_free(entry->data);
-    // entry->data = NULL;
-    // entry->size = 0;
-  }
-  state->lastentry = NULL;
-  state->tailbytes = 0;
-  state->codebits = state->basebits + 1;
-}
-
-void lzw_decoder_close (lzw_state *state)
-{
-  lzw_decoder_clear(state);
-  if (state->flags & LZW_TABLE_ALLOC)
-    lzw_free(state->table);
-}
-
-static int lzw_next_entry (lzw_state *state, lzw_entry *nextentry)
-{
-  lzw_entry *lastentry, *newentry;
-  if ((lastentry = state->lastentry) == NULL)
-    return 1; /* its ok */
-  if (state->index == LZW_TABLE_SIZE)
-    return 0; /* invalid input; eod marker expected earlier */
-  /* put the new entry on the top of the table */
-  newentry = lzw_entry_at(state, state->index++);
-  /* its size is the last entrtyy size plus 1 */
-  newentry->size = lastentry->size + 1;
-  /* its content is the content of the last entry, */
-  newentry->data = (char *)lzw_malloc((size_t)newentry->size);
-  memcpy(newentry->data, lastentry->data, lastentry->size);
-  /* plus the first byte of the new entry (usually fixed code entry) */
-  newentry->data[newentry->size - 1] = nextentry->data[0];
-  return 1;
-}
-
-#define lzw_write_bytes(O, state) ((state->tailbytes -= (int)iof_write(O, state->lastentry->data, (size_t)state->tailbytes)) == 0)
-
-iof_status lzw_decode_state (iof *I, iof *O, lzw_state *state)
-{
-  const lzw_index clear = lzw_clear_code(state), eod = lzw_eod_code(state);
-  lzw_index code;
-  lzw_entry *entry;
-  if (state->lastentry != NULL)
-  { /* write out the tail from the last call */
-    if (state->tailbytes > 0 && !lzw_write_bytes(O, state))
-      return IOFFULL;
-    /* do what we normally do at the end of the loop body below */
-    lzw_check_bits(state);
-  }
-  // if (state->flags & LZW_LOW_BITS_FIRST)
-  //   return IOFERR;
-  while (1)
-  {
-    /* get input code of length state->codebits */
-    code = (state->lastbyte & ((1 << state->tailbits) - 1)) << (state->codebits - state->tailbits);
-    for (state->tailbits -= state->codebits; state->tailbits < 0; )
-    {
-      get_code:
-      if ((state->lastbyte = iof_get(I)) < 0)
-        return state->flush ? IOFEOF : state->lastbyte;
-      state->tailbits += 8;
-      if (state->tailbits < 0)
-      {
-        code |= (state->lastbyte << (-state->tailbits));
-        goto get_code;
-      }
-      else
-      {
-        code |= (state->lastbyte >> state->tailbits);
-        break;
-      }
-    }
-    /* interpret the code */
-    if (code < state->index)
-    { /* single byte code or special marker */
-      if (code == clear)
-      {
-        lzw_decoder_clear(state);
-        continue;
-      }
-      if (code == eod)
-        return IOFEOF;
-      entry = lzw_entry_at(state, code);
-      if (!lzw_next_entry(state, entry))
-        return IOFERR;
-    }
-    else if (code == state->index)
-    { /* apparently encoder has emitted the code of the key just created (see notes) */
-      if (!lzw_next_entry(state, state->lastentry))
-        return IOFERR;
-      entry = lzw_entry_at(state, state->index - 1);
-    }
-    else
-    { /* invalid input code */
-      return IOFERR;
-    }
-    /* record the entry found */
-    state->lastentry = entry;
-    /* emit the sequence pointed by that entry */
-    state->tailbytes = entry->size;
-    if (!lzw_write_bytes(O, state))
-      return IOFFULL;
-    /* check and update code bits */
-    lzw_check_bits(state);
-  }
-  return state->lastbyte; // never reached
-}
-
-/* encoder */
-
-#define lzw_node_at(state, index) (&state->lookup[index])
-
-#define lzw_node_init(node, i, c) (node->index = i, node->suffix = c, node->left = NULL, node->right = NULL, node->map = NULL)
-
-static lzw_state * lzw_encoder_init_table (lzw_state *state, lzw_node *lookup, int flags)
-{
-  lzw_index index;
-  lzw_node *node;
-  state->basebits = lzw_base_bits(flags); // first four bits of flags is base bits of code (default 8)
-  if (!lzw_bit_range(state->basebits))
-    return NULL;
-  state->flags = flags;
-  if ((state->lookup = lookup) == NULL)
-  {
-    state->lookup = lzw_malloc(LZW_LOOKUP_SIZE*sizeof(lzw_node));
-    state->flags |= LZW_TABLE_ALLOC;
-  }
-  state->index = lzw_initial_index(state);
-  for (index = 0; index < lzw_initial_codes(state); ++index)
-  {
-    node = lzw_node_at(state, index);
-    lzw_node_init(node, index, (unsigned char)index);
-  }
-  state->codebits = state->basebits + 1;
-  state->lastnode = NULL;
-  state->lastbyte = 0;
-  state->tailbits = 0;
-  return state;
-}
-
-lzw_state * lzw_encoder_init (lzw_state *state, int flags)
-{
-  return lzw_encoder_init_table(state, NULL, flags);
-}
-
-void lzw_encoder_close (lzw_state *state)
-{
-  if (state->flags & LZW_TABLE_ALLOC)
-    lzw_free(state->lookup);
-}
-
-static void lzw_encoder_clear (lzw_state *state)
-{
-  lzw_node *node;
-  lzw_index index;
-  /* clear fixed nodes */
-  for (index = 0; index < lzw_initial_codes(state); ++index)
-  {
-    node = lzw_node_at(state, index);
-    lzw_node_init(node, index, (unsigned char)index);
-  }
-  /* reset table index */
-  state->index = lzw_initial_index(state);
-  /* reset code bits */
-  state->codebits = state->basebits + 1;
-}
-
-static void lzw_put_code (iof *O, lzw_state *state, lzw_index code, int todobits)
-{
-  int leftbits, rightbits;
-  do
-  {
-    leftbits = 8 - state->tailbits;
-    rightbits = todobits - leftbits;
-    if (rightbits >= 0)
-    {
-      state->lastbyte |= (code >> rightbits);
-      iof_put(O, state->lastbyte);
-      code = code & ((1 << rightbits) - 1);
-      todobits -= leftbits;
-      state->lastbyte = 0;
-      state->tailbits = 0;
-    }
-    else
-    {
-      state->lastbyte |= (code << (-rightbits));
-      state->tailbits += todobits;
-      return;
-    }
-  } while (1);
-}
-
-static iof_status lzw_encode_last (iof *O, lzw_state *state)
-{
-  if (state->flush)
-  {
-    /* put the last code if any */
-    if (state->lastnode != NULL)
-      lzw_put_code(O, state, state->lastnode->index, state->codebits);
-    /* put eod marker, */
-    lzw_put_code(O, state, lzw_eod_code(state), state->codebits);
-    /* with tail bits set to 0 */
-    if (state->tailbits > 0)
-      lzw_put_code(O, state, 0, 8 - state->tailbits);
-    return IOFEOF;
-  }
-  return IOFEMPTY;
-}
-
-static lzw_node * lzw_node_push (lzw_state *state, unsigned char suffix)
-{
-  lzw_node *node;
-  node = lzw_node_at(state, state->index);
-  lzw_node_init(node, state->index, suffix);
-  ++state->index;
-  return node;
-}
-
-static int lzw_next_node (lzw_state *state, unsigned char suffix)
-{
-  lzw_node *node;
-  if ((node = state->lastnode->map) == NULL)
-  {
-    state->lastnode->map = lzw_node_push(state, suffix);
-    return 0;
-  }
-  while (1)
-  {
-    if (suffix < node->suffix)
-    {
-      if (node->left == NULL)
-      {
-        node->left = lzw_node_push(state, suffix);
-        return 0;
-      }
-      node = node->left;
-    }
-    else if (suffix > node->suffix)
-    {
-      if (node->right == NULL)
-      {
-        node->right = lzw_node_push(state, suffix);
-        return 0;
-      }
-      node = node->right;
-    }
-    else
-    {
-      state->lastnode = node;
-      return 1;
-    }
-  }
-  return 0; // never reached
-}
-
-iof_status lzw_encode_state (iof *I, iof *O, lzw_state *state)
-{
-  int byte;
-  if (state->lastnode == NULL)
-  { /* first call only; following convention, put clear-table marker */
-    if (!iof_ensure(O, 2))
-      return IOFFULL;
-    lzw_put_code(O, state, lzw_clear_code(state), state->codebits);
-    /* get the first input byte and initialize the current table entry */
-    if ((byte = iof_get(I)) < 0)
-      return lzw_encode_last(O, state);
-    state->lastnode = lzw_node_at(state, byte);
-  }
-  while (iof_ensure(O, 2))
-  { /* we need to write at most 2 bytes on each iteration */
-    if ((byte = iof_get(I)) < 0)
-      return lzw_encode_last(O, state);
-    if (lzw_next_node(state, (unsigned char)byte) == 0)
-    { /* means that the key hasn't been found and the new entry has just been created */
-      /* output the code pointing the longest sequence so far */
-      lzw_put_code(O, state, state->lastnode->index, state->codebits);
-      /* update code bits */
-      if (state->index == lzw_max_index(state) + 1)
-      {
-        if (state->codebits < LZW_MAX_BITS)
-          ++state->codebits;
-        else
-        {
-          /* put clear-table marker */
-          lzw_put_code(O, state, lzw_clear_code(state), state->codebits);
-          /* reset the table */
-          lzw_encoder_clear(state);
-        }
-      }
-      /* in any case, recent byte becomes the current table code */
-      state->lastnode = lzw_node_at(state, byte);
-    }
-    /* otherwise no new entry is appended and state->lastnode points the longer sequence just found */
-  }
-  return IOFFULL;
-}
-
-/* single call codecs */
-
-iof_status lzw_decode (iof *I, iof *O, int flags)
-{
-  lzw_state state = { { 0 } }; // shut overactive warnings
-  lzw_entry table[LZW_TABLE_SIZE];
-  int ret;
-  lzw_decoder_init_table(&state, table, flags);
-  state.flush = 1;
-  ret = lzw_decode_state(I, O, &state);
-  // iof_flush(O); // ?
-  lzw_decoder_close(&state);
-  return ret;
-}
-
-iof_status lzw_encode (iof *I, iof *O, int flags)
-{
-  lzw_state state;
-  lzw_node lookup[LZW_LOOKUP_SIZE];
-  int ret;
-  lzw_encoder_init_table(&state, lookup, flags);
-  state.flush = 1;
-  ret = lzw_encode_state(I, O, &state);
-  // iof_flush(O); // ?
-  lzw_encoder_close(&state);
-  return ret;
-}
-
-/* filters */
-
-// lzw decoder function
-
-static size_t lzw_decoder (iof *F, iof_mode mode)
-{
-  lzw_state *state;
-  iof_status status;
-  size_t tail;
-
-  state = iof_filter_state(lzw_state *, F);
-  switch(mode)
-  {
-    case IOFLOAD:
-    case IOFREAD:
-      if (F->flags & IOF_STOPPED)
-        return 0;
-      tail = iof_tail(F);
-      F->pos = F->buf + tail;
-      F->end = F->buf + F->space;
-      do {
-        status = lzw_decode_state(F->next, F, state);
-      } while (mode == IOFLOAD && status == IOFFULL && iof_resize_buffer(F));
-      return iof_decoder_retval(F, "lzw", status);
-    case IOFCLOSE:
-      lzw_decoder_close(state);
-      iof_free(F);
-      return 0;
-    default:
-      break;
-  }
-  return 0;
-}
-
-// lzw encoder function
-
-static size_t lzw_encoder (iof *F, iof_mode mode)
-{
-  lzw_state *state;
-  iof_status status;
-
-  state = iof_filter_state(lzw_state *, F);
-  switch (mode)
-  {
-    case IOFFLUSH:
-      state->flush = 1;
-      // fall through
-    case IOFWRITE:
-      F->end = F->pos;
-      F->pos = F->buf;
-      status = lzw_encode_state(F, F->next, state);
-      return iof_encoder_retval(F, "lzw", status);
-    case IOFCLOSE:
-      if (!state->flush)
-        lzw_encoder(F, IOFFLUSH);
-      lzw_encoder_close(state);
-      iof_free(F);
-      return 0;
-    default:
-      break;
-  }
-  return 0;
-}
-
-iof * iof_filter_lzw_decoder (iof *N, int flags)
-{
-  iof *I;
-  lzw_state *state;
-  I = iof_filter_reader(lzw_decoder, sizeof(lzw_state), &state);
-  iof_setup_next(I, N);
-  if (lzw_decoder_init(state, flags) == NULL)
-  {
-    iof_discard(I);
-    return NULL;
-  }
-  state->flush = 1;
-  return I;
-}
-
-iof * iof_filter_lzw_encoder (iof *N, int flags)
-{
-  iof *O;
-  lzw_state *state;
-  O = iof_filter_writer(lzw_encoder, sizeof(lzw_state), &state);
-  iof_setup_next(O, N);
-  if (lzw_encoder_init(state, flags) == NULL)
-  {
-    iof_discard(O);
-    return NULL;
-  }
-  return O;
-}
--- texlive-bin.orig/texk/web2c/luatexdir/luapplib/util/utillzw.h
+++ /dev/null
@@ -1,30 +0,0 @@
-#ifndef UTIL_LZW_H
-#define UTIL_LZW_H
-
-#include "utiliof.h"
-
-typedef struct lzw_state lzw_state;
-
-#define LZW_BASE_BITS 8
-#define LZW_TABLE_ALLOC (1<<4)
-#define LZW_EARLY_INDEX (1<<5)
-//#define LZW_LOW_BITS_FIRST (1<<6)
-#define LZW_DECODER_DEFAULTS (LZW_BASE_BITS|LZW_EARLY_INDEX|0)
-#define LZW_ENCODER_DEFAULTS (LZW_BASE_BITS|LZW_EARLY_INDEX|0)
-
-lzw_state * lzw_decoder_init (lzw_state *state, int flags);
-lzw_state * lzw_encoder_init (lzw_state *state, int flags);
-
-void lzw_decoder_close (lzw_state *state);
-void lzw_encoder_close (lzw_state *state);
-
-iof_status lzw_encode_state (iof *I, iof *O, lzw_state *state);
-iof_status lzw_decode_state (iof *I, iof *O, lzw_state *state);
-
-iof_status lzw_encode (iof *I, iof *O, int flags);
-iof_status lzw_decode (iof *I, iof *O, int flags);
-
-iof * iof_filter_lzw_decoder (iof *N, int flags);
-iof * iof_filter_lzw_encoder (iof *N, int flags);
-
-#endif
\ No newline at end of file
--- texlive-bin.orig/texk/web2c/luatexdir/luapplib/util/utilmd5.c
+++ /dev/null
@@ -1,413 +0,0 @@
-/* md5 implementation by Peter Deutsch (ghost@aladdin.com) with some convenience shorthands  */
-
-/* begin of md5.c */
-
-/*
-  Copyright (C) 1999, 2000, 2002 Aladdin Enterprises.  All rights reserved.
-
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the authors be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-
-  L. Peter Deutsch
-  ghost@aladdin.com
-
- */
-/* $Id: md5.c,v 1.6 2002/04/13 19:20:28 lpd Exp $ */
-/*
-  Independent implementation of MD5 (RFC 1321).
-
-  This code implements the MD5 Algorithm defined in RFC 1321, whose
-  text is available at
-	http://www.ietf.org/rfc/rfc1321.txt
-  The code is derived from the text of the RFC, including the test suite
-  (section A.5) but excluding the rest of Appendix A.  It does not include
-  any code or documentation that is identified in the RFC as being
-  copyrighted.
-
-  The original and principal author of md5.c is L. Peter Deutsch
-  <ghost@aladdin.com>.  Other authors are noted in the change history
-  that follows (in reverse chronological order):
-
-  2002-04-13 lpd Clarified derivation from RFC 1321; now handles byte order
-	either statically or dynamically; added missing #include <string.h>
-	in library.
-  2002-03-11 lpd Corrected argument list for main(), and added int return
-	type, in test program and T value program.
-  2002-02-21 lpd Added missing #include <stdio.h> in test program.
-  2000-07-03 lpd Patched to eliminate warnings about "constant is
-	unsigned in ANSI C, signed in traditional"; made test program
-	self-checking.
-  1999-11-04 lpd Edited comments slightly for automatic TOC extraction.
-  1999-10-18 lpd Fixed typo in header comment (ansi2knr rather than md5).
-  1999-05-03 lpd Original version.
- */
-
-//#include "md5.h"
-#include "utilmd5.h"
-#include <string.h>
-
-#undef BYTE_ORDER	/* 1 = big-endian, -1 = little-endian, 0 = unknown */
-#ifdef ARCH_IS_BIG_ENDIAN
-#  define BYTE_ORDER (ARCH_IS_BIG_ENDIAN ? 1 : -1)
-#else
-#  define BYTE_ORDER 0
-#endif
-
-#define T_MASK ((uint32_t)~0)
-#define T1 /* 0xd76aa478 */ (T_MASK ^ 0x28955b87)
-#define T2 /* 0xe8c7b756 */ (T_MASK ^ 0x173848a9)
-#define T3    0x242070db
-#define T4 /* 0xc1bdceee */ (T_MASK ^ 0x3e423111)
-#define T5 /* 0xf57c0faf */ (T_MASK ^ 0x0a83f050)
-#define T6    0x4787c62a
-#define T7 /* 0xa8304613 */ (T_MASK ^ 0x57cfb9ec)
-#define T8 /* 0xfd469501 */ (T_MASK ^ 0x02b96afe)
-#define T9    0x698098d8
-#define T10 /* 0x8b44f7af */ (T_MASK ^ 0x74bb0850)
-#define T11 /* 0xffff5bb1 */ (T_MASK ^ 0x0000a44e)
-#define T12 /* 0x895cd7be */ (T_MASK ^ 0x76a32841)
-#define T13    0x6b901122
-#define T14 /* 0xfd987193 */ (T_MASK ^ 0x02678e6c)
-#define T15 /* 0xa679438e */ (T_MASK ^ 0x5986bc71)
-#define T16    0x49b40821
-#define T17 /* 0xf61e2562 */ (T_MASK ^ 0x09e1da9d)
-#define T18 /* 0xc040b340 */ (T_MASK ^ 0x3fbf4cbf)
-#define T19    0x265e5a51
-#define T20 /* 0xe9b6c7aa */ (T_MASK ^ 0x16493855)
-#define T21 /* 0xd62f105d */ (T_MASK ^ 0x29d0efa2)
-#define T22    0x02441453
-#define T23 /* 0xd8a1e681 */ (T_MASK ^ 0x275e197e)
-#define T24 /* 0xe7d3fbc8 */ (T_MASK ^ 0x182c0437)
-#define T25    0x21e1cde6
-#define T26 /* 0xc33707d6 */ (T_MASK ^ 0x3cc8f829)
-#define T27 /* 0xf4d50d87 */ (T_MASK ^ 0x0b2af278)
-#define T28    0x455a14ed
-#define T29 /* 0xa9e3e905 */ (T_MASK ^ 0x561c16fa)
-#define T30 /* 0xfcefa3f8 */ (T_MASK ^ 0x03105c07)
-#define T31    0x676f02d9
-#define T32 /* 0x8d2a4c8a */ (T_MASK ^ 0x72d5b375)
-#define T33 /* 0xfffa3942 */ (T_MASK ^ 0x0005c6bd)
-#define T34 /* 0x8771f681 */ (T_MASK ^ 0x788e097e)
-#define T35    0x6d9d6122
-#define T36 /* 0xfde5380c */ (T_MASK ^ 0x021ac7f3)
-#define T37 /* 0xa4beea44 */ (T_MASK ^ 0x5b4115bb)
-#define T38    0x4bdecfa9
-#define T39 /* 0xf6bb4b60 */ (T_MASK ^ 0x0944b49f)
-#define T40 /* 0xbebfbc70 */ (T_MASK ^ 0x4140438f)
-#define T41    0x289b7ec6
-#define T42 /* 0xeaa127fa */ (T_MASK ^ 0x155ed805)
-#define T43 /* 0xd4ef3085 */ (T_MASK ^ 0x2b10cf7a)
-#define T44    0x04881d05
-#define T45 /* 0xd9d4d039 */ (T_MASK ^ 0x262b2fc6)
-#define T46 /* 0xe6db99e5 */ (T_MASK ^ 0x1924661a)
-#define T47    0x1fa27cf8
-#define T48 /* 0xc4ac5665 */ (T_MASK ^ 0x3b53a99a)
-#define T49 /* 0xf4292244 */ (T_MASK ^ 0x0bd6ddbb)
-#define T50    0x432aff97
-#define T51 /* 0xab9423a7 */ (T_MASK ^ 0x546bdc58)
-#define T52 /* 0xfc93a039 */ (T_MASK ^ 0x036c5fc6)
-#define T53    0x655b59c3
-#define T54 /* 0x8f0ccc92 */ (T_MASK ^ 0x70f3336d)
-#define T55 /* 0xffeff47d */ (T_MASK ^ 0x00100b82)
-#define T56 /* 0x85845dd1 */ (T_MASK ^ 0x7a7ba22e)
-#define T57    0x6fa87e4f
-#define T58 /* 0xfe2ce6e0 */ (T_MASK ^ 0x01d3191f)
-#define T59 /* 0xa3014314 */ (T_MASK ^ 0x5cfebceb)
-#define T60    0x4e0811a1
-#define T61 /* 0xf7537e82 */ (T_MASK ^ 0x08ac817d)
-#define T62 /* 0xbd3af235 */ (T_MASK ^ 0x42c50dca)
-#define T63    0x2ad7d2bb
-#define T64 /* 0xeb86d391 */ (T_MASK ^ 0x14792c6e)
-
-
-static void
-md5_process(md5_state_t *pms, const uint8_t *data /*[64]*/)
-{
-    uint32_t
-	a = pms->abcd[0], b = pms->abcd[1],
-	c = pms->abcd[2], d = pms->abcd[3];
-    uint32_t t;
-#if BYTE_ORDER > 0
-    /* Define storage only for big-endian CPUs. */
-    uint32_t X[16];
-#else
-    /* Define storage for little-endian or both types of CPUs. */
-    uint32_t xbuf[16];
-    const uint32_t *X;
-#endif
-
-    {
-#if BYTE_ORDER == 0
-	/*
-	 * Determine dynamically whether this is a big-endian or
-	 * little-endian machine, since we can use a more efficient
-	 * algorithm on the latter.
-	 */
-	static const int w = 1;
-
-	if (*((const uint8_t *)&w)) /* dynamic little-endian */
-#endif
-#if BYTE_ORDER <= 0		/* little-endian */
-	{
-	    /*
-	     * On little-endian machines, we can process properly aligned
-	     * data without copying it.
-	     */
-	    if (!((data - (const uint8_t *)0) & 3)) {
-		/* data are properly aligned */
-		X = (const uint32_t *)data;
-	    } else {
-		/* not aligned */
-		memcpy(xbuf, data, 64);
-		X = xbuf;
-	    }
-	}
-#endif
-#if BYTE_ORDER == 0
-	else			/* dynamic big-endian */
-#endif
-#if BYTE_ORDER >= 0		/* big-endian */
-	{
-	    /*
-	     * On big-endian machines, we must arrange the bytes in the
-	     * right order.
-	     */
-	    const uint8_t *xp = data;
-	    int i;
-
-#  if BYTE_ORDER == 0
-	    X = xbuf;		/* (dynamic only) */
-#  else
-#    define xbuf X		/* (static only) */
-#  endif
-	    for (i = 0; i < 16; ++i, xp += 4)
-		xbuf[i] = xp[0] + (xp[1] << 8) + (xp[2] << 16) + (xp[3] << 24);
-	}
-#endif
-    }
-
-#define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32 - (n))))
-
-    /* Round 1. */
-    /* Let [abcd k s i] denote the operation
-       a = b + ((a + F(b,c,d) + X[k] + T[i]) <<< s). */
-#define F(x, y, z) (((x) & (y)) | (~(x) & (z)))
-#define SET(a, b, c, d, k, s, Ti)\
-  t = a + F(b,c,d) + X[k] + Ti;\
-  a = ROTATE_LEFT(t, s) + b
-    /* Do the following 16 operations. */
-    SET(a, b, c, d,  0,  7,  T1);
-    SET(d, a, b, c,  1, 12,  T2);
-    SET(c, d, a, b,  2, 17,  T3);
-    SET(b, c, d, a,  3, 22,  T4);
-    SET(a, b, c, d,  4,  7,  T5);
-    SET(d, a, b, c,  5, 12,  T6);
-    SET(c, d, a, b,  6, 17,  T7);
-    SET(b, c, d, a,  7, 22,  T8);
-    SET(a, b, c, d,  8,  7,  T9);
-    SET(d, a, b, c,  9, 12, T10);
-    SET(c, d, a, b, 10, 17, T11);
-    SET(b, c, d, a, 11, 22, T12);
-    SET(a, b, c, d, 12,  7, T13);
-    SET(d, a, b, c, 13, 12, T14);
-    SET(c, d, a, b, 14, 17, T15);
-    SET(b, c, d, a, 15, 22, T16);
-#undef SET
-
-     /* Round 2. */
-     /* Let [abcd k s i] denote the operation
-          a = b + ((a + G(b,c,d) + X[k] + T[i]) <<< s). */
-#define G(x, y, z) (((x) & (z)) | ((y) & ~(z)))
-#define SET(a, b, c, d, k, s, Ti)\
-  t = a + G(b,c,d) + X[k] + Ti;\
-  a = ROTATE_LEFT(t, s) + b
-     /* Do the following 16 operations. */
-    SET(a, b, c, d,  1,  5, T17);
-    SET(d, a, b, c,  6,  9, T18);
-    SET(c, d, a, b, 11, 14, T19);
-    SET(b, c, d, a,  0, 20, T20);
-    SET(a, b, c, d,  5,  5, T21);
-    SET(d, a, b, c, 10,  9, T22);
-    SET(c, d, a, b, 15, 14, T23);
-    SET(b, c, d, a,  4, 20, T24);
-    SET(a, b, c, d,  9,  5, T25);
-    SET(d, a, b, c, 14,  9, T26);
-    SET(c, d, a, b,  3, 14, T27);
-    SET(b, c, d, a,  8, 20, T28);
-    SET(a, b, c, d, 13,  5, T29);
-    SET(d, a, b, c,  2,  9, T30);
-    SET(c, d, a, b,  7, 14, T31);
-    SET(b, c, d, a, 12, 20, T32);
-#undef SET
-
-     /* Round 3. */
-     /* Let [abcd k s t] denote the operation
-          a = b + ((a + H(b,c,d) + X[k] + T[i]) <<< s). */
-#define H(x, y, z) ((x) ^ (y) ^ (z))
-#define SET(a, b, c, d, k, s, Ti)\
-  t = a + H(b,c,d) + X[k] + Ti;\
-  a = ROTATE_LEFT(t, s) + b
-     /* Do the following 16 operations. */
-    SET(a, b, c, d,  5,  4, T33);
-    SET(d, a, b, c,  8, 11, T34);
-    SET(c, d, a, b, 11, 16, T35);
-    SET(b, c, d, a, 14, 23, T36);
-    SET(a, b, c, d,  1,  4, T37);
-    SET(d, a, b, c,  4, 11, T38);
-    SET(c, d, a, b,  7, 16, T39);
-    SET(b, c, d, a, 10, 23, T40);
-    SET(a, b, c, d, 13,  4, T41);
-    SET(d, a, b, c,  0, 11, T42);
-    SET(c, d, a, b,  3, 16, T43);
-    SET(b, c, d, a,  6, 23, T44);
-    SET(a, b, c, d,  9,  4, T45);
-    SET(d, a, b, c, 12, 11, T46);
-    SET(c, d, a, b, 15, 16, T47);
-    SET(b, c, d, a,  2, 23, T48);
-#undef SET
-
-     /* Round 4. */
-     /* Let [abcd k s t] denote the operation
-          a = b + ((a + I(b,c,d) + X[k] + T[i]) <<< s). */
-#define I(x, y, z) ((y) ^ ((x) | ~(z)))
-#define SET(a, b, c, d, k, s, Ti)\
-  t = a + I(b,c,d) + X[k] + Ti;\
-  a = ROTATE_LEFT(t, s) + b
-     /* Do the following 16 operations. */
-    SET(a, b, c, d,  0,  6, T49);
-    SET(d, a, b, c,  7, 10, T50);
-    SET(c, d, a, b, 14, 15, T51);
-    SET(b, c, d, a,  5, 21, T52);
-    SET(a, b, c, d, 12,  6, T53);
-    SET(d, a, b, c,  3, 10, T54);
-    SET(c, d, a, b, 10, 15, T55);
-    SET(b, c, d, a,  1, 21, T56);
-    SET(a, b, c, d,  8,  6, T57);
-    SET(d, a, b, c, 15, 10, T58);
-    SET(c, d, a, b,  6, 15, T59);
-    SET(b, c, d, a, 13, 21, T60);
-    SET(a, b, c, d,  4,  6, T61);
-    SET(d, a, b, c, 11, 10, T62);
-    SET(c, d, a, b,  2, 15, T63);
-    SET(b, c, d, a,  9, 21, T64);
-#undef SET
-
-     /* Then perform the following additions. (That is increment each
-        of the four registers by the value it had before this block
-        was started.) */
-    pms->abcd[0] += a;
-    pms->abcd[1] += b;
-    pms->abcd[2] += c;
-    pms->abcd[3] += d;
-}
-
-void
-pplib_md5_init(md5_state_t *pms)
-{
-    pms->count[0] = pms->count[1] = 0;
-    pms->abcd[0] = 0x67452301;
-    pms->abcd[1] = /*0xefcdab89*/ T_MASK ^ 0x10325476;
-    pms->abcd[2] = /*0x98badcfe*/ T_MASK ^ 0x67452301;
-    pms->abcd[3] = 0x10325476;
-}
-
-void
-md5_add(md5_state_t *pms, const void *input, size_t size)
-{
-    const uint8_t *p = (const uint8_t *)input;
-    int nbytes = (int)size; // PJ
-    int left = nbytes;
-    int offset = (pms->count[0] >> 3) & 63;
-    uint32_t nbits = (uint32_t)(nbytes << 3);
-
-    if (nbytes <= 0)
-	return;
-
-    /* Update the message length. */
-    pms->count[1] += nbytes >> 29;
-    pms->count[0] += nbits;
-    if (pms->count[0] < nbits)
-	pms->count[1]++;
-
-    /* Process an initial partial block. */
-    if (offset) {
-	int copy = (offset + nbytes > 64 ? 64 - offset : nbytes);
-
-	memcpy(pms->buf + offset, p, copy);
-	if (offset + copy < 64)
-	    return;
-	p += copy;
-	left -= copy;
-	md5_process(pms, pms->buf);
-    }
-
-    /* Process full blocks. */
-    for (; left >= 64; p += 64, left -= 64)
-	md5_process(pms, p);
-
-    /* Process a final partial block. */
-    if (left)
-	memcpy(pms->buf, p, left);
-}
-
-void
-md5_put(md5_state_t *pms, uint8_t digest[16])
-{
-    static const uint8_t pad[64] = {
-	0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
-    };
-    uint8_t data[8];
-    int i;
-
-    /* Save the length before padding. */
-    for (i = 0; i < 8; ++i)
-	data[i] = (uint8_t)(pms->count[i >> 2] >> ((i & 3) << 3));
-    /* Pad to 56 bytes mod 64. */
-    md5_add(pms, pad, ((55 - (pms->count[0] >> 3)) & 63) + 1);
-    /* Append the length. */
-    md5_add(pms, data, 8);
-    for (i = 0; i < 16; ++i)
-	digest[i] = (uint8_t)(pms->abcd[i >> 2] >> ((i & 3) << 3));
-}
-
-/* end of md5.h */
-
-static md5_state_t state;
-
-void pplib_md5 (const void *input, size_t length, uint8_t output[16])
-{
-  pplib_md5_init(&state);
-  md5_add(&state, input, length);
-  md5_put(&state, output);
-}
-
-void md5init (void)
-{
-  pplib_md5_init(&state);
-}
-
-void md5add (const void *input, size_t length)
-{
-  md5_add(&state, input, length);
-}
-
-void md5put (uint8_t output[16])
-{
-  md5_put(&state, output);
-}
--- texlive-bin.orig/texk/web2c/luatexdir/luapplib/util/utilmd5.c.orig
+++ /dev/null
@@ -1,413 +0,0 @@
-/* md5 implementation by Peter Deutsch (ghost@aladdin.com) with some convenience shorthands  */
-
-/* begin of md5.c */
-
-/*
-  Copyright (C) 1999, 2000, 2002 Aladdin Enterprises.  All rights reserved.
-
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the authors be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-
-  L. Peter Deutsch
-  ghost@aladdin.com
-
- */
-/* $Id: md5.c,v 1.6 2002/04/13 19:20:28 lpd Exp $ */
-/*
-  Independent implementation of MD5 (RFC 1321).
-
-  This code implements the MD5 Algorithm defined in RFC 1321, whose
-  text is available at
-	http://www.ietf.org/rfc/rfc1321.txt
-  The code is derived from the text of the RFC, including the test suite
-  (section A.5) but excluding the rest of Appendix A.  It does not include
-  any code or documentation that is identified in the RFC as being
-  copyrighted.
-
-  The original and principal author of md5.c is L. Peter Deutsch
-  <ghost@aladdin.com>.  Other authors are noted in the change history
-  that follows (in reverse chronological order):
-
-  2002-04-13 lpd Clarified derivation from RFC 1321; now handles byte order
-	either statically or dynamically; added missing #include <string.h>
-	in library.
-  2002-03-11 lpd Corrected argument list for main(), and added int return
-	type, in test program and T value program.
-  2002-02-21 lpd Added missing #include <stdio.h> in test program.
-  2000-07-03 lpd Patched to eliminate warnings about "constant is
-	unsigned in ANSI C, signed in traditional"; made test program
-	self-checking.
-  1999-11-04 lpd Edited comments slightly for automatic TOC extraction.
-  1999-10-18 lpd Fixed typo in header comment (ansi2knr rather than md5).
-  1999-05-03 lpd Original version.
- */
-
-//#include "md5.h"
-#include "utilmd5.h"
-#include <string.h>
-
-#undef BYTE_ORDER	/* 1 = big-endian, -1 = little-endian, 0 = unknown */
-#ifdef ARCH_IS_BIG_ENDIAN
-#  define BYTE_ORDER (ARCH_IS_BIG_ENDIAN ? 1 : -1)
-#else
-#  define BYTE_ORDER 0
-#endif
-
-#define T_MASK ((uint32_t)~0)
-#define T1 /* 0xd76aa478 */ (T_MASK ^ 0x28955b87)
-#define T2 /* 0xe8c7b756 */ (T_MASK ^ 0x173848a9)
-#define T3    0x242070db
-#define T4 /* 0xc1bdceee */ (T_MASK ^ 0x3e423111)
-#define T5 /* 0xf57c0faf */ (T_MASK ^ 0x0a83f050)
-#define T6    0x4787c62a
-#define T7 /* 0xa8304613 */ (T_MASK ^ 0x57cfb9ec)
-#define T8 /* 0xfd469501 */ (T_MASK ^ 0x02b96afe)
-#define T9    0x698098d8
-#define T10 /* 0x8b44f7af */ (T_MASK ^ 0x74bb0850)
-#define T11 /* 0xffff5bb1 */ (T_MASK ^ 0x0000a44e)
-#define T12 /* 0x895cd7be */ (T_MASK ^ 0x76a32841)
-#define T13    0x6b901122
-#define T14 /* 0xfd987193 */ (T_MASK ^ 0x02678e6c)
-#define T15 /* 0xa679438e */ (T_MASK ^ 0x5986bc71)
-#define T16    0x49b40821
-#define T17 /* 0xf61e2562 */ (T_MASK ^ 0x09e1da9d)
-#define T18 /* 0xc040b340 */ (T_MASK ^ 0x3fbf4cbf)
-#define T19    0x265e5a51
-#define T20 /* 0xe9b6c7aa */ (T_MASK ^ 0x16493855)
-#define T21 /* 0xd62f105d */ (T_MASK ^ 0x29d0efa2)
-#define T22    0x02441453
-#define T23 /* 0xd8a1e681 */ (T_MASK ^ 0x275e197e)
-#define T24 /* 0xe7d3fbc8 */ (T_MASK ^ 0x182c0437)
-#define T25    0x21e1cde6
-#define T26 /* 0xc33707d6 */ (T_MASK ^ 0x3cc8f829)
-#define T27 /* 0xf4d50d87 */ (T_MASK ^ 0x0b2af278)
-#define T28    0x455a14ed
-#define T29 /* 0xa9e3e905 */ (T_MASK ^ 0x561c16fa)
-#define T30 /* 0xfcefa3f8 */ (T_MASK ^ 0x03105c07)
-#define T31    0x676f02d9
-#define T32 /* 0x8d2a4c8a */ (T_MASK ^ 0x72d5b375)
-#define T33 /* 0xfffa3942 */ (T_MASK ^ 0x0005c6bd)
-#define T34 /* 0x8771f681 */ (T_MASK ^ 0x788e097e)
-#define T35    0x6d9d6122
-#define T36 /* 0xfde5380c */ (T_MASK ^ 0x021ac7f3)
-#define T37 /* 0xa4beea44 */ (T_MASK ^ 0x5b4115bb)
-#define T38    0x4bdecfa9
-#define T39 /* 0xf6bb4b60 */ (T_MASK ^ 0x0944b49f)
-#define T40 /* 0xbebfbc70 */ (T_MASK ^ 0x4140438f)
-#define T41    0x289b7ec6
-#define T42 /* 0xeaa127fa */ (T_MASK ^ 0x155ed805)
-#define T43 /* 0xd4ef3085 */ (T_MASK ^ 0x2b10cf7a)
-#define T44    0x04881d05
-#define T45 /* 0xd9d4d039 */ (T_MASK ^ 0x262b2fc6)
-#define T46 /* 0xe6db99e5 */ (T_MASK ^ 0x1924661a)
-#define T47    0x1fa27cf8
-#define T48 /* 0xc4ac5665 */ (T_MASK ^ 0x3b53a99a)
-#define T49 /* 0xf4292244 */ (T_MASK ^ 0x0bd6ddbb)
-#define T50    0x432aff97
-#define T51 /* 0xab9423a7 */ (T_MASK ^ 0x546bdc58)
-#define T52 /* 0xfc93a039 */ (T_MASK ^ 0x036c5fc6)
-#define T53    0x655b59c3
-#define T54 /* 0x8f0ccc92 */ (T_MASK ^ 0x70f3336d)
-#define T55 /* 0xffeff47d */ (T_MASK ^ 0x00100b82)
-#define T56 /* 0x85845dd1 */ (T_MASK ^ 0x7a7ba22e)
-#define T57    0x6fa87e4f
-#define T58 /* 0xfe2ce6e0 */ (T_MASK ^ 0x01d3191f)
-#define T59 /* 0xa3014314 */ (T_MASK ^ 0x5cfebceb)
-#define T60    0x4e0811a1
-#define T61 /* 0xf7537e82 */ (T_MASK ^ 0x08ac817d)
-#define T62 /* 0xbd3af235 */ (T_MASK ^ 0x42c50dca)
-#define T63    0x2ad7d2bb
-#define T64 /* 0xeb86d391 */ (T_MASK ^ 0x14792c6e)
-
-
-static void
-md5_process(md5_state_t *pms, const uint8_t *data /*[64]*/)
-{
-    uint32_t
-	a = pms->abcd[0], b = pms->abcd[1],
-	c = pms->abcd[2], d = pms->abcd[3];
-    uint32_t t;
-#if BYTE_ORDER > 0
-    /* Define storage only for big-endian CPUs. */
-    uint32_t X[16];
-#else
-    /* Define storage for little-endian or both types of CPUs. */
-    uint32_t xbuf[16];
-    const uint32_t *X;
-#endif
-
-    {
-#if BYTE_ORDER == 0
-	/*
-	 * Determine dynamically whether this is a big-endian or
-	 * little-endian machine, since we can use a more efficient
-	 * algorithm on the latter.
-	 */
-	static const int w = 1;
-
-	if (*((const uint8_t *)&w)) /* dynamic little-endian */
-#endif
-#if BYTE_ORDER <= 0		/* little-endian */
-	{
-	    /*
-	     * On little-endian machines, we can process properly aligned
-	     * data without copying it.
-	     */
-	    if (!((data - (const uint8_t *)0) & 3)) {
-		/* data are properly aligned */
-		X = (const uint32_t *)data;
-	    } else {
-		/* not aligned */
-		memcpy(xbuf, data, 64);
-		X = xbuf;
-	    }
-	}
-#endif
-#if BYTE_ORDER == 0
-	else			/* dynamic big-endian */
-#endif
-#if BYTE_ORDER >= 0		/* big-endian */
-	{
-	    /*
-	     * On big-endian machines, we must arrange the bytes in the
-	     * right order.
-	     */
-	    const uint8_t *xp = data;
-	    int i;
-
-#  if BYTE_ORDER == 0
-	    X = xbuf;		/* (dynamic only) */
-#  else
-#    define xbuf X		/* (static only) */
-#  endif
-	    for (i = 0; i < 16; ++i, xp += 4)
-		xbuf[i] = xp[0] + (xp[1] << 8) + (xp[2] << 16) + (xp[3] << 24);
-	}
-#endif
-    }
-
-#define ROTATE_LEFT(x, n) (((x) << (n)) | ((x) >> (32 - (n))))
-
-    /* Round 1. */
-    /* Let [abcd k s i] denote the operation
-       a = b + ((a + F(b,c,d) + X[k] + T[i]) <<< s). */
-#define F(x, y, z) (((x) & (y)) | (~(x) & (z)))
-#define SET(a, b, c, d, k, s, Ti)\
-  t = a + F(b,c,d) + X[k] + Ti;\
-  a = ROTATE_LEFT(t, s) + b
-    /* Do the following 16 operations. */
-    SET(a, b, c, d,  0,  7,  T1);
-    SET(d, a, b, c,  1, 12,  T2);
-    SET(c, d, a, b,  2, 17,  T3);
-    SET(b, c, d, a,  3, 22,  T4);
-    SET(a, b, c, d,  4,  7,  T5);
-    SET(d, a, b, c,  5, 12,  T6);
-    SET(c, d, a, b,  6, 17,  T7);
-    SET(b, c, d, a,  7, 22,  T8);
-    SET(a, b, c, d,  8,  7,  T9);
-    SET(d, a, b, c,  9, 12, T10);
-    SET(c, d, a, b, 10, 17, T11);
-    SET(b, c, d, a, 11, 22, T12);
-    SET(a, b, c, d, 12,  7, T13);
-    SET(d, a, b, c, 13, 12, T14);
-    SET(c, d, a, b, 14, 17, T15);
-    SET(b, c, d, a, 15, 22, T16);
-#undef SET
-
-     /* Round 2. */
-     /* Let [abcd k s i] denote the operation
-          a = b + ((a + G(b,c,d) + X[k] + T[i]) <<< s). */
-#define G(x, y, z) (((x) & (z)) | ((y) & ~(z)))
-#define SET(a, b, c, d, k, s, Ti)\
-  t = a + G(b,c,d) + X[k] + Ti;\
-  a = ROTATE_LEFT(t, s) + b
-     /* Do the following 16 operations. */
-    SET(a, b, c, d,  1,  5, T17);
-    SET(d, a, b, c,  6,  9, T18);
-    SET(c, d, a, b, 11, 14, T19);
-    SET(b, c, d, a,  0, 20, T20);
-    SET(a, b, c, d,  5,  5, T21);
-    SET(d, a, b, c, 10,  9, T22);
-    SET(c, d, a, b, 15, 14, T23);
-    SET(b, c, d, a,  4, 20, T24);
-    SET(a, b, c, d,  9,  5, T25);
-    SET(d, a, b, c, 14,  9, T26);
-    SET(c, d, a, b,  3, 14, T27);
-    SET(b, c, d, a,  8, 20, T28);
-    SET(a, b, c, d, 13,  5, T29);
-    SET(d, a, b, c,  2,  9, T30);
-    SET(c, d, a, b,  7, 14, T31);
-    SET(b, c, d, a, 12, 20, T32);
-#undef SET
-
-     /* Round 3. */
-     /* Let [abcd k s t] denote the operation
-          a = b + ((a + H(b,c,d) + X[k] + T[i]) <<< s). */
-#define H(x, y, z) ((x) ^ (y) ^ (z))
-#define SET(a, b, c, d, k, s, Ti)\
-  t = a + H(b,c,d) + X[k] + Ti;\
-  a = ROTATE_LEFT(t, s) + b
-     /* Do the following 16 operations. */
-    SET(a, b, c, d,  5,  4, T33);
-    SET(d, a, b, c,  8, 11, T34);
-    SET(c, d, a, b, 11, 16, T35);
-    SET(b, c, d, a, 14, 23, T36);
-    SET(a, b, c, d,  1,  4, T37);
-    SET(d, a, b, c,  4, 11, T38);
-    SET(c, d, a, b,  7, 16, T39);
-    SET(b, c, d, a, 10, 23, T40);
-    SET(a, b, c, d, 13,  4, T41);
-    SET(d, a, b, c,  0, 11, T42);
-    SET(c, d, a, b,  3, 16, T43);
-    SET(b, c, d, a,  6, 23, T44);
-    SET(a, b, c, d,  9,  4, T45);
-    SET(d, a, b, c, 12, 11, T46);
-    SET(c, d, a, b, 15, 16, T47);
-    SET(b, c, d, a,  2, 23, T48);
-#undef SET
-
-     /* Round 4. */
-     /* Let [abcd k s t] denote the operation
-          a = b + ((a + I(b,c,d) + X[k] + T[i]) <<< s). */
-#define I(x, y, z) ((y) ^ ((x) | ~(z)))
-#define SET(a, b, c, d, k, s, Ti)\
-  t = a + I(b,c,d) + X[k] + Ti;\
-  a = ROTATE_LEFT(t, s) + b
-     /* Do the following 16 operations. */
-    SET(a, b, c, d,  0,  6, T49);
-    SET(d, a, b, c,  7, 10, T50);
-    SET(c, d, a, b, 14, 15, T51);
-    SET(b, c, d, a,  5, 21, T52);
-    SET(a, b, c, d, 12,  6, T53);
-    SET(d, a, b, c,  3, 10, T54);
-    SET(c, d, a, b, 10, 15, T55);
-    SET(b, c, d, a,  1, 21, T56);
-    SET(a, b, c, d,  8,  6, T57);
-    SET(d, a, b, c, 15, 10, T58);
-    SET(c, d, a, b,  6, 15, T59);
-    SET(b, c, d, a, 13, 21, T60);
-    SET(a, b, c, d,  4,  6, T61);
-    SET(d, a, b, c, 11, 10, T62);
-    SET(c, d, a, b,  2, 15, T63);
-    SET(b, c, d, a,  9, 21, T64);
-#undef SET
-
-     /* Then perform the following additions. (That is increment each
-        of the four registers by the value it had before this block
-        was started.) */
-    pms->abcd[0] += a;
-    pms->abcd[1] += b;
-    pms->abcd[2] += c;
-    pms->abcd[3] += d;
-}
-
-void
-md5_init(md5_state_t *pms)
-{
-    pms->count[0] = pms->count[1] = 0;
-    pms->abcd[0] = 0x67452301;
-    pms->abcd[1] = /*0xefcdab89*/ T_MASK ^ 0x10325476;
-    pms->abcd[2] = /*0x98badcfe*/ T_MASK ^ 0x67452301;
-    pms->abcd[3] = 0x10325476;
-}
-
-void
-md5_add(md5_state_t *pms, const void *input, size_t size)
-{
-    const uint8_t *p = (const uint8_t *)input;
-    int nbytes = (int)size; // PJ
-    int left = nbytes;
-    int offset = (pms->count[0] >> 3) & 63;
-    uint32_t nbits = (uint32_t)(nbytes << 3);
-
-    if (nbytes <= 0)
-	return;
-
-    /* Update the message length. */
-    pms->count[1] += nbytes >> 29;
-    pms->count[0] += nbits;
-    if (pms->count[0] < nbits)
-	pms->count[1]++;
-
-    /* Process an initial partial block. */
-    if (offset) {
-	int copy = (offset + nbytes > 64 ? 64 - offset : nbytes);
-
-	memcpy(pms->buf + offset, p, copy);
-	if (offset + copy < 64)
-	    return;
-	p += copy;
-	left -= copy;
-	md5_process(pms, pms->buf);
-    }
-
-    /* Process full blocks. */
-    for (; left >= 64; p += 64, left -= 64)
-	md5_process(pms, p);
-
-    /* Process a final partial block. */
-    if (left)
-	memcpy(pms->buf, p, left);
-}
-
-void
-md5_put(md5_state_t *pms, uint8_t digest[16])
-{
-    static const uint8_t pad[64] = {
-	0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
-    };
-    uint8_t data[8];
-    int i;
-
-    /* Save the length before padding. */
-    for (i = 0; i < 8; ++i)
-	data[i] = (uint8_t)(pms->count[i >> 2] >> ((i & 3) << 3));
-    /* Pad to 56 bytes mod 64. */
-    md5_add(pms, pad, ((55 - (pms->count[0] >> 3)) & 63) + 1);
-    /* Append the length. */
-    md5_add(pms, data, 8);
-    for (i = 0; i < 16; ++i)
-	digest[i] = (uint8_t)(pms->abcd[i >> 2] >> ((i & 3) << 3));
-}
-
-/* end of md5.h */
-
-static md5_state_t state;
-
-void md5 (const void *input, size_t length, uint8_t output[16])
-{
-  md5_init(&state);
-  md5_add(&state, input, length);
-  md5_put(&state, output);
-}
-
-void md5init (void)
-{
-  md5_init(&state);
-}
-
-void md5add (const void *input, size_t length)
-{
-  md5_add(&state, input, length);
-}
-
-void md5put (uint8_t output[16])
-{
-  md5_put(&state, output);
-}
--- texlive-bin.orig/texk/web2c/luatexdir/luapplib/util/utilmd5.h
+++ /dev/null
@@ -1,115 +0,0 @@
-#ifndef UTIL_MD5_H
-#define UTIL_MD5_H
-
-#include <stdint.h> // for uintX8_t
-#include <stddef.h> // for size_t
-#include "utildecl.h"
-
-/* begin of md5.h */
-
-/*
-  Copyright (C) 1999, 2002 Aladdin Enterprises.  All rights reserved.
-
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the authors be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-
-  L. Peter Deutsch
-  ghost@aladdin.com
-
- */
-/* $Id: md5.h,v 1.4 2002/04/13 19:20:28 lpd Exp $ */
-/*
-  Independent implementation of MD5 (RFC 1321).
-
-  This code implements the MD5 Algorithm defined in RFC 1321, whose
-  text is available at
-	http://www.ietf.org/rfc/rfc1321.txt
-  The code is derived from the text of the RFC, including the test suite
-  (section A.5) but excluding the rest of Appendix A.  It does not include
-  any code or documentation that is identified in the RFC as being
-  copyrighted.
-
-  The original and principal author of md5.h is L. Peter Deutsch
-  <ghost@aladdin.com>.  Other authors are noted in the change history
-  that follows (in reverse chronological order):
-
-  2002-04-13 lpd Removed support for non-ANSI compilers; removed
-	references to Ghostscript; clarified derivation from RFC 1321;
-	now handles byte order either statically or dynamically.
-  1999-11-04 lpd Edited comments slightly for automatic TOC extraction.
-  1999-10-18 lpd Fixed typo in header comment (ansi2knr rather than md5);
-	added conditionalization for C++ compilation from Martin
-	Purschke <purschke@bnl.gov>.
-  1999-05-03 lpd Original version.
- */
-
-//#ifndef md5_INCLUDED
-//#  define md5_INCLUDED
-
-/*
- * This package supports both compile-time and run-time determination of CPU
- * byte order.  If ARCH_IS_BIG_ENDIAN is defined as 0, the code will be
- * compiled to run only on little-endian CPUs; if ARCH_IS_BIG_ENDIAN is
- * defined as non-zero, the code will be compiled to run only on big-endian
- * CPUs; if ARCH_IS_BIG_ENDIAN is not defined, the code will be compiled to
- * run on either big- or little-endian CPUs, but will run slightly less
- * efficiently on either one than if ARCH_IS_BIG_ENDIAN is defined.
- */
-
-// PJ: replaced with uint8_t and uint32_t
-//typedef unsigned char md5_byte_t; /* 8-bit byte */
-//typedef unsigned int md5_word_t; /* 32-bit word */
-
-/* Define the state of the MD5 Algorithm. */
-typedef struct md5_state_s {
-    uint32_t count[2];	/* message length in bits, lsw first */
-    uint32_t abcd[4];		/* digest buffer */
-    uint8_t buf[64];		/* accumulate block */
-} md5_state_t;
-
-#ifdef __cplusplus
-extern "C" 
-{
-#endif
-
-/* Initialize the algorithm. */
-UTILAPI void pplib_md5_init (md5_state_t *pms);
-
-/* Append a string to the message. */
-//void md5_add(md5_state_t *pms, const uint8_t *data, int nbytes); // PJ
-UTILAPI void md5_add (md5_state_t *pms, const void *input, size_t size);
-
-/* Finish the message and return the digest. */
-//void md5_finish(md5_state_t *pms, uint8_t digest[16]); // PJ
-UTILAPI void md5_put (md5_state_t *pms, uint8_t digest[16]);
-
-#ifdef __cplusplus
-}  /* end extern "C" */
-#endif
-
-//#endif /* md5_INCLUDED */
-
-/* end of md5.h */
-
-#define md5_state md5_state_t
-
-UTILAPI void md5init (void);
-UTILAPI void md5add (const void *input, size_t length);
-UTILAPI void md5put (uint8_t output[16]);
-
-UTILAPI void pplib_md5 (const void *input, size_t length, uint8_t output[16]);
-
-#endif
\ No newline at end of file
--- texlive-bin.orig/texk/web2c/luatexdir/luapplib/util/utilmd5.h.orig
+++ /dev/null
@@ -1,115 +0,0 @@
-#ifndef UTIL_MD5_H
-#define UTIL_MD5_H
-
-#include <stdint.h> // for uintX8_t
-#include <stddef.h> // for size_t
-#include "utildecl.h"
-
-/* begin of md5.h */
-
-/*
-  Copyright (C) 1999, 2002 Aladdin Enterprises.  All rights reserved.
-
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the authors be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-
-  L. Peter Deutsch
-  ghost@aladdin.com
-
- */
-/* $Id: md5.h,v 1.4 2002/04/13 19:20:28 lpd Exp $ */
-/*
-  Independent implementation of MD5 (RFC 1321).
-
-  This code implements the MD5 Algorithm defined in RFC 1321, whose
-  text is available at
-	http://www.ietf.org/rfc/rfc1321.txt
-  The code is derived from the text of the RFC, including the test suite
-  (section A.5) but excluding the rest of Appendix A.  It does not include
-  any code or documentation that is identified in the RFC as being
-  copyrighted.
-
-  The original and principal author of md5.h is L. Peter Deutsch
-  <ghost@aladdin.com>.  Other authors are noted in the change history
-  that follows (in reverse chronological order):
-
-  2002-04-13 lpd Removed support for non-ANSI compilers; removed
-	references to Ghostscript; clarified derivation from RFC 1321;
-	now handles byte order either statically or dynamically.
-  1999-11-04 lpd Edited comments slightly for automatic TOC extraction.
-  1999-10-18 lpd Fixed typo in header comment (ansi2knr rather than md5);
-	added conditionalization for C++ compilation from Martin
-	Purschke <purschke@bnl.gov>.
-  1999-05-03 lpd Original version.
- */
-
-//#ifndef md5_INCLUDED
-//#  define md5_INCLUDED
-
-/*
- * This package supports both compile-time and run-time determination of CPU
- * byte order.  If ARCH_IS_BIG_ENDIAN is defined as 0, the code will be
- * compiled to run only on little-endian CPUs; if ARCH_IS_BIG_ENDIAN is
- * defined as non-zero, the code will be compiled to run only on big-endian
- * CPUs; if ARCH_IS_BIG_ENDIAN is not defined, the code will be compiled to
- * run on either big- or little-endian CPUs, but will run slightly less
- * efficiently on either one than if ARCH_IS_BIG_ENDIAN is defined.
- */
-
-// PJ: replaced with uint8_t and uint32_t
-//typedef unsigned char md5_byte_t; /* 8-bit byte */
-//typedef unsigned int md5_word_t; /* 32-bit word */
-
-/* Define the state of the MD5 Algorithm. */
-typedef struct md5_state_s {
-    uint32_t count[2];	/* message length in bits, lsw first */
-    uint32_t abcd[4];		/* digest buffer */
-    uint8_t buf[64];		/* accumulate block */
-} md5_state_t;
-
-#ifdef __cplusplus
-extern "C" 
-{
-#endif
-
-/* Initialize the algorithm. */
-UTILAPI void md5_init (md5_state_t *pms);
-
-/* Append a string to the message. */
-//void md5_add(md5_state_t *pms, const uint8_t *data, int nbytes); // PJ
-UTILAPI void md5_add (md5_state_t *pms, const void *input, size_t size);
-
-/* Finish the message and return the digest. */
-//void md5_finish(md5_state_t *pms, uint8_t digest[16]); // PJ
-UTILAPI void md5_put (md5_state_t *pms, uint8_t digest[16]);
-
-#ifdef __cplusplus
-}  /* end extern "C" */
-#endif
-
-//#endif /* md5_INCLUDED */
-
-/* end of md5.h */
-
-#define md5_state md5_state_t
-
-UTILAPI void md5init (void);
-UTILAPI void md5add (const void *input, size_t length);
-UTILAPI void md5put (uint8_t output[16]);
-
-UTILAPI void md5 (const void *input, size_t length, uint8_t output[16]);
-
-#endif
\ No newline at end of file
--- texlive-bin.orig/texk/web2c/luatexdir/luapplib/util/utilmem.c
+++ /dev/null
@@ -1,68 +0,0 @@
-
-#include <string.h> // for memcpy
-
-#include "utilmem.h"
-#include "utillog.h"
-
-#ifndef util_memerr
-#  if defined(_WIN64) || defined(__MINGW32__)
-#    define util_memerr(size) { loggerf("ooops, not enough memory (%I64u)", ((unsigned long long)(size))); abort(); }
-#  else
-#    define util_memerr(size) { loggerf("ooops, not enough memory (%llu)", ((unsigned long long)(size))); abort(); }
-#  endif
-#endif
-
-void * util_malloc (size_t size)
-{
-  void *m;
-  if ((m = malloc(size)) == NULL)
-    util_memerr(size);
-  return m;
-}
-
-void * util_calloc (size_t num, size_t size)
-{
-  void *m;
-  if ((m = calloc(num, size)) == NULL)
-    util_memerr(size);
-  return m;
-}
-
-void * util_realloc (void *m, size_t size)
-{
-  if ((m = realloc(m, size)) == NULL)
-    util_memerr(size);
-  return m;
-}
-
-/* common array resizer
-
-data -- the beginning of array
-unit -- sizeof array element
-size -- current array size
-extra -- requested extra size
-space -- pointer to available space
-allocated -- flag indicating if *data has been allocated (with malloc)
-
-*/
-
-void util_resize (void **data, size_t unit, size_t size, size_t extra, size_t *space, int allocated)
-{
-  if (*space == 0)
-    *space = 4; // ... better keep *space non-zero to avoid it
-  do { *space <<= 1; }
-  while (size + extra > *space);
-
-  if (allocated)
-  {
-    *data = util_realloc(*data, *space * unit);
-  }
-  else
-  {
-    void *newdata = util_malloc(*space * unit);
-    if (*data != NULL)
-      memcpy(newdata, *data, size * unit);
-    *data = newdata;
-  }
-}
-
--- texlive-bin.orig/texk/web2c/luatexdir/luapplib/util/utilmem.h
+++ /dev/null
@@ -1,59 +0,0 @@
-
-#ifndef UTIL_MEM_H
-#define UTIL_MEM_H
-
-#include <stdlib.h> // for size_t and alloc functions
-#include "utildecl.h"
-
-UTILAPI void * util_malloc (size_t size);
-UTILAPI void * util_calloc (size_t num, size_t size);
-UTILAPI void * util_realloc (void *m, size_t size);
-
-#define util_free free // not a call
-
-/* arrays */
-
-#define array_header(element_type, integer_type) \
-    element_type *data; integer_type size; integer_type space
-
-#define array_of(element_type) array_header(element_type, size_t)
-
-#define array_data_is_allocated(array) ((array)->data != (void *)((array) + 1))
-
-#define array_create(array, array_type, element_type, init) \
-  (array = (array_type *)util_malloc(sizeof(array_type) + ((init) > 0 ? ((init) * sizeof(element_type)) : 1)), \
-   array_init(array, element_type, init))
-
-#define array_init(array, element_type, init) \
-  ((array)->data = (element_type *)((array) + 1), (array)->size = 0, (array)->space = init)
-
-#define array_init_data(array, element_type, init) \
-  ((array)->data = (element_type *)util_malloc((init) * sizeof(element_type)), (array)->size = 0, (array)->space = init)
-
-#define array_free_data(array) \
-  ((void)(array_data_is_allocated(array) && (util_free((array)->data), 0)))
-
-#define array_free(array) \
-  ((void)(array_free_data(array), (util_free(array), 0)))
-
-void util_resize (void **data, size_t unit, size_t size, size_t extra, size_t *space, int allocated);
-
-#define array_ensure(array, unit, extra) \
-  ((void)((array)->size + (extra) > (array)->space && \
-         (util_resize((void **)(&(array)->data), unit, (array)->size, extra, &(array)->space, array_data_is_allocated(array)), 0)))
-
-#define array_ensure_alloc(array, unit, extra, isalloc) \
-  ((void)((array)->size + (extra) > (array)->space && \
-         (util_resize((void **)(&(array)->data), unit, (array)->size, extra, &(array)->space, isalloc), 0)))
-
-#define array_at(array, index) ((array)->data + index)
-#define array_index(array, index) (index < (array)->size ? array_at(array, index) : NULL)
-#define array_top(array) ((array)->data + (array)->size - 1)
-
-#define array_from_bottom(array, index) array_at(array, index - 1)
-#define array_from_top(array, negindex) array_at(array, (array)->size + (negindex))
-
-#define array_push(array) ((array)->data + ((array)->size)++)
-#define array_pop(array) ((array)->data + --((array)->size))
-
-#endif
--- texlive-bin.orig/texk/web2c/luatexdir/luapplib/util/utilnumber.c
+++ /dev/null
@@ -1,1325 +0,0 @@
-
-#include <math.h> /* for log10() and floor() */
-#include <stdio.h> /* for printf() */
-
-#include "utilnumber.h"
-
-const int base10_lookup[] = {
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-   0, 1, 2, 3, 4, 5, 6, 7, 8, 9,-1,-1,-1,-1,-1,-1,
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1
-};
-
-const int base16_lookup[] = {
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-   0, 1, 2, 3, 4, 5, 6, 7, 8, 9,-1,-1,-1,-1,-1,-1,
-  -1,10,11,12,13,14,15,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  -1,10,11,12,13,14,15,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1
-};
-
-const int base26_lookup[] = {
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  -1, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,
-  16,17,18,19,20,21,22,23,24,25,26,-1,-1,-1,-1,-1,
-  -1, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15,
-  16,17,18,19,20,21,22,23,24,25,26,-1,-1,-1,-1,-1,
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1
-};
-
-const int base36_lookup[] = {
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-   0, 1, 2, 3, 4, 5, 6, 7, 8, 9,-1,-1,-1,-1,-1,-1,
-  -1,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,
-  25,26,27,28,29,30,31,32,33,34,35,-1,-1,-1,-1,-1,
-  -1,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,
-  25,26,27,28,29,30,31,32,33,34,35,-1,-1,-1,-1,-1,
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
-  -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1
-};
-
-/* integer from string; return a pointer to character next to the last digit */
-
-#define string_scan_sign(s, c, sign) _scan_sign(c, sign, *++s)
-#define string_scan_integer(s, c, number) _scan_integer(c, number, *++s)
-#define string_scan_radix(s, c, number, radix) _scan_radix(c, number, radix, *++s)
-#define string_read_integer(s, c, number) _read_integer(c, number, *++s)
-#define string_read_radix(s, c, number, radix) _read_radix(c, number, radix, *++s)
-
-const char * string_to_int32 (const char *s, int32_t *number)
-{
-  int sign, c = *s;
-  string_scan_sign(s, c, sign);
-  string_scan_integer(s, c, *number);
-  if (sign) *number = -*number;
-  return s;
-}
-
-const char * string_to_intlw (const char *s, intlw_t *number)
-{
-  int sign, c = *s;
-  string_scan_sign(s, c, sign);
-  string_scan_integer(s, c, *number);
-  if (sign) *number = -*number;
-  return s;
-}
-
-const char * string_to_int64 (const char *s, int64_t *number)
-{
-  int sign, c = *s;
-  string_scan_sign(s, c, sign);
-  string_scan_integer(s, c, *number);
-  if (sign) *number = -*number;
-  return s;
-}
-
-const char * string_to_uint32 (const char *s, uint32_t *number)
-{
-  int c = *s;
-  string_scan_integer(s, c, *number);
-  return s;
-}
-
-const char * string_to_uintlw (const char *s, uintlw_t *number)
-{
-  int c = *s;
-  string_scan_integer(s, c, *number);
-  return s;
-}
-
-const char * string_to_uint64 (const char *s, uint64_t *number)
-{
-  int c = *s;
-  string_scan_integer(s, c, *number);
-  return s;
-}
-
-const char * radix_to_int32 (const char *s, int32_t *number, int radix)
-{
-  int sign, c = *s;
-  string_scan_sign(s, c, sign);
-  string_scan_radix(s, c, *number, radix);
-  if (sign) *number = -*number;
-  return s;
-}
-
-const char * radix_to_intlw (const char *s, intlw_t *number, int radix)
-{
-  int sign, c = *s;
-  string_scan_sign(s, c, sign);
-  string_scan_radix(s, c, *number, radix);
-  if (sign) *number = -*number;
-  return s;
-}
-
-const char * radix_to_int64 (const char *s, int64_t *number, int radix)
-{
-  int sign, c = *s;
-  string_scan_sign(s, c, sign);
-  string_scan_radix(s, c, *number, radix);
-  if (sign) *number = -*number;
-  return s;
-}
-
-const char * radix_to_uint32 (const char *s, uint32_t *number, int radix)
-{
-  int c = *s;
-  string_scan_radix(s, c, *number, radix);
-  return s;
-}
-
-const char * radix_to_uintlw (const char *s, uintlw_t *number, int radix)
-{
-  int c = *s;
-  string_scan_radix(s, c, *number, radix);
-  return s;
-}
-
-const char * radix_to_uint64 (const char *s, uint64_t *number, int radix)
-{
-  int c = *s;
-  string_scan_radix(s, c, *number, radix);
-  return s;
-}
-
-/* roman to uint16_t */
-
-#define roman1000(c) (c == 'M' || c == 'm')
-#define roman500(c)  (c == 'D' || c == 'd')
-#define roman100(c)  (c == 'C' || c == 'c')
-#define roman50(c)   (c == 'L' || c == 'l')
-#define roman10(c)   (c == 'X' || c == 'x')
-#define roman5(c)    (c == 'V' || c == 'v')
-#define roman1(c)    (c == 'I' || c == 'i')
-
-#define roman100s(p) (roman100(*p) ? (100 + ((++p, roman100(*p)) ? (100 + ((++p, roman100(*p)) ? (++p, 100) : 0)) : 0)) : 0)
-#define roman10s(p) (roman10(*p) ? (10 + ((++p, roman10(*p)) ? (10 + ((++p, roman10(*p)) ? (++p, 10) : 0)) : 0)) : 0)
-#define roman1s(p) (roman1(*p) ? (1 + ((++p, roman1(*p)) ? (1 + ((++p, roman1(*p)) ? (++p, 1) : 0)) : 0)) : 0)
-
-const char * roman_to_uint16 (const char *s, uint16_t *number)
-{
-  const char *p;
-  /* M */
-  for (*number = 0, p = s; roman1000(*p); *number += 1000, ++p);
-  /* D C */
-  if (roman500(*p))
-  {
-    ++p;
-    *number += 500 + roman100s(p);
-  }
-  else if (roman100(*p))
-  {
-    ++p;
-    if (roman1000(*p))
-    {
-      ++p;
-      *number += 900;
-    }
-    else if (roman500(*p))
-    {
-      ++p;
-      *number += 400;
-    }
-    else
-      *number += 100 + roman100s(p);
-  }
-  /* L X */
-  if (roman50(*p))
-  {
-    ++p;
-    *number += 50 + roman10s(p);
-  }
-  else if (roman10(*p))
-  {
-    ++p;
-    if (roman100(*p))
-    {
-      ++p;
-      *number += 90;
-    }
-    else if (roman50(*p))
-    {
-      ++p;
-      *number += 40;
-    }
-    else
-      *number += 10 + roman10s(p);
-  }
-  /* V I */
-  if (roman5(*p))
-  {
-    ++p;
-    *number += 5 + roman1s(p);
-  }
-  else if (roman1(*p))
-  {
-    ++p;
-    if (roman10(*p))
-    {
-      ++p;
-      *number += 9;
-    }
-    else if (roman5(*p))
-    {
-      ++p;
-      *number += 4;
-    }
-    else
-      *number += 1 + roman1s(p);
-  }
-  return p;
-}
-
-/* integer to string; return a pointer to null-terminated static const string */
-
-static char integer_buffer[MAX_INTEGER_DIGITS] = {'\0'};
-#define end_of_integer_buffer (integer_buffer + MAX_INTEGER_DIGITS - 1)
-
-/* writing integers */
-
-#define number_printrev_signed(p, number, quotient) \
-  do { \
-    quotient = number; number /= 10; \
-    *--p = base10_palindrome[9 + (quotient - number*10)]; \
-  } while (number); \
-  if (quotient < 0) *--p = '-'
-
-#define number_printrev_unsigned(p, number, quotient) \
-  do { \
-    quotient = number; number /= 10; \
-    *--p = (char)(quotient - integer_multiplied10(number)) + '0'; \
-  } while (number)
-
-char * int32_as_string (int32_t number, char **e)
-{
-  char *p;
-  int quotient;
-  p = end_of_integer_buffer; *p = '\0';
-  if (e != NULL) *e = p;
-  number_printrev_signed(p, number, quotient);
-  return p;
-}
-
-char * intlw_as_string (intlw_t number, char **e)
-{
-  char *p;
-  intlw_t quotient;
-  p = end_of_integer_buffer; *p = '\0';
-  if (e != NULL) *e = p;
-  number_printrev_signed(p, number, quotient);
-  return p;
-}
-
-char * int64_as_string (int64_t number, char **e)
-{
-  char *p;
-  int64_t quotient;
-  p = end_of_integer_buffer; *p = '\0';
-  if (e != NULL) *e = p;
-  number_printrev_signed(p, number, quotient);
-  return p;
-}
-
-char * uint32_as_string (uint32_t number, char **e)
-{
-  char *p;
-  uint32_t quotient;
-  p = end_of_integer_buffer; *p = '\0';
-  if (e != NULL) *e = p;
-  number_printrev_unsigned(p, number, quotient);
-  return p;
-}
-
-char * uintlw_as_string (uintlw_t number, char **e)
-{
-  char *p;
-  uintlw_t quotient;
-  p = end_of_integer_buffer; *p = '\0';
-  if (e != NULL) *e = p;
-  number_printrev_unsigned(p, number, quotient);
-  return p;
-}
-
-char * uint64_as_string (uint64_t number, char **e)
-{
-  char *p;
-  uint64_t quotient;
-  p = end_of_integer_buffer; *p = '\0';
-  if (e != NULL) *e = p;
-  number_printrev_unsigned(p, number, quotient);
-  return p;
-}
-
-/* radix variant */
-
-#define number_printrev_signed_radix_uc(p, number, radix, quotient) \
-  do { \
-    quotient = number; number /= radix; \
-    *--p = base36_uc_palindrome[MAX_RADIX - 1 + (quotient - number*radix)]; \
-  } while (number)
-
-#define number_printrev_signed_radix_lc(p, number, radix, quotient) \
-  do { \
-    quotient = number; number /= radix; \
-    *--p = base36_lc_palindrome[MAX_RADIX - 1 + (quotient - number*radix)]; \
-  } while (number)
-
-#define number_printrev_signed_radix(p, number, radix, quotient) \
-  do { \
-    if (radix > 0) { number_printrev_signed_radix_uc(p, number, radix, quotient); } \
-    else { radix = -radix; number_printrev_signed_radix_lc(p, number, radix, quotient); } \
-    if (quotient < 0) *--p = '-'; \
-  } while (0)
-
-#define number_printrev_unsigned_radix_uc(p, number, radix, quotient) \
-  do { \
-    quotient = number; number /= radix; \
-    *--p = base36_uc_alphabet[quotient % radix]; \
-  } while (number)
-
-#define number_printrev_unsigned_radix_lc(p, number, radix, quotient) \
-  do { \
-    quotient = number; number /= radix; \
-    *--p = base36_lc_alphabet[quotient % radix]; \
-  } while (number)
-
-#define number_printrev_unsigned_radix(p, number, radix, quotient) \
-  do { \
-    if (radix > 0) { number_printrev_unsigned_radix_uc(p, number, radix, quotient); } \
-    else { radix = -radix; number_printrev_unsigned_radix_lc(p, number, radix, quotient); } \
-  } while (0)
-
-char * int32_as_radix (int number, int radix, char **e)
-{
-  char *p;
-  int quotient;
-  p = end_of_integer_buffer; *p = '\0';
-  if (e != NULL) *e = p;
-  number_printrev_signed_radix(p, number, radix, quotient);
-  return p;
-}
-
-char * intlw_as_radix (intlw_t number, int radix, char **e)
-{
-  char *p;
-  intlw_t quotient;
-  p = end_of_integer_buffer; *p = '\0';
-  if (e != NULL) *e = p;
-  number_printrev_signed_radix(p, number, radix, quotient);
-  return p;
-}
-
-char * int64_as_radix (int64_t number, int radix, char **e)
-{
-  char *p;
-  int64_t quotient;
-  p = end_of_integer_buffer; *p = '\0';
-  if (e != NULL) *e = p;
-  number_printrev_signed_radix(p, number, radix, quotient);
-  return p;
-}
-
-char * uint32_as_radix (uint32_t number, int radix, char **e)
-{
-  char *p;
-  uint32_t quotient;
-  p = end_of_integer_buffer; *p = '\0';
-  if (e != NULL) *e = p;
-  number_printrev_unsigned_radix(p, number, radix, quotient);
-  return p;
-}
-
-char * uintlw_as_radix (uintlw_t number, int radix, char **e)
-{
-  char *p;
-  uintlw_t quotient;
-  p = end_of_integer_buffer; *p = '\0';
-  if (e != NULL) *e = p;
-  number_printrev_unsigned_radix(p, number, radix, quotient);
-  return p;
-}
-
-char * uint64_as_radix (uint64_t number, int radix, char **e)
-{
-  char *p;
-  uint64_t quotient;
-  p = end_of_integer_buffer; *p = '\0';
-  if (e != NULL) *e = p;
-  number_printrev_unsigned_radix(p, number, radix, quotient);
-  return p;
-}
-
-/* aaa, aab, aac, ...; unsigned only. 0 gives empty string */
-
-#define string_scan_alpha(s, c, number, radix) \
-  for (number = 0, c = *s; (c = base26_value(c)) > 0; number = number * radix + c, c = *++s)
-
-const char * alpha_to_uint32 (const char *s, uint32_t *number)
-{
-  int c;
-  string_scan_alpha(s, c, *number, 26);
-  return s;
-}
-
-const char * alpha_to_uintlw (const char *s, uintlw_t *number)
-{
-  int c;
-  string_scan_alpha(s, c, *number, 26);
-  return s;
-}
-
-const char * alpha_to_uint64 (const char *s, uint64_t *number)
-{
-  int c;
-  string_scan_alpha(s, c, *number, 26);
-  return s;
-}
-
-#define number_printrev_unsigned_alpha_uc(p, number, radix, quotient) \
-  while (number > 0) { \
-    quotient = --number; number /= radix; \
-    *--p = base26_uc_alphabet[quotient % radix]; \
-  }
-
-#define number_printrev_unsigned_alpha_lc(p, number, radix, quotient) \
-  while (number > 0) { \
-    quotient = --number; number /= radix; \
-    *--p = base26_lc_alphabet[quotient % radix]; \
-  }
-
-char * uint32_as_alpha_uc (uint32_t number, char **e)
-{
-  char *p;
-  uint32_t quotient;
-  p = end_of_integer_buffer; *p = '\0';
-  if (e != NULL) *e = p;
-  number_printrev_unsigned_alpha_uc(p, number, 26, quotient);
-  return p;
-}
-
-char * uint32_as_alpha_lc (uint32_t number, char **e)
-{
-  char *p;
-  uint32_t quotient;
-  p = end_of_integer_buffer; *p = '\0';
-  if (e != NULL) *e = p;
-  number_printrev_unsigned_alpha_lc(p, number, 26, quotient);
-  return p;
-}
-
-char * uintlw_as_alpha_uc (uintlw_t number, char **e)
-{
-  char *p;
-  uintlw_t quotient;
-  p = end_of_integer_buffer; *p = '\0';
-  if (e != NULL) *e = p;
-  number_printrev_unsigned_alpha_uc(p, number, 26, quotient);
-  return p;
-}
-
-char * uintlw_as_alpha_lc (uintlw_t number, char **e)
-{
-  char *p;
-  uintlw_t quotient;
-  p = end_of_integer_buffer; *p = '\0';
-  if (e != NULL) *e = p;
-  number_printrev_unsigned_alpha_lc(p, number, 26, quotient);
-  return p;
-}
-
-char * uint64_as_alpha_uc (uint64_t number, char **e)
-{
-  char *p;
-  uint64_t quotient;
-  p = end_of_integer_buffer; *p = '\0';
-  if (e != NULL) *e = p;
-  number_printrev_unsigned_alpha_uc(p, number, 26, quotient);
-  return p;
-}
-
-char * uint64_as_alpha_lc (uint64_t number, char **e)
-{
-  char *p;
-  uint64_t quotient;
-  p = end_of_integer_buffer; *p = '\0';
-  if (e != NULL) *e = p;
-  number_printrev_unsigned_alpha_lc(p, number, 26, quotient);
-  return p;
-}
-
-/* a variant of alphabetic, a, b, c, ..., z, aa, bb, cc, ..., zz (eg. pdf page labelling) */
-
-#define string_scan_alphan(s, c, number, radix) \
-  do { \
-    number = 0; \
-    if ((c = base26_value(*s)) > 0) { \
-      number = c; \
-      while (c == base26_value(*++s)) number += radix; \
-    }  \
-  } while (0)
-
-const char * alphan_to_uint32 (const char *s, uint32_t *number)
-{
-  int c;
-  string_scan_alphan(s, c, *number, 26);
-  return s;
-}
-
-const char * alphan_to_uintlw (const char *s, uintlw_t *number)
-{
-  int c;
-  string_scan_alphan(s, c, *number, 26);
-  return s;
-}
-
-const char * alphan_to_uint64 (const char *s, uintlw_t *number)
-{
-  int c;
-  string_scan_alphan(s, c, *number, 26);
-  return s;
-}
-
-#define number_print_alphan_uc(s, c, number, radix) \
-  if (number > 0) { \
-    for (c = (--number) % radix, number -= c; ; number -= radix) { \
-      *s++ = base26_uc_alphabet[c]; \
-       if (number == 0 || p >= end_of_integer_buffer) break; \
-    } \
-  }
-
-#define number_print_alphan_lc(s, c, number, radix) \
-  if (number > 0) { \
-    for (c = (--number) % radix, number -= c; ; number -= radix) { \
-      *s++ = base26_lc_alphabet[c]; \
-       if (number == 0 || p >= end_of_integer_buffer) break; \
-    } \
-  }
-
-char * uint32_as_alphan_uc (uint32_t number, char **e)
-{
-  char *p;
-  uint8_t c;
-  p = integer_buffer;
-  number_print_alphan_uc(p, c, number, 26);
-  *p = '\0'; if (e != NULL) *e = p;
-  return integer_buffer;
-}
-
-char * uint32_as_alphan_lc (uint32_t number, char **e)
-{
-  char *p;
-  uint8_t c;
-  p = integer_buffer;
-  number_print_alphan_lc(p, c, number, 26);
-  *p = '\0'; if (e != NULL) *e = p;
-  return integer_buffer;
-}
-
-char * uintlw_as_alphan_uc (uintlw_t number, char **e)
-{
-  char *p;
-  uint8_t c;
-  p = integer_buffer;
-  number_print_alphan_uc(p, c, number, 26);
-  *p = '\0'; if (e != NULL) *e = p;
-  return integer_buffer;
-}
-
-char * uintlw_as_alphan_lc (uintlw_t number, char **e)
-{
-  char *p;
-  uint8_t c;
-  p = integer_buffer;
-  number_print_alphan_lc(p, c, number, 26);
-  *p = '\0'; if (e != NULL) *e = p;
-  return integer_buffer;
-}
-
-char * uint64_as_alphan_uc (uint64_t number, char **e)
-{
-  char *p;
-  uint8_t c;
-  p = integer_buffer;
-  number_print_alphan_uc(p, c, number, 26);
-  *p = '\0'; if (e != NULL) *e = p;
-  return integer_buffer;
-}
-
-char * uint64_as_alphan_lc (uint64_t number, char **e)
-{
-  char *p;
-  uint8_t c;
-  p = integer_buffer;
-  number_print_alphan_lc(p, c, number, 26);
-  *p = '\0'; if (e != NULL) *e = p;
-  return integer_buffer;
-}
-
-/* roman numeral */
-
-/* todo: large roman numerals? http://mathforum.org/library/drmath/view/57569.html */
-
-#define base_roman_uc_alphabet "MDCLXVI"
-#define base_roman_lc_alphabet "mdclxvi"
-
-static const uint32_t base_roman_values[] = { 1000, 500, 100, 50, 10, 5, 1 };
-
-#define integer_to_roman(p, number, alphabet) \
-  { \
-    uint32_t k, j, v, u; \
-    for (j = 0, v = base_roman_values[0]; number > 0; ) \
-    { \
-      if (number >= v) \
-      { \
-       *p++ = alphabet[j]; \
-       number -= v; \
-       continue; \
-      } \
-      if (j & 1) \
-        k = j + 1; \
-      else \
-        k = j + 2; \
-      u = base_roman_values[k]; \
-      if (number + u >= v) \
-      { \
-        *p++ = alphabet[k]; \
-        number += u; \
-      } \
-      else \
-        v = base_roman_values[++j]; \
-    } \
-  }
-
-char * uint16_as_roman_uc (uint16_t number, char **e)
-{
-  char *p = integer_buffer;
-  integer_to_roman(p, number, base_roman_uc_alphabet);
-  if (e != NULL)
-    *e = p;
-  *p = '\0';
-  return integer_buffer;
-}
-
-char * uint16_as_roman_lc (uint16_t number, char **e)
-{
-  char *p = integer_buffer;
-  integer_to_roman(p, number, base_roman_lc_alphabet);
-  if (e != NULL)
-    *e = p;
-  *p = '\0';
-  return integer_buffer;
-}
-
-/* IEEE-754 */
-
-#define BINARY_MODF    1
-
-#define NOT_A_NUMBER_STRING "NaN"
-#define INFINITY_STRING "INF"
-#define SIGNED_INFINITY 1
-#define SIGNED_ZERO 0
-#define SIGNED_NOT_A_NUMBER 0
-#define RADIX_CHAR '.'
-
-/* double/float to decimal */
-
-typedef struct ieee_double {
-  union {
-    double number;
-    uint64_t bits;
-  };
-  uint64_t fraction;
-  int exponent, sign;
-} ieee_double;
-
-typedef struct ieee_float {
-  union {
-    float number;
-    uint32_t bits;
-  };
-  uint32_t fraction;
-  int exponent, sign;
-} ieee_float;
-
-#define IEEE_DOUBLE_BIAS           1023
-#define IEEE_DOUBLE_MIN_EXPONENT  -1023
-#define IEEE_DOUBLE_MAX_EXPONENT  (0x7ff - IEEE_DOUBLE_BIAS)
-
-#define IEEE_FLOAT_BIAS            127
-#define IEEE_FLOAT_MIN_EXPONENT   -127
-#define IEEE_FLOAT_MAX_EXPONENT   (0xff - IEEE_FLOAT_BIAS)
-
-#define ieee_double_fraction(i) (i & 0x000fffffffffffffull)
-#define ieee_double_exponent(i) ((0x7ff & (i >> 52)) - IEEE_DOUBLE_BIAS)
-#define ieee_double_sign(ieee_number) ((void)((ieee_number.sign = ieee_number.bits >> 63) && (ieee_number.number = -ieee_number.number)))
-#define ieee_double_init(ieee_number, number) \
-  ieee_number.number = number, \
-  ieee_number.fraction = ieee_double_fraction(ieee_number.bits), \
-  ieee_number.exponent = ieee_double_exponent(ieee_number.bits)
-
-#define ieee_float_fraction(i) (i & 0x007fffff)
-#define ieee_float_exponent(i) ((0xff & (i >> 23)) - IEEE_FLOAT_BIAS)
-#define ieee_float_sign(ieee_number) ((void)((ieee_number.sign = ieee_number.bits >> 31) && (ieee_number.number = -ieee_number.number)))
-#define ieee_float_init(ieee_number, number) \
-  ieee_number.number = number, \
-  ieee_number.fraction = ieee_float_fraction(ieee_number.bits), \
-  ieee_number.exponent = ieee_float_exponent(ieee_number.bits)
-
-/* special cases  */
-
-#define ieee_double_is_zero(ieee_number) (ieee_number.number == 0) // || ieee_double_too_small(ieee_number) ?
-#define ieee_double_too_small(ieee_number) (ieee_number.exponent == 0 && ieee_number.fraction != 0) // denormalized, implicit fracion bit not set
-
-#define ieee_float_is_zero(ieee_number) (ieee_number.number == 0) // || ieee_float_too_small(ieee_number) ?
-#define ieee_float_too_small(ieee_number) (ieee_number.exponent == 0 && ieee_number.fraction != 0)
-
-#define ieee_double_zero_string(ieee_number) (SIGNED_ZERO && ieee_number.sign ? "-0" : "0")
-#define ieee_double_infinity_string(ieee_number) (SIGNED_INFINITY && ieee_number.sign ? "-" INFINITY_STRING : INFINITY_STRING)
-
-#define ieee_float_zero_string ieee_double_zero_string
-#define ieee_float_infinity_string ieee_double_infinity_string
-
-#define ieee_double_special_case(ieee_number) (ieee_number.exponent == IEEE_DOUBLE_MAX_EXPONENT)
-#define ieee_double_special_string(ieee_number) (ieee_number.fraction ? NOT_A_NUMBER_STRING : ieee_double_infinity_string(ieee_number))
-
-#define ieee_float_special_case(ieee_number) (ieee_number.exponent == IEEE_FLOAT_MAX_EXPONENT)
-#define ieee_float_special_string(ieee_number) (ieee_number.fraction ? NOT_A_NUMBER_STRING : ieee_float_infinity_string(ieee_number))
-
-#if 0
-
-const double double_binary_power10[] =
-{
-  1.0e1, 1.0e2, 1.0e4, 1.0e8, 1.0e16, 1.0e32, 1.0e64, 1.0e128, 1.0e256
-};
-
-const float float_binary_power10[] =
-{
-  1.0e1, 1.0e2, 1.0e4, 1.0e8, 1.0e16, 1.0e32
-};
-
-const double double_binary_negpower10[] =
-{
-  1.0e-1, 1.0e-2, 1.0e-4, 1.0e-8, 1.0e-16, 1.0e-32
-};
-
-const float float_binary_negpower10[] =
-{
-  1.0e-1, 1.0e-2, 1.0e-4, 1.0e-8, 1.0e-16, 1.0e-32
-};
-
-#else
-
-const double double_decimal_power10[] = {
-    1.0e0,   1.0e1,   1.0e2,   1.0e3,   1.0e4,   1.0e5,   1.0e6,   1.0e7,   1.0e8,   1.0e9,
-   1.0e10,  1.0e11,  1.0e12,  1.0e13,  1.0e14,  1.0e15,  1.0e16,  1.0e17,  1.0e18,  1.0e19,
-   1.0e20,  1.0e21,  1.0e22,  1.0e23,  1.0e24,  1.0e25,  1.0e26,  1.0e27,  1.0e28,  1.0e29,
-   1.0e30,  1.0e31,  1.0e32,  1.0e33,  1.0e34,  1.0e35,  1.0e36,  1.0e37,  1.0e38,  1.0e39,
-   1.0e40,  1.0e41,  1.0e42,  1.0e43,  1.0e44,  1.0e45,  1.0e46,  1.0e47,  1.0e48,  1.0e49,
-   1.0e50,  1.0e51,  1.0e52,  1.0e53,  1.0e54,  1.0e55,  1.0e56,  1.0e57,  1.0e58,  1.0e59,
-   1.0e60,  1.0e61,  1.0e62,  1.0e63,  1.0e64,  1.0e65,  1.0e66,  1.0e67,  1.0e68,  1.0e69,
-   1.0e70,  1.0e71,  1.0e72,  1.0e73,  1.0e74,  1.0e75,  1.0e76,  1.0e77,  1.0e78,  1.0e79,
-   1.0e80,  1.0e81,  1.0e82,  1.0e83,  1.0e84,  1.0e85,  1.0e86,  1.0e87,  1.0e88,  1.0e89,
-   1.0e90,  1.0e91,  1.0e92,  1.0e93,  1.0e94,  1.0e95,  1.0e96,  1.0e97,  1.0e98,  1.0e99,
-  1.0e100, 1.0e101, 1.0e102, 1.0e103, 1.0e104, 1.0e105, 1.0e106, 1.0e107, 1.0e108, 1.0e109,
-  1.0e110, 1.0e111, 1.0e112, 1.0e113, 1.0e114, 1.0e115, 1.0e116, 1.0e117, 1.0e118, 1.0e119,
-  1.0e120, 1.0e121, 1.0e122, 1.0e123, 1.0e124, 1.0e125, 1.0e126, 1.0e127, 1.0e128, 1.0e129,
-  1.0e130, 1.0e131, 1.0e132, 1.0e133, 1.0e134, 1.0e135, 1.0e136, 1.0e137, 1.0e138, 1.0e139,
-  1.0e140, 1.0e141, 1.0e142, 1.0e143, 1.0e144, 1.0e145, 1.0e146, 1.0e147, 1.0e148, 1.0e149,
-  1.0e150, 1.0e151, 1.0e152, 1.0e153, 1.0e154, 1.0e155, 1.0e156, 1.0e157, 1.0e158, 1.0e159,
-  1.0e160, 1.0e161, 1.0e162, 1.0e163, 1.0e164, 1.0e165, 1.0e166, 1.0e167, 1.0e168, 1.0e169,
-  1.0e170, 1.0e171, 1.0e172, 1.0e173, 1.0e174, 1.0e175, 1.0e176, 1.0e177, 1.0e178, 1.0e179,
-  1.0e180, 1.0e181, 1.0e182, 1.0e183, 1.0e184, 1.0e185, 1.0e186, 1.0e187, 1.0e188, 1.0e189,
-  1.0e190, 1.0e191, 1.0e192, 1.0e193, 1.0e194, 1.0e195, 1.0e196, 1.0e197, 1.0e198, 1.0e199,
-  1.0e200, 1.0e201, 1.0e202, 1.0e203, 1.0e204, 1.0e205, 1.0e206, 1.0e207, 1.0e208, 1.0e209,
-  1.0e210, 1.0e211, 1.0e212, 1.0e213, 1.0e214, 1.0e215, 1.0e216, 1.0e217, 1.0e218, 1.0e219,
-  1.0e220, 1.0e221, 1.0e222, 1.0e223, 1.0e224, 1.0e225, 1.0e226, 1.0e227, 1.0e228, 1.0e229,
-  1.0e230, 1.0e231, 1.0e232, 1.0e233, 1.0e234, 1.0e235, 1.0e236, 1.0e237, 1.0e238, 1.0e239,
-  1.0e240, 1.0e241, 1.0e242, 1.0e243, 1.0e244, 1.0e245, 1.0e246, 1.0e247, 1.0e248, 1.0e249,
-  1.0e250, 1.0e251, 1.0e252, 1.0e253, 1.0e254, 1.0e255, 1.0e256, 1.0e257, 1.0e258, 1.0e259,
-  1.0e260, 1.0e261, 1.0e262, 1.0e263, 1.0e264, 1.0e265, 1.0e266, 1.0e267, 1.0e268, 1.0e269,
-  1.0e270, 1.0e271, 1.0e272, 1.0e273, 1.0e274, 1.0e275, 1.0e276, 1.0e277, 1.0e278, 1.0e279,
-  1.0e280, 1.0e281, 1.0e282, 1.0e283, 1.0e284, 1.0e285, 1.0e286, 1.0e287, 1.0e288, 1.0e289,
-  1.0e290, 1.0e291, 1.0e292, 1.0e293, 1.0e294, 1.0e295, 1.0e296, 1.0e297, 1.0e298, 1.0e299,
-  1.0e300, 1.0e301, 1.0e302, 1.0e303, 1.0e304, 1.0e305, 1.0e306, 1.0e307, 1.0e308
-};
-
-const float float_decimal_power10[] = {
-    1.0e0f,   1.0e1f,   1.0e2f,   1.0e3f,   1.0e4f,   1.0e5f,   1.0e6f,   1.0e7f,   1.0e8f,   1.0e9f,
-   1.0e10f,  1.0e11f,  1.0e12f,  1.0e13f,  1.0e14f,  1.0e15f,  1.0e16f,  1.0e17f,  1.0e18f,  1.0e19f,
-   1.0e20f,  1.0e21f,  1.0e22f,  1.0e23f,  1.0e24f,  1.0e25f,  1.0e26f,  1.0e27f,  1.0e28f,  1.0e29f,
-   1.0e30f,  1.0e31f,  1.0e32f,  1.0e33f,  1.0e34f,  1.0e35f,  1.0e36f,  1.0e37f,  1.0e38f
-};
-
-const double double_decimal_negpower10[] = {
-    1.0e0,   1.0e-1,   1.0e-2,   1.0e-3,   1.0e-4,   1.0e-5,   1.0e-6,   1.0e-7,   1.0e-8,   1.0e-9,
-   1.0e-10,  1.0e-11,  1.0e-12,  1.0e-13,  1.0e-14,  1.0e-15,  1.0e-16,  1.0e-17,  1.0e-18,  1.0e-19,
-   1.0e-20,  1.0e-21,  1.0e-22,  1.0e-23,  1.0e-24,  1.0e-25,  1.0e-26,  1.0e-27,  1.0e-28,  1.0e-29,
-   1.0e-30,  1.0e-31,  1.0e-32,  1.0e-33,  1.0e-34,  1.0e-35,  1.0e-36,  1.0e-37,  1.0e-38,  1.0e-39,
-   1.0e-40,  1.0e-41,  1.0e-42,  1.0e-43,  1.0e-44,  1.0e-45,  1.0e-46,  1.0e-47,  1.0e-48,  1.0e-49,
-   1.0e-50,  1.0e-51,  1.0e-52,  1.0e-53,  1.0e-54,  1.0e-55,  1.0e-56,  1.0e-57,  1.0e-58,  1.0e-59,
-   1.0e-60,  1.0e-61,  1.0e-62,  1.0e-63,  1.0e-64,  1.0e-65,  1.0e-66,  1.0e-67,  1.0e-68,  1.0e-69,
-   1.0e-70,  1.0e-71,  1.0e-72,  1.0e-73,  1.0e-74,  1.0e-75,  1.0e-76,  1.0e-77,  1.0e-78,  1.0e-79,
-   1.0e-80,  1.0e-81,  1.0e-82,  1.0e-83,  1.0e-84,  1.0e-85,  1.0e-86,  1.0e-87,  1.0e-88,  1.0e-89,
-   1.0e-90,  1.0e-91,  1.0e-92,  1.0e-93,  1.0e-94,  1.0e-95,  1.0e-96,  1.0e-97,  1.0e-98,  1.0e-99,
-  1.0e-100, 1.0e-101, 1.0e-102, 1.0e-103, 1.0e-104, 1.0e-105, 1.0e-106, 1.0e-107, 1.0e-108, 1.0e-109,
-  1.0e-110, 1.0e-111, 1.0e-112, 1.0e-113, 1.0e-114, 1.0e-115, 1.0e-116, 1.0e-117, 1.0e-118, 1.0e-119,
-  1.0e-120, 1.0e-121, 1.0e-122, 1.0e-123, 1.0e-124, 1.0e-125, 1.0e-126, 1.0e-127, 1.0e-128, 1.0e-129,
-  1.0e-130, 1.0e-131, 1.0e-132, 1.0e-133, 1.0e-134, 1.0e-135, 1.0e-136, 1.0e-137, 1.0e-138, 1.0e-139,
-  1.0e-140, 1.0e-141, 1.0e-142, 1.0e-143, 1.0e-144, 1.0e-145, 1.0e-146, 1.0e-147, 1.0e-148, 1.0e-149,
-  1.0e-150, 1.0e-151, 1.0e-152, 1.0e-153, 1.0e-154, 1.0e-155, 1.0e-156, 1.0e-157, 1.0e-158, 1.0e-159,
-  1.0e-160, 1.0e-161, 1.0e-162, 1.0e-163, 1.0e-164, 1.0e-165, 1.0e-166, 1.0e-167, 1.0e-168, 1.0e-169,
-  1.0e-170, 1.0e-171, 1.0e-172, 1.0e-173, 1.0e-174, 1.0e-175, 1.0e-176, 1.0e-177, 1.0e-178, 1.0e-179,
-  1.0e-180, 1.0e-181, 1.0e-182, 1.0e-183, 1.0e-184, 1.0e-185, 1.0e-186, 1.0e-187, 1.0e-188, 1.0e-189,
-  1.0e-190, 1.0e-191, 1.0e-192, 1.0e-193, 1.0e-194, 1.0e-195, 1.0e-196, 1.0e-197, 1.0e-198, 1.0e-199,
-  1.0e-200, 1.0e-201, 1.0e-202, 1.0e-203, 1.0e-204, 1.0e-205, 1.0e-206, 1.0e-207, 1.0e-208, 1.0e-209,
-  1.0e-210, 1.0e-211, 1.0e-212, 1.0e-213, 1.0e-214, 1.0e-215, 1.0e-216, 1.0e-217, 1.0e-218, 1.0e-219,
-  1.0e-220, 1.0e-221, 1.0e-222, 1.0e-223, 1.0e-224, 1.0e-225, 1.0e-226, 1.0e-227, 1.0e-228, 1.0e-229,
-  1.0e-230, 1.0e-231, 1.0e-232, 1.0e-233, 1.0e-234, 1.0e-235, 1.0e-236, 1.0e-237, 1.0e-238, 1.0e-239,
-  1.0e-240, 1.0e-241, 1.0e-242, 1.0e-243, 1.0e-244, 1.0e-245, 1.0e-246, 1.0e-247, 1.0e-248, 1.0e-249,
-  1.0e-250, 1.0e-251, 1.0e-252, 1.0e-253, 1.0e-254, 1.0e-255, 1.0e-256, 1.0e-257, 1.0e-258, 1.0e-259,
-  1.0e-260, 1.0e-261, 1.0e-262, 1.0e-263, 1.0e-264, 1.0e-265, 1.0e-266, 1.0e-267, 1.0e-268, 1.0e-269,
-  1.0e-270, 1.0e-271, 1.0e-272, 1.0e-273, 1.0e-274, 1.0e-275, 1.0e-276, 1.0e-277, 1.0e-278, 1.0e-279,
-  1.0e-280, 1.0e-281, 1.0e-282, 1.0e-283, 1.0e-284, 1.0e-285, 1.0e-286, 1.0e-287, 1.0e-288, 1.0e-289,
-  1.0e-290, 1.0e-291, 1.0e-292, 1.0e-293, 1.0e-294, 1.0e-295, 1.0e-296, 1.0e-297, 1.0e-298, 1.0e-299,
-  1.0e-300, 1.0e-301, 1.0e-302, 1.0e-303, 1.0e-304, 1.0e-305, 1.0e-306, 1.0e-307, 1.0e-308
-};
-
-const float float_decimal_negpower10[] = {
-     1.0e0f,   1.0e-1f,   1.0e-2f,   1.0e-3f,   1.0e-4f,   1.0e-5f,   1.0e-6f,   1.0e-7f,   1.0e-8f,   1.0e-9f,
-   1.0e-10f,  1.0e-11f,  1.0e-12f,  1.0e-13f,  1.0e-14f,  1.0e-15f,  1.0e-16f,  1.0e-17f,  1.0e-18f,  1.0e-19f,
-   1.0e-20f,  1.0e-21f,  1.0e-22f,  1.0e-23f,  1.0e-24f,  1.0e-25f,  1.0e-26f,  1.0e-27f,  1.0e-28f,  1.0e-29f,
-   1.0e-30f,  1.0e-31f,  1.0e-32f,  1.0e-33f,  1.0e-34f,  1.0e-35f,  1.0e-36f,  1.0e-37f,  1.0e-38f
-};
-
-#endif
-
-/* scale number by floor(log10(number)) + 1 so that the result is in range [0.1, 1) */
-
-#define ieee_double_exponent10(ieee_number) ((int)floor(log10(ieee_number.number)) + 1)
-#define ieee_float_exponent10(ieee_number) ((int)floorf(log10f(ieee_number.number)) + 1) // floorf, log10f ?
-
-#define ieee_double_exp10(ieee_number, exponent10) \
-  exponent10 = ieee_double_exponent10(ieee_number); \
-  if (exponent10 > 0) { \
-    double_negative_exp10(ieee_number.number, -exponent10); \
-    ieee_number.fraction = ieee_double_fraction(ieee_number.bits); \
-    ieee_number.exponent = ieee_double_exponent(ieee_number.bits); \
-  } else if (exponent10 < 0) { \
-    double_positive_exp10(ieee_number.number, -exponent10); \
-    ieee_number.fraction = ieee_double_fraction(ieee_number.bits); \
-    ieee_number.exponent = ieee_double_exponent(ieee_number.bits); \
-  }
-
-#define ieee_float_exp10(ieee_number, exponent10) \
-  exponent10 = ieee_float_exponent10(ieee_number); \
-  if (exponent10 > 0) { \
-    float_negative_exp10(ieee_number.number, -exponent10); \
-    ieee_number.fraction = ieee_float_fraction(ieee_number.bits); \
-    ieee_number.exponent = ieee_float_exponent(ieee_number.bits); \
-  } else if (exponent10 < 0) { \
-    float_positive_exp10(ieee_number.number, -exponent10); \
-    ieee_number.fraction = ieee_float_fraction(ieee_number.bits); \
-    ieee_number.exponent = ieee_float_exponent(ieee_number.bits); \
-  }
-
-#if BINARY_MODF
-
-/* unhide implicit bit 53, produce 56-bit denormalised fraction (binary exponent already in range [-4, -1]) */
-
-#define ieee_double_denormalize(ieee_number) \
-  (ieee_number.exponent == IEEE_DOUBLE_MIN_EXPONENT ? (++ieee_number.exponent, 0) : (ieee_number.fraction |= (1ull<<52))), \
-  ieee_number.fraction <<= (ieee_number.exponent + 4)
-
-/* unhide implicit bit 24, produce 27-bit denormalized fraction (binary exponent already in range [-4, -1]) */
-
-#define ieee_float_denormalize(ieee_number) \
-  (ieee_number.exponent == IEEE_FLOAT_MIN_EXPONENT ? (++ieee_number.exponent, 0) : (ieee_number.fraction |= (1<<23))), \
-  ieee_number.fraction <<= (ieee_number.exponent + 4)
-
-/* turn off significant bits over 56 (integer part), multiply by 10, return new integer part (subsequent decimal digit) */
-
-#define ieee_double_binary_fraction(ieee_number) \
-  (ieee_number.fraction &= ((1ull<<56) - 1), \
-   ieee_number.fraction = (ieee_number.fraction << 1) + (ieee_number.fraction << 3), \
-   ieee_number.fraction >> 56)
-
-/* turn off significant bits over 27 (integer part), multiply by 10, return the integer part (subsequent decimal digit) */
-
-#define ieee_float_binary_fraction(ieee_number) \
-  (ieee_number.fraction &= ((1<<27) - 1), \
-   ieee_number.fraction = (ieee_number.fraction << 1) + (ieee_number.fraction << 3), \
-   ieee_number.fraction >> 27)
-
-#define ieee_double_decimal(ieee_number, exponent10, digits, p) \
-  ieee_number_decimal(ieee_double_binary_fraction, ieee_number, exponent10, digits, p)
-#define ieee_float_decimal(ieee_number, exponent10, digits, p) \
-  ieee_number_decimal(ieee_float_binary_fraction, ieee_number, exponent10, digits, p)
-#define ieee_double_decimal_dot(ieee_number, exponent10, digits, p, dot) \
-  ieee_number_decimal_dot(ieee_double_binary_fraction, ieee_number, exponent10, digits, p, dot)
-#define ieee_float_decimal_dot(ieee_number, exponent10, digits, p, dot) \
-  ieee_number_decimal_dot(ieee_float_binary_fraction, ieee_number, exponent10, digits, p, dot)
-
-#else
-
-/* generic method */
-
-#define ieee_double_decimal_fraction(ieee_number, i) (ieee_number.number = modf(10*ieee_number.number, &i), i)
-#define ieee_float_decimal_fraction(ieee_number, i) (ieee_number.number = (float)modf(10*ieee_number.number, &i), i) // ???
-
-#define ieee_double_decimal(ieee_number, exponent10, digits, p) \
-  ieee_number_decimal(ieee_double_decimal_fraction, ieee_number, exponent10, digits, p)
-#define ieee_float_decimal(ieee_number, exponent10, digits, p) \
-  ieee_number_decimal(ieee_float_decimal_fraction, ieee_number, exponent10, digits, p)
-#define ieee_double_decimal_dot(ieee_number, exponent10, digits, p, dot) \
-  ieee_number_decimal_dot(ieee_double_decimal_fraction, ieee_number, exponent10, digits, p, dot)
-#define ieee_float_decimal_dot(ieee_number, exponent10, digits, p, dot) \
-  ieee_number_decimal_dot(ieee_float_decimal_fraction, ieee_number, exponent10, digits, p, dot)
-
-#endif
-
-#define ieee_number_decimal(method, ieee_number, exponent10, digits, p) \
-  ieee_double_denormalize(ieee_number); \
-  if (ieee_number.sign) *p++ = '-'; \
-  if (exponent10 <= 0) \
-    for (*p++ = '0', *p++ = RADIX_CHAR; exponent10 && digits; *p++ = '0', ++exponent10, --digits); \
-  else \
-  { \
-    do { *p++ = '0' + (char)method(ieee_number); } while (--exponent10); \
-    *p++ = RADIX_CHAR; \
-  } \
-  for  ( ; digits && ieee_number.fraction; --digits) \
-    *p++ = '0' + (char)method(ieee_number)
-
-#define ieee_number_decimal_dot(method, ieee_number, exponent10, digits, p, dot) \
-  ieee_double_denormalize(ieee_number); \
-  if (ieee_number.sign) *p++ = '-'; \
-  if (exponent10 <= 0) \
-  { \
-    *p++ = '0'; \
-    if (dot != NULL) *dot = p; \
-    for (*p++ = RADIX_CHAR; exponent10 && digits; *p++ = '0', ++exponent10, --digits); \
-  } \
-  else \
-  { \
-    do { *p++ = '0' + (char)method(ieee_number); } while (--exponent10); \
-    if (dot != NULL) *dot = p; \
-    *p++ = RADIX_CHAR; \
-  } \
-  for  ( ; digits && ieee_number.fraction; --digits) \
-    *p++ = '0' + (char)method(ieee_number)
-
-/* rounding to nearest integer */
-
-#if BINARY_MODF
-/* check if the mantissa has the most significant bit set, means >= 0.5 */
-#  define ieee_double_half(ieee_number) (ieee_number.fraction & (1ull<<55))
-#  define ieee_float_half(ieee_number) (ieee_number.fraction & (1<<26))
-#else
-#  define ieee_double_half(ieee_number) (ieee_number.number >= 0.5)
-#  define ieee_float_half(ieee_number) (ieee_number.number >= 0.5)
-#endif
-
-/* rounding to nearest integer */
-
-#define buffer_ceil(s, p, sign) \
-  { \
-    while (*--p == '9'); \
-    if (*p != RADIX_CHAR) ++*p++; \
-    else { \
-      char *q; \
-      for (q = p - 1; ; --q) { \
-        if (*q < '9') { ++*q; break; } \
-        *q = '0'; \
-        if (q == s) \
-          *--s = '1'; \
-        else if (sign && q - 1 == s) \
-          *s = '1', *--s = '-'; \
-      } \
-    } \
-  }
-
-#define buffer_remove_trailing_zeros(s, p, sign) \
-  { \
-    while (*--p == '0'); \
-    if (*p != RADIX_CHAR) \
-      ++p; \
-    else if (!SIGNED_ZERO && sign && p - 2 == s && *(p - 1) == '0') \
-      p -= 2, *p++ = '0'; \
-  }
-
-// if digits parameter was initially less then exponent10, then exponent10 > 0 and ieee_double_half(ieee_number) is irrelevant
-#define ieee_double_round(ieee_number, exponent10, s, p) \
-  if (exponent10 == 0 && ieee_double_half(ieee_number)) \
-    { buffer_ceil(s, p, ieee_number.sign); } \
-  else \
-    { buffer_remove_trailing_zeros(s, p, ieee_number.sign); }
-
-#define ieee_float_round(ieee_number, exponent10, s, p) \
-  if (exponent10 == 0 && ieee_float_half(ieee_number)) \
-    { buffer_ceil(s, p, ieee_number.sign); } \
-  else \
-    { buffer_remove_trailing_zeros(s, p, ieee_number.sign); }
-
-/* double to decimal */
-
-static char number_buffer[512];
-
-#define ieee_copy_special_string(special, p, _p) \
-  for (p = (char *)number_buffer, _p = special; ; ++p, ++_p) { \
-    if ((*p = *_p) == '\0') break; \
-  }
-
-#define ieee_copy_special_string_re(special, p, _p, r, e) \
-  for (p = (char *)number_buffer, _p = special; ; ++p, ++_p) { \
-    if ((*p = *_p) == '\0') { \
-    	if (r != NULL) *r = NULL; \
-    	if (e != NULL) *e = p; \
-      break; \
-    } \
-  }
-
-char * double_to_string (double number, int digits)
-{
-  ieee_double ieee_number;
-  int exponent10;
-  char *s, *p; const char *_p;
-  ieee_double_init(ieee_number, number);
-  ieee_double_sign(ieee_number);
-  if (ieee_double_is_zero(ieee_number)) // to avoid crash on log10(number)
-  {
-    ieee_copy_special_string(ieee_double_zero_string(ieee_number), p, _p);
-    return (char *)number_buffer;
-  }
-  if (ieee_double_special_case(ieee_number))
-  {
-    ieee_copy_special_string(ieee_double_special_string(ieee_number), p, _p);
-    return (char *)number_buffer;
-  }
-  s = p = number_buffer + 1;
-  ieee_double_exp10(ieee_number, exponent10);
-  ieee_double_decimal(ieee_number, exponent10, digits, p);
-  ieee_double_round(ieee_number, exponent10, s, p);
-  *p = '\0';
-  return s;
-}
-
-char * double_as_string (double number, int digits, char **r, char **e)
-{
-  ieee_double ieee_number;
-  int exponent10;
-  char *s, *p; const char *_p;
-  s = p = number_buffer + 1;
-  ieee_double_init(ieee_number, number);
-  ieee_double_sign(ieee_number);
-  if (ieee_double_is_zero(ieee_number)) // to avoid crash on log10(number)
-  {
-    ieee_copy_special_string_re(ieee_double_zero_string(ieee_number), p, _p, r, e);
-    return (char *)number_buffer;
-  }
-  if (ieee_double_special_case(ieee_number))
-  {
-    ieee_copy_special_string_re(ieee_double_special_string(ieee_number), p, _p, r, e);
-    return (char *)number_buffer;
-  }
-  ieee_double_exp10(ieee_number, exponent10);
-  ieee_double_decimal_dot(ieee_number, exponent10, digits, p, r);
-  ieee_double_round(ieee_number, exponent10, s, p);
-  if (e != NULL) *e = p;
-  *p = '\0';
-  return s;
-}
-
-/* float to decimal */
-
-char * float_to_string (float number, int digits)
-{
-  ieee_float ieee_number;
-  int exponent10;
-  char *s, *p; const char *_p;
-  ieee_float_init(ieee_number, number);
-  ieee_float_sign(ieee_number);
-  if (ieee_float_is_zero(ieee_number))
-  {
-    ieee_copy_special_string(ieee_float_zero_string(ieee_number), p, _p);
-    return (char *)number_buffer;
-  }
-  if (ieee_float_special_case(ieee_number))
-  {
-    ieee_copy_special_string(ieee_float_special_string(ieee_number), p, _p);
-    return (char *)number_buffer;
-  }
-  s = p = number_buffer + 1;
-  ieee_float_exp10(ieee_number, exponent10);
-  ieee_float_decimal(ieee_number, exponent10, digits, p);
-  ieee_float_round(ieee_number, exponent10, s, p);
-  *p = '\0';
-  return s;
-}
-
-char * float_as_string (float number, int digits, char **r, char **e)
-{
-  ieee_float ieee_number;
-  int exponent10;
-  char *s, *p; const char *_p;
-  s = p = number_buffer + 1;
-  ieee_float_init(ieee_number, number);
-  ieee_float_sign(ieee_number);
-  if (ieee_float_is_zero(ieee_number))
-  {
-    ieee_copy_special_string_re(ieee_float_zero_string(ieee_number), p, _p, r, e);
-    return (char *)number_buffer;
-  }
-  if (ieee_float_special_case(ieee_number))
-  {
-    ieee_copy_special_string_re(ieee_float_special_string(ieee_number), p, _p, r, e);
-    return (char *)number_buffer;
-  }
-  ieee_float_exp10(ieee_number, exponent10);
-  ieee_float_decimal_dot(ieee_number, exponent10, digits, p, r);
-  ieee_float_round(ieee_number, exponent10, s, p);
-  if (e != NULL) *e = p;
-  *p = '\0';
-  return s;
-}
-
-/* decimal string to double/float */
-
-#define string_scan_decimal(s, c, number) _scan_decimal(c, number, *++s)
-#define string_scan_fraction(s, c, number, exponent10) _scan_fraction(c, number, exponent10, *++s)
-#define string_scan_exponent10(s, c, exponent10) _scan_exponent10(c, exponent10, *++s)
-
-const char * string_to_double (const char *s, double *number)
-{
-  int sign, exponent10, c = *s;
-  string_scan_sign(s, c, sign);
-  string_scan_decimal(s, c, *number);
-  if (c == '.')
-  {
-    c = *++s;
-    string_scan_fraction(s, c, *number, exponent10);
-  }
-  else
-    exponent10 = 0;
-  if (c == 'e' || c == 'E')
-  {
-    c = *++s;
-    string_scan_exponent10(s, c, exponent10);
-  }
-  double_exp10(*number, exponent10);
-  if (sign) *number = -*number;
-  return s;
-}
-
-const char * string_to_float (const char *s, float *number)
-{
-  int sign, exponent10, c = *s;
-  string_scan_sign(s, c, sign);
-  string_scan_decimal(s, c, *number);
-  if (c == '.')
-  {
-    c = *++s;
-    string_scan_fraction(s, c, *number, exponent10);
-  }
-  else
-    exponent10 = 0;
-  if (c == 'e' || c == 'E')
-  {
-    c = *++s;
-    string_scan_exponent10(s, c, exponent10);
-  }
-  float_exp10(*number, exponent10);
-  if (sign) *number = -*number;
-  return s;
-}
-
-/* conventional form */
-
-const char * convert_to_double (const char *s, double *number)
-{
-  int sign, c = *s;
-  string_scan_sign(s, c, sign);
-  string_scan_decimal(s, c, *number);
-  if (c == '.' || c == ',')
-  {
-    int exponent10;
-    c = *++s;
-    string_scan_fraction(s, c, *number, exponent10);
-    if (exponent10 < 0)
-      double_negative_exp10(*number, exponent10);
-  }
-  if (sign) *number = -*number;
-  return s;
-}
-
-const char * convert_to_float (const char *s, float *number)
-{
-  int sign, c = *s;
-  string_scan_sign(s, c, sign);
-  string_scan_decimal(s, c, *number);
-  if (c == '.' || c == ',')
-  {
-    int exponent10;
-    c = *++s;
-    string_scan_fraction(s, c, *number, exponent10);
-    if (exponent10 < 0)
-      float_negative_exp10(*number, exponent10);
-  }
-  if (sign) *number = -*number;
-  return s;
-}
-
-/* pretty common stuff */
-
-size_t bytes_to_hex_lc (const void *input, size_t size, unsigned char *output)
-{
-  size_t i;
-  const unsigned char *p;
-  for (i = 0, p = (const unsigned char *)input; i < size; ++i, ++p)
-  {
-    *output++ = base16_lc_digit1(*p);
-    *output++ = base16_lc_digit2(*p);
-  }
-  *output = '\0';
-  return 2*size + 1;
-}
-
-size_t bytes_to_hex_uc (const void *input, size_t size, unsigned char *output)
-{
-  size_t i;
-  const unsigned char *p;
-  for (i = 0, p = (const unsigned char *)input; i < size; ++i, ++p)           
-  {
-    *output++ = base16_uc_digit1(*p);
-    *output++ = base16_uc_digit2(*p);
-  }
-  *output = '\0';
-  return 2*size + 1;
-}
-
-size_t hex_to_bytes (const void *input, size_t size, unsigned char *output)
-{
-  size_t i;
-  int c1, c2;
-  const unsigned char *p;
-  for (i = 1, p = (const unsigned char *)input; i < size; i += 2)
-  {
-    c1 = base16_value(*p);
-    ++p;
-    c2 = base16_value(*p);
-    ++p;
-    if (c1 >= 0 && c2 >= 0)
-      *output++ = (unsigned char)((c1<<4)|c2);
-    else
-      break;
-  }
-  return i >> 1;
-}
-
-void print_as_hex (const void *input, size_t bytes)
-{
-  const unsigned char *p;
-  for (p = (const unsigned char *)input; bytes > 0; --bytes, ++p)
-    printf("%02x", *p);
-}
\ No newline at end of file
--- texlive-bin.orig/texk/web2c/luatexdir/luapplib/util/utilnumber.h
+++ /dev/null
@@ -1,354 +0,0 @@
-#ifndef UTIL_NUMBER_H
-#define UTIL_NUMBER_H
-
-#include <stddef.h> // for size_t
-
-#include "utilplat.h"
-#include "utildecl.h"
-
-/* since 'long' isn't long for msvc64/mingw64, we need a type for machine word */
-
-#if !defined(__cplusplus) || !defined(_MSC_VER)
-#  include <stdint.h> // int*_t types are in standard in msvc++
-#endif
-
-//#if defined(MSVC64) || defined(__MINGW64__) || defined(__x86_64__) || UINTPTR_MAX > 0xffffffff
-//#  define BIT64
-//#else
-//#  define BIT64
-//#endif
-
-#if defined(_WIN64) || defined(__MINGW32__)
-#  define INT64F "%I64d"
-#  define UINT64F "%I64u"
-#else
-#  define INT64F "%lld"
-#  define UINT64F "%llu"
-#endif
-
-#if defined(MSVC64)
-#  define intlw_t int64_t
-#  define uintlw_t uint64_t
-#  define INTLW(N) N##I64
-#  define UINTLW(N) N##UI64
-#  define INTLWF INT64F
-#  define UINTLWF UINT64F
-#elif defined(__MINGW64__)
-#  define intlw_t int64_t
-#  define uintlw_t uint64_t
-#  define INTLW(N) N##LL
-#  define UINTLW(N) N##ULL
-#  define INTLWF INT64F
-#  define UINTLWF UINT64F
-#else // 32bit or sane 64bit (LP64)
-#  define intlw_t long
-#  define uintlw_t size_t /*unsigned long*/
-#  define INTLW(N) N##L
-#  define UINTLW(N) N##UL
-#  define INTLWF "%ld"
-#  define UINTLWF "%lu"
-#endif
-
-/* basic constants */
-
-#define MAX_RADIX 36
-// #define MAX_INTEGER_DIGITS 65 /* 64-bit number in binary form plus '\0' */
-#define MAX_INTEGER_DIGITS 128 // to handle romannumeral of short int
-
-#define base36_uc_alphabet "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
-#define base36_lc_alphabet "0123456789abcdefghijklmnopqrstuvwxyz"
-
-#define base26_uc_alphabet "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
-#define base26_lc_alphabet "abcdefghijklmnopqrstuvwxyz"
-extern const int base26_lookup[];
-
-#define base36_lc_palindrome "zyxwvutsrqponmlkjihgfedcba9876543210123456789abcdefghijklmnopqrstuvwxyz"
-#define base36_uc_palindrome "ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
-
-extern const int base36_lookup[];
-
-#define base10_palindrome "9876543210123456789"
-#define base10_alphabet "0123456789"
-extern const int base10_lookup[];
-
-#define base16_uc_alphabet "0123456789ABCDEF"
-#define base16_lc_alphabet "0123456789abcdef"
-extern const int base16_lookup[];
-
-#define base16_uc_digit1(c) base16_uc_alphabet[(c)>>4]
-#define base16_uc_digit2(c) base16_uc_alphabet[(c)&15]
-#define base16_lc_digit1(c) base16_lc_alphabet[(c)>>4]
-#define base16_lc_digit2(c) base16_lc_alphabet[(c)&15]
-
-#define base8_digit(c)  ((unsigned)(c - '0') <= (unsigned)('7' - '0'))
-#define base8_value(c)  (base8_digit(c) ? (c) - '0' : -1)
-
-#define base10_digit(c) ((unsigned)(c - '0') <= (unsigned)('9' - '0'))
-#define base10_value(c) (base10_lookup[(uint8_t)c])              
-
-#define base16_digit(c) (base16_lookup[(uint8_t)c] >= 0)
-#define base16_value(c) (base16_lookup[(uint8_t)c])
-
-#define base26_digit(c) (base26_lookup[(uint8_t)c] >= 0)
-#define base26_value(c) (base26_lookup[(uint8_t)c])
-
-#define base36_digit(c) (base36_lookup[(uint8_t)c] >= 0)
-#define base36_value(c) (base36_lookup[(uint8_t)c])
-
-//#define base_digit(c, radix) ((unsigned)(base36_lookup[c]) < (unsigned)(radix))
-//#define base_value(c, radix) (base_digit(c, radix) ? base36_lookup[c] : -1)
-
-/* integer from string; return a pointer to character next to the last digit */
-
-UTILAPI const char * string_to_int32 (const char *s, int32_t *number);
-UTILAPI const char * string_to_intlw (const char *s, intlw_t *number);
-UTILAPI const char * string_to_int64 (const char *s, int64_t *number);
-
-UTILAPI const char * string_to_uint32 (const char *s, uint32_t *number);
-UTILAPI const char * string_to_uintlw (const char *s, uintlw_t *number);
-UTILAPI const char * string_to_uint64 (const char *s, uint64_t *number);
-
-UTILAPI const char * radix_to_int32 (const char *s, int32_t *number, int radix);
-UTILAPI const char * radix_to_intlw (const char *s, intlw_t *number, int radix);
-UTILAPI const char * radix_to_int64 (const char *s, int64_t *number, int radix);
-
-UTILAPI const char * radix_to_uint32 (const char *s, uint32_t *number, int radix);
-UTILAPI const char * radix_to_uintlw (const char *s, uintlw_t *number, int radix);
-UTILAPI const char * radix_to_uint64 (const char *s, uint64_t *number, int radix);
-
-UTILAPI const char * roman_to_uint16 (const char *s, uint16_t *number);
-
-UTILAPI const char * alpha_to_uint32 (const char *s, uint32_t *number);
-UTILAPI const char * alpha_to_uintlw (const char *s, uintlw_t *number);
-UTILAPI const char * alpha_to_uint64 (const char *s, uint64_t *number);
-
-UTILAPI const char * alphan_to_uint32 (const char *s, uint32_t *number);
-UTILAPI const char * alphan_to_uintlw (const char *s, uintlw_t *number);
-UTILAPI const char * alphan_to_uint64 (const char *s, uintlw_t *number);
-
-/*
-integer to string; return a pointer to null-terminated static const string
-same but also stores pointer to trailing null (to be used for firther formatting)
-*/
-
-UTILAPI char * int32_as_string (int32_t number, char **e);
-UTILAPI char * intlw_as_string (intlw_t number, char **e);
-UTILAPI char * int64_as_string (int64_t number, char **e);
-
-UTILAPI char * uint32_as_string (uint32_t number, char **e);
-UTILAPI char * uintlw_as_string (uintlw_t number, char **e);
-UTILAPI char * uint64_as_string (uint64_t number, char **e);
-
-#define int32_to_string(number) int32_as_string(number, NULL)
-#define intlw_to_string(number) intlw_as_string(number, NULL)
-#define int64_to_string(number) int64_as_string(number, NULL)
-
-#define uint32_to_string(number) uint32_as_string(number, NULL)
-#define uintlw_to_string(number) uintlw_as_string(number, NULL)
-#define uint64_to_string(number) uint64_as_string(number, NULL)
-
-UTILAPI char * int32_as_radix (int32_t number, int radix, char **e);
-UTILAPI char * intlw_as_radix (intlw_t number, int radix, char **e);
-UTILAPI char * int64_as_radix (int64_t number, int radix, char **e);
-
-UTILAPI char * uint32_as_radix (uint32_t number, int radix, char **e);
-UTILAPI char * uintlw_as_radix (uintlw_t number, int radix, char **e);
-UTILAPI char * uint64_as_radix (uint64_t number, int radix, char **e);
-
-#define int32_to_radix(number, radix) int32_as_radix(number, radix, NULL)
-#define intlw_to_radix(number, radix) intlw_as_radix(number, radix, NULL)
-#define int64_to_radix(number, radix) int64_as_radix(number, radix, NULL)
-
-#define uint32_to_radix(number, radix) uint32_as_radix(number, radix, NULL)
-#define uintlw_to_radix(number, radix) uintlw_as_radix(number, radix, NULL)
-#define uint64_to_radix(number, radix) uint64_as_radix(number, radix, NULL)
-
-UTILAPI char * uint32_as_alpha_uc (uint32_t number, char **e);
-UTILAPI char * uint32_as_alpha_lc (uint32_t number, char **e);
-UTILAPI char * uintlw_as_alpha_uc (uintlw_t number, char **e);
-UTILAPI char * uintlw_as_alpha_lc (uintlw_t number, char **e);
-UTILAPI char * uint64_as_alpha_uc (uint64_t number, char **e);
-UTILAPI char * uint64_as_alpha_lc (uint64_t number, char **e);
-
-#define uint32_to_alpha_uc(number) uint32_as_alpha_uc(number, NULL)
-#define uint32_to_alpha_lc(number) uint32_as_alpha_lc(number, NULL)
-#define uintlw_to_alpha_uc(number) uintlw_as_alpha_uc(number, NULL)
-#define uintlw_to_alpha_lc(number) uintlw_as_alpha_lc(number, NULL)
-#define uint64_to_alpha_uc(number) uint64_as_alpha_uc(number, NULL)
-#define uint64_to_alpha_lc(number) uint64_as_alpha_lc(number, NULL)
-
-UTILAPI char * uint32_as_alphan_uc (uint32_t number, char **e);
-UTILAPI char * uint32_as_alphan_lc (uint32_t number, char **e);
-UTILAPI char * uintlw_as_alphan_uc (uintlw_t number, char **e);
-UTILAPI char * uintlw_as_alphan_lc (uintlw_t number, char **e);
-UTILAPI char * uint64_as_alphan_uc (uint64_t number, char **e);
-UTILAPI char * uint64_as_alphan_lc (uint64_t number, char **e);
-
-#define uint32_to_alphan_uc(number) uint32_as_alpha_uc(number, NULL)
-#define uint32_to_alphan_lc(number) uint32_as_alpha_lc(number, NULL)
-#define uintlw_to_alphan_uc(number) uintlw_as_alpha_uc(number, NULL)
-#define uintlw_to_alphan_lc(number) uintlw_as_alpha_lc(number, NULL)
-#define uint64_to_alphan_uc(number) uint64_as_alpha_uc(number, NULL)
-#define uint64_to_alphan_lc(number) uint64_as_alpha_lc(number, NULL)
-
-/* roman numeral (limited to uint16_t) */
-
-UTILAPI char * uint16_as_roman_uc (uint16_t number, char **e);
-UTILAPI char * uint16_as_roman_lc (uint16_t number, char **e);
-
-#define uint16_to_roman_uc(number) uint16_as_roman_uc(number, NULL)
-#define uint16_to_roman_lc(number) uint16_as_roman_lc(number, NULL)
-
-#define uint16_as_roman(number) uint16_as_roman_uc(number)
-#define uint16_to_roman(number) uint16_to_roman_uc(number)
-
-/* double/float  to string */
-
-UTILAPI char * double_to_string (double number, int digits);
-UTILAPI char * float_to_string (float number, int digits);
-
-UTILAPI char * double_as_string (double number, int digits, char **r, char **e);
-UTILAPI char * float_as_string (float number, int digits, char **r, char **e);
-
-/* string to double/float */
-
-UTILAPI const char * string_to_double (const char *s, double *number);
-UTILAPI const char * string_to_float  (const char *s, float *number);
-
-/* convenience form accepting comma among a dot, with not exp notation (eg. pdf) */
-
-UTILAPI const char * convert_to_double (const char *s, double *number);
-UTILAPI const char * convert_to_float  (const char *s, float *number);
-
-/* binary data parsers helpers */
-
-#define get_byte1(i) ((i)&255)
-#define get_byte2(i) (((i)>>8)&255)
-#define get_byte3(i) (((i)>>16)&255)
-#define get_byte4(i) (((i)>>24)&255)
-
-#define read_uint16be_as(s, int_type) ((int_type)((s[0]<<8)|s[1]))
-#define read_uint32be_as(s, int_type) ((int_type)((s[0]<<24)|(s[1]<<16)|(s[2]<<8)|s[3]))
-
-#define read_uint16le_as(s, int_type) ((int_type)((s[1]<<8)|s[0]))
-#define read_uint32le_as(s, int_type) ((int_type)((s[3]<<24)|(s[2]<<16)|(s[1]<<8)|s[0]))
-
-#define read_uint16_native(s) (*((uint16_t *)(s)))
-#define read_uint32_native(s) (*((uint32_t *)(s)))
-#define read_int16_native(s)  (*((int16_t *)(s)))
-#define read_int32_native(s)  (*((int32_t *)(s)))
-
-#define scan_uint16be_as(s, int_type) (s += 2, (int_type)((s[-2]<<8)|s[-1]))
-#define scan_uint32be_as(s, int_type) (s += 4, (int_type)((s[-4]<<24)|(s[-3]<<16)|(s[-2]<<8)|s[-1]))
-
-#define scan_uint16le_as(s, int_type) (s += 2, (int_type)((s[-1]<<8)|s[-2]))
-#define scan_uint32le_as(s, int_type) (s += 4, (int_type)((s[-1]<<24)|(s[-2]<<16)|(s[-3]<<8)|s[-4]))
-
-#define scan_uint16_native(s) (s += 2, read_uint16_native(s-2))
-#define scan_uint32_native(s) (s += 4, read_uint32_native(s-4))
-#define scan_int16_native(s)  (s += 2, read_int16_native(s-2))
-#define scan_int32_native(s)  (s += 4, read_int32_native(s-4))
-
-#define read_fixed16_16_as(s, float_type)  (((float_type)read_uint32be_as(s, signed int))/(1<<16))
-#define read_fixed2_14_as(s, float_type)  (((float_type)read_uint16be_as(s, signed short))/(1<<14))
-
-#define scan_fixed16_16_as(s, float_type) (((float_type)scan_uint32be_as(s, signed int))/(1<<16))
-#define scan_fixed2_14_as(s, float_type) (((float_type)scan_uint16be_as(s, signed short))/(1<<14))
-
-/* internal procedures */
-
-#define _scan_sign(c, sign, next) \
-  do { if (c == '-') { sign = 1; c = next; } else if (c == '+') { sign = 0; c = next; } else sign = 0; } while (0)
-
-#define integer_multiplied10(number) (((number) << 1) + ((number) << 3))
-
-#define _scan_integer(c, number, next) \
-  for (number = 0; base10_digit(c); number = integer_multiplied10(number) + (c - '0'), c = next)
-#define _scan_radix(c, number, radix, next) \
-  for (number = 0; (c = base36_value(c)) >= 0 && c < radix; number = number * radix + c, c = next)
-
-#define _read_integer(c, number, next) \
-  for (number = c - '0', c = next; base10_digit(c); number = integer_multiplied10(number) + (c - '0'), c = next)
-#define _read_radix(c, number, radix, next) \
-  for (number = c - '0', c = next; (c = base36_value(c)) >= 0 && c < radix; number = number * radix + c, c = next)
-
-/* rationals */
-
-#define _scan_decimal(c, number, next) \
-  for (number = 0; base10_digit(c); number = number*10 + (c - '0'), c = next)
-#define _scan_fraction(c, number, exponent10, next) \
-  for (exponent10 = 0; base10_digit(c); --exponent10, number = number*10 + (c - '0'), c = next)
-
-#define _scan_exponent10(c, exponent10, next) \
-  do { \
-    int eexponent10, eexpsign; \
-    _scan_sign(c, eexpsign, next); \
-    _scan_integer(c, eexponent10, next); \
-    if (eexpsign) \
-      exponent10 -= eexponent10; \
-    else \
-      exponent10 += eexponent10; \
-  } while(0)
-
-#if 0
-
-// kept just for sentiment ;)
-
-extern const double double_binary_power10[];
-extern const float float_binary_power10[];
-extern const double double_binary_negpower10[];
-extern const float float_binary_negpower10[];
-
-#define double_negative_exp10(number, exponent) \
-{ const double *bp10; int e = ((exponent) < 511 ? 511 : -(exponent)); \
-  for (bp10 = double_binary_negpower10; e > 0; e >>= 1, ++bp10) \
-    if (e & 1) number *= *bp10; }
-
-#define float_negative_exp10(number, exponent) \
-{ const float *bp10; int e = ((exponent) < 64 ? 64 : -(exponent)); \
-  for (bp10 = float_binary_negpower10; e > 0; e >>= 1, ++bp10) \
-    if (e & 1) number *= *bp10; }
-
-#define double_positive_exp10(number, exponent) \
-{ const double *bp10; int e = ((exponent) > 511 ? 511 : (exponent)); \
-  for (bp10 = double_binary_power10; e > 0; e >>= 1, ++bp10) \
-    if (e & 1) number *= *bp10; }
-
-#define float_positive_exp10(number, exponent) \
-{ const float *bp10; int e = ((exponent) > 64 ? 64 : (exponent)); \
-  for (bp10 = double_binary_power10; e > 0; e >>= 1, ++bp10) \
-    if (e & 1) number *= *bp10; }
-
-#define double_exp10(number, exponent) \
-  if ((exponent) < 0) double_negative_exp10(number, exponent) else if ((exponent) > 0) double_positive_exp10(number, exponent)
-
-#define float_exp10(number, exponent) \
-  if ((exponent) < 0) float_negative_exp10(number, exponent) else if ((exponent) > 0) float_positive_exp10(number, exponent)
-
-#else
-
-extern const double double_decimal_power10[];
-extern const float float_decimal_power10[];
-extern const double double_decimal_negpower10[];
-extern const float float_decimal_negpower10[];
-
-#define double_negative_exp10(number, exponent) ((number) *= double_decimal_negpower10[(exponent) < -308 ? 308 : -(exponent)])
-#define double_positive_exp10(number, exponent) ((number) *= double_decimal_power10[(exponent) > 308 ? 308 : (exponent)])
-
-#define float_negative_exp10(number, exponent) ((number) *= float_decimal_negpower10[(exponent) < -38 ? 38 : -(exponent)])
-#define float_positive_exp10(number, exponent) ((number) *= float_decimal_power10[(exponent) > 38 ? 38 : (exponent)])
-
-#define double_exp10(number, exponent) ((void)(((exponent) < 0 && double_negative_exp10(number, exponent)) || (((exponent) > 0 && double_positive_exp10(number, exponent)))))
-#define float_exp10(number, exponent) ((void)(((exponent) < 0 && float_negative_exp10(number, exponent)) || (((exponent) > 0 && float_positive_exp10(number, exponent)))))
-
-#endif
-
-/* pretty common stuff */
-
-#define bytes_to_hex(input, size, output) bytes_to_hex_lc(input, size, output)
-UTILAPI size_t bytes_to_hex_lc (const void *input, size_t size, uint8_t *output);
-UTILAPI size_t bytes_to_hex_uc (const void *input, size_t size, uint8_t *output);
-UTILAPI size_t hex_to_bytes (const void *input, size_t size, uint8_t *output);
-UTILAPI void print_as_hex (const void *input, size_t bytes);
-
-#endif
\ No newline at end of file
--- texlive-bin.orig/texk/web2c/luatexdir/luapplib/util/utilplat.h
+++ /dev/null
@@ -1,23 +0,0 @@
-
-#ifndef UTIL_PLAT_H
-#define UTIL_PLAT_H
-
-#if defined(_WIN32) || defined(WIN32)
-#  ifdef _MSC_VER
-#    if defined(_M_64) || defined(_WIN64)
-#      define MSVC64
-#    else
-#      define MSVC32
-#    endif
-#  else
-#    if defined(__MINGW64__)
-#      define MINGW64
-#    else
-#      if defined(__MINGW32__)
-#        define MINGW32
-#      endif
-#    endif
-#  endif
-#endif
-
-#endif
\ No newline at end of file
--- texlive-bin.orig/texk/web2c/luatexdir/luapplib/util/utilsha.c
+++ /dev/null
@@ -1,1290 +0,0 @@
-/* sha2 implementation by Aaron D. Gifford (http://www.aarongifford.com) */
-
-#if defined __arm__ || defined __ARM__ || defined ARM || defined __ARM || defined __arm || defined __ARM_ARCH ||defined __aarch64__ 
-#include <stdlib.h>
-#endif
-
-#ifndef BYTE_ORDER
-#define BYTE_ORDER LITTLE_ENDIAN
-#endif
-/* begin of sha2.c */
-
-/*
- * FILE:	sha2.c
- * AUTHOR:	Aaron D. Gifford - http://www.aarongifford.com/
- *
- * Copyright (c) 2000-2001, Aaron D. Gifford
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holder nor the names of contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTOR(S) ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTOR(S) BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- * $Id: sha2.c,v 1.1 2001/11/08 00:01:51 adg Exp adg $
- */
-
-#include <string.h>	/* memcpy()/memset() or bcopy()/bzero() */
-#if defined __arm__ || defined __ARM__ || defined ARM || defined __ARM || defined __arm || defined __ARM_ARCH ||defined __aarch64__ 
-#include <stdlib.h>
-#endif
-#include <assert.h>	/* assert() */
-//#include "sha2.h"
-#include "utilsha.h"
-
-/*
- * ASSERT NOTE:
- * Some sanity checking code is included using assert().  On my FreeBSD
- * system, this additional code can be removed by compiling with NDEBUG
- * defined.  Check your own systems manpage on assert() to see how to
- * compile WITHOUT the sanity checking code on your system.
- *
- * UNROLLED TRANSFORM LOOP NOTE:
- * You can define SHA2_UNROLL_TRANSFORM to use the unrolled transform
- * loop version for the hash transform rounds (defined using macros
- * later in this file).  Either define on the command line, for example:
- *
- *   cc -DSHA2_UNROLL_TRANSFORM -o sha2 sha2.c sha2prog.c
- *
- * or define below:
- *
- *   #define SHA2_UNROLL_TRANSFORM
- *
- */
-
-
-/*** SHA-256/384/512 Machine Architecture Definitions *****************/
-/*
- * BYTE_ORDER NOTE:
- *
- * Please make sure that your system defines BYTE_ORDER.  If your
- * architecture is little-endian, make sure it also defines
- * LITTLE_ENDIAN and that the two (BYTE_ORDER and LITTLE_ENDIAN) are
- * equivilent.
- *
- * If your system does not define the above, then you can do so by
- * hand like this:
- *
- *   #define LITTLE_ENDIAN 1234
- *   #define BIG_ENDIAN    4321
- *
- * And for little-endian machines, add:
- *
- *   #define BYTE_ORDER LITTLE_ENDIAN
- *
- * Or for big-endian machines:
- *
- *   #define BYTE_ORDER BIG_ENDIAN
- *
- * The FreeBSD machine this was written on defines BYTE_ORDER
- * appropriately by including <sys/types.h> (which in turn includes
- * <machine/endian.h> where the appropriate definitions are actually
- * made).
- */
-#if !defined(BYTE_ORDER) || (BYTE_ORDER != LITTLE_ENDIAN && BYTE_ORDER != BIG_ENDIAN)
-#error Define BYTE_ORDER to be equal to either LITTLE_ENDIAN or BIG_ENDIAN
-#endif
-
-/*
- * Define the followingsha2_* types to types of the correct length on
- * the native archtecture.   Most BSD systems and Linux define u_intXX_t
- * types.  Machines with very recent ANSI C headers, can use the
- * uintXX_t definintions from inttypes.h by defining SHA2_USE_INTTYPES_H
- * during compile or in the sha.h header file.
- *
- * Machines that support neither u_intXX_t nor inttypes.h's uintXX_t
- * will need to define these three typedefs below (and the appropriate
- * ones in sha.h too) by hand according to their system architecture.
- *
- * Thank you, Jun-ichiro itojun Hagino, for suggesting using u_intXX_t
- * types and pointing out recent ANSI C support for uintXX_t in inttypes.h.
- *
- * PJ: replace by uintX_t
- */
-
-//typedef uint8_t  sha2_byte;	/* Exactly 1 byte */
-//typedef uint32_t sha2_word32;	/* Exactly 4 bytes */
-//typedef uint64_t sha2_word64;	/* Exactly 8 bytes */
-
-/*** SHA-256/384/512 Various Length Definitions ***********************/
-/* NOTE: Most of these are in sha2.h */
-#define SHA256_SHORT_BLOCK_LENGTH	(SHA256_BLOCK_LENGTH - 8)
-#define SHA384_SHORT_BLOCK_LENGTH	(SHA384_BLOCK_LENGTH - 16)
-#define SHA512_SHORT_BLOCK_LENGTH	(SHA512_BLOCK_LENGTH - 16)
-
-
-/*** ENDIAN REVERSAL MACROS *******************************************/
-#if BYTE_ORDER == LITTLE_ENDIAN
-#define REVERSE32(w,x)	{ \
-	uint32_t tmp = (w); \
-	tmp = (tmp >> 16) | (tmp << 16); \
-	(x) = ((tmp & 0xff00ff00UL) >> 8) | ((tmp & 0x00ff00ffUL) << 8); \
-}
-#define REVERSE64(w,x)	{ \
-	uint64_t tmp = (w); \
-	tmp = (tmp >> 32) | (tmp << 32); \
-	tmp = ((tmp & 0xff00ff00ff00ff00ULL) >> 8) | \
-	      ((tmp & 0x00ff00ff00ff00ffULL) << 8); \
-	(x) = ((tmp & 0xffff0000ffff0000ULL) >> 16) | \
-	      ((tmp & 0x0000ffff0000ffffULL) << 16); \
-}
-#endif /* BYTE_ORDER == LITTLE_ENDIAN */
-
-/*
- * Macro for incrementally adding the unsigned 64-bit integer n to the
- * unsigned 128-bit integer (represented using a two-element array of
- * 64-bit words):
- */
-#define ADDINC128(w,n)	{ \
-	(w)[0] += (uint64_t)(n); \
-	if ((w)[0] < (n)) { \
-		(w)[1]++; \
-	} \
-}
-
-/*
- * Macros for copying blocks of memory and for zeroing out ranges
- * of memory.  Using these macros makes it easy to switch from
- * using memset()/memcpy() and using bzero()/bcopy().
- *
- * Please define either SHA2_USE_MEMSET_MEMCPY or define
- * SHA2_USE_BZERO_BCOPY depending on which function set you
- * choose to use:
- */
-#if !defined(SHA2_USE_MEMSET_MEMCPY) && !defined(SHA2_USE_BZERO_BCOPY)
-/* Default to memset()/memcpy() if no option is specified */
-#define	SHA2_USE_MEMSET_MEMCPY	1
-#endif
-#if defined(SHA2_USE_MEMSET_MEMCPY) && defined(SHA2_USE_BZERO_BCOPY)
-/* Abort with an error if BOTH options are defined */
-#error Define either SHA2_USE_MEMSET_MEMCPY or SHA2_USE_BZERO_BCOPY, not both!
-#endif
-
-#ifdef SHA2_USE_MEMSET_MEMCPY
-#define MEMSET_BZERO(p,l)	memset((p), 0, (l))
-#define MEMCPY_BCOPY(d,s,l)	memcpy((d), (s), (l))
-#endif
-#ifdef SHA2_USE_BZERO_BCOPY
-#define MEMSET_BZERO(p,l)	bzero((p), (l))
-#define MEMCPY_BCOPY(d,s,l)	bcopy((s), (d), (l))
-#endif
-
-
-/*** THE SIX LOGICAL FUNCTIONS ****************************************/
-/*
- * Bit shifting and rotation (used by the six SHA-XYZ logical functions:
- *
- *   NOTE:  The naming of R and S appears backwards here (R is a SHIFT and
- *   S is a ROTATION) because the SHA-256/384/512 description document
- *   (see http://csrc.nist.gov/cryptval/shs/sha256-384-512.pdf) uses this
- *   same "backwards" definition.
- */
-/* Shift-right (used in SHA-256, SHA-384, and SHA-512): */
-#define R(b,x) 		((x) >> (b))
-/* 32-bit Rotate-right (used in SHA-256): */
-#define S32(b,x)	(((x) >> (b)) | ((x) << (32 - (b))))
-/* 64-bit Rotate-right (used in SHA-384 and SHA-512): */
-#define S64(b,x)	(((x) >> (b)) | ((x) << (64 - (b))))
-
-/* Two of six logical functions used in SHA-256, SHA-384, and SHA-512: */
-#define Ch(x,y,z)	(((x) & (y)) ^ ((~(x)) & (z)))
-#define Maj(x,y,z)	(((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z)))
-
-/* Four of six logical functions used in SHA-256: */
-#define Sigma0_256(x)	(S32(2,  (x)) ^ S32(13, (x)) ^ S32(22, (x)))
-#define Sigma1_256(x)	(S32(6,  (x)) ^ S32(11, (x)) ^ S32(25, (x)))
-#define sigma0_256(x)	(S32(7,  (x)) ^ S32(18, (x)) ^ R(3 ,   (x)))
-#define sigma1_256(x)	(S32(17, (x)) ^ S32(19, (x)) ^ R(10,   (x)))
-
-/* Four of six logical functions used in SHA-384 and SHA-512: */
-#define Sigma0_512(x)	(S64(28, (x)) ^ S64(34, (x)) ^ S64(39, (x)))
-#define Sigma1_512(x)	(S64(14, (x)) ^ S64(18, (x)) ^ S64(41, (x)))
-#define sigma0_512(x)	(S64( 1, (x)) ^ S64( 8, (x)) ^ R( 7,   (x)))
-#define sigma1_512(x)	(S64(19, (x)) ^ S64(61, (x)) ^ R( 6,   (x)))
-
-/*** INTERNAL FUNCTION PROTOTYPES *************************************/
-/* NOTE: These should not be accessed directly from outside this
- * library -- they are intended for private internal visibility/use
- * only.
- */
-static void SHA512_Last(SHA512_CTX*);
-static void SHA256_Transform(SHA256_CTX*, const uint32_t*);
-static void SHA512_Transform(SHA512_CTX*, const uint64_t*);
-
-
-/*** SHA-XYZ INITIAL HASH VALUES AND CONSTANTS ************************/
-/* Hash constant words K for SHA-256: */
-static const uint32_t K256[64] = {
-	0x428a2f98UL, 0x71374491UL, 0xb5c0fbcfUL, 0xe9b5dba5UL,
-	0x3956c25bUL, 0x59f111f1UL, 0x923f82a4UL, 0xab1c5ed5UL,
-	0xd807aa98UL, 0x12835b01UL, 0x243185beUL, 0x550c7dc3UL,
-	0x72be5d74UL, 0x80deb1feUL, 0x9bdc06a7UL, 0xc19bf174UL,
-	0xe49b69c1UL, 0xefbe4786UL, 0x0fc19dc6UL, 0x240ca1ccUL,
-	0x2de92c6fUL, 0x4a7484aaUL, 0x5cb0a9dcUL, 0x76f988daUL,
-	0x983e5152UL, 0xa831c66dUL, 0xb00327c8UL, 0xbf597fc7UL,
-	0xc6e00bf3UL, 0xd5a79147UL, 0x06ca6351UL, 0x14292967UL,
-	0x27b70a85UL, 0x2e1b2138UL, 0x4d2c6dfcUL, 0x53380d13UL,
-	0x650a7354UL, 0x766a0abbUL, 0x81c2c92eUL, 0x92722c85UL,
-	0xa2bfe8a1UL, 0xa81a664bUL, 0xc24b8b70UL, 0xc76c51a3UL,
-	0xd192e819UL, 0xd6990624UL, 0xf40e3585UL, 0x106aa070UL,
-	0x19a4c116UL, 0x1e376c08UL, 0x2748774cUL, 0x34b0bcb5UL,
-	0x391c0cb3UL, 0x4ed8aa4aUL, 0x5b9cca4fUL, 0x682e6ff3UL,
-	0x748f82eeUL, 0x78a5636fUL, 0x84c87814UL, 0x8cc70208UL,
-	0x90befffaUL, 0xa4506cebUL, 0xbef9a3f7UL, 0xc67178f2UL
-};
-
-/* Initial hash value H for SHA-256: */
-static const uint32_t sha256_initial_hash_value[8] = {
-	0x6a09e667UL,
-	0xbb67ae85UL,
-	0x3c6ef372UL,
-	0xa54ff53aUL,
-	0x510e527fUL,
-	0x9b05688cUL,
-	0x1f83d9abUL,
-	0x5be0cd19UL
-};
-
-/* Hash constant words K for SHA-384 and SHA-512: */
-static const uint64_t K512[80] = {
-	0x428a2f98d728ae22ULL, 0x7137449123ef65cdULL,
-	0xb5c0fbcfec4d3b2fULL, 0xe9b5dba58189dbbcULL,
-	0x3956c25bf348b538ULL, 0x59f111f1b605d019ULL,
-	0x923f82a4af194f9bULL, 0xab1c5ed5da6d8118ULL,
-	0xd807aa98a3030242ULL, 0x12835b0145706fbeULL,
-	0x243185be4ee4b28cULL, 0x550c7dc3d5ffb4e2ULL,
-	0x72be5d74f27b896fULL, 0x80deb1fe3b1696b1ULL,
-	0x9bdc06a725c71235ULL, 0xc19bf174cf692694ULL,
-	0xe49b69c19ef14ad2ULL, 0xefbe4786384f25e3ULL,
-	0x0fc19dc68b8cd5b5ULL, 0x240ca1cc77ac9c65ULL,
-	0x2de92c6f592b0275ULL, 0x4a7484aa6ea6e483ULL,
-	0x5cb0a9dcbd41fbd4ULL, 0x76f988da831153b5ULL,
-	0x983e5152ee66dfabULL, 0xa831c66d2db43210ULL,
-	0xb00327c898fb213fULL, 0xbf597fc7beef0ee4ULL,
-	0xc6e00bf33da88fc2ULL, 0xd5a79147930aa725ULL,
-	0x06ca6351e003826fULL, 0x142929670a0e6e70ULL,
-	0x27b70a8546d22ffcULL, 0x2e1b21385c26c926ULL,
-	0x4d2c6dfc5ac42aedULL, 0x53380d139d95b3dfULL,
-	0x650a73548baf63deULL, 0x766a0abb3c77b2a8ULL,
-	0x81c2c92e47edaee6ULL, 0x92722c851482353bULL,
-	0xa2bfe8a14cf10364ULL, 0xa81a664bbc423001ULL,
-	0xc24b8b70d0f89791ULL, 0xc76c51a30654be30ULL,
-	0xd192e819d6ef5218ULL, 0xd69906245565a910ULL,
-	0xf40e35855771202aULL, 0x106aa07032bbd1b8ULL,
-	0x19a4c116b8d2d0c8ULL, 0x1e376c085141ab53ULL,
-	0x2748774cdf8eeb99ULL, 0x34b0bcb5e19b48a8ULL,
-	0x391c0cb3c5c95a63ULL, 0x4ed8aa4ae3418acbULL,
-	0x5b9cca4f7763e373ULL, 0x682e6ff3d6b2b8a3ULL,
-	0x748f82ee5defb2fcULL, 0x78a5636f43172f60ULL,
-	0x84c87814a1f0ab72ULL, 0x8cc702081a6439ecULL,
-	0x90befffa23631e28ULL, 0xa4506cebde82bde9ULL,
-	0xbef9a3f7b2c67915ULL, 0xc67178f2e372532bULL,
-	0xca273eceea26619cULL, 0xd186b8c721c0c207ULL,
-	0xeada7dd6cde0eb1eULL, 0xf57d4f7fee6ed178ULL,
-	0x06f067aa72176fbaULL, 0x0a637dc5a2c898a6ULL,
-	0x113f9804bef90daeULL, 0x1b710b35131c471bULL,
-	0x28db77f523047d84ULL, 0x32caab7b40c72493ULL,
-	0x3c9ebe0a15c9bebcULL, 0x431d67c49c100d4cULL,
-	0x4cc5d4becb3e42b6ULL, 0x597f299cfc657e2aULL,
-	0x5fcb6fab3ad6faecULL, 0x6c44198c4a475817ULL
-};
-
-/* Initial hash value H for SHA-384 */
-static const uint64_t sha384_initial_hash_value[8] = {
-	0xcbbb9d5dc1059ed8ULL,
-	0x629a292a367cd507ULL,
-	0x9159015a3070dd17ULL,
-	0x152fecd8f70e5939ULL,
-	0x67332667ffc00b31ULL,
-	0x8eb44a8768581511ULL,
-	0xdb0c2e0d64f98fa7ULL,
-	0x47b5481dbefa4fa4ULL
-};
-
-/* Initial hash value H for SHA-512 */
-static const uint64_t sha512_initial_hash_value[8] = {
-	0x6a09e667f3bcc908ULL,
-	0xbb67ae8584caa73bULL,
-	0x3c6ef372fe94f82bULL,
-	0xa54ff53a5f1d36f1ULL,
-	0x510e527fade682d1ULL,
-	0x9b05688c2b3e6c1fULL,
-	0x1f83d9abfb41bd6bULL,
-	0x5be0cd19137e2179ULL
-};
-
-/*
- * Constant used by SHA256/384/512_End() functions for converting the
- * digest to a readable hexadecimal character string:
- */
-
-//static const char *sha2_hex_digits = "0123456789abcdef"; // PJ
-
-
-/*** SHA-256: *********************************************************/
-static void SHA256_Init(SHA256_CTX* context) {
-	if (context == (SHA256_CTX*)0) {
-		return;
-	}
-	MEMCPY_BCOPY(context->state, sha256_initial_hash_value, SHA256_DIGEST_LENGTH);
-	MEMSET_BZERO(context->buffer, SHA256_BLOCK_LENGTH);
-	context->bitcount = 0;
-}
-
-#ifdef SHA2_UNROLL_TRANSFORM
-
-/* Unrolled SHA-256 round macros: */
-
-#if BYTE_ORDER == LITTLE_ENDIAN
-
-#define ROUND256_0_TO_15(a,b,c,d,e,f,g,h)	\
-	REVERSE32(*data++, W256[j]); \
-	T1 = (h) + Sigma1_256(e) + Ch((e), (f), (g)) + \
-             K256[j] + W256[j]; \
-	(d) += T1; \
-	(h) = T1 + Sigma0_256(a) + Maj((a), (b), (c)); \
-	j++
-
-
-#else /* BYTE_ORDER == LITTLE_ENDIAN */
-
-#define ROUND256_0_TO_15(a,b,c,d,e,f,g,h)	\
-	T1 = (h) + Sigma1_256(e) + Ch((e), (f), (g)) + \
-	     K256[j] + (W256[j] = *data++); \
-	(d) += T1; \
-	(h) = T1 + Sigma0_256(a) + Maj((a), (b), (c)); \
-	j++
-
-#endif /* BYTE_ORDER == LITTLE_ENDIAN */
-
-#define ROUND256(a,b,c,d,e,f,g,h)	\
-	s0 = W256[(j+1)&0x0f]; \
-	s0 = sigma0_256(s0); \
-	s1 = W256[(j+14)&0x0f]; \
-	s1 = sigma1_256(s1); \
-	T1 = (h) + Sigma1_256(e) + Ch((e), (f), (g)) + K256[j] + \
-	     (W256[j&0x0f] += s1 + W256[(j+9)&0x0f] + s0); \
-	(d) += T1; \
-	(h) = T1 + Sigma0_256(a) + Maj((a), (b), (c)); \
-	j++
-
-void SHA256_Transform(SHA256_CTX* context, const uint32_t* data) {
-	uint32_t	a, b, c, d, e, f, g, h, s0, s1;
-	uint32_t	T1, *W256;
-	int		j;
-
-	W256 = (uint32_t*)context->buffer;
-
-	/* Initialize registers with the prev. intermediate value */
-	a = context->state[0];
-	b = context->state[1];
-	c = context->state[2];
-	d = context->state[3];
-	e = context->state[4];
-	f = context->state[5];
-	g = context->state[6];
-	h = context->state[7];
-
-	j = 0;
-	do {
-		/* Rounds 0 to 15 (unrolled): */
-		ROUND256_0_TO_15(a,b,c,d,e,f,g,h);
-		ROUND256_0_TO_15(h,a,b,c,d,e,f,g);
-		ROUND256_0_TO_15(g,h,a,b,c,d,e,f);
-		ROUND256_0_TO_15(f,g,h,a,b,c,d,e);
-		ROUND256_0_TO_15(e,f,g,h,a,b,c,d);
-		ROUND256_0_TO_15(d,e,f,g,h,a,b,c);
-		ROUND256_0_TO_15(c,d,e,f,g,h,a,b);
-		ROUND256_0_TO_15(b,c,d,e,f,g,h,a);
-	} while (j < 16);
-
-	/* Now for the remaining rounds to 64: */
-	do {
-		ROUND256(a,b,c,d,e,f,g,h);
-		ROUND256(h,a,b,c,d,e,f,g);
-		ROUND256(g,h,a,b,c,d,e,f);
-		ROUND256(f,g,h,a,b,c,d,e);
-		ROUND256(e,f,g,h,a,b,c,d);
-		ROUND256(d,e,f,g,h,a,b,c);
-		ROUND256(c,d,e,f,g,h,a,b);
-		ROUND256(b,c,d,e,f,g,h,a);
-	} while (j < 64);
-
-	/* Compute the current intermediate hash value */
-	context->state[0] += a;
-	context->state[1] += b;
-	context->state[2] += c;
-	context->state[3] += d;
-	context->state[4] += e;
-	context->state[5] += f;
-	context->state[6] += g;
-	context->state[7] += h;
-
-	/* Clean up */
-	a = b = c = d = e = f = g = h = T1 = 0;
-}
-
-#else /* SHA2_UNROLL_TRANSFORM */
-
-static void SHA256_Transform(SHA256_CTX* context, const uint32_t* data) {
-	uint32_t	a, b, c, d, e, f, g, h, s0, s1;
-	uint32_t	T1, T2, *W256;
-	int		j;
-
-#if defined __arm__ || defined __ARM__ || defined ARM || defined __ARM || defined __arm || defined __ARM_ARCH ||defined __aarch64__ 
-	W256 = (uint32_t*)((void *)context->buffer);
-#else
-	W256 = (uint32_t*)context->buffer;
-#endif
-
-
-	/* Initialize registers with the prev. intermediate value */
-	a = context->state[0];
-	b = context->state[1];
-	c = context->state[2];
-	d = context->state[3];
-	e = context->state[4];
-	f = context->state[5];
-	g = context->state[6];
-	h = context->state[7];
-
-	j = 0;
-	do {
-#if BYTE_ORDER == LITTLE_ENDIAN
-		/* Copy data while converting to host byte order */
-		REVERSE32(*data++,W256[j]);
-		/* Apply the SHA-256 compression function to update a..h */
-		T1 = h + Sigma1_256(e) + Ch(e, f, g) + K256[j] + W256[j];
-#else /* BYTE_ORDER == LITTLE_ENDIAN */
-		/* Apply the SHA-256 compression function to update a..h with copy */
-		T1 = h + Sigma1_256(e) + Ch(e, f, g) + K256[j] + (W256[j] = *data++);
-#endif /* BYTE_ORDER == LITTLE_ENDIAN */
-		T2 = Sigma0_256(a) + Maj(a, b, c);
-		h = g;
-		g = f;
-		f = e;
-		e = d + T1;
-		d = c;
-		c = b;
-		b = a;
-		a = T1 + T2;
-
-		j++;
-	} while (j < 16);
-
-	do {
-		/* Part of the message block expansion: */
-		s0 = W256[(j+1)&0x0f];
-		s0 = sigma0_256(s0);
-		s1 = W256[(j+14)&0x0f];
-		s1 = sigma1_256(s1);
-
-		/* Apply the SHA-256 compression function to update a..h */
-		T1 = h + Sigma1_256(e) + Ch(e, f, g) + K256[j] +
-		     (W256[j&0x0f] += s1 + W256[(j+9)&0x0f] + s0);
-		T2 = Sigma0_256(a) + Maj(a, b, c);
-		h = g;
-		g = f;
-		f = e;
-		e = d + T1;
-		d = c;
-		c = b;
-		b = a;
-		a = T1 + T2;
-
-		j++;
-	} while (j < 64);
-
-	/* Compute the current intermediate hash value */
-	context->state[0] += a;
-	context->state[1] += b;
-	context->state[2] += c;
-	context->state[3] += d;
-	context->state[4] += e;
-	context->state[5] += f;
-	context->state[6] += g;
-	context->state[7] += h;
-
-	/* Clean up */
-	a = b = c = d = e = f = g = h = T1 = T2 = 0;
-}
-
-#endif /* SHA2_UNROLL_TRANSFORM */
-
-static void SHA256_Update(SHA256_CTX* context, const uint8_t *data, size_t len) {
-	unsigned int	freespace, usedspace;
-
-	if (len == 0) {
-		/* Calling with no data is valid - we do nothing */
-		return;
-	}
-
-	/* Sanity check: */
-	assert(context != (SHA256_CTX*)0 && data != (uint8_t*)0);
-
-	usedspace = (context->bitcount >> 3) % SHA256_BLOCK_LENGTH;
-	if (usedspace > 0) {
-		/* Calculate how much free space is available in the buffer */
-		freespace = SHA256_BLOCK_LENGTH - usedspace;
-
-		if (len >= freespace) {
-			/* Fill the buffer completely and process it */
-			MEMCPY_BCOPY(&context->buffer[usedspace], data, freespace);
-			context->bitcount += freespace << 3;
-			len -= freespace;
-			data += freespace;
-#if defined __arm__ || defined __ARM__ || defined ARM || defined __ARM || defined __arm || defined __ARM_ARCH ||defined __aarch64__ 
-			SHA256_Transform(context, (uint32_t*)((void *)context->buffer));
-#else
-			SHA256_Transform(context, (uint32_t*)context->buffer);
-#endif
-
-		} else {
-			/* The buffer is not yet full */
-			MEMCPY_BCOPY(&context->buffer[usedspace], data, len);
-			context->bitcount += len << 3;
-			/* Clean up: */
-			usedspace = freespace = 0;
-			return;
-		}
-	}
-	while (len >= SHA256_BLOCK_LENGTH) {
-		/* Process as many complete blocks as we can */
-#if defined __arm__ || defined __ARM__ || defined ARM || defined __ARM || defined __arm || defined __ARM_ARCH ||defined __aarch64__ 
-  	        SHA256_Transform(context, (const uint32_t*)(const void *)(data));
-#else
-		SHA256_Transform(context, (const uint32_t*)data);
-#endif
-
-		context->bitcount += SHA256_BLOCK_LENGTH << 3;
-		len -= SHA256_BLOCK_LENGTH;
-		data += SHA256_BLOCK_LENGTH;
-	}
-	if (len > 0) {
-		/* There's left-overs, so save 'em */
-		MEMCPY_BCOPY(context->buffer, data, len);
-		context->bitcount += len << 3;
-	}
-	/* Clean up: */
-	usedspace = freespace = 0;
-}
-
-static void SHA256_Final(uint8_t digest[], SHA256_CTX* context) {
-#if defined __arm__ || defined __ARM__ || defined ARM || defined __ARM || defined __arm || defined __ARM_ARCH ||defined __aarch64__ 
-        uint32_t	*d ;
-#else
-        uint32_t	*d = (uint32_t*)digest;
-
-#endif
-	unsigned int	usedspace;
-
-	/* Sanity check: */
-	assert(context != (SHA256_CTX*)0);
-#if defined __arm__ || defined __ARM__ || defined ARM || defined __ARM || defined __arm || defined __ARM_ARCH ||defined __aarch64__ 
-        d = malloc(sizeof(uint32_t)*8); /* why  8 ?  see below for loop */
-        assert(d);		   
-#endif
-	
-	/* If no digest buffer is passed, we don't bother doing this: */
-	if (digest != (uint8_t*)0) {
-		usedspace = (context->bitcount >> 3) % SHA256_BLOCK_LENGTH;
-#if BYTE_ORDER == LITTLE_ENDIAN
-		/* Convert FROM host byte order */
-		REVERSE64(context->bitcount,context->bitcount);
-#endif
-		if (usedspace > 0) {
-			/* Begin padding with a 1 bit: */
-			context->buffer[usedspace++] = 0x80;
-
-			if (usedspace <= SHA256_SHORT_BLOCK_LENGTH) {
-				/* Set-up for the last transform: */
-				MEMSET_BZERO(&context->buffer[usedspace], SHA256_SHORT_BLOCK_LENGTH - usedspace);
-			} else {
-				if (usedspace < SHA256_BLOCK_LENGTH) {
-					MEMSET_BZERO(&context->buffer[usedspace], SHA256_BLOCK_LENGTH - usedspace);
-				}
-				/* Do second-to-last transform: */
-#if defined __arm__ || defined __ARM__ || defined ARM || defined __ARM || defined __arm || defined __ARM_ARCH ||defined __aarch64__ 
-				SHA256_Transform(context, (uint32_t*)(void *)(context->buffer));
-#else
-				SHA256_Transform(context, (uint32_t*)context->buffer);
-#endif
-
-
-				/* And set-up for the last transform: */
-				MEMSET_BZERO(context->buffer, SHA256_SHORT_BLOCK_LENGTH);
-			}
-		} else {
-			/* Set-up for the last transform: */
-			MEMSET_BZERO(context->buffer, SHA256_SHORT_BLOCK_LENGTH);
-
-			/* Begin padding with a 1 bit: */
-			*context->buffer = 0x80;
-		}
-		/* Set the bit count: */
-		//*(uint64_t*)&context->buffer[SHA256_SHORT_BLOCK_LENGTH] = context->bitcount; // aliasing violation warning
-    context->buffer64[SHA256_SHORT_BLOCK_LENGTH / sizeof(uint64_t)] = context->bitcount;
-
-		/* Final transform: */
-#if defined __arm__ || defined __ARM__ || defined ARM || defined __ARM || defined __arm || defined __ARM_ARCH ||defined __aarch64__ 
-                SHA256_Transform(context, (uint32_t*)((void *)(context->buffer)));
-
-#else
-		SHA256_Transform(context, (uint32_t*)context->buffer);
-
-#endif
-
-#if BYTE_ORDER == LITTLE_ENDIAN
-		{
-			/* Convert TO host byte order */
-			int	j;
-			for (j = 0; j < 8; j++) {
-				REVERSE32(context->state[j],context->state[j]);
-				*d++ = context->state[j];
-			}
-		}
-#else
-		MEMCPY_BCOPY(d, context->state, SHA256_DIGEST_LENGTH);
-#endif
-	}
-
-#if defined __arm__ || defined __ARM__ || defined ARM || defined __ARM || defined __arm || defined __ARM_ARCH ||defined __aarch64__ 
-        memcpy(digest,d,SHA256_DIGEST_LENGTH);
-        free(d);		   
-#endif
-	
-	/* Clean up state data: */
-	MEMSET_BZERO(context, sizeof(*context));
-	usedspace = 0;
-}
-
-/*
-static char *SHA256_End(SHA256_CTX* context, char buffer[]) {
-	uint8_t	digest[SHA256_DIGEST_LENGTH], *d = digest;
-	int		i;
-
-	/ * Sanity check: * /
-	assert(context != (SHA256_CTX*)0);
-
-	if (buffer != (char*)0) {
-		SHA256_Final(digest, context);
-
-		for (i = 0; i < SHA256_DIGEST_LENGTH; i++) {
-			*buffer++ = sha2_hex_digits[(*d & 0xf0) >> 4];
-			*buffer++ = sha2_hex_digits[*d & 0x0f];
-			d++;
-		}
-		*buffer = (char)0;
-	} else {
-		MEMSET_BZERO(context, sizeof(context));
-	}
-	MEMSET_BZERO(digest, SHA256_DIGEST_LENGTH);
-	return buffer;
-}
-
-static char* SHA256_Data(const uint8_t* data, size_t len, char digest[SHA256_DIGEST_STRING_LENGTH]) {
-	SHA256_CTX	context;
-
-	SHA256_Init(&context);
-	SHA256_Update(&context, data, len);
-	return SHA256_End(&context, digest);
-}
-*/
-
-
-/*** SHA-512: *********************************************************/
-static void SHA512_Init(SHA512_CTX* context) {
-	if (context == (SHA512_CTX*)0) {
-		return;
-	}
-	MEMCPY_BCOPY(context->state, sha512_initial_hash_value, SHA512_DIGEST_LENGTH);
-	MEMSET_BZERO(context->buffer, SHA512_BLOCK_LENGTH);
-	context->bitcount[0] = context->bitcount[1] =  0;
-}
-
-#ifdef SHA2_UNROLL_TRANSFORM
-
-/* Unrolled SHA-512 round macros: */
-#if BYTE_ORDER == LITTLE_ENDIAN
-
-#define ROUND512_0_TO_15(a,b,c,d,e,f,g,h)	\
-	REVERSE64(*data++, W512[j]); \
-	T1 = (h) + Sigma1_512(e) + Ch((e), (f), (g)) + \
-             K512[j] + W512[j]; \
-	(d) += T1, \
-	(h) = T1 + Sigma0_512(a) + Maj((a), (b), (c)), \
-	j++
-
-
-#else /* BYTE_ORDER == LITTLE_ENDIAN */
-
-#define ROUND512_0_TO_15(a,b,c,d,e,f,g,h)	\
-	T1 = (h) + Sigma1_512(e) + Ch((e), (f), (g)) + \
-             K512[j] + (W512[j] = *data++); \
-	(d) += T1; \
-	(h) = T1 + Sigma0_512(a) + Maj((a), (b), (c)); \
-	j++
-
-#endif /* BYTE_ORDER == LITTLE_ENDIAN */
-
-#define ROUND512(a,b,c,d,e,f,g,h)	\
-	s0 = W512[(j+1)&0x0f]; \
-	s0 = sigma0_512(s0); \
-	s1 = W512[(j+14)&0x0f]; \
-	s1 = sigma1_512(s1); \
-	T1 = (h) + Sigma1_512(e) + Ch((e), (f), (g)) + K512[j] + \
-             (W512[j&0x0f] += s1 + W512[(j+9)&0x0f] + s0); \
-	(d) += T1; \
-	(h) = T1 + Sigma0_512(a) + Maj((a), (b), (c)); \
-	j++
-
-static void SHA512_Transform(SHA512_CTX* context, const uint64_t* data) {
-	uint64_t	a, b, c, d, e, f, g, h, s0, s1;
-	uint64_t	T1, *W512 = (uint64_t*)context->buffer;
-	int		j;
-
-	/* Initialize registers with the prev. intermediate value */
-	a = context->state[0];
-	b = context->state[1];
-	c = context->state[2];
-	d = context->state[3];
-	e = context->state[4];
-	f = context->state[5];
-	g = context->state[6];
-	h = context->state[7];
-
-	j = 0;
-	do {
-		ROUND512_0_TO_15(a,b,c,d,e,f,g,h);
-		ROUND512_0_TO_15(h,a,b,c,d,e,f,g);
-		ROUND512_0_TO_15(g,h,a,b,c,d,e,f);
-		ROUND512_0_TO_15(f,g,h,a,b,c,d,e);
-		ROUND512_0_TO_15(e,f,g,h,a,b,c,d);
-		ROUND512_0_TO_15(d,e,f,g,h,a,b,c);
-		ROUND512_0_TO_15(c,d,e,f,g,h,a,b);
-		ROUND512_0_TO_15(b,c,d,e,f,g,h,a);
-	} while (j < 16);
-
-	/* Now for the remaining rounds up to 79: */
-	do {
-		ROUND512(a,b,c,d,e,f,g,h);
-		ROUND512(h,a,b,c,d,e,f,g);
-		ROUND512(g,h,a,b,c,d,e,f);
-		ROUND512(f,g,h,a,b,c,d,e);
-		ROUND512(e,f,g,h,a,b,c,d);
-		ROUND512(d,e,f,g,h,a,b,c);
-		ROUND512(c,d,e,f,g,h,a,b);
-		ROUND512(b,c,d,e,f,g,h,a);
-	} while (j < 80);
-
-	/* Compute the current intermediate hash value */
-	context->state[0] += a;
-	context->state[1] += b;
-	context->state[2] += c;
-	context->state[3] += d;
-	context->state[4] += e;
-	context->state[5] += f;
-	context->state[6] += g;
-	context->state[7] += h;
-
-	/* Clean up */
-	a = b = c = d = e = f = g = h = T1 = 0;
-}
-
-#else /* SHA2_UNROLL_TRANSFORM */
-
-static void SHA512_Transform(SHA512_CTX* context, const uint64_t* data) {
-	uint64_t	a, b, c, d, e, f, g, h, s0, s1;
-	uint64_t	T1, T2, *W512 = (uint64_t*)((void *)context->buffer);
-	int		j;
-
-	/* Initialize registers with the prev. intermediate value */
-	a = context->state[0];
-	b = context->state[1];
-	c = context->state[2];
-	d = context->state[3];
-	e = context->state[4];
-	f = context->state[5];
-	g = context->state[6];
-	h = context->state[7];
-
-	j = 0;
-	do {
-#if BYTE_ORDER == LITTLE_ENDIAN
-		/* Convert TO host byte order */
-		REVERSE64(*data++, W512[j]);
-		/* Apply the SHA-512 compression function to update a..h */
-		T1 = h + Sigma1_512(e) + Ch(e, f, g) + K512[j] + W512[j];
-#else /* BYTE_ORDER == LITTLE_ENDIAN */
-		/* Apply the SHA-512 compression function to update a..h with copy */
-		T1 = h + Sigma1_512(e) + Ch(e, f, g) + K512[j] + (W512[j] = *data++);
-#endif /* BYTE_ORDER == LITTLE_ENDIAN */
-		T2 = Sigma0_512(a) + Maj(a, b, c);
-		h = g;
-		g = f;
-		f = e;
-		e = d + T1;
-		d = c;
-		c = b;
-		b = a;
-		a = T1 + T2;
-
-		j++;
-	} while (j < 16);
-
-	do {
-		/* Part of the message block expansion: */
-		s0 = W512[(j+1)&0x0f];
-		s0 = sigma0_512(s0);
-		s1 = W512[(j+14)&0x0f];
-		s1 =  sigma1_512(s1);
-
-		/* Apply the SHA-512 compression function to update a..h */
-		T1 = h + Sigma1_512(e) + Ch(e, f, g) + K512[j] +
-		     (W512[j&0x0f] += s1 + W512[(j+9)&0x0f] + s0);
-		T2 = Sigma0_512(a) + Maj(a, b, c);
-		h = g;
-		g = f;
-		f = e;
-		e = d + T1;
-		d = c;
-		c = b;
-		b = a;
-		a = T1 + T2;
-
-		j++;
-	} while (j < 80);
-
-	/* Compute the current intermediate hash value */
-	context->state[0] += a;
-	context->state[1] += b;
-	context->state[2] += c;
-	context->state[3] += d;
-	context->state[4] += e;
-	context->state[5] += f;
-	context->state[6] += g;
-	context->state[7] += h;
-
-	/* Clean up */
-	a = b = c = d = e = f = g = h = T1 = T2 = 0;
-}
-
-#endif /* SHA2_UNROLL_TRANSFORM */
-
-static void SHA512_Update(SHA512_CTX* context, const uint8_t *data, size_t len) {
-	unsigned int	freespace, usedspace;
-
-	if (len == 0) {
-		/* Calling with no data is valid - we do nothing */
-		return;
-	}
-
-	/* Sanity check: */
-	assert(context != (SHA512_CTX*)0 && data != (uint8_t*)0);
-
-	usedspace = (context->bitcount[0] >> 3) % SHA512_BLOCK_LENGTH;
-	if (usedspace > 0) {
-		/* Calculate how much free space is available in the buffer */
-		freespace = SHA512_BLOCK_LENGTH - usedspace;
-
-		if (len >= freespace) {
-			/* Fill the buffer completely and process it */
-			MEMCPY_BCOPY(&context->buffer[usedspace], data, freespace);
-			ADDINC128(context->bitcount, freespace << 3);
-			len -= freespace;
-			data += freespace;
-#if defined __arm__ || defined __ARM__ || defined ARM || defined __ARM || defined __arm || defined __ARM_ARCH ||defined __aarch64__ 
-			SHA512_Transform(context, (uint64_t*)((void *)context->buffer));
-#else
-			SHA512_Transform(context, (uint64_t*)context->buffer);
-#endif
-		} else {
-			/* The buffer is not yet full */
-			MEMCPY_BCOPY(&context->buffer[usedspace], data, len);
-			ADDINC128(context->bitcount, len << 3);
-			/* Clean up: */
-			usedspace = freespace = 0;
-			return;
-		}
-	}
-	while (len >= SHA512_BLOCK_LENGTH) {
-		/* Process as many complete blocks as we can */
-#if defined __arm__ || defined __ARM__ || defined ARM || defined __ARM || defined __arm || defined __ARM_ARCH ||defined __aarch64__ 
-  	                SHA512_Transform(context, (uint64_t*)((void *)context->buffer));
-#else
-			SHA512_Transform(context, (uint64_t*)context->buffer);
-#endif
-		ADDINC128(context->bitcount, SHA512_BLOCK_LENGTH << 3);
-		len -= SHA512_BLOCK_LENGTH;
-		data += SHA512_BLOCK_LENGTH;
-	}
-	if (len > 0) {
-		/* There's left-overs, so save 'em */
-		MEMCPY_BCOPY(context->buffer, data, len);
-		ADDINC128(context->bitcount, len << 3);
-	}
-	/* Clean up: */
-	usedspace = freespace = 0;
-}
-
-static void SHA512_Last(SHA512_CTX* context) {
-	unsigned int	usedspace;
-
-	usedspace = (context->bitcount[0] >> 3) % SHA512_BLOCK_LENGTH;
-#if BYTE_ORDER == LITTLE_ENDIAN
-	/* Convert FROM host byte order */
-	REVERSE64(context->bitcount[0],context->bitcount[0]);
-	REVERSE64(context->bitcount[1],context->bitcount[1]);
-#endif
-	if (usedspace > 0) {
-		/* Begin padding with a 1 bit: */
-		context->buffer[usedspace++] = 0x80;
-
-		if (usedspace <= SHA512_SHORT_BLOCK_LENGTH) {
-			/* Set-up for the last transform: */
-			MEMSET_BZERO(&context->buffer[usedspace], SHA512_SHORT_BLOCK_LENGTH - usedspace);
-		} else {
-			if (usedspace < SHA512_BLOCK_LENGTH) {
-				MEMSET_BZERO(&context->buffer[usedspace], SHA512_BLOCK_LENGTH - usedspace);
-			}
-			/* Do second-to-last transform: */
-#if defined __arm__ || defined __ARM__ || defined ARM || defined __ARM || defined __arm || defined __ARM_ARCH ||defined __aarch64__ 
-			SHA512_Transform(context, (uint64_t*)((void *)context->buffer));
-#else
-			SHA512_Transform(context, (uint64_t*)context->buffer);
-#endif
-
-
-			/* And set-up for the last transform: */
-			MEMSET_BZERO(context->buffer, SHA512_BLOCK_LENGTH - 2);
-		}
-	} else {
-		/* Prepare for final transform: */
-		MEMSET_BZERO(context->buffer, SHA512_SHORT_BLOCK_LENGTH);
-
-		/* Begin padding with a 1 bit: */
-		*context->buffer = 0x80;
-	}
-	/* Store the length of input data (in bits): */
-	//*(uint64_t*)&context->buffer[SHA512_SHORT_BLOCK_LENGTH] = context->bitcount[1]; // aliasing violation warning
-	//*(uint64_t*)&context->buffer[SHA512_SHORT_BLOCK_LENGTH+8] = context->bitcount[0];
-  context->buffer64[SHA512_SHORT_BLOCK_LENGTH / sizeof(uint64_t)] = context->bitcount[1];
-  context->buffer64[SHA512_SHORT_BLOCK_LENGTH / sizeof(uint64_t) + 1] = context->bitcount[0];
-
-	/* Final transform: */
-#if defined __arm__ || defined __ARM__ || defined ARM || defined __ARM || defined __arm || defined __ARM_ARCH ||defined __aarch64__ 
-        SHA512_Transform(context, (uint64_t*)((void *)context->buffer));
-#else
-	SHA512_Transform(context, (uint64_t*)context->buffer);
-#endif
-
-}
-
-static void SHA512_Final(uint8_t digest[], SHA512_CTX* context) {
-#if defined __arm__ || defined __ARM__ || defined ARM || defined __ARM || defined __arm || defined __ARM_ARCH ||defined __aarch64__ 
-        uint64_t	*d ;
-#else
-        uint64_t	*d = (uint64_t*)digest;
-
-#endif
-
-	/* Sanity check: */
-	assert(context != (SHA512_CTX*)0);
-#if defined __arm__ || defined __ARM__ || defined ARM || defined __ARM || defined __arm || defined __ARM_ARCH ||defined __aarch64__ 
-        d = malloc(sizeof(uint64_t)*8); /* why  8 ?  see below for loop */
-        assert(d);		   
-#endif
-
-	/* If no digest buffer is passed, we don't bother doing this: */
-	if (digest != (uint8_t*)0) {
-		SHA512_Last(context);
-
-		/* Save the hash data for output: */
-#if BYTE_ORDER == LITTLE_ENDIAN
-		{
-			/* Convert TO host byte order */
-			int	j;
-			for (j = 0; j < 8; j++) {
-				REVERSE64(context->state[j],context->state[j]);
-				*d++ = context->state[j];
-			}
-		}
-#else
-		MEMCPY_BCOPY(d, context->state, SHA512_DIGEST_LENGTH);
-#endif
-	}
-#if defined __arm__ || defined __ARM__ || defined ARM || defined __ARM || defined __arm || defined __ARM_ARCH ||defined __aarch64__ 
-        memcpy(digest,d,SHA512_DIGEST_LENGTH);
-        free(d);		   
-#endif
-
-	/* Zero out state data */
-	MEMSET_BZERO(context, sizeof(*context));
-}
-
-/*
-static char *SHA512_End(SHA512_CTX* context, char buffer[]) {
-	uint8_t	digest[SHA512_DIGEST_LENGTH], *d = digest;
-	int		i;
-
-	/ * Sanity check: * /
-	assert(context != (SHA512_CTX*)0);
-
-	if (buffer != (char*)0) {
-		SHA512_Final(digest, context);
-
-		for (i = 0; i < SHA512_DIGEST_LENGTH; i++) {
-			*buffer++ = sha2_hex_digits[(*d & 0xf0) >> 4];
-			*buffer++ = sha2_hex_digits[*d & 0x0f];
-			d++;
-		}
-		*buffer = (char)0;
-	} else {
-		MEMSET_BZERO(context, sizeof(context));
-	}
-	MEMSET_BZERO(digest, SHA512_DIGEST_LENGTH);
-	return buffer;
-}
-
-static char* SHA512_Data(const uint8_t* data, size_t len, char digest[SHA512_DIGEST_STRING_LENGTH]) {
-	SHA512_CTX	context;
-
-	SHA512_Init(&context);
-	SHA512_Update(&context, data, len);
-	return SHA512_End(&context, digest);
-}
-*/
-
-/*** SHA-384: *********************************************************/
-static void SHA384_Init(SHA384_CTX* context) {
-	if (context == (SHA384_CTX*)0) {
-		return;
-	}
-	MEMCPY_BCOPY(context->state, sha384_initial_hash_value, SHA512_DIGEST_LENGTH);
-	MEMSET_BZERO(context->buffer, SHA384_BLOCK_LENGTH);
-	context->bitcount[0] = context->bitcount[1] = 0;
-}
-
-static void SHA384_Update(SHA384_CTX* context, const uint8_t* data, size_t len) {
-	SHA512_Update((SHA512_CTX*)context, data, len);
-}
-
-static void SHA384_Final(uint8_t digest[], SHA384_CTX* context) {
-#if defined __arm__ || defined __ARM__ || defined ARM || defined __ARM || defined __arm || defined __ARM_ARCH ||defined __aarch64__ 
-        uint64_t	*d;
-#else
-        uint64_t	*d = (uint64_t*)digest;
-#endif
-
-
-
-	/* Sanity check: */
-	assert(context != (SHA384_CTX*)0);
-#if defined __arm__ || defined __ARM__ || defined ARM || defined __ARM || defined __arm || defined __ARM_ARCH ||defined __aarch64__ 
-        d = malloc(sizeof(uint64_t)*6); /* why  6 ?  see below for loop */
-        assert(d);		   
-#endif
-
-	/* If no digest buffer is passed, we don't bother doing this: */
-	if (digest != (uint8_t*)0) {
-		SHA512_Last((SHA512_CTX*)context);
-
-		/* Save the hash data for output: */
-#if BYTE_ORDER == LITTLE_ENDIAN
-		{
-			/* Convert TO host byte order */
-			int	j;
-			for (j = 0; j < 6; j++) {
-				REVERSE64(context->state[j],context->state[j]);
-				*d++ = context->state[j];
-			}
-		}
-#else
-		MEMCPY_BCOPY(d, context->state, SHA384_DIGEST_LENGTH);
-#endif
-	}
-#if defined __arm__ || defined __ARM__ || defined ARM || defined __ARM || defined __arm || defined __ARM_ARCH ||defined __aarch64__ 
-        memcpy(digest,d,SHA384_DIGEST_LENGTH);
-        free(d);		   
-#endif
-	/* Zero out state data */
-	MEMSET_BZERO(context, sizeof(*context));
-}
-
-/*
-static char *SHA384_End(SHA384_CTX* context, char buffer[]) {
-	uint8_t	digest[SHA384_DIGEST_LENGTH], *d = digest;
-	int		i;
-
-	/ * Sanity check: * /
-	assert(context != (SHA384_CTX*)0);
-
-	if (buffer != (char*)0) {
-		SHA384_Final(digest, context);
-
-		for (i = 0; i < SHA384_DIGEST_LENGTH; i++) {
-			*buffer++ = sha2_hex_digits[(*d & 0xf0) >> 4];
-			*buffer++ = sha2_hex_digits[*d & 0x0f];
-			d++;
-		}
-		*buffer = (char)0;
-	} else {
-		MEMSET_BZERO(context, sizeof(context));
-	}
-	MEMSET_BZERO(digest, SHA384_DIGEST_LENGTH);
-	return buffer;
-}
-
-static char* SHA384_Data(const uint8_t* data, size_t len, char digest[SHA384_DIGEST_STRING_LENGTH]) {
-	SHA384_CTX	context;
-
-	SHA384_Init(&context);
-	SHA384_Update(&context, data, len);
-	return SHA384_End(&context, digest);
-}
-*/
-
-/* end of sha2.c */
-
-void sha256_init (sha256_state *state)
-{
-  SHA256_Init(state);
-}
-
-void sha384_init (sha384_state *state)
-{
-  SHA384_Init(state);
-}
-
-void sha512_init (sha512_state *state)
-{
-  SHA512_Init(state);
-}
-
-
-void sha256_add (sha256_state *state, const void *data, size_t size)
-{
-  SHA256_Update(state, (const uint8_t *)data, size);
-}
-
-void sha384_add (sha384_state *state, const void *data, size_t size)
-{
-  SHA384_Update(state, (const uint8_t *)data, size);
-}
-
-void sha512_add (sha512_state *state, const void *data, size_t size)
-{
-  SHA512_Update(state, (const uint8_t *)data, size);
-}
-
-
-void sha256_put (sha256_state *state, uint8_t digest[SHA256_DIGEST_LENGTH])
-{
-  SHA256_Final(digest, state);
-}
-
-void sha384_put (sha384_state *state, uint8_t digest[SHA384_DIGEST_LENGTH])
-{
-  SHA384_Final(digest, state);
-}
-
-void sha512_put (sha384_state *state, uint8_t digest[SHA512_DIGEST_LENGTH])
-{
-  SHA512_Final(digest, state);
-}
-
-
-void sha256 (const void *data, size_t size, uint8_t digest[SHA256_DIGEST_LENGTH])
-{
-  sha256_state state;
-  SHA256_Init(&state);
-  SHA256_Update(&state, (const uint8_t *)data, size);
-  SHA256_Final(digest, &state);
-}
-
-void sha384 (const void *data, size_t size, uint8_t digest[SHA384_DIGEST_LENGTH])
-{
-  sha384_state state;
-  SHA384_Init(&state);
-  SHA384_Update(&state, (const uint8_t *)data, size);
-  SHA384_Final(digest, &state);
-}
-
-void sha512 (const void *data, size_t size, uint8_t digest[SHA512_DIGEST_LENGTH])
-{
-  sha512_state state;
-  SHA512_Init(&state);
-  SHA512_Update(&state, (const uint8_t *)data, size);
-  SHA512_Final(digest, &state);
-}
-
-static sha256_state sha256state;
-static sha384_state sha384state;
-static sha512_state sha512state;
-
-
-void sha256init (void)
-{
-  SHA256_Init(&sha256state);
-}
-
-void sha384init (void)
-{
-  SHA384_Init(&sha384state);
-}
-
-void sha512init (void)
-{
-  SHA512_Init(&sha512state);
-}
-
-
-void sha256add (const void *data, size_t size)
-{
-  SHA256_Update(&sha256state, (const uint8_t *)data, size);
-}
-
-void sha384add (const void *data, size_t size)
-{
-  SHA384_Update(&sha384state, (const uint8_t *)data, size);
-}
-
-void sha512add (const void *data, size_t size)
-{
-  SHA512_Update(&sha512state, (const uint8_t *)data, size);
-}
-
-
-void sha256put (uint8_t digest[SHA256_DIGEST_LENGTH])
-{
-  SHA256_Final(digest, &sha256state);
-}
-
-void sha384put (uint8_t digest[SHA384_DIGEST_LENGTH])
-{
-  SHA384_Final(digest, &sha384state);
-}
-
-void sha512put (uint8_t digest[SHA512_DIGEST_LENGTH])
-{
-  SHA512_Final(digest, &sha512state);
-}
--- texlive-bin.orig/texk/web2c/luatexdir/luapplib/util/utilsha.c-OK
+++ /dev/null
@@ -1,1198 +0,0 @@
-/* sha2 implementation by Aaron D. Gifford (http://www.aarongifford.com) */
-
-#define BYTE_ORDER LITTLE_ENDIAN
-
-/* begin of sha2.c */
-
-/*
- * FILE:	sha2.c
- * AUTHOR:	Aaron D. Gifford - http://www.aarongifford.com/
- *
- * Copyright (c) 2000-2001, Aaron D. Gifford
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holder nor the names of contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTOR(S) ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTOR(S) BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- * $Id: sha2.c,v 1.1 2001/11/08 00:01:51 adg Exp adg $
- */
-
-#include <string.h>	/* memcpy()/memset() or bcopy()/bzero() */
-#include <assert.h>	/* assert() */
-//#include "sha2.h"
-#include "utilsha.h"
-
-/*
- * ASSERT NOTE:
- * Some sanity checking code is included using assert().  On my FreeBSD
- * system, this additional code can be removed by compiling with NDEBUG
- * defined.  Check your own systems manpage on assert() to see how to
- * compile WITHOUT the sanity checking code on your system.
- *
- * UNROLLED TRANSFORM LOOP NOTE:
- * You can define SHA2_UNROLL_TRANSFORM to use the unrolled transform
- * loop version for the hash transform rounds (defined using macros
- * later in this file).  Either define on the command line, for example:
- *
- *   cc -DSHA2_UNROLL_TRANSFORM -o sha2 sha2.c sha2prog.c
- *
- * or define below:
- *
- *   #define SHA2_UNROLL_TRANSFORM
- *
- */
-
-
-/*** SHA-256/384/512 Machine Architecture Definitions *****************/
-/*
- * BYTE_ORDER NOTE:
- *
- * Please make sure that your system defines BYTE_ORDER.  If your
- * architecture is little-endian, make sure it also defines
- * LITTLE_ENDIAN and that the two (BYTE_ORDER and LITTLE_ENDIAN) are
- * equivilent.
- *
- * If your system does not define the above, then you can do so by
- * hand like this:
- *
- *   #define LITTLE_ENDIAN 1234
- *   #define BIG_ENDIAN    4321
- *
- * And for little-endian machines, add:
- *
- *   #define BYTE_ORDER LITTLE_ENDIAN
- *
- * Or for big-endian machines:
- *
- *   #define BYTE_ORDER BIG_ENDIAN
- *
- * The FreeBSD machine this was written on defines BYTE_ORDER
- * appropriately by including <sys/types.h> (which in turn includes
- * <machine/endian.h> where the appropriate definitions are actually
- * made).
- */
-#if !defined(BYTE_ORDER) || (BYTE_ORDER != LITTLE_ENDIAN && BYTE_ORDER != BIG_ENDIAN)
-#error Define BYTE_ORDER to be equal to either LITTLE_ENDIAN or BIG_ENDIAN
-#endif
-
-/*
- * Define the followingsha2_* types to types of the correct length on
- * the native archtecture.   Most BSD systems and Linux define u_intXX_t
- * types.  Machines with very recent ANSI C headers, can use the
- * uintXX_t definintions from inttypes.h by defining SHA2_USE_INTTYPES_H
- * during compile or in the sha.h header file.
- *
- * Machines that support neither u_intXX_t nor inttypes.h's uintXX_t
- * will need to define these three typedefs below (and the appropriate
- * ones in sha.h too) by hand according to their system architecture.
- *
- * Thank you, Jun-ichiro itojun Hagino, for suggesting using u_intXX_t
- * types and pointing out recent ANSI C support for uintXX_t in inttypes.h.
- *
- * PJ: replace by uintX_t
- */
-
-//typedef uint8_t  sha2_byte;	/* Exactly 1 byte */
-//typedef uint32_t sha2_word32;	/* Exactly 4 bytes */
-//typedef uint64_t sha2_word64;	/* Exactly 8 bytes */
-
-/*** SHA-256/384/512 Various Length Definitions ***********************/
-/* NOTE: Most of these are in sha2.h */
-#define SHA256_SHORT_BLOCK_LENGTH	(SHA256_BLOCK_LENGTH - 8)
-#define SHA384_SHORT_BLOCK_LENGTH	(SHA384_BLOCK_LENGTH - 16)
-#define SHA512_SHORT_BLOCK_LENGTH	(SHA512_BLOCK_LENGTH - 16)
-
-
-/*** ENDIAN REVERSAL MACROS *******************************************/
-#if BYTE_ORDER == LITTLE_ENDIAN
-#define REVERSE32(w,x)	{ \
-	uint32_t tmp = (w); \
-	tmp = (tmp >> 16) | (tmp << 16); \
-	(x) = ((tmp & 0xff00ff00UL) >> 8) | ((tmp & 0x00ff00ffUL) << 8); \
-}
-#define REVERSE64(w,x)	{ \
-	uint64_t tmp = (w); \
-	tmp = (tmp >> 32) | (tmp << 32); \
-	tmp = ((tmp & 0xff00ff00ff00ff00ULL) >> 8) | \
-	      ((tmp & 0x00ff00ff00ff00ffULL) << 8); \
-	(x) = ((tmp & 0xffff0000ffff0000ULL) >> 16) | \
-	      ((tmp & 0x0000ffff0000ffffULL) << 16); \
-}
-#endif /* BYTE_ORDER == LITTLE_ENDIAN */
-
-/*
- * Macro for incrementally adding the unsigned 64-bit integer n to the
- * unsigned 128-bit integer (represented using a two-element array of
- * 64-bit words):
- */
-#define ADDINC128(w,n)	{ \
-	(w)[0] += (uint64_t)(n); \
-	if ((w)[0] < (n)) { \
-		(w)[1]++; \
-	} \
-}
-
-/*
- * Macros for copying blocks of memory and for zeroing out ranges
- * of memory.  Using these macros makes it easy to switch from
- * using memset()/memcpy() and using bzero()/bcopy().
- *
- * Please define either SHA2_USE_MEMSET_MEMCPY or define
- * SHA2_USE_BZERO_BCOPY depending on which function set you
- * choose to use:
- */
-#if !defined(SHA2_USE_MEMSET_MEMCPY) && !defined(SHA2_USE_BZERO_BCOPY)
-/* Default to memset()/memcpy() if no option is specified */
-#define	SHA2_USE_MEMSET_MEMCPY	1
-#endif
-#if defined(SHA2_USE_MEMSET_MEMCPY) && defined(SHA2_USE_BZERO_BCOPY)
-/* Abort with an error if BOTH options are defined */
-#error Define either SHA2_USE_MEMSET_MEMCPY or SHA2_USE_BZERO_BCOPY, not both!
-#endif
-
-#ifdef SHA2_USE_MEMSET_MEMCPY
-#define MEMSET_BZERO(p,l)	memset((p), 0, (l))
-#define MEMCPY_BCOPY(d,s,l)	memcpy((d), (s), (l))
-#endif
-#ifdef SHA2_USE_BZERO_BCOPY
-#define MEMSET_BZERO(p,l)	bzero((p), (l))
-#define MEMCPY_BCOPY(d,s,l)	bcopy((s), (d), (l))
-#endif
-
-
-/*** THE SIX LOGICAL FUNCTIONS ****************************************/
-/*
- * Bit shifting and rotation (used by the six SHA-XYZ logical functions:
- *
- *   NOTE:  The naming of R and S appears backwards here (R is a SHIFT and
- *   S is a ROTATION) because the SHA-256/384/512 description document
- *   (see http://csrc.nist.gov/cryptval/shs/sha256-384-512.pdf) uses this
- *   same "backwards" definition.
- */
-/* Shift-right (used in SHA-256, SHA-384, and SHA-512): */
-#define R(b,x) 		((x) >> (b))
-/* 32-bit Rotate-right (used in SHA-256): */
-#define S32(b,x)	(((x) >> (b)) | ((x) << (32 - (b))))
-/* 64-bit Rotate-right (used in SHA-384 and SHA-512): */
-#define S64(b,x)	(((x) >> (b)) | ((x) << (64 - (b))))
-
-/* Two of six logical functions used in SHA-256, SHA-384, and SHA-512: */
-#define Ch(x,y,z)	(((x) & (y)) ^ ((~(x)) & (z)))
-#define Maj(x,y,z)	(((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z)))
-
-/* Four of six logical functions used in SHA-256: */
-#define Sigma0_256(x)	(S32(2,  (x)) ^ S32(13, (x)) ^ S32(22, (x)))
-#define Sigma1_256(x)	(S32(6,  (x)) ^ S32(11, (x)) ^ S32(25, (x)))
-#define sigma0_256(x)	(S32(7,  (x)) ^ S32(18, (x)) ^ R(3 ,   (x)))
-#define sigma1_256(x)	(S32(17, (x)) ^ S32(19, (x)) ^ R(10,   (x)))
-
-/* Four of six logical functions used in SHA-384 and SHA-512: */
-#define Sigma0_512(x)	(S64(28, (x)) ^ S64(34, (x)) ^ S64(39, (x)))
-#define Sigma1_512(x)	(S64(14, (x)) ^ S64(18, (x)) ^ S64(41, (x)))
-#define sigma0_512(x)	(S64( 1, (x)) ^ S64( 8, (x)) ^ R( 7,   (x)))
-#define sigma1_512(x)	(S64(19, (x)) ^ S64(61, (x)) ^ R( 6,   (x)))
-
-/*** INTERNAL FUNCTION PROTOTYPES *************************************/
-/* NOTE: These should not be accessed directly from outside this
- * library -- they are intended for private internal visibility/use
- * only.
- */
-static void SHA512_Last(SHA512_CTX*);
-static void SHA256_Transform(SHA256_CTX*, const uint32_t*);
-static void SHA512_Transform(SHA512_CTX*, const uint64_t*);
-
-
-/*** SHA-XYZ INITIAL HASH VALUES AND CONSTANTS ************************/
-/* Hash constant words K for SHA-256: */
-static const uint32_t K256[64] = {
-	0x428a2f98UL, 0x71374491UL, 0xb5c0fbcfUL, 0xe9b5dba5UL,
-	0x3956c25bUL, 0x59f111f1UL, 0x923f82a4UL, 0xab1c5ed5UL,
-	0xd807aa98UL, 0x12835b01UL, 0x243185beUL, 0x550c7dc3UL,
-	0x72be5d74UL, 0x80deb1feUL, 0x9bdc06a7UL, 0xc19bf174UL,
-	0xe49b69c1UL, 0xefbe4786UL, 0x0fc19dc6UL, 0x240ca1ccUL,
-	0x2de92c6fUL, 0x4a7484aaUL, 0x5cb0a9dcUL, 0x76f988daUL,
-	0x983e5152UL, 0xa831c66dUL, 0xb00327c8UL, 0xbf597fc7UL,
-	0xc6e00bf3UL, 0xd5a79147UL, 0x06ca6351UL, 0x14292967UL,
-	0x27b70a85UL, 0x2e1b2138UL, 0x4d2c6dfcUL, 0x53380d13UL,
-	0x650a7354UL, 0x766a0abbUL, 0x81c2c92eUL, 0x92722c85UL,
-	0xa2bfe8a1UL, 0xa81a664bUL, 0xc24b8b70UL, 0xc76c51a3UL,
-	0xd192e819UL, 0xd6990624UL, 0xf40e3585UL, 0x106aa070UL,
-	0x19a4c116UL, 0x1e376c08UL, 0x2748774cUL, 0x34b0bcb5UL,
-	0x391c0cb3UL, 0x4ed8aa4aUL, 0x5b9cca4fUL, 0x682e6ff3UL,
-	0x748f82eeUL, 0x78a5636fUL, 0x84c87814UL, 0x8cc70208UL,
-	0x90befffaUL, 0xa4506cebUL, 0xbef9a3f7UL, 0xc67178f2UL
-};
-
-/* Initial hash value H for SHA-256: */
-static const uint32_t sha256_initial_hash_value[8] = {
-	0x6a09e667UL,
-	0xbb67ae85UL,
-	0x3c6ef372UL,
-	0xa54ff53aUL,
-	0x510e527fUL,
-	0x9b05688cUL,
-	0x1f83d9abUL,
-	0x5be0cd19UL
-};
-
-/* Hash constant words K for SHA-384 and SHA-512: */
-static const uint64_t K512[80] = {
-	0x428a2f98d728ae22ULL, 0x7137449123ef65cdULL,
-	0xb5c0fbcfec4d3b2fULL, 0xe9b5dba58189dbbcULL,
-	0x3956c25bf348b538ULL, 0x59f111f1b605d019ULL,
-	0x923f82a4af194f9bULL, 0xab1c5ed5da6d8118ULL,
-	0xd807aa98a3030242ULL, 0x12835b0145706fbeULL,
-	0x243185be4ee4b28cULL, 0x550c7dc3d5ffb4e2ULL,
-	0x72be5d74f27b896fULL, 0x80deb1fe3b1696b1ULL,
-	0x9bdc06a725c71235ULL, 0xc19bf174cf692694ULL,
-	0xe49b69c19ef14ad2ULL, 0xefbe4786384f25e3ULL,
-	0x0fc19dc68b8cd5b5ULL, 0x240ca1cc77ac9c65ULL,
-	0x2de92c6f592b0275ULL, 0x4a7484aa6ea6e483ULL,
-	0x5cb0a9dcbd41fbd4ULL, 0x76f988da831153b5ULL,
-	0x983e5152ee66dfabULL, 0xa831c66d2db43210ULL,
-	0xb00327c898fb213fULL, 0xbf597fc7beef0ee4ULL,
-	0xc6e00bf33da88fc2ULL, 0xd5a79147930aa725ULL,
-	0x06ca6351e003826fULL, 0x142929670a0e6e70ULL,
-	0x27b70a8546d22ffcULL, 0x2e1b21385c26c926ULL,
-	0x4d2c6dfc5ac42aedULL, 0x53380d139d95b3dfULL,
-	0x650a73548baf63deULL, 0x766a0abb3c77b2a8ULL,
-	0x81c2c92e47edaee6ULL, 0x92722c851482353bULL,
-	0xa2bfe8a14cf10364ULL, 0xa81a664bbc423001ULL,
-	0xc24b8b70d0f89791ULL, 0xc76c51a30654be30ULL,
-	0xd192e819d6ef5218ULL, 0xd69906245565a910ULL,
-	0xf40e35855771202aULL, 0x106aa07032bbd1b8ULL,
-	0x19a4c116b8d2d0c8ULL, 0x1e376c085141ab53ULL,
-	0x2748774cdf8eeb99ULL, 0x34b0bcb5e19b48a8ULL,
-	0x391c0cb3c5c95a63ULL, 0x4ed8aa4ae3418acbULL,
-	0x5b9cca4f7763e373ULL, 0x682e6ff3d6b2b8a3ULL,
-	0x748f82ee5defb2fcULL, 0x78a5636f43172f60ULL,
-	0x84c87814a1f0ab72ULL, 0x8cc702081a6439ecULL,
-	0x90befffa23631e28ULL, 0xa4506cebde82bde9ULL,
-	0xbef9a3f7b2c67915ULL, 0xc67178f2e372532bULL,
-	0xca273eceea26619cULL, 0xd186b8c721c0c207ULL,
-	0xeada7dd6cde0eb1eULL, 0xf57d4f7fee6ed178ULL,
-	0x06f067aa72176fbaULL, 0x0a637dc5a2c898a6ULL,
-	0x113f9804bef90daeULL, 0x1b710b35131c471bULL,
-	0x28db77f523047d84ULL, 0x32caab7b40c72493ULL,
-	0x3c9ebe0a15c9bebcULL, 0x431d67c49c100d4cULL,
-	0x4cc5d4becb3e42b6ULL, 0x597f299cfc657e2aULL,
-	0x5fcb6fab3ad6faecULL, 0x6c44198c4a475817ULL
-};
-
-/* Initial hash value H for SHA-384 */
-static const uint64_t sha384_initial_hash_value[8] = {
-	0xcbbb9d5dc1059ed8ULL,
-	0x629a292a367cd507ULL,
-	0x9159015a3070dd17ULL,
-	0x152fecd8f70e5939ULL,
-	0x67332667ffc00b31ULL,
-	0x8eb44a8768581511ULL,
-	0xdb0c2e0d64f98fa7ULL,
-	0x47b5481dbefa4fa4ULL
-};
-
-/* Initial hash value H for SHA-512 */
-static const uint64_t sha512_initial_hash_value[8] = {
-	0x6a09e667f3bcc908ULL,
-	0xbb67ae8584caa73bULL,
-	0x3c6ef372fe94f82bULL,
-	0xa54ff53a5f1d36f1ULL,
-	0x510e527fade682d1ULL,
-	0x9b05688c2b3e6c1fULL,
-	0x1f83d9abfb41bd6bULL,
-	0x5be0cd19137e2179ULL
-};
-
-/*
- * Constant used by SHA256/384/512_End() functions for converting the
- * digest to a readable hexadecimal character string:
- */
-
-//static const char *sha2_hex_digits = "0123456789abcdef"; // PJ
-
-
-/*** SHA-256: *********************************************************/
-static void SHA256_Init(SHA256_CTX* context) {
-	if (context == (SHA256_CTX*)0) {
-		return;
-	}
-	MEMCPY_BCOPY(context->state, sha256_initial_hash_value, SHA256_DIGEST_LENGTH);
-	MEMSET_BZERO(context->buffer, SHA256_BLOCK_LENGTH);
-	context->bitcount = 0;
-}
-
-#ifdef SHA2_UNROLL_TRANSFORM
-
-/* Unrolled SHA-256 round macros: */
-
-#if BYTE_ORDER == LITTLE_ENDIAN
-
-#define ROUND256_0_TO_15(a,b,c,d,e,f,g,h)	\
-	REVERSE32(*data++, W256[j]); \
-	T1 = (h) + Sigma1_256(e) + Ch((e), (f), (g)) + \
-             K256[j] + W256[j]; \
-	(d) += T1; \
-	(h) = T1 + Sigma0_256(a) + Maj((a), (b), (c)); \
-	j++
-
-
-#else /* BYTE_ORDER == LITTLE_ENDIAN */
-
-#define ROUND256_0_TO_15(a,b,c,d,e,f,g,h)	\
-	T1 = (h) + Sigma1_256(e) + Ch((e), (f), (g)) + \
-	     K256[j] + (W256[j] = *data++); \
-	(d) += T1; \
-	(h) = T1 + Sigma0_256(a) + Maj((a), (b), (c)); \
-	j++
-
-#endif /* BYTE_ORDER == LITTLE_ENDIAN */
-
-#define ROUND256(a,b,c,d,e,f,g,h)	\
-	s0 = W256[(j+1)&0x0f]; \
-	s0 = sigma0_256(s0); \
-	s1 = W256[(j+14)&0x0f]; \
-	s1 = sigma1_256(s1); \
-	T1 = (h) + Sigma1_256(e) + Ch((e), (f), (g)) + K256[j] + \
-	     (W256[j&0x0f] += s1 + W256[(j+9)&0x0f] + s0); \
-	(d) += T1; \
-	(h) = T1 + Sigma0_256(a) + Maj((a), (b), (c)); \
-	j++
-
-void SHA256_Transform(SHA256_CTX* context, const uint32_t* data) {
-	uint32_t	a, b, c, d, e, f, g, h, s0, s1;
-	uint32_t	T1, *W256;
-	int		j;
-
-	W256 = (uint32_t*)context->buffer;
-
-	/* Initialize registers with the prev. intermediate value */
-	a = context->state[0];
-	b = context->state[1];
-	c = context->state[2];
-	d = context->state[3];
-	e = context->state[4];
-	f = context->state[5];
-	g = context->state[6];
-	h = context->state[7];
-
-	j = 0;
-	do {
-		/* Rounds 0 to 15 (unrolled): */
-		ROUND256_0_TO_15(a,b,c,d,e,f,g,h);
-		ROUND256_0_TO_15(h,a,b,c,d,e,f,g);
-		ROUND256_0_TO_15(g,h,a,b,c,d,e,f);
-		ROUND256_0_TO_15(f,g,h,a,b,c,d,e);
-		ROUND256_0_TO_15(e,f,g,h,a,b,c,d);
-		ROUND256_0_TO_15(d,e,f,g,h,a,b,c);
-		ROUND256_0_TO_15(c,d,e,f,g,h,a,b);
-		ROUND256_0_TO_15(b,c,d,e,f,g,h,a);
-	} while (j < 16);
-
-	/* Now for the remaining rounds to 64: */
-	do {
-		ROUND256(a,b,c,d,e,f,g,h);
-		ROUND256(h,a,b,c,d,e,f,g);
-		ROUND256(g,h,a,b,c,d,e,f);
-		ROUND256(f,g,h,a,b,c,d,e);
-		ROUND256(e,f,g,h,a,b,c,d);
-		ROUND256(d,e,f,g,h,a,b,c);
-		ROUND256(c,d,e,f,g,h,a,b);
-		ROUND256(b,c,d,e,f,g,h,a);
-	} while (j < 64);
-
-	/* Compute the current intermediate hash value */
-	context->state[0] += a;
-	context->state[1] += b;
-	context->state[2] += c;
-	context->state[3] += d;
-	context->state[4] += e;
-	context->state[5] += f;
-	context->state[6] += g;
-	context->state[7] += h;
-
-	/* Clean up */
-	a = b = c = d = e = f = g = h = T1 = 0;
-}
-
-#else /* SHA2_UNROLL_TRANSFORM */
-
-static void SHA256_Transform(SHA256_CTX* context, const uint32_t* data) {
-	uint32_t	a, b, c, d, e, f, g, h, s0, s1;
-	uint32_t	T1, T2, *W256;
-	int		j;
-
-	W256 = (uint32_t*)context->buffer;
-
-	/* Initialize registers with the prev. intermediate value */
-	a = context->state[0];
-	b = context->state[1];
-	c = context->state[2];
-	d = context->state[3];
-	e = context->state[4];
-	f = context->state[5];
-	g = context->state[6];
-	h = context->state[7];
-
-	j = 0;
-	do {
-#if BYTE_ORDER == LITTLE_ENDIAN
-		/* Copy data while converting to host byte order */
-		REVERSE32(*data++,W256[j]);
-		/* Apply the SHA-256 compression function to update a..h */
-		T1 = h + Sigma1_256(e) + Ch(e, f, g) + K256[j] + W256[j];
-#else /* BYTE_ORDER == LITTLE_ENDIAN */
-		/* Apply the SHA-256 compression function to update a..h with copy */
-		T1 = h + Sigma1_256(e) + Ch(e, f, g) + K256[j] + (W256[j] = *data++);
-#endif /* BYTE_ORDER == LITTLE_ENDIAN */
-		T2 = Sigma0_256(a) + Maj(a, b, c);
-		h = g;
-		g = f;
-		f = e;
-		e = d + T1;
-		d = c;
-		c = b;
-		b = a;
-		a = T1 + T2;
-
-		j++;
-	} while (j < 16);
-
-	do {
-		/* Part of the message block expansion: */
-		s0 = W256[(j+1)&0x0f];
-		s0 = sigma0_256(s0);
-		s1 = W256[(j+14)&0x0f];
-		s1 = sigma1_256(s1);
-
-		/* Apply the SHA-256 compression function to update a..h */
-		T1 = h + Sigma1_256(e) + Ch(e, f, g) + K256[j] +
-		     (W256[j&0x0f] += s1 + W256[(j+9)&0x0f] + s0);
-		T2 = Sigma0_256(a) + Maj(a, b, c);
-		h = g;
-		g = f;
-		f = e;
-		e = d + T1;
-		d = c;
-		c = b;
-		b = a;
-		a = T1 + T2;
-
-		j++;
-	} while (j < 64);
-
-	/* Compute the current intermediate hash value */
-	context->state[0] += a;
-	context->state[1] += b;
-	context->state[2] += c;
-	context->state[3] += d;
-	context->state[4] += e;
-	context->state[5] += f;
-	context->state[6] += g;
-	context->state[7] += h;
-
-	/* Clean up */
-	a = b = c = d = e = f = g = h = T1 = T2 = 0;
-}
-
-#endif /* SHA2_UNROLL_TRANSFORM */
-
-static void SHA256_Update(SHA256_CTX* context, const uint8_t *data, size_t len) {
-	unsigned int	freespace, usedspace;
-
-	if (len == 0) {
-		/* Calling with no data is valid - we do nothing */
-		return;
-	}
-
-	/* Sanity check: */
-	assert(context != (SHA256_CTX*)0 && data != (uint8_t*)0);
-
-	usedspace = (context->bitcount >> 3) % SHA256_BLOCK_LENGTH;
-	if (usedspace > 0) {
-		/* Calculate how much free space is available in the buffer */
-		freespace = SHA256_BLOCK_LENGTH - usedspace;
-
-		if (len >= freespace) {
-			/* Fill the buffer completely and process it */
-			MEMCPY_BCOPY(&context->buffer[usedspace], data, freespace);
-			context->bitcount += freespace << 3;
-			len -= freespace;
-			data += freespace;
-			SHA256_Transform(context, (uint32_t*)context->buffer);
-		} else {
-			/* The buffer is not yet full */
-			MEMCPY_BCOPY(&context->buffer[usedspace], data, len);
-			context->bitcount += len << 3;
-			/* Clean up: */
-			usedspace = freespace = 0;
-			return;
-		}
-	}
-	while (len >= SHA256_BLOCK_LENGTH) {
-		/* Process as many complete blocks as we can */
-		SHA256_Transform(context, (const uint32_t*)data);
-		context->bitcount += SHA256_BLOCK_LENGTH << 3;
-		len -= SHA256_BLOCK_LENGTH;
-		data += SHA256_BLOCK_LENGTH;
-	}
-	if (len > 0) {
-		/* There's left-overs, so save 'em */
-		MEMCPY_BCOPY(context->buffer, data, len);
-		context->bitcount += len << 3;
-	}
-	/* Clean up: */
-	usedspace = freespace = 0;
-}
-
-static void SHA256_Final(uint8_t digest[], SHA256_CTX* context) {
-	uint32_t	*d = (uint32_t*)digest;
-	unsigned int	usedspace;
-
-	/* Sanity check: */
-	assert(context != (SHA256_CTX*)0);
-
-	/* If no digest buffer is passed, we don't bother doing this: */
-	if (digest != (uint8_t*)0) {
-		usedspace = (context->bitcount >> 3) % SHA256_BLOCK_LENGTH;
-#if BYTE_ORDER == LITTLE_ENDIAN
-		/* Convert FROM host byte order */
-		REVERSE64(context->bitcount,context->bitcount);
-#endif
-		if (usedspace > 0) {
-			/* Begin padding with a 1 bit: */
-			context->buffer[usedspace++] = 0x80;
-
-			if (usedspace <= SHA256_SHORT_BLOCK_LENGTH) {
-				/* Set-up for the last transform: */
-				MEMSET_BZERO(&context->buffer[usedspace], SHA256_SHORT_BLOCK_LENGTH - usedspace);
-			} else {
-				if (usedspace < SHA256_BLOCK_LENGTH) {
-					MEMSET_BZERO(&context->buffer[usedspace], SHA256_BLOCK_LENGTH - usedspace);
-				}
-				/* Do second-to-last transform: */
-				SHA256_Transform(context, (uint32_t*)context->buffer);
-
-				/* And set-up for the last transform: */
-				MEMSET_BZERO(context->buffer, SHA256_SHORT_BLOCK_LENGTH);
-			}
-		} else {
-			/* Set-up for the last transform: */
-			MEMSET_BZERO(context->buffer, SHA256_SHORT_BLOCK_LENGTH);
-
-			/* Begin padding with a 1 bit: */
-			*context->buffer = 0x80;
-		}
-		/* Set the bit count: */
-		//*(uint64_t*)&context->buffer[SHA256_SHORT_BLOCK_LENGTH] = context->bitcount; // aliasing violation warning
-    context->buffer64[SHA256_SHORT_BLOCK_LENGTH / sizeof(uint64_t)] = context->bitcount;
-
-		/* Final transform: */
-		SHA256_Transform(context, (uint32_t*)context->buffer);
-
-#if BYTE_ORDER == LITTLE_ENDIAN
-		{
-			/* Convert TO host byte order */
-			int	j;
-			for (j = 0; j < 8; j++) {
-				REVERSE32(context->state[j],context->state[j]);
-				*d++ = context->state[j];
-			}
-		}
-#else
-		MEMCPY_BCOPY(d, context->state, SHA256_DIGEST_LENGTH);
-#endif
-	}
-
-	/* Clean up state data: */
-	MEMSET_BZERO(context, sizeof(*context));
-	usedspace = 0;
-}
-
-/*
-static char *SHA256_End(SHA256_CTX* context, char buffer[]) {
-	uint8_t	digest[SHA256_DIGEST_LENGTH], *d = digest;
-	int		i;
-
-	/ * Sanity check: * /
-	assert(context != (SHA256_CTX*)0);
-
-	if (buffer != (char*)0) {
-		SHA256_Final(digest, context);
-
-		for (i = 0; i < SHA256_DIGEST_LENGTH; i++) {
-			*buffer++ = sha2_hex_digits[(*d & 0xf0) >> 4];
-			*buffer++ = sha2_hex_digits[*d & 0x0f];
-			d++;
-		}
-		*buffer = (char)0;
-	} else {
-		MEMSET_BZERO(context, sizeof(context));
-	}
-	MEMSET_BZERO(digest, SHA256_DIGEST_LENGTH);
-	return buffer;
-}
-
-static char* SHA256_Data(const uint8_t* data, size_t len, char digest[SHA256_DIGEST_STRING_LENGTH]) {
-	SHA256_CTX	context;
-
-	SHA256_Init(&context);
-	SHA256_Update(&context, data, len);
-	return SHA256_End(&context, digest);
-}
-*/
-
-
-/*** SHA-512: *********************************************************/
-static void SHA512_Init(SHA512_CTX* context) {
-	if (context == (SHA512_CTX*)0) {
-		return;
-	}
-	MEMCPY_BCOPY(context->state, sha512_initial_hash_value, SHA512_DIGEST_LENGTH);
-	MEMSET_BZERO(context->buffer, SHA512_BLOCK_LENGTH);
-	context->bitcount[0] = context->bitcount[1] =  0;
-}
-
-#ifdef SHA2_UNROLL_TRANSFORM
-
-/* Unrolled SHA-512 round macros: */
-#if BYTE_ORDER == LITTLE_ENDIAN
-
-#define ROUND512_0_TO_15(a,b,c,d,e,f,g,h)	\
-	REVERSE64(*data++, W512[j]); \
-	T1 = (h) + Sigma1_512(e) + Ch((e), (f), (g)) + \
-             K512[j] + W512[j]; \
-	(d) += T1, \
-	(h) = T1 + Sigma0_512(a) + Maj((a), (b), (c)), \
-	j++
-
-
-#else /* BYTE_ORDER == LITTLE_ENDIAN */
-
-#define ROUND512_0_TO_15(a,b,c,d,e,f,g,h)	\
-	T1 = (h) + Sigma1_512(e) + Ch((e), (f), (g)) + \
-             K512[j] + (W512[j] = *data++); \
-	(d) += T1; \
-	(h) = T1 + Sigma0_512(a) + Maj((a), (b), (c)); \
-	j++
-
-#endif /* BYTE_ORDER == LITTLE_ENDIAN */
-
-#define ROUND512(a,b,c,d,e,f,g,h)	\
-	s0 = W512[(j+1)&0x0f]; \
-	s0 = sigma0_512(s0); \
-	s1 = W512[(j+14)&0x0f]; \
-	s1 = sigma1_512(s1); \
-	T1 = (h) + Sigma1_512(e) + Ch((e), (f), (g)) + K512[j] + \
-             (W512[j&0x0f] += s1 + W512[(j+9)&0x0f] + s0); \
-	(d) += T1; \
-	(h) = T1 + Sigma0_512(a) + Maj((a), (b), (c)); \
-	j++
-
-static void SHA512_Transform(SHA512_CTX* context, const uint64_t* data) {
-	uint64_t	a, b, c, d, e, f, g, h, s0, s1;
-	uint64_t	T1, *W512 = (uint64_t*)context->buffer;
-	int		j;
-
-	/* Initialize registers with the prev. intermediate value */
-	a = context->state[0];
-	b = context->state[1];
-	c = context->state[2];
-	d = context->state[3];
-	e = context->state[4];
-	f = context->state[5];
-	g = context->state[6];
-	h = context->state[7];
-
-	j = 0;
-	do {
-		ROUND512_0_TO_15(a,b,c,d,e,f,g,h);
-		ROUND512_0_TO_15(h,a,b,c,d,e,f,g);
-		ROUND512_0_TO_15(g,h,a,b,c,d,e,f);
-		ROUND512_0_TO_15(f,g,h,a,b,c,d,e);
-		ROUND512_0_TO_15(e,f,g,h,a,b,c,d);
-		ROUND512_0_TO_15(d,e,f,g,h,a,b,c);
-		ROUND512_0_TO_15(c,d,e,f,g,h,a,b);
-		ROUND512_0_TO_15(b,c,d,e,f,g,h,a);
-	} while (j < 16);
-
-	/* Now for the remaining rounds up to 79: */
-	do {
-		ROUND512(a,b,c,d,e,f,g,h);
-		ROUND512(h,a,b,c,d,e,f,g);
-		ROUND512(g,h,a,b,c,d,e,f);
-		ROUND512(f,g,h,a,b,c,d,e);
-		ROUND512(e,f,g,h,a,b,c,d);
-		ROUND512(d,e,f,g,h,a,b,c);
-		ROUND512(c,d,e,f,g,h,a,b);
-		ROUND512(b,c,d,e,f,g,h,a);
-	} while (j < 80);
-
-	/* Compute the current intermediate hash value */
-	context->state[0] += a;
-	context->state[1] += b;
-	context->state[2] += c;
-	context->state[3] += d;
-	context->state[4] += e;
-	context->state[5] += f;
-	context->state[6] += g;
-	context->state[7] += h;
-
-	/* Clean up */
-	a = b = c = d = e = f = g = h = T1 = 0;
-}
-
-#else /* SHA2_UNROLL_TRANSFORM */
-
-static void SHA512_Transform(SHA512_CTX* context, const uint64_t* data) {
-	uint64_t	a, b, c, d, e, f, g, h, s0, s1;
-	uint64_t	T1, T2, *W512 = (uint64_t*)context->buffer;
-	int		j;
-
-	/* Initialize registers with the prev. intermediate value */
-	a = context->state[0];
-	b = context->state[1];
-	c = context->state[2];
-	d = context->state[3];
-	e = context->state[4];
-	f = context->state[5];
-	g = context->state[6];
-	h = context->state[7];
-
-	j = 0;
-	do {
-#if BYTE_ORDER == LITTLE_ENDIAN
-		/* Convert TO host byte order */
-		REVERSE64(*data++, W512[j]);
-		/* Apply the SHA-512 compression function to update a..h */
-		T1 = h + Sigma1_512(e) + Ch(e, f, g) + K512[j] + W512[j];
-#else /* BYTE_ORDER == LITTLE_ENDIAN */
-		/* Apply the SHA-512 compression function to update a..h with copy */
-		T1 = h + Sigma1_512(e) + Ch(e, f, g) + K512[j] + (W512[j] = *data++);
-#endif /* BYTE_ORDER == LITTLE_ENDIAN */
-		T2 = Sigma0_512(a) + Maj(a, b, c);
-		h = g;
-		g = f;
-		f = e;
-		e = d + T1;
-		d = c;
-		c = b;
-		b = a;
-		a = T1 + T2;
-
-		j++;
-	} while (j < 16);
-
-	do {
-		/* Part of the message block expansion: */
-		s0 = W512[(j+1)&0x0f];
-		s0 = sigma0_512(s0);
-		s1 = W512[(j+14)&0x0f];
-		s1 =  sigma1_512(s1);
-
-		/* Apply the SHA-512 compression function to update a..h */
-		T1 = h + Sigma1_512(e) + Ch(e, f, g) + K512[j] +
-		     (W512[j&0x0f] += s1 + W512[(j+9)&0x0f] + s0);
-		T2 = Sigma0_512(a) + Maj(a, b, c);
-		h = g;
-		g = f;
-		f = e;
-		e = d + T1;
-		d = c;
-		c = b;
-		b = a;
-		a = T1 + T2;
-
-		j++;
-	} while (j < 80);
-
-	/* Compute the current intermediate hash value */
-	context->state[0] += a;
-	context->state[1] += b;
-	context->state[2] += c;
-	context->state[3] += d;
-	context->state[4] += e;
-	context->state[5] += f;
-	context->state[6] += g;
-	context->state[7] += h;
-
-	/* Clean up */
-	a = b = c = d = e = f = g = h = T1 = T2 = 0;
-}
-
-#endif /* SHA2_UNROLL_TRANSFORM */
-
-static void SHA512_Update(SHA512_CTX* context, const uint8_t *data, size_t len) {
-	unsigned int	freespace, usedspace;
-
-	if (len == 0) {
-		/* Calling with no data is valid - we do nothing */
-		return;
-	}
-
-	/* Sanity check: */
-	assert(context != (SHA512_CTX*)0 && data != (uint8_t*)0);
-
-	usedspace = (context->bitcount[0] >> 3) % SHA512_BLOCK_LENGTH;
-	if (usedspace > 0) {
-		/* Calculate how much free space is available in the buffer */
-		freespace = SHA512_BLOCK_LENGTH - usedspace;
-
-		if (len >= freespace) {
-			/* Fill the buffer completely and process it */
-			MEMCPY_BCOPY(&context->buffer[usedspace], data, freespace);
-			ADDINC128(context->bitcount, freespace << 3);
-			len -= freespace;
-			data += freespace;
-			SHA512_Transform(context, (uint64_t*)context->buffer);
-		} else {
-			/* The buffer is not yet full */
-			MEMCPY_BCOPY(&context->buffer[usedspace], data, len);
-			ADDINC128(context->bitcount, len << 3);
-			/* Clean up: */
-			usedspace = freespace = 0;
-			return;
-		}
-	}
-	while (len >= SHA512_BLOCK_LENGTH) {
-		/* Process as many complete blocks as we can */
-		SHA512_Transform(context, (const uint64_t*)data);
-		ADDINC128(context->bitcount, SHA512_BLOCK_LENGTH << 3);
-		len -= SHA512_BLOCK_LENGTH;
-		data += SHA512_BLOCK_LENGTH;
-	}
-	if (len > 0) {
-		/* There's left-overs, so save 'em */
-		MEMCPY_BCOPY(context->buffer, data, len);
-		ADDINC128(context->bitcount, len << 3);
-	}
-	/* Clean up: */
-	usedspace = freespace = 0;
-}
-
-static void SHA512_Last(SHA512_CTX* context) {
-	unsigned int	usedspace;
-
-	usedspace = (context->bitcount[0] >> 3) % SHA512_BLOCK_LENGTH;
-#if BYTE_ORDER == LITTLE_ENDIAN
-	/* Convert FROM host byte order */
-	REVERSE64(context->bitcount[0],context->bitcount[0]);
-	REVERSE64(context->bitcount[1],context->bitcount[1]);
-#endif
-	if (usedspace > 0) {
-		/* Begin padding with a 1 bit: */
-		context->buffer[usedspace++] = 0x80;
-
-		if (usedspace <= SHA512_SHORT_BLOCK_LENGTH) {
-			/* Set-up for the last transform: */
-			MEMSET_BZERO(&context->buffer[usedspace], SHA512_SHORT_BLOCK_LENGTH - usedspace);
-		} else {
-			if (usedspace < SHA512_BLOCK_LENGTH) {
-				MEMSET_BZERO(&context->buffer[usedspace], SHA512_BLOCK_LENGTH - usedspace);
-			}
-			/* Do second-to-last transform: */
-			SHA512_Transform(context, (uint64_t*)context->buffer);
-
-			/* And set-up for the last transform: */
-			MEMSET_BZERO(context->buffer, SHA512_BLOCK_LENGTH - 2);
-		}
-	} else {
-		/* Prepare for final transform: */
-		MEMSET_BZERO(context->buffer, SHA512_SHORT_BLOCK_LENGTH);
-
-		/* Begin padding with a 1 bit: */
-		*context->buffer = 0x80;
-	}
-	/* Store the length of input data (in bits): */
-	//*(uint64_t*)&context->buffer[SHA512_SHORT_BLOCK_LENGTH] = context->bitcount[1]; // aliasing violation warning
-	//*(uint64_t*)&context->buffer[SHA512_SHORT_BLOCK_LENGTH+8] = context->bitcount[0];
-  context->buffer64[SHA512_SHORT_BLOCK_LENGTH / sizeof(uint64_t)] = context->bitcount[1];
-  context->buffer64[SHA512_SHORT_BLOCK_LENGTH / sizeof(uint64_t) + 1] = context->bitcount[0];
-
-	/* Final transform: */
-	SHA512_Transform(context, (uint64_t*)context->buffer);
-}
-
-static void SHA512_Final(uint8_t digest[], SHA512_CTX* context) {
-	uint64_t	*d = (uint64_t*)digest;
-
-	/* Sanity check: */
-	assert(context != (SHA512_CTX*)0);
-
-	/* If no digest buffer is passed, we don't bother doing this: */
-	if (digest != (uint8_t*)0) {
-		SHA512_Last(context);
-
-		/* Save the hash data for output: */
-#if BYTE_ORDER == LITTLE_ENDIAN
-		{
-			/* Convert TO host byte order */
-			int	j;
-			for (j = 0; j < 8; j++) {
-				REVERSE64(context->state[j],context->state[j]);
-				*d++ = context->state[j];
-			}
-		}
-#else
-		MEMCPY_BCOPY(d, context->state, SHA512_DIGEST_LENGTH);
-#endif
-	}
-
-	/* Zero out state data */
-	MEMSET_BZERO(context, sizeof(*context));
-}
-
-/*
-static char *SHA512_End(SHA512_CTX* context, char buffer[]) {
-	uint8_t	digest[SHA512_DIGEST_LENGTH], *d = digest;
-	int		i;
-
-	/ * Sanity check: * /
-	assert(context != (SHA512_CTX*)0);
-
-	if (buffer != (char*)0) {
-		SHA512_Final(digest, context);
-
-		for (i = 0; i < SHA512_DIGEST_LENGTH; i++) {
-			*buffer++ = sha2_hex_digits[(*d & 0xf0) >> 4];
-			*buffer++ = sha2_hex_digits[*d & 0x0f];
-			d++;
-		}
-		*buffer = (char)0;
-	} else {
-		MEMSET_BZERO(context, sizeof(context));
-	}
-	MEMSET_BZERO(digest, SHA512_DIGEST_LENGTH);
-	return buffer;
-}
-
-static char* SHA512_Data(const uint8_t* data, size_t len, char digest[SHA512_DIGEST_STRING_LENGTH]) {
-	SHA512_CTX	context;
-
-	SHA512_Init(&context);
-	SHA512_Update(&context, data, len);
-	return SHA512_End(&context, digest);
-}
-*/
-
-/*** SHA-384: *********************************************************/
-static void SHA384_Init(SHA384_CTX* context) {
-	if (context == (SHA384_CTX*)0) {
-		return;
-	}
-	MEMCPY_BCOPY(context->state, sha384_initial_hash_value, SHA512_DIGEST_LENGTH);
-	MEMSET_BZERO(context->buffer, SHA384_BLOCK_LENGTH);
-	context->bitcount[0] = context->bitcount[1] = 0;
-}
-
-static void SHA384_Update(SHA384_CTX* context, const uint8_t* data, size_t len) {
-	SHA512_Update((SHA512_CTX*)context, data, len);
-}
-
-static void SHA384_Final(uint8_t digest[], SHA384_CTX* context) {
-	uint64_t	*d = (uint64_t*)digest;
-
-	/* Sanity check: */
-	assert(context != (SHA384_CTX*)0);
-
-	/* If no digest buffer is passed, we don't bother doing this: */
-	if (digest != (uint8_t*)0) {
-		SHA512_Last((SHA512_CTX*)context);
-
-		/* Save the hash data for output: */
-#if BYTE_ORDER == LITTLE_ENDIAN
-		{
-			/* Convert TO host byte order */
-			int	j;
-			for (j = 0; j < 6; j++) {
-				REVERSE64(context->state[j],context->state[j]);
-				*d++ = context->state[j];
-			}
-		}
-#else
-		MEMCPY_BCOPY(d, context->state, SHA384_DIGEST_LENGTH);
-#endif
-	}
-
-	/* Zero out state data */
-	MEMSET_BZERO(context, sizeof(*context));
-}
-
-/*
-static char *SHA384_End(SHA384_CTX* context, char buffer[]) {
-	uint8_t	digest[SHA384_DIGEST_LENGTH], *d = digest;
-	int		i;
-
-	/ * Sanity check: * /
-	assert(context != (SHA384_CTX*)0);
-
-	if (buffer != (char*)0) {
-		SHA384_Final(digest, context);
-
-		for (i = 0; i < SHA384_DIGEST_LENGTH; i++) {
-			*buffer++ = sha2_hex_digits[(*d & 0xf0) >> 4];
-			*buffer++ = sha2_hex_digits[*d & 0x0f];
-			d++;
-		}
-		*buffer = (char)0;
-	} else {
-		MEMSET_BZERO(context, sizeof(context));
-	}
-	MEMSET_BZERO(digest, SHA384_DIGEST_LENGTH);
-	return buffer;
-}
-
-static char* SHA384_Data(const uint8_t* data, size_t len, char digest[SHA384_DIGEST_STRING_LENGTH]) {
-	SHA384_CTX	context;
-
-	SHA384_Init(&context);
-	SHA384_Update(&context, data, len);
-	return SHA384_End(&context, digest);
-}
-*/
-
-/* end of sha2.c */
-
-void sha256_init (sha256_state *state)
-{
-  SHA256_Init(state);
-}
-
-void sha384_init (sha384_state *state)
-{
-  SHA384_Init(state);
-}
-
-void sha512_init (sha512_state *state)
-{
-  SHA512_Init(state);
-}
-
-
-void sha256_add (sha256_state *state, const void *data, size_t size)
-{
-  SHA256_Update(state, (const uint8_t *)data, size);
-}
-
-void sha384_add (sha384_state *state, const void *data, size_t size)
-{
-  SHA384_Update(state, (const uint8_t *)data, size);
-}
-
-void sha512_add (sha512_state *state, const void *data, size_t size)
-{
-  SHA512_Update(state, (const uint8_t *)data, size);
-}
-
-
-void sha256_put (sha256_state *state, uint8_t digest[SHA256_DIGEST_LENGTH])
-{
-  SHA256_Final(digest, state);
-}
-
-void sha384_put (sha384_state *state, uint8_t digest[SHA384_DIGEST_LENGTH])
-{
-  SHA384_Final(digest, state);
-}
-
-void sha512_put (sha384_state *state, uint8_t digest[SHA512_DIGEST_LENGTH])
-{
-  SHA512_Final(digest, state);
-}
-
-
-void sha256 (const void *data, size_t size, uint8_t digest[SHA256_DIGEST_LENGTH])
-{
-  sha256_state state;
-  SHA256_Init(&state);
-  SHA256_Update(&state, (const uint8_t *)data, size);
-  SHA256_Final(digest, &state);
-}
-
-void sha384 (const void *data, size_t size, uint8_t digest[SHA384_DIGEST_LENGTH])
-{
-  sha384_state state;
-  SHA384_Init(&state);
-  SHA384_Update(&state, (const uint8_t *)data, size);
-  SHA384_Final(digest, &state);
-}
-
-void sha512 (const void *data, size_t size, uint8_t digest[SHA512_DIGEST_LENGTH])
-{
-  sha512_state state;
-  SHA512_Init(&state);
-  SHA512_Update(&state, (const uint8_t *)data, size);
-  SHA512_Final(digest, &state);
-}
-
-static sha256_state sha256state;
-static sha384_state sha384state;
-static sha512_state sha512state;
-
-
-void sha256init (void)
-{
-  SHA256_Init(&sha256state);
-}
-
-void sha384init (void)
-{
-  SHA384_Init(&sha384state);
-}
-
-void sha512init (void)
-{
-  SHA512_Init(&sha512state);
-}
-
-
-void sha256add (const void *data, size_t size)
-{
-  SHA256_Update(&sha256state, (const uint8_t *)data, size);
-}
-
-void sha384add (const void *data, size_t size)
-{
-  SHA384_Update(&sha384state, (const uint8_t *)data, size);
-}
-
-void sha512add (const void *data, size_t size)
-{
-  SHA512_Update(&sha512state, (const uint8_t *)data, size);
-}
-
-
-void sha256put (uint8_t digest[SHA256_DIGEST_LENGTH])
-{
-  SHA256_Final(digest, &sha256state);
-}
-
-void sha384put (uint8_t digest[SHA384_DIGEST_LENGTH])
-{
-  SHA384_Final(digest, &sha384state);
-}
-
-void sha512put (uint8_t digest[SHA512_DIGEST_LENGTH])
-{
-  SHA512_Final(digest, &sha512state);
-}
--- texlive-bin.orig/texk/web2c/luatexdir/luapplib/util/utilsha.h
+++ /dev/null
@@ -1,134 +0,0 @@
-/* sha2 implementation by Aaron D. Gifford (http://www.aarongifford.com) */
-
-#ifndef UTIL_SHA_H
-#define UTIL_SHA_H
-
-#include <stddef.h>
-#include <stdint.h>
-#include "utildecl.h"
-
-/* begin of sha2.h */
-
-/*
- * FILE:  sha2.h
- * AUTHOR:  Aaron D. Gifford - http://www.aarongifford.com/
- *
- * Copyright (c) 2000-2001, Aaron D. Gifford
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the copyright holder nor the names of contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTOR(S) ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTOR(S) BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- *
- * $Id: sha2.h,v 1.1 2001/11/08 00:02:01 adg Exp adg $
- */
-
-/*** SHA-256/384/512 Various Length Definitions ***********************/
-
-#define SHA256_BLOCK_LENGTH   64
-#define SHA256_DIGEST_LENGTH    32
-#define SHA256_DIGEST_STRING_LENGTH (SHA256_DIGEST_LENGTH * 2 + 1)
-#define SHA384_BLOCK_LENGTH   128
-#define SHA384_DIGEST_LENGTH    48
-#define SHA384_DIGEST_STRING_LENGTH (SHA384_DIGEST_LENGTH * 2 + 1)
-#define SHA512_BLOCK_LENGTH   128
-#define SHA512_DIGEST_LENGTH    64
-#define SHA512_DIGEST_STRING_LENGTH (SHA512_DIGEST_LENGTH * 2 + 1)
-
-typedef struct _SHA256_CTX {
-  uint32_t  state[8];
-  uint64_t  bitcount;
-  union {
-    uint8_t buffer[SHA256_BLOCK_LENGTH];
-    uint64_t buffer64[SHA256_BLOCK_LENGTH / sizeof(uint64_t)]; // to avoid warnings about violating aliasing rules
-  };
-} SHA256_CTX;
-
-typedef struct _SHA512_CTX {
-  uint64_t  state[8];
-  uint64_t  bitcount[2];
-  union {
-    uint8_t buffer[SHA512_BLOCK_LENGTH];
-    uint64_t buffer64[SHA512_BLOCK_LENGTH / sizeof(uint64_t)];
-  };
-} SHA512_CTX;
-
-typedef SHA512_CTX SHA384_CTX;
-
-/*** SHA-256/384/512 Function Prototypes ******************************/
-
-/*
-void SHA256_Init(SHA256_CTX *);
-void SHA256_Update(SHA256_CTX*, const u_int8_t*, size_t);
-void SHA256_Final(u_int8_t[SHA256_DIGEST_LENGTH], SHA256_CTX*);
-char* SHA256_End(SHA256_CTX*, char[SHA256_DIGEST_STRING_LENGTH]);
-char* SHA256_Data(const u_int8_t*, size_t, char[SHA256_DIGEST_STRING_LENGTH]);
-
-void SHA384_Init(SHA384_CTX*);
-void SHA384_Update(SHA384_CTX*, const u_int8_t*, size_t);
-void SHA384_Final(u_int8_t[SHA384_DIGEST_LENGTH], SHA384_CTX*);
-char* SHA384_End(SHA384_CTX*, char[SHA384_DIGEST_STRING_LENGTH]);
-char* SHA384_Data(const u_int8_t*, size_t, char[SHA384_DIGEST_STRING_LENGTH]);
-
-void SHA512_Init(SHA512_CTX*);
-void SHA512_Update(SHA512_CTX*, const u_int8_t*, size_t);
-void SHA512_Final(u_int8_t[SHA512_DIGEST_LENGTH], SHA512_CTX*);
-char* SHA512_End(SHA512_CTX*, char[SHA512_DIGEST_STRING_LENGTH]);
-char* SHA512_Data(const u_int8_t*, size_t, char[SHA512_DIGEST_STRING_LENGTH]);
-*/
-
-/* end of sha2.h */
-
-#define sha256_state SHA256_CTX
-#define sha384_state SHA384_CTX
-#define sha512_state SHA512_CTX
-
-UTILAPI void sha256_init (sha256_state *state);
-UTILAPI void sha384_init (sha384_state *state);
-UTILAPI void sha512_init (sha512_state *state);
-
-UTILAPI void sha256_add (sha256_state *state, const void *data, size_t size);
-UTILAPI void sha384_add (sha384_state *state, const void *data, size_t size);
-UTILAPI void sha512_add (sha512_state *state, const void *data, size_t size);
-
-UTILAPI void sha256_put (sha256_state *state, uint8_t digest[SHA256_DIGEST_LENGTH]);
-UTILAPI void sha384_put (sha384_state *state, uint8_t digest[SHA384_DIGEST_LENGTH]);
-UTILAPI void sha512_put (sha512_state *state, uint8_t digest[SHA512_DIGEST_LENGTH]);
-
-UTILAPI void sha256 (const void *data, size_t size, uint8_t digest[SHA256_DIGEST_LENGTH]);
-UTILAPI void sha384 (const void *data, size_t size, uint8_t digest[SHA384_DIGEST_LENGTH]);
-UTILAPI void sha512 (const void *data, size_t size, uint8_t digest[SHA512_DIGEST_LENGTH]);
-
-UTILAPI void sha256init (void);
-UTILAPI void sha384init (void);
-UTILAPI void sha512init (void);
-
-UTILAPI void sha256add (const void *data, size_t size);
-UTILAPI void sha384add (const void *data, size_t size);
-UTILAPI void sha512add (const void *data, size_t size);
-
-UTILAPI void sha256put (uint8_t digest[SHA256_DIGEST_LENGTH]);
-UTILAPI void sha384put (uint8_t digest[SHA384_DIGEST_LENGTH]);
-UTILAPI void sha512put (uint8_t digest[SHA512_DIGEST_LENGTH]);
-
-#endif
\ No newline at end of file
--- texlive-bin.orig/texk/web2c/luatexdir/luapplib/zlib/zconf.h
+++ /dev/null
@@ -1,428 +0,0 @@
-/* zconf.h -- configuration of the zlib compression library
- * Copyright (C) 1995-2010 Jean-loup Gailly.
- * For conditions of distribution and use, see copyright notice in zlib.h
- */
-
-/* @(#) $Id$ */
-
-#ifndef ZCONF_H
-#define ZCONF_H
-
-/*
- * If you *really* need a unique prefix for all types and library functions,
- * compile with -DZ_PREFIX. The "standard" zlib should be compiled without it.
- * Even better than compiling with -DZ_PREFIX would be to use configure to set
- * this permanently in zconf.h using "./configure --zprefix".
- */
-#ifdef Z_PREFIX     /* may be set to #if 1 by ./configure */
-
-/* all linked symbols */
-#  define _dist_code            z__dist_code
-#  define _length_code          z__length_code
-#  define _tr_align             z__tr_align
-#  define _tr_flush_block       z__tr_flush_block
-#  define _tr_init              z__tr_init
-#  define _tr_stored_block      z__tr_stored_block
-#  define _tr_tally             z__tr_tally
-#  define adler32               z_adler32
-#  define adler32_combine       z_adler32_combine
-#  define adler32_combine64     z_adler32_combine64
-#  define compress              z_compress
-#  define compress2             z_compress2
-#  define compressBound         z_compressBound
-#  define crc32                 z_crc32
-#  define crc32_combine         z_crc32_combine
-#  define crc32_combine64       z_crc32_combine64
-#  define deflate               z_deflate
-#  define deflateBound          z_deflateBound
-#  define deflateCopy           z_deflateCopy
-#  define deflateEnd            z_deflateEnd
-#  define deflateInit2_         z_deflateInit2_
-#  define deflateInit_          z_deflateInit_
-#  define deflateParams         z_deflateParams
-#  define deflatePrime          z_deflatePrime
-#  define deflateReset          z_deflateReset
-#  define deflateSetDictionary  z_deflateSetDictionary
-#  define deflateSetHeader      z_deflateSetHeader
-#  define deflateTune           z_deflateTune
-#  define deflate_copyright     z_deflate_copyright
-#  define get_crc_table         z_get_crc_table
-#  define gz_error              z_gz_error
-#  define gz_intmax             z_gz_intmax
-#  define gz_strwinerror        z_gz_strwinerror
-#  define gzbuffer              z_gzbuffer
-#  define gzclearerr            z_gzclearerr
-#  define gzclose               z_gzclose
-#  define gzclose_r             z_gzclose_r
-#  define gzclose_w             z_gzclose_w
-#  define gzdirect              z_gzdirect
-#  define gzdopen               z_gzdopen
-#  define gzeof                 z_gzeof
-#  define gzerror               z_gzerror
-#  define gzflush               z_gzflush
-#  define gzgetc                z_gzgetc
-#  define gzgets                z_gzgets
-#  define gzoffset              z_gzoffset
-#  define gzoffset64            z_gzoffset64
-#  define gzopen                z_gzopen
-#  define gzopen64              z_gzopen64
-#  define gzprintf              z_gzprintf
-#  define gzputc                z_gzputc
-#  define gzputs                z_gzputs
-#  define gzread                z_gzread
-#  define gzrewind              z_gzrewind
-#  define gzseek                z_gzseek
-#  define gzseek64              z_gzseek64
-#  define gzsetparams           z_gzsetparams
-#  define gztell                z_gztell
-#  define gztell64              z_gztell64
-#  define gzungetc              z_gzungetc
-#  define gzwrite               z_gzwrite
-#  define inflate               z_inflate
-#  define inflateBack           z_inflateBack
-#  define inflateBackEnd        z_inflateBackEnd
-#  define inflateBackInit_      z_inflateBackInit_
-#  define inflateCopy           z_inflateCopy
-#  define inflateEnd            z_inflateEnd
-#  define inflateGetHeader      z_inflateGetHeader
-#  define inflateInit2_         z_inflateInit2_
-#  define inflateInit_          z_inflateInit_
-#  define inflateMark           z_inflateMark
-#  define inflatePrime          z_inflatePrime
-#  define inflateReset          z_inflateReset
-#  define inflateReset2         z_inflateReset2
-#  define inflateSetDictionary  z_inflateSetDictionary
-#  define inflateSync           z_inflateSync
-#  define inflateSyncPoint      z_inflateSyncPoint
-#  define inflateUndermine      z_inflateUndermine
-#  define inflate_copyright     z_inflate_copyright
-#  define inflate_fast          z_inflate_fast
-#  define inflate_table         z_inflate_table
-#  define uncompress            z_uncompress
-#  define zError                z_zError
-#  define zcalloc               z_zcalloc
-#  define zcfree                z_zcfree
-#  define zlibCompileFlags      z_zlibCompileFlags
-#  define zlibVersion           z_zlibVersion
-
-/* all zlib typedefs in zlib.h and zconf.h */
-#  define Byte                  z_Byte
-#  define Bytef                 z_Bytef
-#  define alloc_func            z_alloc_func
-#  define charf                 z_charf
-#  define free_func             z_free_func
-#  define gzFile                z_gzFile
-#  define gz_header             z_gz_header
-#  define gz_headerp            z_gz_headerp
-#  define in_func               z_in_func
-#  define intf                  z_intf
-#  define out_func              z_out_func
-#  define uInt                  z_uInt
-#  define uIntf                 z_uIntf
-#  define uLong                 z_uLong
-#  define uLongf                z_uLongf
-#  define voidp                 z_voidp
-#  define voidpc                z_voidpc
-#  define voidpf                z_voidpf
-
-/* all zlib structs in zlib.h and zconf.h */
-#  define gz_header_s           z_gz_header_s
-#  define internal_state        z_internal_state
-
-#endif
-
-#if defined(__MSDOS__) && !defined(MSDOS)
-#  define MSDOS
-#endif
-#if (defined(OS_2) || defined(__OS2__)) && !defined(OS2)
-#  define OS2
-#endif
-#if defined(_WINDOWS) && !defined(WINDOWS)
-#  define WINDOWS
-#endif
-#if defined(_WIN32) || defined(_WIN32_WCE) || defined(__WIN32__)
-#  ifndef WIN32
-#    define WIN32
-#  endif
-#endif
-#if (defined(MSDOS) || defined(OS2) || defined(WINDOWS)) && !defined(WIN32)
-#  if !defined(__GNUC__) && !defined(__FLAT__) && !defined(__386__)
-#    ifndef SYS16BIT
-#      define SYS16BIT
-#    endif
-#  endif
-#endif
-
-/*
- * Compile with -DMAXSEG_64K if the alloc function cannot allocate more
- * than 64k bytes at a time (needed on systems with 16-bit int).
- */
-#ifdef SYS16BIT
-#  define MAXSEG_64K
-#endif
-#ifdef MSDOS
-#  define UNALIGNED_OK
-#endif
-
-#ifdef __STDC_VERSION__
-#  ifndef STDC
-#    define STDC
-#  endif
-#  if __STDC_VERSION__ >= 199901L
-#    ifndef STDC99
-#      define STDC99
-#    endif
-#  endif
-#endif
-#if !defined(STDC) && (defined(__STDC__) || defined(__cplusplus))
-#  define STDC
-#endif
-#if !defined(STDC) && (defined(__GNUC__) || defined(__BORLANDC__))
-#  define STDC
-#endif
-#if !defined(STDC) && (defined(MSDOS) || defined(WINDOWS) || defined(WIN32))
-#  define STDC
-#endif
-#if !defined(STDC) && (defined(OS2) || defined(__HOS_AIX__))
-#  define STDC
-#endif
-
-#if defined(__OS400__) && !defined(STDC)    /* iSeries (formerly AS/400). */
-#  define STDC
-#endif
-
-#ifndef STDC
-#  ifndef const /* cannot use !defined(STDC) && !defined(const) on Mac */
-#    define const       /* note: need a more gentle solution here */
-#  endif
-#endif
-
-/* Some Mac compilers merge all .h files incorrectly: */
-#if defined(__MWERKS__)||defined(applec)||defined(THINK_C)||defined(__SC__)
-#  define NO_DUMMY_DECL
-#endif
-
-/* Maximum value for memLevel in deflateInit2 */
-#ifndef MAX_MEM_LEVEL
-#  ifdef MAXSEG_64K
-#    define MAX_MEM_LEVEL 8
-#  else
-#    define MAX_MEM_LEVEL 9
-#  endif
-#endif
-
-/* Maximum value for windowBits in deflateInit2 and inflateInit2.
- * WARNING: reducing MAX_WBITS makes minigzip unable to extract .gz files
- * created by gzip. (Files created by minigzip can still be extracted by
- * gzip.)
- */
-#ifndef MAX_WBITS
-#  define MAX_WBITS   15 /* 32K LZ77 window */
-#endif
-
-/* The memory requirements for deflate are (in bytes):
-            (1 << (windowBits+2)) +  (1 << (memLevel+9))
- that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)
- plus a few kilobytes for small objects. For example, if you want to reduce
- the default memory requirements from 256K to 128K, compile with
-     make CFLAGS="-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7"
- Of course this will generally degrade compression (there's no free lunch).
-
-   The memory requirements for inflate are (in bytes) 1 << windowBits
- that is, 32K for windowBits=15 (default value) plus a few kilobytes
- for small objects.
-*/
-
-                        /* Type declarations */
-
-#ifndef OF /* function prototypes */
-#  ifdef STDC
-#    define OF(args)  args
-#  else
-#    define OF(args)  ()
-#  endif
-#endif
-
-/* The following definitions for FAR are needed only for MSDOS mixed
- * model programming (small or medium model with some far allocations).
- * This was tested only with MSC; for other MSDOS compilers you may have
- * to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,
- * just define FAR to be empty.
- */
-#ifdef SYS16BIT
-#  if defined(M_I86SM) || defined(M_I86MM)
-     /* MSC small or medium model */
-#    define SMALL_MEDIUM
-#    ifdef _MSC_VER
-#      define FAR _far
-#    else
-#      define FAR far
-#    endif
-#  endif
-#  if (defined(__SMALL__) || defined(__MEDIUM__))
-     /* Turbo C small or medium model */
-#    define SMALL_MEDIUM
-#    ifdef __BORLANDC__
-#      define FAR _far
-#    else
-#      define FAR far
-#    endif
-#  endif
-#endif
-
-#if defined(WINDOWS) || defined(WIN32)
-   /* If building or using zlib as a DLL, define ZLIB_DLL.
-    * This is not mandatory, but it offers a little performance increase.
-    */
-#  ifdef ZLIB_DLL
-#    if defined(WIN32) && (!defined(__BORLANDC__) || (__BORLANDC__ >= 0x500))
-#      ifdef ZLIB_INTERNAL
-#        define ZEXTERN extern __declspec(dllexport)
-#      else
-#        define ZEXTERN extern __declspec(dllimport)
-#      endif
-#    endif
-#  endif  /* ZLIB_DLL */
-   /* If building or using zlib with the WINAPI/WINAPIV calling convention,
-    * define ZLIB_WINAPI.
-    * Caution: the standard ZLIB1.DLL is NOT compiled using ZLIB_WINAPI.
-    */
-#  ifdef ZLIB_WINAPI
-#    ifdef FAR
-#      undef FAR
-#    endif
-#    include <windows.h>
-     /* No need for _export, use ZLIB.DEF instead. */
-     /* For complete Windows compatibility, use WINAPI, not __stdcall. */
-#    define ZEXPORT WINAPI
-#    ifdef WIN32
-#      define ZEXPORTVA WINAPIV
-#    else
-#      define ZEXPORTVA FAR CDECL
-#    endif
-#  endif
-#endif
-
-#if defined (__BEOS__)
-#  ifdef ZLIB_DLL
-#    ifdef ZLIB_INTERNAL
-#      define ZEXPORT   __declspec(dllexport)
-#      define ZEXPORTVA __declspec(dllexport)
-#    else
-#      define ZEXPORT   __declspec(dllimport)
-#      define ZEXPORTVA __declspec(dllimport)
-#    endif
-#  endif
-#endif
-
-#ifndef ZEXTERN
-#  define ZEXTERN extern
-#endif
-#ifndef ZEXPORT
-#  define ZEXPORT
-#endif
-#ifndef ZEXPORTVA
-#  define ZEXPORTVA
-#endif
-
-#ifndef FAR
-#  define FAR
-#endif
-
-#if !defined(__MACTYPES__)
-typedef unsigned char  Byte;  /* 8 bits */
-#endif
-typedef unsigned int   uInt;  /* 16 bits or more */
-typedef unsigned long  uLong; /* 32 bits or more */
-
-#ifdef SMALL_MEDIUM
-   /* Borland C/C++ and some old MSC versions ignore FAR inside typedef */
-#  define Bytef Byte FAR
-#else
-   typedef Byte  FAR Bytef;
-#endif
-typedef char  FAR charf;
-typedef int   FAR intf;
-typedef uInt  FAR uIntf;
-typedef uLong FAR uLongf;
-
-#ifdef STDC
-   typedef void const *voidpc;
-   typedef void FAR   *voidpf;
-   typedef void       *voidp;
-#else
-   typedef Byte const *voidpc;
-   typedef Byte FAR   *voidpf;
-   typedef Byte       *voidp;
-#endif
-
-#ifdef HAVE_UNISTD_H    /* may be set to #if 1 by ./configure */
-#  define Z_HAVE_UNISTD_H
-#endif
-
-#ifdef STDC
-#  include <sys/types.h>    /* for off_t */
-#endif
-
-/* a little trick to accommodate both "#define _LARGEFILE64_SOURCE" and
- * "#define _LARGEFILE64_SOURCE 1" as requesting 64-bit operations, (even
- * though the former does not conform to the LFS document), but considering
- * both "#undef _LARGEFILE64_SOURCE" and "#define _LARGEFILE64_SOURCE 0" as
- * equivalently requesting no 64-bit operations
- */
-#if -_LARGEFILE64_SOURCE - -1 == 1
-#  undef _LARGEFILE64_SOURCE
-#endif
-
-#if defined(Z_HAVE_UNISTD_H) || defined(_LARGEFILE64_SOURCE)
-#  include <unistd.h>       /* for SEEK_* and off_t */
-#  ifdef VMS
-#    include <unixio.h>     /* for off_t */
-#  endif
-#  ifndef z_off_t
-#    define z_off_t off_t
-#  endif
-#endif
-
-#ifndef SEEK_SET
-#  define SEEK_SET        0       /* Seek from beginning of file.  */
-#  define SEEK_CUR        1       /* Seek from current position.  */
-#  define SEEK_END        2       /* Set file pointer to EOF plus "offset" */
-#endif
-
-#ifndef z_off_t
-#  define z_off_t long
-#endif
-
-#if defined(_LARGEFILE64_SOURCE) && _LFS64_LARGEFILE-0
-#  define z_off64_t off64_t
-#else
-#  define z_off64_t z_off_t
-#endif
-
-#if defined(__OS400__)
-#  define NO_vsnprintf
-#endif
-
-#if defined(__MVS__)
-#  define NO_vsnprintf
-#endif
-
-/* MVS linker does not support external names larger than 8 bytes */
-#if defined(__MVS__)
-  #pragma map(deflateInit_,"DEIN")
-  #pragma map(deflateInit2_,"DEIN2")
-  #pragma map(deflateEnd,"DEEND")
-  #pragma map(deflateBound,"DEBND")
-  #pragma map(inflateInit_,"ININ")
-  #pragma map(inflateInit2_,"ININ2")
-  #pragma map(inflateEnd,"INEND")
-  #pragma map(inflateSync,"INSY")
-  #pragma map(inflateSetDictionary,"INSEDI")
-  #pragma map(compressBound,"CMBND")
-  #pragma map(inflate_table,"INTABL")
-  #pragma map(inflate_fast,"INFA")
-  #pragma map(inflate_copyright,"INCOPY")
-#endif
-
-#endif /* ZCONF_H */
--- texlive-bin.orig/texk/web2c/luatexdir/luapplib/zlib/zlib.h
+++ /dev/null
@@ -1,1613 +0,0 @@
-/* zlib.h -- interface of the 'zlib' general purpose compression library
-  version 1.2.5, April 19th, 2010
-
-  Copyright (C) 1995-2010 Jean-loup Gailly and Mark Adler
-
-  This software is provided 'as-is', without any express or implied
-  warranty.  In no event will the authors be held liable for any damages
-  arising from the use of this software.
-
-  Permission is granted to anyone to use this software for any purpose,
-  including commercial applications, and to alter it and redistribute it
-  freely, subject to the following restrictions:
-
-  1. The origin of this software must not be misrepresented; you must not
-     claim that you wrote the original software. If you use this software
-     in a product, an acknowledgment in the product documentation would be
-     appreciated but is not required.
-  2. Altered source versions must be plainly marked as such, and must not be
-     misrepresented as being the original software.
-  3. This notice may not be removed or altered from any source distribution.
-
-  Jean-loup Gailly        Mark Adler
-  jloup@gzip.org          madler@alumni.caltech.edu
-
-
-  The data format used by the zlib library is described by RFCs (Request for
-  Comments) 1950 to 1952 in the files http://www.ietf.org/rfc/rfc1950.txt
-  (zlib format), rfc1951.txt (deflate format) and rfc1952.txt (gzip format).
-*/
-
-#ifndef ZLIB_H
-#define ZLIB_H
-
-#include "zconf.h"
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#define ZLIB_VERSION "1.2.5"
-#define ZLIB_VERNUM 0x1250
-#define ZLIB_VER_MAJOR 1
-#define ZLIB_VER_MINOR 2
-#define ZLIB_VER_REVISION 5
-#define ZLIB_VER_SUBREVISION 0
-
-/*
-    The 'zlib' compression library provides in-memory compression and
-  decompression functions, including integrity checks of the uncompressed data.
-  This version of the library supports only one compression method (deflation)
-  but other algorithms will be added later and will have the same stream
-  interface.
-
-    Compression can be done in a single step if the buffers are large enough,
-  or can be done by repeated calls of the compression function.  In the latter
-  case, the application must provide more input and/or consume the output
-  (providing more output space) before each call.
-
-    The compressed data format used by default by the in-memory functions is
-  the zlib format, which is a zlib wrapper documented in RFC 1950, wrapped
-  around a deflate stream, which is itself documented in RFC 1951.
-
-    The library also supports reading and writing files in gzip (.gz) format
-  with an interface similar to that of stdio using the functions that start
-  with "gz".  The gzip format is different from the zlib format.  gzip is a
-  gzip wrapper, documented in RFC 1952, wrapped around a deflate stream.
-
-    This library can optionally read and write gzip streams in memory as well.
-
-    The zlib format was designed to be compact and fast for use in memory
-  and on communications channels.  The gzip format was designed for single-
-  file compression on file systems, has a larger header than zlib to maintain
-  directory information, and uses a different, slower check method than zlib.
-
-    The library does not install any signal handler.  The decoder checks
-  the consistency of the compressed data, so the library should never crash
-  even in case of corrupted input.
-*/
-
-typedef voidpf (*alloc_func) OF((voidpf opaque, uInt items, uInt size));
-typedef void   (*free_func)  OF((voidpf opaque, voidpf address));
-
-struct internal_state;
-
-typedef struct z_stream_s {
-    Bytef    *next_in;  /* next input byte */
-    uInt     avail_in;  /* number of bytes available at next_in */
-    uLong    total_in;  /* total nb of input bytes read so far */
-
-    Bytef    *next_out; /* next output byte should be put there */
-    uInt     avail_out; /* remaining free space at next_out */
-    uLong    total_out; /* total nb of bytes output so far */
-
-    char     *msg;      /* last error message, NULL if no error */
-    struct internal_state FAR *state; /* not visible by applications */
-
-    alloc_func zalloc;  /* used to allocate the internal state */
-    free_func  zfree;   /* used to free the internal state */
-    voidpf     opaque;  /* private data object passed to zalloc and zfree */
-
-    int     data_type;  /* best guess about the data type: binary or text */
-    uLong   adler;      /* adler32 value of the uncompressed data */
-    uLong   reserved;   /* reserved for future use */
-} z_stream;
-
-typedef z_stream FAR *z_streamp;
-
-/*
-     gzip header information passed to and from zlib routines.  See RFC 1952
-  for more details on the meanings of these fields.
-*/
-typedef struct gz_header_s {
-    int     text;       /* true if compressed data believed to be text */
-    uLong   time;       /* modification time */
-    int     xflags;     /* extra flags (not used when writing a gzip file) */
-    int     os;         /* operating system */
-    Bytef   *extra;     /* pointer to extra field or Z_NULL if none */
-    uInt    extra_len;  /* extra field length (valid if extra != Z_NULL) */
-    uInt    extra_max;  /* space at extra (only when reading header) */
-    Bytef   *name;      /* pointer to zero-terminated file name or Z_NULL */
-    uInt    name_max;   /* space at name (only when reading header) */
-    Bytef   *comment;   /* pointer to zero-terminated comment or Z_NULL */
-    uInt    comm_max;   /* space at comment (only when reading header) */
-    int     hcrc;       /* true if there was or will be a header crc */
-    int     done;       /* true when done reading gzip header (not used
-                           when writing a gzip file) */
-} gz_header;
-
-typedef gz_header FAR *gz_headerp;
-
-/*
-     The application must update next_in and avail_in when avail_in has dropped
-   to zero.  It must update next_out and avail_out when avail_out has dropped
-   to zero.  The application must initialize zalloc, zfree and opaque before
-   calling the init function.  All other fields are set by the compression
-   library and must not be updated by the application.
-
-     The opaque value provided by the application will be passed as the first
-   parameter for calls of zalloc and zfree.  This can be useful for custom
-   memory management.  The compression library attaches no meaning to the
-   opaque value.
-
-     zalloc must return Z_NULL if there is not enough memory for the object.
-   If zlib is used in a multi-threaded application, zalloc and zfree must be
-   thread safe.
-
-     On 16-bit systems, the functions zalloc and zfree must be able to allocate
-   exactly 65536 bytes, but will not be required to allocate more than this if
-   the symbol MAXSEG_64K is defined (see zconf.h).  WARNING: On MSDOS, pointers
-   returned by zalloc for objects of exactly 65536 bytes *must* have their
-   offset normalized to zero.  The default allocation function provided by this
-   library ensures this (see zutil.c).  To reduce memory requirements and avoid
-   any allocation of 64K objects, at the expense of compression ratio, compile
-   the library with -DMAX_WBITS=14 (see zconf.h).
-
-     The fields total_in and total_out can be used for statistics or progress
-   reports.  After compression, total_in holds the total size of the
-   uncompressed data and may be saved for use in the decompressor (particularly
-   if the decompressor wants to decompress everything in a single step).
-*/
-
-                        /* constants */
-
-#define Z_NO_FLUSH      0
-#define Z_PARTIAL_FLUSH 1
-#define Z_SYNC_FLUSH    2
-#define Z_FULL_FLUSH    3
-#define Z_FINISH        4
-#define Z_BLOCK         5
-#define Z_TREES         6
-/* Allowed flush values; see deflate() and inflate() below for details */
-
-#define Z_OK            0
-#define Z_STREAM_END    1
-#define Z_NEED_DICT     2
-#define Z_ERRNO        (-1)
-#define Z_STREAM_ERROR (-2)
-#define Z_DATA_ERROR   (-3)
-#define Z_MEM_ERROR    (-4)
-#define Z_BUF_ERROR    (-5)
-#define Z_VERSION_ERROR (-6)
-/* Return codes for the compression/decompression functions. Negative values
- * are errors, positive values are used for special but normal events.
- */
-
-#define Z_NO_COMPRESSION         0
-#define Z_BEST_SPEED             1
-#define Z_BEST_COMPRESSION       9
-#define Z_DEFAULT_COMPRESSION  (-1)
-/* compression levels */
-
-#define Z_FILTERED            1
-#define Z_HUFFMAN_ONLY        2
-#define Z_RLE                 3
-#define Z_FIXED               4
-#define Z_DEFAULT_STRATEGY    0
-/* compression strategy; see deflateInit2() below for details */
-
-#define Z_BINARY   0
-#define Z_TEXT     1
-#define Z_ASCII    Z_TEXT   /* for compatibility with 1.2.2 and earlier */
-#define Z_UNKNOWN  2
-/* Possible values of the data_type field (though see inflate()) */
-
-#define Z_DEFLATED   8
-/* The deflate compression method (the only one supported in this version) */
-
-#define Z_NULL  0  /* for initializing zalloc, zfree, opaque */
-
-#define zlib_version zlibVersion()
-/* for compatibility with versions < 1.0.2 */
-
-
-                        /* basic functions */
-
-ZEXTERN const char * ZEXPORT zlibVersion OF((void));
-/* The application can compare zlibVersion and ZLIB_VERSION for consistency.
-   If the first character differs, the library code actually used is not
-   compatible with the zlib.h header file used by the application.  This check
-   is automatically made by deflateInit and inflateInit.
- */
-
-/*
-ZEXTERN int ZEXPORT deflateInit OF((z_streamp strm, int level));
-
-     Initializes the internal stream state for compression.  The fields
-   zalloc, zfree and opaque must be initialized before by the caller.  If
-   zalloc and zfree are set to Z_NULL, deflateInit updates them to use default
-   allocation functions.
-
-     The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:
-   1 gives best speed, 9 gives best compression, 0 gives no compression at all
-   (the input data is simply copied a block at a time).  Z_DEFAULT_COMPRESSION
-   requests a default compromise between speed and compression (currently
-   equivalent to level 6).
-
-     deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough
-   memory, Z_STREAM_ERROR if level is not a valid compression level, or
-   Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible
-   with the version assumed by the caller (ZLIB_VERSION).  msg is set to null
-   if there is no error message.  deflateInit does not perform any compression:
-   this will be done by deflate().
-*/
-
-
-ZEXTERN int ZEXPORT deflate OF((z_streamp strm, int flush));
-/*
-    deflate compresses as much data as possible, and stops when the input
-  buffer becomes empty or the output buffer becomes full.  It may introduce
-  some output latency (reading input without producing any output) except when
-  forced to flush.
-
-    The detailed semantics are as follows.  deflate performs one or both of the
-  following actions:
-
-  - Compress more input starting at next_in and update next_in and avail_in
-    accordingly.  If not all input can be processed (because there is not
-    enough room in the output buffer), next_in and avail_in are updated and
-    processing will resume at this point for the next call of deflate().
-
-  - Provide more output starting at next_out and update next_out and avail_out
-    accordingly.  This action is forced if the parameter flush is non zero.
-    Forcing flush frequently degrades the compression ratio, so this parameter
-    should be set only when necessary (in interactive applications).  Some
-    output may be provided even if flush is not set.
-
-    Before the call of deflate(), the application should ensure that at least
-  one of the actions is possible, by providing more input and/or consuming more
-  output, and updating avail_in or avail_out accordingly; avail_out should
-  never be zero before the call.  The application can consume the compressed
-  output when it wants, for example when the output buffer is full (avail_out
-  == 0), or after each call of deflate().  If deflate returns Z_OK and with
-  zero avail_out, it must be called again after making room in the output
-  buffer because there might be more output pending.
-
-    Normally the parameter flush is set to Z_NO_FLUSH, which allows deflate to
-  decide how much data to accumulate before producing output, in order to
-  maximize compression.
-
-    If the parameter flush is set to Z_SYNC_FLUSH, all pending output is
-  flushed to the output buffer and the output is aligned on a byte boundary, so
-  that the decompressor can get all input data available so far.  (In
-  particular avail_in is zero after the call if enough output space has been
-  provided before the call.) Flushing may degrade compression for some
-  compression algorithms and so it should be used only when necessary.  This
-  completes the current deflate block and follows it with an empty stored block
-  that is three bits plus filler bits to the next byte, followed by four bytes
-  (00 00 ff ff).
-
-    If flush is set to Z_PARTIAL_FLUSH, all pending output is flushed to the
-  output buffer, but the output is not aligned to a byte boundary.  All of the
-  input data so far will be available to the decompressor, as for Z_SYNC_FLUSH.
-  This completes the current deflate block and follows it with an empty fixed
-  codes block that is 10 bits long.  This assures that enough bytes are output
-  in order for the decompressor to finish the block before the empty fixed code
-  block.
-
-    If flush is set to Z_BLOCK, a deflate block is completed and emitted, as
-  for Z_SYNC_FLUSH, but the output is not aligned on a byte boundary, and up to
-  seven bits of the current block are held to be written as the next byte after
-  the next deflate block is completed.  In this case, the decompressor may not
-  be provided enough bits at this point in order to complete decompression of
-  the data provided so far to the compressor.  It may need to wait for the next
-  block to be emitted.  This is for advanced applications that need to control
-  the emission of deflate blocks.
-
-    If flush is set to Z_FULL_FLUSH, all output is flushed as with
-  Z_SYNC_FLUSH, and the compression state is reset so that decompression can
-  restart from this point if previous compressed data has been damaged or if
-  random access is desired.  Using Z_FULL_FLUSH too often can seriously degrade
-  compression.
-
-    If deflate returns with avail_out == 0, this function must be called again
-  with the same value of the flush parameter and more output space (updated
-  avail_out), until the flush is complete (deflate returns with non-zero
-  avail_out).  In the case of a Z_FULL_FLUSH or Z_SYNC_FLUSH, make sure that
-  avail_out is greater than six to avoid repeated flush markers due to
-  avail_out == 0 on return.
-
-    If the parameter flush is set to Z_FINISH, pending input is processed,
-  pending output is flushed and deflate returns with Z_STREAM_END if there was
-  enough output space; if deflate returns with Z_OK, this function must be
-  called again with Z_FINISH and more output space (updated avail_out) but no
-  more input data, until it returns with Z_STREAM_END or an error.  After
-  deflate has returned Z_STREAM_END, the only possible operations on the stream
-  are deflateReset or deflateEnd.
-
-    Z_FINISH can be used immediately after deflateInit if all the compression
-  is to be done in a single step.  In this case, avail_out must be at least the
-  value returned by deflateBound (see below).  If deflate does not return
-  Z_STREAM_END, then it must be called again as described above.
-
-    deflate() sets strm->adler to the adler32 checksum of all input read
-  so far (that is, total_in bytes).
-
-    deflate() may update strm->data_type if it can make a good guess about
-  the input data type (Z_BINARY or Z_TEXT).  In doubt, the data is considered
-  binary.  This field is only for information purposes and does not affect the
-  compression algorithm in any manner.
-
-    deflate() returns Z_OK if some progress has been made (more input
-  processed or more output produced), Z_STREAM_END if all input has been
-  consumed and all output has been produced (only when flush is set to
-  Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example
-  if next_in or next_out was Z_NULL), Z_BUF_ERROR if no progress is possible
-  (for example avail_in or avail_out was zero).  Note that Z_BUF_ERROR is not
-  fatal, and deflate() can be called again with more input and more output
-  space to continue compressing.
-*/
-
-
-ZEXTERN int ZEXPORT deflateEnd OF((z_streamp strm));
-/*
-     All dynamically allocated data structures for this stream are freed.
-   This function discards any unprocessed input and does not flush any pending
-   output.
-
-     deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the
-   stream state was inconsistent, Z_DATA_ERROR if the stream was freed
-   prematurely (some input or output was discarded).  In the error case, msg
-   may be set but then points to a static string (which must not be
-   deallocated).
-*/
-
-
-/*
-ZEXTERN int ZEXPORT inflateInit OF((z_streamp strm));
-
-     Initializes the internal stream state for decompression.  The fields
-   next_in, avail_in, zalloc, zfree and opaque must be initialized before by
-   the caller.  If next_in is not Z_NULL and avail_in is large enough (the
-   exact value depends on the compression method), inflateInit determines the
-   compression method from the zlib header and allocates all data structures
-   accordingly; otherwise the allocation will be deferred to the first call of
-   inflate.  If zalloc and zfree are set to Z_NULL, inflateInit updates them to
-   use default allocation functions.
-
-     inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough
-   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the
-   version assumed by the caller, or Z_STREAM_ERROR if the parameters are
-   invalid, such as a null pointer to the structure.  msg is set to null if
-   there is no error message.  inflateInit does not perform any decompression
-   apart from possibly reading the zlib header if present: actual decompression
-   will be done by inflate().  (So next_in and avail_in may be modified, but
-   next_out and avail_out are unused and unchanged.) The current implementation
-   of inflateInit() does not process any header information -- that is deferred
-   until inflate() is called.
-*/
-
-
-ZEXTERN int ZEXPORT inflate OF((z_streamp strm, int flush));
-/*
-    inflate decompresses as much data as possible, and stops when the input
-  buffer becomes empty or the output buffer becomes full.  It may introduce
-  some output latency (reading input without producing any output) except when
-  forced to flush.
-
-  The detailed semantics are as follows.  inflate performs one or both of the
-  following actions:
-
-  - Decompress more input starting at next_in and update next_in and avail_in
-    accordingly.  If not all input can be processed (because there is not
-    enough room in the output buffer), next_in is updated and processing will
-    resume at this point for the next call of inflate().
-
-  - Provide more output starting at next_out and update next_out and avail_out
-    accordingly.  inflate() provides as much output as possible, until there is
-    no more input data or no more space in the output buffer (see below about
-    the flush parameter).
-
-    Before the call of inflate(), the application should ensure that at least
-  one of the actions is possible, by providing more input and/or consuming more
-  output, and updating the next_* and avail_* values accordingly.  The
-  application can consume the uncompressed output when it wants, for example
-  when the output buffer is full (avail_out == 0), or after each call of
-  inflate().  If inflate returns Z_OK and with zero avail_out, it must be
-  called again after making room in the output buffer because there might be
-  more output pending.
-
-    The flush parameter of inflate() can be Z_NO_FLUSH, Z_SYNC_FLUSH, Z_FINISH,
-  Z_BLOCK, or Z_TREES.  Z_SYNC_FLUSH requests that inflate() flush as much
-  output as possible to the output buffer.  Z_BLOCK requests that inflate()
-  stop if and when it gets to the next deflate block boundary.  When decoding
-  the zlib or gzip format, this will cause inflate() to return immediately
-  after the header and before the first block.  When doing a raw inflate,
-  inflate() will go ahead and process the first block, and will return when it
-  gets to the end of that block, or when it runs out of data.
-
-    The Z_BLOCK option assists in appending to or combining deflate streams.
-  Also to assist in this, on return inflate() will set strm->data_type to the
-  number of unused bits in the last byte taken from strm->next_in, plus 64 if
-  inflate() is currently decoding the last block in the deflate stream, plus
-  128 if inflate() returned immediately after decoding an end-of-block code or
-  decoding the complete header up to just before the first byte of the deflate
-  stream.  The end-of-block will not be indicated until all of the uncompressed
-  data from that block has been written to strm->next_out.  The number of
-  unused bits may in general be greater than seven, except when bit 7 of
-  data_type is set, in which case the number of unused bits will be less than
-  eight.  data_type is set as noted here every time inflate() returns for all
-  flush options, and so can be used to determine the amount of currently
-  consumed input in bits.
-
-    The Z_TREES option behaves as Z_BLOCK does, but it also returns when the
-  end of each deflate block header is reached, before any actual data in that
-  block is decoded.  This allows the caller to determine the length of the
-  deflate block header for later use in random access within a deflate block.
-  256 is added to the value of strm->data_type when inflate() returns
-  immediately after reaching the end of the deflate block header.
-
-    inflate() should normally be called until it returns Z_STREAM_END or an
-  error.  However if all decompression is to be performed in a single step (a
-  single call of inflate), the parameter flush should be set to Z_FINISH.  In
-  this case all pending input is processed and all pending output is flushed;
-  avail_out must be large enough to hold all the uncompressed data.  (The size
-  of the uncompressed data may have been saved by the compressor for this
-  purpose.) The next operation on this stream must be inflateEnd to deallocate
-  the decompression state.  The use of Z_FINISH is never required, but can be
-  used to inform inflate that a faster approach may be used for the single
-  inflate() call.
-
-     In this implementation, inflate() always flushes as much output as
-  possible to the output buffer, and always uses the faster approach on the
-  first call.  So the only effect of the flush parameter in this implementation
-  is on the return value of inflate(), as noted below, or when it returns early
-  because Z_BLOCK or Z_TREES is used.
-
-     If a preset dictionary is needed after this call (see inflateSetDictionary
-  below), inflate sets strm->adler to the adler32 checksum of the dictionary
-  chosen by the compressor and returns Z_NEED_DICT; otherwise it sets
-  strm->adler to the adler32 checksum of all output produced so far (that is,
-  total_out bytes) and returns Z_OK, Z_STREAM_END or an error code as described
-  below.  At the end of the stream, inflate() checks that its computed adler32
-  checksum is equal to that saved by the compressor and returns Z_STREAM_END
-  only if the checksum is correct.
-
-    inflate() can decompress and check either zlib-wrapped or gzip-wrapped
-  deflate data.  The header type is detected automatically, if requested when
-  initializing with inflateInit2().  Any information contained in the gzip
-  header is not retained, so applications that need that information should
-  instead use raw inflate, see inflateInit2() below, or inflateBack() and
-  perform their own processing of the gzip header and trailer.
-
-    inflate() returns Z_OK if some progress has been made (more input processed
-  or more output produced), Z_STREAM_END if the end of the compressed data has
-  been reached and all uncompressed output has been produced, Z_NEED_DICT if a
-  preset dictionary is needed at this point, Z_DATA_ERROR if the input data was
-  corrupted (input stream not conforming to the zlib format or incorrect check
-  value), Z_STREAM_ERROR if the stream structure was inconsistent (for example
-  next_in or next_out was Z_NULL), Z_MEM_ERROR if there was not enough memory,
-  Z_BUF_ERROR if no progress is possible or if there was not enough room in the
-  output buffer when Z_FINISH is used.  Note that Z_BUF_ERROR is not fatal, and
-  inflate() can be called again with more input and more output space to
-  continue decompressing.  If Z_DATA_ERROR is returned, the application may
-  then call inflateSync() to look for a good compression block if a partial
-  recovery of the data is desired.
-*/
-
-
-ZEXTERN int ZEXPORT inflateEnd OF((z_streamp strm));
-/*
-     All dynamically allocated data structures for this stream are freed.
-   This function discards any unprocessed input and does not flush any pending
-   output.
-
-     inflateEnd returns Z_OK if success, Z_STREAM_ERROR if the stream state
-   was inconsistent.  In the error case, msg may be set but then points to a
-   static string (which must not be deallocated).
-*/
-
-
-                        /* Advanced functions */
-
-/*
-    The following functions are needed only in some special applications.
-*/
-
-/*
-ZEXTERN int ZEXPORT deflateInit2 OF((z_streamp strm,
-                                     int  level,
-                                     int  method,
-                                     int  windowBits,
-                                     int  memLevel,
-                                     int  strategy));
-
-     This is another version of deflateInit with more compression options.  The
-   fields next_in, zalloc, zfree and opaque must be initialized before by the
-   caller.
-
-     The method parameter is the compression method.  It must be Z_DEFLATED in
-   this version of the library.
-
-     The windowBits parameter is the base two logarithm of the window size
-   (the size of the history buffer).  It should be in the range 8..15 for this
-   version of the library.  Larger values of this parameter result in better
-   compression at the expense of memory usage.  The default value is 15 if
-   deflateInit is used instead.
-
-     windowBits can also be -8..-15 for raw deflate.  In this case, -windowBits
-   determines the window size.  deflate() will then generate raw deflate data
-   with no zlib header or trailer, and will not compute an adler32 check value.
-
-     windowBits can also be greater than 15 for optional gzip encoding.  Add
-   16 to windowBits to write a simple gzip header and trailer around the
-   compressed data instead of a zlib wrapper.  The gzip header will have no
-   file name, no extra data, no comment, no modification time (set to zero), no
-   header crc, and the operating system will be set to 255 (unknown).  If a
-   gzip stream is being written, strm->adler is a crc32 instead of an adler32.
-
-     The memLevel parameter specifies how much memory should be allocated
-   for the internal compression state.  memLevel=1 uses minimum memory but is
-   slow and reduces compression ratio; memLevel=9 uses maximum memory for
-   optimal speed.  The default value is 8.  See zconf.h for total memory usage
-   as a function of windowBits and memLevel.
-
-     The strategy parameter is used to tune the compression algorithm.  Use the
-   value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a
-   filter (or predictor), Z_HUFFMAN_ONLY to force Huffman encoding only (no
-   string match), or Z_RLE to limit match distances to one (run-length
-   encoding).  Filtered data consists mostly of small values with a somewhat
-   random distribution.  In this case, the compression algorithm is tuned to
-   compress them better.  The effect of Z_FILTERED is to force more Huffman
-   coding and less string matching; it is somewhat intermediate between
-   Z_DEFAULT_STRATEGY and Z_HUFFMAN_ONLY.  Z_RLE is designed to be almost as
-   fast as Z_HUFFMAN_ONLY, but give better compression for PNG image data.  The
-   strategy parameter only affects the compression ratio but not the
-   correctness of the compressed output even if it is not set appropriately.
-   Z_FIXED prevents the use of dynamic Huffman codes, allowing for a simpler
-   decoder for special applications.
-
-     deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
-   memory, Z_STREAM_ERROR if any parameter is invalid (such as an invalid
-   method), or Z_VERSION_ERROR if the zlib library version (zlib_version) is
-   incompatible with the version assumed by the caller (ZLIB_VERSION).  msg is
-   set to null if there is no error message.  deflateInit2 does not perform any
-   compression: this will be done by deflate().
-*/
-
-ZEXTERN int ZEXPORT deflateSetDictionary OF((z_streamp strm,
-                                             const Bytef *dictionary,
-                                             uInt  dictLength));
-/*
-     Initializes the compression dictionary from the given byte sequence
-   without producing any compressed output.  This function must be called
-   immediately after deflateInit, deflateInit2 or deflateReset, before any call
-   of deflate.  The compressor and decompressor must use exactly the same
-   dictionary (see inflateSetDictionary).
-
-     The dictionary should consist of strings (byte sequences) that are likely
-   to be encountered later in the data to be compressed, with the most commonly
-   used strings preferably put towards the end of the dictionary.  Using a
-   dictionary is most useful when the data to be compressed is short and can be
-   predicted with good accuracy; the data can then be compressed better than
-   with the default empty dictionary.
-
-     Depending on the size of the compression data structures selected by
-   deflateInit or deflateInit2, a part of the dictionary may in effect be
-   discarded, for example if the dictionary is larger than the window size
-   provided in deflateInit or deflateInit2.  Thus the strings most likely to be
-   useful should be put at the end of the dictionary, not at the front.  In
-   addition, the current implementation of deflate will use at most the window
-   size minus 262 bytes of the provided dictionary.
-
-     Upon return of this function, strm->adler is set to the adler32 value
-   of the dictionary; the decompressor may later use this value to determine
-   which dictionary has been used by the compressor.  (The adler32 value
-   applies to the whole dictionary even if only a subset of the dictionary is
-   actually used by the compressor.) If a raw deflate was requested, then the
-   adler32 value is not computed and strm->adler is not set.
-
-     deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a
-   parameter is invalid (e.g.  dictionary being Z_NULL) or the stream state is
-   inconsistent (for example if deflate has already been called for this stream
-   or if the compression method is bsort).  deflateSetDictionary does not
-   perform any compression: this will be done by deflate().
-*/
-
-ZEXTERN int ZEXPORT deflateCopy OF((z_streamp dest,
-                                    z_streamp source));
-/*
-     Sets the destination stream as a complete copy of the source stream.
-
-     This function can be useful when several compression strategies will be
-   tried, for example when there are several ways of pre-processing the input
-   data with a filter.  The streams that will be discarded should then be freed
-   by calling deflateEnd.  Note that deflateCopy duplicates the internal
-   compression state which can be quite large, so this strategy is slow and can
-   consume lots of memory.
-
-     deflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
-   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
-   (such as zalloc being Z_NULL).  msg is left unchanged in both source and
-   destination.
-*/
-
-ZEXTERN int ZEXPORT deflateReset OF((z_streamp strm));
-/*
-     This function is equivalent to deflateEnd followed by deflateInit,
-   but does not free and reallocate all the internal compression state.  The
-   stream will keep the same compression level and any other attributes that
-   may have been set by deflateInit2.
-
-     deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent (such as zalloc or state being Z_NULL).
-*/
-
-ZEXTERN int ZEXPORT deflateParams OF((z_streamp strm,
-                                      int level,
-                                      int strategy));
-/*
-     Dynamically update the compression level and compression strategy.  The
-   interpretation of level and strategy is as in deflateInit2.  This can be
-   used to switch between compression and straight copy of the input data, or
-   to switch to a different kind of input data requiring a different strategy.
-   If the compression level is changed, the input available so far is
-   compressed with the old level (and may be flushed); the new level will take
-   effect only at the next call of deflate().
-
-     Before the call of deflateParams, the stream state must be set as for
-   a call of deflate(), since the currently available input may have to be
-   compressed and flushed.  In particular, strm->avail_out must be non-zero.
-
-     deflateParams returns Z_OK if success, Z_STREAM_ERROR if the source
-   stream state was inconsistent or if a parameter was invalid, Z_BUF_ERROR if
-   strm->avail_out was zero.
-*/
-
-ZEXTERN int ZEXPORT deflateTune OF((z_streamp strm,
-                                    int good_length,
-                                    int max_lazy,
-                                    int nice_length,
-                                    int max_chain));
-/*
-     Fine tune deflate's internal compression parameters.  This should only be
-   used by someone who understands the algorithm used by zlib's deflate for
-   searching for the best matching string, and even then only by the most
-   fanatic optimizer trying to squeeze out the last compressed bit for their
-   specific input data.  Read the deflate.c source code for the meaning of the
-   max_lazy, good_length, nice_length, and max_chain parameters.
-
-     deflateTune() can be called after deflateInit() or deflateInit2(), and
-   returns Z_OK on success, or Z_STREAM_ERROR for an invalid deflate stream.
- */
-
-ZEXTERN uLong ZEXPORT deflateBound OF((z_streamp strm,
-                                       uLong sourceLen));
-/*
-     deflateBound() returns an upper bound on the compressed size after
-   deflation of sourceLen bytes.  It must be called after deflateInit() or
-   deflateInit2(), and after deflateSetHeader(), if used.  This would be used
-   to allocate an output buffer for deflation in a single pass, and so would be
-   called before deflate().
-*/
-
-ZEXTERN int ZEXPORT deflatePrime OF((z_streamp strm,
-                                     int bits,
-                                     int value));
-/*
-     deflatePrime() inserts bits in the deflate output stream.  The intent
-   is that this function is used to start off the deflate output with the bits
-   leftover from a previous deflate stream when appending to it.  As such, this
-   function can only be used for raw deflate, and must be used before the first
-   deflate() call after a deflateInit2() or deflateReset().  bits must be less
-   than or equal to 16, and that many of the least significant bits of value
-   will be inserted in the output.
-
-     deflatePrime returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent.
-*/
-
-ZEXTERN int ZEXPORT deflateSetHeader OF((z_streamp strm,
-                                         gz_headerp head));
-/*
-     deflateSetHeader() provides gzip header information for when a gzip
-   stream is requested by deflateInit2().  deflateSetHeader() may be called
-   after deflateInit2() or deflateReset() and before the first call of
-   deflate().  The text, time, os, extra field, name, and comment information
-   in the provided gz_header structure are written to the gzip header (xflag is
-   ignored -- the extra flags are set according to the compression level).  The
-   caller must assure that, if not Z_NULL, name and comment are terminated with
-   a zero byte, and that if extra is not Z_NULL, that extra_len bytes are
-   available there.  If hcrc is true, a gzip header crc is included.  Note that
-   the current versions of the command-line version of gzip (up through version
-   1.3.x) do not support header crc's, and will report that it is a "multi-part
-   gzip file" and give up.
-
-     If deflateSetHeader is not used, the default gzip header has text false,
-   the time set to zero, and os set to 255, with no extra, name, or comment
-   fields.  The gzip header is returned to the default state by deflateReset().
-
-     deflateSetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent.
-*/
-
-/*
-ZEXTERN int ZEXPORT inflateInit2 OF((z_streamp strm,
-                                     int  windowBits));
-
-     This is another version of inflateInit with an extra parameter.  The
-   fields next_in, avail_in, zalloc, zfree and opaque must be initialized
-   before by the caller.
-
-     The windowBits parameter is the base two logarithm of the maximum window
-   size (the size of the history buffer).  It should be in the range 8..15 for
-   this version of the library.  The default value is 15 if inflateInit is used
-   instead.  windowBits must be greater than or equal to the windowBits value
-   provided to deflateInit2() while compressing, or it must be equal to 15 if
-   deflateInit2() was not used.  If a compressed stream with a larger window
-   size is given as input, inflate() will return with the error code
-   Z_DATA_ERROR instead of trying to allocate a larger window.
-
-     windowBits can also be zero to request that inflate use the window size in
-   the zlib header of the compressed stream.
-
-     windowBits can also be -8..-15 for raw inflate.  In this case, -windowBits
-   determines the window size.  inflate() will then process raw deflate data,
-   not looking for a zlib or gzip header, not generating a check value, and not
-   looking for any check values for comparison at the end of the stream.  This
-   is for use with other formats that use the deflate compressed data format
-   such as zip.  Those formats provide their own check values.  If a custom
-   format is developed using the raw deflate format for compressed data, it is
-   recommended that a check value such as an adler32 or a crc32 be applied to
-   the uncompressed data as is done in the zlib, gzip, and zip formats.  For
-   most applications, the zlib format should be used as is.  Note that comments
-   above on the use in deflateInit2() applies to the magnitude of windowBits.
-
-     windowBits can also be greater than 15 for optional gzip decoding.  Add
-   32 to windowBits to enable zlib and gzip decoding with automatic header
-   detection, or add 16 to decode only the gzip format (the zlib format will
-   return a Z_DATA_ERROR).  If a gzip stream is being decoded, strm->adler is a
-   crc32 instead of an adler32.
-
-     inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
-   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the
-   version assumed by the caller, or Z_STREAM_ERROR if the parameters are
-   invalid, such as a null pointer to the structure.  msg is set to null if
-   there is no error message.  inflateInit2 does not perform any decompression
-   apart from possibly reading the zlib header if present: actual decompression
-   will be done by inflate().  (So next_in and avail_in may be modified, but
-   next_out and avail_out are unused and unchanged.) The current implementation
-   of inflateInit2() does not process any header information -- that is
-   deferred until inflate() is called.
-*/
-
-ZEXTERN int ZEXPORT inflateSetDictionary OF((z_streamp strm,
-                                             const Bytef *dictionary,
-                                             uInt  dictLength));
-/*
-     Initializes the decompression dictionary from the given uncompressed byte
-   sequence.  This function must be called immediately after a call of inflate,
-   if that call returned Z_NEED_DICT.  The dictionary chosen by the compressor
-   can be determined from the adler32 value returned by that call of inflate.
-   The compressor and decompressor must use exactly the same dictionary (see
-   deflateSetDictionary).  For raw inflate, this function can be called
-   immediately after inflateInit2() or inflateReset() and before any call of
-   inflate() to set the dictionary.  The application must insure that the
-   dictionary that was used for compression is provided.
-
-     inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a
-   parameter is invalid (e.g.  dictionary being Z_NULL) or the stream state is
-   inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the
-   expected one (incorrect adler32 value).  inflateSetDictionary does not
-   perform any decompression: this will be done by subsequent calls of
-   inflate().
-*/
-
-ZEXTERN int ZEXPORT inflateSync OF((z_streamp strm));
-/*
-     Skips invalid compressed data until a full flush point (see above the
-   description of deflate with Z_FULL_FLUSH) can be found, or until all
-   available input is skipped.  No output is provided.
-
-     inflateSync returns Z_OK if a full flush point has been found, Z_BUF_ERROR
-   if no more input was provided, Z_DATA_ERROR if no flush point has been
-   found, or Z_STREAM_ERROR if the stream structure was inconsistent.  In the
-   success case, the application may save the current current value of total_in
-   which indicates where valid compressed data was found.  In the error case,
-   the application may repeatedly call inflateSync, providing more input each
-   time, until success or end of the input data.
-*/
-
-ZEXTERN int ZEXPORT inflateCopy OF((z_streamp dest,
-                                    z_streamp source));
-/*
-     Sets the destination stream as a complete copy of the source stream.
-
-     This function can be useful when randomly accessing a large stream.  The
-   first pass through the stream can periodically record the inflate state,
-   allowing restarting inflate at those points when randomly accessing the
-   stream.
-
-     inflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
-   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
-   (such as zalloc being Z_NULL).  msg is left unchanged in both source and
-   destination.
-*/
-
-ZEXTERN int ZEXPORT inflateReset OF((z_streamp strm));
-/*
-     This function is equivalent to inflateEnd followed by inflateInit,
-   but does not free and reallocate all the internal decompression state.  The
-   stream will keep attributes that may have been set by inflateInit2.
-
-     inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent (such as zalloc or state being Z_NULL).
-*/
-
-ZEXTERN int ZEXPORT inflateReset2 OF((z_streamp strm,
-                                      int windowBits));
-/*
-     This function is the same as inflateReset, but it also permits changing
-   the wrap and window size requests.  The windowBits parameter is interpreted
-   the same as it is for inflateInit2.
-
-     inflateReset2 returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent (such as zalloc or state being Z_NULL), or if
-   the windowBits parameter is invalid.
-*/
-
-ZEXTERN int ZEXPORT inflatePrime OF((z_streamp strm,
-                                     int bits,
-                                     int value));
-/*
-     This function inserts bits in the inflate input stream.  The intent is
-   that this function is used to start inflating at a bit position in the
-   middle of a byte.  The provided bits will be used before any bytes are used
-   from next_in.  This function should only be used with raw inflate, and
-   should be used before the first inflate() call after inflateInit2() or
-   inflateReset().  bits must be less than or equal to 16, and that many of the
-   least significant bits of value will be inserted in the input.
-
-     If bits is negative, then the input stream bit buffer is emptied.  Then
-   inflatePrime() can be called again to put bits in the buffer.  This is used
-   to clear out bits leftover after feeding inflate a block description prior
-   to feeding inflate codes.
-
-     inflatePrime returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent.
-*/
-
-ZEXTERN long ZEXPORT inflateMark OF((z_streamp strm));
-/*
-     This function returns two values, one in the lower 16 bits of the return
-   value, and the other in the remaining upper bits, obtained by shifting the
-   return value down 16 bits.  If the upper value is -1 and the lower value is
-   zero, then inflate() is currently decoding information outside of a block.
-   If the upper value is -1 and the lower value is non-zero, then inflate is in
-   the middle of a stored block, with the lower value equaling the number of
-   bytes from the input remaining to copy.  If the upper value is not -1, then
-   it is the number of bits back from the current bit position in the input of
-   the code (literal or length/distance pair) currently being processed.  In
-   that case the lower value is the number of bytes already emitted for that
-   code.
-
-     A code is being processed if inflate is waiting for more input to complete
-   decoding of the code, or if it has completed decoding but is waiting for
-   more output space to write the literal or match data.
-
-     inflateMark() is used to mark locations in the input data for random
-   access, which may be at bit positions, and to note those cases where the
-   output of a code may span boundaries of random access blocks.  The current
-   location in the input stream can be determined from avail_in and data_type
-   as noted in the description for the Z_BLOCK flush parameter for inflate.
-
-     inflateMark returns the value noted above or -1 << 16 if the provided
-   source stream state was inconsistent.
-*/
-
-ZEXTERN int ZEXPORT inflateGetHeader OF((z_streamp strm,
-                                         gz_headerp head));
-/*
-     inflateGetHeader() requests that gzip header information be stored in the
-   provided gz_header structure.  inflateGetHeader() may be called after
-   inflateInit2() or inflateReset(), and before the first call of inflate().
-   As inflate() processes the gzip stream, head->done is zero until the header
-   is completed, at which time head->done is set to one.  If a zlib stream is
-   being decoded, then head->done is set to -1 to indicate that there will be
-   no gzip header information forthcoming.  Note that Z_BLOCK or Z_TREES can be
-   used to force inflate() to return immediately after header processing is
-   complete and before any actual data is decompressed.
-
-     The text, time, xflags, and os fields are filled in with the gzip header
-   contents.  hcrc is set to true if there is a header CRC.  (The header CRC
-   was valid if done is set to one.) If extra is not Z_NULL, then extra_max
-   contains the maximum number of bytes to write to extra.  Once done is true,
-   extra_len contains the actual extra field length, and extra contains the
-   extra field, or that field truncated if extra_max is less than extra_len.
-   If name is not Z_NULL, then up to name_max characters are written there,
-   terminated with a zero unless the length is greater than name_max.  If
-   comment is not Z_NULL, then up to comm_max characters are written there,
-   terminated with a zero unless the length is greater than comm_max.  When any
-   of extra, name, or comment are not Z_NULL and the respective field is not
-   present in the header, then that field is set to Z_NULL to signal its
-   absence.  This allows the use of deflateSetHeader() with the returned
-   structure to duplicate the header.  However if those fields are set to
-   allocated memory, then the application will need to save those pointers
-   elsewhere so that they can be eventually freed.
-
-     If inflateGetHeader is not used, then the header information is simply
-   discarded.  The header is always checked for validity, including the header
-   CRC if present.  inflateReset() will reset the process to discard the header
-   information.  The application would need to call inflateGetHeader() again to
-   retrieve the header from the next gzip stream.
-
-     inflateGetHeader returns Z_OK if success, or Z_STREAM_ERROR if the source
-   stream state was inconsistent.
-*/
-
-/*
-ZEXTERN int ZEXPORT inflateBackInit OF((z_streamp strm, int windowBits,
-                                        unsigned char FAR *window));
-
-     Initialize the internal stream state for decompression using inflateBack()
-   calls.  The fields zalloc, zfree and opaque in strm must be initialized
-   before the call.  If zalloc and zfree are Z_NULL, then the default library-
-   derived memory allocation routines are used.  windowBits is the base two
-   logarithm of the window size, in the range 8..15.  window is a caller
-   supplied buffer of that size.  Except for special applications where it is
-   assured that deflate was used with small window sizes, windowBits must be 15
-   and a 32K byte window must be supplied to be able to decompress general
-   deflate streams.
-
-     See inflateBack() for the usage of these routines.
-
-     inflateBackInit will return Z_OK on success, Z_STREAM_ERROR if any of
-   the paramaters are invalid, Z_MEM_ERROR if the internal state could not be
-   allocated, or Z_VERSION_ERROR if the version of the library does not match
-   the version of the header file.
-*/
-
-typedef unsigned (*in_func) OF((void FAR *, unsigned char FAR * FAR *));
-typedef int (*out_func) OF((void FAR *, unsigned char FAR *, unsigned));
-
-ZEXTERN int ZEXPORT inflateBack OF((z_streamp strm,
-                                    in_func in, void FAR *in_desc,
-                                    out_func out, void FAR *out_desc));
-/*
-     inflateBack() does a raw inflate with a single call using a call-back
-   interface for input and output.  This is more efficient than inflate() for
-   file i/o applications in that it avoids copying between the output and the
-   sliding window by simply making the window itself the output buffer.  This
-   function trusts the application to not change the output buffer passed by
-   the output function, at least until inflateBack() returns.
-
-     inflateBackInit() must be called first to allocate the internal state
-   and to initialize the state with the user-provided window buffer.
-   inflateBack() may then be used multiple times to inflate a complete, raw
-   deflate stream with each call.  inflateBackEnd() is then called to free the
-   allocated state.
-
-     A raw deflate stream is one with no zlib or gzip header or trailer.
-   This routine would normally be used in a utility that reads zip or gzip
-   files and writes out uncompressed files.  The utility would decode the
-   header and process the trailer on its own, hence this routine expects only
-   the raw deflate stream to decompress.  This is different from the normal
-   behavior of inflate(), which expects either a zlib or gzip header and
-   trailer around the deflate stream.
-
-     inflateBack() uses two subroutines supplied by the caller that are then
-   called by inflateBack() for input and output.  inflateBack() calls those
-   routines until it reads a complete deflate stream and writes out all of the
-   uncompressed data, or until it encounters an error.  The function's
-   parameters and return types are defined above in the in_func and out_func
-   typedefs.  inflateBack() will call in(in_desc, &buf) which should return the
-   number of bytes of provided input, and a pointer to that input in buf.  If
-   there is no input available, in() must return zero--buf is ignored in that
-   case--and inflateBack() will return a buffer error.  inflateBack() will call
-   out(out_desc, buf, len) to write the uncompressed data buf[0..len-1].  out()
-   should return zero on success, or non-zero on failure.  If out() returns
-   non-zero, inflateBack() will return with an error.  Neither in() nor out()
-   are permitted to change the contents of the window provided to
-   inflateBackInit(), which is also the buffer that out() uses to write from.
-   The length written by out() will be at most the window size.  Any non-zero
-   amount of input may be provided by in().
-
-     For convenience, inflateBack() can be provided input on the first call by
-   setting strm->next_in and strm->avail_in.  If that input is exhausted, then
-   in() will be called.  Therefore strm->next_in must be initialized before
-   calling inflateBack().  If strm->next_in is Z_NULL, then in() will be called
-   immediately for input.  If strm->next_in is not Z_NULL, then strm->avail_in
-   must also be initialized, and then if strm->avail_in is not zero, input will
-   initially be taken from strm->next_in[0 ..  strm->avail_in - 1].
-
-     The in_desc and out_desc parameters of inflateBack() is passed as the
-   first parameter of in() and out() respectively when they are called.  These
-   descriptors can be optionally used to pass any information that the caller-
-   supplied in() and out() functions need to do their job.
-
-     On return, inflateBack() will set strm->next_in and strm->avail_in to
-   pass back any unused input that was provided by the last in() call.  The
-   return values of inflateBack() can be Z_STREAM_END on success, Z_BUF_ERROR
-   if in() or out() returned an error, Z_DATA_ERROR if there was a format error
-   in the deflate stream (in which case strm->msg is set to indicate the nature
-   of the error), or Z_STREAM_ERROR if the stream was not properly initialized.
-   In the case of Z_BUF_ERROR, an input or output error can be distinguished
-   using strm->next_in which will be Z_NULL only if in() returned an error.  If
-   strm->next_in is not Z_NULL, then the Z_BUF_ERROR was due to out() returning
-   non-zero.  (in() will always be called before out(), so strm->next_in is
-   assured to be defined if out() returns non-zero.) Note that inflateBack()
-   cannot return Z_OK.
-*/
-
-ZEXTERN int ZEXPORT inflateBackEnd OF((z_streamp strm));
-/*
-     All memory allocated by inflateBackInit() is freed.
-
-     inflateBackEnd() returns Z_OK on success, or Z_STREAM_ERROR if the stream
-   state was inconsistent.
-*/
-
-ZEXTERN uLong ZEXPORT zlibCompileFlags OF((void));
-/* Return flags indicating compile-time options.
-
-    Type sizes, two bits each, 00 = 16 bits, 01 = 32, 10 = 64, 11 = other:
-     1.0: size of uInt
-     3.2: size of uLong
-     5.4: size of voidpf (pointer)
-     7.6: size of z_off_t
-
-    Compiler, assembler, and debug options:
-     8: DEBUG
-     9: ASMV or ASMINF -- use ASM code
-     10: ZLIB_WINAPI -- exported functions use the WINAPI calling convention
-     11: 0 (reserved)
-
-    One-time table building (smaller code, but not thread-safe if true):
-     12: BUILDFIXED -- build static block decoding tables when needed
-     13: DYNAMIC_CRC_TABLE -- build CRC calculation tables when needed
-     14,15: 0 (reserved)
-
-    Library content (indicates missing functionality):
-     16: NO_GZCOMPRESS -- gz* functions cannot compress (to avoid linking
-                          deflate code when not needed)
-     17: NO_GZIP -- deflate can't write gzip streams, and inflate can't detect
-                    and decode gzip streams (to avoid linking crc code)
-     18-19: 0 (reserved)
-
-    Operation variations (changes in library functionality):
-     20: PKZIP_BUG_WORKAROUND -- slightly more permissive inflate
-     21: FASTEST -- deflate algorithm with only one, lowest compression level
-     22,23: 0 (reserved)
-
-    The sprintf variant used by gzprintf (zero is best):
-     24: 0 = vs*, 1 = s* -- 1 means limited to 20 arguments after the format
-     25: 0 = *nprintf, 1 = *printf -- 1 means gzprintf() not secure!
-     26: 0 = returns value, 1 = void -- 1 means inferred string length returned
-
-    Remainder:
-     27-31: 0 (reserved)
- */
-
-
-                        /* utility functions */
-
-/*
-     The following utility functions are implemented on top of the basic
-   stream-oriented functions.  To simplify the interface, some default options
-   are assumed (compression level and memory usage, standard memory allocation
-   functions).  The source code of these utility functions can be modified if
-   you need special options.
-*/
-
-ZEXTERN int ZEXPORT compress OF((Bytef *dest,   uLongf *destLen,
-                                 const Bytef *source, uLong sourceLen));
-/*
-     Compresses the source buffer into the destination buffer.  sourceLen is
-   the byte length of the source buffer.  Upon entry, destLen is the total size
-   of the destination buffer, which must be at least the value returned by
-   compressBound(sourceLen).  Upon exit, destLen is the actual size of the
-   compressed buffer.
-
-     compress returns Z_OK if success, Z_MEM_ERROR if there was not
-   enough memory, Z_BUF_ERROR if there was not enough room in the output
-   buffer.
-*/
-
-ZEXTERN int ZEXPORT compress2 OF((Bytef *dest,   uLongf *destLen,
-                                  const Bytef *source, uLong sourceLen,
-                                  int level));
-/*
-     Compresses the source buffer into the destination buffer.  The level
-   parameter has the same meaning as in deflateInit.  sourceLen is the byte
-   length of the source buffer.  Upon entry, destLen is the total size of the
-   destination buffer, which must be at least the value returned by
-   compressBound(sourceLen).  Upon exit, destLen is the actual size of the
-   compressed buffer.
-
-     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
-   memory, Z_BUF_ERROR if there was not enough room in the output buffer,
-   Z_STREAM_ERROR if the level parameter is invalid.
-*/
-
-ZEXTERN uLong ZEXPORT compressBound OF((uLong sourceLen));
-/*
-     compressBound() returns an upper bound on the compressed size after
-   compress() or compress2() on sourceLen bytes.  It would be used before a
-   compress() or compress2() call to allocate the destination buffer.
-*/
-
-ZEXTERN int ZEXPORT uncompress OF((Bytef *dest,   uLongf *destLen,
-                                   const Bytef *source, uLong sourceLen));
-/*
-     Decompresses the source buffer into the destination buffer.  sourceLen is
-   the byte length of the source buffer.  Upon entry, destLen is the total size
-   of the destination buffer, which must be large enough to hold the entire
-   uncompressed data.  (The size of the uncompressed data must have been saved
-   previously by the compressor and transmitted to the decompressor by some
-   mechanism outside the scope of this compression library.) Upon exit, destLen
-   is the actual size of the uncompressed buffer.
-
-     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not
-   enough memory, Z_BUF_ERROR if there was not enough room in the output
-   buffer, or Z_DATA_ERROR if the input data was corrupted or incomplete.
-*/
-
-
-                        /* gzip file access functions */
-
-/*
-     This library supports reading and writing files in gzip (.gz) format with
-   an interface similar to that of stdio, using the functions that start with
-   "gz".  The gzip format is different from the zlib format.  gzip is a gzip
-   wrapper, documented in RFC 1952, wrapped around a deflate stream.
-*/
-
-typedef voidp gzFile;       /* opaque gzip file descriptor */
-
-/*
-ZEXTERN gzFile ZEXPORT gzopen OF((const char *path, const char *mode));
-
-     Opens a gzip (.gz) file for reading or writing.  The mode parameter is as
-   in fopen ("rb" or "wb") but can also include a compression level ("wb9") or
-   a strategy: 'f' for filtered data as in "wb6f", 'h' for Huffman-only
-   compression as in "wb1h", 'R' for run-length encoding as in "wb1R", or 'F'
-   for fixed code compression as in "wb9F".  (See the description of
-   deflateInit2 for more information about the strategy parameter.) Also "a"
-   can be used instead of "w" to request that the gzip stream that will be
-   written be appended to the file.  "+" will result in an error, since reading
-   and writing to the same gzip file is not supported.
-
-     gzopen can be used to read a file which is not in gzip format; in this
-   case gzread will directly read from the file without decompression.
-
-     gzopen returns NULL if the file could not be opened, if there was
-   insufficient memory to allocate the gzFile state, or if an invalid mode was
-   specified (an 'r', 'w', or 'a' was not provided, or '+' was provided).
-   errno can be checked to determine if the reason gzopen failed was that the
-   file could not be opened.
-*/
-
-ZEXTERN gzFile ZEXPORT gzdopen OF((int fd, const char *mode));
-/*
-     gzdopen associates a gzFile with the file descriptor fd.  File descriptors
-   are obtained from calls like open, dup, creat, pipe or fileno (if the file
-   has been previously opened with fopen).  The mode parameter is as in gzopen.
-
-     The next call of gzclose on the returned gzFile will also close the file
-   descriptor fd, just like fclose(fdopen(fd, mode)) closes the file descriptor
-   fd.  If you want to keep fd open, use fd = dup(fd_keep); gz = gzdopen(fd,
-   mode);.  The duplicated descriptor should be saved to avoid a leak, since
-   gzdopen does not close fd if it fails.
-
-     gzdopen returns NULL if there was insufficient memory to allocate the
-   gzFile state, if an invalid mode was specified (an 'r', 'w', or 'a' was not
-   provided, or '+' was provided), or if fd is -1.  The file descriptor is not
-   used until the next gz* read, write, seek, or close operation, so gzdopen
-   will not detect if fd is invalid (unless fd is -1).
-*/
-
-ZEXTERN int ZEXPORT gzbuffer OF((gzFile file, unsigned size));
-/*
-     Set the internal buffer size used by this library's functions.  The
-   default buffer size is 8192 bytes.  This function must be called after
-   gzopen() or gzdopen(), and before any other calls that read or write the
-   file.  The buffer memory allocation is always deferred to the first read or
-   write.  Two buffers are allocated, either both of the specified size when
-   writing, or one of the specified size and the other twice that size when
-   reading.  A larger buffer size of, for example, 64K or 128K bytes will
-   noticeably increase the speed of decompression (reading).
-
-     The new buffer size also affects the maximum length for gzprintf().
-
-     gzbuffer() returns 0 on success, or -1 on failure, such as being called
-   too late.
-*/
-
-ZEXTERN int ZEXPORT gzsetparams OF((gzFile file, int level, int strategy));
-/*
-     Dynamically update the compression level or strategy.  See the description
-   of deflateInit2 for the meaning of these parameters.
-
-     gzsetparams returns Z_OK if success, or Z_STREAM_ERROR if the file was not
-   opened for writing.
-*/
-
-ZEXTERN int ZEXPORT gzread OF((gzFile file, voidp buf, unsigned len));
-/*
-     Reads the given number of uncompressed bytes from the compressed file.  If
-   the input file was not in gzip format, gzread copies the given number of
-   bytes into the buffer.
-
-     After reaching the end of a gzip stream in the input, gzread will continue
-   to read, looking for another gzip stream, or failing that, reading the rest
-   of the input file directly without decompression.  The entire input file
-   will be read if gzread is called until it returns less than the requested
-   len.
-
-     gzread returns the number of uncompressed bytes actually read, less than
-   len for end of file, or -1 for error.
-*/
-
-ZEXTERN int ZEXPORT gzwrite OF((gzFile file,
-                                voidpc buf, unsigned len));
-/*
-     Writes the given number of uncompressed bytes into the compressed file.
-   gzwrite returns the number of uncompressed bytes written or 0 in case of
-   error.
-*/
-
-ZEXTERN int ZEXPORTVA gzprintf OF((gzFile file, const char *format, ...));
-/*
-     Converts, formats, and writes the arguments to the compressed file under
-   control of the format string, as in fprintf.  gzprintf returns the number of
-   uncompressed bytes actually written, or 0 in case of error.  The number of
-   uncompressed bytes written is limited to 8191, or one less than the buffer
-   size given to gzbuffer().  The caller should assure that this limit is not
-   exceeded.  If it is exceeded, then gzprintf() will return an error (0) with
-   nothing written.  In this case, there may also be a buffer overflow with
-   unpredictable consequences, which is possible only if zlib was compiled with
-   the insecure functions sprintf() or vsprintf() because the secure snprintf()
-   or vsnprintf() functions were not available.  This can be determined using
-   zlibCompileFlags().
-*/
-
-ZEXTERN int ZEXPORT gzputs OF((gzFile file, const char *s));
-/*
-     Writes the given null-terminated string to the compressed file, excluding
-   the terminating null character.
-
-     gzputs returns the number of characters written, or -1 in case of error.
-*/
-
-ZEXTERN char * ZEXPORT gzgets OF((gzFile file, char *buf, int len));
-/*
-     Reads bytes from the compressed file until len-1 characters are read, or a
-   newline character is read and transferred to buf, or an end-of-file
-   condition is encountered.  If any characters are read or if len == 1, the
-   string is terminated with a null character.  If no characters are read due
-   to an end-of-file or len < 1, then the buffer is left untouched.
-
-     gzgets returns buf which is a null-terminated string, or it returns NULL
-   for end-of-file or in case of error.  If there was an error, the contents at
-   buf are indeterminate.
-*/
-
-ZEXTERN int ZEXPORT gzputc OF((gzFile file, int c));
-/*
-     Writes c, converted to an unsigned char, into the compressed file.  gzputc
-   returns the value that was written, or -1 in case of error.
-*/
-
-ZEXTERN int ZEXPORT gzgetc OF((gzFile file));
-/*
-     Reads one byte from the compressed file.  gzgetc returns this byte or -1
-   in case of end of file or error.
-*/
-
-ZEXTERN int ZEXPORT gzungetc OF((int c, gzFile file));
-/*
-     Push one character back onto the stream to be read as the first character
-   on the next read.  At least one character of push-back is allowed.
-   gzungetc() returns the character pushed, or -1 on failure.  gzungetc() will
-   fail if c is -1, and may fail if a character has been pushed but not read
-   yet.  If gzungetc is used immediately after gzopen or gzdopen, at least the
-   output buffer size of pushed characters is allowed.  (See gzbuffer above.)
-   The pushed character will be discarded if the stream is repositioned with
-   gzseek() or gzrewind().
-*/
-
-ZEXTERN int ZEXPORT gzflush OF((gzFile file, int flush));
-/*
-     Flushes all pending output into the compressed file.  The parameter flush
-   is as in the deflate() function.  The return value is the zlib error number
-   (see function gzerror below).  gzflush is only permitted when writing.
-
-     If the flush parameter is Z_FINISH, the remaining data is written and the
-   gzip stream is completed in the output.  If gzwrite() is called again, a new
-   gzip stream will be started in the output.  gzread() is able to read such
-   concatented gzip streams.
-
-     gzflush should be called only when strictly necessary because it will
-   degrade compression if called too often.
-*/
-
-/*
-ZEXTERN z_off_t ZEXPORT gzseek OF((gzFile file,
-                                   z_off_t offset, int whence));
-
-     Sets the starting position for the next gzread or gzwrite on the given
-   compressed file.  The offset represents a number of bytes in the
-   uncompressed data stream.  The whence parameter is defined as in lseek(2);
-   the value SEEK_END is not supported.
-
-     If the file is opened for reading, this function is emulated but can be
-   extremely slow.  If the file is opened for writing, only forward seeks are
-   supported; gzseek then compresses a sequence of zeroes up to the new
-   starting position.
-
-     gzseek returns the resulting offset location as measured in bytes from
-   the beginning of the uncompressed stream, or -1 in case of error, in
-   particular if the file is opened for writing and the new starting position
-   would be before the current position.
-*/
-
-ZEXTERN int ZEXPORT    gzrewind OF((gzFile file));
-/*
-     Rewinds the given file. This function is supported only for reading.
-
-     gzrewind(file) is equivalent to (int)gzseek(file, 0L, SEEK_SET)
-*/
-
-/*
-ZEXTERN z_off_t ZEXPORT    gztell OF((gzFile file));
-
-     Returns the starting position for the next gzread or gzwrite on the given
-   compressed file.  This position represents a number of bytes in the
-   uncompressed data stream, and is zero when starting, even if appending or
-   reading a gzip stream from the middle of a file using gzdopen().
-
-     gztell(file) is equivalent to gzseek(file, 0L, SEEK_CUR)
-*/
-
-/*
-ZEXTERN z_off_t ZEXPORT gzoffset OF((gzFile file));
-
-     Returns the current offset in the file being read or written.  This offset
-   includes the count of bytes that precede the gzip stream, for example when
-   appending or when using gzdopen() for reading.  When reading, the offset
-   does not include as yet unused buffered input.  This information can be used
-   for a progress indicator.  On error, gzoffset() returns -1.
-*/
-
-ZEXTERN int ZEXPORT gzeof OF((gzFile file));
-/*
-     Returns true (1) if the end-of-file indicator has been set while reading,
-   false (0) otherwise.  Note that the end-of-file indicator is set only if the
-   read tried to go past the end of the input, but came up short.  Therefore,
-   just like feof(), gzeof() may return false even if there is no more data to
-   read, in the event that the last read request was for the exact number of
-   bytes remaining in the input file.  This will happen if the input file size
-   is an exact multiple of the buffer size.
-
-     If gzeof() returns true, then the read functions will return no more data,
-   unless the end-of-file indicator is reset by gzclearerr() and the input file
-   has grown since the previous end of file was detected.
-*/
-
-ZEXTERN int ZEXPORT gzdirect OF((gzFile file));
-/*
-     Returns true (1) if file is being copied directly while reading, or false
-   (0) if file is a gzip stream being decompressed.  This state can change from
-   false to true while reading the input file if the end of a gzip stream is
-   reached, but is followed by data that is not another gzip stream.
-
-     If the input file is empty, gzdirect() will return true, since the input
-   does not contain a gzip stream.
-
-     If gzdirect() is used immediately after gzopen() or gzdopen() it will
-   cause buffers to be allocated to allow reading the file to determine if it
-   is a gzip file.  Therefore if gzbuffer() is used, it should be called before
-   gzdirect().
-*/
-
-ZEXTERN int ZEXPORT    gzclose OF((gzFile file));
-/*
-     Flushes all pending output if necessary, closes the compressed file and
-   deallocates the (de)compression state.  Note that once file is closed, you
-   cannot call gzerror with file, since its structures have been deallocated.
-   gzclose must not be called more than once on the same file, just as free
-   must not be called more than once on the same allocation.
-
-     gzclose will return Z_STREAM_ERROR if file is not valid, Z_ERRNO on a
-   file operation error, or Z_OK on success.
-*/
-
-ZEXTERN int ZEXPORT gzclose_r OF((gzFile file));
-ZEXTERN int ZEXPORT gzclose_w OF((gzFile file));
-/*
-     Same as gzclose(), but gzclose_r() is only for use when reading, and
-   gzclose_w() is only for use when writing or appending.  The advantage to
-   using these instead of gzclose() is that they avoid linking in zlib
-   compression or decompression code that is not used when only reading or only
-   writing respectively.  If gzclose() is used, then both compression and
-   decompression code will be included the application when linking to a static
-   zlib library.
-*/
-
-ZEXTERN const char * ZEXPORT gzerror OF((gzFile file, int *errnum));
-/*
-     Returns the error message for the last error which occurred on the given
-   compressed file.  errnum is set to zlib error number.  If an error occurred
-   in the file system and not in the compression library, errnum is set to
-   Z_ERRNO and the application may consult errno to get the exact error code.
-
-     The application must not modify the returned string.  Future calls to
-   this function may invalidate the previously returned string.  If file is
-   closed, then the string previously returned by gzerror will no longer be
-   available.
-
-     gzerror() should be used to distinguish errors from end-of-file for those
-   functions above that do not distinguish those cases in their return values.
-*/
-
-ZEXTERN void ZEXPORT gzclearerr OF((gzFile file));
-/*
-     Clears the error and end-of-file flags for file.  This is analogous to the
-   clearerr() function in stdio.  This is useful for continuing to read a gzip
-   file that is being written concurrently.
-*/
-
-
-                        /* checksum functions */
-
-/*
-     These functions are not related to compression but are exported
-   anyway because they might be useful in applications using the compression
-   library.
-*/
-
-ZEXTERN uLong ZEXPORT adler32 OF((uLong adler, const Bytef *buf, uInt len));
-/*
-     Update a running Adler-32 checksum with the bytes buf[0..len-1] and
-   return the updated checksum.  If buf is Z_NULL, this function returns the
-   required initial value for the checksum.
-
-     An Adler-32 checksum is almost as reliable as a CRC32 but can be computed
-   much faster.
-
-   Usage example:
-
-     uLong adler = adler32(0L, Z_NULL, 0);
-
-     while (read_buffer(buffer, length) != EOF) {
-       adler = adler32(adler, buffer, length);
-     }
-     if (adler != original_adler) error();
-*/
-
-/*
-ZEXTERN uLong ZEXPORT adler32_combine OF((uLong adler1, uLong adler2,
-                                          z_off_t len2));
-
-     Combine two Adler-32 checksums into one.  For two sequences of bytes, seq1
-   and seq2 with lengths len1 and len2, Adler-32 checksums were calculated for
-   each, adler1 and adler2.  adler32_combine() returns the Adler-32 checksum of
-   seq1 and seq2 concatenated, requiring only adler1, adler2, and len2.
-*/
-
-ZEXTERN uLong ZEXPORT crc32   OF((uLong crc, const Bytef *buf, uInt len));
-/*
-     Update a running CRC-32 with the bytes buf[0..len-1] and return the
-   updated CRC-32.  If buf is Z_NULL, this function returns the required
-   initial value for the for the crc.  Pre- and post-conditioning (one's
-   complement) is performed within this function so it shouldn't be done by the
-   application.
-
-   Usage example:
-
-     uLong crc = crc32(0L, Z_NULL, 0);
-
-     while (read_buffer(buffer, length) != EOF) {
-       crc = crc32(crc, buffer, length);
-     }
-     if (crc != original_crc) error();
-*/
-
-/*
-ZEXTERN uLong ZEXPORT crc32_combine OF((uLong crc1, uLong crc2, z_off_t len2));
-
-     Combine two CRC-32 check values into one.  For two sequences of bytes,
-   seq1 and seq2 with lengths len1 and len2, CRC-32 check values were
-   calculated for each, crc1 and crc2.  crc32_combine() returns the CRC-32
-   check value of seq1 and seq2 concatenated, requiring only crc1, crc2, and
-   len2.
-*/
-
-
-                        /* various hacks, don't look :) */
-
-/* deflateInit and inflateInit are macros to allow checking the zlib version
- * and the compiler's view of z_stream:
- */
-ZEXTERN int ZEXPORT deflateInit_ OF((z_streamp strm, int level,
-                                     const char *version, int stream_size));
-ZEXTERN int ZEXPORT inflateInit_ OF((z_streamp strm,
-                                     const char *version, int stream_size));
-ZEXTERN int ZEXPORT deflateInit2_ OF((z_streamp strm, int  level, int  method,
-                                      int windowBits, int memLevel,
-                                      int strategy, const char *version,
-                                      int stream_size));
-ZEXTERN int ZEXPORT inflateInit2_ OF((z_streamp strm, int  windowBits,
-                                      const char *version, int stream_size));
-ZEXTERN int ZEXPORT inflateBackInit_ OF((z_streamp strm, int windowBits,
-                                         unsigned char FAR *window,
-                                         const char *version,
-                                         int stream_size));
-#define deflateInit(strm, level) \
-        deflateInit_((strm), (level),       ZLIB_VERSION, sizeof(z_stream))
-#define inflateInit(strm) \
-        inflateInit_((strm),                ZLIB_VERSION, sizeof(z_stream))
-#define deflateInit2(strm, level, method, windowBits, memLevel, strategy) \
-        deflateInit2_((strm),(level),(method),(windowBits),(memLevel),\
-                      (strategy),           ZLIB_VERSION, sizeof(z_stream))
-#define inflateInit2(strm, windowBits) \
-        inflateInit2_((strm), (windowBits), ZLIB_VERSION, sizeof(z_stream))
-#define inflateBackInit(strm, windowBits, window) \
-        inflateBackInit_((strm), (windowBits), (window), \
-                                            ZLIB_VERSION, sizeof(z_stream))
-
-/* provide 64-bit offset functions if _LARGEFILE64_SOURCE defined, and/or
- * change the regular functions to 64 bits if _FILE_OFFSET_BITS is 64 (if
- * both are true, the application gets the *64 functions, and the regular
- * functions are changed to 64 bits) -- in case these are set on systems
- * without large file support, _LFS64_LARGEFILE must also be true
- */
-#if defined(_LARGEFILE64_SOURCE) && _LFS64_LARGEFILE-0
-   ZEXTERN gzFile ZEXPORT gzopen64 OF((const char *, const char *));
-   ZEXTERN z_off64_t ZEXPORT gzseek64 OF((gzFile, z_off64_t, int));
-   ZEXTERN z_off64_t ZEXPORT gztell64 OF((gzFile));
-   ZEXTERN z_off64_t ZEXPORT gzoffset64 OF((gzFile));
-   ZEXTERN uLong ZEXPORT adler32_combine64 OF((uLong, uLong, z_off64_t));
-   ZEXTERN uLong ZEXPORT crc32_combine64 OF((uLong, uLong, z_off64_t));
-#endif
-
-#if !defined(ZLIB_INTERNAL) && _FILE_OFFSET_BITS-0 == 64 && _LFS64_LARGEFILE-0
-#  define gzopen gzopen64
-#  define gzseek gzseek64
-#  define gztell gztell64
-#  define gzoffset gzoffset64
-#  define adler32_combine adler32_combine64
-#  define crc32_combine crc32_combine64
-#  ifdef _LARGEFILE64_SOURCE
-     ZEXTERN gzFile ZEXPORT gzopen64 OF((const char *, const char *));
-     ZEXTERN z_off_t ZEXPORT gzseek64 OF((gzFile, z_off_t, int));
-     ZEXTERN z_off_t ZEXPORT gztell64 OF((gzFile));
-     ZEXTERN z_off_t ZEXPORT gzoffset64 OF((gzFile));
-     ZEXTERN uLong ZEXPORT adler32_combine64 OF((uLong, uLong, z_off_t));
-     ZEXTERN uLong ZEXPORT crc32_combine64 OF((uLong, uLong, z_off_t));
-#  endif
-#else
-   ZEXTERN gzFile ZEXPORT gzopen OF((const char *, const char *));
-   ZEXTERN z_off_t ZEXPORT gzseek OF((gzFile, z_off_t, int));
-   ZEXTERN z_off_t ZEXPORT gztell OF((gzFile));
-   ZEXTERN z_off_t ZEXPORT gzoffset OF((gzFile));
-   ZEXTERN uLong ZEXPORT adler32_combine OF((uLong, uLong, z_off_t));
-   ZEXTERN uLong ZEXPORT crc32_combine OF((uLong, uLong, z_off_t));
-#endif
-
-/* hack for buggy compilers */
-#if !defined(ZUTIL_H) && !defined(NO_DUMMY_DECL)
-    struct internal_state {int dummy;};
-#endif
-
-/* undocumented functions */
-ZEXTERN const char   * ZEXPORT zError           OF((int));
-ZEXTERN int            ZEXPORT inflateSyncPoint OF((z_streamp));
-ZEXTERN const uLongf * ZEXPORT get_crc_table    OF((void));
-ZEXTERN int            ZEXPORT inflateUndermine OF((z_streamp, int));
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* ZLIB_H */
