#! /usr/bin/env perl

=begin COPYRIGHT

----------------------------------------------------------------------------

    Copyright (C) 2005-2018 Marc Penninga.

    This program is free software; you can redistribute it and/or
    modify it under the terms of the GNU General Public License
    as published by the Free Software Foundation, either version 2
    of the License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to
        Free Software Foundation, Inc.,
        59 Temple Place,
        Suite 330,
        Boston, MA 02111-1307,
        USA

----------------------------------------------------------------------------

=end COPYRIGHT

=cut

use strict;
use warnings;

use File::Path ();
use File::Spec ();
use Getopt::Long ();
use Pod::Usage ();

my ($d, $m, $y) = (localtime time)[3 .. 5];
my $TODAY = sprintf "%04d/%02d/%02d", $y + 1900, $m + 1, $d;

=begin Comment

    The next three tables map the names of weights, widths and shapes
    to NFSS codes. New entries can be added, but the names should be
    all lowercase. Also make sure that the NFSS 'series' attribute
    (the concatenation of weight and width) is unique!

    The 'book' and 'regular' weights and the 'regular' width are mapped
    to an empty string rather than 'm', because the 'm' disappears when
    weight and width are combined into the NFSS series (unless *both* are
    'regular', but we deal with that case separately).

=end Comment

=cut

my %FD_WEIGHT = (
    two             => '2',
    four            => '4',
    eight           => '8',
    hair            => 'a',
    thin            => 't',
    ultralight      => 'ul',
    extralight      => 'el',
    light           => 'l',
    book            => 'sl',
    regular         => '',
    medium          => 'mb',
    demibold        => 'db',
    demi            => 'db',
    semibold        => 'sb',
    bold            => 'b',
    extrabold       => 'eb',
    ultra           => 'ub',
    ultrabold       => 'ub',
    black           => 'k',
    extrablack      => 'ek',
    ultrablack      => 'uk',
    heavy           => 'h',
    poster          => 'r',
);

my %FD_WIDTH = (
    ultracompressed => 'up',
    extracompressed => 'ep',
    compressed      => 'p',
    comp            => 'p',
    cmp             => 'p',
    compact         => 'p',
    ultracondensed  => 'uc',
    extracondensed  => 'ec',
    condensed       => 'c',
    cond            => 'c',
    narrow          => 'n',
    semicondensed   => 'sc',
    regular         => '',
    semiextended    => 'sx',
    extended        => 'x',
    expanded        => 'e',
    wide            => 'w',
);

my %FD_SHAPE = (
    roman           => 'n',
    upright         => 'n',
    italic          => 'it',
    ita             => 'it',
    it              => 'it',
    cursive         => 'it',
    kursiv          => 'it',
    inclined        => 'sl',
    incline         => 'sl',
    oblique         => 'sl',
    slanted         => 'sl',
    slant           => 'sl',
    romani          => 'n',     # Adobe Silentium Pro has two roman shapes;
    romanii         => 'it',    # we map the second one to 'it'
);

=begin Comment

    The next table is used to generate extra DeclareFontShape rules in 
    the .fd files to map missing slanted shapes to italic or vice versa.

=end Comment

=cut

my %FD_SSUB = (
    sl      => 'it',
    scsl    => 'scit',
    tlsl    => 'tlit',
    it      => 'sl',
    scit    => 'scsl',
    tlit    => 'tlsl',
);

=begin Comment

    The %STYLE table is used in deciding which figure styles to generate. 
    Each figure style (lining, oldstyle, tabular, proportional, superior,
    inferior etc.) becomes a separate font family.

    Each key in this table names a figure style; the corresponding
    value is an anonymous hash with four key/value pairs:
        reqd    A list of required OpenType features;
                this style is built if the font supports *all* these features.
        nice    A list of optional OpenType features;
                these are used if the font supports them, but don't
                prevent this style from being built when missing.
        extra   Extra options passed to otftotfm when creating this style.
        shape   An anonymous array of 'variant' shapes to build with
                this figure style.
                
    The 'reqd' and 'nice' subtables for the TLF, LF, TOsF and OsF styles 
    are empty; these are filled in at run time, depending on
    which figure style is default for the current font.
    
    The 'reqd' subtable for the Inf style is also empty; this may be filled
    with either 'sinf' or 'subs' depending on the -inferiors options.

    Ornaments are treated as a separate 'figure style'.
    This may seem a bit weird, but that's the easiest way to handle them.

=end Comment

=cut

my %STYLE = (
    TLF => {
        reqd   => [],
        nice   => [],
        extra  => '',
        shapes => ['normal', 'smallcaps', 'swash', 'titling', 'textcomp'],
    },
    LF => {
        reqd   => [],
        nice   => [],
        extra  => '',
        shapes => ['normal', 'smallcaps', 'swash', 'titling', 'textcomp'],
    },
    TOsF => {
        reqd   => [],
        nice   => [],
        extra  => '',
        shapes => ['normal', 'smallcaps', 'swash', 'textcomp'],
    },
    OsF => {
        reqd   => [],
        nice   => [],
        extra  => '',
        shapes => ['normal', 'smallcaps', 'swash', 'textcomp'],
    },
    Sup => {
        reqd   => ['sups'],
        nice   => [],
        extra  => '--ligkern="* {KL} *"',
        shapes => ['normal'],
    },
    Inf => {
        reqd   => [],
        nice   => [],
        extra  => '--ligkern="* {KL} *"',
        shapes => ['normal'],
    },
    Numr => {
        reqd   => ['numr'],
        nice   => [],
        extra  => '--ligkern="* {KL} *"',
        shapes => ['normal'],
    },
    Dnom => {
        reqd   => ['dnom'],
        nice   => [],
        extra  => '--ligkern="* {KL} *"',
        shapes => ['normal'],
    },
    Orn => {
        reqd   => ['ornm'],
        nice   => [],
        extra  => '--ligkern="* {KL} *"',
        shapes => ['normal'],
    },
);

=begin Comment

    The %STYLE_DEFAULTS table is used to populate the 'reqd' and 'nice'
    subtables of the %STYLE table, depending on the default figure style
    for the current font. This is needed because some font families 
    provide only features for the non-default figure styles.
    
    We therefore make the OpenType features that correspond 
    to the default figure style 'nice' (optional), so that this figure style
    is always generated, even without OpenType features in the font;
    the other figure style are only generated when the corresponding
    features are present in the font.

=end Comment

=cut

my %STYLE_DEFAULTS = (
    lnum => 
        sub {
            push @{$STYLE{TLF}{nice}},  'lnum';
            push @{$STYLE{LF}{nice}},   'lnum';
            push @{$STYLE{TOsF}{reqd}}, 'onum';
            push @{$STYLE{OsF}{reqd}},  'onum';
        },
    onum => 
        sub {
            push @{$STYLE{TLF}{reqd}},  'lnum';
            push @{$STYLE{LF}{reqd}},   'lnum';
            push @{$STYLE{TOsF}{nice}}, 'onum';
            push @{$STYLE{OsF}{nice}},  'onum';
        },
    tnum => 
        sub {
            push @{$STYLE{TLF}{nice}},  'tnum';
            push @{$STYLE{TOsF}{nice}}, 'tnum';
            push @{$STYLE{LF}{reqd}},   'pnum';
            push @{$STYLE{OsF}{reqd}},  'pnum';
        },
    pnum => 
        sub {
            push @{$STYLE{TLF}{reqd}},  'tnum';
            push @{$STYLE{TOsF}{reqd}}, 'tnum';
            push @{$STYLE{LF}{nice}},   'pnum';
            push @{$STYLE{OsF}{nice}},  'pnum';
        },
);

=begin Comment

    The %SHAPE table is used in deciding which font shapes 
    (normal, small caps, swash, titling or textcomp) to generate.

    Each key in this table names a shape; the corresponding value
    is an anonymous hash with several key/value pairs:
        code    An anonymous hash with three possible keys:
                'n'  -> the NFSS code to use for this variant shape
                        if the 'basic shape' is upright;
                'it' -> the NFSS code to use for this variant shape
                        if the 'basic shape' is italic
                'sl' -> the NFSS code to use for this variant shape
                        if the 'basic shape' is slanted (aka oblique);
                If any entry is missing, the corresponding version 
                of this variant shape will not be built.
        reqd    A list of required OpenType features;
                this shape is built if the font supports at least *one*
                of these features.
        nice    A list of optional OpenType features;
                these are used if the font supports them, but don't
                prevent this shape from being built when missing.
        extra   Extra options passed to otftotfm when creating this shape.
        name    A string added to the name of the generated font,
                to make it unique.
    
    Textcomp is treated as a 'shape' even though it is technically 
    an encoding; that is just the easiest way to do things.

=end Comment

=cut

my %SHAPE = (
    normal => {
        code  => { n => 'n', it => 'it', sl => 'sl' },
        reqd  => [],
        nice  => ['kern', 'liga'],
        extra => '',
        name  => '',
    },
    smallcaps => {
        code  => { n => 'sc', it => 'scit', sl => 'scsl' },
        reqd  => ['smcp'],
        nice  => ['kern', 'liga'],
        extra => '--unicoding="germandbls =: SSsmall"',
        name  => 'sc',
    },
    # '--feature=aalt' is in 'extra' instead of 'nice' because 'extra'
    # comes last in the command line; else 'aalt' might be overridden
    swash => {
        code  => { n => 'nw', it => 'sw' },
        reqd  => ['swsh', 'dlig'],
        nice  => ['kern', 'liga'],
        extra => '--include-alternates="*.swash" --feature=aalt',
        name  => 'swash',
    },
    titling => {
        code  => { n => 'tl', it => 'tlit', sl => 'tlsl' },
        reqd  => ['titl', 'case', 'cpsp'],
        nice  => ['kern', 'liga'],
        extra => '',
        name  => 'titling',
    },
    textcomp => {
        code  => { n => 'n', it => 'it', sl => 'sl' },
        reqd  => [],
        nice  => ['onum'],
        extra => '',
        name  => '',
    },
);


############################################################################


sub main {
    ARGV::parse_options();

    my @fonts = map { Fontinfo::parse_fontinfo($_) } @ARGV;
    Fontinfo::assert_unique(@fonts);

    # For each font, figure out the styles, shapes and encodings to generate
    my @worklist
        = cleanup(expand_encodings(expand_shapes(expand_styles(@fonts))));

    # Organize the worklist by family, encoding, style, series and shape
    my %fddata;
    for my $item (@worklist) {
        my $family   = $item->{font}{family};
        my $encoding = $item->{encoding}[1];
        my $style    = $item->{style};
        my $series   = $item->{font}{fdseries};
        my $shape    = $item->{fdshape};
        my $minsize  = $item->{font}{minsize};
        my $maxsize  = $item->{font}{maxsize};

        push @{$fddata{$family}{$encoding}{$style}{$series}{$shape}},
             [ $minsize, $maxsize, $item->{fontname} ];
    }
    
    create_logfile(@worklist);

    if (!$ARGV{dryrun}) {
        # Create the LaTeX support files
        while (my ($fam, $famdata) = each %fddata) {
            LaTeX::write_stylefile($fam, $famdata);
            while (my ($enc, $encdata) = each %$famdata) {
                while (my ($sty, $stydata) = each %$encdata) {
                    LaTeX::write_fdfile($fam, $enc, $sty, $stydata);
                }
            }
        }

        # Create (and execute) commands for otftotfm
        make_commands(@worklist);
    }

    return;
}

#-----------------------------------------------------------------------
# Determine which figure styles to create for each font;
# return a list of (font, style) tuples
#-----------------------------------------------------------------------
sub expand_styles {
    return map { my $font = $_;
                 map { { font => $font, style => $_ } }
                     grep { has_reqd_style($font, $STYLE{$_}) }
                          keys %STYLE
               }
               @_;
}

#-----------------------------------------------------------------------
# Check if $font has all features mentioned in the 'reqd' subtable of $target
#-----------------------------------------------------------------------
sub has_reqd_style {
    my ($font, $target) = @_;

    return 0 unless defined $target;
    for my $prereq (@{$target->{reqd}}) {
        return 0 if !$font->{feature}{$prereq};
    }
    return 1;
}

#-----------------------------------------------------------------------
# Determine which shapes to create for each (font, style) combination;
# return a list of (font, style, shape) tuples
#-----------------------------------------------------------------------
sub expand_shapes {
    return map { my ($font, $style) = @{$_}{qw(font style)};
                 map { { font => $font, style => $style, shape => $_ } }
                     grep { has_reqd_shape($font, $SHAPE{$_}) }
                          @{$STYLE{$style}{shapes}};
               }
               @_;
}

#-----------------------------------------------------------------------
# Check if $font has at least one of the features mentioned in the
# 'reqd' subtable of $target
#-----------------------------------------------------------------------
sub has_reqd_shape {
    my ($font, $target) = @_;

    return 0 unless defined $target->{code}{$font->{basicshape}};
    return 1 unless @{$target->{reqd}};
    return grep { $font->{feature}{$_} } @{$target->{reqd}};
}

#-----------------------------------------------------------------------
# Determine which encodings to use for each (font, style, shape) combi;
# return a list of (font, style, shape, encoding) tuples
#-----------------------------------------------------------------------
sub expand_encodings {
    return
        map { my ($font, $style, $shape) = @{$_}{qw(font style shape)};
              my @encodings
                  = $shape eq 'textcomp' ? (['fontools_ts1', 'ts1'])
                  : $style eq 'Orn'      ? ([Fontinfo::get_orn($font), 'u'])
                  : map { [lc $_, lc $_] } @{$ARGV{encoding}}
                  ;
              map {  { font     => $font,
                       style    => $style,
                       shape    => $shape,
                       encoding => $_,
                     }
                  }
                  @encodings;
            }
            @_;
}

#-----------------------------------------------------------------------
# Add some finishing touches to the work list
#-----------------------------------------------------------------------
sub cleanup {
    my @worklist = @_;

    for my $item (@worklist) {
        my ($font, $style, $shape, $encoding)
            = @{$item}{qw(font style shape encoding)};

        # generate unique name for this font
        $item->{fontname} = join '-', grep { $_ } $font->{name},
                                                  lc $style,
                                                  lc $SHAPE{$shape}{name},
                                                  lc $encoding->[1];

        # look up NFSS code for font's shape
        $item->{fdshape} = $SHAPE{$shape}{code}{$font->{basicshape}};

        # compile list of OpenType features to use with this font
        my %feature = map { ($_ => 1) }
                          grep { $font->{feature}{$_} }
                               ( @{$STYLE{$style}{reqd}},
                                 @{$STYLE{$style}{nice}},
                                 @{$SHAPE{$shape}{reqd}},
                                 @{$SHAPE{$shape}{nice}},
                               );
        if ($feature{lnum} && $feature{onum}) {
            delete $feature{lnum};
        }
        $item->{features} = [ sort keys %feature ];

        # add finishing touches to name and NFSS code of encoding
        $item->{encoding}[0] =~ s/\A (ot1|t1|ly1) \z/fontools_$1/xms;
        $item->{encoding}[1] = uc $item->{encoding}[1];
        
        $item->{cmdline} = make_cmdline($item);
    }

    return @worklist;
}

#-----------------------------------------------------------------------
# Dump all relevant info to the logfile
#-----------------------------------------------------------------------
sub create_logfile {
    my @worklist
        = sort { $a->{font}{filename} cmp $b->{font}{filename}
                    || $a->{encoding}[1] cmp $b->{encoding}[1]
                    || $a->{style} cmp $b->{style}
               } @_;
               
    open my $LOG, '>', $ARGV{logfile}
        or die "$0: cannot create $ARGV{logfile}: $!";

    print {$LOG} <<"END_ARGUMENTS";

$ARGV{cmdline}


****************************************************************************


I'm using the following options:

    encoding(s):        @{[ join ', ', @{$ARGV{encoding}} ]}
    NFSS:               $ARGV{nfss} @{[ $ARGV{nfss} eq 'rm' ? '(serif)'
                                      : $ARGV{nfss} eq 'sf' ? '(sanserif)'
                                      : $ARGV{nfss} eq 'tt' ? '(typewriter)'
                                      :                       '(unknown)'
                                    ]}

    lining:             @{[ $ARGV{lining}       ? 'yes' : 'no' ]}
    oldstyle:           @{[ $ARGV{oldstyle}     ? 'yes' : 'no' ]}
    proportional:       @{[ $ARGV{proportional} ? 'yes' : 'no' ]}
    tabular:            @{[ $ARGV{tabular}      ? 'yes' : 'no' ]}
    ts1:                @{[ $SHAPE{textcomp}    ? 'yes' : 'no' ]}
    smallcaps:          @{[ $ARGV{smallcaps}    ? 'yes' : 'no' ]}
    swash:              @{[ $ARGV{swash}        ? 'yes' : 'no' ]}
    titling:            @{[ $ARGV{titling}      ? 'yes' : 'no' ]}
    superiors:          @{[ $ARGV{superiors}    ? 'yes' : 'no' ]}
    inferiors:          $ARGV{inferiors}
    ornaments:          @{[ $ARGV{ornaments}    ? 'yes' : 'no' ]}
    fractions:          @{[ $ARGV{fractions}    ? 'yes' : 'no' ]}

    dry run/real:       @{[ $ARGV{dryrun}       ? 'dry run'   : 'real'   ]}
    auto/manual:        @{[ $ARGV{manual}       ? 'manual'    : 'auto'   ]}
    target:             $ARGV{target}
    extra:              @{[ $ARGV{extra} || '<empty>' ]}

    figurekern:         @{[ $ARGV{figurekern}   ? 'no action' : 'remove' ]}
    

    font files:
        @{[ join "\n        ", @ARGV ]}

END_ARGUMENTS

    my ($prevfn, $prevsty, $prevenc) = ('') x 3;
    my @cmds;
    for my $item (@worklist) {
        if ($prevfn ne $item->{font}{filename}) {
            push @cmds, "\n" . '*' x 76;
            print {$LOG} <<"END_FONTINFO";


****************************************************************************


$item->{font}{filename}
        Name:       $item->{font}{name}
        Family:     $item->{font}{family}
        Subfamily:  $item->{font}{subfamily}
        Width:      $item->{font}{width}
        Weight:     $item->{font}{weight}
        Shape:      $item->{font}{shape}
        Size:       $item->{font}{minsize}-$item->{font}{maxsize}
        Features:   @{[ join ', ', sort keys %{$item->{font}{feature}} ]}
        
        
Generating these encodings, figure styles and shapes:

    ENC     STYLE   SHAPE   FEATURES USED
    --------------------------------------------------------------------
END_FONTINFO
        }
        if ($prevenc ne $item->{encoding}[1]
            || $prevsty ne $item->{style}) {
            print {$LOG} "\n";
        }
        printf {$LOG} "    %-3s     %-4s    %-4s    %s\n",
                            $item->{encoding}[1],
                            $item->{style},
                            $item->{fdshape},
                            join(', ', @{$item->{features}}),
                            ;
        $prevfn  = $item->{font}{filename};
        $prevsty = $item->{style};
        $prevenc = $item->{encoding}[1];
        
        push @cmds, $item->{cmdline};
    }
    
    print {$LOG} join "\n\n", @cmds;
    print {$LOG} "\n";
    close $LOG;
}

#-----------------------------------------------------------------------
# Generate all otftotfm commands, and either save or execute them
#-----------------------------------------------------------------------
sub make_commands {
    my @worklist = @_;

    my @commands = map { $_->{cmdline} } @worklist;

    # make sure the last command *does* call updmap
    $commands[-1] =~ s/--no-updmap//xms if $ARGV{updmap};

    if ($ARGV{manual}) {
        open my $BAT, '>', 'autoinst.bat'
            or die "[ERROR] Can't create 'autoinst.bat': $!";
        print {$BAT} "$_\n" for @commands;
        close $BAT;
    }
    else {
        if (grep { system $_ } @commands) {
            warn "[WARNING] 'otftotfm' returned non-zero; something's wrong!\n";
        }
    }

    return;
}

# The official names for various coding schemes
my %SCHEME = (
    fontools_ly1 => 'TEX TYPEWRITER AND WINDOWS ANSI',
    fontools_t1  => 'EXTENDED TEX FONT ENCODING - LATIN',
    fontools_ot1 => 'TEX TEXT',
    fontools_ts1 => 'TEX TEXT COMPANION SYMBOLS 1---TS1',
);

#-----------------------------------------------------------------------
# Generate a command line for otftotfm
#-----------------------------------------------------------------------
sub make_cmdline {
    my $item = shift;

    return join ' ', 'otftotfm',
                     ($ARGV{manual} ? '--pl' : '--automatic'),
                     "--encoding=$item->{encoding}[0]",
                     set_targetdirs($item->{font}{family}),
                     '--no-updmap',
                     ($item->{font}{filename} =~ m/[.]ttf\z/xms
                        ? '--no-type1'
                        : ''),
                     ($SCHEME{$item->{encoding}[0]}
                        ? qq(--coding-scheme="$SCHEME{$item->{encoding}[0]}")
                        : ''),
                     (map { "--feature=$_" } @{$item->{features}}),
                     ((grep { $_ eq 'liga' } @{$item->{features}})
                        ? ''
                        : ( '--ligkern="f i =: fi"',
                            '--ligkern="f l =: fl"',
                            '--ligkern="f f =: ff"',
                            '--ligkern="ff i =: ffi"',
                            '--ligkern="ff l =: ffl"' )),
                     $STYLE{$item->{style}}{extra},
                     $SHAPE{$item->{shape}}{extra},
                     $ARGV{extra},
                     qq("$item->{font}{filename}"),
                     $item->{fontname},
                     ;
}

#-----------------------------------------------------------------------
# Return a string with all "directory" options for otftotfm set
#-----------------------------------------------------------------------
my @FILETYPES = qw(tfm vf type1 truetype);

sub set_targetdirs {
    my $family = shift;

    my %dir = map { ($_ => File::Spec->catdir(
                        $ARGV{target},
                        'fonts',
                        $_,
                        $ARGV{vendor},
                        $ARGV{typeface} || $family))
                  }
                  @FILETYPES;

    $dir{$_} = File::Spec->catdir(
            $ARGV{target}, 'fonts', $_, 'dvips', $ARGV{typeface} || $family)
        for qw(enc map);

    File::Path::make_path(values %dir) unless $ARGV{dryrun};

    my $result = join ' ', map { "--${_}-directory=$dir{$_}" } @FILETYPES;
    $result .= " --encoding-directory=$dir{enc} --map-file="
                . File::Spec->catfile($dir{map}, "${family}.map");

    return $result;
}


############################################################################


package ARGV;

my $USAGE =<<'END_USAGE';

'autoinst' is a wrapper around Eddie Kohler's TypeTools
(http://www.lcdf.org/type/), for installing OpenType fonts in LaTeX.

Usage: autoinst [options] font[s]

Possible options:
    -encoding=ENC[,ENC]*    Specify text encoding(s) (default: OT1,T1,LY1)

    -(no)lining             Toggle creation of lining digits
    -(no)oldstyle           Toggle creation of oldstyle digits
    -(no)proportional       Toggle creation of proportional digits
    -(no)tabular            Toggle creation of tabular digits
    -(no)ts1                Toggle creation of TS1 fonts
    -(no)smallcaps          Toggle creation of smallcaps shape
    -(no)swash              Toggle creation of swash shape
    -(no)titling            Toggle creation of titling shape
    -(no)superiors          Toggle creation of fonts with superior characters
    -inferiors=[sinf|subs]  Use this style for subscripts (see docs)
    -(no)ornaments          Toggle creation of ornament fonts
    -(no)fractions          Toggle creation of fonts with digits for fractions

    -sanserif               Install font as sanserif font
    -typewriter             Install font as typewriter font
    
    -defaultlining
    -defaultoldstyle        Specify which figure style should be
    -defaulttabular             considered 'default' for this font; see docs
    -defaultproportional    
    
    -extra="TEXT"           Add TEXT to the command for 'otftotfm'
    -target="DIRECTORY"     Install files into specified TEXMF tree
    -vendor="VENDOR"        Only used for naming directories
    -typeface="TYPEFACE"    Only used for naming directories
    -(no)updmap             Toggle running of updmap
    -manual                 Manual mode (see documentation)

    -(no)figurekern         Keep or remove kerns between tabular figures

    -help                   Print this text and exit
    -doc                    Print the complete documentation and exit
    -dryrun                 Don't generate fonts, only log what would be done

    font[s]                 The fonts (.otf or .ttf format) to install.

Please report any bugs or suggestions to <marcpenninga@gmail.com>.
END_USAGE

# Default values for the command-line arguments
%ARGV = (
    encoding     => 'OT1,T1,LY1',
    textcomp     => '2',     # 0 = no, 1 = yes, 2 = (enc eq 'T1' ? yes : no)
    lining       => '1',     # 0 = no, 1 = yes
    oldstyle     => '1',     # 0 = no, 1 = yes
    proportional => '1',     # 0 = no, 1 = yes
    tabular      => '1',     # 0 = no, 1 = yes
    smallcaps    => '1',     # 0 = no, 1 = yes
    swash        => '1',     # 0 = no, 1 = yes
    titling      => '1',     # 0 = no, 1 = yes
    superiors    => '1',     # 0 = no, 1 = yes
    inferiors    => '',      # possible values: '', 'sinf', 'subs', 'dnom'
    ornaments    => '1',     # 0 = no, 1 = yes
    fractions    => '0',     # 0 = no, 1 = yes
    nfss         => 'rm',
    fig_height   => 'lnum',
    fig_width    => 'tnum',
    extra        => '',
    target       => '',
    vendor       => 'lcdftools',
    typeface     => '',
    updmap       => '1',     # 0 = no, 1 = yes
    manual       => '0',     # 0 = no, 1 = yes
    dryrun       => '0',     # 0 = no, 1 = yes
    logfile      => 'autoinst.log',
    figurekern   => '1',     # 0 = no, 1 = yes
);

#-----------------------------------------------------------------------
# Process command-line arguments
#-----------------------------------------------------------------------
sub parse_options {
    $ARGV{cmdline} = join ' ', ($0, @ARGV);

    Getopt::Long::GetOptions(
        'help|?'              =>  sub { print $USAGE; exit; },
        'doc'                 =>  sub { Pod::Usage::pod2usage(-verbose => 2); },
        'encoding=s'          => \$ARGV{encoding},
        'ts1!'                => \$ARGV{textcomp},
        'lining!'             => \$ARGV{lining},
        'oldstyle!'           => \$ARGV{oldstyle},
        'proportional!'       => \$ARGV{proportional},
        'tabular!'            => \$ARGV{tabular},
        'smallcaps!'          => \$ARGV{smallcaps},
        'swash!'              => \$ARGV{swash},
        'titling!'            => \$ARGV{titling},
        'superiors!'          => \$ARGV{superiors},
        'inferiors=s'         => \$ARGV{inferiors},
        'ornaments!'          => \$ARGV{ornaments},
        'fractions!'          => \$ARGV{fractions},
        'sanserif'            =>  sub { $ARGV{nfss} = 'sf' },
        'typewriter'          =>  sub { $ARGV{nfss} = 'tt' },
        'defaultlining'       =>  sub { $ARGV{fig_height} = 'lnum' },
        'defaultoldstyle'     =>  sub { $ARGV{fig_height} = 'onum' },
        'defaulttabular'      =>  sub { $ARGV{fig_width}  = 'tnum' },
        'defaultproportional' =>  sub { $ARGV{fig_width}  = 'pnum' },
        'extra=s'             => \$ARGV{extra},
        'target=s'            => \$ARGV{target},
        'vendor=s'            => \$ARGV{vendor},
        'typeface=s'          => \$ARGV{typeface},
        'updmap!'             => \$ARGV{updmap},
        'dryrun'              => \$ARGV{dryrun},
        'manual'              => \$ARGV{manual},
        'figurekern!'         => \$ARGV{figurekern},
        'verbose+'            => sub {},
    )
    or die "$USAGE";

    die "$USAGE" unless @ARGV;

    delete $SHAPE{smallcaps}     unless $ARGV{smallcaps};
    delete $SHAPE{swash}         unless $ARGV{swash};
    delete $SHAPE{titling}       unless $ARGV{titling};

    delete $STYLE{Sup}           unless $ARGV{superiors};
    delete $STYLE{Orn}           unless $ARGV{ornaments};
    delete @STYLE{qw(Numr Dnom)} unless $ARGV{fractions};
    if    ($ARGV{inferiors} eq 'sinf') { $STYLE{Inf}{reqd} = ['sinf'] }
    elsif ($ARGV{inferiors} eq 'subs') { $STYLE{Inf}{reqd} = ['subs'] }
    elsif ($ARGV{inferiors} eq 'dnom') { $STYLE{Inf}{reqd} = ['dnom'] }
    else  { 
        warn "[WARNING] unknown value -inferiors=$ARGV{inferiors} ignored!\n"
            if $ARGV{inferiors};
        $ARGV{inferiors} = 'no'; 
        delete $STYLE{Inf} 
    }

    $ARGV{encoding} =~ s/\s+//xmsg;
    my @textencodings = grep { $_ ne 'TS1' }
                             map { uc }
                                 split /,/, $ARGV{encoding};
    $ARGV{encoding} = \@textencodings;

    # TS1-encoded fonts are generated if:
    # - the user explicitly asked for TS1, or
    # - the text encodings contain T1 and the user didn't turn off TS1
    unless ( (grep { $_ eq 'T1' } @{$ARGV{encoding}} and $ARGV{textcomp})
             or $ARGV{textcomp} == 1 )
    {
        delete $SHAPE{textcomp};
    }

    # Fix the %STYLE table to take 'default' figure styles into account.
    $STYLE_DEFAULTS{$ARGV{fig_height}}();
    $STYLE_DEFAULTS{$ARGV{fig_width}}();

    delete @STYLE{qw(LF TLF)}    unless $ARGV{lining};
    delete @STYLE{qw(OsF TOsF)}  unless $ARGV{oldstyle};
    delete @STYLE{qw(LF OsF)}    unless $ARGV{proportional};
    delete @STYLE{qw(TLF TOsF)}  unless $ARGV{tabular};

    if ($ARGV{manual}) {
        warn "[WARNING] option '-target' overridden by '-manual'!\n"
            if $ARGV{target};
        $ARGV{target} = File::Spec->curdir();
    }
    elsif (not $ARGV{target}) {
        my @dirs = grep { -w $_ }
                        map { split m/:/xms, substr $_, 0, -1 }
                            ( `kpsewhich --expand-path='\$TEXMFLOCAL'`,
                              `kpsewhich --expand-path='\$TEXMFHOME'`, );
        $ARGV{target} = $dirs[0] || File::Spec->curdir();
    }

    if (!$ARGV{figurekern}) {
        my @digits = qw(zero one two three four five six seven eight nine);
        my $tkern
            = join ' ', map { my $left = $_;
                              map { qq(--ligkern="$left {} $_") } @digits
                            }
                            @digits;

        $STYLE{TLF}{extra}  = $tkern;
        $STYLE{TOsF}{extra} = $tkern;
    }
}


############################################################################


package Fontinfo;

#-----------------------------------------------------------------------
# Return ref to hash with all relevant info about this font
#-----------------------------------------------------------------------
sub parse_fontinfo {
    my ($filename) = @_;

    my $info = {
        filename  => $filename,
        width     => 'regular',
        weight    => 'regular',
        shape     => 'roman',
        minsize   => 0,
        maxsize   => 0,
    };

    parse_basicinfo($info);
    parse_sizeinfo($info);
    parse_features($info);

    return $info;
}

# table for converting digits in font names to text (safer for LaTeX)
my @DIGITS = qw(Zero One Two Three Four Five Six Seven Eight Nine);

#-----------------------------------------------------------------------
# Get some basic info (family, weight, width, shape) about this font
#-----------------------------------------------------------------------
sub parse_basicinfo {
    my $info = shift;

    open my $otfinfo, '-|', qq(otfinfo --info "$info->{filename}")
        or die "[ERROR] 'otfinfo --info $info->{filename}' failed";
    my %data = map { my ($k,$v) = m/\A\s* ([^:]+?) \s*:\s* ([^\r\n]+)/xms;
                     $k =~ s/\s+//xmsg;
                     $v =~ s/\s+//xmsg;
                     (lc $k => $v);
                   }
                   grep { m/\A\s* [^:]+? \s*:\s* [^\r\n]+/xms } <$otfinfo>;
    close $otfinfo;

    $data{family}    =  $data{preferredfamily} || $data{family};
    $data{subfamily} =  $data{preferredsubfamily} || $data{subfamily};
    $data{fullname}  =~ s/\A$data{family}//xms;
    $data{fullname}  =  lc $data{fullname};

    # clean up family name (it's used in LaTeX command names)
    $data{family}    =~ s/\A(?: Adobe | ITC | LT | MT)//xms;
    $data{family}    =~ s/(\d)/$DIGITS[$1]/xmsge;
    $data{family}    =~ s/[^A-Za-z]+//xmsg;
    
    my $fullinfo =  lc "$data{subfamily} | $data{fullname}";
    
    for my $width (mqrs(keys %FD_WIDTH)) {
        if ($fullinfo =~ s/${width}//xmsi) {
            $info->{width} = $width;
            last;
        }
    }

    for my $weight (mqrs(keys %FD_WEIGHT)) {
        if ($fullinfo =~ s/${weight}//xmsi) {
            $info->{weight} = $weight;
            last;
        }
    }

    for my $shape (mqrs(keys %FD_SHAPE)) {
        if ($fullinfo =~ s/${shape}//xmsi) {
            $info->{shape} = $shape;
            last;
        }
    }

    # If font data parsing fails, we may end up with several fonts
    # having the same values for all NFSS parameters.
    # In that case, we divide the family into subfamilies and try again;
    # hopefully, the NFSS paramaters in each subfamily will be unique.
    # In many font families, each font is in a subfamily of its own;
    # the 'subfamily'-strategy would then lead to a proliferation of
    # subfamilies. To avoid this, we remove width, weight and shape 
    # from the font's 'subfamily' value.
    my $subst;
    $subst = join '|', 
                  mqrs(grep { $FD_WIDTH{$_} eq $FD_WIDTH{$info->{width}} } 
                            keys %FD_WIDTH);
    $data{subfamily} =~ s/$subst//xmsi;

    $subst = join '|', 
                  mqrs(grep { $FD_WEIGHT{$_} eq $FD_WEIGHT{$info->{weight}} } 
                            keys %FD_WEIGHT);
    $data{subfamily} =~ s/$subst//xmsi;

    $subst = join '|', 
                  mqrs(grep { $FD_SHAPE{$_} eq $FD_SHAPE{$info->{shape}} } 
                            keys %FD_SHAPE);
    $data{subfamily} =~ s/$subst//xmsi;
    

    $info->{name}      = $data{postscriptname};
    $info->{family}    = $data{family};
    $info->{subfamily} = $data{subfamily};

    $info->{basicshape} = $FD_SHAPE{$info->{shape}};
    $info->{fdseries}
        = ($FD_WEIGHT{$info->{weight}} . $FD_WIDTH{$info->{width}}) || 'm';

    return $info;
}

#-----------------------------------------------------------------------
# When matching against data, try longer strings before shorter ones
#-----------------------------------------------------------------------
sub mqrs {
    return map { quotemeta } reverse sort { length($a) <=> length($b) } @_;
}

#-----------------------------------------------------------------------
# Get all features this font supports
#-----------------------------------------------------------------------
sub parse_features {
    my $info = shift;

    open my $otfinfo, '-|', qq(otfinfo --features "$info->{filename}")
        or die "[ERROR] 'otfinfo --features $info->{filename}' failed";
    %{$info->{feature}} = map { (substr($_, 0, 4) => 1) } <$otfinfo>;
    close $otfinfo;

    open $otfinfo, '-|', qq(otfinfo --tables "$info->{filename}")
        or die "[ERROR] 'otfinfo --tables $info->{filename}' failed";
    $info->{feature}{kern} = 1 if grep { m/\d+ \s+ kern/xms } <$otfinfo>;
    close $otfinfo;

    return $info;
}

#-----------------------------------------------------------------------
# Get the optical sizes for this font
#-----------------------------------------------------------------------
sub parse_sizeinfo {
    my $info = shift;

    open my $otfinfo, '-|', qq(otfinfo --optical-size "$info->{filename}")
        or die "[ERROR] 'otfinfo --optical-size $info->{filename}' failed";

    if (my ($minsize, $maxsize) = <$otfinfo> =~ m/[(] ([\d.]+) \s* pt, \s*
                                              ([\d.]+) \s* pt  \s* []]/xms )
    {
    # fix some known bugs
        if ($info->{name} eq 'GaramondPremrPro-It'
            && $minsize == 6 && $maxsize == 8.9)
        {
            ($minsize, $maxsize) = (8.9, 14.9);
        }
        elsif ($info->{family} eq 'KeplerStd'
            && $info->{subfamily} =~ m/Caption/xms
            && $minsize == 8.9 && $maxsize == 13.9)
        {
            ($minsize, $maxsize) = (6, 8.9);
        }
        elsif ($info->{family} eq 'KeplerStd'
            && $info->{subfamily} =~ m/Subhead/xms
            && $minsize == 8.9 && $maxsize == 13.9)
        {
            ($minsize, $maxsize) = (13.9, 23);
        }
        elsif ($info->{family} eq 'KeplerStd'
            && $info->{subfamily} =~ m/Display/xms
            && $minsize == 8.9 && $maxsize == 13.9)
        {
            ($minsize, $maxsize) = (23, 72);
        }

        @{$info}{qw(minsize maxsize)} = ($minsize, $maxsize);
    }
    close $otfinfo;

    return $info;
}


# Error messages, used in assert_unique()
my $WARN_PARSE =<<'END_WARN_PARSE';
[WARNING] I failed to parse all fonts in a unique way, so I will split
          your font family into multiple subfamilies and try again:

              %s

          Please check the output!

END_WARN_PARSE

my $ERR_PARSE =<<'END_ERR_PARSE';
[ERROR] I failed to parse all fonts in a unique way;
        presumably some fonts have unusual widths, weights or shapes.

        Try one of the following:
        -   Run 'autoinst' on a smaller set of fonts,
            omitting the ones that weren't parsed correctly;
        -   Add the missing widths, weights or shapes to the tables
            '%FD_WIDTH', '%FD_WEIGHT' or '%FD_SHAPE' near the top
            of the source code;

        Please also send a bug report to the author.

END_ERR_PARSE

my $ERR_DETAIL =<<'END_ERR_DETAIL';
[ERROR] I've parsed both %s
                     and %s as

        Family:     %s
        Weight:     %s
        Width:      %s
        Shape:      %s
        Size:       %s-%s

END_ERR_DETAIL

#-----------------------------------------------------------------------
# Assert all font infos are unique
#-----------------------------------------------------------------------
sub assert_unique {
    my @fonts = @_;

    # These attributes should uniquely identify each font
    my @attributes = qw(family weight width shape minsize maxsize);

    ATTEMPT:
    for my $attempt (1 .. 2) {
        my (%seen, $err_details);
        for my $font (@fonts) {
            my $key
                = join "\x00",
                       @{$font}{ @attributes };

            if ($seen{$key}) {
                $err_details .= sprintf $ERR_DETAIL,
                                        $seen{$key}{filename},
                                        $font->{filename},
                                        @{$font}{ @attributes };
            }
            else {
                $seen{$key} = $font;
            }
        }

        # If the font infos aren't unique, 
        # append 'Subfamily' to 'Family' and try again
        if ($err_details) {
            if ($attempt == 1) {
                $err_details =~ s/\[ERROR\]/[WARNING]/xmsg;
                warn $err_details;

                for my $font (@fonts) {
                    $font->{family} .= $font->{subfamily};
                }

                my @subfamilies
                    = sort keys %{{ map { ($_->{family} => 1) } @fonts }};
                warn sprintf $WARN_PARSE, join ', ', @subfamilies;

                next ATTEMPT;
            }
            else {
                die $err_details, $ERR_PARSE;
            }
        }

        last ATTEMPT;
    }

    return 1;
}

#-----------------------------------------------------------------------
# Generate (font-specific) encoding vector for ornament glyphs
#-----------------------------------------------------------------------
sub get_orn {
    my ($font) = @_;

    my $fontfile = $font->{filename};
    my $enc_name = $font->{family} . '_orn';

    if (not -e "$enc_name.enc") {
        # Default ornament names: 'orn.' plus three digits
        my @encoding = map { sprintf "orn.%03d", $_ } 1 .. 256;

        open my $OTFINFO, '-|', qq(otfinfo --glyphs "$font->{filename}")
            or die "[ERROR] 'otfinfo --glyphs $font->{filename}' failed";
        chop(my @glyphnames = <$OTFINFO>);
        close $OTFINFO;

        # Test for some known alternative names (probably not exhaustive)
        my @ornaments
            = sort grep { m/\A (?: orn|u2022[.]|word[.]|hand|bullet[.])
                            | [.]orn \z/xms
                        }
                        @glyphnames;

        @encoding[0 .. $#ornaments] = @ornaments;

        open my $ORN, '>', "$enc_name.enc"
            or die "[ERROR] Can't create '$enc_name.enc': $!";

        print {$ORN} "/$font->{family}OrnamentEncoding [\n";
        map { print {$ORN} "    /$_\n" } @encoding[0 .. 255];
        print {$ORN} "] def\n";
        close $ORN;
    }

    return $enc_name;
}


############################################################################


package LaTeX;

#-----------------------------------------------------------------------
# Create a style file for LaTeX
#-----------------------------------------------------------------------
sub write_stylefile {
    my ($fam, $data) = @_;

    my %seen = %{ get_keys($data) };

    my $fn = sprintf "%s.sty", $fam;
    my $dir = File::Spec->catdir(
        $ARGV{target}, 'tex', 'latex', $ARGV{typeface} || $fam);
    File::Path::make_path($dir);
    $fn = File::Spec->catfile($dir, $fn);
    open my $STY, '>', $fn or die "[ERROR] Can't create '$fn': $!";

    print {$STY} <<"END_STY_HEADER";
%% Generated by autoinst on $TODAY
%%
\\NeedsTeXFormat{LaTeX2e}
\\ProvidesPackage{$fam}
    [$TODAY (autoinst)  Style file for $fam.]

END_STY_HEADER

    my $enc = join ',', grep { $_ ne 'OT1' } @{$ARGV{encoding}};

    print {$STY} "\\RequirePackage[$enc]{fontenc}\n" if $enc;
    print {$STY} "\\RequirePackage{textcomp}\n" if $seen{TS1};

    print {$STY} <<'END_STY_FONTAXES_START';
\IfFileExists{mweights.sty}{\RequirePackage{mweights}}{}
\IfFileExists{fontaxes.sty}{
    \RequirePackage{fontaxes}
END_STY_FONTAXES_START

        if ($seen{tl} or $seen{tlit}) {
        print {$STY} <<'END_STY_FONTAXES_TL';
    \providecommand{\tldefault}{tl}
    \DeclareRobustCommand\tlshape{\not@math@alphabet\tlshape\relax
        \fontsecondaryshape\tldefault\selectfont}
    \DeclareTextFontCommand{\texttl}{\tlshape}
    \let\texttitling\texttl
    \fa@naming@exception{shape}{{n}{tl}}{tl}
    \fa@naming@exception{shape}{{it}{tl}}{tlit}
    \fa@naming@exception{shape}{{sl}{tl}}{tlsl}

END_STY_FONTAXES_TL
    }

    if ($seen{nw} or $seen{sw}) {
        print {$STY} <<'END_STY_FONTAXES_SW';
    \DeclareRobustCommand\swshape{\not@math@alphabet\swshape\relax
        \fontprimaryshape\itdefault\fontsecondaryshape\swdefault\selectfont}
    \fa@naming@exception{shape}{{n}{sw}}{nw}
    \fa@naming@exception{shape}{{it}{sw}}{sw}

END_STY_FONTAXES_SW
    }

    if ($seen{Sup}) {
        print {$STY} <<'END_STY_FONTAXES_SUP';
    \fa@naming@exception{figures}{{superior}{proportional}}{Sup}
    \fa@naming@exception{figures}{{superior}{tabular}}{Sup}
    \def\sufigures{\@nomath\sufigures
        \fontfigurestyle{superior}\selectfont}
    \DeclareTextFontCommand{\textsu}{\sufigures}
    \let\textsuperior\textsu

END_STY_FONTAXES_SUP
    }

    if ($seen{Inf}) {
        print {$STY} <<'END_STY_FONTAXES_INF';
    \fa@naming@exception{figures}{{inferior}{proportional}}{Inf}
    \fa@naming@exception{figures}{{inferior}{tabular}}{Inf}
    \def\infigures{\@nomath\infigures
        \fontfigurestyle{inferior}\selectfont}
    \DeclareTextFontCommand{\textin}{\infigures}
    \let\textinferior\textin

END_STY_FONTAXES_INF
    }

    if ($seen{Orn}) {
        print {$STY} <<'END_STY_FONTAXES_ORN';
    \fa@naming@exception{figures}{{ornament}{proportional}}{Orn}
    \fa@naming@exception{figures}{{ornament}{tabular}}{Orn}
    \def\ornaments{\@nomath\ornaments
        \fontencoding{U}\fontfigurestyle{ornament}\selectfont}
    \DeclareTextFontCommand{\textornaments}{\ornaments}
    \providecommand{\ornament}[1]{\textornaments{\char##1}}

END_STY_FONTAXES_ORN
    }

    if ($seen{Numr}) {
        print {$STY} <<'END_STY_FONTAXES_NUMR';
    \fa@naming@exception{figures}{{numerators}{proportional}}{Numr}
    \fa@naming@exception{figures}{{numerators}{tabular}}{Numr}

END_STY_FONTAXES_NUMR
    }

    if ($seen{Dnom}) {
        print {$STY} <<'END_STY_FONTAXES_DNOM';
    \fa@naming@exception{figures}{{denominators}{proportional}}{Dnom}
    \fa@naming@exception{figures}{{denominators}{tabular}}{Dnom}

END_STY_FONTAXES_DNOM
    }

    print {$STY} "}{}\n\n";

    print {$STY} <<"END_STY_XKEYVAL";
\\IfFileExists{xkeyval.sty}{
    \\newcommand*{\\$fam\@scale}{1}
    \\RequirePackage{xkeyval}
    \\DeclareOptionX{scale}{\\renewcommand*{\\$fam\@scale}{##1}}
    \\DeclareOptionX{scaled}{\\renewcommand*{\\$fam\@scale}{##1}}
}{
    \\let\\DeclareOptionX\\DeclareOption
    \\let\\ExecuteOptionsX\\ExecuteOptions
    \\let\\ProcessOptionsX\\ProcessOptions
}

END_STY_XKEYVAL

    if ($seen{LF} or $seen{TLF}) {
        print {$STY}
            "\\DeclareOptionX{lining}{\\edef\\$fam\@figurestyle{LF}}\n";
    }
    if ($seen{OsF} or $seen{TOsF}) {
        print {$STY}
            "\\DeclareOptionX{oldstyle}{\\edef\\$fam\@figurestyle{OsF}}\n";
    }
    if ($seen{TLF} or $seen{TOsF}) {
        print {$STY}
            "\\DeclareOptionX{tabular}{\\edef\\$fam\@figurealign{T}}\n";
    }
    if ($seen{LF} or $seen{OsF}) {
        print {$STY}
            "\\DeclareOptionX{proportional}{\\edef\\$fam\@figurealign{}}\n";
    }

    my $defaults
        = $seen{OsF}  ? 'oldstyle,proportional'
        : $seen{TOsF} ? 'oldstyle,tabular'
        : $seen{LF}   ? 'lining,proportional'
        : $seen{TLF}  ? 'lining,tabular'
        :               die "[ERROR] Internal bug, please report!";

    my $default_bold;
    for my $series (qw(ultrablack ultrabold heavy extrablack black
                        extrabold demibold semibold bold)) 
    {
        if ($seen{$FD_WEIGHT{$series}}) {
            print {$STY}
                "\\DeclareOptionX{$series}{\\edef\\bfseries\@$ARGV{nfss}",
                "{$FD_WEIGHT{$series}}}\n";
            $default_bold = $series;
        }
    }
    $defaults .= ",$default_bold" if $default_bold;

    my $default_regular;
    for my $series (qw(light medium book regular)) {
        if ($seen{$FD_WEIGHT{$series} || 'm'}) {
            print {$STY}
                "\\DeclareOptionX{$series}{\\edef\\mdseries\@$ARGV{nfss}",
                "{@{[ $FD_WEIGHT{$series} || 'm' ]}}}\n";
            $default_regular = $series;
        }
    }
    $defaults .= ",$default_regular" if $default_regular;

    print {$STY} <<"END_STYLE_REST";
\\ExecuteOptionsX{$defaults}
\\ProcessOptionsX\\relax

\\renewcommand*
    {\\$ARGV{nfss}default}
    {$fam-\\$fam\@figurealign\\$fam\@figurestyle}
\\renewcommand*{\\familydefault}{\\$ARGV{nfss}default}

\\endinput
END_STYLE_REST

    close $STY;

    return;
}

#-----------------------------------------------------------------------
# Walk a nested dictionary, return lookup table with all keys
#-----------------------------------------------------------------------
sub get_keys {
    my $dict = shift;
    my $seen = shift || {};

    while (my ($k, $v) = each %$dict) {
        $seen->{$k} = 1;
        get_keys($v, $seen) if ref $v eq 'HASH';
    }

    return $seen;
}

#-----------------------------------------------------------------------
# Create a .fd file for LaTeX's NFSS
#-----------------------------------------------------------------------
sub write_fdfile {
    my ($fam, $enc, $sty, $data) = @_;

    my $fn = sprintf "%s%s-%s.fd", $enc, $fam, $sty;
    my $dir = File::Spec->catdir(
        $ARGV{target}, 'tex', 'latex', $ARGV{typeface} || $fam);
    File::Path::make_path($dir);
    $fn = File::Spec->catfile($dir, $fn);
    open my $FD, '>', $fn or die "[ERROR] Can't create '$fn': $!";

    print {$FD} <<"END_FD_HEADER";
%% Generated by autoinst on $TODAY
%%
\\ProvidesFile{${enc}${fam}-${sty}.fd}
    [$TODAY (autoinst)  Font definitions for ${enc}/${fam}-${sty}.]

\\expandafter\\ifx\\csname ${fam}\@scale\\endcsname\\relax
    \\let\\${fam}\@\@scale\\\@empty
\\else
    \\edef\\${fam}\@\@scale{s*[\\csname ${fam}\@scale\\endcsname]}%
\\fi

\\DeclareFontFamily{${enc}}{${fam}-${sty}}{}

END_FD_HEADER

    while (my ($series, $fdseries) = each %$data) {
        while (my ($shape, $fdshape) = each %$fdseries) {
            print {$FD}
                "\\DeclareFontShape{$enc}{${fam}-${sty}}{$series}{$shape}{\n";
            my @sizes = sort { $a->[0] <=> $b->[0] }
                             @{$fdshape};
            $sizes[0][0] = $sizes[-1][1] = '';
            $sizes[$_][0] = $sizes[$_ - 1][1] for (1 .. $#sizes);
            for my $size (@sizes) {
                print {$FD} "      <$size->[0]-$size->[1]>",
                            " \\${fam}\@\@scale $size->[2]\n";
            }
            print {$FD} "}{}\n\n";
        }
        
        while (my ($shape, $replace) = each %FD_SSUB) {
            if (!exists $fdseries->{$shape} && exists $fdseries->{$replace}) {
                print {$FD} <<"END_FD_SSUB";
\\DeclareFontShape{$enc}{${fam}-${sty}}{$series}{$shape}{
      <-> ssub * ${fam}-${sty}/${series}/${replace}
}{}

END_FD_SSUB
                $fdseries->{$shape} = 1;
            }
        }
    }
    
    for my $shape (keys %{$data->{sl}}) {
        if (!exists $data->{m}{$shape}) {
            print {$FD} <<"END_FD_SSUB_SL";
\\DeclareFontShape{$enc}{${fam}-${sty}}{m}{$shape}{
      <-> ssub * ${fam}-${sty}/sl/${shape}
}{}

END_FD_SSUB_SL
        }
    }
    
    for my $shape (keys %{$data->{b}}) {
        if (!exists $data->{bx}{$shape}) {
            print {$FD} <<"END_FD_SSUB_BX";
\\DeclareFontShape{$enc}{${fam}-${sty}}{bx}{$shape}{
      <-> ssub * ${fam}-${sty}/b/${shape}
}{}

END_FD_SSUB_BX
        }
    }
    print {$FD} "\\endinput\n";

    close $FD;

    return;
}


############################################################################


package main;

main();


__END__


############################################################################


    To create the documentation:

    pod2man --center="Marc Penninga" --release="fontools" --section=1 \
        autoinst - | groff -Tps -man - | ps2pdf - autoinst.pdf


=pod

=head1 NAME

autoinst - wrapper around the F<LCDF TypeTools>,
for installing and using OpenType fonts in (La)TeX.


=head1 SYNOPSIS

B<autoinst> [I<options>] B<fontfile(s)>


=head1 DESCRIPTION

Eddie Kohler's I<LCDF TypeTools> are superb tools for installing 
OpenType fonts in LaTeX, but they can be hard to use: 
they need many, often long, command lines 
and don't generate the F<fd> and F<sty> files LaTeX needs.
B<autoinst> simplifies the use of the I<TypeTools> for font installation
by generating and executing all commands for I<otftotfm>
and by creating and installing all necessary F<fd> and F<sty> files.

Given a family of font files (in F<otf> or F<ttf> format),
B<autoinst> will create several LaTeX font families:

=over 2

=over 3

=item -

Four text families (with lining and oldstyle digits, each in both tabular
and proportional variants), all with the following shapes:

=over 2

=over 8

=item I<n>

Roman text

=item I<it>, I<sl>

Italic and slanted (sometimes called oblique) text

=item I<sc>

Small caps

=item I<sw>

Swash

=item I<tl>

Titling shape. Meant for all-caps text only (even though it sometimes contains
lowercase glyphs as well), where letterspacing and the positioning of
punctuation characters have been adjusted to suit all-caps text.
(This shape is only generated for the families with lining digits, 
since old-style digits make no sense with all-caps text.)

=item I<scit>, I<scsl>

Italic and slanted small caps

=item I<nw>

"Upright swash"; usually roman text with a few "oldstyle" ligatures 
like ct, sp and st.

=item I<tlit>, I<tlsl>

Italic and slanted titling text

=back

=back

=item -

For each T1-encoded text family: a family of TS1-encoded symbol fonts,
in roman, italic and slanted shapes.

=item -

Families with superiors, inferiors, numerators and denominators,
in roman, italic and slanted shapes.

=item -

An ornament family, in roman, italic and slanted shapes.

=back

=back

Of course, if the fonts don't contain italics, oldstyle digits, small caps 
etc., the corresponding shapes and families are not created.
In addition, the creation of most families and shapes can be controlled 
by options (see L</"COMMAND-LINE OPTIONS"> below).

These families use the I<FontPro> project's naming scheme: 
I<< <FontFamily>-<Suffix> >>, where I<< <Suffix> >> is:

=over 8

=item I<LF>

proportional (i.e., figures have varying widths) lining figures

=item I<TLF>

tabular (i.e., all figures have the same width) lining figures

=item I<OsF>

proportional oldstyle figures

=item I<TOsF>

tabular oldstyle figures

=item I<Sup>

superior characters (note that most fonts have only an incomplete set of 
superior characters: digits, some punctuation and the letters I<abdeilmnorst>;
normal forms are used for other characters)

=item I<Inf>

inferior characters; usually only digits and some punctuation,
normal forms for other characters

=item I<Orn>

ornaments

=item I<Numr>

numerators

=item I<Dnom>

denominators

=back

The generated fonts are named I<< <FontName>-<suffix>-<shape>-<enc> >>,
where I<< <suffix> >> is the same as above (but in lowercase),
I<< <shape> >> is either empty, "sc", "swash" or "titling",
and I<< <enc> >> is the encoding (also in lowercase).
A typical name in this scheme would be "FiraSans-Light-osf-sc-ly1".


=head2 On the choice of text encoding

By default, B<autoinst> generates text fonts with OT1, T1 and LY1
encodings, and the generated style files use LY1 as the default text encoding.
LY1 has been chosen over T1 because it has some empty slots to accommodate
the additional ligatures provided by many OpenType fonts.
Other encodings can be chosen using the I<-encoding> option 
(see L</"COMMAND-LINE OPTIONS"> below).


=head2 Using the fonts in your LaTeX documents

B<autoinst> generates a style file for using the font in LaTeX documents,
named F<< <FontFamily>.sty >>. This style file also takes care of loading the
F<fontenc> and F<textcomp> packages.
To use the font, put the command C<<< \usepackage{I<< <FontFamily> >>} >>>
in the preamble of your document.

This style file defines a number of options:

=over 4

=item C<lining>, C<oldstyle>, C<tabular>, C<proportional>

Choose which figure style to use. 
The defaults are "oldstyle" and "proportional" (if available).

=item C<<< scale=I<< <number> >> >>>

Scale the font by a factor of I<< <number> >>.
E.g., to increase the size of the font by 5%, use 
C<<< \usepackage[scale=1.05]{I<< <FontFamily> >>} >>>. 
May also be spelled C<scaled>.

This option is only available when you have the F<xkeyval> package installed.

=item C<light>, C<medium>, C<regular>

Select the weight that LaTeX will use as the "regular" weight; 
the default is C<regular>.

=item C<ultrablack>, C<ultrabold>, C<heavy>, C<extrablack>, C<black>, 
      C<extrabold>, C<demibold>, C<semibold>, C<bold>

Select the weight that LaTeX will use as the "bold" weight; 
the default is C<bold>.

=back

The previous two groups of options will only work if
you have the F<mweights> package installed.

The style file will also try to load the F<fontaxes> package 
(available on CTAN), which gives easy access to various font shapes and styles.
Using the machinery set up by F<fontaxes>, the generated style file 
defines a number of commands (which take the text to be typeset as argument)
and declarations (which don't take arguments, but affect all text up to
the end of the current group) to access titling, superior and inferior 
characters:


    DECLARATION     COMMAND         SHORT FORM OF COMMAND

    \tlshape        \texttitling    \texttl
    \sufigures      \textsuperior   \textsu
    \infigures      \textinferior   \textin


In addition, the C<\swshape> and C<\textsw> commands are redefined to place
swash on the secondary shape axis (F<fontaxes> places it on the primary
shape axis) to make them behave properly when nested, so that
C<\swshape\upshape> will give upright swash.

There are no commands for accessing the numerator and denominator
fonts; these can be selected using F<fontaxes>' standard commands,
e.g., C<\fontfigurestyle{numerator}\selectfont>.

The style file also provides a command C<<< \ornament{I<< <number> >>} >>>,
where C<<< I<< <number> >> >>> is a number from 0 to the total number of
ornaments minus one. Ornaments are always typeset using the current family,
series and shape. A list of all ornaments in a font can be created by
running LaTeX on the file F<nfssfont.tex> (part of a standard
LaTeX installation) and supplying the name of the ornament font.

To access the ornaments, B<autoinst> creates a font-specific encoding file
F<< <FontFamily>_orn.enc >>, 
but only if that file doesn't yet exist in the current directory.
This is a deliberate feature that allows you to provide your own
encoding vector, e.g. if your fonts use non-standard glyph names for ornaments.

These commands are only generated for existing shapes and number styles;
no commands are generated for shapes and styles that don't exist, 
or whose generation was turned off by the user.
Also these commands are built on top of F<fontaxes>, so if that package 
cannot be found, you're limited to using the lower-level commands from 
standard NFSS (C<\fontfamily>, C<\fontseries>, C<\fontshape> etc.).


=head2 NFSS codes

NFSS identifies fonts by a combination of family, series 
(the concatenation of weight and width), shape and size.
B<autoinst> parses the output of C<otfinfo --info> to determine
these parameters. When this fails
(e.g., because the font family contains uncommon widths or weights),
B<autoinst> ends up with different fonts having the I<same> values
for these font parameters, which means that these fonts cannot be used in NFSS.
In that case, B<autoinst> will split the font family into multiple subfamilies
(based on each font file's "Subfamily" value) and try again.
(Since many font vendors misunderstand the "Subfamily" concept
and make each font file its own separate subfamily,
this strategy is only used as a last resort.)

If such a proliferation of font families is unwanted,
either run B<autoinst> on a smaller set of fonts or 
add the missing widths, weights and shapes to the tables C<%FD_WIDTH>,
C<%FD_WEIGHT> and C<%FD_SHAPE>, at the beginning of the source code.
Please also send a bug report (see L<AUTHOR> below).

B<autoinst> maps widths, weights and shapes to NFSS codes using
the following tables. These are based on the standard I<Fontname> scheme 
and Philipp Lehman's F<Font Installation Guide>, but some changes were made 
to avoid name clashes in font families with many different widths and weights,
such as Helvetica Neue and Fira Sans.


    WEIGHT                              WIDTH

    
    Two            2     [1]            Ultra Compressed    up
    Four           4     [1]            Extra Compressed    ep
    Eight          8     [1]            Compressed          p
    Hair           a                    Compact             p
    Thin           t                    Ultra Condensed     uc
    Ultra Light    ul                   Extra Condensed     ec
    Extra Light    el                   Condensed           c
    Light          l                    Narrow              n
    Book           sl    [2]            Semicondensed       sc
    Regular              [3]            Regular                     [3]
    Medium         mb                   Semiextended        sx
    Demibold       db                   Extended            x
    Semibold       sb                   Expanded            e
    Bold           b                    Wide                w
    Extra Bold     eb
    Ultra          ub
    Ultra Bold     ub                   SHAPE
    Black          k
    Extra Black    ek                   Roman, Upright      n       [4]
    Ultra Black    uk                   Italic              it
    Heavy          h                    Cursive, Kursiv     it
    Poster         r                    Oblique             sl      [5]
                                        Slanted             sl      [5]
                                        Incline(d)          sl      [5]


=head3 Notes

=over 4

=item [1]

These weights only occur (as far as I know) in Fira Sans.

=item [2]

Since release 2018-01-09, B<autoinst> adds "ssub" rules to the F<fd> files 
to substitute "Book" weight for "Regular" when the latter is missing.
Before that, "Book" was treated as a synonym for "Regular".

=item [3]

When I<both> weight and width are empty, the "series" attribute becomes "m".

=item [4]

Adobe Silentium Pro contains two "Roman" shapes ("RomanI" and "RomanII");
the first of these is mapped to "n", the second one to "it".

=item [5]

Since release 2014-01-21; before that, slanted shapes were mapped to "it".

=back


=head2 A note for MiKTeX users

Automatically installing the fonts into a suitable TEXMF tree
(as B<autoinst> tries to do by default) requires a TeX-installation that uses
the F<kpathsea> library; with TeX distributions that implement their
own directory searching (such as MiKTeX), B<autoinst> will complain that
it cannot find the F<kpsewhich> program and install all generated files
into subdirectories of the current directory.
If you use such a TeX distribution, you should either move these files
to their correct destinations by hand, or use the I<-target> option
(see L</"COMMAND-LINE OPTIONS"> below) to specify a TEXMF tree.

Also, some OpenType fonts may lead to F<pl> and F<vpl> files that
are too big for MiKTeX's F<pltotf> and F<vptovf>;
the versions that come with W32TeX (F<http://www.w32tex.org>)
and TeXLive (F<http://tug.org/texlive>) don't seem to have this problem.


=head1 COMMAND-LINE OPTIONS

B<autoinst> tries hard to do The Right Thing (TM) by default, 
so in many cases you won't need these options;
but most aspects of its operation can be fine-tuned if you want to.

You may use either one or two dashes before options,
and option names may be shortened to a unique prefix
(e.g., B<-encoding> may be abbreviated to B<-enc> or even B<-en>,
but B<-e> is ambiguous (it may mean either B<-encoding> or B<-extra>)).

=over 4

=item B<-dryrun>

Don't actually do anything, only create the logfile F<autoinst.log> 
showing which fonts would have been generated. 

=item B<-encoding>=I<encoding[,encoding]>

Generate the specified encoding(s) for the text fonts. The default is 
"OT1,T1,LY1".
For each encoding, a file F<< <encoding>.enc >> (in all I<lowercase>!)
should be somewhere where F<otftotfm> can find it. Suitable encoding files
for OT1, T1/TS1 and LY1 come with B<autoinst>. (These files are
called F<fontools_ot1.enc> etc. to avoid name clashes with other packages;
the "fontools_" prefix may be omitted.)

Multiple text encodings can be specified as a comma-separated list:
C<-encoding=OT1,T1> (without spaces!). The generated style file passes these encodings 
to F<fontenc> in the specified order, so the last one will become 
the default text encoding for your documents.

=item B<-ts1> / B<-nots1>

Control the creation of TS1-encoded fonts. The default is B<-ts1>
if the text encodings (see I<-encoding> above) include T1,
B<-nots1> otherwise.

=item B<-sanserif>

Install the font as a sanserif font, accessed via C<\sffamily> and C<\textsf>.
The generated style file redefines C<\familydefault>,
so including it will still make this font the default text font.

=item B<-typewriter>

Install the font as a typewriter font, accessed via C<\ttfamily> and
C<\texttt>.
The generated style file redefines C<\familydefault>,
so including it will still make this font the default text font.

=item B<-lining> / B<-nolining>

Control the creation of fonts with lining figures. The default is
B<-lining>.

=item B<-oldstyle> / B<-nooldstyle>

Control the creation of fonts with oldstyle figures. The default is
B<-oldstyle>.

=item B<-proportional> / B<-noproportional>

Control the creation of fonts with proportional figures. The default is
B<-proportional>.

=item B<-tabular> / B<-notabular>

Control the creation of fonts with tabular figures. The default is
B<-tabular>.

=item B<-smallcaps> / B<-nosmallcaps>

Control the creation of small caps fonts. The default is
B<-smallcaps>.

=item B<-swash> / B<-noswash>

Control the creation of swash fonts. The default is B<-swash>.

=item B<-titling> / B<-notitling>

Control the creation of titling fonts. The default is B<-titling>.

=item B<-superiors> / B<-nosuperiors>

Control the creation of fonts with superior characters.
The default is B<-superiors>.

=item B<-inferiors>=[ B<sinf> | B<subs> | B<dnom> ]

The OpenType standard defines several kinds of digits that might be used 
as inferiors or subscripts: "Scientific Inferiors" 
(OpenType feature "sinf"), "Subscripts" ("subs") and "Denominators" ("dnom").
This option allows the user to determine which of these styles B<autoinst>
should use for the inferior characters. The default is not to create fonts 
with inferior characters.

Note that many fonts contain only one (or even none) of these types
of inferior characters. If you specify a style of inferiors that isn't
actually present in the font, B<autoinst> silently falls back to its default
of not creating fonts with inferiors; it doesn't try to substitute one of
the other features.

=item B<-fractions> / B<-nofractions>

Control the creation of fonts with numerators and denominators.
The default is B<-nofractions>.

=item B<-ornaments> / B<-noornaments>

Control the creation of ornament fonts. The default is B<-ornaments>.

=item B<-defaultlining> / B<-defaultoldstyle>

=item B<-defaulttabular> / B<-defaultproportional>

Tell B<autoinst> which figure style is the current font family's default
(i.e., which figures you get when you don't specify any OpenType features).

I<Don't use these options unless you are certain you need them!>
They are only needed for fonts that don't provide OpenType features 
for their default figure style; and even in that case, 
B<autoinst>'s default values (B<-defaultlining> and B<-defaulttabular>) 
are usually correct.

=item B<-nofigurekern>

Some fonts provide kerning pairs for tabular figures.
This is very probably not what you want 
(e.g., numbers in tables won't line up exactly).
This option adds extra I< --ligkern> options
to the commands for I<otftotfm> to suppress such kerns. 
Note that this option leads to very long commands (it adds
one hundred I< --ligkern> options), which may cause problems on some systems.

=item B<-extra>=I<text>

Append I<text> as extra options to the command lines for I<otftotfm>. 
To prevent I<text> from accidentily being interpreted as options to B<autoinst>, 
it should be properly quoted.

=item B<-manual>

Manual mode. By default, B<autoinst> immediately executes all F<otftotfm>
commands it generates; with the B<-manual> option, these commands are
instead written to a file F<autoinst.bat>.
Furthermore it adds the I< --pl> option
(which tells F<otftotfm> to generate human readable/editable F<pl> 
and F<vpl> files instead of the default F<tfm> and F<vf> files)
and omits the I< --automatic> option (which causes F<otftotfm> to
leave all generated files in the current directory, rather than install
them into your TEXMF tree). Manual mode is meant to enable tweaking 
the generated commands and post-processing the generated files.

When using this option, run F<pltotf> and F<vptovf> after executing 
the commands (to convert the F<pl> and F<vf> files to F<tfm> and F<vf> format)
and move all generated files to their proper destinations.

=back

All following options are only meaningful in automatic mode,
and hence ignored in manual mode:

=over 4

=item B<-target>=I<DIRECTORY>

Install all generated files into the TEXMF tree at I<DIRECTORY>.

By default, B<autoinst> searches your $TEXMFLOCAL and $TEXMFHOME paths
and installs all files into subdirectories of the first writable TEXMF tree
it finds (or into subdirectories of the current directory,
if no writable directory is found).

=item B<-vendor>=I<VENDOR>

=item B<-typeface>=I<TYPEFACE>

These options are equivalent to F<otftotfm>'s I< --vendor> and I< --typeface>
options: they change the "vendor" and "typeface" parts of the names of the
subdirectories in the TEXMF tree where generated files will be stored.
The default values are "lcdftools" and the font's FontFamily name.

Note that these options change I<only> directory names,
not the names of any generated files.

=item B<-updmap> / B<-noupdmap>

Control whether or not F<updmap> is called after the last call to F<otftotfm>.
The default is B<-updmap>.

=back


=head1 SEE ALSO

Eddie Kohler's B<TypeTools> (F<http://www.lcdf.org/type>).

B<Perl> can be obtained from F<http://www.perl.org>; 
it is a standard part of many Linux distributions.
For Windows, try ActivePerl (F<http://www.activestate.com>)
or Strawberry Perl (F<http://strawberryperl.com>).

B<XeTeX> (F<http://www.tug.org/xetex>) and B<LuaTeX> (F<http://www.luatex.org>)
are Unicode-aware TeX engines that can use OpenType fonts directly, 
without the need for any (La)TeX-specific support files.

The B<FontPro> project (F<https://github.com/sebschub/FontPro>)
offers very complete LaTeX support (including math) for Adobe's Minion Pro, 
Myriad Pro and Cronos Pro font families.

John Owens' B<otfinst> (available from CTAN) is another wrapper
around F<otftotfm>.


=head1 AUTHOR

Marc Penninga <marcpenninga@gmail.com>

When sending a bug report, please give as much relevant information as
possible; this includes at least (but may not be limited to) 
the log file F<autoinst.log>.
If you see any error messages (either from B<autoinst> itself, from the I<LCDF TypeTools>,
from Perl or from the OS), please include these I<verbatim> as well; don't paraphrase them.


=head1 COPYRIGHT

Copyright (C) 2005-2018 Marc Penninga.


=head1 LICENSE

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published
by the Free Software Foundation, either version 2 of the License,
or (at your option) any later version.
A copy of the text of the GNU General Public License is included in 
the I<fontools> distribution; see the file F<GPLv2.txt>.


=head1 DISCLAIMER

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.



=head1 RECENT CHANGES

(See the source for the full story, all the way back to 2005.)

=over 12

=item I<2018-01-09>

Added the "sl" weight for font families (such as Fira Sans) that contain both
"Book" and "Regular" weights (reported by Bob Tennent). 
Added the "Two", "Four", "Eight" and "Hair" weights.

=item I<2017-06-16>

Changed the I<-inferiors> option from a binary yes-or-no choice to allow
the user to choose one of the "sinf", "subs" and "dnom" features.
B<autoinst> now always creates a log file.

=item I<2017-03-21>

Updated the F<fontools_ot1.enc> encoding file to include the "Lslash" 
and "lslash" glyphs (thanks to Bob Tennent).

=back


=begin Really_old_history

=over 12

=item I<2015-11-22>

Bugfix: Latex doesn't like command names with dashes in it.

=item I<2015-05-13>

Fixed an error message that mixed up width and weight.

=item I<2014-04-04>

Fixed a bug in the font info parsing code.

=item I<2014-01-21>

"Oblique" or "slanted" fonts are now mapped to NFSS code "sl" instead 
of "it"; added "ssub" rules to the F<fd> files to substitute slanted fonts
for italic ones if the latter are missing. Fixed a few bugs.

=item I<2014-01-03>

Added the I<-dryrun> and I<-logfile> options; changed which info is logged.
Added the I<-lining>, I<-oldstyle>, I<-tabular> and I<-proportional> 
options; the old options with those names have been renamed to 
I<-defaultlining>, I<-defaultoldstyle> etc.

=item I<2013-10-31>

The previous change required Perl v5.14 or newer; 
now it also works with older versions.

=item I<2013-10-01>

Added the I<-lining>, I<-oldstyle>, I<-tabular> and I<-proportional>
command line options. 

=item I<2013-07-25>

The generated F<sty> files now use the I<mweights> package instead of
redefining C<\mddefault> and C<\bfdefault>. 
Added C<scale> as an alias for the package option C<scaled>.

=item I<2013-02-06>

Bugfix: the directory names for map and encoding files contained 
the "vendor" instead of the "typeface".

=item I<2013-01-03>

Added extra "ssub" rules to the F<fd> files that substitute "b" for "bx".
Verbose mode now also prints all generated commands before they're executed.

=item I<2012-10-25>

Added extra "ssub" rules to the F<fd> files that substitute italic
shapes for slanted ones.

=item I<2012-09-25>

Added the I<-vendor>, I<-typeface> and I<-(no)updmap> command line options.

=item I<2012-07-06>

Documentation update.

=item I<2012-03-06>

Implemented the "splitting the font family into multiple subfamilies"
emergency strategy when font info parsing fails.
Added recognition for a number of unusual widths, weights and shapes.

=item I<2012-02-29>

Fixed a bug in the font parsing code,
where possible widths, weights and shapes where tested in the wrong order;
this led to "ExtraLight" fonts being recognised as "Light".
Added recognition for "Narrow" and "Wide" widths.
Also added the I<-(no)figurekern> command-line option.

=item I<2012-02-01>

Reorganised the code, and fixed some bugs in the process.
Added the I<-target> command-line option.
Made B<autoinst> install the F<fd> and F<sty> files in
the same TEXMF tree as the other generated files.
Generate OT1, T1 and LY1 encoded text fonts by default.
Made I<-titling> a default option (instead of I<-notitling>).
Updated the documentation.

=item I<2011-06-15>

Fixed the font info parsing code for some fonts that are
too lazy to spell out "Italic" in full.

=item I<2010-04-29>

The I< --feature=kern> option is only used for fonts that
contain either a I<kern> feature or a I<kern> table.
Font feature selection commands in the F<sty> file are only
generated for shapes and figure styles that are supported
by the current font, and whose generation has not been
turned off using the command-line options.
Fixed the font info parsing to work with the Condensed fonts
in the Minion Pro family.

=item I<2010-04-23>

Always provide the I< --feature=kern> option to F<otftotfm>,
even if the font doesn't have a I<kern> feature;
this will make F<otftotfm> use the I<kern> table if present.
For fonts without a I<liga> feature, add I< --ligkern>
options for the common f-ligatures to the F<otftotfm> command line,
so that any ligatures present in the font will still be used.
Bug fix: the generated F<sty> files now work for font families
with names containing digits.

=item I<2009-04-09>

Prefixed the filenames of  the included encoding files with
I<fontools_>, to prevent name clashes with other packages.

=item I<2009-04-06>

A small patch to the C<get_orn> subroutine:
it now also recognises the I<bullet.xxx> ornament glyphs
in Adobe Kepler Pro.

=item I<2007-08-07>

Fixed a small bug with filename quoting on Windows.

=item I<2007-07-31>

Changed the tables that map weights and widths to NFSS codes:
in some extended families, different combinations of
weight and width were mapped to the same series.
Added a work-around for incorrect size info in some Kepler fonts.
Fixed a small bug in the generated commands for otftotfm
(sometimes, the "onum" feature was included twice).
Added encoding file for OT1 to the I<fontools> collection.

=item I<2007-07-27>

Two bugfixes: a closing brace was missing in the generated style file,
and the NFSS series was formed as "width plus weight" instead of the reverse.

=item I<2007-06-10>

Bugfix: silently replacing \DeclareOption, \ProcessOptions and
\ExecuteOptions with their counterparts from the xkeyval package
caused problems for some other packages.

=item I<2007-06-04>

Added the I< --no-updmap> option to all generated commands for F<otftotfm>
(except the last); this should yield a significant speed-up for large
families (suggested by Steven E. Harris).
Tweaked the font info parsing to work around a bug in the naming of
some FontFont fonts, where every font is in a family of its own.
Added the "scaled" option (including the loading of F<xkeyval>)
to the generated style file.
Extended the output of the I<-verbose> option.

=item I<2007-02-08>

Yet Another Complete Rewrite.
The code is now much more readable and more flexible;
the program can now handle fonts from different families,
as well as multiple text encodings.
Rewrote the font info parsing code to work for Arno Pro.

=item I<2006-10-11>

The program determines the fonts' weights, widths and shapes by parsing
the output from C<otfinfo --info> instead of the font filename.
This should make B<autoinst> work for non-Adobe fonts.
Filenames with spaces now work as well.

=item I<2006-08-31>

Made the generated style files try to include "fontaxes.sty";
changed the names of the generated fonts and families
(to make the previous change possible);
added command-line options for most font styles and shapes;
tweaked the filename parsing code for Cronos Pro and Gill Sans Pro;
added runtime generation of encoding vectors for ornament fonts
(because GaramondPremier's ornament names differ from other fonts);
changed the NFSS-code for italic small caps and titling to "scit" and "tlit"
(to work with F<fontaxes>);
and edited (and hopefully improved) the documentation.

=item I<2005-10-03>

When creating LY1, T1, OT1 or TS1 encoded fonts, the I<-coding-scheme>
option is added to the commands for F<otftotfm>; this should make the
generated F<pl> and F<vpl> files acceptable to I<fontinst>.
Also elaborated the documentation somewhat and fixed a small bug.

=item I<2005-09-22>

Added check to see if filename parsing succeeded;
updated the filename parsing code to cater for GaramondPremier Pro, 
Silentium Pro and some non-Adobe fonts;
added the I<-sanserif> and I<-typewriter> options and hacked the
style files to support using several different font families in one document.

=item I<2005-09-12>

Cleaned up the code (it now runs under the F<strict> and F<warnings> pragmas);
fixed a (rather obscure) bug that occurred when creating TS1-encoded
fonts for families with multiple optical masters and oldstyle digits;
added the I<medium, semibold> etc. options to the style file;
and improved the layout of the generated files.

=item I<2005-08-11>

The generated commands weren't actually executed, only printed...
Also added a small hack to cater for fonts
(such as some recent versions of MinionPro)
that contain swash characters but don't provide a "swsh" feature.

=item I<2005-08-10>

Dropped the "fontname" scheme in favor of a more verbose naming scheme,
since many filenames were still more than eight characters long anyway.
Added F<nfssext.sty>-like commands to the generated style file.
Changed the default encoding to LY1 and added the "inferior" shape.

=item I<2005-08-01>

Rewrote (and hopefully improved) the user interface;
changed the program to by default execute the generated F<otftotfm> command
lines rather than writing them to a file;
added automatic determination of the "fontname" code for the font family;
changed the NFSS code for italic small caps to "si"; added titling shapes;
changed the generated style
file to include an interface for the ornaments and to load Lehman's NFSS
extensions F<nfssext.sty> if this is installed; corrected the "fontname" codes
for OT1, T1, LY1 and user-specific encodings; extended the output generated by
the I<-verbose> option; and rewrote and extended the documentation.

=item I<2005-06-16>

Did some more finetuning to the filename-parsing code.

=item I<2005-05-31>

Generate correct fontname for OT1-encoded fonts.

=item I<2005-05-18>

Tried to make the filename-parsing code a bit more robust by adding several
weights and widths; changed the error that's displayed when filename parsing
fails; commented the code.

=item I<2005-04-29>

Rewrote large parts of the code (yes it I<was> even worse).

=item I<2005-04-18>

Changed default text-encoding to T1, added TS1.

=item I<2005-03-29>

Added support for font families with multiple widths.

=item I<2005-03-15>

First version.

=back

=end Really_old_history
