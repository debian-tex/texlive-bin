commit 1b8b254a766350291f8e7e19feaf6326ebabe633
Author: Luigi Scarso <luigi.scarso@gmail.com>
Date:   Wed Sep 5 21:30:41 2018 +0000

    sync with luatex revision 6924.
    
    git-svn-id: svn://tug.org/texlive/trunk@48591 c570f23f-e606-0410-a88d-b1316a301751

--- texlive-bin.orig/libs/lua53/ChangeLog
+++ texlive-bin/libs/lua53/ChangeLog
@@ -2,17 +2,6 @@
 
 	* luaerror.test: LC_ALL=LANGUAGE=C.
 
-2018-07-21 Luigi Scarso <luigi.scarso@gmail.com>
-	
-	* Adapted for Lua 5.3.5
-
-
-2018-06-18 Luigi Scarso <luigi.scarso@gmail.com>
-	
-	* dropped poppler, new pplib from
-	  http://eurydyka.kaliope.org.pl/~pawel/libpp/html/ppapi.html
-
-
 2017-10-24 Luigi Scarso <luigi.scarso@gmail.com>
 	
 	* Adapted for Lua 5.3.4
--- texlive-bin.orig/libs/lua53/Makefile.am
+++ texlive-bin/libs/lua53/Makefile.am
@@ -65,7 +65,6 @@ nodist_libtexlua53_la_SOURCES = \
 	@LUA53_TREE@/src/lvm.c \
 	@LUA53_TREE@/src/lzio.c 
 
-
 lua53includedir = ${includedir}/texlua53
 
 lua53include_HEADERS = \
--- texlive-bin.orig/libs/lua53/TLpatches/ChangeLog
+++ texlive-bin/libs/lua53/TLpatches/ChangeLog
@@ -1,7 +1,3 @@
-2018-07-21 Luigi Scarso <luigi.scarso@gmail.com>
-	Adapted for lua 5.3.5
-
-
 2017-10-24 Luigi Scarso <luigi.scarso@gmail.com>
 	Adapted for lua 5.3.4
 
--- texlive-bin.orig/libs/lua53/TLpatches/patch-01-utf-8
+++ texlive-bin/libs/lua53/TLpatches/patch-01-utf-8
@@ -1,16 +1,7 @@
-diff -u lctype.h.orig lctype.h 
---- lctype.h.orig	2018-07-21 09:57:36.061692228 +0200
-+++ lctype.h	2018-07-21 10:03:29.625677730 +0200
-@@ -7,6 +7,8 @@
- #ifndef lctype_h
- #define lctype_h
- 
-+#include <ctype.h>
-+
- #include "lua.h"
- 
- 
-@@ -53,9 +55,11 @@
+diff -ur lua-5.3.4.orig/src/lctype.h lua-5.3.4/src/lctype.h
+--- lctype.h.orig	2017-10-24 15:14:50.724139638 +0200
++++ lctype.h	2017-10-24 15:15:51.704137138 +0200
+@@ -53,9 +53,11 @@
  
  /*
  ** 'lalpha' (Lua alphabetic) and 'lalnum' (Lua alphanumeric) both include '_'
--- texlive-bin.orig/libs/lua53/TLpatches/patch-02-FreeBSD
+++ texlive-bin/libs/lua53/TLpatches/patch-02-FreeBSD
@@ -1,6 +1,6 @@
-diff -u liolib.c.orig liolib.c 
---- liolib.c.orig	2017-04-19 19:29:57.000000000 +0200
-+++ liolib.c	2018-07-21 10:04:50.965674394 +0200
+diff -ur liolib.c.orig liolib.c 
+--- liolib.c.orig	2017-10-24 15:16:06.036136550 +0200
++++ liolib.c	2017-10-24 15:16:49.968134748 +0200
 @@ -16,6 +16,9 @@
  #include <stdio.h>
  #include <stdlib.h>
--- texlive-bin.orig/libs/lua53/TLpatches/patch-03-export
+++ texlive-bin/libs/lua53/TLpatches/patch-03-export
@@ -1,6 +1,6 @@
-diff -u lopcodes.h.orig lopcodes.h 
---- lopcodes.h.orig	2018-07-21 09:59:37.349687255 +0200
-+++ lopcodes.h	2018-07-21 10:07:04.413668921 +0200
+diff -ur lopcodes.h.orig lopcodes.h 
+--- lopcodes.h.orig	2017-10-24 15:22:51.012119943 +0200
++++ lopcodes.h	2017-10-24 15:18:37.924130321 +0200
 @@ -278,7 +278,7 @@
    OpArgK   /* argument is a constant or register/constant */
  };
@@ -20,10 +20,9 @@ diff -u lopcodes.h.orig lopcodes.h
  
  /* number of list items to accumulate before a SETLIST instruction */
 
-
-diff -u lundump.h.orig lundump.h 
---- lundump.h.orig	2018-07-21 10:00:01.545686262 +0200
-+++ lundump.h	2018-07-21 10:08:12.341666136 +0200
+diff -ur lundump.h.orig lundump.h 
+--- lundump.h.orig	2017-10-24 15:19:03.860129258 +0200
++++ lundump.h	2017-10-24 15:19:47.088127485 +0200
 @@ -26,7 +26,7 @@
  LUAI_FUNC LClosure* luaU_undump (lua_State* L, ZIO* Z, const char* name);
  
@@ -33,3 +32,4 @@ diff -u lundump.h.orig lundump.h
                           void* data, int strip);
  
  #endif
+
--- texlive-bin.orig/libs/lua53/lua53-src/README
+++ texlive-bin/libs/lua53/lua53-src/README
@@ -1,5 +1,5 @@
 
-This is Lua 5.3.5, released on 26 Jun 2018.
+This is Lua 5.3.4, released on 12 Jan 2017.
 
 For installation instructions, license details, and
 further information about Lua, see doc/readme.html.
--- texlive-bin.orig/libs/lua53/lua53-src/doc/contents.html
+++ texlive-bin/libs/lua53/lua53-src/doc/contents.html
@@ -32,7 +32,7 @@ For a complete introduction to Lua progr
 
 <P>
 <SMALL>
-Copyright &copy; 2015&ndash;2018 Lua.org, PUC-Rio.
+Copyright &copy; 2015&ndash;2017 Lua.org, PUC-Rio.
 Freely available under the terms of the
 <A HREF="http://www.lua.org/license.html">Lua license</A>.
 </SMALL>
@@ -609,10 +609,10 @@ Freely available under the terms of the
 
 <P CLASS="footer">
 Last update:
-Mon Jun 18 22:56:06 -03 2018
+Thu Dec 22 18:29:39 BRST 2016
 </P>
 <!--
-Last change: revised for Lua 5.3.5
+Last change: revised for Lua 5.3.4
 -->
 
 </BODY>
--- texlive-bin.orig/libs/lua53/lua53-src/doc/lua.css
+++ texlive-bin/libs/lua53/lua53-src/doc/lua.css
@@ -10,7 +10,7 @@ body {
 	line-height: 1.25 ;
 	margin: 16px auto ;
 	padding: 32px ;
-	border: solid #ccc 1px ;
+	border: solid #a0a0a0 1px ;
 	border-radius: 20px ;
 	max-width: 70em ;
 	width: 90% ;
@@ -111,29 +111,36 @@ pre.session {
 	border-radius: 8px ;
 }
 
-table {
+td.gutter {
+	width: 4% ;
+}
+
+table.columns {
 	border: none ;
 	border-spacing: 0 ;
 	border-collapse: collapse ;
 }
 
-td {
-	padding: 0 ;
-	margin: 0 ;
-}
-
-td.gutter {
-	width: 4% ;
-}
-
 table.columns td {
 	vertical-align: top ;
+	padding: 0 ;
 	padding-bottom: 1em ;
 	text-align: justify ;
 	line-height: 1.25 ;
 }
 
+p.logos a:link:hover, p.logos a:visited:hover {
+	background-color: inherit ;
+}
+
+table.book {
+	border: none ;
+	border-spacing: 0 ;
+	border-collapse: collapse ;
+}
+
 table.book td {
+	padding: 0 ;
 	vertical-align: top ;
 }
 
@@ -152,10 +159,6 @@ table.book span {
 	margin-top: 0.25em ;
 }
 
-p.logos a:link:hover, p.logos a:visited:hover {
-	background-color: inherit ;
-}
-
 img {
 	background-color: white ;
 }
--- texlive-bin.orig/libs/lua53/lua53-src/doc/manual.html
+++ texlive-bin/libs/lua53/lua53-src/doc/manual.html
@@ -19,7 +19,7 @@ by Roberto Ierusalimschy, Luiz Henrique
 
 <P>
 <SMALL>
-Copyright &copy; 2015&ndash;2018 Lua.org, PUC-Rio.
+Copyright &copy; 2015&ndash;2017 Lua.org, PUC-Rio.
 Freely available under the terms of the
 <a href="http://www.lua.org/license.html">Lua license</a>.
 </SMALL>
@@ -35,7 +35,7 @@ Freely available under the terms of the
 <!-- ====================================================================== -->
 <p>
 
-<!-- $Id: manual.of,v 1.167.1.2 2018/06/26 15:49:07 roberto Exp $ -->
+<!-- $Id: manual.of,v 1.167 2017/01/09 15:18:11 roberto Exp $ -->
 
 
 
@@ -203,8 +203,8 @@ even those that do not support threads n
 
 <p>
 The type <em>table</em> implements associative arrays,
-that is, arrays that can have as indices not only numbers,
-but any Lua value except <b>nil</b> and NaN.
+that is, arrays that can be indexed not only with numbers,
+but with any Lua value except <b>nil</b> and NaN.
 (<em>Not a Number</em> is a special value used to represent
 undefined or unrepresentable numerical results, such as <code>0/0</code>.)
 Tables can be <em>heterogeneous</em>;
@@ -400,8 +400,6 @@ with the event name prefixed by two unde
 the corresponding values are called <em>metamethods</em>.
 In the previous example, the key is "<code>__add</code>"
 and the metamethod is the function that performs the addition.
-Unless stated otherwise,
-metamethods should be function values.
 
 
 <p>
@@ -599,7 +597,7 @@ it is also slower than a real <code>__le
 </li>
 
 <li><b><code>__index</code>: </b>
-The indexing access operation <code>table[key]</code>.
+The indexing access <code>table[key]</code>.
 This event happens when <code>table</code> is not a table or
 when <code>key</code> is not present in <code>table</code>.
 The metamethod is looked up in <code>table</code>.
@@ -1278,8 +1276,13 @@ Square brackets are used to index a tabl
 <pre>
 	var ::= prefixexp &lsquo;<b>[</b>&rsquo; exp &lsquo;<b>]</b>&rsquo;
 </pre><p>
-The meaning of accesses to table fields can be changed via metatables
-(see <a href="#2.4">&sect;2.4</a>).
+The meaning of accesses to table fields can be changed via metatables.
+An access to an indexed variable <code>t[i]</code> is equivalent to
+a call <code>gettable_event(t,i)</code>.
+(See <a href="#2.4">&sect;2.4</a> for a complete description of the
+<code>gettable_event</code> function.
+This function is not defined or callable in Lua.
+We use it here only for explanatory purposes.)
 
 
 <p>
@@ -1474,15 +1477,20 @@ cyclically permutes the values of <code>
 
 
 <p>
-An assignment to a global name <code>x = val</code>
-is equivalent to the assignment
-<code>_ENV.x = val</code> (see <a href="#2.2">&sect;2.2</a>).
+The meaning of assignments to global variables
+and table fields can be changed via metatables.
+An assignment to an indexed variable <code>t[i] = val</code> is equivalent to
+<code>settable_event(t,i,val)</code>.
+(See <a href="#2.4">&sect;2.4</a> for a complete description of the
+<code>settable_event</code> function.
+This function is not defined or callable in Lua.
+We use it here only for explanatory purposes.)
 
 
 <p>
-The meaning of assignments to table fields and
-global variables (which are actually table fields, too)
-can be changed via metatables (see <a href="#2.4">&sect;2.4</a>).
+An assignment to a global name <code>x = val</code>
+is equivalent to the assignment
+<code>_ENV.x = val</code> (see <a href="#2.2">&sect;2.2</a>).
 
 
 
@@ -1823,17 +1831,17 @@ Here are some examples:
      g(f(), x)          -- f() is adjusted to 1 result
      g(x, f())          -- g gets x plus all results from f()
      a,b,c = f(), x     -- f() is adjusted to 1 result (c gets nil)
-     a,b = ...          -- a gets the first vararg argument, b gets
+     a,b = ...          -- a gets the first vararg parameter, b gets
                         -- the second (both a and b can get nil if there
-                        -- is no corresponding vararg argument)
+                        -- is no corresponding vararg parameter)
      
      a,b,c = x, f()     -- f() is adjusted to 2 results
      a,b,c = f()        -- f() is adjusted to 3 results
      return f()         -- returns all results from f()
-     return ...         -- returns all received vararg arguments
+     return ...         -- returns all received vararg parameters
      return x,y,f()     -- returns x, y, and all results from f()
      {f()}              -- creates a list with all results from f()
-     {...}              -- creates a list with all vararg arguments
+     {...}              -- creates a list with all vararg parameters
      {f(), nil}         -- f() is adjusted to 1 result
 </pre>
 
@@ -2031,12 +2039,9 @@ two objects are considered equal only if
 Every time you create a new object
 (a table, userdata, or thread),
 this new object is different from any previously existing object.
-A closure is always equal to itself.
+Closures with the same reference are always equal.
 Closures with any detectable difference
 (different behavior, different definition) are always different.
-Closures created at different times but with no detectable differences
-may be classified as equal or not
-(depending on internal caching details).
 
 
 <p>
@@ -2298,7 +2303,7 @@ If the value of prefixexp has type <em>f
 then this function is called
 with the given arguments.
 Otherwise, the prefixexp "call" metamethod is called,
-having as first argument the value of prefixexp,
+having as first parameter the value of prefixexp,
 followed by the original call arguments
 (see <a href="#2.4">&sect;2.4</a>).
 
@@ -2876,7 +2881,7 @@ it can do whatever it wants on that Lua
 as it should be already protected.
 However,
 when C code operates on other Lua states
-(e.g., a Lua argument to the function,
+(e.g., a Lua parameter to the function,
 a Lua state stored in the registry, or
 the result of <a href="#lua_newthread"><code>lua_newthread</code></a>),
 it should use them only in API calls that cannot raise errors.
@@ -3365,7 +3370,7 @@ it is left unchanged.
 Destroys all objects in the given Lua state
 (calling the corresponding garbage-collection metamethods, if any)
 and frees all dynamic memory used by this state.
-In several platforms, you may not need to call this function,
+On several platforms, you may not need to call this function,
 because all resources are naturally released when the host program ends.
 On the other hand, long-running programs that create multiple states,
 such as daemons or web servers,
@@ -5579,7 +5584,7 @@ given as argument to a hook (see <a href
 
 
 <p>
-To get information about a function, you push it onto the stack
+To get information about a function you push it onto the stack
 and start the <code>what</code> string with the character '<code>&gt;</code>'.
 (In that case,
 <code>lua_getinfo</code> pops the function from the top of the stack.)
@@ -6457,7 +6462,7 @@ file-related functions in the standard l
 
 <p>
 Pushes onto the stack the field <code>e</code> from the metatable
-of the object at index <code>obj</code> and returns the type of the pushed value.
+of the object at index <code>obj</code> and returns the type of pushed value.
 If the object does not have a metatable,
 or if the metatable does not have this field,
 pushes nothing and returns <code>LUA_TNIL</code>.
@@ -6744,7 +6749,7 @@ In words, if the argument <code>arg</cod
 the macro results in the default <code>dflt</code>.
 Otherwise, it results in the result of calling <code>func</code>
 with the state <code>L</code> and the argument index <code>arg</code> as
-arguments.
+parameters.
 Note that it evaluates the expression <code>dflt</code> only if needed.
 
 
@@ -8675,7 +8680,7 @@ the lowercase letters plus the '<code>-<
 <p>
 You can put a closing square bracket in a set
 by positioning it as the first character in the set.
-You can put a hyphen in a set
+You can put an hyphen in a set
 by positioning it as the first or the last character in the set.
 (You can also use an escape for both cases.)
 
@@ -9077,8 +9082,8 @@ Returns the destination table <code>a2</
 
 
 <p>
-Returns a new table with all arguments stored into keys 1, 2, etc.
-and with a field "<code>n</code>" with the total number of arguments.
+Returns a new table with all parameters stored into keys 1, 2, etc.
+and with a field "<code>n</code>" with the total number of parameters.
 Note that the resulting table may not be a sequence.
 
 
@@ -9210,7 +9215,7 @@ Returns the arc sine of <code>x</code> (
 <p>
 
 Returns the arc tangent of <code>y/x</code> (in radians),
-but uses the signs of both arguments to find the
+but uses the signs of both parameters to find the
 quadrant of the result.
 (It also handles correctly the case of <code>x</code> being zero.)
 
@@ -9511,7 +9516,7 @@ all I/O functions return <b>nil</b> on f
 (plus an error message as a second result and
 a system-dependent error code as a third result)
 and some value different from <b>nil</b> on success.
-In non-POSIX systems,
+On non-POSIX systems,
 the computation of the error message and error code
 in case of errors
 may be not thread safe,
@@ -9548,7 +9553,7 @@ When called with a file name, it opens t
 and sets its handle as the default input file.
 When called with a file handle,
 it simply sets this file handle as the default input file.
-When called without arguments,
+When called without parameters,
 it returns the current default input file.
 
 
@@ -9575,7 +9580,7 @@ it returns no values (to finish the loop
 The call <code>io.lines()</code> (with no file name) is equivalent
 to <code>io.input():lines("*l")</code>;
 that is, it iterates over the lines of the default input file.
-In this case, the iterator does not close the file when the loop ends.
+In this case it does not close the file when the loop ends.
 
 
 <p>
@@ -9958,7 +9963,7 @@ the host system and on the current local
 
 
 <p>
-In non-POSIX systems,
+On non-POSIX systems,
 this function may be not thread safe
 because of its reliance on C&nbsp;function <code>gmtime</code> and C&nbsp;function <code>localtime</code>.
 
@@ -10158,7 +10163,7 @@ and explicitly removed when no longer ne
 
 
 <p>
-In POSIX systems,
+On POSIX systems,
 this function also creates a file with that name,
 to avoid security risks.
 (Someone else might create the file with wrong permissions
@@ -10296,8 +10301,8 @@ The first parameter or local variable ha
 following the order that they are declared in the code,
 counting only the variables that are active
 in the current scope of the function.
-Negative indices refer to vararg arguments;
--1 is the first vararg argument.
+Negative indices refer to vararg parameters;
+-1 is the first vararg parameter.
 The function returns <b>nil</b> if there is no variable with the given index,
 and raises an error when called with a level out of range.
 (You can call <a href="#pdf-debug.getinfo"><code>debug.getinfo</code></a> to check whether the level is valid.)
@@ -10395,7 +10400,7 @@ When called without arguments,
 
 
 <p>
-When the hook is called, its first argument is a string
+When the hook is called, its first parameter is a string
 describing the event that has triggered its call:
 <code>"call"</code> (or <code>"tail call"</code>),
 <code>"return"</code>,
@@ -10546,8 +10551,7 @@ The options are:
 
 <ul>
 <li><b><code>-e <em>stat</em></code>: </b> executes string <em>stat</em>;</li>
-<li><b><code>-l <em>mod</em></code>: </b> "requires" <em>mod</em> and assigns the
-  result to global @<em>mod</em>;</li>
+<li><b><code>-l <em>mod</em></code>: </b> "requires" <em>mod</em>;</li>
 <li><b><code>-i</code>: </b> enters interactive mode after running <em>script</em>;</li>
 <li><b><code>-v</code>: </b> prints version information;</li>
 <li><b><code>-E</code>: </b> ignores environment variables;</li>
@@ -10625,7 +10629,7 @@ For instance, the call
 </pre><p>
 will print "<code>-e</code>".
 If there is a script,
-the script is called with arguments
+the script is called with parameters
 <code>arg[1]</code>, &middot;&middot;&middot;, <code>arg[#arg]</code>.
 (Like all chunks in Lua,
 the script is compiled as a vararg function.)
@@ -10811,7 +10815,7 @@ The following functions were deprecated
 <code>frexp</code>, and <code>ldexp</code>.
 You can replace <code>math.pow(x,y)</code> with <code>x^y</code>;
 you can replace <code>math.atan2</code> with <code>math.atan</code>,
-which now accepts one or two arguments;
+which now accepts one or two parameters;
 you can replace <code>math.ldexp(x,exp)</code> with <code>x * 2.0^exp</code>.
 For the other operations,
 you can either use an external library or
@@ -10846,7 +10850,7 @@ of the first result.)
 <ul>
 
 <li>
-Continuation functions now receive as arguments what they needed
+Continuation functions now receive as parameters what they needed
 to get through <code>lua_getctx</code>,
 so <code>lua_getctx</code> has been removed.
 Adapt your code accordingly.
@@ -10969,13 +10973,12 @@ and LiteralString, see <a href="#3.1">&s
 
 
 
-
 <P CLASS="footer">
 Last update:
-Tue Jun 26 13:16:37 -03 2018
+Mon Jan  9 13:30:53 BRST 2017
 </P>
 <!--
-Last change: revised for Lua 5.3.5
+Last change: revised for Lua 5.3.4
 -->
 
 </body></html>
--- texlive-bin.orig/libs/lua53/lua53-src/doc/readme.html
+++ texlive-bin/libs/lua53/lua53-src/doc/readme.html
@@ -107,7 +107,7 @@ Here are the details.
 <OL>
 <LI>
 Open a terminal window and move to
-the top-level directory, which is named <TT>lua-5.3.5</TT>.
+the top-level directory, which is named <TT>lua-5.3.x</TT>.
 The <TT>Makefile</TT> there controls both the build process and the installation process.
 <P>
 <LI>
@@ -355,10 +355,10 @@ THE SOFTWARE.
 
 <P CLASS="footer">
 Last update:
-Mon Jun 18 22:57:33 -03 2018
+Thu Dec 22 18:22:57 BRST 2016
 </P>
 <!--
-Last change: revised for Lua 5.3.5
+Last change: revised for Lua 5.3.4
 -->
 
 </BODY>
--- texlive-bin.orig/libs/lua53/lua53-src/src/Makefile
+++ texlive-bin/libs/lua53/lua53-src/src/Makefile
@@ -102,7 +102,7 @@ c89:
 
 
 freebsd:
-	$(MAKE) $(ALL) SYSCFLAGS="-DLUA_USE_LINUX -DLUA_USE_READLINE -I/usr/include/edit" SYSLIBS="-Wl,-E -ledit" CC="cc"
+	$(MAKE) $(ALL) SYSCFLAGS="-DLUA_USE_LINUX" SYSLIBS="-Wl,-E -lreadline"
 
 generic: $(ALL)
 
@@ -110,7 +110,7 @@ linux:
 	$(MAKE) $(ALL) SYSCFLAGS="-DLUA_USE_LINUX" SYSLIBS="-Wl,-E -ldl -lreadline"
 
 macosx:
-	$(MAKE) $(ALL) SYSCFLAGS="-DLUA_USE_MACOSX" SYSLIBS="-lreadline"
+	$(MAKE) $(ALL) SYSCFLAGS="-DLUA_USE_MACOSX" SYSLIBS="-lreadline" CC=cc
 
 mingw:
 	$(MAKE) "LUA_A=lua53.dll" "LUA_T=lua.exe" \
--- texlive-bin.orig/libs/lua53/lua53-src/src/lapi.c
+++ texlive-bin/libs/lua53/lua53-src/src/lapi.c
@@ -1,5 +1,5 @@
 /*
-** $Id: lapi.c,v 2.259.1.2 2017/12/06 18:35:12 roberto Exp $
+** $Id: lapi.c,v 2.259 2016/02/29 14:27:14 roberto Exp $
 ** Lua API
 ** See Copyright Notice in lua.h
 */
@@ -533,7 +533,6 @@ LUA_API void lua_pushcclosure (lua_State
   lua_lock(L);
   if (n == 0) {
     setfvalue(L->top, fn);
-    api_incr_top(L);
   }
   else {
     CClosure *cl;
@@ -547,9 +546,9 @@ LUA_API void lua_pushcclosure (lua_State
       /* does not need barrier because closure is white */
     }
     setclCvalue(L, L->top, cl);
-    api_incr_top(L);
-    luaC_checkGC(L);
   }
+  api_incr_top(L);
+  luaC_checkGC(L);
   lua_unlock(L);
 }
 
--- texlive-bin.orig/libs/lua53/lua53-src/src/lapi.h
+++ texlive-bin/libs/lua53/lua53-src/src/lapi.h
@@ -1,5 +1,5 @@
 /*
-** $Id: lapi.h,v 2.9.1.1 2017/04/19 17:20:42 roberto Exp $
+** $Id: lapi.h,v 2.9 2015/03/06 19:49:50 roberto Exp $
 ** Auxiliary functions from Lua API
 ** See Copyright Notice in lua.h
 */
--- texlive-bin.orig/libs/lua53/lua53-src/src/lauxlib.c
+++ texlive-bin/libs/lua53/lua53-src/src/lauxlib.c
@@ -1,5 +1,5 @@
 /*
-** $Id: lauxlib.c,v 1.289.1.1 2017/04/19 17:20:42 roberto Exp $
+** $Id: lauxlib.c,v 1.289 2016/12/20 18:37:00 roberto Exp $
 ** Auxiliary functions for building Lua libraries
 ** See Copyright Notice in lua.h
 */
--- texlive-bin.orig/libs/lua53/lua53-src/src/lauxlib.h
+++ texlive-bin/libs/lua53/lua53-src/src/lauxlib.h
@@ -1,5 +1,5 @@
 /*
-** $Id: lauxlib.h,v 1.131.1.1 2017/04/19 17:20:42 roberto Exp $
+** $Id: lauxlib.h,v 1.131 2016/12/06 14:54:31 roberto Exp $
 ** Auxiliary functions for building Lua libraries
 ** See Copyright Notice in lua.h
 */
--- texlive-bin.orig/libs/lua53/lua53-src/src/lbaselib.c
+++ texlive-bin/libs/lua53/lua53-src/src/lbaselib.c
@@ -1,5 +1,5 @@
 /*
-** $Id: lbaselib.c,v 1.314.1.1 2017/04/19 17:39:34 roberto Exp $
+** $Id: lbaselib.c,v 1.314 2016/09/05 19:06:34 roberto Exp $
 ** Basic library
 ** See Copyright Notice in lua.h
 */
--- texlive-bin.orig/libs/lua53/lua53-src/src/lbitlib.c
+++ texlive-bin/libs/lua53/lua53-src/src/lbitlib.c
@@ -1,5 +1,5 @@
 /*
-** $Id: lbitlib.c,v 1.30.1.1 2017/04/19 17:20:42 roberto Exp $
+** $Id: lbitlib.c,v 1.30 2015/11/11 19:08:09 roberto Exp $
 ** Standard library for bitwise operations
 ** See Copyright Notice in lua.h
 */
--- texlive-bin.orig/libs/lua53/lua53-src/src/lcode.c
+++ texlive-bin/libs/lua53/lua53-src/src/lcode.c
@@ -1,5 +1,5 @@
 /*
-** $Id: lcode.c,v 2.112.1.1 2017/04/19 17:20:42 roberto Exp $
+** $Id: lcode.c,v 2.112 2016/12/22 13:08:50 roberto Exp $
 ** Code generator for Lua
 ** See Copyright Notice in lua.h
 */
--- texlive-bin.orig/libs/lua53/lua53-src/src/lcode.h
+++ texlive-bin/libs/lua53/lua53-src/src/lcode.h
@@ -1,5 +1,5 @@
 /*
-** $Id: lcode.h,v 1.64.1.1 2017/04/19 17:20:42 roberto Exp $
+** $Id: lcode.h,v 1.64 2016/01/05 16:22:37 roberto Exp $
 ** Code generator for Lua
 ** See Copyright Notice in lua.h
 */
--- texlive-bin.orig/libs/lua53/lua53-src/src/lcorolib.c
+++ texlive-bin/libs/lua53/lua53-src/src/lcorolib.c
@@ -1,5 +1,5 @@
 /*
-** $Id: lcorolib.c,v 1.10.1.1 2017/04/19 17:20:42 roberto Exp $
+** $Id: lcorolib.c,v 1.10 2016/04/11 19:19:55 roberto Exp $
 ** Coroutine Library
 ** See Copyright Notice in lua.h
 */
--- texlive-bin.orig/libs/lua53/lua53-src/src/lctype.c
+++ texlive-bin/libs/lua53/lua53-src/src/lctype.c
@@ -1,5 +1,5 @@
 /*
-** $Id: lctype.c,v 1.12.1.1 2017/04/19 17:20:42 roberto Exp $
+** $Id: lctype.c,v 1.12 2014/11/02 19:19:04 roberto Exp $
 ** 'ctype' functions for Lua
 ** See Copyright Notice in lua.h
 */
--- texlive-bin.orig/libs/lua53/lua53-src/src/lctype.h
+++ texlive-bin/libs/lua53/lua53-src/src/lctype.h
@@ -1,5 +1,5 @@
 /*
-** $Id: lctype.h,v 1.12.1.1 2013/04/12 18:48:47 roberto Exp $
+** $Id: lctype.h,v 1.12 2011/07/15 12:50:29 roberto Exp $
 ** 'ctype' functions for Lua
 ** See Copyright Notice in lua.h
 */
@@ -76,7 +76,6 @@ LUAI_DDEC const lu_byte luai_ctype_[UCHA
 
 
 #else			/* }{ */
-
 /*
 ** use standard C ctypes
 */
--- texlive-bin.orig/libs/lua53/lua53-src/src/lctype.h.orig
+++ texlive-bin/libs/lua53/lua53-src/src/lctype.h.orig
@@ -1,5 +1,5 @@
 /*
-** $Id: lctype.h,v 1.12.1.1 2013/04/12 18:48:47 roberto Exp $
+** $Id: lctype.h,v 1.12 2011/07/15 12:50:29 roberto Exp $
 ** 'ctype' functions for Lua
 ** See Copyright Notice in lua.h
 */
--- texlive-bin.orig/libs/lua53/lua53-src/src/ldblib.c
+++ texlive-bin/libs/lua53/lua53-src/src/ldblib.c
@@ -1,5 +1,5 @@
 /*
-** $Id: ldblib.c,v 1.151.1.1 2017/04/19 17:20:42 roberto Exp $
+** $Id: ldblib.c,v 1.151 2015/11/23 11:29:43 roberto Exp $
 ** Interface from Lua to its debug API
 ** See Copyright Notice in lua.h
 */
--- texlive-bin.orig/libs/lua53/lua53-src/src/ldebug.c
+++ texlive-bin/libs/lua53/lua53-src/src/ldebug.c
@@ -1,5 +1,5 @@
 /*
-** $Id: ldebug.c,v 2.121.1.2 2017/07/10 17:21:50 roberto Exp $
+** $Id: ldebug.c,v 2.121 2016/10/19 12:32:10 roberto Exp $
 ** Debug Interface
 ** See Copyright Notice in lua.h
 */
@@ -653,7 +653,6 @@ l_noret luaG_runerror (lua_State *L, con
   CallInfo *ci = L->ci;
   const char *msg;
   va_list argp;
-  luaC_checkGC(L);  /* error message uses memory */
   va_start(argp, fmt);
   msg = luaO_pushvfstring(L, fmt, argp);  /* format message */
   va_end(argp);
--- texlive-bin.orig/libs/lua53/lua53-src/src/ldebug.h
+++ texlive-bin/libs/lua53/lua53-src/src/ldebug.h
@@ -1,5 +1,5 @@
 /*
-** $Id: ldebug.h,v 2.14.1.1 2017/04/19 17:20:42 roberto Exp $
+** $Id: ldebug.h,v 2.14 2015/05/22 17:45:56 roberto Exp $
 ** Auxiliary functions from Debug Interface module
 ** See Copyright Notice in lua.h
 */
--- texlive-bin.orig/libs/lua53/lua53-src/src/ldo.c
+++ texlive-bin/libs/lua53/lua53-src/src/ldo.c
@@ -1,5 +1,5 @@
 /*
-** $Id: ldo.c,v 2.157.1.1 2017/04/19 17:20:42 roberto Exp $
+** $Id: ldo.c,v 2.157 2016/12/13 15:52:21 roberto Exp $
 ** Stack and Call structure of Lua
 ** See Copyright Notice in lua.h
 */
--- texlive-bin.orig/libs/lua53/lua53-src/src/ldo.h
+++ texlive-bin/libs/lua53/lua53-src/src/ldo.h
@@ -1,5 +1,5 @@
 /*
-** $Id: ldo.h,v 2.29.1.1 2017/04/19 17:20:42 roberto Exp $
+** $Id: ldo.h,v 2.29 2015/12/21 13:02:14 roberto Exp $
 ** Stack and Call structure of Lua
 ** See Copyright Notice in lua.h
 */
--- texlive-bin.orig/libs/lua53/lua53-src/src/ldump.c
+++ texlive-bin/libs/lua53/lua53-src/src/ldump.c
@@ -1,5 +1,5 @@
 /*
-** $Id: ldump.c,v 2.37.1.1 2017/04/19 17:20:42 roberto Exp $
+** $Id: ldump.c,v 2.37 2015/10/08 15:53:49 roberto Exp $
 ** save precompiled Lua chunks
 ** See Copyright Notice in lua.h
 */
--- texlive-bin.orig/libs/lua53/lua53-src/src/lfunc.c
+++ texlive-bin/libs/lua53/lua53-src/src/lfunc.c
@@ -1,5 +1,5 @@
 /*
-** $Id: lfunc.c,v 2.45.1.1 2017/04/19 17:39:34 roberto Exp $
+** $Id: lfunc.c,v 2.45 2014/11/02 19:19:04 roberto Exp $
 ** Auxiliary functions to manipulate prototypes and closures
 ** See Copyright Notice in lua.h
 */
--- texlive-bin.orig/libs/lua53/lua53-src/src/lfunc.h
+++ texlive-bin/libs/lua53/lua53-src/src/lfunc.h
@@ -1,5 +1,5 @@
 /*
-** $Id: lfunc.h,v 2.15.1.1 2017/04/19 17:39:34 roberto Exp $
+** $Id: lfunc.h,v 2.15 2015/01/13 15:49:11 roberto Exp $
 ** Auxiliary functions to manipulate prototypes and closures
 ** See Copyright Notice in lua.h
 */
--- texlive-bin.orig/libs/lua53/lua53-src/src/lgc.c
+++ texlive-bin/libs/lua53/lua53-src/src/lgc.c
@@ -1,5 +1,5 @@
 /*
-** $Id: lgc.c,v 2.215.1.2 2017/08/31 16:15:27 roberto Exp $
+** $Id: lgc.c,v 2.215 2016/12/22 13:08:50 roberto Exp $
 ** Garbage Collector
 ** See Copyright Notice in lua.h
 */
@@ -643,9 +643,8 @@ static void clearkeys (global_State *g,
     for (n = gnode(h, 0); n < limit; n++) {
       if (!ttisnil(gval(n)) && (iscleared(g, gkey(n)))) {
         setnilvalue(gval(n));  /* remove value ... */
+        removeentry(n);  /* and remove entry from table */
       }
-      if (ttisnil(gval(n)))  /* is entry empty? */
-        removeentry(n);  /* remove entry from table */
     }
   }
 }
--- texlive-bin.orig/libs/lua53/lua53-src/src/lgc.h
+++ texlive-bin/libs/lua53/lua53-src/src/lgc.h
@@ -1,5 +1,5 @@
 /*
-** $Id: lgc.h,v 2.91.1.1 2017/04/19 17:39:34 roberto Exp $
+** $Id: lgc.h,v 2.91 2015/12/21 13:02:14 roberto Exp $
 ** Garbage Collector
 ** See Copyright Notice in lua.h
 */
--- texlive-bin.orig/libs/lua53/lua53-src/src/linit.c
+++ texlive-bin/libs/lua53/lua53-src/src/linit.c
@@ -1,5 +1,5 @@
 /*
-** $Id: linit.c,v 1.39.1.1 2017/04/19 17:20:42 roberto Exp $
+** $Id: linit.c,v 1.39 2016/12/04 20:17:24 roberto Exp $
 ** Initialization of libraries for lua.c and other clients
 ** See Copyright Notice in lua.h
 */
--- texlive-bin.orig/libs/lua53/lua53-src/src/liolib.c
+++ texlive-bin/libs/lua53/lua53-src/src/liolib.c
@@ -1,5 +1,5 @@
 /*
-** $Id: liolib.c,v 2.151.1.1 2017/04/19 17:29:57 roberto Exp $
+** $Id: liolib.c,v 2.151 2016/12/20 18:37:00 roberto Exp $
 ** Standard I/O (and system) library
 ** See Copyright Notice in lua.h
 */
@@ -209,16 +209,11 @@ static int aux_close (lua_State *L) {
 }
 
 
-static int f_close (lua_State *L) {
-  tofile(L);  /* make sure argument is an open stream */
-  return aux_close(L);
-}
-
-
 static int io_close (lua_State *L) {
   if (lua_isnone(L, 1))  /* no argument? */
     lua_getfield(L, LUA_REGISTRYINDEX, IO_OUTPUT);  /* use standard output */
-  return f_close(L);
+  tofile(L);  /* make sure argument is an open stream */
+  return aux_close(L);
 }
 
 
@@ -720,7 +715,7 @@ static const luaL_Reg iolib[] = {
 ** methods for file handles
 */
 static const luaL_Reg flib[] = {
-  {"close", f_close},
+  {"close", io_close},
   {"flush", f_flush},
   {"lines", f_lines},
   {"read", f_read},
--- texlive-bin.orig/libs/lua53/lua53-src/src/liolib.c.orig
+++ texlive-bin/libs/lua53/lua53-src/src/liolib.c.orig
@@ -1,5 +1,5 @@
 /*
-** $Id: liolib.c,v 2.151.1.1 2017/04/19 17:29:57 roberto Exp $
+** $Id: liolib.c,v 2.151 2016/12/20 18:37:00 roberto Exp $
 ** Standard I/O (and system) library
 ** See Copyright Notice in lua.h
 */
@@ -206,16 +206,11 @@ static int aux_close (lua_State *L) {
 }
 
 
-static int f_close (lua_State *L) {
-  tofile(L);  /* make sure argument is an open stream */
-  return aux_close(L);
-}
-
-
 static int io_close (lua_State *L) {
   if (lua_isnone(L, 1))  /* no argument? */
     lua_getfield(L, LUA_REGISTRYINDEX, IO_OUTPUT);  /* use standard output */
-  return f_close(L);
+  tofile(L);  /* make sure argument is an open stream */
+  return aux_close(L);
 }
 
 
@@ -717,7 +712,7 @@ static const luaL_Reg iolib[] = {
 ** methods for file handles
 */
 static const luaL_Reg flib[] = {
-  {"close", f_close},
+  {"close", io_close},
   {"flush", f_flush},
   {"lines", f_lines},
   {"read", f_read},
--- texlive-bin.orig/libs/lua53/lua53-src/src/llex.c
+++ texlive-bin/libs/lua53/lua53-src/src/llex.c
@@ -1,5 +1,5 @@
 /*
-** $Id: llex.c,v 2.96.1.1 2017/04/19 17:20:42 roberto Exp $
+** $Id: llex.c,v 2.96 2016/05/02 14:02:12 roberto Exp $
 ** Lexical Analyzer
 ** See Copyright Notice in lua.h
 */
--- texlive-bin.orig/libs/lua53/lua53-src/src/llex.h
+++ texlive-bin/libs/lua53/lua53-src/src/llex.h
@@ -1,5 +1,5 @@
 /*
-** $Id: llex.h,v 1.79.1.1 2017/04/19 17:20:42 roberto Exp $
+** $Id: llex.h,v 1.79 2016/05/02 14:02:12 roberto Exp $
 ** Lexical Analyzer
 ** See Copyright Notice in lua.h
 */
--- texlive-bin.orig/libs/lua53/lua53-src/src/llimits.h
+++ texlive-bin/libs/lua53/lua53-src/src/llimits.h
@@ -1,5 +1,5 @@
 /*
-** $Id: llimits.h,v 1.141.1.1 2017/04/19 17:20:42 roberto Exp $
+** $Id: llimits.h,v 1.141 2015/11/19 19:16:22 roberto Exp $
 ** Limits, basic types, and some other 'installation-dependent' definitions
 ** See Copyright Notice in lua.h
 */
--- texlive-bin.orig/libs/lua53/lua53-src/src/lmathlib.c
+++ texlive-bin/libs/lua53/lua53-src/src/lmathlib.c
@@ -1,5 +1,5 @@
 /*
-** $Id: lmathlib.c,v 1.119.1.1 2017/04/19 17:20:42 roberto Exp $
+** $Id: lmathlib.c,v 1.119 2016/12/22 13:08:50 roberto Exp $
 ** Standard mathematical library
 ** See Copyright Notice in lua.h
 */
--- texlive-bin.orig/libs/lua53/lua53-src/src/lmem.c
+++ texlive-bin/libs/lua53/lua53-src/src/lmem.c
@@ -1,5 +1,5 @@
 /*
-** $Id: lmem.c,v 1.91.1.1 2017/04/19 17:20:42 roberto Exp $
+** $Id: lmem.c,v 1.91 2015/03/06 19:45:54 roberto Exp $
 ** Interface to Memory Manager
 ** See Copyright Notice in lua.h
 */
--- texlive-bin.orig/libs/lua53/lua53-src/src/lmem.h
+++ texlive-bin/libs/lua53/lua53-src/src/lmem.h
@@ -1,5 +1,5 @@
 /*
-** $Id: lmem.h,v 1.43.1.1 2017/04/19 17:20:42 roberto Exp $
+** $Id: lmem.h,v 1.43 2014/12/19 17:26:14 roberto Exp $
 ** Interface to Memory Manager
 ** See Copyright Notice in lua.h
 */
--- texlive-bin.orig/libs/lua53/lua53-src/src/loadlib.c
+++ texlive-bin/libs/lua53/lua53-src/src/loadlib.c
@@ -1,5 +1,5 @@
 /*
-** $Id: loadlib.c,v 1.130.1.1 2017/04/19 17:20:42 roberto Exp $
+** $Id: loadlib.c,v 1.130 2017/01/12 17:14:26 roberto Exp $
 ** Dynamic library loader for Lua
 ** See Copyright Notice in lua.h
 **
--- texlive-bin.orig/libs/lua53/lua53-src/src/lobject.c
+++ texlive-bin/libs/lua53/lua53-src/src/lobject.c
@@ -1,5 +1,5 @@
 /*
-** $Id: lobject.c,v 2.113.1.1 2017/04/19 17:29:57 roberto Exp $
+** $Id: lobject.c,v 2.113 2016/12/22 13:08:50 roberto Exp $
 ** Some generic functions over Lua objects
 ** See Copyright Notice in lua.h
 */
@@ -435,8 +435,7 @@ const char *luaO_pushvfstring (lua_State
       }
       case 'p': {  /* a pointer */
         char buff[4*sizeof(void *) + 8]; /* should be enough space for a '%p' */
-        void *p = va_arg(argp, void *);
-        int l = lua_pointer2str(buff, sizeof(buff), p);
+        int l = l_sprintf(buff, sizeof(buff), "%p", va_arg(argp, void *));
         pushstr(L, buff, l);
         break;
       }
--- texlive-bin.orig/libs/lua53/lua53-src/src/lobject.h
+++ texlive-bin/libs/lua53/lua53-src/src/lobject.h
@@ -1,5 +1,5 @@
 /*
-** $Id: lobject.h,v 2.117.1.1 2017/04/19 17:39:34 roberto Exp $
+** $Id: lobject.h,v 2.117 2016/08/01 19:51:24 roberto Exp $
 ** Type definitions for Lua objects
 ** See Copyright Notice in lua.h
 */
--- texlive-bin.orig/libs/lua53/lua53-src/src/lopcodes.c
+++ texlive-bin/libs/lua53/lua53-src/src/lopcodes.c
@@ -1,5 +1,5 @@
 /*
-** $Id: lopcodes.c,v 1.55.1.1 2017/04/19 17:20:42 roberto Exp $
+** $Id: lopcodes.c,v 1.55 2015/01/05 13:48:33 roberto Exp $
 ** Opcodes for Lua virtual machine
 ** See Copyright Notice in lua.h
 */
--- texlive-bin.orig/libs/lua53/lua53-src/src/lopcodes.h
+++ texlive-bin/libs/lua53/lua53-src/src/lopcodes.h
@@ -1,5 +1,5 @@
 /*
-** $Id: lopcodes.h,v 1.149.1.1 2017/04/19 17:20:42 roberto Exp $
+** $Id: lopcodes.h,v 1.149 2016/07/19 17:12:21 roberto Exp $
 ** Opcodes for Lua virtual machine
 ** See Copyright Notice in lua.h
 */
--- texlive-bin.orig/libs/lua53/lua53-src/src/lopcodes.h.orig
+++ texlive-bin/libs/lua53/lua53-src/src/lopcodes.h.orig
@@ -1,5 +1,5 @@
 /*
-** $Id: lopcodes.h,v 1.149.1.1 2017/04/19 17:20:42 roberto Exp $
+** $Id: lopcodes.h,v 1.149 2016/07/19 17:12:21 roberto Exp $
 ** Opcodes for Lua virtual machine
 ** See Copyright Notice in lua.h
 */
--- texlive-bin.orig/libs/lua53/lua53-src/src/loslib.c
+++ texlive-bin/libs/lua53/lua53-src/src/loslib.c
@@ -1,5 +1,5 @@
 /*
-** $Id: loslib.c,v 1.65.1.1 2017/04/19 17:29:57 roberto Exp $
+** $Id: loslib.c,v 1.65 2016/07/18 17:58:58 roberto Exp $
 ** Standard Operating System library
 ** See Copyright Notice in lua.h
 */
@@ -293,8 +293,7 @@ static int os_date (lua_State *L) {
   else
     stm = l_localtime(&t, &tmr);
   if (stm == NULL)  /* invalid date? */
-    return luaL_error(L,
-                 "time result cannot be represented in this installation");
+    luaL_error(L, "time result cannot be represented in this installation");
   if (strcmp(s, "*t") == 0) {
     lua_createtable(L, 0, 9);  /* 9 = number of fields */
     setallfields(L, stm);
@@ -341,8 +340,7 @@ static int os_time (lua_State *L) {
     setallfields(L, &ts);  /* update fields with normalized values */
   }
   if (t != (time_t)(l_timet)t || t == (time_t)(-1))
-    return luaL_error(L,
-                  "time result cannot be represented in this installation");
+    luaL_error(L, "time result cannot be represented in this installation");
   l_pushtime(L, t);
   return 1;
 }
--- texlive-bin.orig/libs/lua53/lua53-src/src/lparser.c
+++ texlive-bin/libs/lua53/lua53-src/src/lparser.c
@@ -1,5 +1,5 @@
 /*
-** $Id: lparser.c,v 2.155.1.2 2017/04/29 18:11:40 roberto Exp $
+** $Id: lparser.c,v 2.155 2016/08/01 19:51:24 roberto Exp $
 ** Lua Parser
 ** See Copyright Notice in lua.h
 */
@@ -1392,7 +1392,7 @@ static void test_then_block (LexState *l
     luaK_goiffalse(ls->fs, &v);  /* will jump to label if condition is true */
     enterblock(fs, &bl, 0);  /* must enter block before 'goto' */
     gotostat(ls, v.t);  /* handle goto/break */
-    while (testnext(ls, ';')) {}  /* skip colons */
+    skipnoopstat(ls);  /* skip other no-op statements */
     if (block_follow(ls, 0)) {  /* 'goto' is the entire block? */
       leaveblock(fs);
       return;  /* and that is it */
--- texlive-bin.orig/libs/lua53/lua53-src/src/lparser.h
+++ texlive-bin/libs/lua53/lua53-src/src/lparser.h
@@ -1,5 +1,5 @@
 /*
-** $Id: lparser.h,v 1.76.1.1 2017/04/19 17:20:42 roberto Exp $
+** $Id: lparser.h,v 1.76 2015/12/30 18:16:13 roberto Exp $
 ** Lua Parser
 ** See Copyright Notice in lua.h
 */
--- texlive-bin.orig/libs/lua53/lua53-src/src/lprefix.h
+++ texlive-bin/libs/lua53/lua53-src/src/lprefix.h
@@ -1,5 +1,5 @@
 /*
-** $Id: lprefix.h,v 1.2.1.1 2017/04/19 17:20:42 roberto Exp $
+** $Id: lprefix.h,v 1.2 2014/12/29 16:54:13 roberto Exp $
 ** Definitions for Lua code that must come before any other header file
 ** See Copyright Notice in lua.h
 */
--- texlive-bin.orig/libs/lua53/lua53-src/src/lstate.c
+++ texlive-bin/libs/lua53/lua53-src/src/lstate.c
@@ -1,5 +1,5 @@
 /*
-** $Id: lstate.c,v 2.133.1.1 2017/04/19 17:39:34 roberto Exp $
+** $Id: lstate.c,v 2.133 2015/11/13 12:16:51 roberto Exp $
 ** Global State
 ** See Copyright Notice in lua.h
 */
--- texlive-bin.orig/libs/lua53/lua53-src/src/lstate.h
+++ texlive-bin/libs/lua53/lua53-src/src/lstate.h
@@ -1,5 +1,5 @@
 /*
-** $Id: lstate.h,v 2.133.1.1 2017/04/19 17:39:34 roberto Exp $
+** $Id: lstate.h,v 2.133 2016/12/22 13:08:50 roberto Exp $
 ** Global State
 ** See Copyright Notice in lua.h
 */
@@ -26,24 +26,6 @@
 ** 'tobefnz': all objects ready to be finalized;
 ** 'fixedgc': all objects that are not to be collected (currently
 ** only small strings, such as reserved words).
-**
-** Moreover, there is another set of lists that control gray objects.
-** These lists are linked by fields 'gclist'. (All objects that
-** can become gray have such a field. The field is not the same
-** in all objects, but it always has this name.)  Any gray object
-** must belong to one of these lists, and all objects in these lists
-** must be gray:
-**
-** 'gray': regular gray objects, still waiting to be visited.
-** 'grayagain': objects that must be revisited at the atomic phase.
-**   That includes
-**   - black objects got in a write barrier;
-**   - all kinds of weak tables during propagation phase;
-**   - all threads.
-** 'weak': tables with weak values to be cleared;
-** 'ephemeron': ephemeron tables with white->white entries;
-** 'allweak': tables with weak keys and/or weak values to be cleared.
-** The last three lists are used only during the atomic phase.
 
 */
 
--- texlive-bin.orig/libs/lua53/lua53-src/src/lstring.c
+++ texlive-bin/libs/lua53/lua53-src/src/lstring.c
@@ -1,5 +1,5 @@
 /*
-** $Id: lstring.c,v 2.56.1.1 2017/04/19 17:20:42 roberto Exp $
+** $Id: lstring.c,v 2.56 2015/11/23 11:32:51 roberto Exp $
 ** String table (keeps all strings handled by Lua)
 ** See Copyright Notice in lua.h
 */
--- texlive-bin.orig/libs/lua53/lua53-src/src/lstring.h
+++ texlive-bin/libs/lua53/lua53-src/src/lstring.h
@@ -1,5 +1,5 @@
 /*
-** $Id: lstring.h,v 1.61.1.1 2017/04/19 17:20:42 roberto Exp $
+** $Id: lstring.h,v 1.61 2015/11/03 15:36:01 roberto Exp $
 ** String table (keep all strings handled by Lua)
 ** See Copyright Notice in lua.h
 */
--- texlive-bin.orig/libs/lua53/lua53-src/src/lstrlib.c
+++ texlive-bin/libs/lua53/lua53-src/src/lstrlib.c
@@ -1,5 +1,5 @@
 /*
-** $Id: lstrlib.c,v 1.254.1.1 2017/04/19 17:29:57 roberto Exp $
+** $Id: lstrlib.c,v 1.254 2016/12/22 13:08:50 roberto Exp $
 ** Standard library for string operations and pattern-matching
 ** See Copyright Notice in lua.h
 */
@@ -879,7 +879,7 @@ static int lua_number2strx (lua_State *L
       buff[i] = toupper(uchar(buff[i]));
   }
   else if (fmt[SIZELENMOD] != 'a')
-    return luaL_error(L, "modifiers for format '%%a'/'%%A' not implemented");
+    luaL_error(L, "modifiers for format '%%a'/'%%A' not implemented");
   return n;
 }
 
@@ -1199,8 +1199,8 @@ static int getnum (const char **fmt, int
 static int getnumlimit (Header *h, const char **fmt, int df) {
   int sz = getnum(fmt, df);
   if (sz > MAXINTSIZE || sz <= 0)
-    return luaL_error(h->L, "integral size (%d) out of limits [1,%d]",
-                            sz, MAXINTSIZE);
+    luaL_error(h->L, "integral size (%d) out of limits [1,%d]",
+                     sz, MAXINTSIZE);
   return sz;
 }
 
--- texlive-bin.orig/libs/lua53/lua53-src/src/ltable.c
+++ texlive-bin/libs/lua53/lua53-src/src/ltable.c
@@ -1,5 +1,5 @@
 /*
-** $Id: ltable.c,v 2.118.1.4 2018/06/08 16:22:51 roberto Exp $
+** $Id: ltable.c,v 2.118 2016/11/07 12:38:35 roberto Exp $
 ** Lua tables (hash)
 ** See Copyright Notice in lua.h
 */
@@ -223,9 +223,7 @@ static unsigned int computesizes (unsign
   unsigned int na = 0;  /* number of elements to go to array part */
   unsigned int optimal = 0;  /* optimal size for array part */
   /* loop while keys can fill more than half of total size */
-  for (i = 0, twotoi = 1;
-       twotoi > 0 && *pna > twotoi / 2;
-       i++, twotoi *= 2) {
+  for (i = 0, twotoi = 1; *pna > twotoi / 2; i++, twotoi *= 2) {
     if (nums[i] > 0) {
       a += nums[i];
       if (a > twotoi/2) {  /* more than half elements present? */
@@ -332,34 +330,17 @@ static void setnodevector (lua_State *L,
 }
 
 
-typedef struct {
-  Table *t;
-  unsigned int nhsize;
-} AuxsetnodeT;
-
-
-static void auxsetnode (lua_State *L, void *ud) {
-  AuxsetnodeT *asn = cast(AuxsetnodeT *, ud);
-  setnodevector(L, asn->t, asn->nhsize);
-}
-
-
 void luaH_resize (lua_State *L, Table *t, unsigned int nasize,
                                           unsigned int nhsize) {
   unsigned int i;
   int j;
-  AuxsetnodeT asn;
   unsigned int oldasize = t->sizearray;
   int oldhsize = allocsizenode(t);
   Node *nold = t->node;  /* save old hash ... */
   if (nasize > oldasize)  /* array part must grow? */
     setarrayvector(L, t, nasize);
   /* create new hash part with appropriate size */
-  asn.t = t; asn.nhsize = nhsize;
-  if (luaD_rawrunprotected(L, auxsetnode, &asn) != LUA_OK) {  /* mem. error? */
-    setarrayvector(L, t, oldasize);  /* array back to its original size */
-    luaD_throw(L, LUA_ERRMEM);  /* rethrow memory error */
-  }
+  setnodevector(L, t, nhsize);
   if (nasize < oldasize) {  /* array part must shrink? */
     t->sizearray = nasize;
     /* re-insert elements from vanishing slice */
@@ -629,13 +610,13 @@ void luaH_setint (lua_State *L, Table *t
 }
 
 
-static lua_Unsigned unbound_search (Table *t, lua_Unsigned j) {
-  lua_Unsigned i = j;  /* i is zero or a present index */
+static int unbound_search (Table *t, unsigned int j) {
+  unsigned int i = j;  /* i is zero or a present index */
   j++;
   /* find 'i' and 'j' such that i is present and j is not */
   while (!ttisnil(luaH_getint(t, j))) {
     i = j;
-    if (j > l_castS2U(LUA_MAXINTEGER) / 2) {  /* overflow? */
+    if (j > cast(unsigned int, MAX_INT)/2) {  /* overflow? */
       /* table was built with bad purposes: resort to linear search */
       i = 1;
       while (!ttisnil(luaH_getint(t, i))) i++;
@@ -645,7 +626,7 @@ static lua_Unsigned unbound_search (Tabl
   }
   /* now do a binary search between them */
   while (j - i > 1) {
-    lua_Unsigned m = (i+j)/2;
+    unsigned int m = (i+j)/2;
     if (ttisnil(luaH_getint(t, m))) j = m;
     else i = m;
   }
@@ -657,7 +638,7 @@ static lua_Unsigned unbound_search (Tabl
 ** Try to find a boundary in table 't'. A 'boundary' is an integer index
 ** such that t[i] is non-nil and t[i+1] is nil (and 0 if t[1] is nil).
 */
-lua_Unsigned luaH_getn (Table *t) {
+int luaH_getn (Table *t) {
   unsigned int j = t->sizearray;
   if (j > 0 && ttisnil(&t->array[j - 1])) {
     /* there is a boundary in the array part: (binary) search for it */
--- texlive-bin.orig/libs/lua53/lua53-src/src/ltable.h
+++ texlive-bin/libs/lua53/lua53-src/src/ltable.h
@@ -1,5 +1,5 @@
 /*
-** $Id: ltable.h,v 2.23.1.2 2018/05/24 19:39:05 roberto Exp $
+** $Id: ltable.h,v 2.23 2016/12/22 13:08:50 roberto Exp $
 ** Lua tables (hash)
 ** See Copyright Notice in lua.h
 */
@@ -54,7 +54,7 @@ LUAI_FUNC void luaH_resize (lua_State *L
 LUAI_FUNC void luaH_resizearray (lua_State *L, Table *t, unsigned int nasize);
 LUAI_FUNC void luaH_free (lua_State *L, Table *t);
 LUAI_FUNC int luaH_next (lua_State *L, Table *t, StkId key);
-LUAI_FUNC lua_Unsigned luaH_getn (Table *t);
+LUAI_FUNC int luaH_getn (Table *t);
 
 
 #if defined(LUA_DEBUG)
--- texlive-bin.orig/libs/lua53/lua53-src/src/ltablib.c
+++ texlive-bin/libs/lua53/lua53-src/src/ltablib.c
@@ -1,5 +1,5 @@
 /*
-** $Id: ltablib.c,v 1.93.1.1 2017/04/19 17:20:42 roberto Exp $
+** $Id: ltablib.c,v 1.93 2016/02/25 19:41:54 roberto Exp $
 ** Library for Table Manipulation
 ** See Copyright Notice in lua.h
 */
--- texlive-bin.orig/libs/lua53/lua53-src/src/ltm.c
+++ texlive-bin/libs/lua53/lua53-src/src/ltm.c
@@ -1,5 +1,5 @@
 /*
-** $Id: ltm.c,v 2.38.1.1 2017/04/19 17:39:34 roberto Exp $
+** $Id: ltm.c,v 2.38 2016/12/22 13:08:50 roberto Exp $
 ** Tag methods
 ** See Copyright Notice in lua.h
 */
--- texlive-bin.orig/libs/lua53/lua53-src/src/ltm.h
+++ texlive-bin/libs/lua53/lua53-src/src/ltm.h
@@ -1,5 +1,5 @@
 /*
-** $Id: ltm.h,v 2.22.1.1 2017/04/19 17:20:42 roberto Exp $
+** $Id: ltm.h,v 2.22 2016/02/26 19:20:15 roberto Exp $
 ** Tag methods
 ** See Copyright Notice in lua.h
 */
--- texlive-bin.orig/libs/lua53/lua53-src/src/lua.c
+++ texlive-bin/libs/lua53/lua53-src/src/lua.c
@@ -1,5 +1,5 @@
 /*
-** $Id: lua.c,v 1.230.1.1 2017/04/19 17:29:57 roberto Exp $
+** $Id: lua.c,v 1.230 2017/01/12 17:14:26 roberto Exp $
 ** Lua stand-alone interpreter
 ** See Copyright Notice in lua.h
 */
@@ -138,7 +138,7 @@ static void print_usage (const char *bad
   "Available options are:\n"
   "  -e stat  execute string 'stat'\n"
   "  -i       enter interactive mode after executing 'script'\n"
-  "  -l name  require library 'name' into global 'name'\n"
+  "  -l name  require library 'name'\n"
   "  -v       show version information\n"
   "  -E       ignore environment variables\n"
   "  --       stop handling options\n"
--- texlive-bin.orig/libs/lua53/lua53-src/src/lua.h
+++ texlive-bin/libs/lua53/lua53-src/src/lua.h
@@ -1,5 +1,5 @@
 /*
-** $Id: lua.h,v 1.332.1.2 2018/06/13 16:58:17 roberto Exp $
+** $Id: lua.h,v 1.332 2016/12/22 15:51:20 roberto Exp $
 ** Lua - A Scripting Language
 ** Lua.org, PUC-Rio, Brazil (http://www.lua.org)
 ** See Copyright Notice at the end of this file
@@ -19,11 +19,11 @@
 #define LUA_VERSION_MAJOR	"5"
 #define LUA_VERSION_MINOR	"3"
 #define LUA_VERSION_NUM		503
-#define LUA_VERSION_RELEASE	"5"
+#define LUA_VERSION_RELEASE	"4"
 
 #define LUA_VERSION	"Lua " LUA_VERSION_MAJOR "." LUA_VERSION_MINOR
 #define LUA_RELEASE	LUA_VERSION "." LUA_VERSION_RELEASE
-#define LUA_COPYRIGHT	LUA_RELEASE "  Copyright (C) 1994-2018 Lua.org, PUC-Rio"
+#define LUA_COPYRIGHT	LUA_RELEASE "  Copyright (C) 1994-2017 Lua.org, PUC-Rio"
 #define LUA_AUTHORS	"R. Ierusalimschy, L. H. de Figueiredo, W. Celes"
 
 
@@ -460,7 +460,7 @@ struct lua_Debug {
 
 
 /******************************************************************************
-* Copyright (C) 1994-2018 Lua.org, PUC-Rio.
+* Copyright (C) 1994-2017 Lua.org, PUC-Rio.
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
--- texlive-bin.orig/libs/lua53/lua53-src/src/luac.c
+++ texlive-bin/libs/lua53/lua53-src/src/luac.c
@@ -1,5 +1,5 @@
 /*
-** $Id: luac.c,v 1.76 2018/06/19 01:32:02 lhf Exp $
+** $Id: luac.c,v 1.75 2015/03/12 01:58:27 lhf Exp $
 ** Lua compiler (saves bytecodes to files; also lists bytecodes)
 ** See Copyright Notice in lua.h
 */
@@ -206,7 +206,7 @@ int main(int argc, char* argv[])
 }
 
 /*
-** $Id: luac.c,v 1.76 2018/06/19 01:32:02 lhf Exp $
+** $Id: luac.c,v 1.75 2015/03/12 01:58:27 lhf Exp $
 ** print bytecodes
 ** See Copyright Notice in lua.h
 */
@@ -348,7 +348,6 @@ static void PrintCode(const Proto* f)
    case OP_ADD:
    case OP_SUB:
    case OP_MUL:
-   case OP_MOD:
    case OP_POW:
    case OP_DIV:
    case OP_IDIV:
--- texlive-bin.orig/libs/lua53/lua53-src/src/luaconf.h
+++ texlive-bin/libs/lua53/lua53-src/src/luaconf.h
@@ -1,5 +1,5 @@
 /*
-** $Id: luaconf.h,v 1.259.1.1 2017/04/19 17:29:57 roberto Exp $
+** $Id: luaconf.h,v 1.259 2016/12/22 13:08:50 roberto Exp $
 ** Configuration file for Lua
 ** See Copyright Notice in lua.h
 */
@@ -604,6 +604,8 @@
 */
 #if !defined(LUA_USE_C89)
 #define l_sprintf(s,sz,f,i)	snprintf(s,sz,f,i)
+/* Should we use this line ? */
+/*#define l_sprintf(s,sz,f,i)	((void)(sz), sprintf(s,f,i))*/
 #else
 #define l_sprintf(s,sz,f,i)	((void)(sz), sprintf(s,f,i))
 #endif
@@ -621,13 +623,6 @@
 
 
 /*
-@@ lua_pointer2str converts a pointer to a readable string in a
-** non-specified way.
-*/
-#define lua_pointer2str(buff,sz,p)	l_sprintf(buff,sz,"%p",p)
-
-
-/*
 @@ lua_number2strx converts a float to an hexadecimal numeric string.
 ** In C99, 'sprintf' (with format specifiers '%a'/'%A') does that.
 ** Otherwise, you can leave 'lua_number2strx' undefined and Lua will
--- texlive-bin.orig/libs/lua53/lua53-src/src/lualib.h
+++ texlive-bin/libs/lua53/lua53-src/src/lualib.h
@@ -1,5 +1,5 @@
 /*
-** $Id: lualib.h,v 1.45.1.1 2017/04/19 17:20:42 roberto Exp $
+** $Id: lualib.h,v 1.45 2017/01/12 17:14:26 roberto Exp $
 ** Lua standard libraries
 ** See Copyright Notice in lua.h
 */
--- texlive-bin.orig/libs/lua53/lua53-src/src/lundump.c
+++ texlive-bin/libs/lua53/lua53-src/src/lundump.c
@@ -1,5 +1,5 @@
 /*
-** $Id: lundump.c,v 2.44.1.1 2017/04/19 17:20:42 roberto Exp $
+** $Id: lundump.c,v 2.44 2015/11/02 16:09:30 roberto Exp $
 ** load precompiled Lua chunks
 ** See Copyright Notice in lua.h
 */
--- texlive-bin.orig/libs/lua53/lua53-src/src/lundump.h
+++ texlive-bin/libs/lua53/lua53-src/src/lundump.h
@@ -1,5 +1,5 @@
 /*
-** $Id: lundump.h,v 1.45.1.1 2017/04/19 17:20:42 roberto Exp $
+** $Id: lundump.h,v 1.45 2015/09/08 15:41:05 roberto Exp $
 ** load precompiled Lua chunks
 ** See Copyright Notice in lua.h
 */
--- texlive-bin.orig/libs/lua53/lua53-src/src/lundump.h.orig
+++ texlive-bin/libs/lua53/lua53-src/src/lundump.h.orig
@@ -1,5 +1,5 @@
 /*
-** $Id: lundump.h,v 1.45.1.1 2017/04/19 17:20:42 roberto Exp $
+** $Id: lundump.h,v 1.45 2015/09/08 15:41:05 roberto Exp $
 ** load precompiled Lua chunks
 ** See Copyright Notice in lua.h
 */
--- texlive-bin.orig/libs/lua53/lua53-src/src/lutf8lib.c
+++ texlive-bin/libs/lua53/lua53-src/src/lutf8lib.c
@@ -1,5 +1,5 @@
 /*
-** $Id: lutf8lib.c,v 1.16.1.1 2017/04/19 17:29:57 roberto Exp $
+** $Id: lutf8lib.c,v 1.16 2016/12/22 13:08:50 roberto Exp $
 ** Standard library for UTF-8 manipulation
 ** See Copyright Notice in lua.h
 */
@@ -171,7 +171,7 @@ static int byteoffset (lua_State *L) {
   }
   else {
     if (iscont(s + posi))
-      return luaL_error(L, "initial position is a continuation byte");
+      luaL_error(L, "initial position is a continuation byte");
     if (n < 0) {
        while (n < 0 && posi > 0) {  /* move back */
          do {  /* find beginning of previous character */
--- texlive-bin.orig/libs/lua53/lua53-src/src/lvm.c
+++ texlive-bin/libs/lua53/lua53-src/src/lvm.c
@@ -1,5 +1,5 @@
 /*
-** $Id: lvm.c,v 2.268.1.1 2017/04/19 17:39:34 roberto Exp $
+** $Id: lvm.c,v 2.268 2016/02/05 19:59:14 roberto Exp $
 ** Lua virtual machine
 ** See Copyright Notice in lua.h
 */
--- texlive-bin.orig/libs/lua53/lua53-src/src/lvm.h
+++ texlive-bin/libs/lua53/lua53-src/src/lvm.h
@@ -1,5 +1,5 @@
 /*
-** $Id: lvm.h,v 2.41.1.1 2017/04/19 17:20:42 roberto Exp $
+** $Id: lvm.h,v 2.41 2016/12/22 13:08:50 roberto Exp $
 ** Lua virtual machine
 ** See Copyright Notice in lua.h
 */
--- texlive-bin.orig/libs/lua53/lua53-src/src/lzio.c
+++ texlive-bin/libs/lua53/lua53-src/src/lzio.c
@@ -1,5 +1,5 @@
 /*
-** $Id: lzio.c,v 1.37.1.1 2017/04/19 17:20:42 roberto Exp $
+** $Id: lzio.c,v 1.37 2015/09/08 15:41:05 roberto Exp $
 ** Buffered streams
 ** See Copyright Notice in lua.h
 */
--- texlive-bin.orig/libs/lua53/lua53-src/src/lzio.h
+++ texlive-bin/libs/lua53/lua53-src/src/lzio.h
@@ -1,5 +1,5 @@
 /*
-** $Id: lzio.h,v 1.31.1.1 2017/04/19 17:20:42 roberto Exp $
+** $Id: lzio.h,v 1.31 2015/09/08 15:41:05 roberto Exp $
 ** Buffered streams
 ** See Copyright Notice in lua.h
 */
--- texlive-bin.orig/libs/luajit/native/Makefile.am
+++ texlive-bin/libs/luajit/native/Makefile.am
@@ -28,7 +28,6 @@ buildvm_arch.h: minilua$(EXEEXT) $(LUAJI
 	  `cat ../dynasm_flags` \
 	  -o $@ $(srcdir)/$(LUAJIT_TREE)/src/vm_$(DASM_ARCH).dasc
 
-minilua_CPPFLAGS = $(AM_CPPFLAGS) $(LUAJIT_DEFINES) `cat ../native_flags`
 nodist_minilua_SOURCES = \
 	@LUAJIT_TREE@/src/host/minilua.c
 minilua_LDADD = $(MATH_LIB)
--- texlive-bin.orig/texk/web2c/Makefile.am
+++ texlive-bin/texk/web2c/Makefile.am
@@ -237,7 +237,6 @@ include $(srcdir)/luatexdir/am/libunilib
 include $(srcdir)/luatexdir/am/luafontforge.am
 include $(srcdir)/luatexdir/am/libluatex.am
 include $(srcdir)/luatexdir/am/luaffi.am
-include $(srcdir)/luatexdir/am/luapplib.am 
 include $(srcdir)/luatexdir/am/luatex.am
 
 ## XeTeX
--- texlive-bin.orig/texk/web2c/ac/web2c.ac
+++ texlive-bin/texk/web2c/ac/web2c.ac
@@ -35,9 +35,9 @@ m4_define([kpse_tex_progs], [dnl
 [[euptex],    [yes], [yes], [e-upTeX],    [ptexenc]],
 [[aleph],     [yes], [],    [Aleph],      []],
 [[pdftex],    [yes], [yes], [pdfTeX],     [xpdf libpng]],
-[[luatex],    [yes], [],    [LuaTeX],     [libpng zziplib lua52]],
-[[luatex53],  [yes], [],    [LuaTeX53],   [libpng zziplib lua53]],
-[[luajittex], [yes], [],    [LuaJITTeX],  [libpng zziplib luajit]],
+[[luatex],    [yes], [],    [LuaTeX],     [poppler mpfr libpng zziplib lua52]],
+[[luatex53],  [yes], [],    [LuaTeX53],   [poppler mpfr libpng zziplib lua53]],
+[[luajittex], [yes], [],    [LuaJITTeX],  [poppler mpfr libpng zziplib luajit]],
 [[mp],        [yes], [],    [MetaPost],   [mpfr cairo libpng]],
 [[pmp],       [yes], [],    [pMetaPost],  [mpfr cairo libpng ptexenc]],
 [[upmp],      [yes], [],    [upMetaPost], [mpfr cairo libpng ptexenc]],
--- texlive-bin.orig/texk/web2c/configure.ac
+++ texlive-bin/texk/web2c/configure.ac
@@ -46,10 +46,13 @@ KPSE_LT_HACK
 KPSE_WEB2C_PREPARE
 m4_include([ac/web2c.ac])
 
-# XeTeX now requires C++11 because poppler does :(.
+# LuaTeX and XeTeX now require C++11 because poppler does :(.
 # XeTeX also requires C+11 because of ICU.
-if test "x$enable_xetex" = xyes; then
-  AC_MSG_NOTICE([checking for C++11, since XeTeX enabled])
+if test "x$enable_xetex" = xyes \
+   || test "x$enable_luatex" = xyes \
+   || test "x$enable_luajittex" = xyes \
+   || test "x$enable_luatex53" = xyes; then
+  AC_MSG_NOTICE([checking for C++11, since LuaTeX and/or XeTeX enabled])
   AX_CXX_COMPILE_STDCXX([11])
 fi
 
--- texlive-bin.orig/texk/web2c/luatexdir/ChangeLog
+++ texlive-bin/texk/web2c/luatexdir/ChangeLog
@@ -2,10 +2,6 @@
 	* fonts/writet1.w (t1_check_unusual_charstring): protect against
 	buffer overflow.
 
-2018-08-27 Luigi Scarso <luigi.scarso@gmail.com>
-	* dropped dependency from gmp and mpfr
-
-
 2017-11-02 Luigi Scarso <luigi.scarso@gmail.com>
 	LuaFilesystem 1.7.0
 
--- texlive-bin.orig/texk/web2c/luatexdir/NEWS
+++ texlive-bin/texk/web2c/luatexdir/NEWS
@@ -1,39 +1,4 @@
 ==============================================================
-LuaTeX 1.08 2018-08-28
-==============================================================
-
-
-(1) This release is a prelude to 1.10, the next stable iteration of LuaTeX
-after version 1.00.
-
-(2) Lua 5.3 is now considered to be default and we might use 5.4 in version
-1.10. There are no real functional changed expected. You still need to rename
-the binary for 5.3!
-
-(3) Binary mode is no longer available in MPlib but it is still available in
-stand alone MetaPost. This simplifies compilation and reduces dependencies.
-
-(4) The dependency on Poppler for pdf image inclusion has been removed. We
-now use a small dedicated library written by Pawel Jakowski. We no longer
-need c++ compilers. We're in the process of making it behave well on all
-platforms. It has been tested on intel platforms.
-
-(5) We know that there can be some (alignment) issues with the arm platform
-but these are looked into. Therefore, later this year we will release 1.09.
-Version 1.10 is planned for TeXlive. We hope that ffi works ok on intel and
-arm platforms at that point.
-
-(6) There have been some extensions to the Lua libraries and some callbacks
-have been added. Also, a few new primitives have been introduced. The
-documentation mentions the stable extensions.
-
-(7) There are the usual bug fixes and cleanups but there have been no real
-fundamental changes in the API.
-
-
-
-
-==============================================================
 LuaTeX 1.07 2018-01-17
 ==============================================================
 
--- texlive-bin.orig/texk/web2c/luatexdir/am/libluatex.am
+++ texlive-bin/texk/web2c/luatexdir/am/libluatex.am
@@ -26,10 +26,9 @@ liblua53tex_a_DEPENDENCIES = libff.a lib
 libluajittex_a_DEPENDENCIES = libff.a libluajitmisc.a
 
 libluatex_a_preflags = $(AM_CPPFLAGS) $(ZLIB_INCLUDES) $(LIBPNG_INCLUDES)
-libluatex_a_preflags += -I$(srcdir)/libmd5
+libluatex_a_preflags += $(POPPLER_INCLUDES) -I$(srcdir)/libmd5
 libluatex_a_preflags += -DpdfTeX -I$(srcdir)/luatexdir
 libluatex_a_preflags += -I$(srcdir)/luatexdir/unilib
-libluatex_a_preflags += -I$(srcdir)/luatexdir/luapplib/util
 libluatex_a_preflags += -I$(srcdir)/luatexdir/luafontloader/fontforge/inc
 libluatex_a_preflags += -DLUA_FF_LIB=1 -I$(srcdir)/luatexdir/luafontloader/fontforge/fontforge
 libluatex_a_preflags += -DSYNCTEX_ENGINE_H='<synctex-luatex.h>' -I$(srcdir)/synctexdir
@@ -44,31 +43,29 @@ liblua53tex_a_CXXFLAGS = $(WARNING_CXXFL
 libluajittex_a_CXXFLAGS = $(WARNING_CXXFLAGS)
 
 dist_libluatex_a_SOURCES = \
-	luatexdir/lua/lstrlibext.c \
-	luatexdir/lua/helpers.c \
-	luatexdir/lua/texluac.c 
+	luatexdir/lua/lstrlibext.c
 nodist_libluatex_a_SOURCES = \
+	helpers.c luastuff.c texluac.c \
 	$(dist_libluatex_sources) \
 	$(nodist_libluatex_sources)
 dist_liblua53tex_a_SOURCES = \
-	luatexdir/lua/lstrlibext.c \
-	luatexdir/lua/helpers.c \
-	luatexdir/lua/texluac.c 
+	luatexdir/lua/lstrlibext.c
 nodist_liblua53tex_a_SOURCES = \
+	helpers.c luastuff.c texluac.c \
 	$(dist_libluatex_sources) \
 	$(nodist_libluatex_sources)
 dist_libluajittex_a_SOURCES = \
 	luatexdir/lua/lauxlib_bridge.h \
-	luatexdir/lua/lstrlibext.c \
-	luatexdir/lua/texluajitc.c
+	luatexdir/lua/lstrlibext.c
 nodist_libluajittex_a_SOURCES = \
+	luastuff.c texluajitc.c \
 	$(dist_libluatex_sources) \
 	$(nodist_libluatex_sources)
 
 ## mplib "stub" backends are in mplibstuff.c
-$(libluatex_a_OBJECTS): libff.a libmplibcore.a libluamisc.a 
-$(liblua53tex_a_OBJECTS): libff.a libmplibcore.a liblua53misc.a 
-$(libluajittex_a_OBJECTS): libff.a libmplibcore.a libluajitmisc.a 
+$(libluatex_a_OBJECTS): libff.a libmplibcore.a libluamisc.a $(POPPLER_DEPEND)
+$(liblua53tex_a_OBJECTS): libff.a libmplibcore.a liblua53misc.a $(POPPLER_DEPEND)
+$(libluajittex_a_OBJECTS): libff.a libmplibcore.a libluajitmisc.a $(POPPLER_DEPEND)
 
 
 ## from luatexdir
@@ -94,77 +91,76 @@ dist_libluatex_sources += \
 ##
 luatex_dvi_ctangle = $(ctangle_silent)CWEBINPUTS=$(srcdir)/luatexdir/dvi $(ctangle)
 
-#dvigen.c: ctangle$(EXEEXT) luatexdir/dvi/dvigen.w
-#	$(luatex_dvi_ctangle) dvigen.w
+dvigen.c: ctangle$(EXEEXT) luatexdir/dvi/dvigen.w
+	$(luatex_dvi_ctangle) dvigen.w
 
-#libluatex_web += luatexdir/dvi/dvigen.w
+libluatex_web += luatexdir/dvi/dvigen.w
 
-#nodist_libluatex_sources += dvigen.c
+nodist_libluatex_sources += dvigen.c
 
 dist_libluatex_sources += \
-	luatexdir/dvi/dvigen.h \
-	luatexdir/dvi/dvigen.c
+	luatexdir/dvi/dvigen.h
 
 ## from luatexdir/font
 ##
 luatex_font_ctangle = $(ctangle_silent)CWEBINPUTS=$(srcdir)/luatexdir/font $(ctangle)
 
-# dofont.c: ctangle$(EXEEXT) luatexdir/font/dofont.w
-# 	$(luatex_font_ctangle) dofont.w
-# luafont.c: ctangle$(EXEEXT) luatexdir/font/luafont.w
-# 	$(luatex_font_ctangle) luafont.w
-# mapfile.c: ctangle$(EXEEXT) luatexdir/font/mapfile.w
-# 	$(luatex_font_ctangle) mapfile.w
-# pkin.c: ctangle$(EXEEXT) luatexdir/font/pkin.w
-# 	$(luatex_font_ctangle) pkin.w
-# sfnt.c: ctangle$(EXEEXT) luatexdir/font/sfnt.w
-# 	$(luatex_font_ctangle) sfnt.w
-# texfont.c: ctangle$(EXEEXT) luatexdir/font/texfont.w
-# 	$(luatex_font_ctangle) texfont.w
-# tfmofm.c: ctangle$(EXEEXT) luatexdir/font/tfmofm.w
-# 	$(luatex_font_ctangle) tfmofm.w
-# tounicode.c: ctangle$(EXEEXT) luatexdir/font/tounicode.w
-# 	$(luatex_font_ctangle) tounicode.w
-# tt_glyf.c: ctangle$(EXEEXT) luatexdir/font/tt_glyf.w
-# 	$(luatex_font_ctangle) tt_glyf.w
-# tt_table.c: ctangle$(EXEEXT) luatexdir/font/tt_table.w
-# 	$(luatex_font_ctangle) tt_table.w
-# vfovf.c: ctangle$(EXEEXT) luatexdir/font/vfovf.w
-# 	$(luatex_font_ctangle) vfovf.w
-# vfpacket.c: ctangle$(EXEEXT) luatexdir/font/vfpacket.w
-# 	$(luatex_font_ctangle) vfpacket.w
-# writecff.c: ctangle$(EXEEXT) luatexdir/font/writecff.w
-# 	$(luatex_font_ctangle) writecff.w
-# writeenc.c: ctangle$(EXEEXT) luatexdir/font/writeenc.w
-# 	$(luatex_font_ctangle) writeenc.w
-# writefont.c: ctangle$(EXEEXT) luatexdir/font/writefont.w
-# 	$(luatex_font_ctangle) writefont.w
-# writet1.c: ctangle$(EXEEXT) luatexdir/font/writet1.w
-# 	$(luatex_font_ctangle) writet1.w
-# writet3.c: ctangle$(EXEEXT) luatexdir/font/writet3.w
-# 	$(luatex_font_ctangle) writet3.w
-# writettf.c: ctangle$(EXEEXT) luatexdir/font/writettf.w
-# 	$(luatex_font_ctangle) writettf.w
-# writetype0.c: ctangle$(EXEEXT) luatexdir/font/writetype0.w
-# 	$(luatex_font_ctangle) writetype0.w
-# writetype2.c: ctangle$(EXEEXT) luatexdir/font/writetype2.w
-# 	$(luatex_font_ctangle) writetype2.w
-
-# libluatex_web += luatexdir/font/dofont.w luatexdir/font/luafont.w luatexdir/font/mapfile.w
-# libluatex_web += luatexdir/font/pkin.w luatexdir/font/sfnt.w 
-# libluatex_web += luatexdir/font/texfont.w luatexdir/font/tfmofm.w
-# libluatex_web += luatexdir/font/tounicode.w luatexdir/font/tt_glyf.w
-# libluatex_web += luatexdir/font/tt_table.w luatexdir/font/vfovf.w
-# libluatex_web += luatexdir/font/vfpacket.w luatexdir/font/writecff.w
-# libluatex_web += luatexdir/font/writeenc.w luatexdir/font/writefont.w
-# libluatex_web += luatexdir/font/writet1.w luatexdir/font/writet3.w
-# libluatex_web += luatexdir/font/writettf.w luatexdir/font/writetype0.w
-# libluatex_web += luatexdir/font/writetype2.w
-
-# nodist_libluatex_sources += dofont.c luafont.c mapfile.c pkin.c sfnt.c 
-# nodist_libluatex_sources += texfont.c tfmofm.c tounicode.c tt_glyf.c tt_table.c vfovf.c vfpacket.c
-# nodist_libluatex_sources += writecff.c writeenc.c writefont.c writet1.c writet3.c writettf.c
-# nodist_libluatex_sources += writetype0.c writetype2.c
+dofont.c: ctangle$(EXEEXT) luatexdir/font/dofont.w
+	$(luatex_font_ctangle) dofont.w
+luafont.c: ctangle$(EXEEXT) luatexdir/font/luafont.w
+	$(luatex_font_ctangle) luafont.w
+mapfile.c: ctangle$(EXEEXT) luatexdir/font/mapfile.w
+	$(luatex_font_ctangle) mapfile.w
+pkin.c: ctangle$(EXEEXT) luatexdir/font/pkin.w
+	$(luatex_font_ctangle) pkin.w
+sfnt.c: ctangle$(EXEEXT) luatexdir/font/sfnt.w
+	$(luatex_font_ctangle) sfnt.w
+texfont.c: ctangle$(EXEEXT) luatexdir/font/texfont.w
+	$(luatex_font_ctangle) texfont.w
+tfmofm.c: ctangle$(EXEEXT) luatexdir/font/tfmofm.w
+	$(luatex_font_ctangle) tfmofm.w
+tounicode.c: ctangle$(EXEEXT) luatexdir/font/tounicode.w
+	$(luatex_font_ctangle) tounicode.w
+tt_glyf.c: ctangle$(EXEEXT) luatexdir/font/tt_glyf.w
+	$(luatex_font_ctangle) tt_glyf.w
+tt_table.c: ctangle$(EXEEXT) luatexdir/font/tt_table.w
+	$(luatex_font_ctangle) tt_table.w
+vfovf.c: ctangle$(EXEEXT) luatexdir/font/vfovf.w
+	$(luatex_font_ctangle) vfovf.w
+vfpacket.c: ctangle$(EXEEXT) luatexdir/font/vfpacket.w
+	$(luatex_font_ctangle) vfpacket.w
+writecff.c: ctangle$(EXEEXT) luatexdir/font/writecff.w
+	$(luatex_font_ctangle) writecff.w
+writeenc.c: ctangle$(EXEEXT) luatexdir/font/writeenc.w
+	$(luatex_font_ctangle) writeenc.w
+writefont.c: ctangle$(EXEEXT) luatexdir/font/writefont.w
+	$(luatex_font_ctangle) writefont.w
+writet1.c: ctangle$(EXEEXT) luatexdir/font/writet1.w
+	$(luatex_font_ctangle) writet1.w
+writet3.c: ctangle$(EXEEXT) luatexdir/font/writet3.w
+	$(luatex_font_ctangle) writet3.w
+writettf.c: ctangle$(EXEEXT) luatexdir/font/writettf.w
+	$(luatex_font_ctangle) writettf.w
+writetype0.c: ctangle$(EXEEXT) luatexdir/font/writetype0.w
+	$(luatex_font_ctangle) writetype0.w
+writetype2.c: ctangle$(EXEEXT) luatexdir/font/writetype2.w
+	$(luatex_font_ctangle) writetype2.w
+
+libluatex_web += luatexdir/font/dofont.w luatexdir/font/luafont.w luatexdir/font/mapfile.w
+libluatex_web += luatexdir/font/pkin.w luatexdir/font/sfnt.w 
+libluatex_web += luatexdir/font/texfont.w luatexdir/font/tfmofm.w
+libluatex_web += luatexdir/font/tounicode.w luatexdir/font/tt_glyf.w
+libluatex_web += luatexdir/font/tt_table.w luatexdir/font/vfovf.w
+libluatex_web += luatexdir/font/vfpacket.w luatexdir/font/writecff.w
+libluatex_web += luatexdir/font/writeenc.w luatexdir/font/writefont.w
+libluatex_web += luatexdir/font/writet1.w luatexdir/font/writet3.w
+libluatex_web += luatexdir/font/writettf.w luatexdir/font/writetype0.w
+libluatex_web += luatexdir/font/writetype2.w
+
+nodist_libluatex_sources += dofont.c luafont.c mapfile.c pkin.c sfnt.c 
+nodist_libluatex_sources += texfont.c tfmofm.c tounicode.c tt_glyf.c tt_table.c vfovf.c vfpacket.c
+nodist_libluatex_sources += writecff.c writeenc.c writefont.c writet1.c writet3.c writettf.c
+nodist_libluatex_sources += writetype0.c writetype2.c
 
 dist_libluatex_sources += \
 	luatexdir/font/luatexfont.h \
@@ -174,54 +170,33 @@ dist_libluatex_sources += \
 	luatexdir/font/tt_glyf.h \
 	luatexdir/font/tt_table.h \
 	luatexdir/font/writecff.h \
-	luatexdir/font/writettf.h \
-	luatexdir/font/dofont.c \
-	luatexdir/font/luafont.c \
-	luatexdir/font/mapfile.c \
-	luatexdir/font/pkin.c \
-	luatexdir/font/sfnt.c \
-	luatexdir/font/texfont.c \
-	luatexdir/font/tfmofm.c \
-	luatexdir/font/tounicode.c \
-	luatexdir/font/tt_glyf.c \
-	luatexdir/font/tt_table.c \
-	luatexdir/font/vfovf.c \
-	luatexdir/font/vfpacket.c \
-	luatexdir/font/writecff.c \
-	luatexdir/font/writeenc.c \
-	luatexdir/font/writefont.c \
-	luatexdir/font/writet1.c \
-	luatexdir/font/writet3.c \
-	luatexdir/font/writettf.c \
-	luatexdir/font/writetype0.c \
-	luatexdir/font/writetype2.c 
-
+	luatexdir/font/writettf.h
 
 ## from luatexdir/image
 ##
 luatex_image_ctangle = $(ctangle_silent)CWEBINPUTS=$(srcdir)/luatexdir/image $(ctangle)
 
-#writeimg.c: ctangle$(EXEEXT) luatexdir/image/writeimg.w
-#	$(luatex_image_ctangle) writeimg.w
-#writejbig2.c: ctangle$(EXEEXT) luatexdir/image/writejbig2.w
-#	$(luatex_image_ctangle) writejbig2.w
-#writejpg.c: ctangle$(EXEEXT) luatexdir/image/writejpg.w
-#	$(luatex_image_ctangle) writejpg.w
-#writejp2.c: ctangle$(EXEEXT) luatexdir/image/writejp2.w
-#	$(luatex_image_ctangle) writejp2.w
-#writepng.c: ctangle$(EXEEXT) luatexdir/image/writepng.w
-#	$(luatex_image_ctangle) writepng.w
-#pdftoepdf.cc: ctangle$(EXEEXT) luatexdir/image/pdftoepdf.w
-#	$(luatex_image_ctangle) pdftoepdf.w - $@
-
-#libluatex_web += luatexdir/image/writeimg.w
-#libluatex_web += luatexdir/image/writejbig2.w
-#libluatex_web += luatexdir/image/writejpg.w
-#libluatex_web += luatexdir/image/writejp2.w
-#libluatex_web += luatexdir/image/writepng.w
-#libluatex_web += luatexdir/image/pdftoepdf.w
+writeimg.c: ctangle$(EXEEXT) luatexdir/image/writeimg.w
+	$(luatex_image_ctangle) writeimg.w
+writejbig2.c: ctangle$(EXEEXT) luatexdir/image/writejbig2.w
+	$(luatex_image_ctangle) writejbig2.w
+writejpg.c: ctangle$(EXEEXT) luatexdir/image/writejpg.w
+	$(luatex_image_ctangle) writejpg.w
+writejp2.c: ctangle$(EXEEXT) luatexdir/image/writejp2.w
+	$(luatex_image_ctangle) writejp2.w
+writepng.c: ctangle$(EXEEXT) luatexdir/image/writepng.w
+	$(luatex_image_ctangle) writepng.w
+pdftoepdf.cc: ctangle$(EXEEXT) luatexdir/image/pdftoepdf.w
+	$(luatex_image_ctangle) pdftoepdf.w - $@
+
+libluatex_web += luatexdir/image/writeimg.w
+libluatex_web += luatexdir/image/writejbig2.w
+libluatex_web += luatexdir/image/writejpg.w
+libluatex_web += luatexdir/image/writejp2.w
+libluatex_web += luatexdir/image/writepng.w
+libluatex_web += luatexdir/image/pdftoepdf.w
 
-#nodist_libluatex_sources += writeimg.c writejbig2.c writejpg.c writejp2.c writepng.c 
+nodist_libluatex_sources += writeimg.c writejbig2.c writejpg.c writejp2.c writepng.c pdftoepdf.cc
 
 dist_libluatex_sources += \
 	luatexdir/image/epdf.h \
@@ -231,61 +206,72 @@ dist_libluatex_sources += \
 	luatexdir/image/writejbig2.h \
 	luatexdir/image/writejpg.h \
 	luatexdir/image/writejp2.h \
-	luatexdir/image/writepng.h \
-	luatexdir/image/pdftoepdf.c \
-	luatexdir/image/writeimg.c \
-	luatexdir/image/writejbig2.c \
-	luatexdir/image/writejp2.c \
-	luatexdir/image/writejpg.c \
-	luatexdir/image/writepng.c
+	luatexdir/image/writepng.h
 
 ## from luatexdir/lang
 ##
 luatex_lang_ctangle = $(ctangle_silent)CWEBINPUTS=$(srcdir)/luatexdir/lang $(ctangle)
 
+hnjalloc.c: ctangle$(EXEEXT) luatexdir/lang/hnjalloc.w
+	$(luatex_lang_ctangle) hnjalloc.w
+hyphen.c: ctangle$(EXEEXT) luatexdir/lang/hyphen.w
+	$(luatex_lang_ctangle) hyphen.w
+texlang.c: ctangle$(EXEEXT) luatexdir/lang/texlang.w
+	$(luatex_lang_ctangle) texlang.w
+
+libluatex_web += luatexdir/lang/texlang.w luatexdir/lang/hyphen.w luatexdir/lang/hnjalloc.w
+
+nodist_libluatex_sources += texlang.c hyphen.c hnjalloc.c
+
 dist_libluatex_sources += \
 	luatexdir/lang/hnjalloc.h \
 	luatexdir/lang/hyphen.h \
-	luatexdir/lang/texlang.h \
-	luatexdir/lang/hnjalloc.c \
-	luatexdir/lang/hyphen.c \
-	luatexdir/lang/texlang.c
+	luatexdir/lang/texlang.h
 
 ## from luatexdir/lua
 ##
 luatex_lua_ctangle = $(ctangle_silent)CWEBINPUTS=$(srcdir)/luatexdir/lua $(ctangle)
 
-#helpers.c: ctangle$(EXEEXT) luatexdir/lua/helpers.w
-#	$(luatex_lua_ctangle) helpers.w
-#luainit.c: ctangle$(EXEEXT) luatexdir/lua/luainit.w
-#	$(luatex_lua_ctangle) luainit.w
+helpers.c: ctangle$(EXEEXT) luatexdir/lua/helpers.w
+	$(luatex_lua_ctangle) helpers.w
+luainit.c: ctangle$(EXEEXT) luatexdir/lua/luainit.w
+	$(luatex_lua_ctangle) luainit.w
 #luajitstuff.c: ctangle$(EXEEXT) luatexdir/lua/luajitstuff.w
 #	$(luatex_lua_ctangle) luajitstuff.w
-#luanode.c: ctangle$(EXEEXT) luatexdir/lua/luanode.w
-#	$(luatex_lua_ctangle) luanode.w
-#luastuff.c: ctangle$(EXEEXT) luatexdir/lua/luastuff.w
-#	$(luatex_lua_ctangle) luastuff.w
-#luatoken.c: ctangle$(EXEEXT) luatexdir/lua/luatoken.w
-#	$(luatex_lua_ctangle) luatoken.w
-#mplibstuff.c: ctangle$(EXEEXT) luatexdir/lua/mplibstuff.w
-#	$(luatex_lua_ctangle) mplibstuff.w
-#texluac.c: ctangle$(EXEEXT) luatexdir/lua/texluac.w
-#	$(luatex_lua_ctangle) texluac.w
-#texluajitc.c: ctangle$(EXEEXT) luatexdir/lua/texluajitc.w
-#	$(luatex_lua_ctangle) texluajitc.w
+luanode.c: ctangle$(EXEEXT) luatexdir/lua/luanode.w
+	$(luatex_lua_ctangle) luanode.w
+luastuff.c: ctangle$(EXEEXT) luatexdir/lua/luastuff.w
+	$(luatex_lua_ctangle) luastuff.w
+luatoken.c: ctangle$(EXEEXT) luatexdir/lua/luatoken.w
+	$(luatex_lua_ctangle) luatoken.w
+mplibstuff.c: ctangle$(EXEEXT) luatexdir/lua/mplibstuff.w
+	$(luatex_lua_ctangle) mplibstuff.w
+texluac.c: ctangle$(EXEEXT) luatexdir/lua/texluac.w
+	$(luatex_lua_ctangle) texluac.w
+texluajitc.c: ctangle$(EXEEXT) luatexdir/lua/texluajitc.w
+	$(luatex_lua_ctangle) texluajitc.w
 
+libluatex_web += luatexdir/lua/helpers.w
 #libluatex_web += luatexdir/lua/luainit.w luatexdir/lua/luajitstuff.w
+libluatex_web += luatexdir/lua/luainit.w 
+libluatex_web += luatexdir/lua/luanode.w luatexdir/lua/luastuff.w luatexdir/lua/luatoken.w
+libluatex_web += luatexdir/lua/mplibstuff.w
+libluatex_web += luatexdir/lua/texluac.w luatexdir/lua/texluajitc.w
+
+nodist_libluatex_sources +=  luainit.c luanode.c luatoken.c
+nodist_libluatex_sources +=  mplibstuff.c
 
 
 dist_libluatex_sources += \
 	luatexdir/lua/lcallbacklib.c \
 	luatexdir/lua/lfontlib.c \
 	luatexdir/lua/limglib.c \
-	luatexdir/lua/lpdfelib.c \
-	luatexdir/lua/lpdfscannerlib.c \
+	luatexdir/lua/lpdfscannerlib.cc \
+	luatexdir/lua/lepdflib.cc \
 	luatexdir/lua/lkpselib.c \
 	luatexdir/lua/llanglib.c \
 	luatexdir/lua/llualib.c \
+	luatexdir/lua/llfslibext.c \
 	luatexdir/lua/lnodelib.c \
 	luatexdir/lua/liolibext.c \
 	luatexdir/lua/loslibext.c \
@@ -295,79 +281,71 @@ dist_libluatex_sources += \
 	luatexdir/lua/ltexlib.c \
 	luatexdir/lua/lnewtokenlib.c \
 	luatexdir/lua/luatex-api.h \
-	luatexdir/lua/luatex-core.c \
-	luatexdir/lua/helpers.c \
-	luatexdir/lua/luainit.c \
-	luatexdir/lua/luanode.c \
-	luatexdir/lua/luastuff.c \
-	luatexdir/lua/luatoken.c \
-	luatexdir/lua/mplibstuff.c 
-
-
+	luatexdir/lua/luatex-core.c
 
 ## from luatexdir/pdf
 ##
 luatex_pdf_ctangle = $(ctangle_silent)CWEBINPUTS=$(srcdir)/luatexdir/pdf $(ctangle)
 
-# pdfpagetree.c: ctangle$(EXEEXT) luatexdir/pdf/pdfpagetree.w
-# 	$(luatex_pdf_ctangle) pdfpagetree.w
-# pdfaction.c: ctangle$(EXEEXT) luatexdir/pdf/pdfaction.w
-# 	$(luatex_pdf_ctangle) pdfaction.w
-# pdfannot.c: ctangle$(EXEEXT) luatexdir/pdf/pdfannot.w
-# 	$(luatex_pdf_ctangle) pdfannot.w
-# pdfcolorstack.c: ctangle$(EXEEXT) luatexdir/pdf/pdfcolorstack.w
-# 	$(luatex_pdf_ctangle) pdfcolorstack.w
-# pdfdest.c: ctangle$(EXEEXT) luatexdir/pdf/pdfdest.w
-# 	$(luatex_pdf_ctangle) pdfdest.w
-# pdffont.c: ctangle$(EXEEXT) luatexdir/pdf/pdffont.w
-# 	$(luatex_pdf_ctangle) pdffont.w
-# pdfgen.c: ctangle$(EXEEXT) luatexdir/pdf/pdfgen.w
-# 	$(luatex_pdf_ctangle) pdfgen.w
-# pdfglyph.c: ctangle$(EXEEXT) luatexdir/pdf/pdfglyph.w
-# 	$(luatex_pdf_ctangle) pdfglyph.w
-# pdfimage.c: ctangle$(EXEEXT) luatexdir/pdf/pdfimage.w
-# 	$(luatex_pdf_ctangle) pdfimage.w
-# pdflink.c: ctangle$(EXEEXT) luatexdir/pdf/pdflink.w
-# 	$(luatex_pdf_ctangle) pdflink.w
-# pdflistout.c: ctangle$(EXEEXT) luatexdir/pdf/pdflistout.w
-# 	$(luatex_pdf_ctangle) pdflistout.w
-# pdfliteral.c: ctangle$(EXEEXT) luatexdir/pdf/pdfliteral.w
-# 	$(luatex_pdf_ctangle) pdfliteral.w
-# pdfobj.c: ctangle$(EXEEXT) luatexdir/pdf/pdfobj.w
-# 	$(luatex_pdf_ctangle) pdfobj.w
-# pdfoutline.c: ctangle$(EXEEXT) luatexdir/pdf/pdfoutline.w
-# 	$(luatex_pdf_ctangle) pdfoutline.w
-# pdfpage.c: ctangle$(EXEEXT) luatexdir/pdf/pdfpage.w
-# 	$(luatex_pdf_ctangle) pdfpage.w
-# pdfrule.c: ctangle$(EXEEXT) luatexdir/pdf/pdfrule.w
-# 	$(luatex_pdf_ctangle) pdfrule.w
-# pdfsaverestore.c: ctangle$(EXEEXT) luatexdir/pdf/pdfsaverestore.w
-# 	$(luatex_pdf_ctangle) pdfsaverestore.w
-# pdfsetmatrix.c: ctangle$(EXEEXT) luatexdir/pdf/pdfsetmatrix.w
-# 	$(luatex_pdf_ctangle) pdfsetmatrix.w
-# pdfshipout.c: ctangle$(EXEEXT) luatexdir/pdf/pdfshipout.w
-# 	$(luatex_pdf_ctangle) pdfshipout.w
-# pdftables.c: ctangle$(EXEEXT) luatexdir/pdf/pdftables.w
-# 	$(luatex_pdf_ctangle) pdftables.w
-# pdfthread.c: ctangle$(EXEEXT) luatexdir/pdf/pdfthread.w
-# 	$(luatex_pdf_ctangle) pdfthread.w
-# pdfxform.c: ctangle$(EXEEXT) luatexdir/pdf/pdfxform.w
-# 	$(luatex_pdf_ctangle) pdfxform.w
-
-#libluatex_web += luatexdir/pdf/pdfpagetree.w luatexdir/pdf/pdfaction.w luatexdir/pdf/pdfannot.w
-#libluatex_web += luatexdir/pdf/pdfcolorstack.w luatexdir/pdf/pdfdest.w
-#libluatex_web += luatexdir/pdf/pdffont.w luatexdir/pdf/pdfgen.w luatexdir/pdf/pdfglyph.w
-#libluatex_web += luatexdir/pdf/pdfimage.w luatexdir/pdf/pdflink.w luatexdir/pdf/pdflistout.w
-#libluatex_web += luatexdir/pdf/pdfliteral.w luatexdir/pdf/pdfobj.w
-#libluatex_web += luatexdir/pdf/pdfoutline.w luatexdir/pdf/pdfpage.w luatexdir/pdf/pdfrule.w
-#libluatex_web += luatexdir/pdf/pdfsaverestore.w luatexdir/pdf/pdfsetmatrix.w
-#libluatex_web += luatexdir/pdf/pdfshipout.w luatexdir/pdf/pdftables.w
-#libluatex_web += luatexdir/pdf/pdfthread.w luatexdir/pdf/pdfxform.w
-
-#nodist_libluatex_sources += pdfpagetree.c pdfaction.c pdfannot.c pdfcolorstack.c pdfdest.c pdffont.c
-#nodist_libluatex_sources += pdfgen.c pdfglyph.c pdfimage.c pdflink.c pdflistout.c pdfliteral.c
-#nodist_libluatex_sources += pdfobj.c pdfoutline.c pdfpage.c pdfrule.c pdfsaverestore.c
-#nodist_libluatex_sources += pdfsetmatrix.c pdfshipout.c pdftables.c pdfthread.c pdfxform.c
+pdfpagetree.c: ctangle$(EXEEXT) luatexdir/pdf/pdfpagetree.w
+	$(luatex_pdf_ctangle) pdfpagetree.w
+pdfaction.c: ctangle$(EXEEXT) luatexdir/pdf/pdfaction.w
+	$(luatex_pdf_ctangle) pdfaction.w
+pdfannot.c: ctangle$(EXEEXT) luatexdir/pdf/pdfannot.w
+	$(luatex_pdf_ctangle) pdfannot.w
+pdfcolorstack.c: ctangle$(EXEEXT) luatexdir/pdf/pdfcolorstack.w
+	$(luatex_pdf_ctangle) pdfcolorstack.w
+pdfdest.c: ctangle$(EXEEXT) luatexdir/pdf/pdfdest.w
+	$(luatex_pdf_ctangle) pdfdest.w
+pdffont.c: ctangle$(EXEEXT) luatexdir/pdf/pdffont.w
+	$(luatex_pdf_ctangle) pdffont.w
+pdfgen.c: ctangle$(EXEEXT) luatexdir/pdf/pdfgen.w
+	$(luatex_pdf_ctangle) pdfgen.w
+pdfglyph.c: ctangle$(EXEEXT) luatexdir/pdf/pdfglyph.w
+	$(luatex_pdf_ctangle) pdfglyph.w
+pdfimage.c: ctangle$(EXEEXT) luatexdir/pdf/pdfimage.w
+	$(luatex_pdf_ctangle) pdfimage.w
+pdflink.c: ctangle$(EXEEXT) luatexdir/pdf/pdflink.w
+	$(luatex_pdf_ctangle) pdflink.w
+pdflistout.c: ctangle$(EXEEXT) luatexdir/pdf/pdflistout.w
+	$(luatex_pdf_ctangle) pdflistout.w
+pdfliteral.c: ctangle$(EXEEXT) luatexdir/pdf/pdfliteral.w
+	$(luatex_pdf_ctangle) pdfliteral.w
+pdfobj.c: ctangle$(EXEEXT) luatexdir/pdf/pdfobj.w
+	$(luatex_pdf_ctangle) pdfobj.w
+pdfoutline.c: ctangle$(EXEEXT) luatexdir/pdf/pdfoutline.w
+	$(luatex_pdf_ctangle) pdfoutline.w
+pdfpage.c: ctangle$(EXEEXT) luatexdir/pdf/pdfpage.w
+	$(luatex_pdf_ctangle) pdfpage.w
+pdfrule.c: ctangle$(EXEEXT) luatexdir/pdf/pdfrule.w
+	$(luatex_pdf_ctangle) pdfrule.w
+pdfsaverestore.c: ctangle$(EXEEXT) luatexdir/pdf/pdfsaverestore.w
+	$(luatex_pdf_ctangle) pdfsaverestore.w
+pdfsetmatrix.c: ctangle$(EXEEXT) luatexdir/pdf/pdfsetmatrix.w
+	$(luatex_pdf_ctangle) pdfsetmatrix.w
+pdfshipout.c: ctangle$(EXEEXT) luatexdir/pdf/pdfshipout.w
+	$(luatex_pdf_ctangle) pdfshipout.w
+pdftables.c: ctangle$(EXEEXT) luatexdir/pdf/pdftables.w
+	$(luatex_pdf_ctangle) pdftables.w
+pdfthread.c: ctangle$(EXEEXT) luatexdir/pdf/pdfthread.w
+	$(luatex_pdf_ctangle) pdfthread.w
+pdfxform.c: ctangle$(EXEEXT) luatexdir/pdf/pdfxform.w
+	$(luatex_pdf_ctangle) pdfxform.w
+
+libluatex_web += luatexdir/pdf/pdfpagetree.w luatexdir/pdf/pdfaction.w luatexdir/pdf/pdfannot.w
+libluatex_web += luatexdir/pdf/pdfcolorstack.w luatexdir/pdf/pdfdest.w
+libluatex_web += luatexdir/pdf/pdffont.w luatexdir/pdf/pdfgen.w luatexdir/pdf/pdfglyph.w
+libluatex_web += luatexdir/pdf/pdfimage.w luatexdir/pdf/pdflink.w luatexdir/pdf/pdflistout.w
+libluatex_web += luatexdir/pdf/pdfliteral.w luatexdir/pdf/pdfobj.w
+libluatex_web += luatexdir/pdf/pdfoutline.w luatexdir/pdf/pdfpage.w luatexdir/pdf/pdfrule.w
+libluatex_web += luatexdir/pdf/pdfsaverestore.w luatexdir/pdf/pdfsetmatrix.w
+libluatex_web += luatexdir/pdf/pdfshipout.w luatexdir/pdf/pdftables.w
+libluatex_web += luatexdir/pdf/pdfthread.w luatexdir/pdf/pdfxform.w
+
+nodist_libluatex_sources += pdfpagetree.c pdfaction.c pdfannot.c pdfcolorstack.c pdfdest.c pdffont.c
+nodist_libluatex_sources += pdfgen.c pdfglyph.c pdfimage.c pdflink.c pdflistout.c pdfliteral.c
+nodist_libluatex_sources += pdfobj.c pdfoutline.c pdfpage.c pdfrule.c pdfsaverestore.c
+nodist_libluatex_sources += pdfsetmatrix.c pdfshipout.c pdftables.c pdfthread.c pdfxform.c
 
 dist_libluatex_sources += \
 	luatexdir/pdf/pdfpagetree.h \
@@ -392,29 +370,7 @@ dist_libluatex_sources += \
 	luatexdir/pdf/pdftables.h \
 	luatexdir/pdf/pdfthread.h \
 	luatexdir/pdf/pdftypes.h \
-	luatexdir/pdf/pdfxform.h \
-	luatexdir/pdf/pdfaction.c \
-	luatexdir/pdf/pdfannot.c \
-	luatexdir/pdf/pdfcolorstack.c \
-	luatexdir/pdf/pdfdest.c \
-	luatexdir/pdf/pdffont.c \
-	luatexdir/pdf/pdfgen.c \
-	luatexdir/pdf/pdfglyph.c \
-	luatexdir/pdf/pdfimage.c \
-	luatexdir/pdf/pdflink.c \
-	luatexdir/pdf/pdflistout.c \
-	luatexdir/pdf/pdfliteral.c \
-	luatexdir/pdf/pdfobj.c \
-	luatexdir/pdf/pdfoutline.c \
-	luatexdir/pdf/pdfpage.c \
-	luatexdir/pdf/pdfpagetree.c \
-	luatexdir/pdf/pdfrule.c \
-	luatexdir/pdf/pdfsaverestore.c \
-	luatexdir/pdf/pdfsetmatrix.c \
-	luatexdir/pdf/pdfshipout.c \
-	luatexdir/pdf/pdftables.c \
-	luatexdir/pdf/pdfthread.c \
-	luatexdir/pdf/pdfxform.c 
+	luatexdir/pdf/pdfxform.h
 
 ################################################################################
 ################################################################################
@@ -459,79 +415,93 @@ dist_libluatex_sources += \
 ##
 luatex_tex_ctangle = $(ctangle_silent)CWEBINPUTS=$(srcdir)/luatexdir/tex $(ctangle)
 
-# align.c: ctangle$(EXEEXT) luatexdir/tex/align.w
-# 	$(luatex_tex_ctangle) align.w
-#arithmetic.c: ctangle$(EXEEXT) luatexdir/tex/arithmetic.w
-#	$(luatex_tex_ctangle) arithmetic.w
-# buildpage.c: ctangle$(EXEEXT) luatexdir/tex/buildpage.w
-# 	$(luatex_tex_ctangle) buildpage.w
-#commands.c: ctangle$(EXEEXT) luatexdir/tex/commands.w
-#	$(luatex_tex_ctangle) commands.w
-#conditional.c: ctangle$(EXEEXT) luatexdir/tex/conditional.w
-#	$(luatex_tex_ctangle) conditional.w
-#directions.c: ctangle$(EXEEXT) luatexdir/tex/directions.w
-#	$(luatex_tex_ctangle) directions.w
-#dumpdata.c: ctangle$(EXEEXT) luatexdir/tex/dumpdata.w
-#	$(luatex_tex_ctangle) dumpdata.w
-#equivalents.c: ctangle$(EXEEXT) luatexdir/tex/equivalents.w
-#	$(luatex_tex_ctangle) equivalents.w
-#errors.c: ctangle$(EXEEXT) luatexdir/tex/errors.w
-#	$(luatex_tex_ctangle) errors.w
-# expand.c: ctangle$(EXEEXT) luatexdir/tex/expand.w
-# 	$(luatex_tex_ctangle) expand.w
-# extensions.c: ctangle$(EXEEXT) luatexdir/tex/extensions.w
-# 	$(luatex_tex_ctangle) extensions.w
-#filename.c: ctangle$(EXEEXT) luatexdir/tex/filename.w
-#	$(luatex_tex_ctangle) filename.w
-#inputstack.c: ctangle$(EXEEXT) luatexdir/tex/inputstack.w
-#	$(luatex_tex_ctangle) inputstack.w
-# linebreak.c: ctangle$(EXEEXT) luatexdir/tex/linebreak.w
-# 	$(luatex_tex_ctangle) linebreak.w
-#mainbody.c: ctangle$(EXEEXT) luatexdir/tex/mainbody.w
-#	$(luatex_tex_ctangle) mainbody.w
-#maincontrol.c: ctangle$(EXEEXT) luatexdir/tex/maincontrol.w
-#	$(luatex_tex_ctangle) maincontrol.w
-#mathcodes.c: ctangle$(EXEEXT) luatexdir/tex/mathcodes.w
-#	$(luatex_tex_ctangle) mathcodes.w
-#memoryword.c: ctangle$(EXEEXT) luatexdir/tex/memoryword.w
-#	$(luatex_tex_ctangle) memoryword.w
-# mlist.c: ctangle$(EXEEXT) luatexdir/tex/mlist.w
-# 	$(luatex_tex_ctangle) mlist.w
-#nesting.c: ctangle$(EXEEXT) luatexdir/tex/nesting.w
-#	$(luatex_tex_ctangle) nesting.w
-# packaging.c: ctangle$(EXEEXT) luatexdir/tex/packaging.w
-# 	$(luatex_tex_ctangle) packaging.w
-#postlinebreak.c: ctangle$(EXEEXT) luatexdir/tex/postlinebreak.w
-#	$(luatex_tex_ctangle) postlinebreak.w
-#primitive.c: ctangle$(EXEEXT) luatexdir/tex/primitive.w
-#	$(luatex_tex_ctangle) primitive.w
-#printing.c: ctangle$(EXEEXT) luatexdir/tex/printing.w
-#	$(luatex_tex_ctangle) printing.w
-# scanning.c: ctangle$(EXEEXT) luatexdir/tex/scanning.w
-# 	$(luatex_tex_ctangle) scanning.w
-#stringpool.c: ctangle$(EXEEXT) luatexdir/tex/stringpool.w
-#	$(luatex_tex_ctangle) stringpool.w
-#texdeffont.c: ctangle$(EXEEXT) luatexdir/tex/texdeffont.w
-#	$(luatex_tex_ctangle) texdeffont.w
-# texfileio.c: ctangle$(EXEEXT) luatexdir/tex/texfileio.w
-# 	$(luatex_tex_ctangle) texfileio.w
-# texmath.c: ctangle$(EXEEXT) luatexdir/tex/texmath.w
-# 	$(luatex_tex_ctangle) texmath.w
-# texnodes.c: ctangle$(EXEEXT) luatexdir/tex/texnodes.w
-# 	$(luatex_tex_ctangle) texnodes.w
-#textcodes.c: ctangle$(EXEEXT) luatexdir/tex/textcodes.w
-#	$(luatex_tex_ctangle) textcodes.w
-# textoken.c: ctangle$(EXEEXT) luatexdir/tex/textoken.w
-# 	$(luatex_tex_ctangle) textoken.w
-
-
-
+align.c: ctangle$(EXEEXT) luatexdir/tex/align.w
+	$(luatex_tex_ctangle) align.w
+arithmetic.c: ctangle$(EXEEXT) luatexdir/tex/arithmetic.w
+	$(luatex_tex_ctangle) arithmetic.w
+buildpage.c: ctangle$(EXEEXT) luatexdir/tex/buildpage.w
+	$(luatex_tex_ctangle) buildpage.w
+commands.c: ctangle$(EXEEXT) luatexdir/tex/commands.w
+	$(luatex_tex_ctangle) commands.w
+conditional.c: ctangle$(EXEEXT) luatexdir/tex/conditional.w
+	$(luatex_tex_ctangle) conditional.w
+directions.c: ctangle$(EXEEXT) luatexdir/tex/directions.w
+	$(luatex_tex_ctangle) directions.w
+dumpdata.c: ctangle$(EXEEXT) luatexdir/tex/dumpdata.w
+	$(luatex_tex_ctangle) dumpdata.w
+equivalents.c: ctangle$(EXEEXT) luatexdir/tex/equivalents.w
+	$(luatex_tex_ctangle) equivalents.w
+errors.c: ctangle$(EXEEXT) luatexdir/tex/errors.w
+	$(luatex_tex_ctangle) errors.w
+expand.c: ctangle$(EXEEXT) luatexdir/tex/expand.w
+	$(luatex_tex_ctangle) expand.w
+extensions.c: ctangle$(EXEEXT) luatexdir/tex/extensions.w
+	$(luatex_tex_ctangle) extensions.w
+filename.c: ctangle$(EXEEXT) luatexdir/tex/filename.w
+	$(luatex_tex_ctangle) filename.w
+inputstack.c: ctangle$(EXEEXT) luatexdir/tex/inputstack.w
+	$(luatex_tex_ctangle) inputstack.w
+linebreak.c: ctangle$(EXEEXT) luatexdir/tex/linebreak.w
+	$(luatex_tex_ctangle) linebreak.w
+mainbody.c: ctangle$(EXEEXT) luatexdir/tex/mainbody.w
+	$(luatex_tex_ctangle) mainbody.w
+maincontrol.c: ctangle$(EXEEXT) luatexdir/tex/maincontrol.w
+	$(luatex_tex_ctangle) maincontrol.w
+mathcodes.c: ctangle$(EXEEXT) luatexdir/tex/mathcodes.w
+	$(luatex_tex_ctangle) mathcodes.w
+memoryword.c: ctangle$(EXEEXT) luatexdir/tex/memoryword.w
+	$(luatex_tex_ctangle) memoryword.w
+mlist.c: ctangle$(EXEEXT) luatexdir/tex/mlist.w
+	$(luatex_tex_ctangle) mlist.w
+nesting.c: ctangle$(EXEEXT) luatexdir/tex/nesting.w
+	$(luatex_tex_ctangle) nesting.w
+packaging.c: ctangle$(EXEEXT) luatexdir/tex/packaging.w
+	$(luatex_tex_ctangle) packaging.w
+postlinebreak.c: ctangle$(EXEEXT) luatexdir/tex/postlinebreak.w
+	$(luatex_tex_ctangle) postlinebreak.w
+primitive.c: ctangle$(EXEEXT) luatexdir/tex/primitive.w
+	$(luatex_tex_ctangle) primitive.w
+printing.c: ctangle$(EXEEXT) luatexdir/tex/printing.w
+	$(luatex_tex_ctangle) printing.w
+scanning.c: ctangle$(EXEEXT) luatexdir/tex/scanning.w
+	$(luatex_tex_ctangle) scanning.w
+stringpool.c: ctangle$(EXEEXT) luatexdir/tex/stringpool.w
+	$(luatex_tex_ctangle) stringpool.w
+texdeffont.c: ctangle$(EXEEXT) luatexdir/tex/texdeffont.w
+	$(luatex_tex_ctangle) texdeffont.w
+texfileio.c: ctangle$(EXEEXT) luatexdir/tex/texfileio.w
+	$(luatex_tex_ctangle) texfileio.w
+texmath.c: ctangle$(EXEEXT) luatexdir/tex/texmath.w
+	$(luatex_tex_ctangle) texmath.w
+texnodes.c: ctangle$(EXEEXT) luatexdir/tex/texnodes.w
+	$(luatex_tex_ctangle) texnodes.w
+textcodes.c: ctangle$(EXEEXT) luatexdir/tex/textcodes.w
+	$(luatex_tex_ctangle) textcodes.w
+textoken.c: ctangle$(EXEEXT) luatexdir/tex/textoken.w
+	$(luatex_tex_ctangle) textoken.w
+
+libluatex_web += luatexdir/tex/align.w luatexdir/tex/arithmetic.w luatexdir/tex/buildpage.w
+libluatex_web += luatexdir/tex/commands.w luatexdir/tex/conditional.w luatexdir/tex/directions.w
+libluatex_web += luatexdir/tex/dumpdata.w luatexdir/tex/equivalents.w luatexdir/tex/errors.w
+libluatex_web += luatexdir/tex/expand.w luatexdir/tex/extensions.w luatexdir/tex/filename.w
+libluatex_web += luatexdir/tex/inputstack.w luatexdir/tex/linebreak.w luatexdir/tex/mainbody.w
+libluatex_web += luatexdir/tex/maincontrol.w luatexdir/tex/mathcodes.w luatexdir/tex/memoryword.w
+libluatex_web += luatexdir/tex/mlist.w luatexdir/tex/nesting.w luatexdir/tex/packaging.w
+libluatex_web += luatexdir/tex/postlinebreak.w luatexdir/tex/primitive.w luatexdir/tex/printing.w
+libluatex_web += luatexdir/tex/scanning.w luatexdir/tex/stringpool.w luatexdir/tex/texdeffont.w
+libluatex_web += luatexdir/tex/texfileio.w luatexdir/tex/texmath.w luatexdir/tex/texnodes.w
+libluatex_web += luatexdir/tex/textcodes.w luatexdir/tex/textoken.w
+
+nodist_libluatex_sources += align.c arithmetic.c buildpage.c commands.c conditional.c directions.c
+nodist_libluatex_sources += dumpdata.c equivalents.c errors.c expand.c extensions.c filename.c
+nodist_libluatex_sources += inputstack.c linebreak.c mainbody.c maincontrol.c mathcodes.c
+nodist_libluatex_sources += memoryword.c mlist.c nesting.c packaging.c postlinebreak.c
+nodist_libluatex_sources += primitive.c printing.c scanning.c stringpool.c texdeffont.c
+nodist_libluatex_sources += texfileio.c texmath.c texnodes.c textcodes.c textoken.c
 
 dist_libluatex_sources += \
 	luatexdir/tex/align.h \
 	luatexdir/tex/arithmetic.h \
-	luatexdir/tex/backend.h \
-	luatexdir/tex/backend.c \
 	luatexdir/tex/buildpage.h \
 	luatexdir/tex/commands.h \
 	luatexdir/tex/conditional.h \
@@ -560,58 +530,25 @@ dist_libluatex_sources += \
 	luatexdir/tex/texfileio.h \
 	luatexdir/tex/texmath.h \
 	luatexdir/tex/texnodes.h \
-	luatexdir/tex/textcodes.h \
 	luatexdir/tex/textoken.h \
-	luatexdir/tex/align.c \
-	luatexdir/tex/arithmetic.c \
-	luatexdir/tex/buildpage.c \
-	luatexdir/tex/commands.c \
-	luatexdir/tex/conditional.c \
-	luatexdir/tex/directions.c \
-	luatexdir/tex/dumpdata.c \
-	luatexdir/tex/equivalents.c \
-	luatexdir/tex/errors.c \
-	luatexdir/tex/expand.c \
-	luatexdir/tex/extensions.c \
-	luatexdir/tex/filename.c \
-	luatexdir/tex/inputstack.c \
-	luatexdir/tex/linebreak.c \
-	luatexdir/tex/mainbody.c \
-	luatexdir/tex/maincontrol.c \
-	luatexdir/tex/mathcodes.c \
-	luatexdir/tex/memoryword.c \
-	luatexdir/tex/mlist.c \
-	luatexdir/tex/nesting.c \
-	luatexdir/tex/packaging.c \
-	luatexdir/tex/postlinebreak.c \
-	luatexdir/tex/primitive.c \
-	luatexdir/tex/printing.c \
-	luatexdir/tex/scanning.c \
-	luatexdir/tex/stringpool.c \
-	luatexdir/tex/texdeffont.c \
-	luatexdir/tex/texfileio.c \
-	luatexdir/tex/texmath.c \
-	luatexdir/tex/texnodes.c \
-	luatexdir/tex/textcodes.c \
-	luatexdir/tex/textoken.c 
-
+	luatexdir/tex/textcodes.h 
 
 ## from luatexdir/utils
 ##
 luatex_utils_ctangle = $(ctangle_silent)CWEBINPUTS=$(srcdir)/luatexdir/utils $(ctangle)
 
-#avlstuff.c: ctangle$(EXEEXT) luatexdir/utils/avlstuff.w
-#	$(luatex_utils_ctangle) avlstuff.w
-#managed-sa.c: ctangle$(EXEEXT) luatexdir/utils/managed-sa.w
-#	$(luatex_utils_ctangle) managed-sa.w
-#utils.c: ctangle$(EXEEXT) luatexdir/utils/utils.w
-#	$(luatex_utils_ctangle) utils.w
-#unistring.c: ctangle$(EXEEXT) luatexdir/utils/unistring.w
-#	$(luatex_utils_ctangle) unistring.w
+avlstuff.c: ctangle$(EXEEXT) luatexdir/utils/avlstuff.w
+	$(luatex_utils_ctangle) avlstuff.w
+managed-sa.c: ctangle$(EXEEXT) luatexdir/utils/managed-sa.w
+	$(luatex_utils_ctangle) managed-sa.w
+utils.c: ctangle$(EXEEXT) luatexdir/utils/utils.w
+	$(luatex_utils_ctangle) utils.w
+unistring.c: ctangle$(EXEEXT) luatexdir/utils/unistring.w
+	$(luatex_utils_ctangle) unistring.w
 
-#libluatex_web += luatexdir/utils/avlstuff.w luatexdir/utils/managed-sa.w luatexdir/utils/utils.w luatexdir/utils/unistring.w
+libluatex_web += luatexdir/utils/avlstuff.w luatexdir/utils/managed-sa.w luatexdir/utils/utils.w luatexdir/utils/unistring.w
 
-#nodist_libluatex_sources += avlstuff.c managed-sa.c utils.c unistring.c
+nodist_libluatex_sources += avlstuff.c managed-sa.c utils.c unistring.c
 
 dist_libluatex_sources += \
 	luatexdir/utils/avl.c \
@@ -619,11 +556,7 @@ dist_libluatex_sources += \
 	luatexdir/utils/avlstuff.h \
 	luatexdir/utils/managed-sa.h \
 	luatexdir/utils/utils.h \
-	luatexdir/utils/unistring.h \
-	luatexdir/utils/avlstuff.c \
-	luatexdir/utils/managed-sa.c \
-	luatexdir/utils/unistring.c \
-	luatexdir/utils/utils.c
+	luatexdir/utils/unistring.h
 
 ## from ../synctexdir
 ##
--- texlive-bin.orig/texk/web2c/luatexdir/am/luamisc.am
+++ texlive-bin/texk/web2c/luatexdir/am/luamisc.am
@@ -8,9 +8,9 @@
 ## and slnunicode)
 EXTRA_LIBRARIES += libluamisc.a liblua53misc.a  libluajitmisc.a
 
-libluamisc_a_DEPENDENCIES = $(ZZIPLIB_DEPEND) libluasocket.a libluaffi.a libluapplib.a
-liblua53misc_a_DEPENDENCIES = $(ZZIPLIB_DEPEND) liblua53socket.a liblua53ffi.a liblua53pplib.a
-libluajitmisc_a_DEPENDENCIES = $(ZZIPLIB_DEPEND) libluajitsocket.a libluajitpplib.a
+libluamisc_a_DEPENDENCIES = $(ZZIPLIB_DEPEND) libluasocket.a libluaffi.a
+liblua53misc_a_DEPENDENCIES = $(ZZIPLIB_DEPEND) liblua53socket.a liblua53ffi.a
+libluajitmisc_a_DEPENDENCIES = $(ZZIPLIB_DEPEND) libluajitsocket.a
 
 $(libluamisc_a_OBJECTS): $(libluamisc_a_DEPENDENCIES)
 $(liblua53misc_a_OBJECTS): $(liblua53misc_a_DEPENDENCIES)
--- texlive-bin.orig/texk/web2c/luatexdir/am/luatex.am
+++ texlive-bin/texk/web2c/luatexdir/am/luatex.am
@@ -42,11 +42,11 @@ endif LUAJITTEX
 EXTRA_PROGRAMS += luatex luatex53 luajittex
 
 # Force Automake to use CXXLD for linking
-#nodist_EXTRA_luatex_SOURCES = dummy.cxx
-#nodist_EXTRA_luatex53_SOURCES = dummy.cxx
-#nodist_EXTRA_luajittex_SOURCES = dummy.cxx
+nodist_EXTRA_luatex_SOURCES = dummy.cxx
+nodist_EXTRA_luatex53_SOURCES = dummy.cxx
+nodist_EXTRA_luajittex_SOURCES = dummy.cxx
 
-luatex_preflags = $(AM_CPPFLAGS) $(ZLIB_INCLUDES) $(LIBPNG_INCLUDES) 
+luatex_preflags = $(AM_CPPFLAGS) $(ZLIB_INCLUDES) $(LIBPNG_INCLUDES) $(POPPLER_INCLUDES) 
 luatex_postflags = -I$(srcdir)/libmd5 -DpdfTeX -I$(srcdir)/luatexdir -I$(srcdir)/mplibdir
 luatex_postflags += -Dextra_version_info=`date +-%Y%m%d%H`
 luatex_postflags += -I$(srcdir)/synctexdir -DSYNCTEX_ENGINE_H='<synctex-luatex.h>'
@@ -64,15 +64,14 @@ luatex_LDFLAGS = -export-dynamic
 luatex53_LDFLAGS = -export-dynamic
 luajittex_LDFLAGS = -export-dynamic $(LUAJIT_LDEXTRA)
 
-#luatex_postldadd = libmplibcore.a $(MPFR_LIBS) $(GMP_LIBS) 
-luatex_postldadd = libmplibcore.a 
-luatex_postldadd += $(ZZIPLIB_LIBS) $(LIBPNG_LIBS) $(ZLIB_LIBS) 
+luatex_postldadd = libmplibcore.a $(MPFR_LIBS) $(GMP_LIBS) 
+luatex_postldadd += $(ZZIPLIB_LIBS) $(LIBPNG_LIBS) $(ZLIB_LIBS) $(POPPLER_LIBS)
 luatex_postldadd += $(LDADD) libmputil.a libunilib.a libmd5.a $(lua_socketlibs)
 
 
-luatex_LDADD = libluatex.a libff.a libluamisc.a libluasocket.a libluaffi.a libluapplib.a $(LUA_LIBS) $(luatex_postldadd)
-luatex53_LDADD = liblua53tex.a libff.a liblua53misc.a liblua53socket.a liblua53ffi.a liblua53pplib.a $(LUA_LUA53_LIBS) $(luatex_postldadd)
-luajittex_LDADD = libluajittex.a libff.a libluajitmisc.a libluajitsocket.a libluajitpplib.a $(LUAJIT_LIBS) $(luatex_postldadd)
+luatex_LDADD = libluatex.a libff.a libluamisc.a libluasocket.a libluaffi.a $(LUA_LIBS) $(luatex_postldadd)
+luatex53_LDADD = liblua53tex.a libff.a liblua53misc.a liblua53socket.a liblua53ffi.a $(LUA_LUA53_LIBS) $(luatex_postldadd)
+luajittex_LDADD = libluajittex.a libff.a libluajitmisc.a libluajitsocket.a $(LUAJIT_LIBS) $(luatex_postldadd)
 
 luatex_depend = $(proglib) $(KPATHSEA_DEPEND) $(LIBPNG_DEPEND) libmputil.a libmd5.a
 luatex_DEPENDENCIES = $(luatex_depend) libluatex.a
--- texlive-bin.orig/texk/web2c/luatexdir/dvi/dvigen.h
+++ texlive-bin/texk/web2c/luatexdir/dvi/dvigen.h
@@ -21,34 +21,166 @@
 #ifndef DVIGEN_H
 #  define DVIGEN_H
 
-/* todo: move initialization from mainbody to ensure_open */
+extern int total_pages;
+extern scaled max_v;
+extern scaled max_h;
+extern int max_push;
+extern int last_bop;
+extern int dead_cycles;
+extern boolean doing_leaders;
+extern int oval, ocmd;
+extern int lq, lr;
+extern int cur_s;
+
+typedef int dvi_index;          /* an index into the output buffer */
 
 extern int dvi_buf_size;
 extern eight_bits *dvi_buf;     /* 0 is unused */
+extern dvi_index half_buf;
+extern dvi_index dvi_limit;
+extern dvi_index dvi_ptr;
+extern int dvi_offset;
+extern int dvi_gone;
+
+/*
+To put a byte in the buffer without paying the cost of invoking a procedure
+each time, we use the macro |dvi_out|.
+*/
+
+#  define dvi_out(A) do {                       \
+	dvi_buf[dvi_ptr++]=(eight_bits)(A);	\
+    if (dvi_ptr==dvi_limit) dvi_swap();         \
+  } while (0)
+
+extern void dvi_swap(void);
+extern void dvi_four(int x);
+extern void dvi_push(void);
+extern void dvi_pop(int l);
+extern void out_cmd(void);
+extern void dvi_font_def(internal_font_number f);
+
+#  define dvi_set(A,B)  do {                    \
+    oval=A; ocmd=set1; out_cmd(); dvi.h += (B); \
+  } while (0)
+
+#  define dvi_put(A)  do {                      \
+    oval=A; ocmd=put1; out_cmd();               \
+  } while (0)
+
+#  define location(A) varmem[(A)+1].cint
+
+extern halfword down_ptr, right_ptr;    /* heads of the down and right stacks */
+
+/*
+The |vinfo| fields in the entries of the down stack or the right stack
+have six possible settings: |y_here| or |z_here| mean that the \.{DVI}
+command refers to |y| or |z|, respectively (or to |w| or |x|, in the
+case of horizontal motion); |yz_OK| means that the \.{DVI} command is
+\\{down} (or \\{right}) but can be changed to either |y| or |z| (or
+to either |w| or |x|); |y_OK| means that it is \\{down} and can be changed
+to |y| but not |z|; |z_OK| is similar; and |d_fixed| means it must stay
+\\{down}.
+
+The four settings |yz_OK|, |y_OK|, |z_OK|, |d_fixed| would not need to
+be distinguished from each other if we were simply solving the
+digit-subscripting problem mentioned above. But in \TeX's case there is
+a complication because of the nested structure of |push| and |pop|
+commands. Suppose we add parentheses to the digit-subscripting problem,
+redefining hits so that $\delta_y\ldots \delta_y$ is a hit if all $y$'s between
+the $\delta$'s are enclosed in properly nested parentheses, and if the
+parenthesis level of the right-hand $\delta_y$ is deeper than or equal to
+that of the left-hand one. Thus, `(' and `)' correspond to `|push|'
+and `|pop|'. Now if we want to assign a subscript to the final 1 in the
+sequence
+$$2_y\,7_d\,1_d\,(\,8_z\,2_y\,8_z\,)\,1$$
+we cannot change the previous $1_d$ to $1_y$, since that would invalidate
+the $2_y\ldots2_y$ hit. But we can change it to $1_z$, scoring a hit
+since the intervening $8_z$'s are enclosed in parentheses.
+*/
+
+typedef enum {
+    y_here = 1,                 /* |vinfo| when the movement entry points to a |y| command */
+    z_here = 2,                 /* |vinfo| when the movement entry points to a |z| command */
+    yz_OK = 3,                  /* |vinfo| corresponding to an unconstrained \\{down} command */
+    y_OK = 4,                   /* |vinfo| corresponding to a \\{down} that can't become a |z| */
+    z_OK = 5,                   /* |vinfo| corresponding to a \\{down} that can't become a |y| */
+    d_fixed = 6,                /* |vinfo| corresponding to a \\{down} that can't change */
+} movement_codes;
+
+/* As we search through the stack, we are in one of three states,
+   |y_seen|, |z_seen|, or |none_seen|, depending on whether we have
+   encountered |y_here| or |z_here| nodes. These states are encoded as
+   multiples of 6, so that they can be added to the |info| fields for quick
+   decision-making. */
+
+#  define none_seen 0           /* no |y_here| or |z_here| nodes have been encountered yet */
+#  define y_seen 6              /* we have seen |y_here| but not |z_here| */
+#  define z_seen 12             /* we have seen |z_here| but not |y_here| */
+
+extern void movement(scaled w, eight_bits o);
+extern void prune_movements(int l);
+
+/*
+The actual distances by which we want to move might be computed as the
+sum of several separate movements. For example, there might be several
+glue nodes in succession, or we might want to move right by the width of
+some box plus some amount of glue. More importantly, the baselineskip
+distances are computed in terms of glue together with the depth and
+height of adjacent boxes, and we want the \.{DVI} file to lump these
+three quantities together into a single motion.
+
+Therefore, \TeX\ maintains two pairs of global variables: |dvi.h| and |dvi.v|
+are the |h| and |v| coordinates corresponding to the commands actually
+output to the \.{DVI} file, while |cur.h| and |cur.v| are the coordinates
+corresponding to the current state of the output routines. Coordinate
+changes will accumulate in |cur.h| and |cur.v| without being reflected
+in the output, until such a change becomes necessary or desirable; we
+can call the |movement| procedure whenever we want to make |dvi.h=pos.h|
+or |dvi.v=pos.v|.
+
+The current font reflected in the \.{DVI} output is called |dvi_f|;
+there is no need for a `\\{cur\_f}' variable.
+
+The depth of nesting of |hlist_out| and |vlist_out| is called |cur_s|;
+this is essentially the depth of |push| commands in the \.{DVI} output.
+*/
+
+#  define synch_h(p) do {                       \
+    if (p.h != dvi.h) {                         \
+      movement(p.h - dvi.h, right1);            \
+      dvi.h = p.h;                              \
+    }                                           \
+  } while (0)
+
+#  define synch_v(p) do {                       \
+    if (p.v != dvi.v) {                         \
+      movement(dvi.v - p.v, down1);             \
+      dvi.v = p.v;                              \
+    }                                           \
+  } while (0)
+
+#  define synch_dvi_with_pos(p) do {synch_h(p); synch_v(p); } while (0)
+
+#  define billion 1000000000.0
+
+#  define vet_glue(A) do { glue_temp=A;         \
+    if (glue_temp>billion)                      \
+      glue_temp=billion;                        \
+    else if (glue_temp<-billion)                \
+      glue_temp=-billion;                       \
+  } while (0)
 
-/*tex Housekeeping.  */
+extern scaledpos dvi;
 
-extern void dvi_open_file(PDF pdf);
-extern void dvi_write_header(PDF pdf);
-extern void dvi_finish_file(PDF pdf, int fatal_error);
-extern void dvi_begin_page(PDF pdf);
-extern void dvi_end_page(PDF pdf);
+extern void dvi_special(PDF pdf, halfword p);
 
-/*tex Specific injections. */
+extern void ensure_dvi_header_written(PDF pdf);
+extern void finish_dvi_file(PDF pdf, int version, int revision);
 
 extern void dvi_place_glyph(PDF pdf, internal_font_number f, int c, int ex);
 extern void dvi_place_rule(PDF pdf, halfword q, scaledpos size);
-extern void dvi_special(PDF pdf, halfword p);
 
-/*tex List handling (and nesting). */
-
-extern void dvi_push_list(PDF pdf, scaledpos *saved_pos, int *saved_loc);
-extern void dvi_pop_list(PDF pdf, scaledpos *saved_pos, int *saved_loc);
-extern void dvi_set_reference_point(PDF pdf, posstructure *refpoint);
-
-/*tex Status information used in |lstatslib|. Not that useful. */
-
-extern int dvi_get_status_ptr(PDF pdf);
-extern int dvi_get_status_gone(PDF pdf);
+extern void dvi_begin_page(PDF pdf);
+extern void dvi_end_page(PDF pdf);
 
 #endif
--- texlive-bin.orig/texk/web2c/luatexdir/font/luatexfont.h
+++ texlive-bin/texk/web2c/luatexdir/font/luatexfont.h
@@ -1,4 +1,4 @@
-/*
+/* luatexfont.h --- General font definitions
 
    Copyright 2008-2013 Taco Hoekwater <taco@luatex.org>
 
@@ -15,36 +15,45 @@
    License for more details.
 
    You should have received a copy of the GNU General Public License along
-   with LuaTeX; if not, see <http://www.gnu.org/licenses/>.
+   with LuaTeX; if not, see <http://www.gnu.org/licenses/>. */
 
-*/
 
 #ifndef LUATEXFONT_H
+#  define LUATEXFONT_H
 
-#define LUATEXFONT_H
+#  include "ptexlib.h"
+#  ifndef pdfTeX
+#    define pdfTeX
+#    include "sfnt.h"           /* which wants that pdfTeX is defined */
+#    undef pdfTeX
+#  else
+#    include "sfnt.h"
+#  endif
+
+/**********************************************************************/
+
+#  define ASCENT_CODE       0
+#  define CAPHEIGHT_CODE    1
+#  define DESCENT_CODE      2
+#  define ITALIC_ANGLE_CODE 3
+#  define STEMV_CODE        4
+#  define XHEIGHT_CODE      5
+#  define FONTBBOX1_CODE    6
+#  define FONTBBOX2_CODE    7
+#  define FONTBBOX3_CODE    8
+#  define FONTBBOX4_CODE    9
+#  define FONTNAME_CODE     10
+#  define GEN_KEY_NUM       (XHEIGHT_CODE + 1)
+#  define MAX_KEY_CODE      (FONTBBOX1_CODE + 1)
+#  define INT_KEYS_NUM      (FONTBBOX4_CODE + 1)
+#  define FONT_KEYS_NUM     (FONTNAME_CODE + 1)
+
+#  define FD_FLAGS_NOT_SET_IN_MAPLINE -1
+#  define FD_FLAGS_DEFAULT_EMBED  4     /* a symbol font */
+#  define FD_FLAGS_DEFAULT_NON_EMBED 0x22
+                                        /* a nonsymbolic serif font */
 
-#include "ptexlib.h"
-#include "sfnt.h"
-
-#define ASCENT_CODE       0
-#define CAPHEIGHT_CODE    1
-#define DESCENT_CODE      2
-#define ITALIC_ANGLE_CODE 3
-#define STEMV_CODE        4
-#define XHEIGHT_CODE      5
-#define FONTBBOX1_CODE    6
-#define FONTBBOX2_CODE    7
-#define FONTBBOX3_CODE    8
-#define FONTBBOX4_CODE    9
-#define FONTNAME_CODE     10
-#define GEN_KEY_NUM       (XHEIGHT_CODE + 1)
-#define MAX_KEY_CODE      (FONTBBOX1_CODE + 1)
-#define INT_KEYS_NUM      (FONTBBOX4_CODE + 1)
-#define FONT_KEYS_NUM     (FONTNAME_CODE + 1)
-
-#define FD_FLAGS_NOT_SET_IN_MAPLINE -1
-#define FD_FLAGS_DEFAULT_EMBED  4          /* a symbol font */
-#define FD_FLAGS_DEFAULT_NON_EMBED 0x22    /* a nonsymbolic serif font */
+/**********************************************************************/
 
 typedef struct {
     const char *pdfname;
@@ -54,59 +63,60 @@ typedef struct {
 
 extern const key_entry font_key[FONT_KEYS_NUM];
 
-#include "mapfile.h"
+#  include "mapfile.h"
 
 typedef struct {
-    int val;                         /* value */
-    boolean set;                     /* true if parameter has been set */
+    int val;                    /* value */
+    boolean set;                /* true if parameter has been set */
 } intparm;
 
 typedef struct {
-    int fe_objnum;                   /* object number */
-    char *name;                      /* encoding file name */
-    char **glyph_names;              /* array of glyph names */
-    struct avl_table *tx_tree;       /* tree of encoding positions marked as used by TeX */
+    int fe_objnum;              /* object number */
+    char *name;                 /* encoding file name */
+    char **glyph_names;         /* array of glyph names */
+    struct avl_table *tx_tree;  /* tree of encoding positions marked as used by TeX */
 } fe_entry;
 
 typedef struct fd_entry_ {
-    int fd_objnum;                   /* object number of the font descriptor object */
-    char *fontname;                  /* /FontName (without subset tag) */
-    char *subset_tag;                /* 6-character subset tag */
+    int fd_objnum;              /* object number of the font descriptor object */
+    char *fontname;             /* /FontName (without subset tag) */
+    char *subset_tag;           /* 6-character subset tag */
     boolean ff_found;
-    int ff_objnum;                   /* object number of the font program stream */
-    boolean all_glyphs;              /* embed all glyphs? */
+    int ff_objnum;              /* object number of the font program stream */
+    boolean all_glyphs;         /* embed all glyphs? */
     boolean write_ttf_glyph_names;
     intparm font_dim[FONT_KEYS_NUM];
-    fe_entry *fe;                    /* pointer to encoding structure */
-    char **builtin_glyph_names;      /* builtin encoding as read from the Type1 font file */
-    fm_entry *fm;                    /* pointer to font map structure */
-    struct avl_table *tx_tree;       /* tree of non-reencoded TeX characters marked as used */
-    struct avl_table *gl_tree;       /* tree of all marked glyphs */
-    internal_font_number tex_font;   /* needed for variable */
+    fe_entry *fe;               /* pointer to encoding structure */
+    char **builtin_glyph_names; /* builtin encoding as read from the Type1 font file */
+    fm_entry *fm;               /* pointer to font map structure */
+    struct avl_table *tx_tree;  /* tree of non-reencoded TeX characters marked as used */
+    struct avl_table *gl_tree;  /* tree of all marked glyphs */
+    internal_font_number tex_font;      /* needed for variable */
 } fd_entry;
 
 typedef struct fo_entry_ {
-    int fo_objnum;                   /* object number of the font dictionary */
-    internal_font_number tex_font;   /* needed only for \pdffontattr{} */
-    fm_entry *fm;                    /* pointer to font map structure for this font dictionary */
-    fd_entry *fd;                    /* pointer to /FontDescriptor object structure */
-    fe_entry *fe;                    /* pointer to encoding structure */
-    int cw_objnum;                   /* object number of the font program object */
-    int first_char;                  /* first character used in this font */
-    int last_char;                   /* last character used in this font */
-    struct avl_table *tx_tree;       /* tree of non-reencoded TeX characters marked as used */
-    int tounicode_objnum;            /* object number of ToUnicode */
+    int fo_objnum;              /* object number of the font dictionary */
+    internal_font_number tex_font;      /* needed only for \pdffontattr{} */
+    fm_entry *fm;               /* pointer to font map structure for this font dictionary */
+    fd_entry *fd;               /* pointer to /FontDescriptor object structure */
+    fe_entry *fe;               /* pointer to encoding structure */
+    int cw_objnum;              /* object number of the font program object */
+    int first_char;             /* first character used in this font */
+    int last_char;              /* last character used in this font */
+    struct avl_table *tx_tree;  /* tree of non-reencoded TeX characters marked as used */
+    int tounicode_objnum;       /* object number of ToUnicode */
 } fo_entry;
 
 typedef struct {
-    char *name;                      /* glyph name */
-    long code;                       /* -1 = undefined; -2 = multiple codes, stored as string in unicode_seq; otherwise unicode value */
-    char *unicode_seq;               /* multiple unicode sequence */
+    char *name;                 /* glyph name */
+    long code;                  /* -1 = undefined; -2 = multiple codes, stored
+                                   as string in unicode_seq; otherwise unicode value */
+    char *unicode_seq;          /* multiple unicode sequence */
 } glyph_unicode_entry;
 
-typedef struct glw_entry_ {          /* subset glyphs for inclusion in CID-based fonts */
-    unsigned int id;                 /* glyph CID */
-    signed int wd;                   /* glyph width in 1/1000 em parts */
+typedef struct glw_entry_ {     /* subset glyphs for inclusion in CID-based fonts */
+    unsigned int id;            /* glyph CID */
+    signed int wd;              /* glyph width in 1/1000 em parts */
 } glw_entry;
 
 typedef struct {
@@ -114,18 +124,19 @@ typedef struct {
     halfword *raster;
 } chardesc;
 
-#include "texfont.h"
+/**********************************************************************/
 
-/* tounicode.c */
+#  include "texfont.h"
 
+/* tounicode.c */
 int write_cid_tounicode(PDF, fo_entry *, internal_font_number);
 void glyph_unicode_free(void);
 void def_tounicode(str_number, str_number);
 int write_tounicode(PDF, char **, char *);
 
 /* vfpacket.c */
-
-void replace_packet_fonts(internal_font_number f, int *old_fontid, int *new_fontid, int count);
+void replace_packet_fonts(internal_font_number f, int *old_fontid,
+                          int *new_fontid, int count);
 int *packet_local_fonts(internal_font_number f, int *num);
 
 int packet_cur_s;               /* current |do_vf_packet()| recursion level */
@@ -133,15 +144,12 @@ int packet_stack_ptr;           /* point
 vf_struct *new_vfstruct(void);
 
 /* writecff.c */
-
 void writetype1w(PDF pdf, fd_entry * fd);
 
 /* writetype0.c */
-
 void writetype0(PDF pdf, fd_entry * fd);
 
 /* writefont.c */
-
 void do_pdf_font(PDF, internal_font_number);
 fd_entry *lookup_fd_entry(char *);
 fd_entry *new_fd_entry(internal_font_number);
@@ -149,7 +157,6 @@ void write_fontstuff(PDF);
 void register_fd_entry(fd_entry * fd);
 
 /* writet1.c */
-
 boolean t1_subset(char *, char *, unsigned char *);
 char **load_enc_file(char *);
 void writet1(PDF, fd_entry *);
@@ -157,40 +164,36 @@ void t1_free(void);
 extern int t1_length1, t1_length2, t1_length3;
 
 /* writetype2.c */
-
 boolean writetype2(PDF, fd_entry *);
 extern unsigned long cidtogid_obj;
+pdf_obj *pdf_new_stream(void);
+void pdf_add_stream(pdf_obj * stream, unsigned char *buf, long len);
+void pdf_release_obj(pdf_obj * stream);
 unsigned long ttc_read_offset(sfnt * sfont, int ttc_idx, fd_entry *fd);
 
 /* writeenc.c */
-
 fe_entry *get_fe_entry(char *);
 void enc_free(void);
 void write_fontencodings(PDF pdf);
 
 /* writettf.c */
-
 void writettf(PDF, fd_entry *);
 void writeotf(PDF, fd_entry *);
 void ttf_free(void);
 extern int ttf_length;
 
 /* pkin.c */
-
 int readchar(boolean, chardesc *);
 
 /* macnames.c */
-
 extern char notdef[];
 
 /* vfovf.c */
-
 internal_font_number letter_space_font(internal_font_number f, int e, boolean nolig);
 void pdf_check_vf(internal_font_number f);
 internal_font_number copy_font_info(internal_font_number f);
 
 /* writet3.c */
-
 extern FILE *t3_file;
 void writet3(PDF, internal_font_number);
 
@@ -198,11 +201,12 @@ extern unsigned char *t3_buffer;
 extern int t3_size;
 extern int t3_curbyte;
 
-#define t3_read_file() readbinfile(t3_file, &t3_buffer, &t3_size)
-#define t3_close()     xfclose(t3_file, cur_file_name)
-#define t3_getchar()   t3_buffer[t3_curbyte++]
-#define t3_eof()       (t3_curbyte>t3_size)
-#define t3_prefix(s)   (!strncmp(t3_line_array, s, strlen(s)))
-#define t3_putchar(c)  pdfout(c)
+#  define t3_read_file() readbinfile(t3_file, &t3_buffer, &t3_size)
+#  define t3_close()     xfclose(t3_file, cur_file_name)
+#  define t3_getchar()   t3_buffer[t3_curbyte++]
+#  define t3_eof()       (t3_curbyte>t3_size)
+
+#  define t3_prefix(s)   (!strncmp(t3_line_array, s, strlen(s)))
+#  define t3_putchar(c)  pdfout(c)
 
-#endif
+#endif                          /* LUATEXFONT_H */
--- texlive-bin.orig/texk/web2c/luatexdir/font/mapfile.h
+++ texlive-bin/texk/web2c/luatexdir/font/mapfile.h
@@ -98,6 +98,13 @@ typedef struct {
 
 /**********************************************************************/
 
+#  define FONT_SLANT_MIN   -2000
+#  define FONT_SLANT_MAX    2000
+#  define FONT_EXTEND_MIN  -5000
+#  define FONT_EXTEND_MAX   5000
+
+/**********************************************************************/
+
 fm_entry *getfontmap(char *tfm_name);
 void fm_free(void);
 ff_entry *check_ff_exist(char *, boolean);
--- texlive-bin.orig/texk/web2c/luatexdir/font/sfnt.h
+++ texlive-bin/texk/web2c/luatexdir/font/sfnt.h
@@ -28,12 +28,11 @@
 #  endif                        /* HAVE_CONFIG_H_ */
 
 /* Data Types as described in Apple's TTRefMan */
-
-/*typedef unsigned char BYTE;*/ /* defined in pdfgen.h */
+typedef unsigned char BYTE;
 typedef signed char ICHAR;
 typedef unsigned short USHORT;
 typedef signed short SHORT;
-/*typedef unsigned long ULONG;*//* defined in pdfgen.h */
+typedef unsigned long ULONG;
 typedef signed long LONG;
 typedef unsigned long Fixed;    /* 16.16-bit signed fixed-point number */
 typedef short FWord;
@@ -71,16 +70,40 @@ struct sfnt_table_directory {
 typedef struct {
     int type;
     struct sfnt_table_directory *directory;
+#  ifdef XETEX
+    FT_Face ft_face;
+    long loc;
+#  elif defined(pdfTeX)
     BYTE *buffer;
     long buflen;
     long loc;
+#  else
+    FILE *stream;
+#  endif
 } sfnt;
 
 /* Convert sfnt "fixed" type to double */
-
 #  define fixed(a) ((double)((a)%0x10000L)/(double)(0x10000L) + \
  (a)/0x10000L - (((a)/0x10000L > 0x7fffL) ? 0x10000L : 0))
 
+#  ifdef XETEX
+UNSIGNED_BYTE ft_unsigned_byte(sfnt * f);
+SIGNED_BYTE ft_signed_byte(sfnt * f);
+UNSIGNED_PAIR ft_unsigned_pair(sfnt * f);
+SIGNED_PAIR ft_signed_pair(sfnt * f);
+UNSIGNED_QUAD ft_unsigned_quad(sfnt * f);
+unsigned long ft_read(unsigned char *buf, unsigned long len, sfnt * f);
+
+#    define sfnt_get_byte(s)   ((BYTE)   ft_unsigned_byte(s))
+#    define sfnt_get_char(s)   ((ICHAR)   ft_signed_byte  (s))
+#    define sfnt_get_ushort(s) ((USHORT) ft_unsigned_pair(s))
+#    define sfnt_get_short(s)  ((SHORT)  ft_signed_pair  (s))
+#    define sfnt_get_ulong(s)  ((ULONG)  ft_unsigned_quad(s))
+#    define sfnt_get_long(s)   ((LONG)   ft_signed_quad  (s))
+
+#    define sfnt_seek_set(s,o) (s)->loc = (o)
+#    define sfnt_read(b,l,s)   ft_read((b), (l), (s))
+#  elif defined(pdfTeX)
 BYTE get_unsigned_byte(sfnt * f);
 ICHAR get_signed_byte(sfnt * f);
 USHORT get_unsigned_pair(sfnt * f);
@@ -88,28 +111,45 @@ SHORT get_signed_pair(sfnt * f);
 ULONG get_unsigned_quad(sfnt * f);
 int do_sfnt_read(unsigned char *dest, int len, sfnt * f);
 
-#define sfnt_get_byte(s)   ((BYTE)   get_unsigned_byte(s))
-#define sfnt_get_char(s)   ((ICHAR)   get_signed_byte  (s))
-#define sfnt_get_ushort(s) ((USHORT) get_unsigned_pair(s))
-#define sfnt_get_short(s)  ((SHORT)  get_signed_pair  (s))
-#define sfnt_get_ulong(s)  ((ULONG)  get_unsigned_quad(s))
-#define sfnt_get_long(s)   ((LONG)   get_signed_quad  (s))
-
-#define sfnt_seek_set(s,o) (s)->loc = (o)
-#define sfnt_read(b,l,s)   do_sfnt_read((b), (l), (s))
+#    define sfnt_get_byte(s)   ((BYTE)   get_unsigned_byte(s))
+#    define sfnt_get_char(s)   ((ICHAR)   get_signed_byte  (s))
+#    define sfnt_get_ushort(s) ((USHORT) get_unsigned_pair(s))
+#    define sfnt_get_short(s)  ((SHORT)  get_signed_pair  (s))
+#    define sfnt_get_ulong(s)  ((ULONG)  get_unsigned_quad(s))
+#    define sfnt_get_long(s)   ((LONG)   get_signed_quad  (s))
+
+#    define sfnt_seek_set(s,o) (s)->loc = (o)
+#    define sfnt_read(b,l,s)   do_sfnt_read((b), (l), (s))
+#  else
+/* get_***_*** from numbers.h */
+#    define sfnt_get_byte(s)   ((BYTE)   get_unsigned_byte((s)->stream))
+#    define sfnt_get_char(s)   ((ICHAR)  get_signed_byte  ((s)->stream))
+#    define sfnt_get_ushort(s) ((USHORT) get_unsigned_pair((s)->stream))
+#    define sfnt_get_short(s)  ((SHORT)  get_signed_pair  ((s)->stream))
+#    define sfnt_get_ulong(s)  ((ULONG)  get_unsigned_quad((s)->stream))
+#    define sfnt_get_long(s)   ((LONG)   get_signed_quad  ((s)->stream))
+
+#    define sfnt_seek_set(s,o)   seek_absolute((s)->stream, (o))
+#    define sfnt_read(b,l,s)     fread((b), 1, (l), (s)->stream)
+#  endif
 
 extern int put_big_endian(void *s, LONG q, int n);
 
-#define sfnt_put_ushort(s,v) put_big_endian((s), v, 2);
-#define sfnt_put_short(s,v)  put_big_endian((s), v, 2);
-#define sfnt_put_ulong(s,v)  put_big_endian((s), v, 4);
-#define sfnt_put_long(s,v)   put_big_endian((s), v, 4);
-
+#  define sfnt_put_ushort(s,v) put_big_endian((s), v, 2);
+#  define sfnt_put_short(s,v)  put_big_endian((s), v, 2);
+#  define sfnt_put_ulong(s,v)  put_big_endian((s), v, 4);
+#  define sfnt_put_long(s,v)   put_big_endian((s), v, 4);
+
+#  ifdef XETEX
+extern sfnt *sfnt_open(FT_Face face, int accept_types);
+#  elif defined(pdfTeX)
 extern sfnt *sfnt_open(unsigned char *buffer, int buflen);
+#  else
+extern sfnt *sfnt_open(FILE * fp);
+#  endif
 extern void sfnt_close(sfnt * sfont);
 
 /* table directory */
-
 extern int sfnt_read_table_directory(sfnt * sfont, ULONG offset);
 extern ULONG sfnt_find_table_len(sfnt * sfont, const char *tag);
 extern ULONG sfnt_find_table_pos(sfnt * sfont, const char *tag);
@@ -119,10 +159,18 @@ extern void sfnt_set_table(sfnt * sfont,
                            const char *tag, void *data, ULONG length);
 extern int sfnt_require_table(sfnt * sfont, const char *tag, int must_exist);
 
-#define ASSERT(a) assert(a)
-#define RELEASE(a) free(a)
-#define NEW(a,b) xmalloc((unsigned)((unsigned)(a)*sizeof(b)))
-#define RENEW(a,b,c) xrealloc(a, (unsigned)((unsigned)(b)*sizeof(c)))
+#  ifdef pdfTeX
+typedef struct {
+    ULONG length;
+    BYTE *data;
+} pdf_obj;
+
+#    define ASSERT(a) assert(a)
+#    define RELEASE(a) free(a)
+#    define NEW(a,b) xmalloc((unsigned)((unsigned)(a)*sizeof(b)))
+#    define RENEW(a,b,c) xrealloc(a, (unsigned)((unsigned)(b)*sizeof(c)))
+
+#  endif
 
 extern pdf_obj *sfnt_create_FontFile_stream(sfnt * sfont);
 
--- texlive-bin.orig/texk/web2c/luatexdir/font/texfont.h
+++ texlive-bin/texk/web2c/luatexdir/font/texfont.h
@@ -32,17 +32,6 @@
 
 #  define pointer halfword
 
-#  define FONT_SLANT_MIN   -2000
-#  define FONT_SLANT_MAX    2000
-#  define FONT_EXTEND_MIN  -5000
-#  define FONT_EXTEND_MAX   5000
-#  define FONT_SQUEEZE_MIN -5000
-#  define FONT_SQUEEZE_MAX  5000
-#  define FONT_MODE_MIN        0
-#  define FONT_MODE_MAX        3 /* pdf values */
-#  define FONT_WIDTH_MIN       0
-#  define FONT_WIDTH_MAX    5000
-
 /* these are dumped en block, so they need endianness tests */
 
 typedef struct liginfo {
@@ -152,9 +141,6 @@ typedef struct texfont {
     boolean _font_oldmath;      /* default to false when MathConstants seen */
     int _font_slant;            /* a slant in ppt */
     int _font_extend;           /* an extension in ppt, or 1000 */
-    int _font_squeeze;          /* an extension in ppt, or 1000 */
-    int _font_width;
-    int _font_mode;
     int font_max_shrink;
     int font_max_stretch;
     int _font_step;             /* amount of one step of expansion */
@@ -343,15 +329,6 @@ boolean cmp_font_area(int, str_number);
 #  define font_extend(a)                 font_tables[a]->_font_extend
 #  define set_font_extend(a,b)           font_extend(a) = b
 
-#  define font_squeeze(a)                font_tables[a]->_font_squeeze
-#  define set_font_squeeze(a,b)          font_squeeze(a) = b
-
-#  define font_width(a)                  font_tables[a]->_font_width
-#  define set_font_width(a,b)            font_width(a) = b
-
-#  define font_mode(a)                   font_tables[a]->_font_mode
-#  define set_font_mode(a,b)             font_mode(a) = b
-
 #  define font_shrink(a)                 font_tables[a]->_font_shrink
 #  define set_font_shrink(a,b)           font_shrink(a) = b
 
@@ -648,7 +625,7 @@ typedef enum { packet_char_code,
     packet_scale_code,
     packet_lua_code,
     packet_pdf_code,
-    packet_pdf_mode
+    packet_pdf_mode,
 } packet_command_codes;
 
 extern scaled store_scaled_f(scaled sq, int fw);
--- texlive-bin.orig/texk/web2c/luatexdir/image/epdf.h
+++ texlive-bin/texk/web2c/luatexdir/image/epdf.h
@@ -18,19 +18,15 @@
    with LuaTeX; if not, see <http://www.gnu.org/licenses/>. */
 
 
-/* this is the common header file for C++ sources pdftoepdf.c and lepdflib.c */
+// this is the common header file for C++ sources pdftoepdf.cc and lepdflib.cc
 
 #ifndef EPDF_H
 #  define EPDF_H
-
-/*extern "C" {*/
-
+extern "C" {
 #ifdef HAVE_CONFIG_H
 #include <w2c/config.h>
 #endif
-
-/*}*/
-
+}
 #  include <stdlib.h>
 #  include <math.h>
 #  include <stddef.h>
@@ -39,22 +35,41 @@
 #  include <kpathsea/c-ctype.h>
 #  include <sys/stat.h>
 #  include <dirent.h>
+#  include <poppler-config.h>
+#  include <goo/GooString.h>
+#  include <goo/gmem.h>
+#  include <goo/gfile.h>
+#  include <Object.h>
+#  include <Stream.h>
+#  include <Gfx.h>
+#  include <Annot.h>
+#  include <Array.h>
+#  include <Dict.h>
+#  include <XRef.h>
+#  include <Catalog.h>
+#  include <StructTreeRoot.h>
+#  include <Link.h>
+#  include <Page.h>
+#  include <GfxFont.h>
+#  include <PDFDoc.h>
+#  include <GlobalParams.h>
+#  include <Error.h>
+#  include <FileSpec.h>
 
-/*extern "C" { */
+extern "C" {
 
 #  include <kpathsea/c-auto.h>
 
-extern char *xstrdup(const char *);
+    extern char *xstrdup(const char *);
 
-typedef enum { FE_FAIL, FE_RETURN_NULL } file_error_mode;
+    typedef enum { FE_FAIL, FE_RETURN_NULL } file_error_mode;
 
 /* the following code is extremly ugly but needed for including web2c/config.h */
 
-typedef const char *const_string;   /* including kpathsea/types.h doesn't work on some systems */
+    typedef const char *const_string;   /* including kpathsea/types.h doesn't work on some systems */
 
 #  define KPATHSEA_CONFIG_H     /* avoid including other kpathsea header files */
-
-/* from web2c/config.h */
+    /* from web2c/config.h */
 
 #  ifdef CONFIG_H               /* CONFIG_H has been defined by some xpdf */
 #    undef CONFIG_H             /* header file */
@@ -69,105 +84,117 @@ typedef const char *const_string;   /* i
 #  include "lua.h"
 #  include "lauxlib.h"
 
-# include "luapplib/pplib.h"
-
-/* pdfgen.w */
-
-extern int ten_pow[10];
-__attribute__ ((format(printf, 2, 3)))
-extern void pdf_printf(PDF, const char *fmt, ...);
-extern void pdf_begin_obj(PDF, int, int);
-extern void pdf_end_obj(PDF);
-extern void pdf_begin_dict(PDF);
-extern void pdf_end_dict(PDF);
-extern void pdf_begin_array(PDF);
-extern void pdf_end_array(PDF);
-extern void pdf_add_null(PDF);
-extern void pdf_add_bool(PDF, int i);
-extern void pdf_add_int(PDF, int i);
-extern void pdf_add_real(PDF, double d);
-extern void pdf_add_ref(PDF, int num);
-extern void pdf_add_name(PDF, const char *name);
-extern void pdf_dict_add_streaminfo(PDF);
-extern void pdf_begin_stream(PDF);
-extern void pdf_end_stream(PDF);
-extern void pdf_room(PDF, int);
-extern void pdf_out_block(PDF pdf, const char *s, size_t n);
-
-extern void pdf_dict_add_int(PDF, const char *key, int i);
-extern void pdf_dict_add_ref(PDF, const char *key, int num);
-extern void pdf_dict_add_name(PDF, const char *key, const char *val);
-extern void pdf_dict_add_streaminfo(PDF);
-
-/* Conflict with pdfgen.h */
-/*#  define pdf_out(pdf, A) do { pdf_room(pdf, 1); *(pdf->buf->p++) = A; } while (0)*/
-/*#  define pdf_quick_out(pdf,A) *(pdf->buf->p++)=(unsigned char)(A) */
+    /* pdfgen.w */
+    extern int ten_pow[10];
+    __attribute__ ((format(printf, 2, 3)))
+    extern void pdf_printf(PDF, const char *fmt, ...);
+    extern void pdf_begin_obj(PDF, int, int);
+    extern void pdf_end_obj(PDF);
+    extern void pdf_begin_dict(PDF);
+    extern void pdf_end_dict(PDF);
+    extern void pdf_begin_array(PDF);
+    extern void pdf_end_array(PDF);
+    extern void pdf_add_null(PDF);
+    extern void pdf_add_bool(PDF, int i);
+    extern void pdf_add_int(PDF, int i);
+    extern void pdf_add_ref(PDF, int num);
+    extern void pdf_add_name(PDF, const char *name);
+    extern void pdf_dict_add_streaminfo(PDF);
+    extern void pdf_begin_stream(PDF);
+    extern void pdf_end_stream(PDF);
+    extern void pdf_room(PDF, int);
+    extern void pdf_out_block(PDF pdf, const char *s, size_t n);
+
+    extern void pdf_dict_add_int(PDF, const char *key, int i);
+    extern void pdf_dict_add_ref(PDF, const char *key, int num);
+    extern void pdf_dict_add_name(PDF, const char *key, const char *val);
+    extern void pdf_dict_add_streaminfo(PDF);
 
+#  define pdf_out(pdf, A) do { pdf_room(pdf, 1); *(pdf->buf->p++) = A; } while (0)
+#  define pdf_quick_out(pdf,A) *(pdf->buf->p++)=(unsigned char)(A)
 #  define pdf_puts(pdf, s) pdf_out_block((pdf), (s), strlen(s))
 
-/* pdfpage.w */
-
-extern void print_pdffloat(PDF pdf, pdffloat f);
-
-/* pdftables.w */
-
-extern int pdf_create_obj(PDF pdf, int t, int i);
-
-/* pdftoepdf.c */
-
-extern void read_pdf_info(image_dict *);
-extern void flush_pdf_info(image_dict *);
+    /* pdfpage.w */
+    extern void print_pdffloat(PDF pdf, pdffloat f);
 
-extern void write_epdf(PDF, image_dict *, int suppress_optional_info);
-extern int  write_epdf_object(PDF, image_dict *, int n);
+    /* pdftables.w */
+    extern int pdf_create_obj(PDF pdf, int t, int i);
 
-extern void unrefPdfDocument(char *);
-extern void unrefMemStreamPdfDocument(char *);
+    /* pdftoepdf.cc */
+    extern void read_pdf_info(image_dict *);
+    extern void flush_pdf_info(image_dict *);
+    extern void write_epdf(PDF, image_dict *, int suppress_optional_info);
+    extern void unrefPdfDocument(char *);
+    extern void unrefMemStreamPdfDocument(char *);
+    extern void epdf_free(void);
+    extern void copyReal(PDF pdf, double d);
 
-extern void epdf_free(void);
+    /* writeimg.w */
+    extern void pdf_dict_add_img_filename(PDF pdf, image_dict * idict);
 
-/* writeimg.w */
+    /* utils.w */
+    extern char *convertStringToPDFString(char *in, int len);
 
-extern void pdf_dict_add_img_filename(PDF pdf, image_dict * idict);
-
-/* utils.w */
-
-/*extern char *convertStringToPDFString(const char *in, int len);*/
-
-/* lepdflib.w */
-
-int luaopen_epdf(lua_State * L);
+    /* lepdflib.w */
+    int luaopen_epdf(lua_State * L);
 
 #  include "luatex-common.h"
 
-/*}*/
+};
 
-typedef struct InObj InObj;
+/**********************************************************************/
 
-struct InObj {
-    ppref *ref;                 /* ref in original PDF */
-    int num;                    /* new object number in output PDF */
-    InObj *next;                /* next entry in list of indirect objects */
-} ;
+// PdfObject encapsulates the xpdf Object type,
+// and properly frees its resources on destruction.
+// Use obj-> to access members of the Object,
+// and &obj to get a pointer to the object.
+// It is no longer necessary to call Object::free explicitely.
+
+#  if 0
+// PdfObject is replaced by xpdf's Object type, with manual obj.free()
+
+// *INDENT-OFF*
+class PdfObject {
+  public:
+    PdfObject() {               // nothing
+    }
+    ~PdfObject() {
+        iObject.free();
+    }
+    Object *operator->() {
+        return &iObject;
+    }
+    Object *operator&() {
+        return &iObject;
+    }
+  private:                     // no copying or assigning
+    PdfObject(const PdfObject &);
+    void operator=(const PdfObject &);
+  public:
+    Object iObject;
+};
+// *INDENT-ON*
+#  endif
 
+/**********************************************************************/
 
-typedef struct avl_table avl_table;
+struct InObj {
+    Ref ref;                    // ref in original PDF
+    int num;                    // new object number in output PDF
+    InObj *next;                // next entry in list of indirect objects
+};
 
 struct PdfDocument {
-    char *file_path;            /* full file name including path */
-    char *checksum;             /* for reopening */
-    ppdoc *pdfe;
-    InObj *inObjList;           /* temporary linked list */
-    avl_table *ObjMapTree;      /* permanent over luatex run */
-    int is_mem;
-    char *memstream;
-    unsigned int occurences;    /* number of references to the PdfDocument; it can be deleted when occurences == 0 */
-    unsigned int pc;            /* counter to track PDFDoc generation or deletion */
+    char *file_path;            // full file name including path
+    char *checksum;             // for reopening
+    PDFDoc *doc;
+    InObj *inObjList;           // temporary linked list
+    avl_table *ObjMapTree;      // permanent over luatex run
+    unsigned int occurences;    // number of references to the PdfDocument; it can be deleted when occurences == 0
+    unsigned int pc;            // counter to track PDFDoc generation or deletion
 };
 
-typedef struct PdfDocument PdfDocument;
-
-PdfDocument *refPdfDocument(const char *file_path, file_error_mode fe, const char *userpassword, const char *ownerpassword);
+PdfDocument *refPdfDocument(const char *file_path, file_error_mode fe);
 
 PdfDocument *refMemStreamPdfDocument(char *docstream, unsigned long long streamsize, const char *file_id);
 
--- texlive-bin.orig/texk/web2c/luatexdir/image/image.h
+++ texlive-bin/texk/web2c/luatexdir/image/image.h
@@ -39,7 +39,6 @@ extern scaled one_hundred_bp;   /* from
 
 typedef struct {
     char *stream;
-    size_t size;
 } pdf_stream_struct;
 
 typedef struct {
@@ -117,8 +116,6 @@ typedef struct {
     char *filepath;             /* full file path after kpathsea */
     char *attr;                 /* additional image dict entries */
     FILE *file;
-    char *userpassword;
-    char *ownerpassword;
     imgtype_e image_type;
     int procset;                /* /ProcSet flags */
     int color_depth;            /* color depth */
@@ -128,7 +125,6 @@ typedef struct {
     int flags;
     int luaref ;
     boolean keepopen;
-    boolean nolength;
     int errorlevel;
     int pdfmajorversion;
     int pdfminorversion;
@@ -163,8 +159,6 @@ typedef struct {
 #  define img_pagename(N)         ((N)->pagename)
 #  define img_filename(N)         ((N)->filename)
 #  define img_visiblefilename(N)  ((N)->visiblefilename)
-#  define img_userpassword(N)     ((N)->userpassword)
-#  define img_ownerpassword(N)    ((N)->ownerpassword)
 #  define img_filepath(N)         ((N)->filepath)
 #  define img_attr(N)             ((N)->attr)
 #  define img_file(N)             ((N)->file)
@@ -177,14 +171,12 @@ typedef struct {
 #  define img_flags(N)            ((N)->flags)
 #  define img_luaref(N)           ((N)->luaref)
 #  define img_keepopen(N)         ((N)->keepopen)
-#  define img_nolength(N)         ((N)->nolength)
 #  define img_errorlevel(N)       ((N)->errorlevel)
 #  define img_pdfmajorversion(N)  ((N)->pdfmajorversion)
 #  define img_pdfminorversion(N)  ((N)->pdfminorversion)
 
 #  define img_pdfstream_ptr(N)    ((N)->img_struct.pdfstream)
 #  define img_pdfstream_stream(N) ((N)->img_struct.pdfstream->stream)
-#  define img_pdfstream_size(N)   ((N)->img_struct.pdfstream->size)
 
 #  define img_png_ptr(N)          ((N)->img_struct.png)
 #  define img_png_png_ptr(N)      ((N)->img_struct.png->png_ptr)
--- texlive-bin.orig/texk/web2c/luatexdir/image/pdftoepdf.h
+++ texlive-bin/texk/web2c/luatexdir/image/pdftoepdf.h
@@ -30,7 +30,12 @@ void flush_pdf_info(image_dict *);
 void unrefPdfDocument(char *);
 void unrefMemStreamPdfDocument(char *);
 void write_epdf(PDF, image_dict *, int suppress_optional_info);
-int write_epdf_object(PDF, image_dict *, int n);
+void epdf_check_mem(void);
+void copyReal(PDF pdf, double d);
+
+int poppler_version_major(void);
+int poppler_version_minor(void);
+int poppler_version_micro(void);
 
 /* epdf.c --- this should go in an own header file */
 
--- texlive-bin.orig/texk/web2c/luatexdir/image/writeimg.h
+++ texlive-bin/texk/web2c/luatexdir/image/writeimg.h
@@ -38,7 +38,6 @@ void scan_pdfrefximage(PDF pdf);
 scaled_whd tex_scale(scaled_whd nat, scaled_whd tex);
 scaled_whd scale_img(image_dict *, scaled_whd, int);
 void write_img(PDF, image_dict *);
-int write_img_object(PDF, image_dict *, int n);
 void pdf_write_image(PDF pdf, int n);
 void check_pdfstream_dict(image_dict *);
 void write_pdfstream(PDF, image_dict *);
--- texlive-bin.orig/texk/web2c/luatexdir/lua/lcallbacklib.c
+++ texlive-bin/texk/web2c/luatexdir/lua/lcallbacklib.c
@@ -22,9 +22,6 @@
 
 int callback_count = 0;
 int saved_callback_count = 0;
-int direct_callback_count = 0;
-int late_callback_count = 0;
-int function_callback_count = 0;
 
 int callback_set[total_callbacks] = { 0 };
 
@@ -77,12 +74,7 @@ static const char *const callbacknames[]
     "call_edit",
     "build_page_insert",
     "glyph_stream_provider",
-    "font_descriptor_objnum_provider",
-    "finish_synctex",
-    "wrapup_run",
-    "new_graf",
-    "page_objnum_provider",
-    "make_extensible",
+    "finish_synctex_callback",
     NULL
 };
 
@@ -215,6 +207,7 @@ int run_saved_callback(int r, const char
     lua_rawget(Luas, -2);
     if (lua_isfunction(Luas, -1)) {
         saved_callback_count++;
+        callback_count++;
         ret = do_run_callback(2, values, args);
     }
     va_end(args);
--- texlive-bin.orig/texk/web2c/luatexdir/lua/lepdflib.cc
+++ texlive-bin/texk/web2c/luatexdir/lua/lepdflib.cc
@@ -17,3 +17,3627 @@
 
    You should have received a copy of the GNU General Public License along
    with LuaTeX; if not, see <http://www.gnu.org/licenses/>. */
+
+
+#include "image/epdf.h"
+
+// Patches for the new poppler 0.59 from
+// https://www.mail-archive.com/arch-commits@archlinux.org/msg357548.html
+// with some modifications to comply the poppler API.
+
+// define DEBUG
+
+//**********************************************************************
+// TODO: add more poppler functions (many are still missing)
+
+//**********************************************************************
+// objects allocated by poppler may not be deleted in the lepdflib
+
+typedef enum { ALLOC_POPPLER, ALLOC_LEPDF } alloctype;
+
+typedef struct {
+    void *d;
+    alloctype atype;            // was it allocated by poppler or the lepdflib.cc?
+    PdfDocument *pd;            // reference to PdfDocument, or NULL
+    unsigned long pc;           // counter to detect PDFDoc change
+} udstruct;
+
+static const char *ErrorCodeNames[] = { "None", "OpenFile", "BadCatalog",
+    "Damaged", "Encrypted", "HighlightFile", "BadPrinter", "Printing",
+    "Permission", "BadPageNum", "FileIO", NULL
+};
+
+//**********************************************************************
+
+#define M_Annot            "epdf.Annot" /* ls-hh: epdf.* gives better protection in registry */
+#define M_Annots           "epdf.Annots"
+#define M_Array            "epdf.Array"
+#define M_Catalog          "epdf.Catalog"
+#define M_Dict             "epdf.Dict"
+#define M_EmbFile          "epdf.EmbFile"
+#define M_FileSpec         "epdf.FileSpec"
+#define M_GooString        "epdf.GooString"
+#define M_LinkDest         "epdf.LinkDest"
+#define M_Link             "epdf.Link"
+#define M_Links            "epdf.Links"
+#define M_Object           "epdf.Object"
+#define M_Page             "epdf.Page"
+#define M_PDFDoc           "epdf.PDFDoc"
+#define M_PDFRectangle     "epdf.PDFRectangle"
+#define M_Ref              "epdf.Ref"
+#define M_Stream           "epdf.Stream"
+#define M_StructElement    "epdf.StructElement"
+#define M_Attribute        "epdf.Attribute"
+#define M_TextSpan         "epdf.TextSpan"
+#define M_StructTreeRoot   "epdf.StructTreeRoot"
+#define M_XRefEntry        "epdf.XRefEntry"
+#define M_XRef             "epdf.XRef"
+
+//**********************************************************************
+
+#define new_poppler_userdata(type)                                              \
+static udstruct *new_##type##_userdata(lua_State * L)                           \
+{                                                                               \
+    udstruct *a;                                                                \
+    a = (udstruct *) lua_newuserdata(L, sizeof(udstruct));  /* udstruct ... */  \
+    a->atype = ALLOC_POPPLER;                                                   \
+    luaL_getmetatable(L, M_##type);     /* m udstruct ... */                    \
+    lua_setmetatable(L, -2);    /* udstruct ... */                              \
+    return a;                                                                   \
+}
+
+new_poppler_userdata(PDFDoc);
+
+new_poppler_userdata(Annot);
+new_poppler_userdata(Array);
+new_poppler_userdata(Catalog);
+new_poppler_userdata(Dict);
+new_poppler_userdata(EmbFile);
+new_poppler_userdata(FileSpec);
+new_poppler_userdata(LinkDest);
+new_poppler_userdata(Links);
+new_poppler_userdata(Object);
+new_poppler_userdata(Page);
+new_poppler_userdata(PDFRectangle);
+new_poppler_userdata(Ref);
+new_poppler_userdata(Stream);
+new_poppler_userdata(StructElement);
+new_poppler_userdata(Attribute);
+new_poppler_userdata(TextSpan);
+new_poppler_userdata(StructTreeRoot);
+new_poppler_userdata(XRef);
+
+//**********************************************************************
+
+static void pdfdoc_changed_error(lua_State * L)
+{
+    luaL_error(L, "PDFDoc changed or gone");
+}
+
+static void pdfdoc_differs_error(lua_State * L)
+{
+    luaL_error(L, "PDFDoc differs between arguments");
+}
+
+//**********************************************************************
+
+static int l_open_PDFDoc(lua_State * L)
+{
+    const char *file_path;
+    udstruct *uout;
+    PdfDocument *d;
+    file_path = luaL_checkstring(L, 1); // path
+    d = refPdfDocument(file_path, FE_RETURN_NULL);
+    if (d == NULL)
+        lua_pushnil(L);
+    else {
+      if (!(globalParams)) // globalParams could be already created
+          globalParams = new GlobalParams();
+        uout = new_PDFDoc_userdata(L);
+        uout->d = d;
+        uout->atype = ALLOC_LEPDF;
+        uout->pc = d->pc;
+        uout->pd = d;
+    }
+    return 1;                   // doc path
+}
+
+static int l_open_MemStreamPDFDoc(lua_State * L)
+{
+    const char *docstream = NULL;
+    char *docstream_usr = NULL ;
+    const char *file_id;
+    unsigned long long stream_size;
+    udstruct *uout;
+    PdfDocument *d;
+    switch (lua_type(L, 1)) {
+      case LUA_TSTRING:
+         docstream = luaL_checkstring(L, 1); // stream as Lua string
+         break;
+      case LUA_TLIGHTUSERDATA:
+         docstream = (const char *) lua_touserdata(L, 1); // stream as sequence of bytes
+	 break;
+       default:
+         luaL_error(L, "bad argument: string or lightuserdata expected");
+    }
+    if (docstream==NULL)
+      luaL_error(L, "bad document");
+    stream_size = (unsigned long long) luaL_checkint(L, 2);// size of the stream
+    file_id  =  luaL_checkstring(L, 3); // a symbolic name for this stream, mandatory
+    if (file_id == NULL)
+      luaL_error(L, "PDFDoc has an invalid id");
+    if (strlen(file_id) >STREAM_FILE_ID_LEN )  // a limit to the length of the string
+      luaL_error(L, "PDFDoc has a too long id");
+    docstream_usr = (char *)gmalloc((unsigned) (stream_size + 1));
+    if (!docstream_usr)
+      luaL_error(L, "no room for PDFDoc");
+    memcpy(docstream_usr, docstream, (stream_size + 1));
+    docstream_usr[stream_size]='\0';
+    d = refMemStreamPdfDocument(docstream_usr, stream_size, file_id);
+    if (d == NULL) {
+      lua_pushnil(L);
+      lua_pushnil(L);
+      lua_pushnil(L);
+    }
+    else if (d->file_path == NULL ) {
+      lua_pushnil(L);
+      lua_pushnil(L);
+      lua_pushnil(L);
+    }
+    else {
+      if (!(globalParams)) // globalParams could be already created
+        globalParams = new GlobalParams();
+      uout = new_PDFDoc_userdata(L);
+      uout->d = d;
+      uout->atype = ALLOC_LEPDF;
+      uout->pc = d->pc;
+      uout->pd = d;
+      lua_pushstring(L,d->file_path);
+      lua_pushstring(L,STREAM_URI);
+    }
+    return 3;                   // stream, stream_id, stream_uri
+}
+
+
+
+
+static int l_new_Array(lua_State * L)
+{
+    udstruct *uxref, *uout;
+    uxref = (udstruct *) luaL_checkudata(L, 1, M_XRef);
+    if (uxref->pd != NULL && uxref->pd->pc != uxref->pc)
+        pdfdoc_changed_error(L);
+    uout = new_Array_userdata(L);
+    uout->d = new Array((XRef *) uxref->d);     // automatic init to length 0
+    uout->atype = ALLOC_LEPDF;
+    uout->pc = uxref->pc;
+    uout->pd = uxref->pd;
+    return 1;
+}
+
+static int l_new_Attribute(lua_State * L)
+{
+    Attribute::Type t;
+    const char *n;
+    int nlen;
+    udstruct *uobj, *uout;
+
+    if (lua_type(L,1)==LUA_TNUMBER) {
+       uobj = (udstruct *) luaL_checkudata(L, 2, M_Object);
+       if (uobj->pd != NULL && uobj->pd->pc != uobj->pc)
+           pdfdoc_changed_error(L);
+       t = (Attribute::Type) luaL_checkint(L, 1);
+       uout = new_Attribute_userdata(L);
+       uout->d = new Attribute(t, (Object *)uobj->d);
+       uout->atype = ALLOC_LEPDF;
+       uout->pc = uobj->pc;
+       uout->pd = uobj->pd;
+
+    } else if (lua_type(L,1)==LUA_TSTRING) {
+       n = luaL_checkstring(L,1);
+       nlen = luaL_checkint(L,2);
+       uobj = (udstruct *) luaL_checkudata(L, 3, M_Object);
+       if (uobj->pd != NULL && uobj->pd->pc != uobj->pc)
+          pdfdoc_changed_error(L);
+       uout = new_Attribute_userdata(L);
+       uout->d = new Attribute(n, nlen, (Object *)uobj->d);
+       uout->atype = ALLOC_LEPDF;
+       uout->pc = uobj->pc;
+       uout->pd = uobj->pd;
+    } else
+       lua_pushnil(L);
+    return 1;
+}
+
+#define ATTRIBUTE_TYPE_ENTRY(name)          \
+   lua_pushstring(L, #name);                \
+   lua_pushinteger(L, Attribute::name);     \
+   lua_settable(L,-3)
+
+
+#define OBJECT_TYPE(name)                   \
+   lua_pushstring(L, #name);                \
+   lua_pushinteger(L, (int)name);           \
+   lua_settable(L,-3)
+
+
+#define STRUCTELEMENT_TYPE_ENTRY(name)      \
+   lua_pushstring(L, #name);                \
+   lua_pushinteger(L, StructElement::name); \
+   lua_settable(L,-3)
+
+
+static int l_Attribute_Type(lua_State * L) {
+   lua_createtable (L, 0, 42);
+   ATTRIBUTE_TYPE_ENTRY(BBox);
+   ATTRIBUTE_TYPE_ENTRY(BackgroundColor);
+   ATTRIBUTE_TYPE_ENTRY(BorderColor);
+   ATTRIBUTE_TYPE_ENTRY(BorderThickness);
+   ATTRIBUTE_TYPE_ENTRY(Color);
+   ATTRIBUTE_TYPE_ENTRY(ColumnGap);
+   ATTRIBUTE_TYPE_ENTRY(ColumnWidths);
+   ATTRIBUTE_TYPE_ENTRY(Desc);
+   ATTRIBUTE_TYPE_ENTRY(Role);
+   ATTRIBUTE_TYPE_ENTRY(TextDecorationColor);
+   ATTRIBUTE_TYPE_ENTRY(TextDecorationThickness);
+   ATTRIBUTE_TYPE_ENTRY(BaselineShift);
+   ATTRIBUTE_TYPE_ENTRY(BlockAlign);
+   ATTRIBUTE_TYPE_ENTRY(BorderStyle);
+   ATTRIBUTE_TYPE_ENTRY(ColSpan);
+   ATTRIBUTE_TYPE_ENTRY(ColumnCount);
+   ATTRIBUTE_TYPE_ENTRY(EndIndent);
+   ATTRIBUTE_TYPE_ENTRY(GlyphOrientationVertical);
+   ATTRIBUTE_TYPE_ENTRY(Headers);
+   ATTRIBUTE_TYPE_ENTRY(Height);
+   ATTRIBUTE_TYPE_ENTRY(InlineAlign);
+   ATTRIBUTE_TYPE_ENTRY(LineHeight);
+   ATTRIBUTE_TYPE_ENTRY(ListNumbering);
+   ATTRIBUTE_TYPE_ENTRY(Padding);
+   ATTRIBUTE_TYPE_ENTRY(Placement);
+   ATTRIBUTE_TYPE_ENTRY(RowSpan);
+   ATTRIBUTE_TYPE_ENTRY(RubyAlign);
+   ATTRIBUTE_TYPE_ENTRY(RubyPosition);
+   ATTRIBUTE_TYPE_ENTRY(Scope);
+   ATTRIBUTE_TYPE_ENTRY(SpaceAfter);
+   ATTRIBUTE_TYPE_ENTRY(SpaceBefore);
+   ATTRIBUTE_TYPE_ENTRY(StartIndent);
+   ATTRIBUTE_TYPE_ENTRY(Summary);
+   ATTRIBUTE_TYPE_ENTRY(TBorderStyle);
+   ATTRIBUTE_TYPE_ENTRY(TPadding);
+   ATTRIBUTE_TYPE_ENTRY(TextAlign);
+   ATTRIBUTE_TYPE_ENTRY(TextDecorationType);
+   ATTRIBUTE_TYPE_ENTRY(TextIndent);
+   ATTRIBUTE_TYPE_ENTRY(Width);
+   ATTRIBUTE_TYPE_ENTRY(WritingMode);
+   ATTRIBUTE_TYPE_ENTRY(Unknown);
+   ATTRIBUTE_TYPE_ENTRY(checked);
+   return 1;
+}
+
+static int l_Object_Type(lua_State * L) {
+   lua_createtable(L,0,16);/*nr of ObjType values*/ ;
+   OBJECT_TYPE(objBool);
+   OBJECT_TYPE(objInt);
+   OBJECT_TYPE(objReal);
+   OBJECT_TYPE(objString);
+   OBJECT_TYPE(objName);
+   OBJECT_TYPE(objNull);
+   OBJECT_TYPE(objArray);
+   OBJECT_TYPE(objDict);
+   OBJECT_TYPE(objStream);
+   OBJECT_TYPE(objRef);
+   OBJECT_TYPE(objCmd);
+   OBJECT_TYPE(objError);
+   OBJECT_TYPE(objEOF);
+   OBJECT_TYPE(objNone);
+   OBJECT_TYPE(objInt64);
+   OBJECT_TYPE(objDead);
+   return 1;
+}
+
+
+static int l_StructElement_Type(lua_State * L) {
+   lua_createtable (L, 0, 50);
+   STRUCTELEMENT_TYPE_ENTRY(Document);
+   STRUCTELEMENT_TYPE_ENTRY(Part);
+   STRUCTELEMENT_TYPE_ENTRY(Art);
+   STRUCTELEMENT_TYPE_ENTRY(Sect);
+   STRUCTELEMENT_TYPE_ENTRY(Div);
+   STRUCTELEMENT_TYPE_ENTRY(BlockQuote);
+   STRUCTELEMENT_TYPE_ENTRY(Caption);
+   STRUCTELEMENT_TYPE_ENTRY(NonStruct);
+   STRUCTELEMENT_TYPE_ENTRY(Index);
+   STRUCTELEMENT_TYPE_ENTRY(Private);
+   STRUCTELEMENT_TYPE_ENTRY(Span);
+   STRUCTELEMENT_TYPE_ENTRY(Quote);
+   STRUCTELEMENT_TYPE_ENTRY(Note);
+   STRUCTELEMENT_TYPE_ENTRY(Reference);
+   STRUCTELEMENT_TYPE_ENTRY(BibEntry);
+   STRUCTELEMENT_TYPE_ENTRY(Code);
+   STRUCTELEMENT_TYPE_ENTRY(Link);
+   STRUCTELEMENT_TYPE_ENTRY(Annot);
+   STRUCTELEMENT_TYPE_ENTRY(Ruby);
+   STRUCTELEMENT_TYPE_ENTRY(RB);
+   STRUCTELEMENT_TYPE_ENTRY(RT);
+   STRUCTELEMENT_TYPE_ENTRY(RP);
+   STRUCTELEMENT_TYPE_ENTRY(Warichu);
+   STRUCTELEMENT_TYPE_ENTRY(WT);
+   STRUCTELEMENT_TYPE_ENTRY(WP);
+   STRUCTELEMENT_TYPE_ENTRY(P);
+   STRUCTELEMENT_TYPE_ENTRY(H);
+   STRUCTELEMENT_TYPE_ENTRY(H1);
+   STRUCTELEMENT_TYPE_ENTRY(H2);
+   STRUCTELEMENT_TYPE_ENTRY(H3);
+   STRUCTELEMENT_TYPE_ENTRY(H4);
+   STRUCTELEMENT_TYPE_ENTRY(H5);
+   STRUCTELEMENT_TYPE_ENTRY(H6);
+   STRUCTELEMENT_TYPE_ENTRY(L);
+   STRUCTELEMENT_TYPE_ENTRY(LI);
+   STRUCTELEMENT_TYPE_ENTRY(Lbl);
+   STRUCTELEMENT_TYPE_ENTRY(LBody);
+   STRUCTELEMENT_TYPE_ENTRY(Table);
+   STRUCTELEMENT_TYPE_ENTRY(TR);
+   STRUCTELEMENT_TYPE_ENTRY(TH);
+   STRUCTELEMENT_TYPE_ENTRY(TD);
+   STRUCTELEMENT_TYPE_ENTRY(THead);
+   STRUCTELEMENT_TYPE_ENTRY(TFoot);
+   STRUCTELEMENT_TYPE_ENTRY(TBody);
+   STRUCTELEMENT_TYPE_ENTRY(Figure);
+   STRUCTELEMENT_TYPE_ENTRY(Formula);
+   STRUCTELEMENT_TYPE_ENTRY(Form);
+   STRUCTELEMENT_TYPE_ENTRY(TOC);
+   STRUCTELEMENT_TYPE_ENTRY(TOCI);
+   lua_pushstring(L, "Unknown");
+   lua_pushinteger(L, 0);
+   lua_settable(L,-3);
+   return 1;
+}
+
+static int l_AttributeOwner_Type(lua_State * L) {
+  lua_createtable (L, 0, 12);
+  lua_pushstring(L, "XML-1.00");       lua_pushinteger(L, Attribute::XML_1_00);      lua_settable(L,-3);
+  lua_pushstring(L, "HTML-3.20");      lua_pushinteger(L, Attribute::HTML_3_20);     lua_settable(L,-3);
+  lua_pushstring(L, "HTML-4.01");      lua_pushinteger(L, Attribute::HTML_4_01);     lua_settable(L,-3);
+  lua_pushstring(L, "OEB-1.00");       lua_pushinteger(L, Attribute::OEB_1_00);      lua_settable(L,-3);
+  lua_pushstring(L, "RTF-1.05");       lua_pushinteger(L, Attribute::RTF_1_05);      lua_settable(L,-3);
+  lua_pushstring(L, "CSS-1.00");       lua_pushinteger(L, Attribute::CSS_1_00);      lua_settable(L,-3);
+  lua_pushstring(L, "CSS-2.00");       lua_pushinteger(L, Attribute::CSS_2_00);      lua_settable(L,-3);
+  lua_pushstring(L, "Layout");	       lua_pushinteger(L, Attribute::Layout);        lua_settable(L,-3);
+  lua_pushstring(L, "PrintField");     lua_pushinteger(L, Attribute::PrintField);    lua_settable(L,-3);
+  lua_pushstring(L, "Table");	       lua_pushinteger(L, Attribute::Table);         lua_settable(L,-3);
+  lua_pushstring(L, "List");	       lua_pushinteger(L, Attribute::List);          lua_settable(L,-3);
+  lua_pushstring(L, "UserProperties"); lua_pushinteger(L, Attribute::UserProperties);lua_settable(L,-3);
+  return 1;
+}
+
+
+static int l_new_Dict(lua_State * L)
+{
+    udstruct *uxref, *uout;
+    uxref = (udstruct *) luaL_checkudata(L, 1, M_XRef);
+    if (uxref->pd != NULL && uxref->pd->pc != uxref->pc)
+        pdfdoc_changed_error(L);
+    uout = new_Dict_userdata(L);
+    uout->d = new Dict((XRef *) uxref->d);      // automatic init to length 0
+    uout->atype = ALLOC_LEPDF;
+    uout->pc = uxref->pc;
+    uout->pd = uxref->pd;
+    return 1;
+}
+
+static int l_new_Object(lua_State * L)
+{
+    udstruct *uout;
+    int n = lua_gettop(L); // number of arguments
+    uout = new_Object_userdata(L);
+    switch(n) {
+    case 0:
+      uout->d = new Object();     // automatic init to type "none"
+      uout->atype = ALLOC_LEPDF;
+      uout->pc = 0;
+      uout->pd = NULL;            // not connected to any PDFDoc
+      break;
+    case 1:
+      if (lua_isboolean (L,1)) {
+	uout->d = new Object(lua_toboolean(L, 1)? gTrue : gFalse);
+	uout->atype = ALLOC_LEPDF;
+	uout->pc = 0;
+	uout->pd = NULL;
+      } else if (lua_isnumber (L,1)) {
+	double d = lua_tonumber(L,1);
+	// Missed :Object(long long int64gA)
+	if (d==((int)d)) {
+	  uout->d = new Object((int)d);
+	} else {
+	  uout->d = new Object(d);
+	}
+	uout->atype = ALLOC_LEPDF;
+	uout->pc = 0;
+	uout->pd = NULL;
+      } else if (lua_isstring (L,1)){
+	GooString *gs;
+	const char *s;
+	size_t len;
+	s = luaL_checklstring(L, 2, &len);
+	gs = new GooString(s, len);
+	uout->d = new Object(gs);
+	uout->atype = ALLOC_LEPDF;
+	uout->pc = 0;
+	uout->pd = NULL;
+      } else if (luaL_testudata(L,1,M_Array)){
+	udstruct *u;
+	Array *a;
+	u = (udstruct *) luaL_checkudata(L, 1, M_Array);
+	a = (Array *)u->d;
+	uout->d = new Object(a);
+	uout->atype = ALLOC_LEPDF;
+	uout->pc = 0;
+	uout->pd = NULL;
+      } else if (luaL_testudata(L,1,M_Dict)){
+	udstruct *u;
+	Dict *d;
+	u = (udstruct *) luaL_checkudata(L, 1, M_Dict);
+	d = (Dict *)u->d;
+	uout->d = new Object(d);
+	uout->atype = ALLOC_LEPDF;
+	uout->pc = 0;
+	uout->pd = NULL;
+      } else if (luaL_testudata(L,1,M_Stream)){
+	udstruct *u;
+	Stream *s;
+	u = (udstruct *) luaL_checkudata(L, 1, M_Stream);
+	s = (Stream *)u->d;
+	*((Object *) uout->d) = Object(s);
+      } else
+	luaL_error(L, "Invalid/unsupported value for Object constructor");
+      break;
+    case 2:
+      if (lua_isnumber (L,1) && lua_isnumber (L,2)) {
+	double numA = lua_tonumber(L,1);
+	double genA = lua_tonumber(L,2);
+	if ( ((numA)==(int)(numA)) && ((genA)==(int)(genA)) ){
+	  uout->d = new Object((int)(numA), (int)(genA));
+	  uout->atype = ALLOC_LEPDF;
+	  uout->pc = 0;
+	  uout->pd = NULL;
+	}
+      } else if (lua_isnumber (L,1) && (lua_isstring(L,2)|| lua_isnoneornil(L,2))) {
+	double d_typeA = lua_tonumber(L,1);
+	int typeA = (int)(d_typeA);
+	if (d_typeA==typeA){
+	  switch((int)(typeA)) {
+	  case     objBool:
+	  case     objInt:
+	  case     objReal:
+	  case     objString:
+	  case     objName:
+	  case     objNull:
+	  case     objArray:
+	  case     objDict:
+	  case     objStream:
+	  case     objRef:
+	  case     objCmd:
+	  case     objError:
+	  case     objEOF:
+	  case     objNone:
+	  case     objInt64:
+	  case     objDead:
+	    if (lua_isstring(L,2))
+	      uout->d = new Object((ObjType)(typeA), luaL_checkstring(L, 2));
+	    else
+	      uout->d = new Object((ObjType)(typeA));
+	    uout->atype = ALLOC_LEPDF;
+	    uout->pc = 0;
+	    uout->pd = NULL;
+
+	    break;
+	  default:
+	    luaL_error(L, "Invalid values for Object constructor");
+	    break;
+	  }//switch((int)(d))
+	} else //  (d_typeA)!=(typeA)
+	  luaL_error(L, "Invalid/unsupported values for Object constructor");
+      } // if (lua_isnumber (L,1) && (lua_isstring(L,2)|| lua_isnoneornil(L,2)))
+      break;
+    default:
+      luaL_error(L, "Invalid specification for Object constructor");
+    }
+    lua_settop(L,1);
+    return 1;
+}
+
+// static int l_new_Object(lua_State * L)
+// {
+//     udstruct *uout;
+//     uout = new_Object_userdata(L);
+//     uout->d = new Object();     // automatic init to type "none"
+//     uout->atype = ALLOC_LEPDF;
+//     uout->pc = 0;
+//     uout->pd = NULL;            // not connected to any PDFDoc
+//     return 1;
+// }
+
+
+// PDFRectangle see Page.h
+
+static int l_new_PDFRectangle(lua_State * L)
+{
+    udstruct *uout;
+    uout = new_PDFRectangle_userdata(L);
+    uout->d = new PDFRectangle();       // automatic init to [0, 0, 0, 0]
+    uout->atype = ALLOC_LEPDF;
+    uout->pc = 0;
+    uout->pd = NULL;
+    return 1;
+}
+
+static const struct luaL_Reg epdflib_f[] = {
+    {"open", l_open_PDFDoc},
+    {"openMemStream", l_open_MemStreamPDFDoc},
+    {"Array", l_new_Array},
+    {"Attribute",          l_new_Attribute},
+    {"StructElement_Type", l_StructElement_Type},
+    {"Attribute_Type",     l_Attribute_Type},
+    {"AttributeOwner_Type",l_AttributeOwner_Type},
+    {"Dict", l_new_Dict},
+    {"Object", l_new_Object},
+    {"Object_Type", l_Object_Type},
+    {"PDFRectangle", l_new_PDFRectangle},
+    {NULL, NULL}                // sentinel
+};
+
+//**********************************************************************
+
+#define m_poppler_get_poppler(in, out, function)               \
+static int m_##in##_##function(lua_State * L)                  \
+{                                                              \
+    out *o;                                                    \
+    udstruct *uin, *uout;                                      \
+    uin = (udstruct *) luaL_checkudata(L, 1, M_##in);          \
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)             \
+        pdfdoc_changed_error(L);                               \
+    o = ((in *) uin->d)->function();                           \
+    if (o != NULL) {                                           \
+        uout = new_##out##_userdata(L);                        \
+        uout->d = o;                                           \
+        uout->pc = uin->pc;                                    \
+        uout->pd = uin->pd;                                    \
+    } else                                                     \
+        lua_pushnil(L);                                        \
+    return 1;                                                  \
+}
+
+#define m_poppler_get_BOOL(in, function)                       \
+static int m_##in##_##function(lua_State * L)                  \
+{                                                              \
+    udstruct *uin;                                             \
+    uin = (udstruct *) luaL_checkudata(L, 1, M_##in);          \
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)             \
+        pdfdoc_changed_error(L);                               \
+    if (((in *) uin->d)->function())                           \
+        lua_pushboolean(L, 1);                                 \
+    else                                                       \
+        lua_pushboolean(L, 0);                                 \
+    return 1;                                                  \
+}
+
+#define m_poppler_get_INT(in, function)                        \
+static int m_##in##_##function(lua_State * L)                  \
+{                                                              \
+    int i;                                                     \
+    udstruct *uin;                                             \
+    uin = (udstruct *) luaL_checkudata(L, 1, M_##in);          \
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)             \
+        pdfdoc_changed_error(L);                               \
+    i = (int) ((in *) uin->d)->function();                     \
+    lua_pushinteger(L, i);                                     \
+    return 1;                                                  \
+}
+
+
+#define m_poppler_get_GUINT(in, function)                      \
+static int m_##in##_##function(lua_State * L)                  \
+{                                                              \
+    unsigned int i;                                            \
+    udstruct *uin;                                             \
+    uin = (udstruct *) luaL_checkudata(L, 1, M_##in);          \
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)             \
+        pdfdoc_changed_error(L);                               \
+    i = (unsigned int) ((in *) uin->d)->function();            \
+    lua_pushinteger(L, i);                                     \
+    return 1;                                                  \
+}
+
+#define m_poppler_get_UINT(in, function)                       \
+m_poppler_get_GUINT(in, function)
+
+
+
+#define m_poppler_get_DOUBLE(in, function)                     \
+static int m_##in##_##function(lua_State * L)                  \
+{                                                              \
+    double d;                                                  \
+    udstruct *uin;                                             \
+    uin = (udstruct *) luaL_checkudata(L, 1, M_##in);          \
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)             \
+        pdfdoc_changed_error(L);                               \
+    d = (double) ((in *) uin->d)->function();                  \
+    lua_pushnumber(L, d); /* float */                          \
+    return 1;                                                  \
+}
+
+#define m_poppler_get_GOOSTRING(in, function)                  \
+static int m_##in##_##function(lua_State * L)                  \
+{                                                              \
+    GooString *gs;                                             \
+    udstruct *uin;                                             \
+    uin = (udstruct *) luaL_checkudata(L, 1, M_##in);          \
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)             \
+        pdfdoc_changed_error(L);                               \
+    gs = (GooString *)((in *) uin->d)->function();             \
+    if (gs != NULL)                                            \
+        lua_pushlstring(L, gs->getCString(), gs->getLength()); \
+    else                                                       \
+        lua_pushnil(L);                                        \
+    return 1;                                                  \
+}
+
+#define m_poppler_get_OBJECT(in, function)                     \
+static int m_##in##_##function(lua_State * L)                  \
+{                                                              \
+    udstruct *uin, *uout;                                      \
+    uin = (udstruct *) luaL_checkudata(L, 1, M_##in);          \
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)             \
+        pdfdoc_changed_error(L);                               \
+    uout = new_Object_userdata(L);                             \
+    uout->d = new Object();                                    \
+    *((Object *)uout->d) = ((in *) uin->d)->function();                  \
+    uout->atype = ALLOC_LEPDF;                                 \
+    uout->pc = uin->pc;                                        \
+    uout->pd = uin->pd;                                        \
+    return 1;                                                  \
+}
+
+#define m_poppler_do(in, function)                             \
+static int m_##in##_##function(lua_State * L)                  \
+{                                                              \
+    udstruct *uin;                                             \
+    uin = (udstruct *) luaL_checkudata(L, 1, M_##in);          \
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)             \
+        pdfdoc_changed_error(L);                               \
+    ((in *) uin->d)->function();                               \
+    return 0;                                                  \
+}
+
+#define m_poppler__tostring(type)                              \
+static int m_##type##__tostring(lua_State * L)                 \
+{                                                              \
+    udstruct *uin;                                             \
+    uin = (udstruct *) luaL_checkudata(L, 1, M_##type);        \
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)             \
+        pdfdoc_changed_error(L);                               \
+    lua_pushfstring(L, "%s: %p", #type, (type *) uin->d);      \
+    return 1;                                                  \
+}
+
+#define m_poppler_check_string(in, function)                   \
+static int m_##in##_##function(lua_State * L)                  \
+{                                                              \
+    const char *s;                                             \
+    udstruct *uin;                                             \
+    uin = (udstruct *) luaL_checkudata(L, 1, M_##in);          \
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)             \
+        pdfdoc_changed_error(L);                               \
+    s = luaL_checkstring(L, 2);                                \
+    if (((in *) uin->d)->function(s))                          \
+        lua_pushboolean(L, 1);                                 \
+    else                                                       \
+        lua_pushboolean(L, 0);                                 \
+    return 1;                                                  \
+}
+
+//**********************************************************************
+// Annot
+
+m_poppler_get_BOOL(Annot, isOk);
+
+static int m_Annot_match(lua_State * L)
+{
+    udstruct *uin, *uref;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Annot);
+    uref = (udstruct *) luaL_checkudata(L, 2, M_Ref);
+    if (uin->pd != NULL && uref->pd != NULL && uin->pd != uref->pd)
+        pdfdoc_differs_error(L);
+    if ((uin->pd != NULL && uin->pd->pc != uin->pc)
+        || (uref->pd != NULL && uref->pd->pc != uref->pc))
+        pdfdoc_changed_error(L);
+    lua_pushboolean(L, ((Annot *) uin->d)->match((Ref *) uref->d));
+    return 1;
+}
+
+m_poppler__tostring(Annot);
+
+static int m_Annot__gc(lua_State * L)
+{
+    udstruct *uin;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Annot);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+#ifdef DEBUG
+    printf("\n===== Annot GC ===== uin=<%p>\n", uin);
+#endif
+    if (uin->atype == ALLOC_LEPDF)
+#if 1                           /* def HAVE_ANNOTDECREFCNT */
+        ((Annot *) uin->d)->decRefCnt();
+#else
+        delete(Annot *) uin->d;
+#endif
+    return 0;
+}
+
+static const struct luaL_Reg Annot_m[] = {
+    {"isOk", m_Annot_isOk},
+    {"match", m_Annot_match},
+    {"__tostring", m_Annot__tostring},
+    {"__gc", m_Annot__gc},
+    {NULL, NULL}                // sentinel
+};
+
+//**********************************************************************
+// Annots
+
+m_poppler_get_INT(Annots, getNumAnnots);
+
+static int m_Annots_getAnnot(lua_State * L)
+{
+    int i, annots;
+    udstruct *uin, *uout;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Annots);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    i = luaL_checkint(L, 2);
+    annots = ((Annots *) uin->d)->getNumAnnots();
+    if (i > 0 && i <= annots) {
+        uout = new_Annot_userdata(L);
+        uout->d = ((Annots *) uin->d)->getAnnot(i);
+        uout->pc = uin->pc;
+        uout->pd = uin->pd;
+    } else
+        lua_pushnil(L);
+    return 1;
+}
+
+m_poppler__tostring(Annots);
+
+static const struct luaL_Reg Annots_m[] = {
+    {"getNumAnnots", m_Annots_getNumAnnots},
+    {"getAnnot", m_Annots_getAnnot},
+    {"__tostring", m_Annots__tostring},
+    {NULL, NULL}                // sentinel
+};
+
+//**********************************************************************
+// Array
+// Now private
+// static int m_Array_incRef(lua_State * L)
+// {
+//     udstruct *uin;
+//     uin = (udstruct *) luaL_checkudata(L, 1, M_Array);
+//     if (uin->pd != NULL && uin->pd->pc != uin->pc)
+//         pdfdoc_changed_error(L);
+//     lua_pushinteger(L, 1);
+//     return 1;
+// }
+// Now private
+// static int m_Array_decRef(lua_State * L)
+// {
+//     int i;
+//     udstruct *uin;
+//     uin = (udstruct *) luaL_checkudata(L, 1, M_Array);
+//     if (uin->pd != NULL && uin->pd->pc != uin->pc)
+//         pdfdoc_changed_error(L);
+//     lua_pushinteger(L, 1);
+//     return 1;
+// }
+
+m_poppler_get_INT(Array, getLength);
+
+static int m_Array_add(lua_State * L)
+{
+    udstruct *uin, *uobj;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Array);
+    uobj = (udstruct *) luaL_checkudata(L, 2, M_Object);
+    if (uin->pd != NULL && uobj->pd != NULL && uin->pd != uobj->pd)
+        pdfdoc_differs_error(L);
+    if ((uin->pd != NULL && uin->pd->pc != uin->pc)
+        || (uobj->pd != NULL && uobj->pd->pc != uobj->pc))
+        pdfdoc_changed_error(L);
+    ((Array *) uin->d)->add(std::move(*((Object *) uobj->d)));
+    return 0;
+}
+
+static int m_Array_get(lua_State * L)
+{
+    int i, len;
+    udstruct *uin, *uout;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Array);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    i = luaL_checkint(L, 2);
+    len = ((Array *) uin->d)->getLength();
+    if (i > 0 && i <= len) {
+        uout = new_Object_userdata(L);
+        uout->d = new Object();
+        *((Object *) uout->d) = ((Array *) uin->d)->get(i - 1);
+        uout->atype = ALLOC_LEPDF;
+        uout->pc = uin->pc;
+        uout->pd = uin->pd;
+    } else
+        lua_pushnil(L);
+    return 1;
+}
+
+static int m_Array_getNF(lua_State * L)
+{
+    int i, len;
+    udstruct *uin, *uout;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Array);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    i = luaL_checkint(L, 2);
+    len = ((Array *) uin->d)->getLength();
+    if (i > 0 && i <= len) {
+        uout = new_Object_userdata(L);
+        uout->d = new Object();
+        *((Object *) uout->d) = ((Array *) uin->d)->getNF(i - 1);
+        uout->atype = ALLOC_LEPDF;
+        uout->pc = uin->pc;
+        uout->pd = uin->pd;
+    } else
+        lua_pushnil(L);
+    return 1;
+}
+
+static int m_Array_getString(lua_State * L)
+{
+    GooString *gs;
+    int i, len;
+    udstruct *uin;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Array);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    i = luaL_checkint(L, 2);
+    len = ((Array *) uin->d)->getLength();
+    if (i > 0 && i <= len) {
+        gs = new GooString();
+        if (((Array *) uin->d)->getString(i - 1, gs))
+            lua_pushlstring(L, gs->getCString(), gs->getLength());
+        else
+            lua_pushnil(L);
+        delete gs;
+    } else
+        lua_pushnil(L);
+    return 1;
+}
+
+m_poppler__tostring(Array);
+
+static const struct luaL_Reg Array_m[] = {
+    // {"incRef", m_Array_incRef},// Now private
+    // {"decRef", m_Array_decRef},// Now private
+    {"getLength", m_Array_getLength},
+    {"add", m_Array_add},
+    {"get", m_Array_get},
+    {"getNF", m_Array_getNF},
+    {"getString", m_Array_getString},
+    {"__tostring", m_Array__tostring},
+    {NULL, NULL}                // sentinel
+};
+
+//**********************************************************************
+// Catalog
+
+m_poppler_get_BOOL(Catalog, isOk);
+m_poppler_get_INT(Catalog, getNumPages);
+
+static int m_Catalog_getPage(lua_State * L)
+{
+    int i, pages;
+    udstruct *uin, *uout;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Catalog);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    i = luaL_checkint(L, 2);
+    pages = ((Catalog *) uin->d)->getNumPages();
+    if (i > 0 && i <= pages) {
+        uout = new_Page_userdata(L);
+        uout->d = ((Catalog *) uin->d)->getPage(i);
+        uout->pc = uin->pc;
+        uout->pd = uin->pd;
+    } else
+        lua_pushnil(L);
+    return 1;
+}
+
+static int m_Catalog_getPageRef(lua_State * L)
+{
+    int i, pages;
+    udstruct *uin, *uout;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Catalog);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    i = luaL_checkint(L, 2);
+    pages = ((Catalog *) uin->d)->getNumPages();
+    if (i > 0 && i <= pages) {
+        uout = new_Ref_userdata(L);
+        uout->d = (Ref *) gmalloc(sizeof(Ref));
+        ((Ref *) uout->d)->num = ((Catalog *) uin->d)->getPageRef(i)->num;
+        ((Ref *) uout->d)->gen = ((Catalog *) uin->d)->getPageRef(i)->gen;
+        uout->atype = ALLOC_LEPDF;
+        uout->pc = uin->pc;
+        uout->pd = uin->pd;
+    } else
+        lua_pushnil(L);
+    return 1;
+}
+
+m_poppler_get_GOOSTRING(Catalog, getBaseURI);
+m_poppler_get_GOOSTRING(Catalog, readMetadata);
+m_poppler_get_poppler(Catalog, StructTreeRoot, getStructTreeRoot);
+
+static int m_Catalog_findPage(lua_State * L)
+{
+    int num, gen, i;
+    udstruct *uin;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Catalog);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    num = luaL_checkint(L, 2);
+    gen = luaL_checkint(L, 3);
+    i = ((Catalog *) uin->d)->findPage(num, gen);
+    if (i > 0)
+        lua_pushinteger(L, i);
+    else
+        lua_pushnil(L);
+    return 1;
+}
+
+static int m_Catalog_findDest(lua_State * L)
+{
+    GooString *name;
+    LinkDest *dest;
+    const char *s;
+    size_t len;
+    udstruct *uin, *uout;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Catalog);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    s = luaL_checklstring(L, 2, &len);
+    name = new GooString(s, len);
+    dest = ((Catalog *) uin->d)->findDest(name);
+    if (dest != NULL) {
+        uout = new_LinkDest_userdata(L);
+        uout->d = dest;
+        uout->pc = uin->pc;
+        uout->pd = uin->pd;
+    } else
+        lua_pushnil(L);
+    delete name;
+    return 1;
+}
+
+m_poppler_get_poppler(Catalog, Object, getDests);
+m_poppler_get_INT(Catalog, numEmbeddedFiles);
+
+static int m_Catalog_embeddedFile(lua_State * L)
+{
+    int i, len;
+    udstruct *uin, *uout;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Catalog);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    i = luaL_checkint(L, 2);
+    len = ((Catalog *) uin->d)->numEmbeddedFiles();
+    if (i > 0 && i <= len) {
+        uout = new_FileSpec_userdata(L);
+        uout->d = ((Catalog *) uin->d)->embeddedFile(i - 1);
+        uout->pc = uin->pc;
+        uout->pd = uin->pd;
+    } else
+        lua_pushnil(L);
+    return 1;
+}
+
+m_poppler_get_INT(Catalog, numJS);
+
+static int m_Catalog_getJS(lua_State * L)
+{
+    GooString *gs;
+    int i, len;
+    udstruct *uin;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Catalog);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    i = luaL_checkint(L, 2);
+    len = ((Catalog *) uin->d)->numJS();
+    if (i > 0 && i <= len) {
+        gs = ((Catalog *) uin->d)->getJS(i - 1);
+        if (gs != NULL)
+            lua_pushlstring(L, gs->getCString(), gs->getLength());
+        else
+            lua_pushnil(L);
+        delete gs;
+    } else
+        lua_pushnil(L);
+    return 1;
+}
+
+m_poppler_get_poppler(Catalog, Object, getOutline);
+m_poppler_get_poppler(Catalog, Object, getAcroForm);
+
+m_poppler__tostring(Catalog);
+
+static const struct luaL_Reg Catalog_m[] = {
+    {"isOk", m_Catalog_isOk},
+    {"getNumPages", m_Catalog_getNumPages},
+    {"getPage", m_Catalog_getPage},
+    {"getPageRef", m_Catalog_getPageRef},
+    {"getBaseURI", m_Catalog_getBaseURI},
+    {"readMetadata", m_Catalog_readMetadata},
+    {"getStructTreeRoot", m_Catalog_getStructTreeRoot},
+    {"findPage", m_Catalog_findPage},
+    {"findDest", m_Catalog_findDest},
+    {"getDests", m_Catalog_getDests},
+    {"numEmbeddedFiles", m_Catalog_numEmbeddedFiles},
+    {"embeddedFile", m_Catalog_embeddedFile},
+    {"numJS", m_Catalog_numJS},
+    {"getJS", m_Catalog_getJS},
+    {"getOutline", m_Catalog_getOutline},
+    {"getAcroForm", m_Catalog_getAcroForm},
+    {"__tostring", m_Catalog__tostring},
+    {NULL, NULL}                // sentinel
+};
+
+//**********************************************************************
+// Dict
+// Now private
+// static int m_Dict_incRef(lua_State * L)
+// {
+//     udstruct *uin;
+//     uin = (udstruct *) luaL_checkudata(L, 1, M_Dict);
+//     if (uin->pd != NULL && uin->pd->pc != uin->pc)
+//         pdfdoc_changed_error(L);
+//     lua_pushinteger(L, 1);
+//     return 1;
+// }
+// Now private
+// static int m_Dict_decRef(lua_State * L)
+// {
+//     udstruct *uin;
+//     uin = (udstruct *) luaL_checkudata(L, 1, M_Dict);
+//     if (uin->pd != NULL && uin->pd->pc != uin->pc)
+//         pdfdoc_changed_error(L);
+//     lua_pushinteger(L, 1);
+//     return 1;
+// }
+
+m_poppler_get_INT(Dict, getLength);
+
+static int m_Dict_add(lua_State * L)
+{
+    char *s;
+    udstruct *uin, *uobj;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Dict);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    s = copyString(luaL_checkstring(L, 2));
+    uobj = (udstruct *) luaL_checkudata(L, 3, M_Object);
+    ((Dict *) uin->d)->add(s, std::move(*((Object *) uobj->d)));
+    return 0;
+}
+
+static int m_Dict_set(lua_State * L)
+{
+    const char *s;
+    udstruct *uin, *uobj;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Dict);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    s = luaL_checkstring(L, 2);
+    uobj = (udstruct *) luaL_checkudata(L, 3, M_Object);
+    ((Dict *) uin->d)->set(s, std::move(*((Object *) uobj->d)));
+    return 0;
+}
+
+static int m_Dict_remove(lua_State * L)
+{
+    const char *s;
+    udstruct *uin;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Dict);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    s = luaL_checkstring(L, 2);
+    ((Dict *) uin->d)->remove(s);
+    return 0;
+}
+
+m_poppler_check_string(Dict, is);
+
+static int m_Dict_lookup(lua_State * L)
+{
+    const char *s;
+    udstruct *uin, *uout;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Dict);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    s = luaL_checkstring(L, 2);
+    uout = new_Object_userdata(L);
+    uout->d = new Object();
+    *((Object *) uout->d) = ((Dict *) uin->d)->lookup(s);
+    uout->atype = ALLOC_LEPDF;
+    uout->pc = uin->pc;
+    uout->pd = uin->pd;
+    return 1;
+}
+
+static int m_Dict_lookupNF(lua_State * L)
+{
+    const char *s;
+    udstruct *uin, *uout;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Dict);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    s = luaL_checkstring(L, 2);
+    uout = new_Object_userdata(L);
+    uout->d = new Object();
+    *((Object *) uout->d) = ((Dict *) uin->d)->lookupNF(s);
+    uout->atype = ALLOC_LEPDF;
+    uout->pc = uin->pc;
+    uout->pd = uin->pd;
+    return 1;
+}
+
+static int m_Dict_lookupInt(lua_State * L)
+{
+    const char *s1, *s2;
+    int i;
+    udstruct *uin;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Dict);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    s1 = luaL_checkstring(L, 2);
+    s2 = luaL_checkstring(L, 3);
+    if (((Dict *) uin->d)->lookupInt(s1, s2, &i))
+        lua_pushinteger(L, i);
+    else
+        lua_pushnil(L);
+    return 1;
+}
+
+static int m_Dict_getKey(lua_State * L)
+{
+    int i, len;
+    udstruct *uin;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Dict);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    i = luaL_checkint(L, 2);
+    len = ((Dict *) uin->d)->getLength();
+    if (i > 0 && i <= len)
+        lua_pushstring(L, ((Dict *) uin->d)->getKey(i - 1));
+    else
+        lua_pushnil(L);
+    return 1;
+}
+
+static int m_Dict_getVal(lua_State * L)
+{
+    int i, len;
+    udstruct *uin, *uout;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Dict);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    i = luaL_checkint(L, 2);
+    len = ((Dict *) uin->d)->getLength();
+    if (i > 0 && i <= len) {
+        uout = new_Object_userdata(L);
+        uout->d = new Object();
+        *((Object *) uout->d) = ((Dict *) uin->d)->getVal(i - 1);
+        uout->atype = ALLOC_LEPDF;
+        uout->pc = uin->pc;
+        uout->pd = uin->pd;
+    } else
+        lua_pushnil(L);
+    return 1;
+}
+
+static int m_Dict_getValNF(lua_State * L)
+{
+    int i, len;
+    udstruct *uin, *uout;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Dict);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    i = luaL_checkint(L, 2);
+    len = ((Dict *) uin->d)->getLength();
+    if (i > 0 && i <= len) {
+        uout = new_Object_userdata(L);
+        uout->d = new Object();
+        *((Object *) uout->d) = ((Dict *) uin->d)->getValNF(i - 1);
+        uout->atype = ALLOC_LEPDF;
+        uout->pc = uin->pc;
+        uout->pd = uin->pd;
+    } else
+        lua_pushnil(L);
+    return 1;
+}
+
+m_poppler_check_string(Dict, hasKey);
+
+m_poppler__tostring(Dict);
+
+static const struct luaL_Reg Dict_m[] = {
+    // {"incRef", m_Dict_incRef},// Now private
+    // {"decRef", m_Dict_decRef},// Now private
+    {"getLength", m_Dict_getLength},
+    {"add", m_Dict_add},
+    {"set", m_Dict_set},
+    {"remove", m_Dict_remove},
+    {"is", m_Dict_is},
+    {"lookup", m_Dict_lookup},
+    {"lookupNF", m_Dict_lookupNF},
+    {"lookupInt", m_Dict_lookupInt},
+    {"getKey", m_Dict_getKey},
+    {"getVal", m_Dict_getVal},
+    {"getValNF", m_Dict_getValNF},
+    {"hasKey", m_Dict_hasKey},
+    {"__tostring", m_Dict__tostring},
+    {NULL, NULL}                // sentinel
+};
+
+//**********************************************************************
+// EmbFile
+
+m_poppler_get_INT(EmbFile, size);
+m_poppler_get_GOOSTRING(EmbFile, modDate);
+m_poppler_get_GOOSTRING(EmbFile, createDate);
+m_poppler_get_GOOSTRING(EmbFile, checksum);
+m_poppler_get_GOOSTRING(EmbFile, mimeType);
+
+m_poppler_get_BOOL(EmbFile, isOk);
+
+static int m_EmbFile_save(lua_State * L)
+{
+    const char *s;
+    size_t len;
+    udstruct *uin;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_EmbFile);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    s = luaL_checklstring(L, 2, &len);
+    if (((EmbFile *) uin->d)->save(s))
+        lua_pushboolean(L, 1);
+    else
+        lua_pushboolean(L, 0);
+    return 1;
+}
+
+m_poppler__tostring(EmbFile);
+
+static const struct luaL_Reg EmbFile_m[] = {
+    {"size", m_EmbFile_size},
+    {"modDate", m_EmbFile_modDate},
+    {"createDate", m_EmbFile_createDate},
+    {"checksum", m_EmbFile_checksum},
+    {"mimeType", m_EmbFile_mimeType},
+    {"isOk", m_EmbFile_isOk},
+    {"save", m_EmbFile_save},
+    {"__tostring", m_EmbFile__tostring},
+    {NULL, NULL}                // sentinel
+};
+
+//**********************************************************************
+// FileSpec
+
+m_poppler_get_BOOL(FileSpec, isOk);
+m_poppler_get_GOOSTRING(FileSpec, getFileName);
+m_poppler_get_GOOSTRING(FileSpec, getFileNameForPlatform);
+m_poppler_get_GOOSTRING(FileSpec, getDescription);
+
+static int m_FileSpec_getEmbeddedFile(lua_State * L)
+{
+    udstruct *uin, *uout;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_FileSpec);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    uout = new_EmbFile_userdata(L);
+    uout->d = ((FileSpec *) uin->d)->getEmbeddedFile();
+    uout->pc = uin->pc;
+    uout->pd = uin->pd;
+    return 1;
+}
+
+m_poppler__tostring(FileSpec);
+
+static const struct luaL_Reg FileSpec_m[] = {
+    {"isOk", m_FileSpec_isOk},
+    {"getFileName", m_FileSpec_getFileName},
+    {"getFileNameForPlatform", m_FileSpec_getFileNameForPlatform},
+    {"getDescription", m_FileSpec_getDescription},
+    {"getEmbeddedFile", m_FileSpec_getEmbeddedFile},
+    {"__tostring", m_FileSpec__tostring},
+    {NULL, NULL}                // sentinel
+};
+
+//**********************************************************************
+// GooString
+
+static int m_GooString__tostring(lua_State * L)
+{
+    udstruct *uin;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_GooString);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    lua_pushlstring(L, ((GooString *) uin->d)->getCString(),
+                    ((GooString *) uin->d)->getLength());
+    return 1;
+}
+
+static const struct luaL_Reg GooString_m[] = {
+    {"__tostring", m_GooString__tostring},
+    {NULL, NULL}                // sentinel
+};
+
+//**********************************************************************
+// LinkDest
+
+static const char *LinkDestKindNames[] =
+    { "XYZ", "Fit", "FitH", "FitV", "FitR", "FitB", "FitBH", "FitBV", NULL };
+
+m_poppler_get_BOOL(LinkDest, isOk);
+
+static int m_LinkDest_getKind(lua_State * L)
+{
+    int i;
+    udstruct *uin;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_LinkDest);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    i = (int) ((LinkDest *) uin->d)->getKind();
+    lua_pushinteger(L, i);
+    return 1;
+}
+
+static int m_LinkDest_getKindName(lua_State * L)
+{
+    int i;
+    udstruct *uin;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_LinkDest);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    i = (int) ((LinkDest *) uin->d)->getKind();
+    lua_pushstring(L, LinkDestKindNames[i]);
+    return 1;
+}
+
+m_poppler_get_BOOL(LinkDest, isPageRef);
+m_poppler_get_INT(LinkDest, getPageNum);
+
+static int m_LinkDest_getPageRef(lua_State * L)
+{
+    udstruct *uin, *uout;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_LinkDest);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    uout = new_Ref_userdata(L);
+    uout->d = (Ref *) gmalloc(sizeof(Ref));
+    ((Ref *) uout->d)->num = ((LinkDest *) uin->d)->getPageRef().num;
+    ((Ref *) uout->d)->gen = ((LinkDest *) uin->d)->getPageRef().gen;
+    uout->atype = ALLOC_LEPDF;
+    uout->pc = uin->pc;
+    uout->pd = uin->pd;
+    return 1;
+}
+
+m_poppler_get_DOUBLE(LinkDest, getLeft);
+m_poppler_get_DOUBLE(LinkDest, getBottom);
+m_poppler_get_DOUBLE(LinkDest, getRight);
+m_poppler_get_DOUBLE(LinkDest, getTop);
+m_poppler_get_DOUBLE(LinkDest, getZoom);
+m_poppler_get_BOOL(LinkDest, getChangeLeft);
+m_poppler_get_BOOL(LinkDest, getChangeTop);
+m_poppler_get_BOOL(LinkDest, getChangeZoom);
+
+m_poppler__tostring(LinkDest);
+
+static const struct luaL_Reg LinkDest_m[] = {
+    {"isOk", m_LinkDest_isOk},
+    {"getKind", m_LinkDest_getKind},
+    {"getKindName", m_LinkDest_getKindName},    // not poppler
+    {"isPageRef", m_LinkDest_isPageRef},
+    {"getPageNum", m_LinkDest_getPageNum},
+    {"getPageRef", m_LinkDest_getPageRef},
+    {"getLeft", m_LinkDest_getLeft},
+    {"getBottom", m_LinkDest_getBottom},
+    {"getRight", m_LinkDest_getRight},
+    {"getTop", m_LinkDest_getTop},
+    {"getZoom", m_LinkDest_getZoom},
+    {"getChangeLeft", m_LinkDest_getChangeLeft},
+    {"getChangeTop", m_LinkDest_getChangeTop},
+    {"getChangeZoom", m_LinkDest_getChangeZoom},
+    {"__tostring", m_LinkDest__tostring},
+    {NULL, NULL}                // sentinel
+};
+
+//**********************************************************************
+// Links
+
+m_poppler_get_INT(Links, getNumLinks);
+
+m_poppler__tostring(Links);
+
+static const struct luaL_Reg Links_m[] = {
+    {"getNumLinks", m_Links_getNumLinks},
+    //{"getLink", m_Links_getLink},
+    {"__tostring", m_Links__tostring},
+    {NULL, NULL}                // sentinel
+};
+
+//**********************************************************************
+// Object
+
+#ifdef HAVE_OBJECT_INITCMD_CONST_CHARP
+#define CHARP_CAST
+#else
+// must cast arg of Object::initCmd, Object::isStream, and Object::streamIs
+// from 'const char *' to 'char *', although they are not modified.
+#define CHARP_CAST (char *)
+#endif
+
+// Special type checking.
+#define m_Object_isType_(function, cast)                                   \
+static int m_Object_##function(lua_State * L)                              \
+{                                                                          \
+    udstruct *uin;                                                         \
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Object);                    \
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)                         \
+        pdfdoc_changed_error(L);                                           \
+    if (lua_gettop(L) >= 2) {                                              \
+        if (lua_isstring(L, 2)                                             \
+            && ((Object *) uin->d)->function(cast lua_tostring(L, 2)))     \
+            lua_pushboolean(L, 1);                                         \
+        else                                                               \
+            lua_pushboolean(L, 0);                                         \
+    } else {                                                               \
+        if (((Object *) uin->d)->function())                               \
+            lua_pushboolean(L, 1);                                         \
+        else                                                               \
+            lua_pushboolean(L, 0);                                         \
+    }                                                                      \
+    return 1;                                                              \
+}
+#define m_Object_isType(function) m_Object_isType_(function, )
+#define m_Object_isType_nonconst(function) m_Object_isType_(function, CHARP_CAST)
+
+static int m_Object_initBool(lua_State * L)
+{
+    udstruct *uin;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Object);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    luaL_checktype(L, 2, LUA_TBOOLEAN);
+    if (lua_toboolean(L, 2) != 0)
+        *((Object *) uin->d) = Object(gTrue);
+    else
+        *((Object *) uin->d) = Object(gFalse);
+    return 0;
+}
+
+static int m_Object_initInt(lua_State * L)
+{
+    int i;
+    udstruct *uin;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Object);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    i = luaL_checkint(L, 2);
+    *((Object *) uin->d) = Object(i);
+    return 0;
+}
+
+static int m_Object_initReal(lua_State * L)
+{
+    double d;
+    udstruct *uin;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Object);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    d = luaL_checknumber(L, 2);
+    *((Object *) uin->d) = Object(d);
+    return 0;
+}
+
+static int m_Object_initString(lua_State * L)
+{
+    GooString *gs;
+    const char *s;
+    size_t len;
+    udstruct *uin;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Object);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    s = luaL_checklstring(L, 2, &len);
+    gs = new GooString(s, len);
+    *((Object *) uin->d) = Object(gs);
+    return 0;
+}
+
+static int m_Object_initName(lua_State * L)
+{
+    const char *s;
+    udstruct *uin;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Object);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    s = luaL_checkstring(L, 2);
+    *((Object *) uin->d) = Object(objName, s);
+    return 0;
+}
+
+static int m_Object_initNull(lua_State * L)
+{
+    udstruct *uin;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Object);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    *((Object *) uin->d) = Object(objNull);
+    return 0;
+}
+
+static int m_Object_initArray(lua_State * L)
+{
+    udstruct *uin, *uxref;
+    Array *a;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Object);
+    uxref = (udstruct *) luaL_checkudata(L, 2, M_XRef);
+    if (uin->pd != NULL && uxref->pd != NULL && uin->pd != uxref->pd)
+        pdfdoc_differs_error(L);
+    if ((uin->pd != NULL && uin->pd->pc != uin->pc)
+        || (uxref->pd != NULL && uxref->pd->pc != uxref->pc))
+        pdfdoc_changed_error(L);
+    a = new Array((XRef *) uxref->d);
+    *((Object *) uin->d) = Object(a);
+    return 0;
+}
+
+// TODO: decide betweeen
+//   Object *initDict(XRef *xref);
+//   Object *initDict(Dict *dictA);
+
+static int m_Object_initDict(lua_State * L)
+{
+    udstruct *uin, *uxref;
+    Dict *d;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Object);
+    uxref = (udstruct *) luaL_checkudata(L, 2, M_XRef);
+    if (uin->pd != NULL && uxref->pd != NULL && uin->pd != uxref->pd)
+        pdfdoc_differs_error(L);
+    if ((uin->pd != NULL && uin->pd->pc != uin->pc)
+        || (uxref->pd != NULL && uxref->pd->pc != uxref->pc))
+        pdfdoc_changed_error(L);
+    d = new Dict((XRef *) uxref->d);
+    *((Object *) uin->d) = Object(d);
+    return 0;
+}
+
+static int m_Object_initStream(lua_State * L)
+{
+    udstruct *uin, *ustream;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Object);
+    ustream = (udstruct *) luaL_checkudata(L, 2, M_Stream);
+    if (uin->pd != NULL && ustream->pd != NULL && uin->pd != ustream->pd)
+        pdfdoc_differs_error(L);
+    if ((uin->pd != NULL && uin->pd->pc != uin->pc)
+        || (ustream->pd != NULL && ustream->pd->pc != ustream->pc))
+        pdfdoc_changed_error(L);
+    *((Object *) uin->d) = Object((Stream *) ustream->d);
+    return 0;
+}
+
+static int m_Object_initRef(lua_State * L)
+{
+    int num, gen;
+    udstruct *uin;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Object);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    num = luaL_checkint(L, 2);
+    gen = luaL_checkint(L, 3);
+    *((Object *) uin->d) = Object(num, gen);
+    return 0;
+}
+
+static int m_Object_initCmd(lua_State * L)
+{
+    const char *s;
+    udstruct *uin;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Object);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    s = luaL_checkstring(L, 2);
+    *((Object *) uin->d) = Object(objCmd, s);
+    return 0;
+}
+
+static int m_Object_initError(lua_State * L)
+{
+    udstruct *uin;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Object);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    *((Object *) uin->d) = Object(objError);
+    return 0;
+}
+
+static int m_Object_initEOF(lua_State * L)
+{
+    udstruct *uin;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Object);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    *((Object *) uin->d) = Object(objEOF);
+    return 0;
+}
+
+static int m_Object_fetch(lua_State * L)
+{
+    udstruct *uin, *uxref, *uout;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Object);
+    uxref = (udstruct *) luaL_checkudata(L, 2, M_XRef);
+    if (uin->pd != NULL && uxref->pd != NULL && uin->pd != uxref->pd)
+        pdfdoc_differs_error(L);
+    if ((uin->pd != NULL && uin->pd->pc != uin->pc)
+        || (uxref->pd != NULL && uxref->pd->pc != uxref->pc))
+        pdfdoc_changed_error(L);
+    uout = new_Object_userdata(L);
+    uout->d = new Object();
+    *((Object *) uout->d) = ((Object *) uin->d)->fetch((XRef *) uxref->d);
+    uout->atype = ALLOC_LEPDF;
+    uout->pc = uin->pc;
+    uout->pd = uin->pd;
+    return 1;
+}
+
+static int m_Object_getType(lua_State * L)
+{
+    ObjType t;
+    udstruct *uin;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Object);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    t = ((Object *) uin->d)->getType();
+    lua_pushinteger(L, (int) t);
+    return 1;
+}
+
+static int m_Object_getTypeName(lua_State * L)
+{
+    udstruct *uin;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Object);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    lua_pushstring(L, ((Object *) uin->d)->getTypeName());
+    return 1;
+}
+
+m_poppler_get_BOOL(Object, isBool);
+m_poppler_get_BOOL(Object, isInt);
+m_poppler_get_BOOL(Object, isReal);
+m_poppler_get_BOOL(Object, isNum);
+m_poppler_get_BOOL(Object, isString);
+m_Object_isType(isName);
+m_poppler_get_BOOL(Object, isNull);
+m_poppler_get_BOOL(Object, isArray);
+m_Object_isType(isDict);
+m_Object_isType_nonconst(isStream);
+m_poppler_get_BOOL(Object, isRef);
+m_Object_isType(isCmd);
+m_poppler_get_BOOL(Object, isError);
+m_poppler_get_BOOL(Object, isEOF);
+m_poppler_get_BOOL(Object, isNone);
+
+static int m_Object_getBool(lua_State * L)
+{
+    udstruct *uin;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Object);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    if (((Object *) uin->d)->isBool()) {
+        if (((Object *) uin->d)->getBool())
+            lua_pushboolean(L, 1);
+        else
+            lua_pushboolean(L, 0);
+    } else
+        lua_pushnil(L);
+    return 1;
+}
+
+static int m_Object_getInt(lua_State * L)
+{
+    udstruct *uin;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Object);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    if (((Object *) uin->d)->isInt())
+        lua_pushinteger(L, ((Object *) uin->d)->getInt());
+    else
+        lua_pushnil(L);
+    return 1;
+}
+
+static int m_Object_getReal(lua_State * L)
+{
+    udstruct *uin;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Object);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    if (((Object *) uin->d)->isReal())
+        lua_pushnumber(L, ((Object *) uin->d)->getReal()); /* float */
+    else
+        lua_pushnil(L);
+    return 1;
+}
+
+static int m_Object_getNum(lua_State * L)
+{
+    udstruct *uin;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Object);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    if (((Object *) uin->d)->isInt())
+        lua_pushinteger(L, ((Object *) uin->d)->getInt());
+    else if (((Object *) uin->d)->isReal())
+        lua_pushinteger(L, ((Object *) uin->d)->getReal());
+    else if (((Object *) uin->d)->isNum()) /* redundant */
+        lua_pushnumber(L, ((Object *) uin->d)->getNum()); /* integer or float */
+    else
+        lua_pushnil(L);
+    return 1;
+}
+
+static int m_Object_getString(lua_State * L)
+{
+    GooString *gs;
+    udstruct *uin;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Object);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    if (((Object *) uin->d)->isString()) {
+        gs = (GooString *)((Object *) uin->d)->getString();
+        lua_pushlstring(L, gs->getCString(), gs->getLength());
+    } else
+        lua_pushnil(L);
+    return 1;
+}
+
+static int m_Object_getName(lua_State * L)
+{
+    udstruct *uin;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Object);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    if (((Object *) uin->d)->isName())
+        lua_pushstring(L, ((Object *) uin->d)->getName());
+    else
+        lua_pushnil(L);
+    return 1;
+}
+
+static int m_Object_getArray(lua_State * L)
+{
+    udstruct *uin, *uout;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Object);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    if (((Object *) uin->d)->isArray()) {
+        uout = new_Array_userdata(L);
+        uout->d = ((Object *) uin->d)->getArray();
+        uout->pc = uin->pc;
+        uout->pd = uin->pd;
+    } else
+        lua_pushnil(L);
+    return 1;
+}
+
+static int m_Object_getDict(lua_State * L)
+{
+    udstruct *uin, *uout;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Object);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    if (((Object *) uin->d)->isDict()) {
+        uout = new_Dict_userdata(L);
+        uout->d = ((Object *) uin->d)->getDict();
+        uout->pc = uin->pc;
+        uout->pd = uin->pd;
+    } else
+        lua_pushnil(L);
+    return 1;
+}
+
+static int m_Object_getStream(lua_State * L)
+{
+    udstruct *uin, *uout;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Object);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    if (((Object *) uin->d)->isStream()) {
+        uout = new_Stream_userdata(L);
+        uout->d = ((Object *) uin->d)->getStream();
+        uout->pc = uin->pc;
+        uout->pd = uin->pd;
+    } else
+        lua_pushnil(L);
+    return 1;
+}
+
+static int m_Object_getRef(lua_State * L)
+{
+    udstruct *uin, *uout;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Object);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    if (((Object *) uin->d)->isRef()) {
+        uout = new_Ref_userdata(L);
+        uout->d = (Ref *) gmalloc(sizeof(Ref));
+        ((Ref *) uout->d)->num = ((Object *) uin->d)->getRef().num;
+        ((Ref *) uout->d)->gen = ((Object *) uin->d)->getRef().gen;
+        uout->atype = ALLOC_LEPDF;
+        uout->pc = uin->pc;
+        uout->pd = uin->pd;
+    } else
+        lua_pushnil(L);
+    return 1;
+}
+
+static int m_Object_getRefNum(lua_State * L)
+{
+    int i;
+    udstruct *uin;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Object);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    if (((Object *) uin->d)->isRef()) {
+        i = ((Object *) uin->d)->getRef().num;
+        lua_pushinteger(L, i);
+    } else
+        lua_pushnil(L);
+    return 1;
+}
+
+static int m_Object_getRefGen(lua_State * L)
+{
+    int i;
+    udstruct *uin;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Object);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    if (((Object *) uin->d)->isRef()) {
+        i = ((Object *) uin->d)->getRef().gen;
+        lua_pushinteger(L, i);
+    } else
+        lua_pushnil(L);
+    return 1;
+}
+
+static int m_Object_getCmd(lua_State * L)
+{
+    udstruct *uin;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Object);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    if (((Object *) uin->d)->isCmd())
+        lua_pushstring(L, ((Object *) uin->d)->getCmd());
+    else
+        lua_pushnil(L);
+    return 1;
+}
+
+static int m_Object_arrayGetLength(lua_State * L)
+{
+    int len;
+    udstruct *uin;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Object);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    if (((Object *) uin->d)->isArray()) {
+        len = ((Object *) uin->d)->arrayGetLength();
+        lua_pushinteger(L, len);
+    } else
+        lua_pushnil(L);
+    return 1;
+}
+
+static int m_Object_arrayAdd(lua_State * L)
+{
+    udstruct *uin, *uobj;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Object);
+    uobj = (udstruct *) luaL_checkudata(L, 2, M_Object);
+    if (uin->pd != NULL && uobj->pd != NULL && uin->pd != uobj->pd)
+        pdfdoc_differs_error(L);
+    if ((uin->pd != NULL && uin->pd->pc != uin->pc)
+        || (uobj->pd != NULL && uobj->pd->pc != uobj->pd->pc))
+        pdfdoc_changed_error(L);
+    if (!((Object *) uin->d)->isArray())
+        luaL_error(L, "Object is not an Array");
+    ((Object *) uin->d)->arrayAdd(std::move(*((Object *) uobj->d)));
+    return 0;
+}
+
+static int m_Object_arrayGet(lua_State * L)
+{
+    int i, len;
+    udstruct *uin, *uout;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Object);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    i = luaL_checkint(L, 2);
+    if (((Object *) uin->d)->isArray()) {
+        len = ((Object *) uin->d)->arrayGetLength();
+        if (i > 0 && i <= len) {
+            uout = new_Object_userdata(L);
+            uout->d = new Object();
+            *((Object *) uout->d) = ((Object *) uin->d)->arrayGet(i - 1);
+            uout->atype = ALLOC_LEPDF;
+            uout->pc = uin->pc;
+            uout->pd = uin->pd;
+        } else
+            lua_pushnil(L);
+    } else
+        lua_pushnil(L);
+    return 1;
+}
+
+static int m_Object_arrayGetNF(lua_State * L)
+{
+    int i, len;
+    udstruct *uin, *uout;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Object);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    i = luaL_checkint(L, 2);
+    if (((Object *) uin->d)->isArray()) {
+        len = ((Object *) uin->d)->arrayGetLength();
+        if (i > 0 && i <= len) {
+            uout = new_Object_userdata(L);
+            uout->d = new Object();
+            *((Object *) uout->d) = ((Object *) uin->d)->arrayGetNF(i - 1);
+            uout->atype = ALLOC_LEPDF;
+            uout->pc = uin->pc;
+            uout->pd = uin->pd;
+        } else
+            lua_pushnil(L);
+    } else
+        lua_pushnil(L);
+    return 1;
+}
+
+static int m_Object_dictGetLength(lua_State * L)
+{
+    int len;
+    udstruct *uin;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Object);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    if (((Object *) uin->d)->isDict()) {
+        len = ((Object *) uin->d)->dictGetLength();
+        lua_pushinteger(L, len);
+    } else
+        lua_pushnil(L);
+    return 1;
+}
+
+static int m_Object_dictAdd(lua_State * L)
+{
+    const char *s;
+    udstruct *uin, *uobj;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Object);
+    s = luaL_checkstring(L, 2);
+    uobj = (udstruct *) luaL_checkudata(L, 3, M_Object);
+    if (uin->pd != NULL && uobj->pd != NULL && uin->pd != uobj->pd)
+        pdfdoc_differs_error(L);
+    if ((uin->pd != NULL && uin->pd->pc != uin->pc)
+        || (uobj->pd != NULL && uobj->pd->pc != uobj->pd->pc))
+        pdfdoc_changed_error(L);
+    if (!((Object *) uin->d)->isDict())
+        luaL_error(L, "Object is not a Dict");
+    ((Object *) uin->d)->dictAdd(copyString(s), std::move(*((Object *) uobj->d)));
+    return 0;
+}
+
+static int m_Object_dictSet(lua_State * L)
+{
+    const char *s;
+    udstruct *uin, *uobj;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Object);
+    s = luaL_checkstring(L, 2);
+    uobj = (udstruct *) luaL_checkudata(L, 3, M_Object);
+    if (uin->pd != NULL && uobj->pd != NULL && uin->pd != uobj->pd)
+        pdfdoc_differs_error(L);
+    if ((uin->pd != NULL && uin->pd->pc != uin->pc)
+        || (uobj->pd != NULL && uobj->pd->pc != uobj->pd->pc))
+        pdfdoc_changed_error(L);
+    if (!((Object *) uin->d)->isDict())
+        luaL_error(L, "Object is not a Dict");
+    ((Object *) uin->d)->dictSet(s, std::move(*((Object *) uobj->d)));
+    return 0;
+}
+
+static int m_Object_dictLookup(lua_State * L)
+{
+    const char *s;
+    udstruct *uin, *uout;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Object);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    s = luaL_checkstring(L, 2);
+    if (((Object *) uin->d)->isDict()) {
+        uout = new_Object_userdata(L);
+        uout->d = new Object();
+        *((Object *) uout->d) = ((Object *) uin->d)->dictLookup(s);
+        uout->atype = ALLOC_LEPDF;
+        uout->pc = uin->pc;
+        uout->pd = uin->pd;
+    } else
+        lua_pushnil(L);
+    return 1;
+}
+
+static int m_Object_dictLookupNF(lua_State * L)
+{
+    const char *s;
+    udstruct *uin, *uout;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Object);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    s = luaL_checkstring(L, 2);
+    if (((Object *) uin->d)->isDict()) {
+        uout = new_Object_userdata(L);
+        uout->d = new Object();
+        *((Object *) uout->d) = ((Object *) uin->d)->dictLookupNF(s);
+        uout->atype = ALLOC_LEPDF;
+        uout->pc = uin->pc;
+        uout->pd = uin->pd;
+    } else
+        lua_pushnil(L);
+    return 1;
+}
+
+static int m_Object_dictGetKey(lua_State * L)
+{
+    int i, len;
+    udstruct *uin;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Object);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    i = luaL_checkint(L, 2);
+    if (((Object *) uin->d)->isDict()) {
+        len = ((Object *) uin->d)->dictGetLength();
+        if (i > 0 && i <= len)
+            lua_pushstring(L, ((Object *) uin->d)->dictGetKey(i - 1));
+        else
+            lua_pushnil(L);
+    } else
+        lua_pushnil(L);
+    return 1;
+}
+
+static int m_Object_dictGetVal(lua_State * L)
+{
+    int i, len;
+    udstruct *uin, *uout;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Object);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    i = luaL_checkint(L, 2);
+    if (((Object *) uin->d)->isDict()) {
+        len = ((Object *) uin->d)->dictGetLength();
+        if (i > 0 && i <= len) {
+            uout = new_Object_userdata(L);
+            uout->d = new Object();
+	    *((Object *) uout->d) = ((Object *) uin->d)->dictGetVal(i - 1);
+            uout->atype = ALLOC_LEPDF;
+            uout->pc = uin->pc;
+            uout->pd = uin->pd;
+        } else
+            lua_pushnil(L);
+    } else
+        lua_pushnil(L);
+    return 1;
+}
+
+static int m_Object_dictGetValNF(lua_State * L)
+{
+    int i, len;
+    udstruct *uin, *uout;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Object);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    i = luaL_checkint(L, 2);
+    if (((Object *) uin->d)->isDict()) {
+        len = ((Object *) uin->d)->dictGetLength();
+        if (i > 0 && i <= len) {
+            uout = new_Object_userdata(L);
+            uout->d = new Object();
+            *((Object *) uout->d) = ((Object *) uin->d)->dictGetValNF(i - 1);
+            uout->atype = ALLOC_LEPDF;
+            uout->pc = uin->pc;
+            uout->pd = uin->pd;
+        } else
+            lua_pushnil(L);
+    } else
+        lua_pushnil(L);
+    return 1;
+}
+
+static int m_Object_streamIs(lua_State * L)
+{
+    const char *s;
+    udstruct *uin;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Object);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    s = luaL_checkstring(L, 2);
+    if (((Object *) uin->d)->isStream()) {
+        if (((Object *) uin->d)->streamIs(CHARP_CAST s))
+            lua_pushboolean(L, 1);
+        else
+            lua_pushboolean(L, 0);
+    } else
+        lua_pushnil(L);
+    return 1;
+}
+
+static int m_Object_streamReset(lua_State * L)
+{
+    udstruct *uin;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Object);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    if (((Object *) uin->d)->isStream())
+        ((Object *) uin->d)->streamReset();
+    return 0;
+}
+
+static int m_Object_streamGetChar(lua_State * L)
+{
+    int i;
+    udstruct *uin;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Object);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    if (((Object *) uin->d)->isStream()) {
+        i = ((Object *) uin->d)->streamGetChar();
+        lua_pushinteger(L, i);
+    } else
+        lua_pushnil(L);
+    return 1;
+}
+
+static int m_Object_streamLookChar(lua_State * L)
+{
+    int i;
+    udstruct *uin;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Object);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    if (((Object *) uin->d)->isStream()) {
+        i = ((Object *) uin->d)->streamLookChar();
+        lua_pushinteger(L, i);
+    } else
+        lua_pushnil(L);
+    return 1;
+}
+
+static int m_Object_streamGetPos(lua_State * L)
+{
+    int i;
+    udstruct *uin;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Object);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    if (((Object *) uin->d)->isStream()) {
+        i = (int) ((Object *) uin->d)->streamGetPos();
+        lua_pushinteger(L, i);
+    } else
+        lua_pushnil(L);
+    return 1;
+}
+
+static int m_Object_streamSetPos(lua_State * L)
+{
+    int i;
+    udstruct *uin;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Object);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    i = luaL_checkint(L, 2);
+    if (((Object *) uin->d)->isStream())
+        ((Object *) uin->d)->streamSetPos(i);
+    return 0;
+}
+
+static int m_Object_streamGetDict(lua_State * L)
+{
+    udstruct *uin, *uout;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Object);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    if (((Object *) uin->d)->isStream()) {
+        uout = new_Dict_userdata(L);
+        uout->d = ((Object *) uin->d)->streamGetDict();
+        uout->pc = uin->pc;
+        uout->pd = uin->pd;
+    } else
+        lua_pushnil(L);
+    return 1;
+}
+
+static int m_Object__gc(lua_State * L)
+{
+    udstruct *uin;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Object);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+#ifdef DEBUG
+    printf("\n===== Object GC ===== uin=<%p>\n", uin);
+#endif
+    if (uin->atype == ALLOC_LEPDF) {
+      // free() seems to collide with the lua gc
+      //((Object *) uin->d)->free();
+        delete(Object *) uin->d;
+    }
+    return 0;
+}
+
+m_poppler__tostring(Object);
+
+static const struct luaL_Reg Object_m[] = {
+    {"initBool", m_Object_initBool},
+    {"initInt", m_Object_initInt},
+    {"initReal", m_Object_initReal},
+    {"initString", m_Object_initString},
+    {"initName", m_Object_initName},
+    {"initNull", m_Object_initNull},
+    {"initArray", m_Object_initArray},
+    {"initDict", m_Object_initDict},
+    {"initStream", m_Object_initStream},
+    {"initRef", m_Object_initRef},
+    {"initCmd", m_Object_initCmd},
+    {"initError", m_Object_initError},
+    {"initEOF", m_Object_initEOF},
+    // {"copy", m_Object_copy},
+    {"fetch", m_Object_fetch},
+    {"getType", m_Object_getType},
+    {"getTypeName", m_Object_getTypeName},
+    {"isBool", m_Object_isBool},
+    {"isInt", m_Object_isInt},
+    {"isReal", m_Object_isReal},
+    {"isNum", m_Object_isNum},
+    {"isString", m_Object_isString},
+    {"isName", m_Object_isName},
+    {"isNull", m_Object_isNull},
+    {"isArray", m_Object_isArray},
+    {"isDict", m_Object_isDict},
+    {"isStream", m_Object_isStream},
+    {"isRef", m_Object_isRef},
+    {"isCmd", m_Object_isCmd},
+    {"isError", m_Object_isError},
+    {"isEOF", m_Object_isEOF},
+    {"isNone", m_Object_isNone},
+    {"getBool", m_Object_getBool},
+    {"getInt", m_Object_getInt},
+    {"getReal", m_Object_getReal},
+    {"getNum", m_Object_getNum},
+    {"getString", m_Object_getString},
+    {"getName", m_Object_getName},
+    {"getArray", m_Object_getArray},
+    {"getDict", m_Object_getDict},
+    {"getStream", m_Object_getStream},
+    {"getRef", m_Object_getRef},
+    {"getRefNum", m_Object_getRefNum},
+    {"getRefGen", m_Object_getRefGen},
+    {"getCmd", m_Object_getCmd},
+    {"arrayGetLength", m_Object_arrayGetLength},
+    {"arrayAdd", m_Object_arrayAdd},
+    {"arrayGet", m_Object_arrayGet},
+    {"arrayGetNF", m_Object_arrayGetNF},
+    {"dictGetLength", m_Object_dictGetLength},
+    {"dictAdd", m_Object_dictAdd},
+    {"dictSet", m_Object_dictSet},
+    {"dictLookup", m_Object_dictLookup},
+    {"dictLookupNF", m_Object_dictLookupNF},
+    {"dictGetKey", m_Object_dictGetKey},
+    {"dictGetVal", m_Object_dictGetVal},
+    {"dictGetValNF", m_Object_dictGetValNF},
+    {"streamIs", m_Object_streamIs},
+    {"streamReset", m_Object_streamReset},
+    // {"streamClose", m_Object_streamClose},
+    {"streamGetChar", m_Object_streamGetChar},
+    {"streamLookChar", m_Object_streamLookChar},
+    // {"streamGetLine", m_Object_streamGetLine},
+    {"streamGetPos", m_Object_streamGetPos},
+    {"streamSetPos", m_Object_streamSetPos},
+    {"streamGetDict", m_Object_streamGetDict},
+    {"__tostring", m_Object__tostring},
+    {"__gc", m_Object__gc},     // finalizer
+    {NULL, NULL}                // sentinel
+};
+
+//**********************************************************************
+// Page
+
+m_poppler_get_BOOL(Page, isOk);
+m_poppler_get_INT(Page, getNum);
+m_poppler_get_poppler(Page, PDFRectangle, getMediaBox);
+m_poppler_get_poppler(Page, PDFRectangle, getCropBox);
+m_poppler_get_BOOL(Page, isCropped);
+m_poppler_get_DOUBLE(Page, getMediaWidth);
+m_poppler_get_DOUBLE(Page, getMediaHeight);
+m_poppler_get_DOUBLE(Page, getCropWidth);
+m_poppler_get_DOUBLE(Page, getCropHeight);
+m_poppler_get_poppler(Page, PDFRectangle, getBleedBox);
+m_poppler_get_poppler(Page, PDFRectangle, getTrimBox);
+m_poppler_get_poppler(Page, PDFRectangle, getArtBox);
+m_poppler_get_INT(Page, getRotate);
+m_poppler_get_GOOSTRING(Page, getLastModified);
+m_poppler_get_poppler(Page, Dict, getBoxColorInfo);
+m_poppler_get_poppler(Page, Dict, getGroup);
+m_poppler_get_poppler(Page, Stream, getMetadata);
+m_poppler_get_poppler(Page, Dict, getPieceInfo);
+m_poppler_get_poppler(Page, Dict, getSeparationInfo);
+m_poppler_get_poppler(Page, Dict, getResourceDict);
+m_poppler_get_OBJECT(Page, getAnnotsObject);
+
+m_poppler_get_OBJECT(Page, getContents);
+
+m_poppler__tostring(Page);
+
+static const struct luaL_Reg Page_m[] = {
+    {"isOk", m_Page_isOk},
+    {"getNum", m_Page_getNum},
+    {"getMediaBox", m_Page_getMediaBox},
+    {"getCropBox", m_Page_getCropBox},
+    {"isCropped", m_Page_isCropped},
+    {"getMediaWidth", m_Page_getMediaWidth},
+    {"getMediaHeight", m_Page_getMediaHeight},
+    {"getCropWidth", m_Page_getCropWidth},
+    {"getCropHeight", m_Page_getCropHeight},
+    {"getBleedBox", m_Page_getBleedBox},
+    {"getTrimBox", m_Page_getTrimBox},
+    {"getArtBox", m_Page_getArtBox},
+    {"getRotate", m_Page_getRotate},
+    {"getLastModified", m_Page_getLastModified},
+    {"getBoxColorInfo", m_Page_getBoxColorInfo},
+    {"getGroup", m_Page_getGroup},
+    {"getMetadata", m_Page_getMetadata},
+    {"getPieceInfo", m_Page_getPieceInfo},
+    {"getSeparationInfo", m_Page_getSeparationInfo},
+    {"getResourceDict", m_Page_getResourceDict},
+    {"getAnnotsObject", m_Page_getAnnotsObject},
+    {"getContents", m_Page_getContents},
+    {"__tostring", m_Page__tostring},
+    {NULL, NULL}                // sentinel
+};
+
+//**********************************************************************
+// PDFDoc
+
+#define m_PDFDoc_BOOL(function)                         \
+static int m_PDFDoc_##function(lua_State * L)           \
+{                                                       \
+    udstruct *uin;                                      \
+    uin = (udstruct *) luaL_checkudata(L, 1, M_PDFDoc); \
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)      \
+        pdfdoc_changed_error(L);                        \
+    if (((PdfDocument *) uin->d)->doc->function())      \
+        lua_pushboolean(L, 1);                          \
+    else                                                \
+        lua_pushboolean(L, 0);                          \
+    return 1;                                           \
+}
+
+#define m_PDFDoc_INT(function)                          \
+static int m_PDFDoc_##function(lua_State * L)           \
+{                                                       \
+    int i;                                              \
+    udstruct *uin;                                      \
+    uin = (udstruct *) luaL_checkudata(L, 1, M_PDFDoc); \
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)      \
+        pdfdoc_changed_error(L);                        \
+    i = ((PdfDocument *) uin->d)->doc->function();      \
+    lua_pushinteger(L, i);                              \
+    return 1;                                           \
+}
+
+m_PDFDoc_BOOL(isOk);
+m_PDFDoc_INT(getErrorCode);
+
+static int m_PDFDoc_getFileName(lua_State * L)
+{
+    GooString *gs;
+    udstruct *uin;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_PDFDoc);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    gs = ((PdfDocument *) uin->d)->doc->getFileName();
+    if (gs != NULL)
+        lua_pushlstring(L, gs->getCString(), gs->getLength());
+    else
+        lua_pushnil(L);
+    return 1;
+}
+
+static int m_PDFDoc_getErrorCodeName(lua_State * L)
+{
+    int i;
+    udstruct *uin;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_PDFDoc);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    i = ((PdfDocument *) uin->d)->doc->getErrorCode();
+    lua_pushstring(L, ErrorCodeNames[i]);
+    return 1;
+}
+
+static int m_PDFDoc_getXRef(lua_State * L)
+{
+    XRef *xref;
+    udstruct *uin, *uout;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_PDFDoc);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    xref = ((PdfDocument *) uin->d)->doc->getXRef();
+    if (xref->isOk()) {
+        uout = new_XRef_userdata(L);
+        uout->d = xref;
+        uout->pc = uin->pc;
+        uout->pd = uin->pd;
+    } else
+        lua_pushnil(L);
+    return 1;
+}
+
+static int m_PDFDoc_getCatalog(lua_State * L)
+{
+    Catalog *cat;
+    udstruct *uin, *uout;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_PDFDoc);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    cat = ((PdfDocument *) uin->d)->doc->getCatalog();
+    if (cat->isOk()) {
+        uout = new_Catalog_userdata(L);
+        uout->d = cat;
+        uout->pc = uin->pc;
+        uout->pd = uin->pd;
+    } else
+        lua_pushnil(L);
+    return 1;
+}
+
+#define m_PDFDoc_PAGEDIMEN(function)                             \
+static int m_PDFDoc_##function(lua_State * L)                    \
+{                                                                \
+    int i, pages;                                                \
+    double d;                                                    \
+    udstruct *uin;                                               \
+    uin = (udstruct *) luaL_checkudata(L, 1, M_PDFDoc);          \
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)               \
+        pdfdoc_changed_error(L);                                 \
+    i = luaL_checkint(L, 2);                                     \
+    pages = ((PdfDocument *) uin->d)->doc->getNumPages();        \
+    if (i > 0 && i <= pages) {                                   \
+        d = (double) ((PdfDocument *) uin->d)->doc->function(i); \
+        lua_pushnumber(L, d); /* float */                        \
+    } else                                                       \
+        lua_pushnil(L);                                          \
+    return 1;                                                    \
+}
+
+m_PDFDoc_PAGEDIMEN(getPageMediaWidth);
+m_PDFDoc_PAGEDIMEN(getPageMediaHeight);
+m_PDFDoc_PAGEDIMEN(getPageCropWidth);
+m_PDFDoc_PAGEDIMEN(getPageCropHeight);
+m_PDFDoc_INT(getNumPages);
+
+static int m_PDFDoc_readMetadata(lua_State * L)
+{
+    GooString *gs;
+    udstruct *uin;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_PDFDoc);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    if (((PdfDocument *) uin->d)->doc->getCatalog()->isOk()) {
+        gs = ((PdfDocument *) uin->d)->doc->readMetadata();
+        if (gs != NULL)
+            lua_pushlstring(L, gs->getCString(), gs->getLength());
+        else
+            lua_pushnil(L);
+    } else
+        lua_pushnil(L);
+    return 1;
+}
+
+static int m_PDFDoc_getStructTreeRoot(lua_State * L)
+{
+    StructTreeRoot *obj;
+    udstruct *uin, *uout;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_PDFDoc);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    if (((PdfDocument *) uin->d)->doc->getCatalog()->isOk()) {
+        obj = ((PdfDocument *) uin->d)->doc->getStructTreeRoot();
+        uout = new_StructTreeRoot_userdata(L);
+        uout->d = obj;
+        uout->pc = uin->pc;
+        uout->pd = uin->pd;
+    } else
+        lua_pushnil(L);
+    return 1;
+}
+
+static int m_PDFDoc_findPage(lua_State * L)
+{
+    int num, gen, i;
+    udstruct *uin;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_PDFDoc);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    num = luaL_checkint(L, 2);
+    gen = luaL_checkint(L, 3);
+    if (((PdfDocument *) uin->d)->doc->getCatalog()->isOk()) {
+        i = ((PdfDocument *) uin->d)->doc->findPage(num, gen);
+        if (i > 0)
+            lua_pushinteger(L, i);
+        else
+            lua_pushnil(L);
+    } else
+        lua_pushnil(L);
+    return 1;
+}
+
+static int m_PDFDoc_getLinks(lua_State * L)
+{
+    int i, pages;
+    Links *links;
+    udstruct *uin, *uout;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_PDFDoc);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    i = luaL_checkint(L, 2);
+    pages = ((PdfDocument *) uin->d)->doc->getNumPages();
+    if (i > 0 && i <= pages) {
+        links = ((PdfDocument *) uin->d)->doc->getLinks(i);
+        if (links != NULL) {
+            uout = new_Links_userdata(L);
+            uout->d = links;
+            uout->pc = uin->pc;
+            uout->pd = uin->pd;
+        } else
+            lua_pushnil(L);
+    } else
+        lua_pushnil(L);
+    return 1;
+}
+
+static int m_PDFDoc_findDest(lua_State * L)
+{
+    GooString *name;
+    LinkDest *dest;
+    const char *s;
+    size_t len;
+    udstruct *uin, *uout;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_PDFDoc);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    s = luaL_checklstring(L, 2, &len);
+    name = new GooString(s, len);
+    if (((PdfDocument *) uin->d)->doc->getCatalog()->isOk()) {
+        dest = ((PdfDocument *) uin->d)->doc->findDest(name);
+        if (dest != NULL) {
+            uout = new_LinkDest_userdata(L);
+            uout->d = dest;
+            uout->pc = uin->pc;
+            uout->pd = uin->pd;
+        } else
+            lua_pushnil(L);
+    } else
+        lua_pushnil(L);
+    delete name;
+    return 1;
+}
+
+m_PDFDoc_BOOL(isEncrypted);
+m_PDFDoc_BOOL(okToPrint);
+m_PDFDoc_BOOL(okToChange);
+m_PDFDoc_BOOL(okToCopy);
+m_PDFDoc_BOOL(okToAddNotes);
+m_PDFDoc_BOOL(isLinearized);
+
+static int m_PDFDoc_getDocInfo(lua_State * L)
+{
+    udstruct *uin, *uout;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_PDFDoc);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    if (((PdfDocument *) uin->d)->doc->getXRef()->isOk()) {
+        uout = new_Object_userdata(L);
+        uout->d = new Object();
+        *((Object *) uout->d) = ((PdfDocument *) uin->d)->doc->getDocInfo();
+        uout->atype = ALLOC_LEPDF;
+        uout->pc = uin->pc;
+        uout->pd = uin->pd;
+    } else
+        lua_pushnil(L);
+    return 1;
+}
+
+static int m_PDFDoc_getDocInfoNF(lua_State * L)
+{
+    udstruct *uin, *uout;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_PDFDoc);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    if (((PdfDocument *) uin->d)->doc->getXRef()->isOk()) {
+        uout = new_Object_userdata(L);
+        uout->d = new Object();
+        *((Object *) uout->d) = ((PdfDocument *) uin->d)->doc->getDocInfoNF();
+        uout->atype = ALLOC_LEPDF;
+        uout->pc = uin->pc;
+        uout->pd = uin->pd;
+    } else
+        lua_pushnil(L);
+    return 1;
+}
+
+m_PDFDoc_INT(getPDFMajorVersion);
+m_PDFDoc_INT(getPDFMinorVersion);
+
+m_poppler__tostring(PDFDoc);
+
+static int m_PDFDoc__gc(lua_State * L)
+{
+    udstruct *uin;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_PDFDoc);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+#ifdef DEBUG
+    printf("\n===== PDFDoc GC ===== file_path=<%s>\n",
+           ((PdfDocument *) uin->d)->file_path);
+#endif
+    assert(uin->atype == ALLOC_LEPDF);
+    unrefPdfDocument(((PdfDocument *) uin->d)->file_path);
+    return 0;
+}
+
+static const struct luaL_Reg PDFDoc_m[] = {
+    {"isOk", m_PDFDoc_isOk},
+    {"getErrorCode", m_PDFDoc_getErrorCode},
+    {"getErrorCodeName", m_PDFDoc_getErrorCodeName},    // not poppler
+    {"getFileName", m_PDFDoc_getFileName},
+    {"getXRef", m_PDFDoc_getXRef},
+    {"getCatalog", m_PDFDoc_getCatalog},
+    // {"getBaseStream", m_PDFDoc_getBaseStream},
+    {"getPageMediaWidth", m_PDFDoc_getPageMediaWidth},
+    {"getPageMediaHeight", m_PDFDoc_getPageMediaHeight},
+    {"getPageCropWidth", m_PDFDoc_getPageCropWidth},
+    {"getPageCropHeight", m_PDFDoc_getPageCropHeight},
+    {"getNumPages", m_PDFDoc_getNumPages},
+    {"readMetadata", m_PDFDoc_readMetadata},
+    {"getStructTreeRoot", m_PDFDoc_getStructTreeRoot},
+    {"findPage", m_PDFDoc_findPage},
+    {"getLinks", m_PDFDoc_getLinks},
+    {"findDest", m_PDFDoc_findDest},
+    {"isEncrypted", m_PDFDoc_isEncrypted},
+    {"okToPrint", m_PDFDoc_okToPrint},
+    {"okToChange", m_PDFDoc_okToChange},
+    {"okToCopy", m_PDFDoc_okToCopy},
+    {"okToAddNotes", m_PDFDoc_okToAddNotes},
+    {"isLinearized", m_PDFDoc_isLinearized},
+    {"getDocInfo", m_PDFDoc_getDocInfo},
+    {"getDocInfoNF", m_PDFDoc_getDocInfoNF},
+    {"getPDFMajorVersion", m_PDFDoc_getPDFMajorVersion},
+    {"getPDFMinorVersion", m_PDFDoc_getPDFMinorVersion},
+    {"__tostring", m_PDFDoc__tostring},
+    {"__gc", m_PDFDoc__gc},     // finalizer
+    {NULL, NULL}                // sentinel
+};
+
+//**********************************************************************
+// PDFRectangle
+
+m_poppler_get_BOOL(PDFRectangle, isValid);
+
+m_poppler__tostring(PDFRectangle);
+
+static int m_PDFRectangle__index(lua_State * L)
+{
+    const char *s;
+    udstruct *uin;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_PDFRectangle);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    s = luaL_checkstring(L, 2);
+    if (strlen(s) == 2) {
+        if (s[0] == 'x') {
+            if (s[1] == '1')
+                lua_pushnumber(L, ((PDFRectangle *) uin->d)->x1); /* float */
+            else if (s[1] == '2')
+                lua_pushnumber(L, ((PDFRectangle *) uin->d)->x2); /* float */
+            else
+                lua_pushnil(L);
+        } else if (s[0] == 'y') {
+            if (s[1] == '1')
+                lua_pushnumber(L, ((PDFRectangle *) uin->d)->y1); /* float */
+            else if (s[1] == '2')
+                lua_pushnumber(L, ((PDFRectangle *) uin->d)->y2); /* float */
+            else
+                lua_pushnil(L);
+        } else
+            lua_pushnil(L);
+    } else
+        lua_pushnil(L);
+    return 1;
+}
+
+static int m_PDFRectangle__newindex(lua_State * L)
+{
+    double d;
+    const char *s;
+    udstruct *uin;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_PDFRectangle);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    s = luaL_checkstring(L, 2);
+    d = luaL_checknumber(L, 3);
+    if (strlen(s) == 2) {
+        if (s[0] == 'x') {
+            if (s[1] == '1')
+                ((PDFRectangle *) uin->d)->x1 = d;
+            else if (s[1] == '2')
+                ((PDFRectangle *) uin->d)->x2 = d;
+            else
+                luaL_error(L, "wrong PDFRectangle coordinate (%s)", s);
+        } else if (s[0] == 'y') {
+            if (s[1] == '1')
+                ((PDFRectangle *) uin->d)->y1 = d;
+            else if (s[1] == '2')
+                ((PDFRectangle *) uin->d)->y2 = d;
+        } else
+            luaL_error(L, "wrong PDFRectangle coordinate (%s)", s);
+    } else
+        luaL_error(L, "wrong PDFRectangle coordinate (%s)", s);
+    return 0;
+}
+
+static int m_PDFRectangle__gc(lua_State * L)
+{
+    udstruct *uin;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_PDFRectangle);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+#ifdef DEBUG
+    printf("\n===== PDFRectangle GC ===== uin=<%p>\n", uin);
+#endif
+    if (uin->atype == ALLOC_LEPDF)
+        delete(PDFRectangle *) uin->d;
+    return 0;
+}
+
+static const struct luaL_Reg PDFRectangle_m[] = {
+    {"isValid", m_PDFRectangle_isValid},
+    {"__index", m_PDFRectangle__index},
+    {"__newindex", m_PDFRectangle__newindex},
+    {"__tostring", m_PDFRectangle__tostring},
+    {"__gc", m_PDFRectangle__gc},
+    {NULL, NULL}                // sentinel
+};
+
+//**********************************************************************
+// Ref
+
+static int m_Ref__index(lua_State * L)
+{
+    const char *s;
+    udstruct *uin;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Ref);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    s = luaL_checkstring(L, 2);
+    if (strcmp(s, "num") == 0)
+        lua_pushinteger(L, ((Ref *) uin->d)->num);
+    else if (strcmp(s, "gen") == 0)
+        lua_pushinteger(L, ((Ref *) uin->d)->gen);
+    else
+        lua_pushnil(L);
+    return 1;
+}
+
+m_poppler__tostring(Ref);
+
+static int m_Ref__gc(lua_State * L)
+{
+    udstruct *uin;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Ref);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+#ifdef DEBUG
+    printf("\n===== Ref GC ===== uin=<%p>\n", uin);
+#endif
+    if (uin->atype == ALLOC_LEPDF && ((Ref *) uin->d) != NULL)
+        gfree(((Ref *) uin->d));
+    return 0;
+}
+
+static const struct luaL_Reg Ref_m[] = {
+    {"__index", m_Ref__index},
+    {"__tostring", m_Ref__tostring},
+    {"__gc", m_Ref__gc},        // finalizer
+    {NULL, NULL}                // sentinel
+};
+
+//**********************************************************************
+// Stream
+
+static const char *StreamKindNames[] =
+    { "File", "ASCIIHex", "ASCII85", "LZW", "RunLength", "CCITTFax", "DCT",
+    "Flate", "JBIG2", "JPX", "Weird", NULL
+};
+
+m_poppler_get_INT(Stream, getKind);
+
+static int m_Stream_getKindName(lua_State * L)
+{
+    StreamKind t;
+    udstruct *uin;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Stream);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    t = ((Stream *) uin->d)->getKind();
+    lua_pushstring(L, StreamKindNames[t]);
+    return 1;
+}
+
+m_poppler_do(Stream, reset);
+m_poppler_do(Stream, close);
+m_poppler_get_INT(Stream, getChar);
+m_poppler_get_INT(Stream, lookChar);
+m_poppler_get_INT(Stream, getRawChar);
+m_poppler_get_INT(Stream, getUnfilteredChar);
+m_poppler_do(Stream, unfilteredReset);
+m_poppler_get_INT(Stream, getPos);
+m_poppler_get_BOOL(Stream, isBinary);
+m_poppler_get_poppler(Stream, Stream, getUndecodedStream);
+m_poppler_get_poppler(Stream, Dict, getDict);
+
+m_poppler__tostring(Stream);
+
+static const struct luaL_Reg Stream_m[] = {
+    {"getKind", m_Stream_getKind},
+    {"getKindName", m_Stream_getKindName},      // not poppler
+    {"reset", m_Stream_reset},
+    {"close", m_Stream_close},
+    {"getUndecodedStream", m_Stream_getUndecodedStream},
+    {"getChar", m_Stream_getChar},
+    {"lookChar", m_Stream_lookChar},
+    {"getRawChar", m_Stream_getRawChar},
+    {"getUnfilteredChar", m_Stream_getUnfilteredChar},
+    {"unfilteredReset", m_Stream_unfilteredReset},
+    // {"getLine", m_Stream_getLine},
+    {"getPos", m_Stream_getPos},
+    {"isBinary", m_Stream_isBinary},
+    {"getUndecodedStream", m_Stream_getUndecodedStream},
+    {"getDict", m_Stream_getDict},
+    {"__tostring", m_Stream__tostring},
+    {NULL, NULL}                // sentinel
+};
+
+//**********************************************************************
+// TextSpan
+
+m_poppler_get_GOOSTRING(TextSpan, getText);
+m_poppler__tostring(TextSpan);
+
+static const struct luaL_Reg TextSpan_m[] = {
+    {"getText", m_TextSpan_getText},
+    {"__tostring", m_TextSpan__tostring},
+    {NULL, NULL}                // sentinel
+};
+
+
+
+
+//**********************************************************************
+// Attribute
+m_poppler_get_BOOL(Attribute,isOk);
+m_poppler_get_INT(Attribute,getType);
+m_poppler_get_INT(Attribute,getOwner);
+m_poppler_get_GOOSTRING(Attribute,getName);
+
+static int m_Attribute_getTypeName(lua_State * L)
+{
+    udstruct *uin;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Attribute);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    lua_pushstring(L, ((Attribute *) uin->d)->getTypeName());
+    return 1;
+}
+
+static int m_Attribute_getOwnerName(lua_State * L)
+{
+    udstruct *uin;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Attribute);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    lua_pushstring(L, ((Attribute *) uin->d)->getOwnerName());
+    return 1;
+}
+
+static int m_Attribute_getValue(lua_State * L)
+{
+    udstruct *uin, *uout;
+    Object *origin;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Attribute);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    uout = new_Object_userdata(L);
+    uout->d = new Object();
+    origin = (Object *) (((Attribute *) uin->d)->getValue());
+    *((Object *) uout->d) = origin->copy();
+    uout->atype = ALLOC_LEPDF;
+    uout->pc = uin->pc;
+    uout->pd = uin->pd;
+    return 1;
+}
+
+
+static int m_Attribute_getDefaultValue(lua_State * L)
+{
+    Attribute::Type t;
+    udstruct *uin, *uout;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Attribute);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    t = (Attribute::Type) luaL_checkint(L, 2);
+    uout = new_Object_userdata(L);
+    uout->d = ((Attribute *)uin->d)->getDefaultValue(t)  ;
+    //uout->atype = ALLOC_LEPDF;
+    uout->pc = uin->pc;
+    uout->pd = uin->pd;
+    return 1;
+}
+
+
+m_poppler_get_GUINT(Attribute,getRevision);
+
+static int m_Attribute_setRevision(lua_State * L)
+{
+    Guint i;
+    udstruct *uin;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Attribute);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    i = (Guint) luaL_checkint(L, 2);
+    ((Attribute *) uin->d)->setRevision(i);
+    return 0;
+}
+
+m_poppler_get_BOOL(Attribute, isHidden);
+
+static int m_Attribute_setHidden(lua_State * L)
+{
+    GBool i;
+    udstruct *uin;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Attribute);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    i = (GBool) lua_toboolean(L, 2);
+    ((Attribute *) uin->d)->setHidden(i);
+    return 0;
+}
+
+static int m_Attribute_getFormattedValue(lua_State * L)
+{
+    udstruct *uin;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Attribute);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    lua_pushstring(L, ((Attribute *) uin->d)->getFormattedValue());
+    return 1;
+}
+
+
+static int m_Attribute_setFormattedValue(lua_State * L)
+{
+    const char *c;
+    udstruct *uin;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Attribute);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    c = luaL_checkstring(L, 2);
+    ((Attribute *) uin->d)->setFormattedValue(c);
+    return 0;
+}
+
+static int m_Attribute__gc(lua_State * L)
+{
+    udstruct *uin;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Attribute);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+#ifdef DEBUG
+    printf("\n===== Attribute GC ===== uin=<%p>\n", uin);
+#endif
+    if (uin->atype == ALLOC_LEPDF) {
+        delete(Attribute *) uin->d;
+    }
+    return 0;
+}
+
+
+m_poppler__tostring(Attribute);
+
+
+static const struct luaL_Reg Attribute_m[] = {
+  {"isOk",m_Attribute_isOk},
+  {"getType",m_Attribute_getType},
+  {"getOwner",m_Attribute_getOwner},
+  {"getTypeName",m_Attribute_getTypeName},
+  {"getOwnerName",m_Attribute_getOwnerName},
+  {"getValue",m_Attribute_getValue},
+  {"getDefaultValue",m_Attribute_getDefaultValue},
+  {"getName",m_Attribute_getName},
+  {"getRevision",m_Attribute_getRevision},
+  {"setRevision",m_Attribute_setRevision},
+  {"istHidden",m_Attribute_isHidden},
+  {"setHidden",m_Attribute_setHidden},
+  {"getFormattedValue",m_Attribute_getFormattedValue},
+  {"setFormattedValue",m_Attribute_setFormattedValue},
+  {"__gc", m_Attribute__gc},
+  {"__tostring", m_Attribute__tostring},
+  {NULL, NULL}                // sentinel
+};
+
+
+
+
+//**********************************************************************
+// StructElement
+
+
+m_poppler_get_INT(StructElement,getType);
+m_poppler_get_BOOL(StructElement,isOk);
+m_poppler_get_BOOL(StructElement,isBlock);
+m_poppler_get_BOOL(StructElement,isInline);
+m_poppler_get_BOOL(StructElement,isGrouping);
+m_poppler_get_BOOL(StructElement,isContent);
+m_poppler_get_BOOL(StructElement,isObjectRef);
+m_poppler_get_BOOL(StructElement,hasPageRef);
+m_poppler_get_INT(StructElement,getMCID);
+m_poppler_get_INT(StructElement, getNumChildren);
+
+m_poppler_get_GUINT(StructElement,getRevision);
+m_poppler_get_UINT(StructElement,getNumAttributes);
+
+m_poppler_get_GOOSTRING(StructElement, getID);
+m_poppler_get_GOOSTRING(StructElement, getLanguage);
+m_poppler_get_GOOSTRING(StructElement, getTitle);
+m_poppler_get_GOOSTRING(StructElement, getExpandedAbbr);
+m_poppler_get_GOOSTRING(StructElement, getAltText);
+m_poppler_get_GOOSTRING(StructElement, getActualText);
+
+m_poppler_get_poppler(StructElement, StructTreeRoot, getStructTreeRoot);
+m_poppler__tostring(StructElement);
+
+
+static int m_StructElement_getObjectRef(lua_State * L)
+{
+    udstruct *uin, *uout;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_StructElement);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    uout = new_Ref_userdata(L);
+    uout->d = (Ref *) gmalloc(sizeof(Ref));
+    ((Ref *) uout->d)->num = ((StructElement *) uin->d)->getObjectRef().num;
+    ((Ref *) uout->d)->gen = ((StructElement *) uin->d)->getObjectRef().gen;
+    uout->atype = ALLOC_LEPDF;
+    uout->pc = uin->pc;
+    uout->pd = uin->pd;
+    return 1;
+}
+
+
+static int m_StructElement_getParentRef(lua_State * L)
+{
+    udstruct *uin, *uout;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_StructElement);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    uout = new_Ref_userdata(L);
+    uout->d = (Ref *) gmalloc(sizeof(Ref));
+    ((Ref *) uout->d)->num = ((StructElement *) uin->d)->getParentRef().num;
+    ((Ref *) uout->d)->gen = ((StructElement *) uin->d)->getParentRef().gen;
+    uout->atype = ALLOC_LEPDF;
+    uout->pc = uin->pc;
+    uout->pd = uin->pd;
+    return 1;
+}
+
+// Not exactly as the header:
+// Ref = StructElement:getPageRef()
+// Ref is false if the C++ functione return false
+static int m_StructElement_getPageRef(lua_State * L)
+{
+    GBool b;
+    Ref *r;
+    udstruct *uin, *uout;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_StructElement);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    r = (Ref *) gmalloc(sizeof(Ref));
+    b = ((StructElement *) uin->d)->getPageRef( *r );
+    if (b) {
+      uout = new_Ref_userdata(L);
+      uout->d = r ;
+      //uout->atype = ALLOC_LEPDF;
+      uout->pc = uin->pc;
+      uout->pd = uin->pd;
+    } else
+      lua_pushboolean(L,0);
+    return 1;
+}
+
+
+
+static int m_StructElement_getTypeName(lua_State * L)
+{
+    udstruct *uin;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_StructElement);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    lua_pushstring(L, ((StructElement *) uin->d)->getTypeName());
+    return 1;
+}
+
+
+static int m_StructElement_setRevision(lua_State * L)
+{
+    Guint i;
+    udstruct *uin;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_StructElement);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    i = (Guint) luaL_checkint(L, 2);
+    ((StructElement *) uin->d)->setRevision(i);
+    return 0;
+}
+
+static int m_StructElement_getText(lua_State * L)
+{
+    GBool i;
+    GooString *gs;
+    udstruct *uin;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_StructElement);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    i = (GBool) lua_toboolean(L, 2);
+    gs =  ((StructElement *) uin->d)->getText(i);
+    if (gs != NULL)
+        lua_pushlstring(L, gs->getCString(), gs->getLength());
+    else
+        lua_pushnil(L);
+    return 1;
+}
+
+
+static int m_StructElement_getChild(lua_State * L)
+{
+    StructElement *c;
+    int i;
+    udstruct *uin, *uout;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_StructElement);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    i = (int) luaL_checkint(L, 2);
+    c =  ((StructElement *) uin->d)->getChild(i-1);
+    if (c != NULL) {
+      uout = new_StructElement_userdata(L);
+      uout->d = c ;
+      //uout->atype = ALLOC_LEPDF;
+      uout->pc = uin->pc;
+      uout->pd = uin->pd;
+    }
+    else
+        lua_pushnil(L);
+    return 1;
+}
+
+
+static int m_StructElement_appendChild(lua_State * L)
+{
+    udstruct *uin, *uin1;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_StructElement);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    uin1 = (udstruct *) luaL_checkudata(L, 2, M_StructElement);
+    if (uin1->pd != NULL && uin1->pd->pc != uin1->pc)
+        pdfdoc_changed_error(L);
+    ((StructElement *) uin->d)->appendChild( (StructElement *)uin1->d );
+    return 0;
+}
+
+
+static int m_StructElement_getAttribute(lua_State * L)
+{
+    Attribute *a;
+    int i;
+    udstruct *uin, *uout;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_StructElement);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    i = (int) luaL_checkint(L, 2);
+    a =  ((StructElement *) uin->d)->getAttribute(i-1);
+    if (a != NULL) {
+      uout = new_Attribute_userdata(L);
+      uout->d = a ;
+      uout->pc = uin->pc;
+      uout->pd = uin->pd;
+    }
+    else
+        lua_pushnil(L);
+    return 1;
+}
+
+
+
+static int m_StructElement_appendAttribute(lua_State * L)
+{
+
+    udstruct *uin, *uin1;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_StructElement);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    uin1 = (udstruct *) luaL_checkudata(L, 2, M_Attribute);
+    if (uin1->pd != NULL && uin1->pd->pc != uin1->pc)
+        pdfdoc_changed_error(L);
+    ((StructElement *) uin->d)->appendAttribute( (Attribute *)uin1->d );
+    return 0;
+}
+
+
+static int m_StructElement_findAttribute(lua_State * L)
+{
+    Attribute::Type t;
+    Attribute::Owner o;
+    GBool g;
+    udstruct *uin, *uout;
+    const Attribute *a;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_StructElement);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    t = (Attribute::Type) luaL_checkint(L,1);
+    o = (Attribute::Owner) luaL_checkint(L,2);
+    g = (GBool) lua_toboolean(L, 3);
+    a = ((StructElement *) uin->d)->findAttribute(t,g,o);
+
+    if (a!=NULL){
+      uout = new_Attribute_userdata(L);
+      uout->d = new Attribute(a->getType(),a->getValue());
+      uout->atype = ALLOC_LEPDF;
+      uout->pc = uin->pc;
+      uout->pd = uin->pd;
+    } else
+        lua_pushnil(L);
+    return 1;
+}
+
+// This returns a lua table
+static int m_StructElement_getTextSpans(lua_State * L)
+{
+    int i ;
+    udstruct *uin, *uout;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_StructElement);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+
+    if ((((StructElement *) uin->d)->getTextSpans()).size()>0) {
+      lua_createtable (L,
+		       (int) (((StructElement *) uin->d)->getTextSpans()).size(),
+		       0);
+      for(i=0;i<(int) (((StructElement *) uin->d)->getTextSpans()).size(); i++){
+	uout = new_TextSpan_userdata(L);
+	uout->d = new TextSpan( (((StructElement *) uin->d)->getTextSpans())[i] );
+	uout->atype = ALLOC_LEPDF;
+	uout->pc = uin->pc;
+	uout->pd = uin->pd;
+	lua_rawseti(L,-2,i+1);
+      }
+    } else
+      lua_pushnil(L);
+    return 1;
+}
+
+
+
+static const struct luaL_Reg StructElement_m[] = {
+  {"getTypeName", m_StructElement_getTypeName},
+  {"getType",m_StructElement_getType},
+  {"isOk",m_StructElement_isOk},
+  {"isBlock",m_StructElement_isBlock},
+  {"isInline",m_StructElement_isInline},
+  {"isGrouping",m_StructElement_isGrouping},
+  {"isContent",m_StructElement_isContent},
+  {"isObjectRef",m_StructElement_isObjectRef},
+  {"getMCID",m_StructElement_getMCID},
+  {"getObjectRef",m_StructElement_getObjectRef},
+  {"getParentRef",m_StructElement_getParentRef},
+  {"hasPageRef",m_StructElement_hasPageRef},
+  {"getPageRef",m_StructElement_getPageRef},
+  {"getStructTreeRoot",m_StructElement_getStructTreeRoot},
+  {"getID",m_StructElement_getID},
+  {"getLanguage",m_StructElement_getLanguage},
+  {"getRevision",m_StructElement_getRevision},
+  {"setRevision",m_StructElement_setRevision},
+  {"getTitle",m_StructElement_getTitle},
+  {"getExpandedAbbr",m_StructElement_getExpandedAbbr},
+  {"getNumChildren",m_StructElement_getNumChildren},
+  {"getChild",m_StructElement_getChild},
+  {"appendChild",m_StructElement_appendChild},
+  {"getNumAttributes",m_StructElement_getNumAttributes},
+  {"getAttribute",m_StructElement_getAttribute},
+  {"appendAttribute",m_StructElement_appendAttribute},
+  {"findAttribute",m_StructElement_findAttribute},
+  {"getAltText",m_StructElement_getAltText},
+  {"getActualText",m_StructElement_getActualText},
+  {"getText",m_StructElement_getText},
+  {"getTextSpans",m_StructElement_getTextSpans},
+  {"__tostring", m_StructElement__tostring},
+  {NULL, NULL}                // sentinel
+};
+
+
+//**********************************************************************
+// StructTreeRoot
+
+m_poppler_get_INT(StructTreeRoot, getNumChildren);
+m_poppler_get_poppler(StructTreeRoot, PDFDoc, getDoc);
+m_poppler_get_poppler(StructTreeRoot, Dict, getRoleMap);
+m_poppler_get_poppler(StructTreeRoot, Dict, getClassMap);
+m_poppler__tostring(StructTreeRoot);
+
+static int m_StructTreeRoot_getChild(lua_State * L)
+{
+    unsigned int i;
+    udstruct *uin, *uout;
+    StructElement *child ;
+    StructTreeRoot *root ;
+
+    uin = (udstruct *) luaL_checkudata(L, 1, M_StructTreeRoot);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    i = (unsigned) luaL_checkint(L, 2);
+    root = (StructTreeRoot *) uin->d;
+    if (i-1 < root->getNumChildren() ){
+       child = root->getChild(i-1);
+       uout = new_StructElement_userdata(L);
+       uout->d = child;
+       //uout->atype = ALLOC_LEPDF;
+       uout->pc = uin->pc;
+       uout->pd = uin->pd;
+    } else
+      lua_pushnil(L);
+    return 1;
+}
+
+static int m_StructTreeRoot_appendChild(lua_State * L)
+{
+    udstruct *uin, *uin_child;
+    StructElement *child ;
+    StructTreeRoot *root ;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_StructTreeRoot);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    uin_child = (udstruct *) luaL_checkudata(L, 2, M_StructElement);
+    if (uin_child->pd != NULL && uin_child->pd->pc != uin_child->pc)
+        pdfdoc_changed_error(L);
+    root = (StructTreeRoot *) uin->d;
+    child = (StructElement *) uin_child->d;
+    root->appendChild(child);
+    return 0;
+}
+
+
+static int m_StructTreeRoot_findParentElement(lua_State * L)
+{
+    unsigned int i;
+    udstruct *uin,  *uout;
+    const StructElement *parent ;
+    StructTreeRoot *root ;
+
+    uin = (udstruct *) luaL_checkudata(L, 1, M_StructTreeRoot);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    i = (unsigned) luaL_checkint(L, 2);
+    root = (StructTreeRoot *) uin->d;
+    parent = root->findParentElement(i-1);
+    if (parent != NULL) {
+       uout = new_StructElement_userdata(L);
+       // see https://isocpp.org/wiki/faq/const-correctness#aliasing-and-const
+       uout->d = (StructElement *) parent;
+       uout->atype = ALLOC_LEPDF;
+       uout->pc = uin->pc;
+       uout->pd = uin->pd;
+    } else
+      lua_pushnil(L);
+    return 1;
+}
+
+
+static const struct luaL_Reg StructTreeRoot_m[] = {
+  {"getDoc",m_StructTreeRoot_getDoc},
+  {"getRoleMap",m_StructTreeRoot_getRoleMap},
+  {"getClassMap",m_StructTreeRoot_getClassMap},
+  {"getNumChildren",m_StructTreeRoot_getNumChildren},
+  {"getChild",m_StructTreeRoot_getChild},
+  {"appendChild",m_StructTreeRoot_appendChild},
+  {"findParentElement",m_StructTreeRoot_findParentElement},
+  {"__tostring", m_StructTreeRoot__tostring},
+  {NULL, NULL}                // sentinel
+};
+
+//**********************************************************************
+// XRef
+
+m_poppler_get_BOOL(XRef, isOk);
+m_poppler_get_INT(XRef, getErrorCode);
+m_poppler_get_BOOL(XRef, isEncrypted);
+m_poppler_get_BOOL(XRef, okToPrint);
+m_poppler_get_BOOL(XRef, okToPrintHighRes);
+m_poppler_get_BOOL(XRef, okToChange);
+m_poppler_get_BOOL(XRef, okToCopy);
+m_poppler_get_BOOL(XRef, okToAddNotes);
+m_poppler_get_BOOL(XRef, okToFillForm);
+m_poppler_get_BOOL(XRef, okToAccessibility);
+m_poppler_get_BOOL(XRef, okToAssemble);
+m_poppler_get_OBJECT(XRef, getCatalog);
+
+static int m_XRef_fetch(lua_State * L)
+{
+    int num, gen;
+    udstruct *uin, *uout;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_XRef);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    num = luaL_checkint(L, 2);
+    gen = luaL_checkint(L, 3);
+    uout = new_Object_userdata(L);
+    uout->d = new Object();
+    *((Object *) uout->d) = ((XRef *) uin->d)->fetch(num, gen);
+    uout->atype = ALLOC_LEPDF;
+    uout->pc = uin->pc;
+    uout->pd = uin->pd;
+    return 1;
+}
+
+m_poppler_get_OBJECT(XRef, getDocInfo);
+m_poppler_get_OBJECT(XRef, getDocInfoNF);
+m_poppler_get_INT(XRef, getNumObjects);
+m_poppler_get_INT(XRef, getRootNum);
+m_poppler_get_INT(XRef, getRootGen);
+// getStreamEnd
+
+static int m_XRef_getNumEntry(lua_State * L)
+{
+    int i, offset;
+    udstruct *uin;
+    uin = (udstruct *) luaL_checkudata(L, 1, M_XRef);
+    if (uin->pd != NULL && uin->pd->pc != uin->pc)
+        pdfdoc_changed_error(L);
+    offset = luaL_checkint(L, 2);
+    i = ((XRef *) uin->d)->getNumEntry(offset);
+    if (i >= 0)
+        lua_pushinteger(L, i);
+    else
+        lua_pushnil(L);
+    return 1;
+}
+
+m_poppler_get_poppler(XRef, Object, getTrailerDict);
+
+m_poppler__tostring(XRef);
+
+static const struct luaL_Reg XRef_m[] = {
+    {"isOk", m_XRef_isOk},
+    {"getErrorCode", m_XRef_getErrorCode},
+    {"isEncrypted", m_XRef_isEncrypted},
+    {"okToPrint", m_XRef_okToPrint},
+    {"okToPrintHighRes", m_XRef_okToPrintHighRes},
+    {"okToChange", m_XRef_okToChange},
+    {"okToCopy", m_XRef_okToCopy},
+    {"okToAddNotes", m_XRef_okToAddNotes},
+    {"okToFillForm", m_XRef_okToFillForm},
+    {"okToAccessibility", m_XRef_okToAccessibility},
+    {"okToAssemble", m_XRef_okToAssemble},
+    {"getCatalog", m_XRef_getCatalog},
+    {"fetch", m_XRef_fetch},
+    {"getDocInfo", m_XRef_getDocInfo},
+    {"getDocInfoNF", m_XRef_getDocInfoNF},
+    {"getNumObjects", m_XRef_getNumObjects},
+    {"getRootNum", m_XRef_getRootNum},
+    {"getRootGen", m_XRef_getRootGen},
+    // {"getStreamEnd", m_XRef_getStreamEnd},
+    {"getNumEntry", m_XRef_getNumEntry},
+    {"getTrailerDict", m_XRef_getTrailerDict},
+    {"__tostring", m_XRef__tostring},
+    {NULL, NULL}                // sentinel
+};
+
+//**********************************************************************
+// XRefEntry
+
+m_poppler__tostring(XRefEntry);
+
+static const struct luaL_Reg XRefEntry_m[] = {
+    {"__tostring", m_XRefEntry__tostring},
+    {NULL, NULL}                // sentinel
+};
+
+//**********************************************************************
+
+#ifdef LuajitTeX
+#define setfuncs_meta(type)                 \
+    luaL_newmetatable(L, M_##type);         \
+    lua_pushvalue(L, -1);                   \
+    lua_setfield(L, -2, "__index");         \
+    lua_pushstring(L, "no user access");    \
+    lua_setfield(L, -2, "__metatable");     \
+    luaL_openlib(L, NULL, type##_m, 0)
+#else
+#define setfuncs_meta(type)                 \
+    luaL_newmetatable(L, M_##type);         \
+    lua_pushvalue(L, -1);                   \
+    lua_setfield(L, -2, "__index");         \
+    lua_pushstring(L, "no user access");    \
+    lua_setfield(L, -2, "__metatable");     \
+    luaL_setfuncs(L, type##_m, 0)
+#endif
+
+int luaopen_epdf(lua_State * L)
+{
+    setfuncs_meta(Annot);
+    setfuncs_meta(Annots);
+    setfuncs_meta(Array);
+    setfuncs_meta(Catalog);
+    setfuncs_meta(Dict);
+    setfuncs_meta(EmbFile);
+    setfuncs_meta(FileSpec);
+    setfuncs_meta(GooString);
+    setfuncs_meta(LinkDest);
+    setfuncs_meta(Links);
+    setfuncs_meta(Object);
+    setfuncs_meta(Page);
+    setfuncs_meta(PDFDoc);
+    setfuncs_meta(PDFRectangle);
+    setfuncs_meta(Ref);
+    setfuncs_meta(Stream);
+    setfuncs_meta(Attribute);
+    setfuncs_meta(StructElement);
+    setfuncs_meta(StructTreeRoot);
+    setfuncs_meta(TextSpan);
+    setfuncs_meta(XRef);
+    setfuncs_meta(XRefEntry);
+    luaL_openlib(L, "epdf", epdflib_f, 0);
+    return 1;
+}
--- texlive-bin.orig/texk/web2c/luatexdir/lua/lfontlib.c
+++ texlive-bin/texk/web2c/luatexdir/lua/lfontlib.c
@@ -324,9 +324,7 @@ static int l_vf_char(lua_State * L)
     }
     mat_p = &(vsp->packet_stack[vsp->packet_stack_level]);
     w = char_width(lf, k);
-    if (ex_glyph != 0)
-        w = round_xn_over_d(w, 1000 + ex_glyph, 1000);
-    mat_p->pos.h += w;
+    mat_p->pos.h += round_xn_over_d(w, 1000 + ex_glyph, 1000);
     synch_pos_with_cur(static_pdf->posstruct, vsp->refpos, mat_p->pos);
     return 0;
 }
@@ -418,14 +416,11 @@ static int l_vf_right(lua_State * L)
 {
     scaled i;
     vf_struct *vsp = static_pdf->vfstruct;
-    int ex_glyph = vsp->ex_glyph/1000;
     packet_stack_record *mat_p;
     if (!vsp->vflua)
         normal_error("vf", "vf.right() outside virtual font");
     mat_p = &(vsp->packet_stack[vsp->packet_stack_level]);
     i = (scaled) luaL_checkinteger(L, 1);
-    if (ex_glyph != 0 && i != 0) /* new, experiment */
-        i = round_xn_over_d(i, 1000 + ex_glyph, 1000);
     i = store_scaled_f(i, vsp->fs_f);
     mat_p->pos.h += i;
     synch_pos_with_cur(static_pdf->posstruct, vsp->refpos, mat_p->pos);
@@ -436,14 +431,11 @@ static int l_vf_rule(lua_State * L)
 {
     scaledpos size;
     vf_struct *vsp = static_pdf->vfstruct;
-    int ex_glyph = vsp->ex_glyph/1000;
     packet_stack_record *mat_p;
     if (!vsp->vflua)
         normal_error("vf", "vf.rule() outside virtual font");
     size.h = (scaled) luaL_checkinteger(L, 1);
     size.v = (scaled) luaL_checkinteger(L, 2);
-    if (ex_glyph != 0 && size.h > 0) /* new, experiment */
-        size.h = round_xn_over_d(size.h, 1000 + ex_glyph, 1000);
     size.h = store_scaled_f(size.h, vsp->fs_f);
     size.v = store_scaled_f(size.v, vsp->fs_f);
     if (size.h > 0 && size.v > 0)
@@ -468,16 +460,6 @@ static int l_vf_special(lua_State * L)
     return 0;
 }
 
-static int l_vf_pdf(lua_State * L)
-{
-    vf_struct *vsp = static_pdf->vfstruct;
-    if (!vsp->vflua)
-        normal_error("vf", "vf.special() outside virtual font");
-    luapdfprint(L);
-    pdf_out(static_pdf, '\n');
-    return 0;
-}
-
 static const struct luaL_Reg vflib[] = {
     {"char", l_vf_char},
     {"down", l_vf_down},
@@ -494,7 +476,6 @@ static const struct luaL_Reg vflib[] = {
     /* {"scale", l_vf_scale}, */
     /* {"slot", l_vf_slot}, */
     {"special", l_vf_special},
-    {"pdf", l_vf_pdf},
     {NULL, NULL}                /* sentinel */
 };
 
--- texlive-bin.orig/texk/web2c/luatexdir/lua/limglib.c
+++ texlive-bin/texk/web2c/luatexdir/lua/limglib.c
@@ -24,7 +24,7 @@
 #include "lua.h"
 #include "lauxlib.h"
 
-#define img_types_max 8
+#define img_types_max 7
 
 const char *img_types[] = {
     "none",
@@ -243,26 +243,6 @@ static void write_image_or_node(lua_Stat
         img_state(ad) = DICT_REFERED;
 }
 
-static int write_image_object(lua_State * L, wrtype_e writetype)
-{
-    image *a, **aa;
-    image_dict *ad;
-    int num;
-    if (lua_gettop(L) != 2)
-        luaL_error(L, "%s expects two argument", wrtype_s[writetype]);
-    aa = (image **) luaL_checkudata(L, 1, TYPE_IMG);
-    a = *aa;
-    ad = img_dict(a);
-
-    read_img(ad);
-
-    /*   setup_image(static_pdf, a, writetype); */
-    num = (int) lua_tointeger(L, 2);
-    num = write_img_object(static_pdf, ad, num);
-    lua_pushinteger(L,num);
-    return 1;
-}
-
 static int l_write_image(lua_State * L)
 {
     write_image_or_node(L, WR_WRITE);
@@ -280,17 +260,6 @@ static int l_immediatewrite_image(lua_St
     return 1;
 }
 
-static int l_immediatewrite_image_object(lua_State * L)
-{
-    check_o_mode(static_pdf, "img.immediatewriteobject", 1 << OMODE_PDF, true);
-    if (global_shipping_mode != NOT_SHIPPING) {
-        luaL_error(L, "img.immediatewriteobject can not be used with \\latelua");
-    } else {
-        write_image_object(L, WR_IMMEDIATEWRITE);
-    }
-    return 1;
-}
-
 static int l_image_node(lua_State * L)
 {
     write_image_or_node(L, WR_NODE);
@@ -304,7 +273,7 @@ static int l_image_keys(lua_State * L)
 
 static int l_image_types(lua_State * L)
 {
-    return lua_show_valid_list(L, img_types, 0, img_types_max);
+    return lua_show_valid_list(L, img_types, img_types_max);
 }
 
 static int l_image_boxes(lua_State * L)
@@ -318,13 +287,10 @@ static const struct luaL_Reg imglib_f[]
     { "scan", l_scan_image },
     { "write", l_write_image },
     { "immediatewrite", l_immediatewrite_image },
-    { "immediatewriteobject", l_immediatewrite_image_object },
     { "node", l_image_node },
-    { "fields", l_image_keys },
+    { "keys", l_image_keys },
     { "types", l_image_types },
     { "boxes", l_image_boxes },
-    /* for a while: */
-    { "keys", l_image_keys },
     { NULL, NULL }
 };
 
@@ -382,10 +348,14 @@ static int m_img_get(lua_State * L)
         } else {
             lua_pushstring(L, img_filename(d));
         }
+    } else if (lua_key_eq(s,visiblefilename)) {
+        if (img_visiblefilename(d) == NULL || strlen(img_visiblefilename(d)) == 0) {
+            lua_pushnil(L);
+        } else {
+            lua_pushstring(L, img_visiblefilename(d));
+        }
     } else if (lua_key_eq(s,keepopen)) {
         lua_pushboolean(L, img_keepopen(d));
-    } else if (lua_key_eq(s,nolength)) {
-        lua_pushboolean(L, img_nolength(d));
     } else if (lua_key_eq(s,filepath)) {
         if (img_filepath(d) == NULL || strlen(img_filepath(d)) == 0) {
             lua_pushnil(L);
@@ -491,28 +461,10 @@ static int m_img_get(lua_State * L)
         if (img_type(d) != IMG_TYPE_PDFSTREAM
                 || img_pdfstream_ptr(d) == NULL
                 || img_pdfstream_stream(d) == NULL
-                || img_pdfstream_size(d) == 0) {
-            lua_pushnil(L);
-        } else {
-            lua_pushlstring(L, img_pdfstream_stream(d), img_pdfstream_size(d));
-        }
-    } else if (lua_key_eq(s,visiblefilename)) {
-        if (img_visiblefilename(d) == NULL || strlen(img_visiblefilename(d)) == 0) {
-            lua_pushnil(L);
-        } else {
-            lua_pushstring(L, img_visiblefilename(d));
-        }
-    } else if (lua_key_eq(s,userpassword)) {
-        if (img_userpassword(d) == NULL || strlen(img_userpassword(d)) == 0) {
-            lua_pushnil(L);
-        } else {
-            lua_pushstring(L, img_userpassword(d));
-        }
-    } else if (lua_key_eq(s,ownerpassword)) {
-        if (img_ownerpassword(d) == NULL || strlen(img_ownerpassword(d)) == 0) {
+                || strlen(img_pdfstream_stream(d)) == 0) {
             lua_pushnil(L);
         } else {
-            lua_pushstring(L, img_ownerpassword(d));
+            lua_pushstring(L, img_pdfstream_stream(d));
         }
     } else if (lua_key_eq(s,ref_count)) {
         lua_pushinteger(L, img_luaref(d));
@@ -568,7 +520,7 @@ static void lua_to_image(lua_State * L,
         if (img_state(d) >= DICT_FILESCANNED) {
             luaL_error(L, "image.filename is now read-only");
         } else if (img_type(d) == IMG_TYPE_PDFSTREAM) {
-            /* just ignore */
+            luaL_error(L, "image.filename can't be used with image.stream");
         } else if (t == LUA_TSTRING) {
             xfree(img_filename(d));
             img_filename(d) = xstrdup(lua_tostring(L, -1));
@@ -579,35 +531,13 @@ static void lua_to_image(lua_State * L,
         if (img_state(d) >= DICT_FILESCANNED) {
             luaL_error(L, "image.visiblefilename is now read-only");
         } else if (img_type(d) == IMG_TYPE_PDFSTREAM) {
-            img_visiblefilename(d) = NULL;
+            luaL_error(L, "image.visiblefilename can't be used with image.stream");
         } else if (t == LUA_TSTRING) {
             xfree(img_visiblefilename(d));
             img_visiblefilename(d) = xstrdup(lua_tostring(L, -1));
         } else {
             luaL_error(L, "image.visiblefilename needs string value");
         }
-    } else if (lua_key_eq(s,userpassword)) {
-        if (img_state(d) >= DICT_FILESCANNED) {
-            luaL_error(L, "image.userpassword is now read-only");
-        } else if (img_type(d) == IMG_TYPE_PDFSTREAM) {
-            img_userpassword(d) = NULL;
-        } else if (t == LUA_TSTRING) {
-            xfree(img_userpassword(d));
-            img_userpassword(d) = xstrdup(lua_tostring(L, -1));
-        } else {
-            luaL_error(L, "image.userpassword needs string value");
-        }
-    } else if (lua_key_eq(s,ownerpassword)) {
-        if (img_state(d) >= DICT_FILESCANNED) {
-            luaL_error(L, "image.ownerpassword is now read-only");
-        } else if (img_type(d) == IMG_TYPE_PDFSTREAM) {
-            img_ownerpassword(d) = NULL;
-        } else if (t == LUA_TSTRING) {
-            xfree(img_ownerpassword(d));
-            img_ownerpassword(d) = xstrdup(lua_tostring(L, -1));
-        } else {
-            luaL_error(L, "image.ownerpassword needs string value");
-        }
     } else if (lua_key_eq(s,attr)) {
         if (img_state(d) >= DICT_FILESCANNED) {
             luaL_error(L, "image.attr is now read-only");
@@ -677,8 +607,6 @@ static void lua_to_image(lua_State * L,
         } else {
             img_keepopen(d) = lua_toboolean(L, -1);
         }
-    } else if (lua_key_eq(s,nolength)) {
-        img_nolength(d) = lua_toboolean(L, -1);
     } else if (lua_key_eq(s,bbox)) {
         if (img_state(d) >= DICT_FILESCANNED) {
             luaL_error(L, "image.bbox is now read-only");
@@ -708,15 +636,11 @@ static void lua_to_image(lua_State * L,
         } else if (img_state(d) >= DICT_FILESCANNED) {
             luaL_error(L, "image.stream is now read-only");
         } else {
-            size_t size = 0;
-            const char *stream = lua_tolstring(L, -1, &size);
             if (img_pdfstream_ptr(d) == NULL) {
                 new_img_pdfstream_struct(d);
             }
             xfree(img_pdfstream_stream(d));
-            img_pdfstream_size(d) = size;
-            img_pdfstream_stream(d) = xmalloc(size);
-            memcpy(img_pdfstream_stream(d),stream,size);
+            img_pdfstream_stream(d) = xstrdup(lua_tostring(L, -1));
             img_type(d) = IMG_TYPE_PDFSTREAM;
         }
     } else {
--- texlive-bin.orig/texk/web2c/luatexdir/lua/liolibext.c
+++ texlive-bin/texk/web2c/luatexdir/lua/liolibext.c
@@ -125,7 +125,7 @@ static int readcardinal1_s(lua_State *L)
     size_t l;
     const char *s = luaL_checklstring(L, 1, &l);
     size_t p = luaL_checkinteger(L, 2) - 1;
-    if (p >= l) {
+    if (p < 0 || p >= l) {
         lua_pushnil(L);
     } else {
         int a = uchar(s[p]);
@@ -150,7 +150,7 @@ static int readcardinal2_s(lua_State *L)
     size_t l;
     const char *s = luaL_checklstring(L, 1, &l);
     size_t p = luaL_checkinteger(L, 2) - 1;
-    if (p+1 >= l) {
+    if (p < 0 || p+1 >= l) {
         lua_pushnil(L);
     } else {
         int a = uchar(s[p++]);
@@ -177,7 +177,7 @@ static int readcardinal3_s(lua_State *L)
     size_t l;
     const char *s = luaL_checklstring(L, 1, &l);
     size_t p = luaL_checkinteger(L, 2) - 1;
-    if (p+2 >= l) {
+    if (p < 0 || p+2 >= l) {
         lua_pushnil(L);
     } else {
         int a = uchar(s[p++]);
@@ -206,7 +206,7 @@ static int readcardinal4_s(lua_State *L)
     size_t l;
     const char *s = luaL_checklstring(L, 1, &l);
     size_t p = luaL_checkinteger(L, 2) - 1;
-    if (p+3 >= l) {
+    if (p < 0 || p+3 >= l) {
         lua_pushnil(L);
     } else {
         int a = uchar(s[p++]);
@@ -218,139 +218,6 @@ static int readcardinal4_s(lua_State *L)
     return 1;
 }
 
-static int readcardinaltable(lua_State *L) {
-    FILE *f = tofile(L);
-    int n = lua_tointeger(L,2);
-    int b = lua_tointeger(L,3);
-    int i;
-    lua_createtable(L,n,0);
-    switch (b) {
-        case 1:
-            for (i=1;i<=n;i++) {
-                int a = getc(f);
-                if (a == EOF) {
-                    break;
-                } else {
-                    lua_pushinteger(L, a);
-                    lua_rawseti(L, -2, i);
-                }
-            }
-            break;
-        case 2:
-            for (i=1;i<=n;i++) {
-                int a = getc(f);
-                int b = getc(f);
-                if (b == EOF) {
-                    break;
-                } else {
-                    /* (a<<8) | b */
-                    lua_pushinteger(L, 0x100 * a + b);
-                    lua_rawseti(L, -2, i);
-                }
-            }
-            break;
-        case 3:
-            for (i=1;i<=n;i++) {
-                int a = getc(f);
-                int b = getc(f);
-                int c = getc(f);
-                if (c == EOF) {
-                    break;
-                } else {
-                    /* (a<<16) | (b<<8) | c */
-                    lua_pushinteger(L, 0x10000 * a + 0x100 * b + c);
-                    lua_rawseti(L, -2, i);
-                }
-            }
-            break;
-        case 4:
-            for (i=1;i<=n;i++) {
-                int a = getc(f);
-                int b = getc(f);
-                int c = getc(f);
-                int d = getc(f);
-                if (d == EOF) {
-                    break;
-                } else {
-                    /* (a<<24) | (b<<16) | (c<<8) | d */
-                    lua_pushinteger(L,0x1000000 * a + 0x10000 * b + 0x100 * c + d);
-                    lua_rawseti(L, -2, i);
-                }
-            }
-            break;
-        default:
-            break;
-    }
-    return 1;
-}
-
-static int readcardinaltable_s(lua_State *L) {
-    size_t l;
-    const char *s = luaL_checklstring(L, 1, &l);
-    size_t p = luaL_checkinteger(L, 2) - 1;
-    int n = lua_tointeger(L,3);
-    int b = lua_tointeger(L,4);
-    int i;
-    lua_createtable(L,n,0);
-    /*if (p >= 0) {*/
-        switch (b) {
-            case 1:
-                for (i=1;i<=n;i++) {
-                    if (p >= l) {
-                        break;
-                    } else {
-                        int a = uchar(s[p++]);
-                        lua_pushinteger(L, a);
-                        lua_rawseti(L, -2, i);
-                    }
-                }
-                break;
-            case 2:
-                for (i=1;i<=n;i++) {
-                    if (p+1 >= l) {
-                        break;
-                    } else {
-                        int a = uchar(s[p++]);
-                        int b = uchar(s[p++]);
-                        lua_pushinteger(L, 0x100 * a + b);
-                        lua_rawseti(L, -2, i);
-                    }
-                }
-                break;
-            case 3:
-                for (i=1;i<=n;i++) {
-                    if (p+2 >= l) {
-                        break;
-                    } else {
-                        int a = uchar(s[p++]);
-                        int b = uchar(s[p++]);
-                        int c = uchar(s[p++]);
-                        lua_pushinteger(L, 0x10000 * a + 0x100 * b + c);
-                        lua_rawseti(L, -2, i);
-                    }
-                }
-                break;
-            case 4:
-                for (i=1;i<=n;i++) {
-                    if (p+3 >= l) {
-                        break;
-                    } else {
-                        int a = uchar(s[p++]);
-                        int b = uchar(s[p++]);
-                        int c = uchar(s[p++]);
-                        int d = uchar(s[p++]);
-                        lua_pushinteger(L,0x1000000 * a + 0x10000 * b + 0x100 * c + d);
-                        lua_rawseti(L, -2, i);
-                    }
-                }
-                break;
-            default:
-                break;
-        }
-    /*}*/
-    return 1;
-}
-
 static int readinteger1(lua_State *L) {
     FILE *f = tofile(L);
     int a = getc(f);
@@ -367,7 +234,7 @@ static int readinteger1_s(lua_State *L)
     size_t l;
     const char *s = luaL_checklstring(L, 1, &l);
     size_t p = luaL_checkinteger(L, 2) - 1;
-    if (p >= l) {
+    if (p < 0 || p >= l) {
         lua_pushnil(L);
     } else {
         int a = uchar(s[p]);
@@ -396,7 +263,7 @@ static int readinteger2_s(lua_State *L)
     size_t l;
     const char *s = luaL_checklstring(L, 1, &l);
     size_t p = luaL_checkinteger(L, 2) - 1;
-    if (p+1 >= l) {
+    if (p < 0 || p+1 >= l) {
         lua_pushnil(L);
     } else {
         int a = uchar(s[p++]);
@@ -427,7 +294,7 @@ static int readinteger3_s(lua_State *L)
     size_t l;
     const char *s = luaL_checklstring(L, 1, &l);
     size_t p = luaL_checkinteger(L, 2) - 1;
-    if (p+2 >= l) {
+    if (p < 0 || p+2 >= l) {
         lua_pushnil(L);
     } else {
         int a = uchar(s[p++]);
@@ -460,7 +327,7 @@ static int readinteger4_s(lua_State *L)
     size_t l;
     const char *s = luaL_checklstring(L, 1, &l);
     size_t p = luaL_checkinteger(L, 2) - 1;
-    if (p+3 >= l) {
+    if (p < 0 || p+3 >= l) {
         lua_pushnil(L);
     } else {
         int a = uchar(s[p++]);
@@ -475,160 +342,6 @@ static int readinteger4_s(lua_State *L)
     return 1;
 }
 
-static int readintegertable(lua_State *L) {
-    FILE *f = tofile(L);
-    int n = lua_tointeger(L,2);
-    int b = lua_tointeger(L,3);
-    int i;
-    lua_createtable(L,n,0);
-    switch (b) {
-        case 1:
-            for (i=1;i<=n;i++) {
-                int a = getc(f);
-                if (a == EOF) {
-                    break;
-                } else if (a >= 0x80) {
-                    lua_pushinteger(L, a - 0x100);
-                } else {
-                    lua_pushinteger(L, a);
-                }
-                lua_rawseti(L, -2, i);
-            }
-            break;
-        case 2:
-            for (i=1;i<=n;i++) {
-                int a = getc(f);
-                int b = getc(f);
-                if (b == EOF) {
-                    break;
-                } else if (a >= 0x80) {
-                    lua_pushinteger(L, 0x100 * a + b - 0x10000);
-                } else {
-                    lua_pushinteger(L, 0x100 * a + b);
-                }
-                lua_rawseti(L, -2, i);
-            }
-            break;
-        case 3:
-            for (i=1;i<=n;i++) {
-                int a = getc(f);
-                int b = getc(f);
-                int c = getc(f);
-                if (c == EOF) {
-                    break;
-                } else if (a >= 0x80) {
-                    lua_pushinteger(L, 0x10000 * a + 0x100 * b + c - 0x1000000);
-                } else {
-                    lua_pushinteger(L, 0x10000 * a + 0x100 * b + c);
-                }
-                lua_rawseti(L, -2, i);
-            }
-            break;
-        case 4:
-            for (i=1;i<=n;i++) {
-                int a = getc(f);
-                int b = getc(f);
-                int c = getc(f);
-                int d = getc(f);
-                if (d == EOF) {
-                    break;
-                } else if (a >= 0x80) {
-                    lua_pushinteger(L, 0x1000000 * a + 0x10000 * b + 0x100 * c + d - 0x100000000);
-                } else {
-                    lua_pushinteger(L, 0x1000000 * a + 0x10000 * b + 0x100 * c + d);
-                }
-                lua_rawseti(L, -2, i);
-            }
-            break;
-        default:
-            break;
-    }
-    return 1;
-}
-
-static int readintegertable_s(lua_State *L) {
-    size_t l;
-    const char *s = luaL_checklstring(L, 1, &l);
-    size_t p = luaL_checkinteger(L, 2) - 1;
-    int n = lua_tointeger(L,3);
-    int b = lua_tointeger(L,4);
-    int i;
-    lua_createtable(L,n,0);
-    /*if (p >= 0) {*/
-        switch (b) {
-            case 1:
-                for (i=1;i<=n;i++) {
-                    if (p >= l) {
-                        break;
-                    } else {
-                        int a = uchar(s[p++]);
-                        if (a >= 0x80) {
-                            lua_pushinteger(L, a - 0x100);
-                        } else {
-                            lua_pushinteger(L, a);
-                        }
-                        lua_rawseti(L, -2, i);
-                    }
-                }
-                break;
-            case 2:
-                for (i=1;i<=n;i++) {
-                    if (p+1 >= l) {
-                        break;
-                    } else {
-                        int a = uchar(s[p++]);
-                        int b = uchar(s[p++]);
-                        if (a >= 0x80) {
-                            lua_pushinteger(L, 0x100 * a + b - 0x10000);
-                        } else {
-                            lua_pushinteger(L, 0x100 * a + b);
-                        }
-                        lua_rawseti(L, -2, i);
-                    }
-                }
-                break;
-            case 3:
-                for (i=1;i<=n;i++) {
-                    if (p+2 >= l) {
-                        break;
-                    } else {
-                        int a = uchar(s[p++]);
-                        int b = uchar(s[p++]);
-                        int c = uchar(s[p++]);
-                        if (a >= 0x80) {
-                            lua_pushinteger(L, 0x10000 * a + 0x100 * b + c - 0x1000000);
-                        } else {
-                            lua_pushinteger(L, 0x10000 * a + 0x100 * b + c);
-                        }
-                        lua_rawseti(L, -2, i);
-                    }
-                }
-                break;
-            case 4:
-                for (i=1;i<=n;i++) {
-                    if (p+3 >= l) {
-                        break;
-                    } else {
-                        int a = uchar(s[p++]);
-                        int b = uchar(s[p++]);
-                        int c = uchar(s[p++]);
-                        int d = uchar(s[p++]);
-                        if (a >= 0x80) {
-                            lua_pushinteger(L, 0x1000000 * a + 0x10000 * b + 0x100 * c + d - 0x100000000);
-                        } else {
-                            lua_pushinteger(L, 0x1000000 * a + 0x10000 * b + 0x100 * c + d);
-                        }
-                        lua_rawseti(L, -2, i);
-                    }
-                }
-                break;
-            default:
-                break;
-        }
-    /*}*/
-    return 1;
-}
-
 static int readfixed2(lua_State *L) {
     FILE *f = tofile(L);
     int a = getc(f);
@@ -646,7 +359,7 @@ static int readfixed2_s(lua_State *L) {
     size_t l;
     const char *s = luaL_checklstring(L, 1, &l);
     size_t p = luaL_checkinteger(L, 2) - 1;
-    if (p+3 >= l) {
+    if (p < 0 || p+3 >= l) {
         lua_pushnil(L);
     } else {
         int a = uchar(s[p++]);
@@ -681,7 +394,7 @@ static int readfixed4_s(lua_State *L) {
     size_t l;
     const char *s = luaL_checklstring(L, 1, &l);
     size_t p = luaL_checkinteger(L, 2) - 1;
-    if (p+3 >= l) {
+    if (p < 0 || p+3 >= l) {
         lua_pushnil(L);
     } else {
         int a = uchar(s[p++]);
@@ -714,7 +427,7 @@ static int read2dot14_s(lua_State *L) {
     size_t l;
     const char *s = luaL_checklstring(L, 1, &l);
     size_t p = luaL_checkinteger(L, 2) - 1;
-    if (p+1 >= l) {
+    if (p < 0 || p+1 >= l) {
         lua_pushnil(L);
     } else {
         int a = uchar(s[p++]);
@@ -784,7 +497,7 @@ static int readbytetable_s(lua_State *L)
     const char *s = luaL_checklstring(L, 1, &l);
     size_t p = luaL_checkinteger(L, 2) - 1;
     int n = lua_tointeger(L,3);
-    if (p >= l) {
+    if (p < 0 || p >= l) {
         lua_pushnil(L);
     } else {
         int i ;
@@ -821,7 +534,7 @@ static int readbytes_s(lua_State *L) {
     const char *s = luaL_checklstring(L, 1, &l);
     size_t p = luaL_checkinteger(L, 2) - 1;
     int n = lua_tointeger(L,3);
-    if (p >= l) {
+    if (p < 0 || p >= l) {
         return 0;
     } else {
         int i ;
@@ -931,48 +644,44 @@ static int readline(lua_State *L)
 
 static const luaL_Reg fiolib[] = {
     /* helpers */
-    { "readcardinal1",     readcardinal1 },
-    { "readcardinal2",     readcardinal2 },
-    { "readcardinal3",     readcardinal3 },
-    { "readcardinal4",     readcardinal4 },
-    { "readcardinaltable", readcardinaltable },
-    { "readinteger1",      readinteger1 },
-    { "readinteger2",      readinteger2 },
-    { "readinteger3",      readinteger3 },
-    { "readinteger4",      readinteger4 },
-    { "readintegertable",  readintegertable },
-    { "readfixed2",        readfixed2 },
-    { "readfixed4",        readfixed4 },
-    { "read2dot14",        read2dot14 },
-    { "setposition",       setposition },
-    { "getposition",       getposition },
-    { "skipposition",      skipposition },
-    { "readbytes",         readbytes },
-    { "readbytetable",     readbytetable },
-    { "readline",          readline },
+    { "readcardinal1",   readcardinal1 },
+    { "readcardinal2",   readcardinal2 },
+    { "readcardinal3",   readcardinal3 },
+    { "readcardinal4",   readcardinal4 },
+    { "readinteger1",    readinteger1 },
+    { "readinteger2",    readinteger2 },
+    { "readinteger3",    readinteger3 },
+    { "readinteger4",    readinteger4 },
+    { "readfixed2",      readfixed2 },
+    { "readfixed4",      readfixed4 },
+    { "read2dot14",      read2dot14 },
+    { "setposition",     setposition },
+    { "getposition",     getposition },
+    { "skipposition",    skipposition },
+    { "readbytes",       readbytes },
+    { "readbytetable",   readbytetable },
+    { "readline",        readline },
     /* extras */
-    { "recordfilename",    recordfilename },
-    { "checkpermission",   checkpermission },
+    { "recordfilename",  recordfilename },
+    { "checkpermission", checkpermission },
     /* done */
     {NULL, NULL}
 };
 
 static const luaL_Reg siolib[] = {
-    { "readcardinal1",     readcardinal1_s },
-    { "readcardinal2",     readcardinal2_s },
-    { "readcardinal3",     readcardinal3_s },
-    { "readcardinal4",     readcardinal4_s },
-    { "readcardinaltable", readcardinaltable_s },
-    { "readinteger1",      readinteger1_s },
-    { "readinteger2",      readinteger2_s },
-    { "readinteger3",      readinteger3_s },
-    { "readinteger4",      readinteger4_s },
-    { "readintegertable",  readintegertable_s },
-    { "readfixed2",        readfixed2_s },
-    { "readfixed4",        readfixed4_s },
-    { "read2dot14",        read2dot14_s },
-    { "readbytes",         readbytes_s },
-    { "readbytetable",     readbytetable_s },
+    { "readcardinal1",   readcardinal1_s },
+    { "readcardinal2",   readcardinal2_s },
+    { "readcardinal3",   readcardinal3_s },
+    { "readcardinal4",   readcardinal4_s },
+    { "readinteger1",    readinteger1_s },
+    { "readinteger2",    readinteger2_s },
+    { "readinteger3",    readinteger3_s },
+    { "readinteger4",    readinteger4_s },
+    { "readfixed2",      readfixed2_s },
+    { "readfixed4",      readfixed4_s },
+    { "read2dot14",      read2dot14_s },
+    { "readbytes",       readbytes_s },
+    { "readbytetable",   readbytetable_s },
     /* done */
     {NULL, NULL}
 };
--- texlive-bin.orig/texk/web2c/luatexdir/lua/llanglib.c
+++ texlive-bin/texk/web2c/luatexdir/lua/llanglib.c
@@ -20,6 +20,7 @@
 #include "ptexlib.h"
 #include "lua/luatex-api.h"
 
+
 #define LANG_METATABLE "luatex.lang"
 
 #define check_islang(L,b) (struct tex_language **)luaL_checkudata(L,b,LANG_METATABLE)
@@ -83,6 +84,7 @@ static int lang_clear_patterns(lua_State
     return 0;
 }
 
+
 static int lang_hyphenation(lua_State * L)
 {
     struct tex_language **lang_ptr;
@@ -135,6 +137,7 @@ static int lang_post_hyphen_char(lua_Sta
     }
 }
 
+
 static int lang_pre_exhyphen_char(lua_State * L)
 {
     struct tex_language **lang_ptr;
@@ -259,6 +262,7 @@ static int do_lang_hyphenate(lua_State *
 }
 
 static const struct luaL_Reg langlib_d[] = {
+    /* *INDENT-OFF* */
     {"clear_patterns",    lang_clear_patterns},
     {"clear_hyphenation", lang_clear_hyphenation},
     {"patterns",          lang_patterns},
@@ -271,11 +275,13 @@ static const struct luaL_Reg langlib_d[]
     {"sethjcode",         lang_sethjcode},
     {"gethjcode",         lang_gethjcode},
     {"id",                lang_id},
-    /*tex sentinel */
-    {NULL,                NULL}
+    /* *INDENT-ON* */
+    {NULL, NULL}                /* sentinel */
 };
 
+
 static const struct luaL_Reg langlib[] = {
+    /* *INDENT-OFF* */
     {"clear_patterns",    lang_clear_patterns},
     {"clear_hyphenation", lang_clear_hyphenation},
     {"patterns",          lang_patterns},
@@ -291,19 +297,17 @@ static const struct luaL_Reg langlib[] =
     {"clean",             do_lang_clean},
     {"hyphenate",         do_lang_hyphenate},
     {"new",               lang_new},
-    /*tex sentinel */
-    {NULL,                NULL}
+    /* *INDENT-ON* */
+    {NULL, NULL}                /* sentinel */
 };
 
+
 int luaopen_lang(lua_State * L)
 {
     luaL_newmetatable(L, LANG_METATABLE);
-    /*tex push metatable */
-    lua_pushvalue(L, -1);
-    /*tex metatable.__index = metatable */
-    lua_setfield(L, -2, "__index");
-    /*tex set dict methods */
-    luaL_openlib(L, NULL, langlib_d, 0);
+    lua_pushvalue(L, -1);       /* push metatable */
+    lua_setfield(L, -2, "__index");     /* metatable.__index = metatable */
+    luaL_openlib(L, NULL, langlib_d, 0);  /* dict methods */
     luaL_openlib(L, "lang", langlib, 0);
     return 1;
 }
--- texlive-bin.orig/texk/web2c/luatexdir/lua/llualib.c
+++ texlive-bin/texk/web2c/luatexdir/lua/llualib.c
@@ -20,13 +20,14 @@
 #include "ptexlib.h"
 #include "lua/luatex-api.h"
 
-#define LOAD_BUF_SIZE 64*1024
+
+#define LOAD_BUF_SIZE 256
 #define UINT_MAX32 0xFFFFFFFF
 
 typedef struct {
     unsigned char *buf;
     int size;
- /* int done; */
+    int done;
     int alloc;
 } bytecode;
 
@@ -94,7 +95,7 @@ void undump_luac_registers(void)
         lua_bytecode_registers = xmalloc((unsigned) (i * sizeof(bytecode)));
         luabytecode_bytes = (unsigned) (i * sizeof(bytecode));
         for (i = 0; i <= (unsigned) luabytecode_max; i++) {
-         /* lua_bytecode_registers[i].done = 0; */
+            lua_bytecode_registers[i].done = 0;
             lua_bytecode_registers[i].size = 0;
             lua_bytecode_registers[i].buf = NULL;
         }
@@ -169,18 +170,14 @@ static int writer(lua_State * L, const v
 static const char *reader(lua_State * L, void *ud, size_t * size)
 {
     bytecode *buf = (bytecode *) ud;
-    (void) L; /* for -Wunused */
-    /*
+    (void) L;                   /* for -Wunused */
     if (buf->done == buf->size) {
         *size = 0;
         buf->done = 0;
         return NULL;
     }
-    */
     *size = (size_t) buf->size;
-    /*
     buf->done = buf->size;
-    */
     return (const char *) buf->buf;
 }
 
@@ -199,7 +196,7 @@ static int get_bytecode(lua_State * L)
 #else
                  "bytecode", NULL)) {
 #endif
-                return luaL_error(L, "bad bytecode register");
+		return luaL_error(L, "bad bytecode register");
             } else {
                 lua_pushvalue(L, -1);
                 bytecode_register_shadow_set(L, k);
@@ -211,41 +208,6 @@ static int get_bytecode(lua_State * L)
     return 1;
 }
 
-void luabytecodecall(int slot)
-{
-    int i;
-    int stacktop = lua_gettop(Luas);
-    lua_active++;
-    if (slot < 0 || slot > luabytecode_max) {
-        luaL_error(Luas, "bytecode register out of range");
-    } else if (bytecode_register_shadow_get(Luas, slot) || lua_bytecode_registers[slot].buf == NULL) {
-        luaL_error(Luas, "undefined bytecode register");
-    } else if (lua_load(Luas, reader, (void *) (lua_bytecode_registers + slot),
-#ifdef LuajitTeX
-             "bytecode"))
-#else
-             "bytecode", NULL))
-#endif
-    {
-        luaL_error(Luas, "bytecode register doesn't load well");
-    } else {
-        int base = lua_gettop(Luas); /* function index */
-        lua_pushinteger(Luas, slot);
-        lua_pushcfunction(Luas, lua_traceback); /* push traceback function */
-        lua_insert(Luas, base); /* put it under chunk  */
-++function_callback_count; /* this will be a dedicated counter */
-        i = lua_pcall(Luas, 1, 0, base);
-        lua_remove(Luas, base); /* remove traceback function */
-        if (i != 0) {
-            lua_gc(Luas, LUA_GCCOLLECT, 0);
-            Luas = luatex_error(Luas, (i == LUA_ERRRUN ? 0 : 1));
-        }
-    }
-
-    lua_settop(Luas,stacktop);
-    lua_active--;
-}
-
 static int set_bytecode(lua_State * L)
 {
     int k, ltype;
@@ -282,7 +244,7 @@ static int set_bytecode(lua_State * L)
         for (i = (unsigned) (luabytecode_max + 1); i <= (unsigned) k; i++) {
             lua_bytecode_registers[i].buf = NULL;
             lua_bytecode_registers[i].size = 0;
-         /* lua_bytecode_registers[i].done = 0; */
+            lua_bytecode_registers[i].done = 0;
         }
         luabytecode_max = k;
     }
@@ -290,7 +252,7 @@ static int set_bytecode(lua_State * L)
         xfree(lua_bytecode_registers[k].buf);
         luabytecode_bytes -= (unsigned) lua_bytecode_registers[k].size;
         lua_bytecode_registers[k].size = 0;
-     /* lua_bytecode_registers[k].done = 0; */
+        lua_bytecode_registers[k].done = 0;
         lua_pushnil(L);
         bytecode_register_shadow_set(L, k);
     }
@@ -306,7 +268,7 @@ static int set_bytecode(lua_State * L)
         lua_dump(L, writer, (void *) (lua_bytecode_registers + k),strip);
 #endif
 #if LUA_VERSION_NUM == 502
-        lua_dump(L, writer, (void *) (lua_bytecode_registers + k));
+        lua_dump(L, writer, (void *) (lua_bytecode_registers + k));    
 #endif
 #endif
     }
@@ -367,18 +329,6 @@ static int new_table(lua_State * L) /* h
     return 1;
 }
 
-static int get_stack_top(lua_State * L) /* hh */
-{
-    lua_pushinteger(L, lua_gettop(L));
-    return 1;
-}
-
-static int get_call_level(lua_State * L) /* hh */
-{
-    lua_pushinteger(L, lua_active);
-    return 1;
-}
-
 static const struct luaL_Reg lualib[] = {
     /* *INDENT-OFF* */
     {"getluaname",  get_luaname},
@@ -387,8 +337,6 @@ static const struct luaL_Reg lualib[] =
     {"setbytecode", set_bytecode},
     {"newtable",    new_table},
     {"get_functions_table",lua_functions_get_table},
-    {"getstacktop",get_stack_top},
-    {"getcalllevel", get_call_level},
     /* *INDENT-ON* */
     {NULL, NULL}                /* sentinel */
 };
--- texlive-bin.orig/texk/web2c/luatexdir/lua/lnewtokenlib.c
+++ texlive-bin/texk/web2c/luatexdir/lua/lnewtokenlib.c
@@ -33,12 +33,10 @@
 #include "ptexlib.h"
 #include "lua/luatex-api.h"
 
-/*
 typedef struct lua_token {
     int token;
     int origin;
 } lua_token;
-*/
 
 typedef struct saved_tex_scanner {
     int token;
@@ -147,51 +145,33 @@ static void push_token(lua_State * L, in
     lua_setmetatable(L, -2);
 }
 
-static int run_get_biggest_char(lua_State * L)
-{
-    lua_pushinteger(L, biggest_char);
-    return 1;
-}
-
-/* not that useful:
-
-static int run_get_cs_offset(lua_State * L)
-{
-    lua_pushinteger(L, cs_token_flag);
-    return 1;
-}
-
-*/
-
-static int run_get_command_id(lua_State * L)
-{
-    int id = -1;
-    if (lua_type(L, -1) == LUA_TSTRING) {
-        id = get_command_id(lua_tostring(L, -1));
-    }
-    if (id >= 0) {
-        lua_pushinteger(L, id);
-    } else {
-        lua_pushnil(L);
-    }
-    return 1;
-}
-
-/* not that useful:
-
-static int run_get_csname_id(lua_State * L)
-{
-    const char *s;
-    size_t k, cs = 0;
-    if (lua_type(L, -1) == LUA_TSTRING) {
-        s = lua_tolstring(L, -1, &k);
-        cs = (size_t) string_lookup(s, k);
-    }
-    lua_pushinteger(L, (lua_Number) cs);
-    return 1;
-}
-
-*/
+/* static int run_get_cs_offset(lua_State * L) */
+/* { */
+/*     lua_pushinteger(L, cs_token_flag); */
+/*     return 1; */
+/* } */
+
+/* static int run_get_command_id(lua_State * L) */
+/* { */
+/*     int cs = -1; */
+/*     if (lua_type(L, -1) == LUA_TSTRING) { */
+/*         cs = get_command_id(lua_tostring(L, -1)); */
+/*     } */
+/*     lua_pushinteger(L, cs); */
+/*     return 1; */
+/* } */
+
+/* static int run_get_csname_id(lua_State * L) */
+/* { */
+/*     const char *s; */
+/*     size_t k, cs = 0; */
+/*     if (lua_type(L, -1) == LUA_TSTRING) { */
+/*         s = lua_tolstring(L, -1, &k); */
+/*         cs = (size_t) string_lookup(s, k); */
+/*     } */
+/*     lua_pushinteger(L, (lua_Number) cs); */
+/*     return 1; */
+/* } */
 
 static int run_get_next(lua_State * L)
 {
@@ -316,22 +296,6 @@ static int run_scan_keyword(lua_State *
     return 1;
 }
 
-static int run_scan_keyword_cs(lua_State * L)
-{
-    saved_tex_scanner texstate;
-    const char *s = luaL_checkstring(L, -1);
-    int v = 0;
-    if (s) {
-        save_tex_scanner(texstate);
-        if (scan_keyword_case_sensitive(s)) {
-            v = 1;
-        }
-        unsave_tex_scanner(texstate);
-    }
-    lua_pushboolean(L,v);
-    return 1;
-}
-
 static int run_scan_csname(lua_State * L)
 {
     unsigned char *s;
@@ -364,138 +328,6 @@ static int run_scan_int(lua_State * L)
     return 1;
 }
 
-/*
-    char * str ;
-*/
-
-# define declare_buffer \
-    unsigned char word[5 + 1]; \
-    char *uindex = (char *)word; \
-    luaL_Buffer b ; \
-    luaL_buffinit(L,&b) ;
-
-/*
-    str = (char *) uni2str(cur_chr);
-    luaL_addstring(&b,(char *) str);
-    xfree(str);
-*/
-
-# define add_to_buffer(chr) \
-    if (chr <= 255) { \
-        luaL_addchar(&b,(unsigned) (char) chr); \
-    } else { \
-        uindex = uni2string((char *)word,(unsigned) chr); \
-        *uindex = '\0'; \
-        luaL_addstring(&b,(char *) word); \
-    }
-
-# define push_buffer \
-    luaL_pushresult(&b);
-
-static int run_scan_float_indeed(lua_State * L, boolean exponent)
-{
-    saved_tex_scanner texstate;
-    int ok;
-    boolean negative = false;
-    double d;
-    declare_buffer;
-    save_tex_scanner(texstate);
-    /* we collapse as in scan_dimen */
-    while(1) {
-        do {
-            get_x_token();
-        } while (cur_cmd == spacer_cmd);
-        if (cur_tok == minus_token) {
-            negative = !negative;
-        } else if (cur_tok != plus_token) {
-            break;
-        }
-    }
-    if (negative) {
-        add_to_buffer('-');
-    }
-    /* we accept [.,]digits */
-    if (cur_tok == point_token || cur_tok == comma_token) {
-        add_to_buffer('.');
-        while (1) {
-            get_x_token();
-            if ((cur_tok >= zero_token) && (cur_tok <= nine_token)) {
-                add_to_buffer(cur_chr);
-            } else if (exponent) {
-                goto EXPONENT;
-            } else {
-                back_input();
-                goto DONE;
-            }
-        }
-    } else {
-        back_input();
-        while (1) {
-            get_x_token();
-            if ((cur_tok >= zero_token) && (cur_tok <= nine_token)) {
-                add_to_buffer(cur_chr);
-            } else {
-                if (cur_tok == point_token || cur_tok == comma_token) {
-                    add_to_buffer('.');
-                    while (1) {
-                        get_x_token();
-                        if ((cur_tok >= zero_token) && (cur_tok <= nine_token)) {
-                            add_to_buffer(cur_chr);
-                        } else {
-                            back_input();
-                            break;
-                        }
-                    }
-                } else if (exponent) {
-                    goto EXPONENT;
-                } else {
-                    back_input();
-                    goto DONE;
-                }
-            }
-        }
-    }
-EXPONENT:
-    if ((cur_chr == 'E') || (cur_chr == 'e')) {
-        add_to_buffer(cur_chr);
-        get_x_token();
-        if ((cur_tok == minus_token) || (cur_tok == plus_token)) {
-            add_to_buffer(cur_chr);
-        } else if ((cur_tok >= zero_token) && (cur_tok <= nine_token)) {
-            add_to_buffer(cur_chr);
-        }
-        while (1) {
-            get_x_token();
-            if ((cur_tok >= zero_token) && (cur_tok <= nine_token)) {
-                add_to_buffer(cur_chr);
-            } else {
-                break;
-            }
-        }
-    }
-    back_input();
-DONE:
-    push_buffer;
-    d = lua_tonumberx(L,1,&ok);
-    if (ok) {
-        lua_pushnumber(L,d);
-    } else {
-        lua_pushnil(L);
-    }
-    unsave_tex_scanner(texstate);
-    return 1;
-}
-
-static int run_scan_float(lua_State * L)
-{
-    return run_scan_float_indeed(L,true);
-}
-
-static int run_scan_real(lua_State * L)
-{
-    return run_scan_float_indeed(L,false);
-}
-
 static int run_scan_dimen(lua_State * L)
 {
     saved_tex_scanner texstate;
@@ -507,7 +339,7 @@ static int run_scan_dimen(lua_State * L)
     if (t>1)
       mu = lua_toboolean(L,2);  /* mu units required ?*/
     save_tex_scanner(texstate);
-    scan_dimen(mu,inf, false); /* arg3 = shortcut */
+    scan_dimen( mu,inf, false); /* arg3 = shortcut */
     v = cur_val;
     o = cur_order;
     unsave_tex_scanner(texstate);
@@ -583,67 +415,25 @@ static int run_scan_string(lua_State * L
     } else if (cur_cmd == call_cmd) {
         t = token_link(cur_chr);
         tokenlist_to_luastring(L,t);
-    } else if (cur_cmd == 11 || cur_cmd == 12 ) {
-        declare_buffer;
-        while (1) {
-            add_to_buffer(cur_chr);
-            get_x_token();
-            if (cur_cmd != 11 && cur_cmd != 12 ) {
-                break ;
-            }
-        }
-        back_input();
-        push_buffer;
     } else {
-        back_input();
-        lua_pushnil(L);
-    }
-    unsave_tex_scanner(texstate);
-    return 1;
-}
-
-static int run_scan_argument(lua_State * L) /* HH */
-{   /* can be simplified, no need for intermediate list */
-    saved_tex_scanner texstate;
-    halfword t, saved_defref;
-    save_tex_scanner(texstate);
-    do {
-        get_token();
-    } while ((cur_cmd == spacer_cmd) || (cur_cmd == relax_cmd));
-    if (cur_cmd == left_brace_cmd) {
-        back_input();
-        saved_defref = def_ref;
-        (void) scan_toks(false, true);
-        t = def_ref;
-        def_ref = saved_defref;
-        tokenlist_to_luastring(L,t);
-    } else if (cur_cmd == call_cmd) {
-        halfword saved_cur_tok = cur_tok;
-        cur_tok = right_brace_token + '}';
-        back_input();
-        cur_tok = saved_cur_tok;
-        back_input();
-        cur_tok = left_brace_token + '{';
-        back_input();
-        saved_defref = def_ref;
-        (void) scan_toks(false, true);
-        t = def_ref;
-        def_ref = saved_defref;
-        tokenlist_to_luastring(L,t);
-    } else if (cur_cmd == 11 || cur_cmd == 12 ) {
-        declare_buffer;
-        while (1) {
-            add_to_buffer(cur_chr);
-            get_x_token();
-            if (cur_cmd != 11 && cur_cmd != 12 ) {
-                break ;
+        if (cur_cmd == 11 || cur_cmd == 12 ) {
+            char * str ;
+            luaL_Buffer b ;
+            luaL_buffinit(L,&b) ;
+            while (1) {
+                str = (char *) uni2str(cur_chr);
+                luaL_addstring(&b,(char *) str);
+                get_x_token();
+                if (cur_cmd != 11 && cur_cmd != 12 ) {
+                    break ;
+                }
             }
+            back_input();
+            luaL_pushresult(&b);
+        } else {
+            back_input();
+            lua_pushnil(L);
         }
-        back_input();
-        push_buffer;
-    } else {
-        back_input();
-        lua_pushnil(L);
     }
     unsave_tex_scanner(texstate);
     return 1;
@@ -657,16 +447,20 @@ static int run_scan_word(lua_State * L)
         get_x_token();
     } while ((cur_cmd == spacer_cmd) || (cur_cmd == relax_cmd));
     if (cur_cmd == 11 || cur_cmd == 12 ) {
-        declare_buffer;
+        char *str ;
+        luaL_Buffer b ;
+        luaL_buffinit(L,&b) ;
         while (1) {
-            add_to_buffer(cur_chr);
+            str = (char *) uni2str(cur_chr);
+            luaL_addstring(&b,str);
+            xfree(str);
             get_x_token();
             if (cur_cmd != 11 && cur_cmd != 12 ) {
                 break ;
             }
         }
         back_input();
-        push_buffer;
+        luaL_pushresult(&b);
     } else {
         back_input();
         lua_pushnil(L);
@@ -709,12 +503,12 @@ static int lua_tokenlib_is_token(lua_Sta
     return 1;
 }
 
-static int run_expand(lua_State * L)
-{
-    (void) L;
-    expand();
-    return 0;
-}
+/* static int run_expand(lua_State * L) */
+/* { */
+/*     (void) L; */
+/*     expand(); */
+/*     return 0; */
+/* } */
 
 static int run_lookup(lua_State * L)
 {
@@ -735,21 +529,6 @@ static int run_lookup(lua_State * L)
     return 1;
 }
 
-static int lua_tokenlib_is_defined(lua_State * L)
-{
-    const char *s;
-    size_t l;
-    if (lua_type(L, -1) == LUA_TSTRING) {
-        s = lua_tolstring(L, -1, &l);
-        if (l > 0) {
-            lua_pushboolean(L,string_lookup(s, l) != undefined_control_sequence);
-            return 1;
-        }
-    }
-    lua_pushnil(L);
-    return 1;
-}
-
 static int run_build(lua_State * L)
 {
     if (lua_type(L, 1) == LUA_TNUMBER) {
@@ -771,15 +550,6 @@ static int run_build(lua_State * L)
     }
 }
 
-static int run_new(lua_State * L)
-{
-    int cs = 0;
-    int chr = (int) lua_tointeger(L, 1);
-    int cmd = (int) lua_tointeger(L, 2);
-    make_new_token(L, cmd, chr, cs);
-    return 1;
-}
-
 /* token instance functions */
 
 static int lua_tokenlib_free(lua_State * L)
@@ -832,6 +602,7 @@ inline static int lua_tokenlib_get_index
             e -= toks_base;
             break;
         default:
+            e = -1;
             break;
     }
     if ((e >= 0) && (e <= 65535)) {
@@ -859,7 +630,7 @@ inline static int lua_tokenlib_get_cmdna
     lua_token *n = check_istoken(L, 1);
     halfword t = token_info(n->token);
     int cmd = (t >= cs_token_flag ? eq_type(t - cs_token_flag) : token_cmd(t));
-    lua_push_string_by_index(L, command_names[cmd].lua);
+    lua_pushstring(L, command_names[cmd].cmd_name); /* can be sped up */
     return 1;
 }
 
@@ -979,7 +750,7 @@ static int lua_tokenlib_equal(lua_State
     n = check_istoken(L, 1);
     m = check_istoken(L, 2);
     if (token_info(n->token) == token_info(m->token)) {
-    lua_pushboolean(L,1);
+	lua_pushboolean(L,1);
         return 1;
     }
     lua_pushboolean(L,0);
@@ -1018,19 +789,6 @@ static int run_scan_token(lua_State * L)
     return 1;
 }
 
-static int run_scan_list(lua_State * L)
-{
-    saved_tex_scanner texstate;
-    save_tex_scanner(texstate);
-    /*tex
-        This is s tricky call as we are in \LUA\ and therefore
-        mess with the main loop.
-    */
-    lua_nodelib_push_fast(L, local_scan_box());
-    unsave_tex_scanner(texstate);
-    return 1;
-}
-
 /* experiment */
 
 /* [catcodetable] csname content        : \def\csname{content}  */
@@ -1086,56 +844,6 @@ static int get_macro(lua_State * L)
     return 0;
 }
 
-static int set_lua(lua_State *L)
-{
-    const char *name = null;
-    const char *s  = null;
-    size_t lname = 0;
-    int cs;
-    int n = lua_gettop(L);
-    int a = 0; /* global state */
-    int p = 0; /* protected state */
-    int f = 0; /* function index */
-    int nncs = no_new_control_sequence;
-    if (n < 2) {
-        return 0 ;
-    }
-    name = lua_tolstring(L, 1, &lname);
-    if (name == null) {
-        return 0 ;
-    }
-    f = lua_tointeger(L, 2);
-    if (n > 2)  {
-        s = lua_tostring(L, 3);
-        if (s) {
-            if (lua_key_eq(s, global)) {
-                a = 4;
-            } else if (lua_key_eq(s, protected)) {
-                p = 1;
-            }
-        }
-        if (n > 3) {
-            s = lua_tostring(L, 4);
-            if (s) {
-                if (lua_key_eq(s, global)) {
-                    a = 4;
-                } else if (lua_key_eq(s, protected)) {
-                    p = 1;
-                }
-            }
-        }
-    }
-    no_new_control_sequence = false ;
-    cs = string_lookup(name, lname);
-    no_new_control_sequence = nncs;
-    if (p) {
-        define(cs, lua_call_cmd, f);
-    } else {
-        define(cs, lua_expandable_call_cmd, f);
-    }
-    return 0;
-}
-
 static int set_macro(lua_State * L)
 {
     const char *name = null;
@@ -1255,75 +963,27 @@ static int set_macro(lua_State * L)
     return 0;
 }
 
-static int set_char(lua_State * L)
-{
-    const char *name = null;
-    const char *s  = null;
-    size_t lname = 0;
-    int cs, value;
-    int n = lua_gettop(L);
-    int a = 0 ; /* global state */
-    int nncs = no_new_control_sequence;
-    if (n < 2)
-        return 0;
-    name = lua_tolstring(L, 1, &lname);
-    if (name == null)
-        return 0;
-    value = lua_tointeger(L, 2);
-    if (value < 0)
-        return 0;
-    if (n > 2)
-        s = lua_tostring(L, 3);
-    if (s && (lua_key_eq(s, global))) {
-        a = 4;
-    }
-    no_new_control_sequence = false ;
-    cs = string_lookup(name, lname);
-    no_new_control_sequence = nncs;
-    define(cs, char_given_cmd, value);
-    return 0;
-}
-
-static int get_command_names(lua_State * L)
-{
-    int i;
-    lua_createtable(L,data_cmd+1,0);
-    for (i = 0; command_names[i].lua != 0; i++) {
-        lua_rawgeti(L, LUA_REGISTRYINDEX, command_names[i].lua);
-        lua_rawseti(L, -2, i);
-    }
-    return 1;
-}
-
 static const struct luaL_Reg tokenlib[] = {
     { "type", lua_tokenlib_type },
     { "create", run_build },
-    { "new", run_new },
     { "is_token", lua_tokenlib_is_token },
-    { "is_defined", lua_tokenlib_is_defined },
-    { "commands", get_command_names },
-    { "command_id", run_get_command_id },
-    { "biggest_char", run_get_biggest_char },
     /* scanners */
     { "get_next", run_get_next },
+    { "put_next", run_put_next },
     { "scan_keyword", run_scan_keyword },
-    { "scan_keyword_cs", run_scan_keyword_cs },
     { "scan_int", run_scan_int },
-    { "scan_float", run_scan_float },
-    { "scan_real", run_scan_real },
     { "scan_dimen", run_scan_dimen },
     { "scan_glue", run_scan_glue },
     { "scan_toks", run_scan_toks },
     { "scan_code", run_scan_code },
     { "scan_string", run_scan_string },
-    { "scan_argument", run_scan_argument },
     { "scan_word", run_scan_word },
     { "scan_csname", run_scan_csname },
     { "scan_token", run_scan_token }, /* expands next token if needed */
-    { "scan_list", run_scan_list },
-    /* writers */
-    { "put_next", run_put_next },
-    { "expand", run_expand },
+    /* push into input stream */
+    /*
+    { "write",luatwrite },
+    */
     /* getters */
     { "get_command", lua_tokenlib_get_command },
     { "get_index", lua_tokenlib_get_index },
@@ -1335,12 +995,15 @@ static const struct luaL_Reg tokenlib[]
     { "get_active", lua_tokenlib_get_active },
     { "get_expandable", lua_tokenlib_get_expandable },
     { "get_protected", lua_tokenlib_get_protected },
+    /* maybe more setters */
+    { "set_macro", set_macro },
     { "get_macro", get_macro },
     { "get_meaning", get_meaning },
-    /* setters */
-    { "set_macro", set_macro },
-    { "set_char", set_char },
-    { "set_lua", set_lua },
+    /* probably never */
+ /* {"expand", run_expand},               */ /* does not work yet! */
+ /* {"csname_id", run_get_csname_id},     */ /* yes or no */
+ /* {"command_id", run_get_command_id},   */ /* yes or no */
+ /* {"cs_offset", run_get_cs_offset},     */ /* not that useful */
     {NULL, NULL}
 };
 
--- texlive-bin.orig/texk/web2c/luatexdir/lua/lnodelib.c
+++ texlive-bin/texk/web2c/luatexdir/lua/lnodelib.c
@@ -209,80 +209,6 @@ halfword *check_isnode(lua_State * L, in
     return NULL;
 }
 
-static int nodelib_setdir_text(lua_State * L, int i, halfword n)
-{
-    if (lua_type(L, i) == LUA_TSTRING) {
-        const char *s = lua_tostring(L, i);
-        if (s==lua_key_plus(TLT)) {
-            dir_dir(n) = 0 ;
-            subtype(n) = normal_dir;
-        } else if (s==lua_key_minus(TLT)) {
-            dir_dir(n) = 0 ;
-            subtype(n) = cancel_dir;
-        } else if (s==lua_key_plus(TRT)) {
-            dir_dir(n) = 1 ;
-            subtype(n) = normal_dir;
-        } else if (s==lua_key_minus(TRT)) {
-            dir_dir(n) = 1 ;
-            subtype(n) = cancel_dir;
-        } else if (s==lua_key_plus(LTL)) {
-            dir_dir(n) = 2 ;
-            subtype(n) = normal_dir;
-        } else if (s==lua_key_minus(LTL)) {
-            dir_dir(n) = 2 ;
-            subtype(n) = cancel_dir;
-        } else if (s==lua_key_plus(RTT)) {
-            dir_dir(n) = 3 ;
-            subtype(n) = normal_dir;
-        } else if (s==lua_key_minus(RTT)) {
-            dir_dir(n) = 3 ;
-            subtype(n) = cancel_dir;
-        } else {
-            luaL_error(L, "Bad direction specifier %s", s);
-        }
-    } else {
-        luaL_error(L, "Direction specifiers have to be strings");
-    }
-    return 0;
-}
-
-static int nodelib_getdir_par(lua_State * L, int n)
-{
-    if (lua_type(L, n) == LUA_TSTRING) {
-        const char *s = lua_tostring(L, n);
-        if (s==lua_key(TLT))
-            return 0 ;
-        else if (s==lua_key(TRT))
-            return 1 ;
-        else if (s==lua_key(LTL))
-            return 2 ;
-        else if (s==lua_key(RTT))
-            return 3 ;
-        else
-            luaL_error(L, "Bad direction specifier %s", s);
-    } else {
-        luaL_error(L, "Direction specifiers have to be strings");
-    }
-    return 0;
-}
-
-static int nodelib_getdirection(lua_State * L, int n)
-{
-    if (lua_type(L, n) == LUA_TNUMBER) {
-        int i = lua_tointeger(L, n);
-        check_dir_value(i);
-        return i;
-    } else {
-        luaL_error(L, "Direction specifiers have to be numbers");
-    }
-    return 0;
-}
-
-int nodelib_getdir(lua_State * L, int n) /* the api public one */
-{
-    return nodelib_getdir_par(L,n);
-}
-
 /*
 
     This routine finds the numerical value of a string (or number) at
@@ -290,32 +216,13 @@ int nodelib_getdir(lua_State * L, int n)
 
 */
 
-/* s = lua_tostring(L, 2); */
-/* if (lua_key_eq(s, id)) { */
-
 static int get_node_type_id_from_name(lua_State * L, int n, node_info * data)
 {
-    if (data != NULL) {
-        int j;
-        const char *s = lua_tostring(L, n);
-        for (j = 0; data[j].id != -1; j++) {
-            if (s == data[j].name) {
-                return j;
-            }
-        }
-    }
-    return -1;
-}
-
-static int get_node_subtype_id_from_name(lua_State * L, int n, subtype_info * data)
-{
-    if (data != NULL) {
-        int j;
-        const char *s = lua_tostring(L, n);
-        for (j = 0; data[j].id != -1; j++) {
-            if (s == data[j].name) {
-                return j;
-            }
+    int j;
+    const char *s = lua_tostring(L, n);
+    for (j = 0; data[j].id != -1; j++) {
+        if (strcmp(s, data[j].name) == 0) {
+            return j;
         }
     }
     return -1;
@@ -327,7 +234,7 @@ static int get_valid_node_type_id(lua_St
     int t = lua_type(L, n);
     if (t == LUA_TSTRING) {
         i = get_node_type_id_from_name(L,n,node_data);
-        if (i < 0) {
+        if (i<0) {
             luaL_error(L, "invalid node type id: %s", lua_tostring(L, n));
         }
     } else if (t == LUA_TNUMBER) {
@@ -440,31 +347,6 @@ void lua_nodelib_push_fast(lua_State * L
     return;
 }
 
-/* getting and setting fields (helpers) */
-
-int nodelib_getlist(lua_State * L, int n)
-{
-    if (lua_isuserdata(L, n)) {
-        halfword m = *check_isnode(L, n);
-        return m;
-    } else {
-        return null;
-    }
-}
-
-static str_number nodelib_getstring(lua_State * L, int a)
-{
-    size_t k;
-    const char *s = lua_tolstring(L, a, &k);
-    return maketexlstring(s, k);
-}
-
-static int nodelib_cantset(lua_State * L, int n, const char *s)
-{
-    luaL_error(L,"You cannot set field %s in a node of type %s",s,node_data[type(n)].name);
-    return 0;
-}
-
 /* converts type strings to type ids */
 
 static int lua_nodelib_id(lua_State * L)
@@ -557,44 +439,6 @@ static int lua_nodelib_direct_setsubtype
         return 1;
     }
 
-/* node.direct.getexpansion */
-/* node.direct.setexpansion */
-
-static int lua_nodelib_direct_getexpansion(lua_State * L)
-{
-    halfword n = lua_tointeger(L, 1);
-    if (n != null) {
-        halfword t = type(n);
-        if (t == glyph_node) {
-            lua_pushinteger(L, ex_glyph(n));
-            return 1;
-        } else if (t == kern_node) {
-            lua_pushinteger(L, ex_kern(n));
-            return 1;
-        }
-    }
-    lua_pushnil(L);
-    return 1;
-}
-
-static int lua_nodelib_direct_setexpansion(lua_State * L)
-{
-    halfword n = lua_tointeger(L, 1);
-    if (n) {
-        halfword t = type(n);
-        halfword e = 0;
-        if (lua_type(L, 2) == LUA_TNUMBER) {
-            e = (halfword) lua_tointeger(L, 2);
-        }
-        if (t == glyph_node) {
-            ex_glyph(n) = e;
-        } else if ( t == kern_node) {
-            ex_kern(n) = e;
-        }
-    }
-    return 0;
-}
-
 /* node.direct.getfont */
 /* node.direct.setfont */
 
@@ -686,10 +530,6 @@ static int lua_nodelib_direct_getfam(lua
             lua_pushinteger(L, math_fam(n));
         } else if (t == delim_node) {
             lua_pushinteger(L, small_fam(n));
-        } else if (t == fraction_noad) {
-            lua_pushinteger(L, fraction_fam(n));
-        } else if (t == simple_noad) {
-            lua_pushinteger(L, noad_fam(n));
         } else {
             lua_pushnil(L);
         }
@@ -725,10 +565,6 @@ static int lua_nodelib_direct_setfam(lua
             math_fam(n) = (halfword) lua_tointeger(L, 2);
         } else if (t == delim_node) {
             small_fam(n) = (halfword) lua_tointeger(L, 2);
-        } else if (t == fraction_noad) {
-            fraction_fam(n) = (halfword) lua_tointeger(L, 2);
-        } else if (t == simple_noad) {
-            noad_fam(n) = (halfword) lua_tointeger(L, 2);
         }
     }
     return 0;
@@ -736,7 +572,7 @@ static int lua_nodelib_direct_setfam(lua
 
     /* node.getchar */
 
-static int lua_nodelib_getchar(lua_State * L)
+    static int lua_nodelib_getchar(lua_State * L)
     {
         halfword *n = lua_touserdata(L, 1);
         if ((n == NULL) || (! lua_getmetatable(L,1))) {
@@ -829,8 +665,7 @@ static int lua_nodelib_direct_setattribu
 {
     halfword n = lua_tointeger(L, 1);
     if ((n) && nodetype_has_attributes(type(n))) {
-        int t = lua_type(L, 2);
-        if (t == LUA_TNUMBER) {
+        if (lua_type(L, 2) == LUA_TNUMBER) {
             halfword a =lua_tointeger(L, 2);
             if (type(a) == attribute_list_node) {
                 reassign_attribute(n,a);
@@ -839,12 +674,6 @@ static int lua_nodelib_direct_setattribu
             } else {
                 reassign_attribute(n,null);
             }
-        } else if (t == LUA_TBOOLEAN) {
-            if (lua_toboolean(L,2)) {
-                reassign_attribute(n,current_attribute_list());
-            } else {
-                reassign_attribute(n,null);
-            }
         } else {
             reassign_attribute(n,null);
         }
@@ -852,6 +681,7 @@ static int lua_nodelib_direct_setattribu
     }
     return 0;
 }
+
 /* node.direct.getpenalty */
 /* node.direct.setpenalty */
 
@@ -997,15 +827,7 @@ static int lua_nodelib_direct_getkern(lu
     halfword n = lua_tointeger(L, 1);
     if (n) {
         halfword t = type(n);
-        if (t == kern_node) {
-            if (lua_toboolean(L,2)) {
-                lua_pushnumber(L, (1+ex_kern(n)/1000) * width(n));
-                lua_pushinteger(L, ex_kern(n));
-                return 2;
-            } else {
-                lua_pushinteger(L, width(n));
-            }
-        } else if (t == margin_kern_node) {
+        if (t == kern_node || t == margin_kern_node) {
             lua_pushinteger(L, width(n));
         } else if (t == math_node) {
             lua_pushinteger(L, surround(n));
@@ -1052,7 +874,7 @@ static int lua_nodelib_direct_getdir(lua
     if (n) {
         halfword t = type(n);
         if (t == dir_node) {
-            lua_push_dir_text(L, dir_dir(n), subtype(n));
+            lua_push_dir_text(L, dir_dir(n));
         } else if (t == hlist_node || t == vlist_node) {
             lua_push_dir_par(L, box_dir(n));
         } else if (t == rule_node) {
@@ -1068,68 +890,19 @@ static int lua_nodelib_direct_getdir(lua
     return 1;
 }
 
-static int lua_nodelib_direct_getdirection(lua_State * L)
-{
-    halfword n = lua_tointeger(L, 1);
-    if (n) {
-        halfword t = type(n);
-        if (t == dir_node) {
-            lua_push_direction(L, dir_dir(n));
-            lua_pushboolean(L, subtype(n));
-            return 2;
-        } else if (t == hlist_node || t == vlist_node) {
-            lua_push_direction(L, box_dir(n));
-        } else if (t == rule_node) {
-            lua_push_direction(L, rule_dir(n));
-        } else if (t == local_par_node) {
-            lua_push_direction(L, local_par_dir(n));
-        } else {
-            lua_pushnil(L);
-        }
-    } else {
-        lua_pushnil(L);
-    }
-    return 1;
-}
-
 static int lua_nodelib_direct_setdir(lua_State * L)
 {
     halfword n = lua_tointeger(L, 1);
     if (n) {
         halfword t = type(n);
         if (t == dir_node) {
-            nodelib_setdir_text(L, 2, n);
-        } else if (t == hlist_node || type(n) == vlist_node) {
-            box_dir(n) = nodelib_getdir_par(L, 2);
-        } else if (t == rule_node) {
-            rule_dir(n) = nodelib_getdir_par(L, 2);
-        } else if (t == local_par_node) {
-            local_par_dir(n) = nodelib_getdir_par(L, 2);
-        }
-    }
-    return 0;
-}
-
-static int lua_nodelib_direct_setdirection(lua_State * L)
-{
-    halfword n = lua_tointeger(L, 1);
-    if (n) {
-        halfword t = type(n);
-        if (t == dir_node) {
-            dir_dir(n) = nodelib_getdirection(L, 2);
-            if ((lua_type(L, 3) == LUA_TBOOLEAN)) {
-                if (lua_toboolean(L, 3)) {
-                    subtype(n) = cancel_dir;
-                } else {
-                    subtype(n) = normal_dir;
-                }
-            }
+            dir_dir(n) = nodelib_getdir(L, 2, 0);
         } else if (t == hlist_node || type(n) == vlist_node) {
-            box_dir(n) = nodelib_getdirection(L, 2);
+            box_dir(n) = nodelib_getdir(L, 2, 1);
         } else if (t == rule_node) {
-            rule_dir(n) = nodelib_getdirection(L, 2);
+            rule_dir(n) = nodelib_getdir(L, 2, 1);
         } else if (t == local_par_node) {
-            local_par_dir(n) = nodelib_getdirection(L, 2);
+            local_par_dir(n) = nodelib_getdir(L, 3, 1);
         }
     }
     return 0;
@@ -1244,24 +1017,15 @@ static int lua_nodelib_direct_setdisc(lu
 /* node.direct.getwhd */
 /* node.direct.setwhd */
 
-#define push_list_whd(n) do { \
-    lua_pushinteger(L, width(n)); \
+#define push_list_whd(n) \
+    lua_pushinteger(L, width(n));  \
     lua_pushinteger(L, height(n)); \
-    lua_pushinteger(L, depth(n)); \
-} while (0)
-
-#define push_char_whd(n) do { \
-    lua_pushinteger(L, char_width(font(n),character(n))); \
-    lua_pushinteger(L, char_height(font(n),character(n))); \
-    lua_pushinteger(L, char_depth(font(n),character(n))); \
-} while (0)
+    lua_pushinteger(L, depth(n));  \
 
-#define push_char_ehd(n) do { \
-    lua_pushnumber(L, (1+ex_glyph(n)/1000) * char_width(font(n),character(n))); \
+#define push_char_whd(n) \
+    lua_pushinteger(L, char_width(font(n),character(n)));  \
     lua_pushinteger(L, char_height(font(n),character(n))); \
-    lua_pushinteger(L, char_depth(font(n),character(n))); \
-    lua_pushinteger(L, ex_glyph(n)); \
-} while (0)
+    lua_pushinteger(L, char_depth(font(n),character(n)));  \
 
 static int lua_nodelib_direct_getwhd(lua_State * L)
 {
@@ -1272,13 +1036,8 @@ static int lua_nodelib_direct_getwhd(lua
             push_list_whd(n);
             return 3;
         } else if (t == glyph_node) {
-            if (lua_toboolean(L,2)) {
-                push_char_ehd(n);
-                return 4;
-            } else {
-                push_char_whd(n);
-                return 3;
-            }
+            push_char_whd(n);
+            return 3;
         } else if (t == glue_node) {
             halfword l = leader_ptr(n);
             if (l != null) {
@@ -1345,13 +1104,8 @@ static int lua_nodelib_direct_setwhd(lua
                 push_list_whd(*n);
                 return 3;
             } else if (t == glyph_node) {
-                if (lua_toboolean(L,2)) {
-                    push_char_ehd(*n);
-                    return 4;
-                } else {
-                    push_char_whd(*n);
-                    return 3;
-                }
+                push_char_whd(*n);
+                return 3;
             } else if (t == glue_node) {
                 halfword l = leader_ptr(*n);
                 if (l != null) {
@@ -1460,7 +1214,7 @@ static int lua_nodelib_direct_getleader(
     return 1;
 }
 
-static int lua_nodelib_direct_setleader(lua_State * L)
+    static int lua_nodelib_direct_setleader(lua_State * L)
 {
     halfword n = lua_tointeger(L, 1);
     if ((n) && (type(n) == glue_node)) {
@@ -1473,7 +1227,7 @@ static int lua_nodelib_direct_setleader(
     return 0;
 }
 
-/* node.getleader */
+    /* node.getleader */
 
     static int lua_nodelib_getleader(lua_State * L)
     {
@@ -1489,241 +1243,6 @@ static int lua_nodelib_direct_setleader(
         return 1;
     }
 
-/* node.direct.getdata */
-/* node.direct.setdata */
-
-#define get_user_node_direct_value(L, n) do {                          \
-    switch (user_node_type(n)) {                                       \
-        case 'a':                                                      \
-            nodelib_pushdirect(user_node_value(n));                    \
-            break;                                                     \
-        case 'd':                                                      \
-            lua_pushinteger(L, user_node_value(n));                    \
-            break;                                                     \
-        case 'l':                                                      \
-            if (user_node_value(n) != 0) {                             \
-                lua_rawgeti(L, LUA_REGISTRYINDEX, user_node_value(n)); \
-            } else {                                                   \
-                lua_pushnil(L);                                        \
-            }                                                          \
-            break;                                                     \
-        case 'n':                                                      \
-            nodelib_pushdirect(user_node_value(n));                    \
-            break;                                                     \
-        case 's':                                                      \
-            nodelib_pushstring(L, user_node_value(n));                 \
-            break;                                                     \
-        case 't':                                                      \
-            tokenlist_to_lua(L, user_node_value(n));                   \
-            break;                                                     \
-        default:                                                       \
-            lua_pushinteger(L, user_node_value(n));                    \
-            break;                                                     \
-    }                                                                  \
-} while (0)
-
-#define set_user_node_direct_value(L,n,i) do {                       \
-    switch (user_node_type(n)) {                                     \
-        case 'a':                                                    \
-            user_node_value(n) = nodelib_getlist(L, i);              \
-            break;                                                   \
-        case 'd':                                                    \
-            user_node_value(n) = (halfword) lua_roundnumber(L, i);   \
-            break;                                                   \
-        case 'l':                                                    \
-            lua_pushvalue(L, i);                                     \
-            if (user_node_value(n) != 0) {                           \
-                luaL_unref(L, LUA_REGISTRYINDEX,user_node_value(n)); \
-            }                                                        \
-            user_node_value(n) = luaL_ref(L, LUA_REGISTRYINDEX);     \
-            break;                                                   \
-        case 'n':                                                    \
-            user_node_value(n) = nodelib_getlist(L, i);              \
-            break;                                                   \
-        case 's':                                                    \
-            user_node_value(n) = nodelib_getstring(L, i);            \
-            break;                                                   \
-        case 't':                                                    \
-            user_node_value(n) = nodelib_gettoks(L, i);              \
-            break;                                                   \
-        default:                                                     \
-            user_node_value(n) = (halfword) lua_roundnumber(L, i);   \
-            break;                                                   \
-    }                                                                \
-} while (0)
-
-#define get_pdf_literal_direct_value(L,n) do {                  \
-    if (pdf_literal_type(n) == lua_refid_literal) {             \
-        lua_rawgeti(L, LUA_REGISTRYINDEX, pdf_literal_data(n)); \
-    } else if (pdf_literal_type(n) == lua_refid_literal) {      \
-        tokenlist_to_luastring(L, pdf_literal_data(n));         \
-    }                                                           \
-} while (0)
-
-#define set_pdf_literal_direct_normal(L,n,i) do {             \
-    if (ini_version) {                                        \
-        pdf_literal_data(n) = nodelib_gettoks(L, i);          \
-        pdf_literal_type(n) = normal;                         \
-    } else {                                                  \
-        lua_pushvalue(L, i);                                  \
-        pdf_literal_data(n) = luaL_ref(L, LUA_REGISTRYINDEX); \
-        pdf_literal_type(n) = lua_refid_literal;              \
-    }                                                         \
-} while (0)
-
-#define set_pdf_literal_direct_token(L,n,i) do { \
-    pdf_literal_data(n) = nodelib_gettoks(L, i); \
-} while (0)
-
-#define cleanup_late_lua(n) do {                               \
-    if (late_lua_data(n) != 0) {                               \
-        if (late_lua_type(n) == normal) {                      \
-            delete_token_ref(late_lua_data(n));                \
-        } else if (late_lua_type(n) == lua_refid_literal) {    \
-            luaL_unref(L, LUA_REGISTRYINDEX,late_lua_data(n)); \
-        }                                                      \
-    }                                                          \
-} while (0)
-
-#define cleanup_late_lua_name(n) do {       \
-    if (late_lua_name(n) != 0) {            \
-        delete_token_ref(late_lua_name(n)); \
-    }                                       \
-} while (0)
-
-#define set_late_lua_direct_normal(L,n,i) do {             \
-    cleanup_late_lua(n) ;                                  \
-    if (ini_version) {                                     \
-        late_lua_data(n) = nodelib_gettoks(L, i);          \
-        late_lua_type(n) = normal;                         \
-    } else if (lua_type(L, i) == LUA_TNUMBER) {            \
-        late_lua_data(n) = lua_tointeger(L,i);             \
-        late_lua_type(n) = lua_refid_call;                 \
-    } else {                                               \
-        lua_pushvalue(L, i);                               \
-        late_lua_data(n) = luaL_ref(L, LUA_REGISTRYINDEX); \
-        late_lua_type(n) = lua_refid_literal;              \
-    }                                                      \
-} while (0)
-
-#define set_late_lua_direct_token(L,n,i) do { \
-    cleanup_late_lua(n) ;                     \
-    late_lua_data(n) = nodelib_gettoks(L, i); \
-    late_lua_type(n) = normal;                \
-} while (0)
-
-#define get_late_lua_direct_value(L,n) do {                  \
-    if (late_lua_type(n) == lua_refid_literal) {             \
-        lua_rawgeti(L, LUA_REGISTRYINDEX, late_lua_data(n)); \
-    } else if (late_lua_type(n) == lua_refid_call) {         \
-        lua_pushinteger(L, late_lua_data(n));                \
-    } else if (late_lua_type(n) == normal) {                 \
-        tokenlist_to_luastring(L, late_lua_data(n));         \
-    }                                                        \
-} while (0)
-
-#define set_special_direct_value(L,n,i) do { \
-    write_tokens(n) = nodelib_gettoks(L, i); \
-} while (0)
-
-#define get_special_direct_value(L,n) do {     \
-    tokenlist_to_luastring(L, write_tokens(n)); \
-} while (0)
-
-#define set_write_direct_value(L,n,i) do {   \
-    write_tokens(n) = nodelib_gettoks(L, i); \
-} while (0)
-
-#define get_write_direct_value(L,n) do {  \
-    tokenlist_to_lua(L, write_tokens(n)); \
-} while (0)
-
-#define set_pdf_setmatrix_direct_value(L,n,i) do { \
-    pdf_setmatrix_data(n) = nodelib_gettoks(L, i);  \
-} while (0)
-
-#define get_pdf_setmatrix_direct_value(L,n) do {     \
-    tokenlist_to_luastring(L, pdf_setmatrix_data(n)); \
-} while (0)
-
-/*tex
-
-    These getter and setter get |data| as well as |value| fields. One can
-    make them equivalent to |getvalue| and |setvalue| if needed.
-
-*/
-
-static int lua_nodelib_direct_getdata(lua_State * L)
-{
-    halfword n = lua_tointeger(L, 1);
-    if (n == null) {
-        lua_pushnil(L);
-    } else {
-        halfword t = type(n) ;
-        if (t == glyph_node) {
-            lua_pushinteger(L,glyph_node_data(n));
-        } else if (t == boundary_node) {
-            lua_pushinteger(L,boundary_value(n));
-        } else if (t == whatsit_node) {
-            halfword s = subtype(n);
-            if (s == user_defined_node) {
-                get_user_node_direct_value(L, n);
-            } else if (s == pdf_literal_node) {
-                get_pdf_literal_direct_value(L, n);
-                /*tex A bonus. */
-                lua_pushinteger(L,pdf_literal_mode(n));
-                return 2;
-            } else if (s == late_lua_node) {
-                get_late_lua_direct_value(L, n);
-            } else if (s == pdf_setmatrix_node) {
-                get_pdf_setmatrix_direct_value(L, n);
-            } else if (s == special_node) {
-                get_special_direct_value(L, n);
-            } else if (s == write_node) {
-                get_write_direct_value(L, n);
-            } else {
-                lua_pushnil(L);
-            }
-        } else {
-            lua_pushnil(L);
-        }
-    }
-    return 1;
-}
-
-static int lua_nodelib_direct_setdata(lua_State * L) /* data and value */
-{
-    halfword n = lua_tointeger(L, 1);
-    if (n != null) {
-        halfword t = type(n) ;
-        if (t == glyph_node) {
-            glyph_node_data(n) = lua_tointeger(L,2);
-        } else if (t == boundary_node) {
-            boundary_value(n) = lua_tointeger(L,2);
-        } else if (t == whatsit_node) {
-            halfword s = subtype(n);
-            if (s == user_defined_node) {
-                set_user_node_direct_value(L, n, 2);
-            } else if (s == pdf_literal_node) {
-                set_pdf_literal_direct_normal(L, n, 2);
-                if (lua_type(L,2) == LUA_TNUMBER) {
-                    /*tex A bonus. */
-                    pdf_literal_mode(n) = lua_tointeger(L,2);
-                }
-            } else if (s == late_lua_node) {
-                set_late_lua_direct_normal(L, n, 2);
-            } else if (s == pdf_setmatrix_node) {
-                set_pdf_setmatrix_direct_value(L, n, 2);
-            } else if (s == special_node) {
-                set_special_direct_value(L, n, 2);
-            } else if (s == write_node) {
-                set_write_direct_value(L,n,2);
-            }
-        }
-    }
-    return 0;
-}
-
 /* node.direct.getnext */
 /* node.direct.setnext */
 
@@ -1969,13 +1488,11 @@ static int lua_nodelib_type(lua_State *
     if (lua_type(L,1) == LUA_TNUMBER) {
         int i = lua_tointeger(L, 1);
         if (known_node_type(i)) {
-         /* lua_pushstring(L, node_data[i].name); */
-            lua_push_string_by_index(L, node_data[i].lua);
+            lua_pushstring(L, node_data[i].name);
             return 1;
         }
     } else if (maybe_isnode(L, 1) != NULL) {
-     /* lua_pushstring(L,"node"); */
-        lua_push_string_by_name(L,node);
+        lua_pushstring(L,"node");
         return 1;
     }
     lua_pushnil(L);
@@ -1984,9 +1501,10 @@ static int lua_nodelib_type(lua_State *
 
 /* node.new (allocate a new node) */
 
-static halfword lua_nodelib_new_node(lua_State * L)
+static int lua_nodelib_new(lua_State * L)
 {
     int i, j;
+    halfword n = null;
     int t = lua_type(L, 1);
     if (t == LUA_TNUMBER) {
         i = lua_tointeger(L,1);
@@ -2018,26 +1536,33 @@ static halfword lua_nodelib_new_node(lua
         }
     } else if (t == LUA_TNUMBER) {
         j = (int) lua_tointeger(L, 2);
-    } else if (t == LUA_TSTRING) {
-        j = get_node_subtype_id_from_name(L,2,node_data[i].subtypes);
     } else {
         j = 0;
     }
-    return new_node(i, j);
-}
-
-static int lua_nodelib_new(lua_State * L)
-{
-    halfword n = lua_nodelib_new_node(L);
+    n = new_node(i, j);
     lua_nodelib_push_fast(L, n);
     return 1;
 }
 
-/* node.direct.new */
+/* node.direct.new (still with checking) */
 
 static int lua_nodelib_direct_new(lua_State * L)
 {
-    halfword n = lua_nodelib_new_node(L);
+    int j;
+    halfword n ;
+    int i = get_valid_node_type_id(L, 1);
+    if (i == whatsit_node) {
+        j = -1;
+        if (lua_gettop(L) > 1)
+            j = get_valid_node_subtype_id(L, 2);
+        if (j < 0)
+            luaL_error(L, "Creating a whatsit requires the subtype number as a second argument");
+    } else {
+        j = 0;
+        if (lua_gettop(L) > 1)
+            j = (int) lua_tointeger(L, 2);
+    }
+    n = new_node(i, j);
     lua_pushinteger(L,n);
     return 1;
 }
@@ -2179,6 +1704,9 @@ static int lua_nodelib_remove(lua_State
             alink(vlink(current)) = t;
         current = vlink(current);
     }
+#if DEBUG
+    show_node_links(head, "after");
+#endif
     /* can be: lua_nodelib_push_fast(L, head); */
     lua_pushinteger(L, head);
     lua_nodelib_push(L);
@@ -2315,9 +1843,8 @@ static int lua_nodelib_direct_insert_bef
         current = tail_of_list(head);
     if (head != current) {
         halfword t = alink(current);
-        if (t == null || vlink(t) != current) {
+        if (t == null || vlink(t) != current)
             set_t_to_prev(head, current);
-        }
         couple_nodes(t, n);
     }
     couple_nodes(n, current); /*  nice but incompatible: couple_nodes(tail_of_list(n),current) */
@@ -2564,10 +2091,8 @@ static int lua_nodelib_hpack(lua_State *
                 luaL_error(L, "wrong mode in hpack");
             }
             if (lua_gettop(L) > 3) {
-                if (lua_type(L, 4) == LUA_TNUMBER) {
-                    d = nodelib_getdirection(L, 4);
-                } else if (lua_type(L, 4) == LUA_TSTRING) {
-                    d = nodelib_getdir_par(L, 4);
+                if (lua_type(L, 4) == LUA_TSTRING) {
+                    d = nodelib_getdir(L, 4, 1);
                 } else {
                     lua_pushstring(L, "incorrect 4th argument");
                 }
@@ -2613,10 +2138,8 @@ static int lua_nodelib_direct_hpack(lua_
                 lua_pushstring(L, "incorrect 3rd argument");
             }
             if (lua_gettop(L) > 3) {
-                if (lua_type(L, 4) == LUA_TNUMBER) {
-                    d = nodelib_getdirection(L, 4);
-                } else if (lua_type(L, 4) == LUA_TSTRING) {
-                    d = nodelib_getdir_par(L, 4);
+                if (lua_type(L, 4) == LUA_TSTRING) {
+                    d = nodelib_getdir(L, 4, 1);
                 } else {
                     lua_pushstring(L, "incorrect 4th argument");
                 }
@@ -2654,10 +2177,8 @@ static int lua_nodelib_vpack(lua_State *
                 }
 
                 if (lua_gettop(L) > 3) {
-                    if (lua_type(L, 4) == LUA_TNUMBER) {
-                        d = nodelib_getdirection(L, 4);
-                    } else if (lua_type(L, 4) == LUA_TSTRING) {
-                        d = nodelib_getdir_par(L, 4);
+                    if (lua_type(L, 4) == LUA_TSTRING) {
+                        d = nodelib_getdir(L, 4, 1);
                     } else {
                         lua_pushstring(L, "incorrect 4th argument");
                     }
@@ -2701,10 +2222,8 @@ static int lua_nodelib_direct_vpack(lua_
                 }
 
                 if (lua_gettop(L) > 3) {
-                    if (lua_type(L, 4) == LUA_TNUMBER) {
-                        d = nodelib_getdirection(L, 4);
-                    } else if (lua_type(L, 4) == LUA_TSTRING) {
-                        d = nodelib_getdir_par(L, 4);
+                    if (lua_type(L, 4) == LUA_TSTRING) {
+                        d = nodelib_getdir(L, 4, 1);
                     } else {
                         lua_pushstring(L, "incorrect 4th argument");
                     }
@@ -2750,17 +2269,13 @@ static int lua_nodelib_dimensions(lua_St
         n = *(check_isnode(L, i));
         if (lua_gettop(L) > i && !lua_isnil(L, (i + 1))) {
             if (lua_type(L, (i + 1)) == LUA_TSTRING) {
-                d = nodelib_getdir_par(L, (i + 1));
+                d = nodelib_getdir(L, (i + 1), 1);
             } else {
                 p = *(check_isnode(L, (i + 1)));
             }
         }
-        if (lua_gettop(L) > (i + 1)) {
-            if (lua_type(L, (i + 2)) == LUA_TNUMBER) {
-                d = nodelib_getdirection(L, (i + 2));
-            } else if (lua_type(L, (i + 2)) == LUA_TSTRING) {
-                d = nodelib_getdir_par(L, (i + 2));
-            }
+        if (lua_gettop(L) > (i + 1) && lua_type(L, (i + 2)) == LUA_TSTRING) {
+            d = nodelib_getdir(L, (i + 2), 1);
         }
         siz = natural_sizes(n, p, g_mult, g_sign, g_order, d);
         lua_pushinteger(L, siz.wd);
@@ -2807,8 +2322,7 @@ static int lua_nodelib_direct_dimensions
         int g_order = normal;
         int i = 1;
         int d = -1;
-        halfword n = null;
-        halfword p = null;
+        halfword n = null, p = null;
         if (top > 3) {
             i += 3;
             g_mult = (glue_ratio) lua_tonumber(L, 1); /* integer or float */
@@ -2818,18 +2332,13 @@ static int lua_nodelib_direct_dimensions
         n = (halfword) lua_tointeger(L,i);
         if (lua_gettop(L) > i && !lua_isnil(L, (i + 1))) {
             if (lua_type(L, (i + 1)) == LUA_TSTRING) {
-                d = nodelib_getdir_par(L, (i + 1));
+                d = nodelib_getdir(L, (i + 1), 1);
             } else {
                 p = (halfword) lua_tointeger(L,i+1);
             }
         }
-        if (lua_gettop(L) > (i + 1)) {
-            if (lua_type(L, (i + 2)) == LUA_TNUMBER) {
-                d = nodelib_getdirection(L, (i + 2));
-            } else if (lua_type(L, (i + 2)) == LUA_TSTRING) {
-                d = nodelib_getdir_par(L, (i + 2));
-            }
-        }
+        if (lua_gettop(L) > (i + 1) && lua_type(L, (i + 2)) == LUA_TSTRING)
+            d = nodelib_getdir(L, (i + 2), 1);
         siz = natural_sizes(n, p, g_mult, g_sign, g_order, d);
         lua_pushinteger(L, siz.wd);
         lua_pushinteger(L, siz.ht);
@@ -2874,7 +2383,7 @@ static int lua_nodelib_mlist_to_hlist(lu
     luaL_checkany(L, 3);
     m = lua_toboolean(L, 3);
     mlist_to_hlist(n, m, w);
-    alink(vlink(temp_head)) = null;
+    alink(vlink(temp_head)) = null; /*hh-ls */
     lua_nodelib_push_fast(L, vlink(temp_head));
     return 1;
 }
@@ -2898,8 +2407,8 @@ static int lua_nodelib_mfont(lua_State *
     identifiers.  It has to do some more work, because not all
     identifiers are valid for all types of nodes.
 
-    We can make this faster if needed but when this needs to
-    be called often something is wrong with the code.
+    If really needed we can optimize this one using a big if ..
+    .. else like with the getter and setter.
 
 */
 
@@ -2929,19 +2438,16 @@ static int get_node_field_id(lua_State *
         }
     } else {
         int j;
-        field_info *fields ;
+        const char **fields = node_data[t].fields;
         if (t == whatsit_node) {
             fields = whatsit_node_data[subtype(node)].fields;
-        } else {
-            fields = node_data[t].fields;
         }
         if (lua_key_eq(s, list)) {
             s = lua_key(head);
         }
         if (fields != NULL) {
-            for (j = 0; fields[j].lua != 0; j++) {
-             // if (strcmp(s, fields[j]) == 0) {
-                if (fields[j].name == s) {
+            for (j = 0; fields[j] != NULL; j++) {
+                if (strcmp(s, fields[j]) == 0) {
                     return j + 3;
                 }
             }
@@ -3043,7 +2549,7 @@ static int lua_nodelib_fields(lua_State
 {
     int i = -1;
     int offset = 2;
-    field_info *fields;
+    const char **fields;
     int t = get_valid_node_type_id(L, 1);
     if (t == whatsit_node) {
         t = get_valid_node_subtype_id(L, 2);
@@ -3067,63 +2573,26 @@ static int lua_nodelib_fields(lua_State
         lua_rawseti(L, -2, -1);
     }
     if (fields != NULL) {
-        for (i = 0; fields[i].lua != 0; i++) {
-         // lua_pushstring(L, fields[i]); /* todo */
-            lua_rawgeti(L, LUA_REGISTRYINDEX, fields[i].lua);
+        for (i = 0; fields[i] != NULL; i++) {
+            lua_pushstring(L, fields[i]); /* todo */
             lua_rawseti(L, -2, (i + offset));
         }
     }
     return 1;
 }
 
-static int lua_nodelib_values(lua_State * L)
-{
-    int i = -1;
-    subtype_info *values = NULL;
-    const char *s ;
-    int t = lua_type(L,1);
-    if (t == LUA_TSTRING) {
-        /*
-            delimiter options (bit set)
-            delimiter modes   (bit set)
-        */
-        s = lua_tostring(L,1);
-             if (lua_key_eq(s,dir))         values = node_values_dir;
-        else if (lua_key_eq(s,direction))   values = node_values_dir;
-        else if (lua_key_eq(s,glue))        values = node_values_fill;
-        /* backend */
-        else if (lua_key_eq(s,pdf_literal)) values = node_values_pdf_literal;
-        else if (lua_key_eq(s,pdf_action))  values = node_values_pdf_action;
-        else if (lua_key_eq(s,pdf_window))  values = node_values_pdf_window;
-        else if (lua_key_eq(s,color_stack)) values = node_values_color_stack;
-        /* extras */
-        else if (lua_key_eq(s,pagestate))   values = other_values_page_states;
-    }
-    if (values != NULL) {
-        lua_checkstack(L, 2);
-        lua_newtable(L);
-        for (i = 0; values[i].id >= 0 ; i++) {
-            lua_rawgeti(L, LUA_REGISTRYINDEX, values[i].lua);
-            lua_rawseti(L, -2, values[i].id);
-        }
-    } else {
-        lua_pushnil(L);
-    }
-    return 1;
-}
-
 static int lua_nodelib_subtypes(lua_State * L)
 {
     int i = -1;
-    subtype_info *subtypes = NULL;
+    int l = 0;
+    const char **subtypes = NULL;
     const char *s ;
     int t = lua_type(L,1);
     if (t == LUA_TSTRING) {
         /* official accessors */
         s = lua_tostring(L,1);
              if (lua_key_eq(s,glyph))           subtypes = node_subtypes_glyph;
-        else if (lua_key_eq(s,glue))            subtypes = node_subtypes_glue;
-        else if (lua_key_eq(s,dir))             subtypes = node_subtypes_dir;
+        else if (lua_key_eq(s,glue))          { subtypes = node_subtypes_glue; l = 1; }
         else if (lua_key_eq(s,boundary))        subtypes = node_subtypes_boundary;
         else if (lua_key_eq(s,penalty))         subtypes = node_subtypes_penalty;
         else if (lua_key_eq(s,kern))            subtypes = node_subtypes_kern;
@@ -3133,8 +2602,8 @@ static int lua_nodelib_subtypes(lua_Stat
              ||  lua_key_eq(s,vlist))           subtypes = node_subtypes_list; /* too many but ok as reserved */
         else if (lua_key_eq(s,adjust))          subtypes = node_subtypes_adjust;
         else if (lua_key_eq(s,disc))            subtypes = node_subtypes_disc;
-        else if (lua_key_eq(s,fill))            subtypes = node_values_fill;
-        else if (lua_key_eq(s,leader))          subtypes = node_subtypes_leader;
+        else if (lua_key_eq(s,fill))            subtypes = node_subtypes_fill;
+        else if (lua_key_eq(s,leader))        { subtypes = node_subtypes_leader; l = 2; }
         else if (lua_key_eq(s,marginkern))      subtypes = node_subtypes_marginkern;
         else if (lua_key_eq(s,math))            subtypes = node_subtypes_math;
         else if (lua_key_eq(s,noad))            subtypes = node_subtypes_noad;
@@ -3142,14 +2611,13 @@ static int lua_nodelib_subtypes(lua_Stat
         else if (lua_key_eq(s,accent))          subtypes = node_subtypes_accent;
         else if (lua_key_eq(s,fence))           subtypes = node_subtypes_fence;
         /* backend */
-        else if (lua_key_eq(s,pdf_destination)) subtypes = node_values_pdf_destination;
-        else if (lua_key_eq(s,pdf_literal))     subtypes = node_values_pdf_literal;
+        else if (lua_key_eq(s,pdf_destination)) subtypes = node_subtypes_pdf_destination;
+        else if (lua_key_eq(s,pdf_literal))     subtypes = node_subtypes_pdf_literal;
     } else if (t == LUA_TNUMBER) {
         /* maybe */
         t = lua_tointeger(L,1);
              if (t == glyph_node)               subtypes = node_subtypes_glyph;
-        else if (t == glue_node)                subtypes = node_subtypes_glue;
-        else if (t == dir_node)                 subtypes = node_subtypes_dir;
+        else if (t == glue_node)              { subtypes = node_subtypes_glue; l = 1; }
         else if (t == boundary_node)            subtypes = node_subtypes_boundary;
         else if (t == penalty_node)             subtypes = node_subtypes_penalty;
         else if (t == kern_node)                subtypes = node_subtypes_kern;
@@ -3158,7 +2626,7 @@ static int lua_nodelib_subtypes(lua_Stat
              || (t == vlist_node))              subtypes = node_subtypes_list;
         else if (t == adjust_node)              subtypes = node_subtypes_adjust;
         else if (t == disc_node)                subtypes = node_subtypes_disc;
-        else if (t == glue_spec_node)           subtypes = node_values_fill;
+        else if (t == glue_spec_node)           subtypes = node_subtypes_fill;
         else if (t == margin_kern_node)         subtypes = node_subtypes_marginkern;
         else if (t == math_node)                subtypes = node_subtypes_math;
         else if (t == simple_noad)              subtypes = node_subtypes_noad;
@@ -3166,15 +2634,29 @@ static int lua_nodelib_subtypes(lua_Stat
         else if (t == accent_noad)              subtypes = node_subtypes_accent;
         else if (t == fence_noad)               subtypes = node_subtypes_fence;
         /* backend */
-        else if (t == pdf_dest_node)            subtypes = node_values_pdf_destination;
-        else if (t == pdf_literal_node)         subtypes = node_values_pdf_literal;
+        else if (t == pdf_dest_node)            subtypes = node_subtypes_pdf_destination;
+        else if (t == pdf_literal_node)         subtypes = node_subtypes_pdf_literal;
     }
     if (subtypes != NULL) {
         lua_checkstack(L, 2);
         lua_newtable(L);
-        for (i = 0; subtypes[i].id >= 0 ; i++) {
-            lua_rawgeti(L, LUA_REGISTRYINDEX, subtypes[i].lua);
-            lua_rawseti(L, -2, subtypes[i].id);
+        if (l < 2) {
+            for (i = 0; subtypes[i] != NULL; i++) {
+                lua_pushstring(L, subtypes[i]); /* todo */
+                lua_rawseti(L, -2, i);
+            }
+        }
+        if (l > 0) {
+            /* add math states */
+            for (i = 0; node_subtypes_mathglue[i] != NULL; i++) {
+                lua_pushstring(L, node_subtypes_mathglue[i]); /* todo */
+                lua_rawseti(L, -2, 98 + i);
+            }
+            /* add leaders */
+            for (i = 0; node_subtypes_leader[i] != NULL; i++) {
+                lua_pushstring(L, node_subtypes_leader[i]); /* todo */
+                lua_rawseti(L, -2, 100 + i);
+            }
         }
     } else {
         lua_pushnil(L);
@@ -3341,10 +2823,7 @@ static int lua_nodelib_get_attribute(lua
         if (p != null) {
             p = vlink(p);
             if (p != null) {
-                int i = 0;
-                if (lua_gettop(L) > 1) {
-                    i = lua_tointeger(L, 2);
-                }
+                int i = lua_tointeger(L, 2);
                 while (p != null) {
                     if (attribute_id(p) == i) {
                         int ret = attribute_value(p);
@@ -3416,10 +2895,7 @@ static int lua_nodelib_direct_get_attrib
         if (p != null) {
             p = vlink(p);
             if (p != null) {
-                int i = 0;
-                if (lua_gettop(L) > 1) {
-                    i = lua_tointeger(L, 2);
-                }
+                int i = lua_tointeger(L, 2);
                 while (p != null) {
                     if (attribute_id(p) == i) {
                         int ret = attribute_value(p);
@@ -3573,24 +3049,10 @@ static int lua_nodelib_direct_getwidth(l
         if (t == hlist_node || t == vlist_node || t == rule_node) {
             lua_pushinteger(L,width(n));
         } else if (t == glyph_node) {
-            if (lua_toboolean(L,2)) {
-                lua_pushnumber(L, (1+ex_glyph(n)/1000) * char_width(font(n),character(n)));
-                lua_pushinteger(L, ex_glyph(n));
-                return 2;
-            } else {
-                lua_pushinteger(L, char_width(font(n),character(n)));
-            }
+            lua_pushinteger(L, char_width(font(n),character(n)));
         } else if (t == glue_node || t == glue_spec_node || t == math_node || t == ins_node) {
             lua_pushinteger(L,width(n));
-        } else if (t == kern_node) {
-            if (lua_toboolean(L,2)) {
-                lua_pushnumber(L, (1+ex_kern(n)/1000) * width(n));
-                lua_pushinteger(L, ex_kern(n));
-                return 2;
-            } else {
-                lua_pushinteger(L, width(n));
-            }
-        } else if (t == margin_kern_node) {
+        } else if (t == kern_node || t == margin_kern_node) {
             lua_pushinteger(L,width(n));
         } else if (t == unset_node) {
             lua_pushinteger(L,width(n));
@@ -3609,8 +3071,7 @@ static int lua_nodelib_direct_setwidth(l
     if (n) {
         halfword t = type(n);
         if (t == hlist_node || t == vlist_node || t == rule_node || t == glue_node || t == glue_spec_node || t == math_node ||
-                t == kern_node || t == margin_kern_node ||  t == ins_node || t == unset_node ||
-                t == fraction_noad || t == radical_noad ) {
+                t == kern_node || t == margin_kern_node ||  t == ins_node || t == unset_node) {
             if (lua_type(L, 2) == LUA_TNUMBER) {
                 width(n) = lua_roundnumber(L,2);
             } else {
@@ -3632,8 +3093,6 @@ static int lua_nodelib_direct_getheight(
             lua_pushinteger(L, char_height(font(n),character(n)));
         } else if (t == unset_node || t == ins_node) {
             lua_pushinteger(L,height(n));
-        } else if (t == fence_noad) {
-            lua_pushinteger(L,delimiterheight(n));
         } else {
             lua_pushnil(L);
         }
@@ -3648,14 +3107,12 @@ static int lua_nodelib_direct_setheight(
     halfword n = lua_tointeger(L, 1);
     if (n) {
         halfword t = type(n);
-        halfword h = 0;
-        if (lua_type(L, 2) == LUA_TNUMBER) {
-            h = lua_roundnumber(L,2);
-        }
         if (t == hlist_node || t == vlist_node || t == rule_node || t == unset_node) {
-            height(n) = h;
-        } else if (t == fence_noad) {
-            delimiterheight(n) = h;
+            if (lua_type(L, 2) == LUA_TNUMBER) {
+                height(n) = lua_roundnumber(L,2);
+            } else {
+                height(n) = 0;
+            }
         }
     }
     return 0;
@@ -3672,8 +3129,6 @@ static int lua_nodelib_direct_getdepth(l
             lua_pushinteger(L, char_depth(font(n),character(n)));
         } else if (t == unset_node || t == ins_node) {
             lua_pushinteger(L,depth(n));
-        } else if (t == fence_noad) {
-            lua_pushinteger(L,delimiterdepth(n));
         } else {
             lua_pushnil(L);
         }
@@ -3688,14 +3143,12 @@ static int lua_nodelib_direct_setdepth(l
     halfword n = lua_tointeger(L, 1);
     if (n) {
         halfword t = type(n);
-        halfword d = 0;
-        if (lua_type(L, 2) == LUA_TNUMBER) {
-            d = lua_roundnumber(L,2);
-        }
         if (t == hlist_node || t == vlist_node || t == rule_node || t == unset_node) {
-            depth(n) = d;
-        } else if (t == fence_noad) {
-            delimiterdepth(n) = d;
+            if (lua_type(L, 2) == LUA_TNUMBER) {
+                depth(n) = lua_roundnumber(L,2);
+            } else {
+                depth(n) = 0;
+            }
         }
     }
     return 0;
@@ -3871,51 +3324,9 @@ static int nodelib_aux_nil(lua_State * L
     return 1;
 }
 
-/* node.direct.traverse */
 /* node.direct.traverse_id */
+/* node.direct.traverse */
 /* node.direct.traverse_char */
-/* node.direct.traverse_glyph */
-/* node.direct.traverse_list */
-
-static int nodelib_direct_aux_next(lua_State * L)
-{
-    halfword t;
-    if (lua_isnil(L, 2)) {
-        t = lua_tointeger(L,1) ;
-        lua_settop(L,1);
-    } else {
-        t = lua_tointeger(L,2) ;
-        t = vlink(t);
-        lua_settop(L,2);
-    }
-    if (t == null) {
-        lua_pushnil(L);
-        return 1;
-    } else {
-        lua_pushinteger(L,t);
-        lua_pushinteger(L,type(t));
-        lua_pushinteger(L,subtype(t));
-        return 3;
-    }
-}
-
-static int lua_nodelib_direct_traverse(lua_State * L)
-{
-    halfword n;
-    if (lua_isnil(L, 1)) {
-        lua_pushcclosure(L, nodelib_aux_nil, 0);
-        return 1;
-    }
-    n = (halfword) lua_tointeger(L, 1);
-    if (n == null) {
-        lua_pushcclosure(L, nodelib_aux_nil, 0);
-        return 1;
-    }
-    lua_pushcclosure(L, nodelib_direct_aux_next, 0);
-    lua_pushinteger(L,n);
-    lua_pushnil(L);
-    return 3;
-}
 
 static int nodelib_direct_aux_next_filtered(lua_State * L)
 {
@@ -3929,17 +3340,18 @@ static int nodelib_direct_aux_next_filte
         t = vlink(t);
         lua_settop(L,2);
     }
-    while (t != null && type(t) != i) {
-        t = vlink(t);
-    }
-    if (t == null) {
-        lua_pushnil(L);
-        return 1;
-    } else {
-        lua_pushinteger(L,t);
-        lua_pushinteger(L,subtype(t));
-        return 2;
+    while (1) {
+        if (t == null) {
+            break;
+        } else if (type(t) == i) {
+            lua_pushinteger(L,t);
+            return 1;
+        } else {
+            t = vlink(t);
+        }
     }
+    lua_pushnil(L);
+    return 1;
 }
 
 static int lua_nodelib_direct_traverse_filtered(lua_State * L)
@@ -3959,7 +3371,7 @@ static int lua_nodelib_direct_traverse_f
     return 3;
 }
 
-static int nodelib_direct_aux_next_char(lua_State * L)
+static int nodelib_direct_aux_next(lua_State * L)
 {
     halfword t;            /* traverser */
     if (lua_isnil(L, 2)) { /* first call */
@@ -3970,21 +3382,15 @@ static int nodelib_direct_aux_next_char(
         t = vlink(t);
         lua_settop(L,2);
     }
-    while (! ((t == null) || (type(t) == glyph_node && subtype(t) < 256))) {
-        t = vlink(t);
-    }
     if (t == null) {
         lua_pushnil(L);
-        return 1;
     } else {
         lua_pushinteger(L,t);
-        lua_pushinteger(L,character(t));
-        lua_pushinteger(L,font(t));
-        return 3;
     }
+    return 1;
 }
 
-static int lua_nodelib_direct_traverse_char(lua_State * L)
+static int lua_nodelib_direct_traverse(lua_State * L)
 {
     halfword n;
     if (lua_isnil(L, 1)) {
@@ -3996,13 +3402,13 @@ static int lua_nodelib_direct_traverse_c
         lua_pushcclosure(L, nodelib_aux_nil, 0);
         return 1;
     }
-    lua_pushcclosure(L, nodelib_direct_aux_next_char, 0);
+    lua_pushcclosure(L, nodelib_direct_aux_next, 0);
     lua_pushinteger(L,n);
     lua_pushnil(L);
     return 3;
 }
 
-static int nodelib_direct_aux_next_glyph(lua_State * L)
+static int nodelib_direct_aux_next_char(lua_State * L)
 {
     halfword t;            /* traverser */
     if (lua_isnil(L, 2)) { /* first call */
@@ -4013,65 +3419,21 @@ static int nodelib_direct_aux_next_glyph
         t = vlink(t);
         lua_settop(L,2);
     }
-    while (t != null && type(t) != glyph_node) {
-        t = vlink(t);
-    }
-    if (t == null) {
-        lua_pushnil(L);
-        return 1;
-    } else {
-        lua_pushinteger(L,t);
-        lua_pushinteger(L,character(t));
-        lua_pushinteger(L,font(t));
-        return 3;
-    }
-}
-
-static int lua_nodelib_direct_traverse_glyph(lua_State * L)
-{
-    halfword n;
-    if (lua_isnil(L, 1)) {
-        lua_pushcclosure(L, nodelib_aux_nil, 0);
-        return 1;
-    }
-    n = (halfword) lua_tointeger(L, 1);
-    if (n == null) {
-        lua_pushcclosure(L, nodelib_aux_nil, 0);
-        return 1;
+    while (1) {
+        if (t == null) {
+            break;
+        } else if ((type(t) == glyph_node) && (subtype(t) < 256)){
+            lua_pushinteger(L,t);
+            return 1;
+        } else {
+            t = vlink(t);
+        }
     }
-    lua_pushcclosure(L, nodelib_direct_aux_next_glyph, 0);
-    lua_pushinteger(L,n);
     lua_pushnil(L);
-    return 3;
-}
-
-static int nodelib_direct_aux_next_list(lua_State * L)
-{
-    halfword t;        /* traverser */
-    if (lua_isnil(L, 2)) {      /* first call */
-        t = lua_tointeger(L,1) ;
-        lua_settop(L,1);
-    } else {
-        t = lua_tointeger(L,2) ;
-        t = vlink(t);
-        lua_settop(L,2);
-    }
-    while (t != null && type(t) != hlist_node && type(t) != vlist_node) {
-        t = vlink(t);
-    }
-    if (t == null) {
-        lua_pushnil(L);
-        return 1;
-    } else {
-        lua_pushinteger(L,t);
-        lua_pushinteger(L,type(t));
-        lua_pushinteger(L,subtype(t));
-        nodelib_pushdirect_or_nil(list_ptr(t));
-        return 4;
-    }
+    return 1;
 }
 
-static int lua_nodelib_direct_traverse_list(lua_State * L)
+static int lua_nodelib_direct_traverse_char(lua_State * L)
 {
     halfword n;
     if (lua_isnil(L, 1)) {
@@ -4083,54 +3445,15 @@ static int lua_nodelib_direct_traverse_l
         lua_pushcclosure(L, nodelib_aux_nil, 0);
         return 1;
     }
-    lua_pushcclosure(L, nodelib_direct_aux_next_list, 1);
-    lua_pushinteger(L, n);
+    lua_pushcclosure(L, nodelib_direct_aux_next_char, 0);
+    lua_pushinteger(L,n);
     lua_pushnil(L);
     return 3;
 }
 
-/* node.traverse */
 /* node.traverse_id */
+/* node.traverse */
 /* node.traverse_char */
-/* node.traverse_glyph */
-/* node.traverse_list */
-
-static int nodelib_aux_next(lua_State * L)
-{
-    halfword t;
-    halfword *a;
-    if (lua_isnil(L, 2)) {
-        t = *check_isnode(L, 1);
-        lua_settop(L,1);
-    } else {
-        t = *check_isnode(L, 2);
-        t = vlink(t);
-        lua_settop(L,2);
-    }
-    if (t == null) {
-        lua_pushnil(L);
-        return 1;
-    } else {
-        fast_metatable_top(t);
-        lua_pushinteger(L,type(t));
-        lua_pushinteger(L,subtype(t));
-        return 3;
-    }
-}
-
-static int lua_nodelib_traverse(lua_State * L)
-{
-    halfword n;
-    if (lua_isnil(L, 1)) {
-        lua_pushcclosure(L, nodelib_aux_nil, 0);
-        return 1;
-    }
-    n = *check_isnode(L, 1);
-    lua_pushcclosure(L, nodelib_aux_next, 0);
-    lua_nodelib_push_fast(L, n);
-    lua_pushnil(L);
-    return 3;
-}
 
 static int nodelib_aux_next_filtered(lua_State * L)
 {
@@ -4150,12 +3473,10 @@ static int nodelib_aux_next_filtered(lua
     }
     if (t == null) {
         lua_pushnil(L);
-        return 1;
     } else {
         fast_metatable_top(t);
-        lua_pushinteger(L,subtype(t));
-        return 2;
     }
+    return 1;
 }
 
 static int lua_nodelib_traverse_filtered(lua_State * L)
@@ -4173,10 +3494,10 @@ static int lua_nodelib_traverse_filtered
     return 3;
 }
 
-static int nodelib_aux_next_char(lua_State * L)
+static int nodelib_aux_next(lua_State * L)
 {
     halfword t;            /* traverser */
-    halfword *a;
+    halfword *a;           /* a or *a */
     if (lua_isnil(L, 2)) { /* first call */
         t = *check_isnode(L, 1);
         lua_settop(L,1);
@@ -4185,21 +3506,15 @@ static int nodelib_aux_next_char(lua_Sta
         t = vlink(t);
         lua_settop(L,2);
     }
-    while (! ((t == null) || (type(t) == glyph_node && subtype(t) < 256))) {
-        t = vlink(t);
-    }
     if (t == null) {
         lua_pushnil(L);
-        return 1;
     } else {
         fast_metatable_top(t);
-        lua_pushinteger(L,character(t));
-        lua_pushinteger(L,font(t));
-        return 3;
     }
+    return 1;
 }
 
-static int lua_nodelib_traverse_char(lua_State * L)
+static int lua_nodelib_traverse(lua_State * L)
 {
     halfword n;
     if (lua_isnil(L, 1)) {
@@ -4207,13 +3522,13 @@ static int lua_nodelib_traverse_char(lua
         return 1;
     }
     n = *check_isnode(L, 1);
-    lua_pushcclosure(L, nodelib_aux_next_char, 0);
+    lua_pushcclosure(L, nodelib_aux_next, 0);
     lua_nodelib_push_fast(L, n);
     lua_pushnil(L);
     return 3;
 }
 
-static int nodelib_aux_next_glyph(lua_State * L)
+static int nodelib_aux_next_char(lua_State * L)
 {
     halfword t;            /* traverser */
     halfword *a;
@@ -4225,62 +3540,20 @@ static int nodelib_aux_next_glyph(lua_St
         t = vlink(t);
         lua_settop(L,2);
     }
-    while (t != null && type(t) != glyph_node) {
-        t = vlink(t);
-    }
-    if (t == null) {
-        lua_pushnil(L);
-        return 1;
-    } else {
-        fast_metatable_top(t);
-        lua_pushinteger(L,character(t));
-        lua_pushinteger(L,font(t));
-        return 3;
-    }
-}
-
-static int lua_nodelib_traverse_glyph(lua_State * L)
-{
-    halfword n;
-    if (lua_isnil(L, 1)) {
-        lua_pushcclosure(L, nodelib_aux_nil, 0);
-        return 1;
-    }
-    n = *check_isnode(L, 1);
-    lua_pushcclosure(L, nodelib_aux_next_glyph, 0);
-    lua_nodelib_push_fast(L, n);
-    lua_pushnil(L);
-    return 3;
-}
-
-static int nodelib_aux_next_list(lua_State * L)
-{
-    halfword t;        /* traverser */
-    halfword *a;
-    if (lua_isnil(L, 2)) {      /* first call */
-        t = *check_isnode(L, 1);
-        lua_settop(L,1);
-    } else {
-        t = *check_isnode(L, 2);
-        t = vlink(t);
-        lua_settop(L,2);
-    }
-    while (t != null && type(t) != hlist_node && type(t) != vlist_node) {
-        t = vlink(t);
-    }
-    if (t == null) {
-        lua_pushnil(L);
-        return 1;
-    } else {
-        fast_metatable_top(t);
-        lua_pushinteger(L,type(t));
-        lua_pushinteger(L,subtype(t));
-        fast_metatable_or_nil(list_ptr(t));
-        return 4;
+    while (1) {
+        if (t == null) {
+            break;
+        } else if ((type(t) == glyph_node) && (subtype(t) < 256)){
+            fast_metatable_top(t);
+            return 1;
+        } else {
+            t = vlink(t);
+        }
     }
+    return 1;
 }
 
-static int lua_nodelib_traverse_list(lua_State * L)
+static int lua_nodelib_traverse_char(lua_State * L)
 {
     halfword n;
     if (lua_isnil(L, 1)) {
@@ -4288,7 +3561,7 @@ static int lua_nodelib_traverse_list(lua
         return 1;
     }
     n = *check_isnode(L, 1);
-    lua_pushcclosure(L, nodelib_aux_next_list, 1);
+    lua_pushcclosure(L, nodelib_aux_next_char, 0);
     lua_nodelib_push_fast(L, n);
     lua_pushnil(L);
     return 3;
@@ -4365,6 +3638,46 @@ static int lua_nodelib_count(lua_State *
     return do_lua_nodelib_count(L, m, i, n);
 }
 
+/* getting and setting fields (helpers) */
+
+int nodelib_getlist(lua_State * L, int n)
+{
+    if (lua_isuserdata(L, n)) {
+        halfword m = *check_isnode(L, n);
+        return m;
+    } else {
+        return null;
+    }
+}
+
+int nodelib_getdir(lua_State * L, int n, int absolute_only)
+{
+    if (lua_type(L, n) == LUA_TSTRING) {
+        const char *s = lua_tostring(L, n);
+        RETURN_DIR_VALUES(TLT);
+        RETURN_DIR_VALUES(TRT);
+        RETURN_DIR_VALUES(LTL);
+        RETURN_DIR_VALUES(RTT);
+        luaL_error(L, "Bad direction specifier %s", s);
+    } else {
+        luaL_error(L, "Direction specifiers have to be strings");
+    }
+    return 0;
+}
+
+static str_number nodelib_getstring(lua_State * L, int a)
+{
+    size_t k;
+    const char *s = lua_tolstring(L, a, &k);
+    return maketexlstring(s, k);
+}
+
+static int nodelib_cantset(lua_State * L, int n, const char *s)
+{
+    luaL_error(L,"You cannot set field %s in a node of type %s",s,node_data[type(n)].name);
+    return 0;
+}
+
 /* node.direct.getfield */
 
 static void lua_nodelib_getfield_whatsit(lua_State * L, int n, const char *s)
@@ -4377,48 +3690,54 @@ static void lua_nodelib_getfield_whatsit
             lua_pushinteger(L, user_node_type(n));
         } else if (lua_key_eq(s, value)) {
             switch (user_node_type(n)) {
-                case 'a':
-                    nodelib_pushlist(L, user_node_value(n));
-                    break;
-                case 'd':
-                    lua_pushinteger(L, user_node_value(n));
-                    break;
-                case 'l':
-                    if (user_node_value(n) != 0) {
-                        lua_rawgeti(L, LUA_REGISTRYINDEX, user_node_value(n));
-                    } else {
-                        lua_pushnil(L);
-                    }
-                    break;
-                case 'n':
-                    nodelib_pushlist(L, user_node_value(n));
-                    break;
-                case 's':
-                    nodelib_pushstring(L, user_node_value(n));
-                    break;
-                case 't':
-                    tokenlist_to_lua(L, user_node_value(n));
-                    break;
-                default:
-                    lua_pushinteger(L, user_node_value(n));
-                    break;
+            case 'a':
+                nodelib_pushlist(L, user_node_value(n));
+                break;
+            case 'd':
+                lua_pushinteger(L, user_node_value(n));
+                break;
+            case 'l':
+                if (user_node_value(n) != 0) {
+                    lua_rawgeti(L, LUA_REGISTRYINDEX, user_node_value(n));
+                } else {
+                    lua_pushnil(L);
+                }
+                break;
+            case 'n':
+                nodelib_pushlist(L, user_node_value(n));
+                break;
+            case 's':
+                nodelib_pushstring(L, user_node_value(n));
+                break;
+            case 't':
+                tokenlist_to_lua(L, user_node_value(n));
+                break;
+            default:
+                lua_pushinteger(L, user_node_value(n));
+                break;
             }
         } else {
             lua_pushnil(L);
         }
     } else if (t == pdf_literal_node) {
-        /*tex The |string| key is obsolete. */
         if (lua_key_eq(s, mode)) {
             lua_pushinteger(L, pdf_literal_mode(n));
-        } else if (lua_key_eq(s, data) || lua_key_eq(s, token) || lua_key_eq(s, string)) {
-            get_pdf_literal_direct_value(L, n);
+        } else if (lua_key_eq(s, data)) {
+            if (pdf_literal_type(n) == lua_refid_literal) {
+                lua_rawgeti(L, LUA_REGISTRYINDEX, pdf_literal_data(n));
+            } else {
+                tokenlist_to_luastring(L, pdf_literal_data(n));
+            }
         } else {
             lua_pushnil(L);
         }
     } else if (t == late_lua_node) {
-        /*tex The |string| key is obsolete. */
-        if (lua_key_eq(s, data) || lua_key_eq(s, token) || lua_key_eq(s, string)) {
-            get_late_lua_direct_value(L,n);
+        if (lua_key_eq(s, string) || lua_key_eq(s, data)) {
+            if (late_lua_type(n) == lua_refid_literal) {
+                lua_rawgeti(L, LUA_REGISTRYINDEX, late_lua_data(n));
+            } else {
+                tokenlist_to_luastring(L, late_lua_data(n));
+            }
         } else if (lua_key_eq(s, name)) {
             tokenlist_to_luastring(L, late_lua_name(n));
         } else {
@@ -4463,7 +3782,7 @@ static void lua_nodelib_getfield_whatsit
         }
     } else if (t == pdf_setmatrix_node) {
         if (lua_key_eq(s, data)) {
-            get_pdf_setmatrix_direct_value(L,n);
+            tokenlist_to_luastring(L, pdf_setmatrix_data(n));
         } else {
             lua_pushnil(L);
         }
@@ -4487,13 +3806,13 @@ static void lua_nodelib_getfield_whatsit
         if (lua_key_eq(s, stream)) {
             lua_pushinteger(L, write_stream(n));
         } else if (lua_key_eq(s, data)) {
-            get_write_direct_value(L,n);
+            tokenlist_to_lua(L, write_tokens(n));
         } else {
             lua_pushnil(L);
         }
     } else if (t == special_node) {
         if (lua_key_eq(s, data)) {
-            get_special_direct_value(L,n);
+            tokenlist_to_luastring(L, write_tokens(n));
         } else {
             lua_pushnil(L);
         }
@@ -4659,8 +3978,8 @@ static int lua_nodelib_fast_getfield(lua
             lua_pushinteger(L, x_displace(n));
         } else if (lua_key_eq(s, yoffset)) {
             lua_pushinteger(L, y_displace(n));
-        } else if (lua_key_eq(s, data)) {
-            lua_pushinteger(L, glyph_node_data(n));
+        } else if (lua_key_eq(s, xadvance)) {
+            lua_pushinteger(L, x_advance(n));
         } else if (lua_key_eq(s, width)) {
             lua_pushinteger(L, char_width(font(n),character(n)));
         } else if (lua_key_eq(s, height)) {
@@ -4694,8 +4013,6 @@ static int lua_nodelib_fast_getfield(lua
             lua_pushinteger(L, height(n));
         } else if (lua_key_eq(s, depth)) {
             lua_pushinteger(L, depth(n));
-        } else if (lua_key_eq(s, direction)) {
-            lua_pushinteger(L, box_dir(n));
         } else if (lua_key_eq(s, dir)) {
             lua_push_dir_par(L, box_dir(n));
         } else if (lua_key_eq(s, shift)) {
@@ -4769,12 +4086,6 @@ static int lua_nodelib_fast_getfield(lua
             lua_pushinteger(L, height(n));
         } else if (lua_key_eq(s, depth)) {
             lua_pushinteger(L, depth(n));
-        } else if (lua_key_eq(s, left)) {
-            lua_pushinteger(L,rule_left(n));
-        } else if (lua_key_eq(s, right)) {
-            lua_pushinteger(L,rule_right(n));
-        } else if (lua_key_eq(s, direction)) {
-            lua_pushinteger(L, rule_dir(n));
         } else if (lua_key_eq(s, dir)) {
             lua_push_dir_par(L, rule_dir(n));
         } else if (lua_key_eq(s, index)) {
@@ -4785,10 +4096,8 @@ static int lua_nodelib_fast_getfield(lua
             lua_pushnil(L);
         }
     } else if (t == dir_node) {
-        if (lua_key_eq(s, direction)) {
-            lua_pushinteger(L, dir_dir(n));
-        } else if (lua_key_eq(s, dir)) {
-            lua_push_dir_text(L, dir_dir(n),subtype(n));
+        if (lua_key_eq(s, dir)) {
+            lua_push_dir_text(L, dir_dir(n));
         } else if (lua_key_eq(s, level)) {
             lua_pushinteger(L, dir_level(n));
         } else if (lua_key_eq(s, subtype)) { /* can be used for anything */
@@ -4801,8 +4110,6 @@ static int lua_nodelib_fast_getfield(lua
             lua_pushinteger(L, local_pen_inter(n));
         } else if (lua_key_eq(s, pen_broken)) {
             lua_pushinteger(L, local_pen_broken(n));
-        } else if (lua_key_eq(s, direction)) {
-            lua_pushinteger(L, local_par_dir(n));
         } else if (lua_key_eq(s, dir)) {
             lua_push_dir_par(L, local_par_dir(n));
         } else if (lua_key_eq(s, box_left)) {
@@ -4934,8 +4241,6 @@ static int lua_nodelib_fast_getfield(lua
             fast_metatable_or_nil(right_delimiter(n));
         } else if (lua_key_eq(s, middle)) {
             fast_metatable_or_nil(middle_delimiter(n));
-        } else if (lua_key_eq(s, fam)) {
-            lua_pushinteger(L, fraction_fam(n));
         } else if (lua_key_eq(s, options)) {
             lua_pushinteger(L, fractionoptions(n));
         } else {
@@ -5104,8 +4409,6 @@ static int lua_nodelib_fast_getfield(lua
             lua_pushinteger(L, height(n));
         } else if (lua_key_eq(s, depth)) {
             lua_pushinteger(L, depth(n));
-        } else if (lua_key_eq(s, direction)) {
-            lua_pushinteger(L, box_dir(n));
         } else if (lua_key_eq(s, dir)) {
             lua_push_dir_par(L, box_dir(n));
         } else if (lua_key_eq(s, shrink)) {
@@ -5174,23 +4477,55 @@ static void lua_nodelib_direct_getfield_
         } else if (lua_key_eq(s, type)) {
             lua_pushinteger(L, user_node_type(n));
         } else if (lua_key_eq(s, value)) {
-            get_user_node_direct_value(L, n);
+            switch (user_node_type(n)) {
+            case 'a':
+                nodelib_pushdirect(user_node_value(n));
+                break;
+            case 'd':
+                lua_pushinteger(L, user_node_value(n));
+                break;
+            case 'l':
+                if (user_node_value(n) != 0) {
+                    lua_rawgeti(L, LUA_REGISTRYINDEX, user_node_value(n));
+                } else {
+                    lua_pushnil(L);
+                }
+                break;
+            case 'n':
+                nodelib_pushdirect(user_node_value(n));
+                break;
+            case 's':
+                nodelib_pushstring(L, user_node_value(n));
+                break;
+            case 't':
+                tokenlist_to_lua(L, user_node_value(n));
+                break;
+            default:
+                lua_pushinteger(L, user_node_value(n));
+                break;
+            }
         } else {
             lua_pushnil(L);
         }
     } else if (t == pdf_literal_node) {
-        /*tex The |string| key is obsolete. */
         if (lua_key_eq(s, mode)) {
             lua_pushinteger(L, pdf_literal_mode(n));
-        } else if (lua_key_eq(s, data) || lua_key_eq(s, token) || lua_key_eq(s, string)) {
-            get_pdf_literal_direct_value(L, n);
+        } else if (lua_key_eq(s, data)) {
+            if (pdf_literal_type(n) == lua_refid_literal) {
+                lua_rawgeti(L, LUA_REGISTRYINDEX, pdf_literal_data(n));
+            } else {
+                tokenlist_to_luastring(L, pdf_literal_data(n));
+            }
         } else {
             lua_pushnil(L);
         }
     } else if (t == late_lua_node) {
-        /*tex The |string| key is obsolete. */
-        if (lua_key_eq(s, data) || lua_key_eq(s, token) || lua_key_eq(s, string)) {
-            get_late_lua_direct_value(L,n);
+        if (lua_key_eq(s, string) || lua_key_eq(s, data)) {
+            if (late_lua_type(n) == lua_refid_literal) {
+                lua_rawgeti(L, LUA_REGISTRYINDEX, late_lua_data(n));
+            } else {
+                tokenlist_to_luastring(L, late_lua_data(n));
+            }
         } else if (lua_key_eq(s, name)) {
             tokenlist_to_luastring(L, late_lua_name(n));
         } else {
@@ -5235,7 +4570,7 @@ static void lua_nodelib_direct_getfield_
         }
     } else if (t == pdf_setmatrix_node) {
         if (lua_key_eq(s, data)) {
-            get_pdf_setmatrix_direct_value(L,n);
+            tokenlist_to_luastring(L, pdf_setmatrix_data(n));
         } else {
             lua_pushnil(L);
         }
@@ -5259,13 +4594,13 @@ static void lua_nodelib_direct_getfield_
         if (lua_key_eq(s, stream)) {
             lua_pushinteger(L, write_stream(n));
         } else if (lua_key_eq(s, data)) {
-            get_write_direct_value(L,n);
+            tokenlist_to_lua(L, write_tokens(n));
         } else {
             lua_pushnil(L);
         }
     } else if (t == special_node) {
         if (lua_key_eq(s, data)) {
-            get_special_direct_value(L,n);
+            tokenlist_to_luastring(L, write_tokens(n));
         } else {
             lua_pushnil(L);
         }
@@ -5416,8 +4751,8 @@ static int lua_nodelib_direct_getfield(l
             lua_pushinteger(L, x_displace(n));
         } else if (lua_key_eq(s, yoffset)) {
             lua_pushinteger(L, y_displace(n));
-        } else if (lua_key_eq(s, data)) {
-            lua_pushinteger(L, glyph_node_data(n));
+        } else if (lua_key_eq(s, xadvance)) {
+            lua_pushinteger(L, x_advance(n));
         } else if (lua_key_eq(s, width)) {
             lua_pushinteger(L, char_width(font(n),character(n)));
         } else if (lua_key_eq(s, height)) {
@@ -5449,8 +4784,6 @@ static int lua_nodelib_direct_getfield(l
             lua_pushinteger(L, height(n));
         } else if (lua_key_eq(s, depth)) {
             lua_pushinteger(L, depth(n));
-        } else if (lua_key_eq(s, direction)) {
-            lua_pushinteger(L, box_dir(n));
         } else if (lua_key_eq(s, dir)) {
             lua_push_dir_par(L, box_dir(n));
         } else if (lua_key_eq(s, shift)) {
@@ -5514,12 +4847,6 @@ static int lua_nodelib_direct_getfield(l
             lua_pushinteger(L, height(n));
         } else if (lua_key_eq(s, depth)) {
             lua_pushinteger(L, depth(n));
-        } else if (lua_key_eq(s, left)) {
-            lua_pushinteger(L,rule_left(n));
-        } else if (lua_key_eq(s, right)) {
-            lua_pushinteger(L,rule_right(n));
-        } else if (lua_key_eq(s, direction)) {
-            lua_pushinteger(L, rule_dir(n));
         } else if (lua_key_eq(s, dir)) {
             lua_push_dir_par(L, rule_dir(n));
         } else if (lua_key_eq(s, index)) {
@@ -5530,10 +4857,8 @@ static int lua_nodelib_direct_getfield(l
             lua_pushnil(L);
         }
     } else if (t == dir_node) {
-        if (lua_key_eq(s, direction)) {
-            lua_pushinteger(L, dir_dir(n));
-        } else if (lua_key_eq(s, dir)) {
-            lua_push_dir_text(L, dir_dir(n), subtype(n));
+        if (lua_key_eq(s, dir)) {
+            lua_push_dir_text(L, dir_dir(n));
         } else if (lua_key_eq(s, level)) {
             lua_pushinteger(L, dir_level(n));
         } else if (lua_key_eq(s, subtype)) { /* can be used for anything */
@@ -5546,8 +4871,6 @@ static int lua_nodelib_direct_getfield(l
             lua_pushinteger(L, local_pen_inter(n));
         } else if (lua_key_eq(s, pen_broken)) {
             lua_pushinteger(L, local_pen_broken(n));
-        } else if (lua_key_eq(s, direction)) {
-            lua_pushinteger(L, local_par_dir(n));
         } else if (lua_key_eq(s, dir)) {
             lua_push_dir_par(L, local_par_dir(n));
         } else if (lua_key_eq(s, box_left)) {
@@ -5646,8 +4969,6 @@ static int lua_nodelib_direct_getfield(l
             nodelib_pushdirect_or_nil(right_delimiter(n));
         } else if (lua_key_eq(s, middle)) {
             nodelib_pushdirect_or_nil(middle_delimiter(n));
-        } else if (lua_key_eq(s, fam)) {
-            lua_pushinteger(L, fraction_fam(n));
         } else if (lua_key_eq(s, options)) {
             lua_pushinteger(L, fractionoptions(n));
         } else {
@@ -5790,8 +5111,6 @@ static int lua_nodelib_direct_getfield(l
             lua_pushinteger(L, height(n));
         } else if (lua_key_eq(s, depth)) {
             lua_pushinteger(L, depth(n));
-        } else if (lua_key_eq(s, direction)) {
-            lua_pushinteger(L, box_dir(n));
         } else if (lua_key_eq(s, dir)) {
             lua_push_dir_par(L, box_dir(n));
         } else if (lua_key_eq(s, shrink)) {
@@ -5894,7 +5213,7 @@ static int lua_nodelib_equal(lua_State *
 static int font_tex_ligaturing(lua_State * L)
 {
     /* on the stack are two nodes and a direction */
-    /* we need to deal with prev nodes when a range starts with a ligature */
+    /* hh-ls: we need to deal with prev nodes when a range starts with a ligature */
     halfword tmp_head;
     halfword h;
     halfword t = null;
@@ -5935,7 +5254,7 @@ static int font_tex_ligaturing(lua_State
 static int font_tex_direct_ligaturing(lua_State * L)
 {
     /* on the stack are two nodes and a direction */
-    /* we need to deal with prev nodes when a range starts with a ligature */
+    /* hh-ls: we need to deal with prev nodes when a range starts with a ligature */
     halfword tmp_head;
     halfword h;
     halfword t = null;
@@ -6486,29 +5805,57 @@ static int lua_nodelib_direct_tonode(lua
 
 /* node.setfield */
 
+#define cleanup_late_lua(n) do { \
+    if (late_lua_data(n) != 0) { \
+        if (late_lua_type(n) == normal) { \
+            delete_token_ref(late_lua_data(n)); \
+        } else if (late_lua_type(n) == lua_refid_literal) { \
+            luaL_unref(L, LUA_REGISTRYINDEX,late_lua_data(n)); \
+        } \
+    } \
+} while (0)
+
+#define cleanup_late_lua_name(n) do { \
+    if (late_lua_name(n) != 0) { \
+        delete_token_ref(late_lua_name(n)); \
+    } \
+} while (0)
+
 static int lua_nodelib_setfield_whatsit(lua_State * L, int n, const char *s)
 {
     int t = subtype(n);
 
     if (t == pdf_literal_node) {
-        /*tex The |string| key is obsolete. */
         if (lua_key_eq(s, mode)) {
             pdf_literal_mode(n) = (quarterword) lua_tointeger(L, 3);
-        } else if (lua_key_eq(s, data) || lua_key_eq(s, string)) {
-            set_pdf_literal_direct_normal(L, n, 3);
-        } else if (lua_key_eq(s, token)) {
-            set_pdf_literal_direct_token(L, n, 3);
+        } else if (lua_key_eq(s, data)) {
+            if (ini_version) {
+                pdf_literal_data(n) = nodelib_gettoks(L, 3);
+            } else {
+                lua_pushvalue(L, 3);
+                pdf_literal_data(n) = luaL_ref(L, LUA_REGISTRYINDEX);
+                pdf_literal_type(n) = lua_refid_literal;
+            }
         } else {
             return nodelib_cantset(L, n, s);
         }
     } else if (t == late_lua_node) {
-        /*tex The |string| key is obsolete. */
-        if (lua_key_eq(s, data) || lua_key_eq(s, string)) {
-            set_late_lua_direct_normal(L, n, 3);
-        } else if (lua_key_eq(s, token)) {
-            set_late_lua_direct_token(L, n, 3);
+        if (lua_key_eq(s, string)) {
+            cleanup_late_lua(n) ; /* ls-hh */
+            if (ini_version) {
+                late_lua_data(n) = nodelib_gettoks(L, 3);
+                late_lua_type(n) = normal;
+            } else {
+                lua_pushvalue(L, 3);
+                late_lua_data(n) = luaL_ref(L, LUA_REGISTRYINDEX);
+                late_lua_type(n) = lua_refid_literal;
+            }
+        } else if (lua_key_eq(s, data)) {
+            cleanup_late_lua(n) ; /* ls-hh */
+            late_lua_data(n) = nodelib_gettoks(L, 3);
+            late_lua_type(n) = normal;
         } else if (lua_key_eq(s, name)) {
-            cleanup_late_lua_name(n) ;
+            cleanup_late_lua_name(n) ; /* ls-hh */
             late_lua_name(n) = nodelib_gettoks(L, 3);
         } else {
             return nodelib_cantset(L, n, s);
@@ -6521,31 +5868,31 @@ static int lua_nodelib_setfield_whatsit(
             user_node_type(n) = (halfword) lua_tointeger(L, 3);
         } else if (lua_key_eq(s, value)) {
             switch (user_node_type(n)) {
-                case 'a':
-                    user_node_value(n) = nodelib_getlist(L, 3);
-                    break;
-                case 'd':
-                    user_node_value(n) = (halfword) lua_roundnumber(L, 3);
-                    break;
-                case 'l':
-                    lua_pushvalue(L, 3);
-                    if (user_node_value(n) != 0) {
-                        luaL_unref(L, LUA_REGISTRYINDEX,user_node_value(n));
-                    }
-                    user_node_value(n) = luaL_ref(L, LUA_REGISTRYINDEX);
-                    break;
-                case 'n':
-                    user_node_value(n) = nodelib_getlist(L, 3);
-                    break;
-                case 's':
-                    user_node_value(n) = nodelib_getstring(L, 3);
-                    break;
-                case 't':
-                    user_node_value(n) = nodelib_gettoks(L, 3);
-                    break;
-                default:
-                    user_node_value(n) = (halfword) lua_roundnumber(L, 3);
-                    break;
+            case 'a':
+                user_node_value(n) = nodelib_getlist(L, 3);
+                break;
+            case 'd':
+                user_node_value(n) = (halfword) lua_roundnumber(L, 3);
+                break;
+            case 'l':
+                lua_pushvalue(L, 3);
+                if (user_node_value(n) != 0) {
+                    luaL_unref(L, LUA_REGISTRYINDEX,user_node_value(n));
+                }
+                user_node_value(n) = luaL_ref(L, LUA_REGISTRYINDEX);
+                break;
+            case 'n':
+                user_node_value(n) = nodelib_getlist(L, 3);
+                break;
+            case 's':
+                user_node_value(n) = nodelib_getstring(L, 3);
+                break;
+            case 't':
+                user_node_value(n) = nodelib_gettoks(L, 3);
+                break;
+            default:
+                user_node_value(n) = (halfword) lua_roundnumber(L, 3);
+                break;
             }
         } else {
             return nodelib_cantset(L, n, s);
@@ -6590,7 +5937,7 @@ static int lua_nodelib_setfield_whatsit(
         }
     } else if (t == pdf_setmatrix_node) {
         if (lua_key_eq(s, data)) {
-            set_pdf_setmatrix_direct_value(L,n,3);
+            pdf_setmatrix_data(n) = nodelib_gettoks(L, 3);
         } else {
             return nodelib_cantset(L, n, s);
         }
@@ -6620,7 +5967,7 @@ static int lua_nodelib_setfield_whatsit(
         if (lua_key_eq(s, stream)) {
             write_stream(n) = (halfword) lua_tointeger(L, 3);
         } else if (lua_key_eq(s, data)) {
-            set_write_direct_value(L,n,3);
+            write_tokens(n) = nodelib_gettoks(L, 3);
         } else {
             return nodelib_cantset(L, n, s);
         }
@@ -6676,7 +6023,7 @@ static int lua_nodelib_setfield_whatsit(
         }
     } else if (t == special_node) {
         if (lua_key_eq(s, data)) {
-            set_special_direct_value(L,n,3);
+            write_tokens(n) = nodelib_gettoks(L, 3);
         } else {
             return nodelib_cantset(L, n, s);
         }
@@ -6760,8 +6107,8 @@ static int lua_nodelib_fast_setfield(lua
             x_displace(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, yoffset)) {
             y_displace(n) = (halfword) lua_roundnumber(L, 3);
-        } else if (lua_key_eq(s, data)) {
-            glyph_node_data(n) = (halfword) lua_tointeger(L, 3);;
+        } else if (lua_key_eq(s, xadvance)) {
+            x_advance(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, width)) {
             /* not yet */
         } else if (lua_key_eq(s, height)) {
@@ -6794,10 +6141,8 @@ static int lua_nodelib_fast_setfield(lua
             height(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, depth)) {
             depth(n) = (halfword) lua_roundnumber(L, 3);
-        } else if (lua_key_eq(s, direction)) {
-            box_dir(n) = nodelib_getdirection(L, 3);
         } else if (lua_key_eq(s, dir)) {
-            box_dir(n) = nodelib_getdir_par(L, 3);
+            box_dir(n) = nodelib_getdir(L, 3, 1);
         } else if (lua_key_eq(s, shift)) {
             shift_amount(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, glue_order)) {
@@ -6868,14 +6213,8 @@ static int lua_nodelib_fast_setfield(lua
             height(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, depth)) {
             depth(n) = (halfword) lua_roundnumber(L, 3);
-        } else if (lua_key_eq(s, left)) {
-            rule_left(n) = (halfword) lua_roundnumber(L, 3);
-        } else if (lua_key_eq(s, right)) {
-            rule_right(n) = (halfword) lua_roundnumber(L, 3);
-        } else if (lua_key_eq(s, direction)) {
-            rule_dir(n) = nodelib_getdirection(L, 3);
         } else if (lua_key_eq(s, dir)) {
-            rule_dir(n) = nodelib_getdir_par(L, 3);
+            rule_dir(n) = nodelib_getdir(L, 3, 1);
         } else if (lua_key_eq(s, index)) {
             rule_index(n) = (halfword) lua_tointeger(L, 3);
         } else if (lua_key_eq(s, transform)) {
@@ -6884,12 +6223,12 @@ static int lua_nodelib_fast_setfield(lua
             return nodelib_cantset(L, n, s);
         }
     } else if (t == dir_node) {
-        if (lua_key_eq(s, direction)) {
-            dir_dir(n) = nodelib_getdirection(L, 3);
-        } else if (lua_key_eq(s, dir)) {
-            nodelib_setdir_text(L, 3, n);
+        if (lua_key_eq(s, dir)) {
+            dir_dir(n) = nodelib_getdir(L, 3, 0);
         } else if (lua_key_eq(s, level)) {
             dir_level(n) = (halfword) lua_tointeger(L, 3);
+        } else if (lua_key_eq(s, subtype)) { /* can be used for anything */
+            subtype(n) = (quarterword) lua_tointeger(L, 3);
         } else {
             return nodelib_cantset(L, n, s);
         }
@@ -6898,10 +6237,8 @@ static int lua_nodelib_fast_setfield(lua
             local_pen_inter(n) = (halfword) lua_tointeger(L, 3);
         } else if (lua_key_eq(s, pen_broken)) {
             local_pen_broken(n) = (halfword) lua_tointeger(L, 3);
-        } else if (lua_key_eq(s, direction)) {
-            local_par_dir(n) = nodelib_getdirection(L, 3);
         } else if (lua_key_eq(s, dir)) {
-            local_par_dir(n) = nodelib_getdir_par(L, 3);
+            local_par_dir(n) = nodelib_getdir(L, 3, 1);
         } else if (lua_key_eq(s, box_left)) {
             local_box_left(n) = nodelib_getlist(L, 3);
         } else if (lua_key_eq(s, box_left_width)) {
@@ -7012,8 +6349,6 @@ static int lua_nodelib_fast_setfield(lua
             right_delimiter(n) = nodelib_getlist(L, 3);
         } else if (lua_key_eq(s, middle)) {
             middle_delimiter(n) = nodelib_getlist(L, 3);
-        } else if (lua_key_eq(s, fam)) {
-            fraction_fam(n) = (halfword) lua_tointeger(L, 3);
         } else if (lua_key_eq(s, options)) {
             fractionoptions(n) = (halfword) lua_tointeger(L, 3);
         } else {
@@ -7182,10 +6517,8 @@ static int lua_nodelib_fast_setfield(lua
             height(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, depth)) {
             depth(n) = (halfword) lua_roundnumber(L, 3);
-        } else if (lua_key_eq(s, direction)) {
-            box_dir(n) = nodelib_getdirection(L, 3);
         } else if (lua_key_eq(s, dir)) {
-            box_dir(n) = nodelib_getdir_par(L, 3);
+            box_dir(n) = nodelib_getdir(L, 3, 1);
         } else if (lua_key_eq(s, shrink)) {
             glue_shrink(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, glue_order)) {
@@ -7259,24 +6592,36 @@ static int lua_nodelib_direct_setfield_w
 {
     int t = subtype(n);
     if (t == pdf_literal_node) {
-        /*tex The |string| key is obsolete. */
         if (lua_key_eq(s, mode)) {
             pdf_literal_mode(n) = (quarterword) lua_tointeger(L, 3);
-        } else if (lua_key_eq(s, data) || lua_key_eq(s, string)) {
-            set_pdf_literal_direct_normal(L, n, 3);
-        } else if (lua_key_eq(s, token)) {
-            set_pdf_literal_direct_token(L, n, 3);
+        } else if (lua_key_eq(s, data)) {
+            if (ini_version) {
+                pdf_literal_data(n) = nodelib_gettoks(L, 3);
+            } else {
+                lua_pushvalue(L, 3);
+                pdf_literal_data(n) = luaL_ref(L, LUA_REGISTRYINDEX);
+                pdf_literal_type(n) = lua_refid_literal;
+            }
         } else {
             return nodelib_cantset(L, n, s);
         }
     } else if (t == late_lua_node) {
-        /*tex The |string| key is obsolete. */
-        if (lua_key_eq(s, data) || lua_key_eq(s, string)) {
-            set_late_lua_direct_normal(L, n, 3);
-        } else if (lua_key_eq(s, token)) {
-            set_late_lua_direct_token(L, n, 3);
+        if (lua_key_eq(s, string)) {
+            cleanup_late_lua(n) ; /* ls-hh */
+            if (ini_version) {
+                late_lua_data(n) = nodelib_gettoks(L, 3);
+                late_lua_type(n) = normal;
+            } else {
+                lua_pushvalue(L, 3);
+                late_lua_data(n) = luaL_ref(L, LUA_REGISTRYINDEX);
+                late_lua_type(n) = lua_refid_literal;
+            }
+        } else if (lua_key_eq(s, data)) {
+            cleanup_late_lua(n) ; /* ls-hh */
+            late_lua_data(n) = nodelib_gettoks(L, 3);
+            late_lua_type(n) = normal;
         } else if (lua_key_eq(s, name)) {
-            cleanup_late_lua_name(n) ;
+            cleanup_late_lua_name(n) ; /* ls-hh */
             late_lua_name(n) = nodelib_gettoks(L, 3);
         } else {
             return nodelib_cantset(L, n, s);
@@ -7287,7 +6632,33 @@ static int lua_nodelib_direct_setfield_w
         } else if (lua_key_eq(s, type)) {
             user_node_type(n) = (halfword) lua_tointeger(L, 3);
         } else if (lua_key_eq(s, value)) {
-            set_user_node_direct_value(L, n, 3);
+            switch (user_node_type(n)) {
+            case 'a':
+                user_node_value(n) = nodelib_getlist(L, 3);
+                break;
+            case 'd':
+                user_node_value(n) = (halfword) lua_roundnumber(L, 3);
+                break;
+            case 'l':
+                lua_pushvalue(L, 3);
+                if (user_node_value(n) != 0) {
+                    luaL_unref(L, LUA_REGISTRYINDEX,user_node_value(n));
+                }
+                user_node_value(n) = luaL_ref(L, LUA_REGISTRYINDEX);
+                break;
+            case 'n':
+                user_node_value(n) = nodelib_getlist(L, 3);
+                break;
+            case 's':
+                user_node_value(n) = nodelib_getstring(L, 3);
+                break;
+            case 't':
+                user_node_value(n) = nodelib_gettoks(L, 3);
+                break;
+            default:
+                user_node_value(n) = (halfword) lua_roundnumber(L, 3);
+                break;
+            }
         } else {
             return nodelib_cantset(L, n, s);
         }
@@ -7331,7 +6702,7 @@ static int lua_nodelib_direct_setfield_w
         }
     } else if (t == pdf_setmatrix_node) {
         if (lua_key_eq(s, data)) {
-            set_pdf_setmatrix_direct_value(L, n, 3);
+            pdf_setmatrix_data(n) = nodelib_gettoks(L, 3);
         } else {
             return nodelib_cantset(L, n, s);
         }
@@ -7359,9 +6730,9 @@ static int lua_nodelib_direct_setfield_w
         }
     } else if (t == write_node) {
         if (lua_key_eq(s, stream)) {
-            set_write_direct_value(L,n,3);
+            write_stream(n) = (halfword) lua_tointeger(L, 3);
         } else if (lua_key_eq(s, data)) {
-            set_write_direct_value(L,n,3);
+            write_tokens(n) = nodelib_gettoks(L, 3);
         } else {
             return nodelib_cantset(L, n, s);
         }
@@ -7417,7 +6788,7 @@ static int lua_nodelib_direct_setfield_w
         }
     } else if (t == special_node) {
         if (lua_key_eq(s, data)) {
-            set_special_direct_value(L, n, 3);
+            write_tokens(n) = nodelib_gettoks(L, 3);
         } else {
             return nodelib_cantset(L, n, s);
         }
@@ -7592,8 +6963,8 @@ static int lua_nodelib_direct_setfield(l
             x_displace(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, yoffset)) {
             y_displace(n) = (halfword) lua_roundnumber(L, 3);
-        } else if (lua_key_eq(s, data)) {
-            glyph_node_data(n) = (halfword) lua_tointeger(L, 3);
+        } else if (lua_key_eq(s, xadvance)) {
+            x_advance(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, expansion_factor)) {
             ex_glyph(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, components)) {
@@ -7626,10 +6997,8 @@ static int lua_nodelib_direct_setfield(l
             height(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, depth)) {
             depth(n) = (halfword) lua_roundnumber(L, 3);
-        } else if (lua_key_eq(s, direction)) {
-            box_dir(n) = nodelib_getdirection(L, 3);
         } else if (lua_key_eq(s, dir)) {
-            box_dir(n) = nodelib_getdir_par(L, 3);
+            box_dir(n) = nodelib_getdir(L, 3, 1);
         } else if (lua_key_eq(s, shift)) {
             shift_amount(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, glue_order)) {
@@ -7700,14 +7069,8 @@ static int lua_nodelib_direct_setfield(l
             height(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, depth)) {
             depth(n) = (halfword) lua_roundnumber(L, 3);
-        } else if (lua_key_eq(s, left)) {
-            rule_left(n) = (halfword) lua_roundnumber(L, 3);
-        } else if (lua_key_eq(s, right)) {
-            rule_right(n) = (halfword) lua_roundnumber(L, 3);
-        } else if (lua_key_eq(s, direction)) {
-            rule_dir(n) = nodelib_getdirection(L, 3);
         } else if (lua_key_eq(s, dir)) {
-            rule_dir(n) = nodelib_getdir_par(L, 3);
+            rule_dir(n) = nodelib_getdir(L, 3, 1);
         } else if (lua_key_eq(s, index)) {
             rule_index(n) = (halfword) lua_tointeger(L, 3);
         } else if (lua_key_eq(s, transform)) {
@@ -7716,12 +7079,12 @@ static int lua_nodelib_direct_setfield(l
             return nodelib_cantset(L, n, s);
         }
     } else if (t == dir_node) {
-        if (lua_key_eq(s, direction)) {
-            dir_dir(n) = nodelib_getdirection(L, 3);
-        } else if (lua_key_eq(s, dir)) {
-            nodelib_setdir_text(L, 3, n);
+        if (lua_key_eq(s, dir)) {
+            dir_dir(n) = nodelib_getdir(L, 3, 0);
         } else if (lua_key_eq(s, level)) {
             dir_level(n) = (halfword) lua_tointeger(L, 3);
+        } else if (lua_key_eq(s, subtype)) { /* can be used for anything */
+            subtype(n) = (quarterword) lua_tointeger(L, 3);
         } else {
             return nodelib_cantset(L, n, s);
         }
@@ -7736,10 +7099,8 @@ static int lua_nodelib_direct_setfield(l
             local_pen_inter(n) = (halfword) lua_tointeger(L, 3);
         } else if (lua_key_eq(s, pen_broken)) {
             local_pen_broken(n) = (halfword) lua_tointeger(L, 3);
-        } else if (lua_key_eq(s, direction)) {
-            local_par_dir(n) = nodelib_getdirection(L, 3);
         } else if (lua_key_eq(s, dir)) {
-            local_par_dir(n) = nodelib_getdir_par(L, 3);
+            local_par_dir(n) = nodelib_getdir(L, 3, 1);
         } else if (lua_key_eq(s, box_left)) {
             local_box_left(n) = nodelib_getlist(L, 3);
         } else if (lua_key_eq(s, box_left_width)) {
@@ -7844,8 +7205,6 @@ static int lua_nodelib_direct_setfield(l
             right_delimiter(n) = nodelib_popdirect(3);
         } else if (lua_key_eq(s, middle)) {
             middle_delimiter(n) = nodelib_popdirect(3);
-        } else if (lua_key_eq(s, fam)) {
-            fraction_fam(n) = (halfword) lua_tointeger(L, 3);
         } else if (lua_key_eq(s, options)) {
             fractionoptions(n) = (halfword) lua_tointeger(L, 3);
         } else {
@@ -8014,10 +7373,8 @@ static int lua_nodelib_direct_setfield(l
             height(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, depth)) {
             depth(n) = (halfword) lua_roundnumber(L, 3);
-        } else if (lua_key_eq(s, direction)) {
-            box_dir(n) = nodelib_getdirection(L, 3);
         } else if (lua_key_eq(s, dir)) {
-            box_dir(n) = nodelib_getdir_par(L, 3);
+            box_dir(n) = nodelib_getdir(L, 3, 1);
         } else if (lua_key_eq(s, shrink)) {
             glue_shrink(n) = (halfword) lua_roundnumber(L, 3);
         } else if (lua_key_eq(s, glue_order)) {
@@ -8159,8 +7516,6 @@ static int lua_nodelib_direct_setbox(lua
 
 /* node.is_node(n) */
 
-/*
-
 static int lua_nodelib_is_node(lua_State * L)
 {
     if (maybe_isnode(L,1) == NULL)
@@ -8170,18 +7525,6 @@ static int lua_nodelib_is_node(lua_State
     return 1;
 }
 
-*/
-
-static int lua_nodelib_is_node(lua_State * L)
-{
-    halfword *p = maybe_isnode(L, 1);
-    if (p == NULL)
-        lua_pushboolean(L,0);
-    else
-        lua_pushinteger(L, *((halfword *)p));
-    return 1;
-}
-
 /* node.direct.is_direct(n) (handy for mixed usage testing) */
 
 static int lua_nodelib_direct_is_direct(lua_State * L)
@@ -8228,7 +7571,7 @@ static int lua_nodelib_direct_is_node(lu
     mechanism. And, one can always sweep the table empty.
 */
 
-static int lua_nodelib_properties_set_mode(lua_State * L)
+static int lua_nodelib_properties_set_mode(lua_State * L) /* hh */
 {   /* <boolean> */
     if (lua_isboolean(L,1)) {
         lua_properties_enabled = lua_toboolean(L,1);
@@ -8241,7 +7584,7 @@ static int lua_nodelib_properties_set_mo
 
 /* We used to have variants in assigned defaults but they made no sense. */
 
-static int lua_nodelib_properties_flush_table(lua_State * L)
+static int lua_nodelib_properties_flush_table(lua_State * L) /* hh */
 {   /* <node|direct> <number> */
     lua_get_metatablelua(node_properties);
     lua_pushnil(L); /* initializes lua_next */
@@ -8256,7 +7599,7 @@ static int lua_nodelib_properties_flush_
 
 /* maybe we should allocate a proper index 0..var_mem_max but not now */
 
-static int lua_nodelib_get_property(lua_State * L)
+static int lua_nodelib_get_property(lua_State * L) /* hh */
 {   /* <node> */
     halfword n = *((halfword *) lua_touserdata(L, 1));
     if (n == null) {
@@ -8268,7 +7611,7 @@ static int lua_nodelib_get_property(lua_
     return 1;
 }
 
-static int lua_nodelib_direct_get_property(lua_State * L)
+static int lua_nodelib_direct_get_property(lua_State * L) /* hh */
 {   /* <direct> */
     halfword n = lua_tointeger(L, 1);
     if (n == null) {
@@ -8280,7 +7623,7 @@ static int lua_nodelib_direct_get_proper
     return 1;
 }
 
-static int lua_nodelib_set_property(lua_State * L)
+static int lua_nodelib_set_property(lua_State * L) /* hh */
 {
     /* <node> <value> */
     halfword n = *((halfword *) lua_touserdata(L, 1));
@@ -8295,7 +7638,7 @@ static int lua_nodelib_set_property(lua_
     return 0;
 }
 
-static int lua_nodelib_direct_set_property(lua_State * L)
+static int lua_nodelib_direct_set_property(lua_State * L) /* hh */
 {
     /* <direct> <value> */
     halfword n = lua_tointeger(L, 1);
@@ -8310,13 +7653,13 @@ static int lua_nodelib_direct_set_proper
     return 0;
 }
 
-static int lua_nodelib_direct_properties_get_table(lua_State * L)
+static int lua_nodelib_direct_properties_get_table(lua_State * L) /* hh */
 {   /* <node|direct> */
     lua_get_metatablelua(node_properties);
     return 1;
 }
 
-static int lua_nodelib_properties_get_table(lua_State * L)
+static int lua_nodelib_properties_get_table(lua_State * L) /* hh */
 {   /* <node|direct> */
     lua_get_metatablelua(node_properties_indirect);
     return 1;
@@ -8324,7 +7667,7 @@ static int lua_nodelib_properties_get_ta
 
 /* bonus */
 
-static int lua_nodelib_get_property_t(lua_State * L)
+static int lua_nodelib_get_property_t(lua_State * L) /* hh */
 {   /* <table> <node> */
     halfword n = *((halfword *) lua_touserdata(L, 2));
     if (n == null) {
@@ -8335,7 +7678,7 @@ static int lua_nodelib_get_property_t(lu
     return 1;
 }
 
-static int lua_nodelib_set_property_t(lua_State * L)
+static int lua_nodelib_set_property_t(lua_State * L) /* hh */
 {
     /* <table> <node> <value> */
     halfword n = *((halfword *) lua_touserdata(L, 2));
@@ -8461,7 +7804,7 @@ static int lua_nodelib_direct_flatten_di
                     try_couple_nodes(alink(current),h);
                 }
                 vlink(n) = null ;
-              /*tlink(n) = null; */
+              //tlink(n) = null;
             } else {
                 if (current == head) {
                     head = next;
@@ -8527,7 +7870,7 @@ static int lua_nodelib_flatten_discretio
                     try_couple_nodes(alink(current),h);
                 }
                 vlink(n) = null ;
-              /*tlink(n) = null; */
+              //tlink(n) = null;
             } else {
                 if (current == head) {
                     head = next;
@@ -8624,115 +7967,6 @@ static int lua_nodelib_direct_get_syncte
     return 0;
 }
 
-/* helper, assumes one node, returns node and delta .. to be tested */
-
-static int lua_nodelib_prepend_prevdepth(lua_State * L)
-{
-    halfword *a;
-    halfword p;
-    halfword prevdepth;
-    boolean mirrored;
-    halfword n = *check_isnode(L, 1);
-    if (!(type(n) == hlist_node || type(n) == vlist_node)) {
-        lua_pushnil(L);
-        return 1;
-    }
-    prevdepth = lua_tointeger(L,2);
-    mirrored = (type(n) == hlist_node) && is_mirrored(box_dir(n)) ;
-    if (prevdepth > ignore_depth) {
-        halfword d;
-        if (mirrored) {
-            d = width(baseline_skip_par) - prevdepth - depth(n);
-        } else {
-            d = width(baseline_skip_par) - prevdepth - height(n);
-        }
-        if (d < line_skip_limit_par) {
-            p = new_param_glue(line_skip_code);
-        } else {
-            p = new_skip_param(baseline_skip_code);
-            width(p) = d;
-        }
-        couple_nodes(p,n);
-        fast_metatable_or_nil(p); /* glue */
-    } else {
-        fast_metatable_or_nil(n); /* node */
-    }
-    if (mirrored) {
-        prevdepth = height(n);
-    } else {
-        prevdepth = depth(n);
-    }
-    lua_pushinteger(L,prevdepth); /* new prevdepth */
-    return 2;
-}
-
-static int lua_nodelib_direct_prepend_prevdepth(lua_State * L)
-{
-    halfword p;
-    halfword prevdepth;
-    boolean mirrored;
-    halfword n = lua_tointeger(L, 1);
-    if (type(n) == hlist_node || type(n) == vlist_node) {
-        lua_pushnil(L);
-        return 1;
-    }
-    prevdepth = lua_tointeger(L,2);
-    mirrored = (type(n) == hlist_node) && is_mirrored(box_dir(n)) ;
-    if (prevdepth > ignore_depth) {
-        halfword d;
-        if (mirrored) {
-            d = width(baseline_skip_par) - prevdepth - depth(n);
-        } else {
-            d = width(baseline_skip_par) - prevdepth - height(n);
-        }
-        if (d < line_skip_limit_par) {
-            p = new_param_glue(line_skip_code);
-        } else {
-            p = new_skip_param(baseline_skip_code);
-            width(p) = d;
-        }
-        couple_nodes(p,n);
-        lua_pushinteger(L,p); /* glue */
-    } else {
-        lua_pushinteger(L,n); /* node */
-    }
-    if (mirrored) {
-        prevdepth = height(n);
-    } else {
-        prevdepth = depth(n);
-    }
-    lua_pushinteger(L,prevdepth); /* new prevdepth */
-    return 2;
-}
-
-static int lua_nodelib_make_extensible(lua_State * L)
-{
-    int top = lua_gettop(L);
-    if (top >= 3) {
-        halfword fnt = lua_tointeger(L,1);
-        halfword chr = lua_tointeger(L,2);
-        halfword size = lua_tointeger(L,3);
-        halfword overlap = 65536 ;
-        halfword attlist = null;
-        halfword b = null;
-        int horizontal = 0;
-        if (top >= 4) {
-            overlap = lua_tointeger(L,4);
-        }
-        if (top >= 5) {
-            horizontal = lua_toboolean(L,5);
-        }
-        if (top >= 6) {
-            attlist = *check_isnode(L, 6);
-        }
-        b = make_extensible(fnt,chr,size,overlap,horizontal,attlist);
-        nodelib_pushlist(L,b);
-    } else {
-        lua_pushnil(L);
-    }
-    return 1;
-}
-
 /* done */
 
 static const struct luaL_Reg nodelib_p[] = {
@@ -8788,7 +8022,6 @@ static const struct luaL_Reg direct_node
     {"getshift", lua_nodelib_direct_getshift},
     {"getfield", lua_nodelib_direct_getfield},
     {"getfont", lua_nodelib_direct_getfont},
-    {"getexpansion", lua_nodelib_direct_getexpansion},
     {"getfam", lua_nodelib_direct_getfam},
     {"getid", lua_nodelib_direct_getid},
     {"getnext", lua_nodelib_direct_getnext},
@@ -8796,13 +8029,11 @@ static const struct luaL_Reg direct_node
     {"getboth", lua_nodelib_direct_getboth},
     {"getlist", lua_nodelib_direct_getlist},
     {"getleader", lua_nodelib_direct_getleader},
-    {"getdata", lua_nodelib_direct_getdata},
     {"getsubtype", lua_nodelib_direct_getsubtype},
     {"getattributelist", lua_nodelib_direct_getattributelist},
     {"getnucleus", lua_nodelib_direct_getnucleus},
     {"getsub", lua_nodelib_direct_getsub},
     {"getsup", lua_nodelib_direct_getsup},
-    {"getdirection", lua_nodelib_direct_getdirection},
     {"has_glyph", lua_nodelib_direct_has_glyph},
     {"has_attribute", lua_nodelib_direct_has_attribute},
     {"get_attribute", lua_nodelib_direct_get_attribute},
@@ -8833,14 +8064,12 @@ static const struct luaL_Reg direct_node
     {"setfield", lua_nodelib_direct_setfield},
     {"setchar", lua_nodelib_direct_setchar},
     {"setfont", lua_nodelib_direct_setfont},
-    {"setexpansion", lua_nodelib_direct_setexpansion},
     {"setfam", lua_nodelib_direct_setfam},
     {"setcomponents", lua_nodelib_direct_setcomponents},
     {"setlang", lua_nodelib_direct_setlang},
     {"setkern", lua_nodelib_direct_setkern},
     {"setpenalty", lua_nodelib_direct_setpenalty},
     {"setdir", lua_nodelib_direct_setdir},
-    {"setdirection", lua_nodelib_direct_setdirection},
     {"setoffsets", lua_nodelib_direct_setoffsets},
     {"setdisc", lua_nodelib_direct_setdisc},
     {"setwhd", lua_nodelib_direct_setwhd},
@@ -8855,7 +8084,6 @@ static const struct luaL_Reg direct_node
     {"setsplit", lua_nodelib_direct_setsplit},
     {"setlist", lua_nodelib_direct_setlist},
     {"setleader", lua_nodelib_direct_setleader},
-    {"setdata", lua_nodelib_direct_setdata},
     {"setsubtype", lua_nodelib_direct_setsubtype},
     {"setattributelist", lua_nodelib_direct_setattributelist},
     {"setnucleus", lua_nodelib_direct_setnucleus},
@@ -8869,8 +8097,6 @@ static const struct luaL_Reg direct_node
     {"traverse", lua_nodelib_direct_traverse},
     {"traverse_id", lua_nodelib_direct_traverse_filtered},
     {"traverse_char", lua_nodelib_direct_traverse_char},
-    {"traverse_glyph", lua_nodelib_direct_traverse_glyph},
-    {"traverse_list", lua_nodelib_direct_traverse_list},
  /* {"type", lua_nodelib_type}, */ /* no node argument */
  /* {"types", lua_nodelib_types}, */ /* no node argument */
     {"unprotect_glyphs", lua_nodelib_direct_unprotect_glyphs},
@@ -8884,15 +8110,14 @@ static const struct luaL_Reg direct_node
  /* {"whatsits", lua_nodelib_whatsits}, */ /* no node argument */
     {"write", lua_nodelib_direct_append},
     {"set_properties_mode",lua_nodelib_properties_set_mode},
-    {"flush_properties_table",lua_nodelib_properties_flush_table},
-    {"get_properties_table",lua_nodelib_direct_properties_get_table},
+    {"flush_properties_table",lua_nodelib_properties_flush_table}, /* hh experiment */
+    {"get_properties_table",lua_nodelib_direct_properties_get_table}, /* hh experiment */
     {"getproperty", lua_nodelib_direct_get_property},
     {"setproperty", lua_nodelib_direct_set_property},
     {"effective_glue", lua_nodelib_direct_effective_glue},
     {"check_discretionary", lua_nodelib_direct_check_discretionary},
     {"check_discretionaries", lua_nodelib_direct_check_discretionaries},
     {"flatten_discretionaries",lua_nodelib_direct_flatten_discretionaries},
-    {"prepend_prevdepth",lua_nodelib_direct_prepend_prevdepth},
     /* done */
     {"set_synctex_fields", lua_nodelib_direct_set_synctex_fields},
     {"get_synctex_fields", lua_nodelib_direct_get_synctex_fields},
@@ -8914,7 +8139,6 @@ static const struct luaL_Reg nodelib_f[]
     {"family_font", lua_nodelib_mfont},
     {"fields", lua_nodelib_fields},
     {"subtypes", lua_nodelib_subtypes},
-    {"values", lua_nodelib_values},
     {"first_glyph", lua_nodelib_first_glyph},
     {"flush_list", lua_nodelib_flush_list},
     {"flush_node", lua_nodelib_flush_node},
@@ -8967,34 +8191,33 @@ static const struct luaL_Reg nodelib_f[]
     {"traverse", lua_nodelib_traverse},
     {"traverse_id", lua_nodelib_traverse_filtered},
     {"traverse_char", lua_nodelib_traverse_char},
-    {"traverse_glyph", lua_nodelib_traverse_glyph},
-    {"traverse_list", lua_nodelib_traverse_list},
     {"type", lua_nodelib_type},
     {"types", lua_nodelib_types},
     {"unprotect_glyphs", lua_nodelib_unprotect_glyphs},
     {"unprotect_glyph", lua_nodelib_unprotect_glyph},
     {"unset_attribute", lua_nodelib_unset_attribute},
-    {"setglue", lua_nodelib_set_glue},
-    {"getglue", lua_nodelib_get_glue},
-    {"is_zero_glue", lua_nodelib_is_zero_glue},
+    {"setglue",lua_nodelib_set_glue},
+    {"getglue",lua_nodelib_get_glue},
+    {"is_zero_glue",lua_nodelib_is_zero_glue},
     {"usedlist", lua_nodelib_usedlist},
     {"vpack", lua_nodelib_vpack},
     {"whatsits", lua_nodelib_whatsits},
     {"write", lua_nodelib_append},
     /* experiment */
- /* {"attributes_to_table",lua_nodelib_attributes_to_table}, */
+ /* {"attributes_to_table",lua_nodelib_attributes_to_table}, */ /* hh experiment */
     /* experiment */
-    {"set_properties_mode", lua_nodelib_properties_set_mode},
-    {"flush_properties_table", lua_nodelib_properties_flush_table},
-    {"get_properties_table", lua_nodelib_properties_get_table},
-    {"getproperty", lua_nodelib_get_property},
-    {"setproperty", lua_nodelib_set_property},
+    {"set_properties_mode",lua_nodelib_properties_set_mode}, /* hh experiment */
+    {"flush_properties_table",lua_nodelib_properties_flush_table}, /* hh experiment */
+    {"get_properties_table",lua_nodelib_properties_get_table}, /* bonus */ /* hh experiment */
+    {"getproperty", lua_nodelib_get_property}, /* hh experiment */
+    {"setproperty", lua_nodelib_set_property}, /* hh experiment */
     {"effective_glue", lua_nodelib_effective_glue},
     {"check_discretionary", lua_nodelib_check_discretionary},
     {"check_discretionaries", lua_nodelib_check_discretionaries},
-    {"flatten_discretionaries", lua_nodelib_flatten_discretionaries},
-    {"prepend_prevdepth", lua_nodelib_prepend_prevdepth},
-    {"make_extensible", lua_nodelib_make_extensible},
+    {"flatten_discretionaries",lua_nodelib_flatten_discretionaries},
+    /* done */
+ /* {"set_synctex_fields", lua_nodelib_set_synctex_fields}, */
+ /* {"get_synctex_fields", lua_nodelib_get_synctex_fields}, */
     /* done */
     {"fix_node_lists", lua_nodelib_fix_node_lists},
     {NULL, NULL} /* sentinel */
@@ -9032,12 +8255,12 @@ void nodelist_to_lua(lua_State * L, int
     lua_nodelib_push(L);
 }
 
-int nodelist_from_lua(lua_State * L, int n)
+int nodelist_from_lua(lua_State * L)
 {
-    if (lua_isnil(L, n)) {
+    if (lua_isnil(L, -1)) {
         return null;
     } else {
-        halfword list = *check_isnode(L, n);
-        return (list ? list : null);
+        halfword n= *check_isnode(L, -1);
+        return (n ? n : null);
     }
 }
--- texlive-bin.orig/texk/web2c/luatexdir/lua/loslibext.c
+++ texlive-bin/texk/web2c/luatexdir/lua/loslibext.c
@@ -703,49 +703,28 @@ static int uname(struct utsname *uts)
     GetVersionEx(&osver);
     GetSystemInfo(&sysinfo);
 
-
-    /*
-        Windows 10               10.0*
-        Windows Server 2016      10.0*
-        Windows 8.1               6.3*
-        Windows Server 2012 R2    6.3*
-        Windows 8                 6.2
-        Windows Server 2012       6.2
-        Windows 7                 6.1
-        Windows Server 2008 R2	  6.1
-        Windows Server 2008       6.0
-        Windows Vista             6.0
-        Windows Server 2003 R2	  5.2
-        Windows Server 2003       5.2
-        Windows XP 64-Bit Edition 5.2
-        Windows XP                5.1
-        Windows 2000              5.0
-    */
-
     switch (osver.dwPlatformId) {
-    case VER_PLATFORM_WIN32_NT:
+    case VER_PLATFORM_WIN32_NT:        /* NT, Windows 2000 or Windows XP */
         if (osver.dwMajorVersion == 4)
-            strcpy(uts->sysname, "Windows NT 4");
+            strcpy(uts->sysname, "Windows NT4x");       /* NT4x */
         else if (osver.dwMajorVersion <= 3)
-            strcpy(uts->sysname, "Windows NT 3");
+            strcpy(uts->sysname, "Windows NT3x");       /* NT3x */
         else if (osver.dwMajorVersion == 5) {
             if (osver.dwMinorVersion == 0)
-                strcpy(uts->sysname, "Windows 2000");
+                strcpy(uts->sysname, "Windows 2000");   /* 2k */
             else if (osver.dwMinorVersion == 1)
-                strcpy(uts->sysname, "Windows XP");
+                strcpy(uts->sysname, "Windows XP");     /* XP */
             else if (osver.dwMinorVersion == 2)
-                strcpy(uts->sysname, "Windows XP 64-Bit");
+                strcpy(uts->sysname, "Windows Server 2003");    /* Server 2003 */
         } else if (osver.dwMajorVersion == 6) {
-            if (osver.dwMinorVersion == 0)
-                strcpy(uts->sysname, "Windows Vista");
-            else if (osver.dwMinorVersion == 1)
-                strcpy(uts->sysname, "Windows 7");
-            else if (osver.dwMinorVersion == 2)
-                strcpy(uts->sysname, "Windows 8");
-            else if (osver.dwMinorVersion == 3)
-                strcpy(uts->sysname, "Windows 8.1");
-        } else if (osver.dwMajorVersion == 10) {
-                strcpy(uts->sysname, "Windows 10");
+            /*
+               if( osver.wProductType == VER_NT_WORKSTATION )
+             */
+            strcpy(uts->sysname, "Windows Vista");      /* Vista */
+            /*
+               else
+               strcpy (uts->sysname, "Windows Server 2008");
+             */
         }
         os = WinNT;
         break;
--- texlive-bin.orig/texk/web2c/luatexdir/lua/lpdflib.c
+++ texlive-bin/texk/web2c/luatexdir/lua/lpdflib.c
@@ -22,7 +22,7 @@
 #include "lua/luatex-api.h"
 #include "pdf/pdftables.h"
 
-int luapdfprint(lua_State * L)
+static int luapdfprint(lua_State * L)
 {
     int n;
     const_lstring st;
@@ -82,7 +82,6 @@ int luapdfprint(lua_State * L)
     }
     st.s = lua_tolstring(L, n, &st.l);
     pdf_out_block(static_pdf, st.s, st.l);
-/*  pdf_out(pdf, '\n'); */
     return 0;
 }
 
@@ -194,7 +193,6 @@ static int table_obj(lua_State * L)
     const_lstring attr, st;
     lstring buf;
     int immediate = 0;          /* default: not immediate */
-    int nolength = 0;
     attr.s = st.s = NULL;
     attr.l = 0;
     assert(lua_istable(L, 1));  /* t */
@@ -215,12 +213,6 @@ static int table_obj(lua_State * L)
         immediate = lua_toboolean(L, -1);       /* 0 or 1 */
     }
     lua_pop(L, 1);              /* t */
-    lua_key_rawgeti(nolength);
-    if (!lua_isnil(L, -1)) {    /* b? t */
-        if (lua_isboolean(L, -1))      /* !b t */
-            nolength = lua_toboolean(L, -1);       /* 0 or 1 */
-    }
-    lua_pop(L, 1);              /* t */
 
     /* is a reserved object referenced by "objnum"? */
 
@@ -343,29 +335,19 @@ static int table_obj(lua_State * L)
     } else {
         if (immediate == 1) {
             pdf_begin_obj(static_pdf, k, OBJSTM_NEVER); /* 0 = not an object stream candidate! */
-            if (nolength && attr.s != NULL) {
-                /* we have a direct copy possible with compressed data */
-                pdf_begin_dict(static_pdf);
+            pdf_begin_dict(static_pdf);
+            if (attr.s != NULL) {
                 pdf_out_block(static_pdf, attr.s, attr.l);
-                static_pdf->compress_level = 0;
-                static_pdf->stream_deflate = false;
-                pdf_end_dict(static_pdf);
-            } else {
-                pdf_begin_dict(static_pdf);
-                if (attr.s != NULL) {
-                    pdf_check_space(static_pdf);
-                    pdf_out_block(static_pdf, attr.s, attr.l);
-                    pdf_set_space(static_pdf);
-                }
-                if (compress_level > -1)
-                    static_pdf->compress_level = compress_level;
-                pdf_dict_add_streaminfo(static_pdf);
-                pdf_end_dict(static_pdf);
+                if (attr.s[attr.l - 1] != '\n')
+                    pdf_out(static_pdf, '\n');
             }
+            if (compress_level > -1)
+                static_pdf->compress_level = compress_level;
+            pdf_dict_add_streaminfo(static_pdf);
+            pdf_end_dict(static_pdf);
             pdf_begin_stream(static_pdf);
         } else {
             set_obj_obj_is_stream(static_pdf, k);
-            set_obj_obj_no_length(static_pdf, k);
             if (compress_level > -1)
                 obj_obj_pdfcompresslevel(static_pdf, k) = compress_level;
         }
@@ -422,42 +404,42 @@ static int orig_obj(lua_State * L)
     obj_data_ptr(static_pdf, k) = pdf_get_mem(static_pdf, pdfmem_obj_size);
     init_obj_obj(static_pdf, k);
     switch (n - first_arg + 1) {
-        case 0:
-            luaL_error(L, "pdf.obj() needs at least one argument");
-            break;
-        case 1:
-            if (!lua_isstring(L, first_arg)) /* or number */
-                luaL_error(L, "pdf.obj() 1st argument must be string");
-            break;
-        case 2:
-        case 3:
-            if (lua_type(L, first_arg) != LUA_TSTRING)
-                luaL_error(L, "pdf.obj() 1st argument must be string");
-            if (!lua_isstring(L, first_arg + 1)) /* or number */
-                luaL_error(L, "pdf.obj() 2nd argument must be string");
-            st_s = lua_tostring(L, first_arg);
-            if (lua_key_eq(st_s, file)) {
-                if (n == first_arg + 2)
-                    luaL_error(L, "pdf.obj() 3rd argument forbidden in file mode");
-                set_obj_obj_is_file(static_pdf, k);
-            } else {
-                if (n == first_arg + 2) {   /* write attr text */
-                    if (!lua_isstring(L, -1)) /* or number */
-                        luaL_error(L, "pdf.obj() 3rd argument must be string");
-                    obj_obj_stream_attr(static_pdf, k) =
-                        luaL_ref(Luas, LUA_REGISTRYINDEX);
-                }
-                if (lua_key_eq(st_s, stream)) {
-                    set_obj_obj_is_stream(static_pdf, k);
-                } else if (lua_key_eq(st_s, streamfile)) {
-                    set_obj_obj_is_stream(static_pdf, k);
-                    set_obj_obj_is_file(static_pdf, k);
-                } else
-                    luaL_error(L, "pdf.obj() invalid argument");
+    case 0:
+        luaL_error(L, "pdf.obj() needs at least one argument");
+        break;
+    case 1:
+        if (!lua_isstring(L, first_arg)) /* or number */
+            luaL_error(L, "pdf.obj() 1st argument must be string");
+        break;
+    case 2:
+    case 3:
+        if (lua_type(L, first_arg) != LUA_TSTRING)
+            luaL_error(L, "pdf.obj() 1st argument must be string");
+        if (!lua_isstring(L, first_arg + 1)) /* or number */
+            luaL_error(L, "pdf.obj() 2nd argument must be string");
+        st_s = lua_tostring(L, first_arg);
+        if (lua_key_eq(st_s, file)) {
+            if (n == first_arg + 2)
+                luaL_error(L, "pdf.obj() 3rd argument forbidden in file mode");
+            set_obj_obj_is_file(static_pdf, k);
+        } else {
+            if (n == first_arg + 2) {   /* write attr text */
+                if (!lua_isstring(L, -1)) /* or number */
+                    luaL_error(L, "pdf.obj() 3rd argument must be string");
+                obj_obj_stream_attr(static_pdf, k) =
+                    luaL_ref(Luas, LUA_REGISTRYINDEX);
             }
-            break;
-        default:
-            luaL_error(L, "pdf.obj() allows max. 3 arguments");
+            if (lua_key_eq(st_s, stream)) {
+                set_obj_obj_is_stream(static_pdf, k);
+            } else if (lua_key_eq(st_s, streamfile)) {
+                set_obj_obj_is_stream(static_pdf, k);
+                set_obj_obj_is_file(static_pdf, k);
+            } else
+                luaL_error(L, "pdf.obj() invalid argument");
+        }
+        break;
+    default:
+        luaL_error(L, "pdf.obj() allows max. 3 arguments");
     }
     obj_obj_data(static_pdf, k) = luaL_ref(L, LUA_REGISTRYINDEX);
     return k;
@@ -496,23 +478,23 @@ static int l_reserveobj(lua_State * L)
     const char *st_s = NULL;
     n = lua_gettop(L);
     switch (n) {
-        case 0:
-            static_pdf->obj_count++;
-            pdf_last_obj = pdf_create_obj(static_pdf, obj_type_obj, static_pdf->obj_ptr + 1);
-            break;
-        case 1:
-            if (lua_type(L, -1) != LUA_TSTRING)
-                luaL_error(L, "pdf.reserveobj() optional argument must be string");
-            st_s = luaL_checkstring(L, 1);
-            if (lua_key_eq(st_s, annot)) {
-                pdf_last_annot = pdf_create_obj(static_pdf, obj_type_annot, 0);
-            } else {
-                luaL_error(L, "pdf.reserveobj() optional string must be \"annot\"");
-            }
-            lua_pop(L, 1);
-            break;
-        default:
-            luaL_error(L, "pdf.reserveobj() allows max. 1 argument");
+    case 0:
+        static_pdf->obj_count++;
+        pdf_last_obj = pdf_create_obj(static_pdf, obj_type_obj, static_pdf->obj_ptr + 1);
+        break;
+    case 1:
+        if (lua_type(L, -1) != LUA_TSTRING)
+            luaL_error(L, "pdf.reserveobj() optional argument must be string");
+        st_s = luaL_checkstring(L, 1);
+        if (lua_key_eq(st_s, annot)) {
+            pdf_last_annot = pdf_create_obj(static_pdf, obj_type_annot, 0);
+        } else {
+            luaL_error(L, "pdf.reserveobj() optional string must be \"annot\"");
+        }
+        lua_pop(L, 1);
+        break;
+    default:
+        luaL_error(L, "pdf.reserveobj() allows max. 1 argument");
     }
     lua_pushinteger(L, static_pdf->obj_ptr);
     return 1;
@@ -523,16 +505,16 @@ static int l_registerannot(lua_State * L
     int n, i;
     n = lua_gettop(L);
     switch (n) {
-        case 1:
-            if (global_shipping_mode == NOT_SHIPPING)
-                luaL_error(L, "pdf.registerannot() can only be used in late lua");
-            i = (int) luaL_checkinteger(L, 1);
-            if (i <= 0)
-                luaL_error(L, "pdf.registerannot() can only register positive object numbers");
-            addto_page_resources(static_pdf, obj_type_annot, i);
-            break;
-        default:
-            luaL_error(L, "pdf.registerannot() needs exactly 1 argument");
+    case 1:
+        if (global_shipping_mode == NOT_SHIPPING)
+            luaL_error(L, "pdf.registerannot() can only be used in late lua");
+        i = (int) luaL_checkinteger(L, 1);
+        if (i <= 0)
+            luaL_error(L, "pdf.registerannot() can only register positive object numbers");
+        addto_page_resources(static_pdf, obj_type_annot, i);
+        break;
+    default:
+        luaL_error(L, "pdf.registerannot() needs exactly 1 argument");
     }
     return 0;
 }
@@ -617,30 +599,55 @@ static int l_set_xformresources (lua_Sta
 static int l_set_xformattributes(lua_State * L) { l_set_pdf_value(xformattributes); }
 static int l_set_trailerid      (lua_State * L) { l_set_pdf_value(trailerid); }
 
-static int getpdfobjtype(lua_State * L)
+/*
+
+static int setpdf(lua_State * L)
 {
-    if (lua_type(L, 1) == LUA_TNUMBER) {
-        int n = (int) lua_tointeger(L, 1);
-        if (n > 0 && n <= static_pdf->obj_ptr) {
-            lua_pushstring(L, pdf_obj_typenames[obj_type(static_pdf, n)]);
-            return 1;
+    const char *s ;
+    if (lua_gettop(L) != 3) {
+        return 0;
+    }
+    if (lua_type(L, -2) == LUA_TSTRING) {
+        s = lua_tostring(L, -1);
+        if (valid_pdf_key) {
+            lua_get_metatablelua(pdf_data);
+            lua_replace(L, -4);
         }
     }
-    lua_pushnil(L);
+    lua_rawset(L, -3);
+    return 0;
+}
+
+*/
+
+static int l_objtype(lua_State * L)
+{
+    int n = lua_gettop(L);
+    if (n != 1)
+        luaL_error(L, "pdf.objtype() needs exactly 1 argument");
+    n = (int) luaL_checkinteger(L, 1);
+    if (n < 0 || n > static_pdf->obj_ptr)
+        lua_pushnil(L);
+    else
+        lua_pushstring(L, pdf_obj_typenames[obj_type(static_pdf, n)]);
     return 1;
 }
 
-static int getpdfmaxobjnum(lua_State * L)
+static int l_maxobjnum(lua_State * L)
 {
+    int n = lua_gettop(L);
+    if (n != 0)
+        luaL_error(L, "pdf.maxobjnum() needs 0 arguments");
     lua_pushinteger(L, static_pdf->obj_ptr);
     return 1;
 }
 
 static int l_mapfile(lua_State * L)
 {
+    char *s;
     const char *st;
-    if ((lua_type(L, 1) == LUA_TSTRING) && (st = lua_tostring(L, 1)) != NULL) {
-        char *s = xstrdup(st);
+    if ((lua_type(L,-1) == LUA_TSTRING) && (st = lua_tostring(L, -1)) != NULL) {
+        s = xstrdup(st);
         process_map_item(s, MAPFILE);
         free(s);
     }
@@ -649,15 +656,29 @@ static int l_mapfile(lua_State * L)
 
 static int l_mapline(lua_State * L)
 {
+    char *s;
     const char *st;
-    if ((lua_type(L, 1) == LUA_TSTRING) && (st = lua_tostring(L, 1)) != NULL) {
-        char *s = xstrdup(st);
+    if ((lua_type(L,-1) == LUA_TSTRING) && (st = lua_tostring(L, -1)) != NULL) {
+        s = xstrdup(st);
         process_map_item(s, MAPLINE);
         free(s);
     }
     return 0;
 }
 
+static int l_pageref(lua_State * L)
+{
+    int n = lua_gettop(L);
+    if (n != 1)
+        luaL_error(L, "pdf.pageref() needs exactly 1 argument");
+    n = (int) luaL_checkinteger(L, 1);
+    if (n <= 0)
+        luaL_error(L, "pdf.pageref() needs page number > 0");
+    n = pdf_get_obj(static_pdf, obj_type_page, n, false);
+    lua_pushinteger(L, n);
+    return 1;
+}
+
 static int l_getpos(lua_State * L)
 {
     lua_pushinteger(L, static_pdf->posstruct->pos.h);
@@ -749,12 +770,6 @@ static int l_get_obj_compress_level(lua_
     return 1 ;
 }
 
-static int l_get_recompress(lua_State * L)
-{
-    lua_pushinteger(L, (pdf_recompress));
-    return 1 ;
-}
-
 static int l_set_compress_level(lua_State * L)
 {
     if (lua_type(L, 1) == LUA_TNUMBER) {
@@ -781,19 +796,6 @@ static int l_set_obj_compress_level(lua_
     return 0 ;
 }
 
-    static int l_set_recompress(lua_State * L)
-{
-    if (lua_type(L, 1) == LUA_TNUMBER) {
-        int c = (int) lua_tointeger(L, 1);
-        if (c<0)
-            c = 0 ;
-        else if (c>9)
-            c = 9 ;
-        set_pdf_recompress(c);
-    }
-    return 0 ;
-}
-
 /* fonts */
 
 static int getpdfgentounicode(lua_State * L)
@@ -824,18 +826,6 @@ static int setpdfomitcidset(lua_State *
     return 0 ;
 }
 
-/* for tracing purposes when no pages are flushed */
-
-static int setforcefile(lua_State * L)
-{
-    if (lua_type(L, 1) == LUA_TBOOLEAN) {
-        static_pdf->force_file = lua_toboolean(L,1);
-    } else {
-        static_pdf->force_file = 0;
-    }
-    return 0 ;
-}
-
 /* accuracy */
 
 static int l_get_decimal_digits(lua_State * L)
@@ -889,10 +879,9 @@ static int getpdffontname(lua_State * L)
     int c, ff ;
     if (lua_type(L, 1) == LUA_TNUMBER) {
         c = (int) lua_tointeger(L, 1);
-     /* pdf_check_vf(c); */
-        if (!font_used(c)) {
+        pdf_check_vf(c);
+        if (!font_used(c))
             pdf_init_font(static_pdf,c);
-        }
         set_ff(c);
         lua_pushinteger(L, (obj_info(static_pdf, pdf_font_num(ff))));
     } else {
@@ -906,10 +895,9 @@ static int getpdffontobjnum(lua_State *
     if (lua_type(L, 1) == LUA_TNUMBER) {
         int ff;
         int c = (int) lua_tointeger(L, 1);
-     /* pdf_check_vf(c); */
-        if (!font_used(c)) {
+        pdf_check_vf(c);
+        if (!font_used(c))
             pdf_init_font(static_pdf,c);
-        }
         set_ff(c);
         lua_pushinteger(L, (pdf_font_num(ff)));
     } else {
@@ -929,19 +917,21 @@ static int getpdffontsize(lua_State * L)
     return 1 ;
 }
 
+/*
+
 static int getpdfpageref(lua_State * L)
 {
     if (lua_type(L, 1) == LUA_TNUMBER) {
         int c = (int) lua_tointeger(L, 1);
-        if (c > 0) {
-            lua_pushinteger(L, (pdf_get_obj(static_pdf, obj_type_page, c, false)));
-            return 1;
-        }
+        lua_pushinteger(L, (pdf_get_obj(static_pdf, obj_type_page, c, false)));
+    } else {
+        lua_pushnil(L);
     }
-    lua_pushnil(L);
     return 1 ;
 }
 
+*/
+
 static int getpdfxformname(lua_State * L)
 {
     if (lua_type(L, 1) == LUA_TNUMBER) {
@@ -954,6 +944,12 @@ static int getpdfxformname(lua_State * L
     return 1 ;
 }
 
+static int getpdfversion(lua_State * L)
+{
+    lua_pushinteger(L,1);
+    return 1 ;
+}
+
 static int getpdfcreationdate(lua_State * L)
 {
     initialize_start_time(static_pdf);
@@ -1173,76 +1169,6 @@ static int l_set_font_attributes(lua_Sta
     return 0;
 }
 
-static int pdfincludechar(lua_State * L)
-{
-    int f = lua_tointeger(L, 1);
-    if (lua_type(L,2) == LUA_TTABLE) {
-        int i, c;
-        int n = lua_rawlen(L, 2);
-        for (i=1; i<=n; i++) {
-            lua_rawgeti(L, 2, i);
-            c = lua_tointeger(L, 3);
-            pdf_mark_char(f,c);
-            lua_pop(L, 1);
-        }
-    } else {
-        int c = lua_tointeger(L, 2);
-        pdf_mark_char(f,c);
-    }
-    return 0;
-}
-
-static int pdfincludefont(lua_State * L)
-{
-    int f = lua_tointeger(L, 1);
-    pdf_init_font(static_pdf,f);
-    return 0;
-}
-
-static int pdfincludeimage(lua_State * L)
-{
-    /*tex How to check for a valid entry? */
-    image_dict *idict = idict_array[lua_tointeger(L,1)];
-    int objnum = img_objnum(idict);
-    if (img_state(idict) < DICT_OUTIMG) {
-        img_state(idict) = DICT_OUTIMG;
-    }
-    if (! is_obj_written(static_pdf, objnum)) {
-        pdf_write_image(static_pdf, objnum);
-    }
-    lua_pushinteger(L,img_type(idict));
-    lua_pushinteger(L,img_xorig(idict));
-    lua_pushinteger(L,img_yorig(idict));
-    lua_pushinteger(L,img_xsize(idict));
-    lua_pushinteger(L,img_ysize(idict));
-    lua_pushinteger(L,img_rotation(idict));
-    lua_pushinteger(L,objnum);
-    if (img_type(idict) == IMG_TYPE_PNG) {
-        lua_pushinteger(L,img_group_ref(idict));
-    } else {
-        lua_pushnil(L);
-    }
-    return 8;
-}
-
-static int getpdfnofobjects(lua_State * L)
-{
-    int k;
-    int written = 0;
-    int dropped = 0;
-    for (k = 1; k <= static_pdf->obj_ptr; k++) {
-        if (is_obj_written(static_pdf, k)) {
-            written += 1;
-        } else {
-            dropped += 1;
-        }
-    }
-    lua_pushinteger(L,written);
-    lua_pushinteger(L,dropped);
-    return 2;
-}
-
-/*tex For normal output see |pdflistout.c|: */
 
 static const struct luaL_Reg pdflib[] = {
     { "gethpos", l_gethpos },
@@ -1253,10 +1179,11 @@ static const struct luaL_Reg pdflib[] =
     { "registerannot", l_registerannot },
     { "reserveobj", l_reserveobj },
     { "getpos", l_getpos },
-    { "getpageref", getpdfpageref },
-    { "getmaxobjnum", getpdfmaxobjnum },
+ /* { "pageref", getpdfpageref }, */
+    { "maxobjnum", l_maxobjnum },
+    { "pageref", l_pageref },
     { "print", luapdfprint },
-    { "getobjtype", getpdfobjtype },
+    { "objtype", l_objtype },
     { "getmatrix", l_getmatrix },
     { "hasmatrix", l_hasmatrix },
     { "setfontattributes", l_set_font_attributes },
@@ -1286,20 +1213,20 @@ static const struct luaL_Reg pdflib[] =
     { "getlastannot", l_get_lastannot },
     { "getcompresslevel", l_get_compress_level },
     { "getobjcompresslevel", l_get_obj_compress_level },
-    { "getrecompress", l_get_recompress },
     { "setcompresslevel", l_set_compress_level },
     { "setobjcompresslevel", l_set_obj_compress_level },
-    { "setrecompress", l_set_recompress },
     { "getdecimaldigits", l_get_decimal_digits },
     { "setdecimaldigits", l_set_decimal_digits },
     { "getpkresolution", l_get_pk_resolution },
     { "setpkresolution", l_set_pk_resolution },
     { "getsuppressoptionalinfo", l_get_suppress_optional_info },
     { "setsuppressoptionalinfo", l_set_suppress_optional_info },
-    { "getfontname", getpdffontname },
-    { "getfontobjnum", getpdffontobjnum },
-    { "getfontsize", getpdffontsize },
-    { "getxformname", getpdfxformname },
+    /* moved from tex table */
+    { "fontname", getpdffontname },
+    { "fontobjnum", getpdffontobjnum },
+    { "fontsize", getpdffontsize },
+    { "xformname", getpdfxformname },
+    { "getversion", getpdfversion },
     { "getcreationdate", getpdfcreationdate },
     { "getmajorversion", getpdfmajorversion },
     { "setmajorversion", setpdfmajorversion },
@@ -1326,22 +1253,8 @@ static const struct luaL_Reg pdflib[] =
     { "setignoreunknownimages", setpdfignoreunknownimages },
     { "setgentounicode", setpdfgentounicode },
     { "setomitcidset", setpdfomitcidset },
-    { "setforcefile", setforcefile },
     { "mapfile", l_mapfile },
     { "mapline", l_mapline },
-    { "includechar", pdfincludechar },
-    { "includefont", pdfincludefont },
-    /* might go, used when sanitizing backend */
-    { "includeimage", pdfincludeimage },
-    { "getnofobjects", getpdfnofobjects },
-    /* for a while */
-    { "maxobjnum", getpdfmaxobjnum },
-    { "pageref", getpdfpageref },
-    { "objtype", getpdfobjtype },
-    { "fontname", getpdffontname },
-    { "fontobjnum", getpdffontobjnum },
-    { "fontsize", getpdffontsize },
-    { "xformname", getpdfxformname },
     /* sentinel */
     {NULL, NULL}
 };
--- texlive-bin.orig/texk/web2c/luatexdir/lua/lpdfscannerlib.cc
+++ texlive-bin/texk/web2c/luatexdir/lua/lpdfscannerlib.cc
@@ -17,70 +17,6 @@
    You should have received a copy of the GNU General Public License along
    with LuaTeX; if not, see <http://www.gnu.org/licenses/>. */
 
-/* converted example in manual:
-
-local operatortable = { }
-
-operatortable.Do = function(scanner,info)
-    local resources = info.resources
-    if resources then
-        local val     = scanner:pop()
-        local name    = val[2]
-        local xobject = pdfe.dictionarytotable(resources.XObject[2])
-        print(info.space .. "Uses XObject " .. name)
-        local kind,
-              entry  = unpack(xobject[name])
-        local dict
-        if kind == 10 then -- reference
-            kind,
-            entry,
-            dict = pdfe.getfromreference(entry)
-        end
-        if kind == 9 then -- stream
-            dict = pdfe.dictionarytotable(dict)
-            local resources = dict.Resources
-            if resources then
-                local newinfo =  {
-                    space     = info.space .. "  " ,
-                    resources = Resources[2],
-                }
-                pdfscanner.scan(entry, operatortable, newinfo)
-            end
-        end
-    end
-end
-
-local function Analyze(filename)
-    local doc = pdfe.open(filename)
-    if doc then
-        local pagenum  = 1
-        local n        = 1 -- pdfe.getnofpages(doc)
-        for i=1,n do
-            local page = pdfe.getpage(doc,i)
-            local kind,
-                  data = pdfe.getfromdictionarybyname(page,"Resources")
-            if kind == 10 then -- reference
-                kind, data = pdfe.getfromreference(data)
-            end
-            data = pdfe.dictionarytotable(data)
-            local info = {
-              space     = "  " ,
-              resources = data,
-            }
-            print("Page " .. i)
-            kind, data = pdfe.getfromdictionarybyname(page,"Contents")
-            if kind == 10 then -- reference
-                kind, data = pdfe.getfromreference(data)
-            end
-            pdfscanner.scan(data,operatortable,info)
-        end
-    end
-end
-
-Analyze("e:/tmp/oeps.pdf")
-
-*/
-
 #  include <stdlib.h>
 #  include <stdio.h>
 #  include <stdarg.h>
@@ -92,10 +28,27 @@ extern "C" {
 #  include <lua.h>
 #  include <lauxlib.h>
 #  include <lualib.h>
-
-#  include "luapplib/pplib.h"
 }
 
+#  include <poppler-config.h>
+#  include <goo/GooString.h>
+#  include <goo/gmem.h>
+#  include <goo/gfile.h>
+#  include <Object.h>
+#  include <Stream.h>
+#  include <Gfx.h>
+#  include <Annot.h>
+#  include <Array.h>
+#  include <Dict.h>
+#  include <XRef.h>
+#  include <Catalog.h>
+#  include <Link.h>
+#  include <Page.h>
+#  include <GfxFont.h>
+#  include <PDFDoc.h>
+#  include <GlobalParams.h>
+#  include <Error.h>
+
 #  include <lua/luatex-api.h>
 
 
@@ -104,47 +57,48 @@ extern "C" {
 #define MAXOPERANDS 1000
 
 typedef enum {
-    pdf_integer = 1,
-    pdf_real,
-    pdf_boolean,
-    pdf_name,
-    pdf_operator,
-    pdf_string,
-    pdf_startarray,
-    pdf_stoparray,
-    pdf_startdict,
-    pdf_stopdict,
+  pdf_integer = 1,
+  pdf_real,
+  pdf_boolean,
+  pdf_name,
+  pdf_operator,
+  pdf_string,
+  pdf_startarray,
+  pdf_stoparray,
+  pdf_startdict,
+  pdf_stopdict,
 } pdf_token_type ;
 
+
 typedef struct Token {
-    pdf_token_type type;
-    double value;
-    char *string;
+  pdf_token_type type;
+  double value;
+  char *string;
 } Token;
 
 typedef struct ObjectList {
-    struct ObjectList *next;
-    ppstream *stream;
+  struct ObjectList *next;
+  Object *stream;
 } ObjectList;
 
 typedef struct scannerdata {
-    int _ininlineimage;
-    int _nextoperand;
-    Token ** _operandstack;
-    ppstream * _stream;
-    ObjectList * _streams;
-    const char *buffer;
-    size_t position;
-    size_t size;
+  int _ininlineimage;
+  int _nextoperand;
+  Token ** _operandstack;
+  Object * _stream;
+  ObjectList * _streams;
 } scannerdata;
 
-#define PDFE_METATABLE_ARRAY  "luatex.pdfe.array"
-#define PDFE_METATABLE_STREAM "luatex.pdfe.stream"
+typedef enum { ALLOC_POPPLER, ALLOC_LEPDF } alloctype;
+
+#define M_Object           "Object"
+#define M_Stream           "Stream"
 
 typedef struct {
     void *d;
+    alloctype atype;            // was it allocated by poppler or the lepdflib.cc?
     void *pd;            // reference to PdfDocument, or NULL
-    unsigned long pc;    // counter to detect PDFDoc change
+    unsigned long pc;           // counter to detect PDFDoc change
 } udstruct;
 
 static void clear_operand_stack (scannerdata *self, int from);
@@ -165,8 +119,8 @@ static void *priv_xrealloc (void *old_pt
 {
     void *new_mem = (void *)realloc(old_ptr, size);
     if (new_mem == NULL) {
-        fprintf(stderr,"fatal: memory exhausted (realloc of %lu bytes).\n", (unsigned long)size);
-        exit(EXIT_FAILURE);
+      fprintf(stderr,"fatal: memory exhausted (realloc of %lu bytes).\n", (unsigned long)size);
+      exit(EXIT_FAILURE);
     }
     return new_mem;
 }
@@ -175,20 +129,20 @@ static void *priv_xrealloc (void *old_pt
 
 #define INITBUFSIZE 64
 
-#define define_buffer(a) \
-  char *a = (char *)priv_xmalloc (INITBUFSIZE); \
-  int a##_size = INITBUFSIZE; \
-  int a##index = 0; \
+#define define_buffer(a)				\
+  char *a = (char *)priv_xmalloc (INITBUFSIZE);		\
+  int a##_size = INITBUFSIZE;				\
+  int a##index = 0;					\
   memset (a,0,INITBUFSIZE)
 
-#define check_overflow(a, wsize) do { \
-    if (wsize >= a##_size) { \
-        int nsize = a##_size + a##_size / 4; \
-        a = (char *) xreallocarray(a, char, (unsigned) nsize); \
-        memset (a+a##_size, 0, a##_size / 4); \
-        a##_size = nsize; \
-    } \
-} while (0)
+#define check_overflow(a, wsize) do {					\
+    if (wsize >= a##_size) {						\
+      int nsize = a##_size + a##_size / 4;				\
+      a = (char *) xreallocarray(a, char, (unsigned) nsize);		\
+      memset (a+a##_size, 0, a##_size / 4);				\
+      a##_size = nsize;							\
+    }									\
+  } while (0)
 
 
 static scannerdata * scanner_push(lua_State * L)
@@ -201,814 +155,769 @@ static scannerdata * scanner_push(lua_St
 
 static scannerdata *scanner_check (lua_State *L, int index)
 {
-    scannerdata *bar;
-    luaL_checktype(L, index, LUA_TUSERDATA);
-    bar = (scannerdata *)luaL_checkudata(L, index, SCANNER);
-    if (bar == NULL)
-        luaL_argerror(L, index, SCANNER " expected");
-    return bar;
+  scannerdata *bar;
+  luaL_checktype(L, index, LUA_TUSERDATA);
+  bar = (scannerdata *)luaL_checkudata(L, index, SCANNER);
+  if (bar == NULL) luaL_argerror(L, index, SCANNER " expected");
+  return bar;
 }
 
 static void free_token (Token *token)
 {
-    if (token->string) {
-        free(token->string);
-    }
-    free(token);
+  if (token->string) {
+    free(token->string);
+  }
+  free(token);
 }
 
 static void clear_operand_stack (scannerdata *self, int from)
 {
-    int i = self->_nextoperand-1;
-        while (i>=from) {
-            if (self->_operandstack[i]) {
-            free_token(self->_operandstack[i]);
-            self->_operandstack[i] = NULL;
-        }
-        i--;
-    }
-    self->_nextoperand = from;
+  int i = self->_nextoperand-1;
+  while (i>=from) {
+    if (self->_operandstack[i]) {
+      free_token(self->_operandstack[i]);
+      self->_operandstack[i] = NULL;
+    }
+    i--;
+  }
+  self->_nextoperand = from;
 }
 
 static void push_operand (scannerdata *self, Token *token)
 {
-    if (self->_nextoperand+1> MAXOPERANDS) {
-        fprintf(stderr, "out of operand stack space");
-        exit(1);
-    }
-    self->_operandstack[self->_nextoperand++] = token;
+  if (self->_nextoperand+1> MAXOPERANDS) {
+    fprintf(stderr, "out of operand stack space");
+    exit(1);
+  }
+  self->_operandstack[self->_nextoperand++] = token;
 }
 
 static Token * new_operand (pdf_token_type c)
 {
-    Token *token = (Token *)priv_xmalloc(sizeof(Token));
-    memset (token, 0, sizeof(Token));
-    token->type = c;
-    return token;
-}
-
-static void _nextStream (scannerdata *self)
-{
-    if (self->buffer != NULL) {
-        ppstream_done(self->_stream);
-    }
-    ObjectList *rover = self->_streams;
-    self->_stream = rover->stream;
-    self->buffer = (const char*) ppstream_all(self->_stream,&self->size,1);
-    self->position = 0;
-    self->_streams = rover->next;
-    free(rover);
+  Token *token = (Token *)priv_xmalloc(sizeof(Token));
+  memset (token, 0, sizeof(Token));
+  token->type = c;
+  return token;
+}
+
+static void _nextStream (scannerdata *self) {
+  self->_stream->streamClose();
+  ObjectList *rover = self->_streams;
+  self->_stream = rover->stream;
+  self->_stream->streamReset();
+  self->_streams = rover->next;
+  free(rover);
+}
+
+static int streamGetChar (scannerdata *self) {
+  int i = self->_stream->streamGetChar();
+  if (i<0 && self->_streams) {
+    _nextStream(self);
+    i = streamGetChar(self);
+  }
+  return i;
+}
+
+static int streamLookChar (scannerdata *self) {
+  int i= self->_stream->streamLookChar();
+  if (i<0 && self->_streams) {
+    _nextStream(self);
+    i = streamLookChar(self);
+  }
+  return i;
 }
 
-static int streamGetChar (scannerdata *self)
-{
-    int i = EOF ;
-    if (self->position < self->size) {
-        const char c = self->buffer[self->position];
-        ++self->position;
-        i = (int) c;
-    }
-    if (i<0 && self->_streams) {
-        _nextStream(self);
-        i = streamGetChar(self);
-    }
-    return i;
-}
-
-static int streamLookChar (scannerdata *self)
-{
-    int i = EOF ;
-    if (self->position < self->size) {
-        const char c = self->buffer[self->position];
-     /* ++self->position; */
-        i = (int) c;
-    }
-    if (i<0 && self->_streams) {
-        _nextStream(self);
-        i = streamGetChar(self);
-    }
-    return i;
-}
-
-static void streamReset (scannerdata *self)
-{
-    self->buffer = (const char*) ppstream_all(self->_stream,&self->size,1);
-    self->position = 0;
-}
-
-static void streamClose (scannerdata *self) {
-    ppstream_done(self->_stream);
-    self->buffer = NULL;
-    self->_stream = NULL;
-}
-
-/* end of stream interface */
-
 static Token * _parseSpace (scannerdata *self)
 {
-    return _parseToken (self,streamGetChar(self));
+  return _parseToken (self,streamGetChar(self));
 }
 
 static Token * _parseString (scannerdata *self, int c)
 {
-    define_buffer(found);
-    int level = 1;
-    while (1) {
-        c = streamGetChar(self);
-        if (c == '(') {
-            level = level + 1 ;
-        } else if (c == ')') {
-            level = level - 1 ;
-            if (level < 1) break;
-        } else if (c == '\\') {
-            int next = streamGetChar(self);
-            if (next == '(' || next == ')' || next == '\\') {
-                c = next;
-            } else if (next == '\n' || next == '\r') {
-                c = '\0';
-            } else if (next == 'n') {
-                c = '\n';
-            } else if (next == 'r') {
-                c = '\r';
-            } else if (next == 't') {
-                c = '\t';
-            } else if (next == 'b') {
-                c = '\b';
-            } else if (next == 'f') {
-                c = '\f';
-            } else if (next >= '0' && next <= '7') {
-                next = next - '0';
-                int next2 = streamLookChar(self);
-                if (next2 >= '0' && next2 <= '7') {
-                    next2 = streamGetChar(self);
-                    next2 = next2 - '0';
-                    int next3 = streamLookChar(self);
-                    if (next3 >= '0' && next3 <= '7') {
-                        next3 = streamGetChar(self);
-                        next3 = next3 - '0';
-                        c = (next*64+next2*8+next3);
-                    } else {
-                        c = (next*8+next2);
-                    }
-                } else {
-                    c = next;
-                }
-            } else {
-                c = next;
-            }
-        }
-        check_overflow(found,foundindex);
-        if (c>=0) {
-            found[foundindex++] = c;
-        }
+  //   local token = {type = pdf_string,value = ''}
+  define_buffer(found);
+  int level = 1;
+  while (1) {
+    c = streamGetChar(self);
+    if (c == '(') {
+      level = level + 1 ;
     }
-    Token *token = new_operand(pdf_string);
-    token->value = foundindex;
-    token->string = found;
-    return token;
+    if (c == ')') {
+      level = level - 1 ;
+      if (level < 1) break;
+    }
+    if (c == '\\') {
+      int next = streamGetChar(self);
+      if (next == '(' || next == ')' || next == '\\') {
+	c = next;
+      } else if (next == '\n' || next == '\r') {
+	c = '\0';
+      } else if (next == 'n') {
+	c = '\n';
+      } else if (next == 'r') {
+	c = '\r';
+      } else if (next == 't') {
+	c = '\t';
+      } else if (next == 'b') {
+	c = '\b';
+      } else if (next == 'f') {
+	c = '\f';
+      } else if (next >= '0' && next <= '7') {
+	next = next - '0';
+ 	int next2 = streamLookChar(self);
+	if (next2 >= '0' && next2 <= '7') {
+	  next2 = streamGetChar(self);
+	  next2 = next2 - '0';
+	  int next3 = streamLookChar(self);
+	  if (next3 >= '0' && next3 <= '7') {
+	    next3 = streamGetChar(self);
+	    next3 = next3 - '0';
+	    c = (next*64+next2*8+next3);
+	  } else {
+	    c = (next*8+next2);
+	  }
+	} else {
+	  c = next;
+	}
+      } else {
+	c = next;
+      }
+    }
+    check_overflow(found,foundindex);
+    if (c>=0) {
+      found[foundindex++] = c;
+    }
+  }
+  Token *token = new_operand(pdf_string);
+  token->value = foundindex;
+  token->string = found;
+  return token;
 }
 
+
 static Token * _parseNumber (scannerdata *self, int c)
 {
-    double value = 0;
-    pdf_token_type type = pdf_integer;
-    int isfraction = 0;
-    int isnegative = 0;
-    int i = 0;
-    if (c == '-') {
-        isnegative = 1;
-        c = streamGetChar(self);
-    }
-    if (c == '.') {
-        type = pdf_real;
-        isfraction = 1;
-    } else  {
-        value = c - '0';
-    }
-    c = streamLookChar(self);
-    if ((c>= '0'&&  c<= '9') || c == '.') {
-        c = streamGetChar(self);
-        while (1) {
-            if (c == '.') {
-                type = pdf_real;
-                isfraction = 1;
-            } else {
-                i = c - '0';
-                if (isfraction>0) {
-                    value = value + (i/(pow(10.0,isfraction)));
-                    isfraction = isfraction + 1;
-                } else {
-                    value = (value * 10) + i;
-                }
-            }
-            c = streamLookChar(self);
-            if (! ((c>= '0' && c<= '9') ||  c == '.'))
-                break ;
-            c = streamGetChar(self);
-        }
-    }
-    if (isnegative) {
-        value = -value;
-    }
-    Token *token = new_operand(type);
-    token->value = value;
-    return token;
+  double value = 0;
+  pdf_token_type type = pdf_integer;
+  int isfraction = 0;
+  int isnegative = 0;
+  int i = 0;
+  if (c == '-') {
+    isnegative = 1;
+    c = streamGetChar(self);
+  }
+  if (c == '.') {
+    type = pdf_real;
+    isfraction = 1;
+  } else  {
+    value = c - '0';
+  }
+  c = streamLookChar(self);
+  if ((c>= '0'&&  c<= '9') || c == '.') {
+    c = streamGetChar(self);
+    while (1) {
+      if (c == '.') {
+	type = pdf_real;
+	isfraction = 1;
+      } else {
+	i = c - '0';
+	if (isfraction>0) {
+	  value = value + (i/(pow(10.0,isfraction)));
+	  isfraction = isfraction + 1;
+	} else {
+	  value = (value * 10) + i;
+	}
+      }
+      c = streamLookChar(self);
+      if (! ((c>= '0' && c<= '9') ||  c == '.')) break ;
+      c = streamGetChar(self);
+    }
+  }
+  if (isnegative) {
+    value = -value;
+  }
+  Token *token = new_operand(type);
+  token->value = value;
+  return token;
 }
 
+
 static Token *_parseName (scannerdata *self, int c)
 {
-    define_buffer(found);
+  define_buffer(found);
+  c = streamGetChar(self);
+  while (1) {
+    check_overflow(found,foundindex);
+    found[foundindex++] = c;
+    c = streamLookChar(self);
+    if (c == ' ' || c == '\n' || c == '\r' || c == '\t' ||
+	c == '/' || c == '[' || c == '(' || c == '<') break ;
     c = streamGetChar(self);
-    while (1) {
-        check_overflow(found,foundindex);
-        found[foundindex++] = c;
-        c = streamLookChar(self);
-        if (c == ' ' || c == '\n' || c == '\r' || c == '\t' ||
-            c == '/' || c == '[' || c == '(' || c == '<') break ;
-        c = streamGetChar(self);
-    }
-    Token *token = new_operand(pdf_name);
-    token->string = found;
-    token->value = strlen(found);
-    return token;
+  }
+  Token *token = new_operand(pdf_name);
+  token->string = found;
+  token->value = strlen(found);
+  return token;
 }
 
-#define hexdigit(c)	\
+#define hexdigit(c)							\
   (c>= '0' && c<= '9') ? (c - '0') : ((c>= 'A' && c<= 'F') ? (c - 'A' + 10) : (c - 'a' + 10))
 
 static Token *_parseHexstring (scannerdata *self, int c)
 {
-    int isodd = 1;
-    int hexval = 0;
-    define_buffer(found);
-    while (c != '>') {
-        if ((c>= '0' && c<= '9') || (c>= 'A' && c<= 'F') || (c>= 'a' && c<= 'f')) {
-            if (isodd==1) {
-                int v = hexdigit(c);
-                hexval = 16 * v;
-            } else {
-                hexval += hexdigit(c);
-                check_overflow(found,foundindex);
-                found[foundindex++] = hexval;
-            }
-            isodd = (isodd==1 ? 0 : 1);
-        }
-        c = streamGetChar(self);
+  int isodd = 1;
+  int hexval = 0;
+  define_buffer(found);
+  while (c != '>') {
+    if ((c>= '0' && c<= '9') ||
+	(c>= 'A' && c<= 'F') ||
+	(c>= 'a' && c<= 'f')) {
+      if (isodd==1) {
+	int v = hexdigit(c);
+	hexval = 16 * v;
+      } else {
+	hexval += hexdigit(c);
+	check_overflow(found,foundindex);
+	found[foundindex++] = hexval;
+      }
+      isodd = (isodd==1 ? 0 : 1);
     }
-    Token *token = new_operand(pdf_string);
-    token->value = foundindex;
-    token->string = found;
-    return token;
+    c = streamGetChar(self);
+  }
+  Token *token = new_operand(pdf_string);
+  token->value = foundindex;
+  token->string = found;
+  return token;
 }
 
 #define pdf_isspace(a) (a == '\0' || a == ' ' || a == '\n' || a == '\r' || a == '\t' || a == '\v')
 
 // -- this is rather horrible
-
 static Token *_parseInlineImage (scannerdata *self, int c)
 {
-    define_buffer(found);
-    if (c == ' ') { // first space can be ignored
-        c = streamGetChar(self);
-    }
-    check_overflow(found, foundindex);
-    found[foundindex++] = c;
-    while (1) {
-        c = streamLookChar(self);
-        if (c == 'E' && (found[foundindex-1] == '\n' || found[foundindex-1] == '\r')) {
-            c = streamGetChar(self);
-            check_overflow(found, foundindex);
-            found[foundindex++] = c;
-            c = streamLookChar(self);
-            if (c == 'I') {
-                c = streamGetChar(self);
-                check_overflow(found, foundindex);
-                found[foundindex++] = c;
-                c = streamLookChar(self);
-                if (pdf_isspace(c)) {
-                    found[--foundindex] = '\0'; /* I */
-                    found[--foundindex] = '\0'; /* E */
-                    /* remove end-of-line before EI */
-                    if (found[foundindex-1] == '\n') {
-                        found[--foundindex] = '\0';
-                    }
-                    if (found[foundindex-1] == '\r') {
-                        found[--foundindex] = '\0';
-                    }
-                    break;
-                } else {
-                    c = streamGetChar(self);
-                    check_overflow(found, foundindex);
-                    found[foundindex++] = c;
-                }
-            } else {
-                c = streamGetChar(self);
-                check_overflow(found, foundindex);
-                found[foundindex++] = c;
-            }
-        } else {
-            c = streamGetChar(self);
-            check_overflow(found, foundindex);
-            found[foundindex++] = c;
-        }
-    }
-    Token *token = new_operand(pdf_string);
-    token->value = foundindex;
-    token->string = found;
-    return token;
+  define_buffer(found);
+  if (c == ' ') { // first space can be ignored
+    c = streamGetChar(self);
+  }
+  check_overflow(found, foundindex);
+  found[foundindex++] = c;
+  while (1) {
+    c = streamLookChar(self);
+    if (c == 'E' && (found[foundindex-1] == '\n' || found[foundindex-1] == '\r')) {
+      c = streamGetChar(self);
+      check_overflow(found, foundindex);
+      found[foundindex++] = c;
+      c = streamLookChar(self);
+      if (c == 'I') {
+	c = streamGetChar(self);
+	check_overflow(found, foundindex);
+	found[foundindex++] = c;
+	c = streamLookChar(self);
+	if (pdf_isspace(c)) {
+	  found[--foundindex] = '\0'; /* I */
+	  found[--foundindex] = '\0'; /* E */
+	  /* remove end-of-line before EI */
+	  if (found[foundindex-1] == '\n') {
+	    found[--foundindex] = '\0';
+	  }
+	  if (found[foundindex-1] == '\r') {
+	    found[--foundindex] = '\0';
+	  }
+	  break;
+	} else {
+	  c = streamGetChar(self);
+	  check_overflow(found, foundindex);
+	  found[foundindex++] = c;
+	}
+      } else {
+	c = streamGetChar(self);
+	check_overflow(found, foundindex);
+	found[foundindex++] = c;
+      }
+    } else {
+      c = streamGetChar(self);
+      check_overflow(found, foundindex);
+      found[foundindex++] = c;
+    }
+  }
+  Token *token = new_operand(pdf_string);
+  token->value = foundindex;
+  token->string = found;
+  return token;
 }
 
 static Token *_parseOperator (scannerdata *self, int c)
 {
-    define_buffer(found);
-    while (1) {
-        check_overflow(found, foundindex);
-        found[foundindex++] = c;
-        c = streamLookChar(self);
-        if ((c<0) || (c == ' ' || c == '\n' || c == '\r' || c == '\t' ||
-                c == '/' || c == '[' || c == '(' || c == '<'))
-            break ;
-        c = streamGetChar(self);
-    }
-    // print (found)
-    if (strcmp(found, "ID") == 0) {
-        self->_ininlineimage = 1;
-    }
-    if (strcmp(found,"false") == 0) {
-        Token *token = new_operand(pdf_boolean);
-        token->value = 0;
-        free(found);
-        return token;
-    } else if (strcmp(found,"true") == 0) {
-        Token *token = new_operand(pdf_boolean);
-        token->value = 1.0;
-        free(found);
-        return token;
-    } else {
-        Token *token = new_operand(pdf_operator);
-        token->string = found;
-        return token;
-    }
+  define_buffer(found);
+  while (1) {
+    check_overflow(found, foundindex);
+    found[foundindex++] = c;
+    c = streamLookChar(self);
+    if ((c<0) || (c == ' ' || c == '\n' || c == '\r' || c == '\t' ||
+		  c == '/' || c == '[' || c == '(' || c == '<'))
+      break ;
+    c = streamGetChar(self);
+  }
+  // print (found)
+  if (strcmp(found, "ID") == 0) {
+    self->_ininlineimage = 1;
+  }
+  if (strcmp(found,"false") == 0) {
+    Token *token = new_operand(pdf_boolean);
+    token->value = 0;
+    free(found);
+    return token;
+  } else if (strcmp(found,"true") == 0) {
+    Token *token = new_operand(pdf_boolean);
+    token->value = 1.0;
+    free(found);
+    return token;
+  } else {
+    Token *token = new_operand(pdf_operator);
+    token->string = found;
+    return token;
+  }
 }
 
 
 static Token * _parseComment  (scannerdata *self, int c)
 {
-    do {
-        c = streamGetChar(self);
-    } while (c != '\n' && c != '\r' && c != -1);
-    return _parseToken(self,streamGetChar(self));
+  do {
+    c = streamGetChar(self);
+  } while (c != '\n' && c != '\r' && c != -1);
+  return _parseToken(self,streamGetChar(self));
 }
 
 static Token *_parseLt (scannerdata *self, int c)
 {
-    c = streamGetChar(self);
-    if (c == '<') {
-        return new_operand(pdf_startdict);
-    } else {
-        return _parseHexstring(self,c);
-    }
+  c = streamGetChar(self);
+  if (c == '<') {
+    return new_operand(pdf_startdict);
+  } else {
+    return _parseHexstring(self,c);
+  }
 }
 
 static Token * _parseGt (scannerdata *self, int c)
 {
-    c = streamGetChar(self);
-    if (c== '>') {
-        return new_operand(pdf_stopdict);
-    } else {
-        fprintf(stderr,"stray > in stream");
-        return NULL;
-    }
+  c = streamGetChar(self);
+  if (c== '>') {
+    return new_operand(pdf_stopdict);
+  } else {
+    fprintf(stderr,"stray > in stream");
+    return NULL;
+  }
 }
 
+
 static Token *_parseError (int c)
 {
-    fprintf(stderr, "stray %c [%d] in stream", c, c);
-    return NULL;
+  fprintf(stderr, "stray %c [%d] in stream", c, c);
+  return NULL;
 }
 
 static Token *_parseStartarray ()
 {
-    return new_operand (pdf_startarray);
+  return new_operand (pdf_startarray);
 }
 
 static Token *_parseStoparray ()
 {
-    return new_operand (pdf_stoparray);
+  return new_operand (pdf_stoparray);
 }
 
 
 static Token *_parseToken (scannerdata *self, int c)
 {
-    if (self->_ininlineimage==1) {
-        self->_ininlineimage = 2;
-        return _parseInlineImage(self,c);
-    } else if (self->_ininlineimage==2) {
-        self->_ininlineimage = 0;
-        Token *token = new_operand(pdf_operator);
-        token->string = strdup("EI");
-        return token;
-    }
-    if (c<0)
-        return NULL ;
-    switch (c) {
-        case '(':
-            return _parseString(self,c);
-            break;
-        case ')':
-            return _parseError(c);
-            break;
-        case '[':
-            return _parseStartarray();
-            break;
-        case ']':
-            return _parseStoparray();
-            break;
-        case '/':
-            return _parseName(self,c);
-            break;
-        case '<':
-            return _parseLt(self,c);
-            break;
-        case '>':
-            return _parseGt(self,c);
-            break;
-        case '%':
-            return _parseComment(self,c);
-            break;
-        case ' ':
-        case '\r':
-        case '\n':
-        case '\t':
-            return _parseSpace(self);
-        break;
-        case '0':
-        case '1':
-        case '2':
-        case '3':
-        case '4':
-        case '5':
-        case '6':
-        case '7':
-        case '8':
-        case '9':
-        case '-':
-        case '.':
-            return _parseNumber(self,c);
-        break;
-        default:
-            if (c<=127) {
-                return _parseOperator(self,c);
-            } else {
-                return _parseError(c);
-            }
-    }
+   if (self->_ininlineimage==1) {
+     self->_ininlineimage = 2;
+     return _parseInlineImage(self,c);
+   } else if (self->_ininlineimage==2) {
+     self->_ininlineimage = 0;
+     Token *token = new_operand(pdf_operator);
+     token->string = strdup("EI");
+     return token;
+   }
+   if (c<0)  return NULL ;
+   switch (c) {
+   case '(': return _parseString(self,c); break;
+   case ')': return _parseError(c); break;
+   case '[': return _parseStartarray(); break;
+   case ']': return _parseStoparray(); break;
+   case '/': return _parseName(self,c); break;
+   case '<': return _parseLt(self,c); break;
+   case '>': return _parseGt(self,c); break;
+   case '%': return _parseComment(self,c); break;
+   case ' ':
+   case '\r':
+   case '\n':
+   case '\t':
+     return _parseSpace(self); break;
+   case '0':
+   case '1':
+   case '2':
+   case '3':
+   case '4':
+   case '5':
+   case '6':
+   case '7':
+   case '8':
+   case '9':
+   case '-':
+   case '.':
+     return _parseNumber(self,c); break;
+   default:
+     if (c<=127) {
+       return _parseOperator(self,c);
+     } else {
+       return _parseError(c);
+     }
+   }
 }
 
 static int scanner_scan(lua_State * L)
 {
-    Token *token;
-    scannerdata *self;
-    if (lua_gettop(L) != 3) {
-        return 0;
-    }
-    luaL_checktype(L, 2, LUA_TTABLE);
-    luaL_checktype(L, 3, LUA_TTABLE);
-    self = scanner_push(L);
-    memset(self,0,sizeof(scannerdata));
-    self->_operandstack = (Token **)priv_xmalloc (MAXOPERANDS * sizeof (Token));
-    memset (self->_operandstack,0,(MAXOPERANDS * sizeof (Token)));
-    // 4 = self
-    if (lua_type(L,1)== LUA_TTABLE) {
-        udstruct *uin;
-        void *ud;
-        int i = 1;
-        while (1) {
-            lua_rawgeti(L,1,i);
-            if (lua_type(L,-1)== LUA_TUSERDATA) {
-                ud = luaL_checkudata(L, -1, PDFE_METATABLE_STREAM);
-                if (ud != NULL) {
-                    uin = (udstruct *) ud;
-                    ObjectList *rover = self->_streams;
-                    ObjectList *item = (ObjectList *)priv_xmalloc (sizeof(ObjectList));
-                    item->stream = ((ppstream *) uin->d);
-                    item->next = NULL;
-                    if (!rover) {
-                        rover = item;
-                        self->_streams = rover;
-                    } else {
-                        while (rover->next)
-                            rover = rover->next;
-                        rover->next = item;
-                    }
-                }
-            } else {
-                ObjectList *rover = self->_streams;
-                self->_stream = rover->stream;
-                self->_streams = rover->next;
-                free(rover);
-                lua_pop(L,1);
-                break;
-            }
-            lua_pop(L,1);
-            i++;
-        }
+  Token *token;
+  scannerdata *self;
+  if (lua_gettop(L) != 3) {
+    return 0;
+  }
+  luaL_checktype(L, 2, LUA_TTABLE);
+  luaL_checktype(L, 3, LUA_TTABLE);
+  self = scanner_push(L);
+  memset(self,0,sizeof(scannerdata));
+  self->_operandstack = (Token **)priv_xmalloc (MAXOPERANDS * sizeof (Token));
+  memset (self->_operandstack,0,(MAXOPERANDS * sizeof (Token)));
+  // 4 = self
+  if (lua_type(L,1)== LUA_TTABLE) {
+    udstruct *uin;
+    int i = 1;
+    while (1) {
+      lua_rawgeti(L,1,i);
+      if (lua_type(L,-1)== LUA_TUSERDATA) {
+	uin = (udstruct *) luaL_checkudata(L, -1, M_Object);
+	if (((Object *) uin->d)->isStream()) {
+	  ObjectList *rover = self->_streams;
+	  ObjectList *item = (ObjectList *)priv_xmalloc (sizeof(ObjectList));
+	  item->stream = ((Object *) uin->d);
+	  item->next = NULL;
+	  if (!rover) {
+	    rover = item;
+	    self->_streams = rover;
+	  } else {
+	    while (rover->next)
+	      rover = rover->next;
+	    rover->next = item;
+	  }
+	}
+      } else { // done
+	ObjectList *rover = self->_streams;
+	self->_stream = rover->stream;
+	self->_streams = rover->next;
+	free(rover);
+	lua_pop(L,1);
+	break;
+      }
+      lua_pop(L,1);
+      i++;
+    }
+
+  } else {
+    udstruct *uin;
+    luaL_checktype(L, 1, LUA_TUSERDATA);
+    uin = (udstruct *) luaL_checkudata(L, 1, M_Object);
+    if (((Object *) uin->d)->isStream()) {
+      self->_stream = ((Object *) uin->d);
+    } else if (((Object *) uin->d)->isArray()) {
+      Array *arrayref = ((Object *) uin->d)->getArray();
+      int count = arrayref->getLength();
+      int i;
+      for (i=0;i<count;i++) {
+	Object *val = new Object();
+	*val = arrayref->get(i);
+	if (val->isStream()) {
+	  ObjectList *rover = self->_streams;
+	  ObjectList *item = (ObjectList *)priv_xmalloc (sizeof(ObjectList));
+	  item->stream = val;
+	  item->next = NULL;
+	  if (!rover) {
+	    rover = item;
+	    self->_streams = rover;
+	  } else {
+	    while (rover->next)
+	      rover = rover->next;
+	    rover->next = item;
+	  }
+	}
+      }
+      ObjectList *rover = self->_streams;
+      self->_stream = rover->stream;
+      self->_streams = rover->next;
+    }
+
+  }
+  assert (lua_gettop(L) == 4);
+  self->_stream->streamReset();
+  token = _parseToken(self,streamGetChar(self));
+  while (token) {
+    if (token->type == pdf_operator) {
+      lua_pushstring(L, token->string);
+      free_token(token);
+      lua_rawget(L,2); // operator table
+      if (lua_isfunction(L,-1)) {
+	lua_pushvalue(L,4);
+	lua_pushvalue(L,3);
+	(void)lua_call(L,2,0);
+      } else {
+	lua_pop(L,1); // nil
+      }
+      clear_operand_stack(self,0);
     } else {
-        udstruct *uin;
-        void *ud;
-        luaL_checktype(L, 1, LUA_TUSERDATA);
-        ud = luaL_checkudata(L, 1, PDFE_METATABLE_STREAM);
-        if (ud != NULL) {
-            uin = (udstruct *) ud;
-            self->_stream = ((ppstream *) uin->d);
-        } else {
-            ud = luaL_checkudata(L, 1, PDFE_METATABLE_ARRAY);
-            if (ud != NULL) {
-                uin = (udstruct *) ud;
-                pparray * array = (pparray *) uin->d;
-                int count = array->size;
-                int i;
-                for (i=0;i<count;i++) {
-                    ppobj *obj = pparray_at(array,i);
-                    if (obj->type == PPSTREAM) {
-                        ObjectList *rover = self->_streams;
-                        ObjectList *item = (ObjectList *)priv_xmalloc (sizeof(ObjectList));
-                        item->stream = obj->stream;
-                        item->next = NULL;
-                        if (!rover) {
-                            rover = item;
-                            self->_streams = rover;
-                        } else {
-                            while (rover->next)
-                            rover = rover->next;
-                            rover->next = item;
-                        }
-                    }
-                }
-                ObjectList *rover = self->_streams;
-                self->_stream = rover->stream;
-                self->_streams = rover->next;
-            }
-        }
+      push_operand(self, token);
     }
-    streamReset(self);
-    token = _parseToken(self,streamGetChar(self));
-    while (token) {
-        if (token->type == pdf_operator) {
-            lua_pushstring(L, token->string);
-            free_token(token);
-            lua_rawget(L,2); // operator table
-            if (lua_isfunction(L,-1)) {
-                lua_pushvalue(L,4);
-                lua_pushvalue(L,3);
-                (void)lua_call(L,2,0);
-            } else {
-                lua_pop(L,1); // nil
-            }
-            clear_operand_stack(self,0);
-        } else {
-            push_operand(self, token);
-        }
-        if (!self->_stream) {
-            break;
-        }
-        token = _parseToken(self,streamGetChar(self));
-    }
-    /* wrap up */
-    if (self->_stream) {
-        streamClose(self);
+    if (!self->_stream) {
+      break;
     }
-    clear_operand_stack(self,0);
-    free(self->_operandstack);
-    return 0;
+    token = _parseToken(self,streamGetChar(self));
+  }
+  /* wrap up */
+  if (self->_stream) {
+    self->_stream->streamClose();
+    self->_stream = NULL;
+  }
+  clear_operand_stack(self,0);
+  free(self->_operandstack);
+  return 0;
 }
 
 static int scanner_done(lua_State * L)
 {
-    int c;
-    scannerdata *self = scanner_check(L,1);
-    while ((c=streamGetChar(self))>=0) ;
-    return 0;
+  int c;
+  scannerdata *self = scanner_check(L,1);
+  while ((c=streamGetChar(self))>=0)
+    ;
+  return 0;
 }
 
 // here are the stack popping functions, and their helpers
 
 static void operandstack_backup (scannerdata *self) {
-    int i = self->_nextoperand-1;
-    int balance = 0;
-    int backupstart = 0;
-    int backupstop = self->_operandstack[i]->type;
-    if (backupstop == pdf_stopdict) {
-        backupstart = pdf_startdict;
-    } else if (backupstop == pdf_stoparray) {
-        backupstart = pdf_startarray;
-    } else {
-        return;
+  int i = self->_nextoperand-1;
+  int balance = 0;
+  int backupstart = 0;
+  int backupstop = self->_operandstack[i]->type;
+  if (backupstop == pdf_stopdict) {
+    backupstart = pdf_startdict;
+  } else if (backupstop == pdf_stoparray) {
+    backupstart = pdf_startarray;
+  } else {
+    return;
+  }
+  for (;i>=0;i--) {
+    if (self->_operandstack[i]->type == backupstop) {
+      balance++;
+    } else if (self->_operandstack[i]->type == backupstart) {
+      balance--;
     }
-    for (;i>=0;i--) {
-        if (self->_operandstack[i]->type == backupstop) {
-            balance++;
-        } else if (self->_operandstack[i]->type == backupstart) {
-            balance--;
-        }
-        if (balance==0) {
-            break;
-        }
+    if (balance==0) {
+      break;
     }
-    self->_nextoperand = i+1;
+  }
+  self->_nextoperand = i+1;
 }
 
 static void push_array (lua_State *L, scannerdata *self)
 {
-    int balance = 1; // nesting tracking
-    int index = 1;   // lua array index
-    Token *token =  self->_operandstack[self->_nextoperand++];
-    lua_newtable(L);
-    while (token) {
-        if (token->type == pdf_stoparray)
-            balance --;
-        if (token->type == pdf_startarray)
-            balance ++;
-        if (!balance) {
-            break;
-        } else {
-            push_token(L,self);
-            lua_rawseti(L,-2, index++);
-        }
-        token =  self->_operandstack[self->_nextoperand++];
+  int balance = 1; // nesting tracking
+  int index = 1;  // lua array index
+  Token *token =  self->_operandstack[self->_nextoperand++];
+  lua_newtable(L);
+  while (token) {
+    if (token->type == pdf_stoparray)
+      balance --;
+    if (token->type == pdf_startarray)
+      balance ++;
+    if (!balance) {
+      break;
+    } else {
+      push_token(L,self);
+      lua_rawseti(L,-2, index++);
     }
+    token =  self->_operandstack[self->_nextoperand++];
+  }
 }
 
 
 static void push_dict (lua_State *L, scannerdata *self)
 {
-    int balance = 1; // nesting tracking
-    int needskey = 1; // toggle between lua value and lua key
-    Token *token =  self->_operandstack[self->_nextoperand++];
-    lua_newtable(L);
-    while (token) {
-        if (token->type == pdf_stopdict)
-            balance --;
-        if (token->type == pdf_startdict)
-            balance ++;
-        if (!balance) {
-            break;
-        } else if (needskey) {
-            lua_pushlstring(L, token->string, token->value);
-            needskey = 0;
-        } else {
-            push_token(L,self);
-            needskey = 1;
-            lua_rawset(L,-3);
-        }
-        token =  self->_operandstack[self->_nextoperand++];
-    }
-}
-
-const char *typenames[pdf_stopdict+1] = {
-    "unknown", "integer", "real", "boolean", "name", "operator",
-    "string", "array", "array", "dict", "dict"
-};
+  int balance = 1; // nesting tracking
+  int needskey = 1; // toggle between lua value and lua key
+  Token *token =  self->_operandstack[self->_nextoperand++];
+  lua_newtable(L);
+  while (token) {
+    if (token->type == pdf_stopdict)
+      balance --;
+    if (token->type == pdf_startdict)
+      balance ++;
+    if (!balance) {
+      break;
+    } else {
+      if (needskey) {
+	lua_pushlstring(L, token->string, token->value);
+	needskey = 0;
+      } else {
+	push_token(L,self);
+	needskey = 1;
+	lua_rawset(L,-3);
+      }
+    }
+    token =  self->_operandstack[self->_nextoperand++];
+  }
+}
+
+const char *typenames[pdf_stopdict+1] =
+  { "unknown", "integer", "real", "boolean", "name", "operator",
+    "string", "array", "array", "dict", "dict" };
 
 static void push_token (lua_State *L, scannerdata *self)
 {
-    Token *token =  self->_operandstack[self->_nextoperand-1];
-    lua_createtable(L,2,0);
-    lua_pushstring (L, typenames[token->type]);
-    lua_rawseti(L,-2,1);
-    if (token->type == pdf_string || token->type == pdf_name) {
-        lua_pushlstring(L, token->string, token->value);
-    } else if (token->type == pdf_real || token->type == pdf_integer) {
-        lua_pushnumber(L, token->value); /* integer or float */
-    } else if (token->type == pdf_boolean) {
-        lua_pushboolean(L, (int)token->value);
-    } else if (token->type == pdf_startarray) {
-        push_array(L, self);
-    } else if (token->type == pdf_startdict) {
-        push_dict(L, self);
-    } else {
-        lua_pushnil(L);
-    }
-    lua_rawseti(L,-2, 2);
+  Token *token =  self->_operandstack[self->_nextoperand-1];
+  lua_createtable(L,2,0);
+  lua_pushstring (L, typenames[token->type]);
+  lua_rawseti(L,-2,1);
+  if (token->type == pdf_string || token->type == pdf_name) {
+    lua_pushlstring(L, token->string, token->value);
+  } else if (token->type == pdf_real || token->type == pdf_integer) {
+    lua_pushnumber(L, token->value); /* integer or float */
+  } else if (token->type == pdf_boolean) {
+    lua_pushboolean(L, (int)token->value);
+  } else if (token->type == pdf_startarray) {
+    push_array(L, self);
+  } else if (token->type == pdf_startdict) {
+    push_dict(L, self);
+  } else {
+    lua_pushnil(L);
+  }
+  lua_rawseti(L,-2, 2);
 }
 
 static int scanner_popsingular (lua_State * L, int token_type) {
-    int clear = 0; // how much of the operand stack needs deleting
-    scannerdata *self = scanner_check(L,1);
-    if (self->_nextoperand==0) {
-        return 0;
-    }
+  int clear = 0; // how much of the operand stack needs deleting
+  scannerdata *self = scanner_check(L,1);
+  if (self->_nextoperand==0) {
+    return 0;
+  }
+  clear = self->_nextoperand-1;
+  Token *token = self->_operandstack[self->_nextoperand-1];
+  if (token ==NULL || (token->type != token_type )) {
+    return 0;
+  }
+  // the simple cases can be written out directly, but dicts and
+  // arrays are better done via the recursive function
+  if (token_type == pdf_stoparray || token_type == pdf_stopdict) {
+    operandstack_backup(self);
     clear = self->_nextoperand-1;
-    Token *token = self->_operandstack[self->_nextoperand-1];
-    if (token ==NULL || (token->type != token_type )) {
-        return 0;
-    }
-    // the simple cases can be written out directly, but dicts and
-    // arrays are better done via the recursive function
-    if (token_type == pdf_stoparray || token_type == pdf_stopdict) {
-        operandstack_backup(self);
-        clear = self->_nextoperand-1;
-        push_token(L, self);
-        lua_rawgeti(L,-1,2);
-    } else if (token_type == pdf_real || token_type == pdf_integer) {
-        lua_pushnumber(L, token->value); /* integer or float */
-    } else if (token_type == pdf_boolean) {
-        lua_pushboolean(L,(int)token->value);
-    } else if (token_type == pdf_name || token_type == pdf_string) {
-        lua_pushlstring(L, token->string, token->value);
-    } else {
-        return 0;
-    }
-    clear_operand_stack(self,clear);
-    return 1;
+    push_token(L, self);
+    lua_rawgeti(L,-1,2);
+  } else if (token_type == pdf_real || token_type == pdf_integer) {
+    lua_pushnumber(L, token->value); /* integer or float */
+  } else if (token_type == pdf_boolean) {
+    lua_pushboolean(L,(int)token->value);
+  } else if (token_type == pdf_name || token_type == pdf_string) {
+    lua_pushlstring(L, token->string, token->value);
+  } else {
+    return 0;
+  }
+  clear_operand_stack(self,clear);
+  return 1;
 }
 
 static int scanner_popanything (lua_State * L) {
-    int clear = 0; // how much of the operand stack needs deleting
-    scannerdata *self = scanner_check(L,1);
-    if (self->_nextoperand==0) {
-        return 0;
-    }
+  int clear = 0; // how much of the operand stack needs deleting
+  scannerdata *self = scanner_check(L,1);
+  if (self->_nextoperand==0) {
+    return 0;
+  }
+  clear = self->_nextoperand-1;
+  Token *token = self->_operandstack[self->_nextoperand-1];
+  if (token ==NULL) {
+    return 0;
+  }
+  int token_type = token->type;
+  // the simple cases can be written out directly, but dicts and
+  // arrays are better done via the recursive function
+  if (token_type == pdf_stoparray || token_type == pdf_stopdict) {
+    operandstack_backup(self);
     clear = self->_nextoperand-1;
-    Token *token = self->_operandstack[self->_nextoperand-1];
-    if (token ==NULL) {
-        return 0;
-    }
-    int token_type = token->type;
-    // the simple cases can be written out directly, but dicts and
-    // arrays are better done via the recursive function
-    if (token_type == pdf_stoparray || token_type == pdf_stopdict) {
-        operandstack_backup(self);
-        clear = self->_nextoperand-1;
-        push_token(L, self);
-    } else {
-        push_token(L, self);
-    }
-    clear_operand_stack(self,clear);
-    return 1;
+    push_token(L, self);
+  } else {
+    push_token(L, self);
+  }
+  clear_operand_stack(self,clear);
+  return 1;
 }
 
 
 static int scanner_popnumber(lua_State * L)
 {
-    if(scanner_popsingular(L,pdf_real))
-        return 1;
-    if (scanner_popsingular(L,pdf_integer))
-        return 1;
-    lua_pushnil(L);
+  if(scanner_popsingular(L,pdf_real))
+    return 1;
+  if (scanner_popsingular(L,pdf_integer))
+    return 1;
+  lua_pushnil(L);
   return 1;
 }
 
 static int scanner_popboolean(lua_State * L)
 {
-    if(scanner_popsingular(L,pdf_boolean))
-        return 1;
-    lua_pushnil(L);
+  if(scanner_popsingular(L,pdf_boolean))
     return 1;
+  lua_pushnil(L);
+  return 1;
 }
 
 static int scanner_popstring(lua_State * L)
 {
-    if (scanner_popsingular(L,pdf_string))
-        return 1;
-    lua_pushnil(L);
+  if (scanner_popsingular(L,pdf_string))
     return 1;
+  lua_pushnil(L);
+  return 1;
 }
 
 static int scanner_popname(lua_State * L)
 {
-    if (scanner_popsingular(L,pdf_name))
-        return 1;
-    lua_pushnil(L);
+  if (scanner_popsingular(L,pdf_name))
     return 1;
+  lua_pushnil(L);
+  return 1;
 }
 
 static int scanner_poparray(lua_State * L)
 {
-    if (scanner_popsingular(L,pdf_stoparray))
-        return 1;
-    lua_pushnil(L);
+  if (scanner_popsingular(L,pdf_stoparray))
     return 1;
+  lua_pushnil(L);
+  return 1;
 }
 
 static int scanner_popdictionary(lua_State * L)
 {
-    if (scanner_popsingular(L,pdf_stopdict))
-        return 1;
-    lua_pushnil(L);
+  if (scanner_popsingular(L,pdf_stopdict))
     return 1;
+  lua_pushnil(L);
+  return 1;
 }
 
 static int scanner_popany(lua_State * L)
 {
-    if (scanner_popanything(L))
-        return 1;
-    lua_pushnil(L);
+  if (scanner_popanything(L))
     return 1;
+  lua_pushnil(L);
+  return 1;
 }
 
 static const luaL_Reg scannerlib_meta[] = {
-    {0, 0}
+  {0, 0}
 };
 
 static const struct luaL_Reg scannerlib_m[] = {
@@ -1020,9 +929,10 @@ static const struct luaL_Reg scannerlib_
     {"popDict",     scanner_popdictionary},
     {"popBool",     scanner_popboolean},
     {"pop",         scanner_popany},
-    {NULL, NULL}    /* sentinel */
+    {NULL, NULL}                /* sentinel */
 };
 
+
 static const luaL_Reg scannerlib[] = {
     {"scan", scanner_scan},
     {NULL, NULL}
--- texlive-bin.orig/texk/web2c/luatexdir/lua/lstatslib.c
+++ texlive-bin/texk/web2c/luatexdir/lua/lstatslib.c
@@ -147,15 +147,13 @@ static lua_Number get_luatexhashchars(vo
 static const char *get_luatexhashtype(void)
 {
 #ifdef LuajitTeX
-     if (jithash_hashname)
-        return (const char *)jithash_hashname;
-     else
-        return "???";
+     return (const char *)jithash_hashname;
 #else
   return "lua";
 #endif
 }
 
+
 static lua_Number get_pdf_gone(void)
 {
     if (static_pdf != NULL)
@@ -268,22 +266,8 @@ static lua_Number get_development_id(voi
     return (lua_Number) luatex_svn_revision ;
 }
 
-static lua_Number get_dvi_gone(void)
-{
-    if (static_pdf != NULL)
-        return (lua_Number) dvi_get_status_gone(static_pdf);
-    return (lua_Number) 0;
-}
-
-static lua_Number get_dvi_ptr(void)
-{
-    if (static_pdf != NULL)
-        return (lua_Number) dvi_get_status_ptr(static_pdf);
-    return (lua_Number) 0;
-}
 
 /* temp, for backward compat */
-
 static int init_pool_ptr = 0;
 
 static struct statistic stats[] = {
@@ -307,9 +291,8 @@ static struct statistic stats[] = {
 
     {"pdf_gone", 'N', &get_pdf_gone},
     {"pdf_ptr", 'N', &get_pdf_ptr},
-    {"dvi_gone", 'g', &get_dvi_gone},
-    {"dvi_ptr", 'g', &get_dvi_ptr},
-
+    {"dvi_gone", 'g', &dvi_offset},
+    {"dvi_ptr", 'g', &dvi_ptr},
     {"total_pages", 'g', &total_pages},
     {"output_file_name", 'S', (void *) &get_output_file_name},
     {"log_name", 'S', (void *) &getlogname},
@@ -372,14 +355,9 @@ static struct statistic stats[] = {
     {"luabytecodes", 'g', &luabytecode_max},
     {"luabytecode_bytes", 'g', &luabytecode_bytes},
     {"luastate_bytes", 'g', &luastate_bytes},
-
     {"callbacks", 'g', &callback_count},
-    {"indirect_callbacks", 'g', &saved_callback_count}, /* these are file io callbacks */
 
-    {"saved_callbacks", 'g', &saved_callback_count},
-    {"late_callbacks", 'g', &late_callback_count},
-    {"direct_callbacks", 'g', &direct_callback_count},
-    {"function_callbacks", 'g', &function_callback_count},
+    {"indirect_callbacks", 'g', &saved_callback_count},
 
     {"lc_ctype", 'S', (void *) &get_lc_ctype},
     {"lc_collate", 'S', (void *) &get_lc_collate},
--- texlive-bin.orig/texk/web2c/luatexdir/lua/ltexiolib.c
+++ texlive-bin/texk/web2c/luatexdir/lua/ltexiolib.c
@@ -155,26 +155,10 @@ static int texio_setescape(lua_State * L
     return 0 ;
 }
 
-static int texio_closeinput(lua_State * L)
-{
-    /*
-        printf("before, first %i, index %i, iname %i, inopen %i, pointer %i\n",istart,iindex,iname,in_open,input_ptr);
-    */
-    if (iindex > 0) {
-        end_token_list();
-        end_file_reading();
-        /*
-            printf("after, first %i, index %i, iname %i, inopen %i, pointer %i\n",istart,iindex,iname,in_open,input_ptr);
-        */
-    }
-    return 0 ;
-}
-
 static const struct luaL_Reg texiolib[] = {
     {"write", texio_print},
     {"write_nl", texio_printnl},
     {"setescape", texio_setescape},
-    {"closeinput",texio_closeinput},
     {NULL, NULL}
 };
 
--- texlive-bin.orig/texk/web2c/luatexdir/lua/ltexlib.c
+++ texlive-bin/texk/web2c/luatexdir/lua/ltexlib.c
@@ -35,8 +35,7 @@ typedef struct {
     void *next;
     boolean partial;
     int cattable;
-    halfword tok;
-    halfword nod;
+ /* halfword tok; */
 } rope;
 
 typedef struct {
@@ -55,64 +54,33 @@ static int spindle_size  = 0;
 static spindle *spindles = NULL;
 static int spindle_index = 0;
 
-static int luac_store(lua_State * L, int i, int partial, int cattable)
+static void luac_store(lua_State * L, int i, int partial, int cattable)
 {
-    char *st = NULL;
-    size_t tsize = 0;
+    const char *sttemp;
+    char *st;
+    size_t tsize;
     rope *rn = NULL;
-    halfword tok = null;
-    halfword nod = null;
-    int t = lua_type(L, i);
-    if (t == LUA_TNUMBER || t == LUA_TSTRING) {
-        const char *sttemp;
-        sttemp = lua_tolstring(L, i, &tsize);
-        st = xmalloc((unsigned) (tsize + 1));
-        memcpy(st, sttemp, (tsize + 1));
-    } else if (t == LUA_TUSERDATA) {
-        void *p ;
-        p = lua_touserdata(L, i);
-        if (p == NULL) {
-            return 0;
-        } else if (lua_getmetatable(L, i)) {
-            lua_get_metatablelua(luatex_token);
-            if (lua_rawequal(L, -1, -2)) {
-                tok = (halfword) token_info((*((lua_token *)p)).token);
-                lua_pop(L, 2);
-            } else {
-                lua_get_metatablelua(luatex_node);
-                if (lua_rawequal(L, -1, -3)) {
-                    nod = *((halfword *)p);
-                    lua_pop(L, 3);
-                } else {
-                    lua_pop(L, 3);
-                    return 0;
-                }
-            }
+    sttemp = lua_tolstring(L, i, &tsize);
+    st = xmalloc((unsigned) (tsize + 1));
+    memcpy(st, sttemp, (tsize + 1));
+    if (st) {
+        luacstrings++;
+        rn = (rope *) xmalloc(sizeof(rope));
+        rn->text = st;
+        rn->tsize = (unsigned) tsize;
+        rn->partial = partial;
+        rn->cattable = cattable;
+        rn->next = NULL;
+     /* rn->tok = 0; */
+        if (write_spindle.head == NULL) {
+            assert(write_spindle.tail == NULL);
+            write_spindle.head = rn;
         } else {
-            return 0;
+            write_spindle.tail->next = rn;
         }
-    } else {
-        return 0;
-    }
-    /* common */
-    luacstrings++;
-    rn = (rope *) xmalloc(sizeof(rope));
-    rn->text = st;
-    rn->tsize = (unsigned) tsize;
-    rn->tok = tok;
-    rn->nod = nod;
-    rn->next = NULL;
-    rn->partial = partial;
-    rn->cattable = cattable;
-    /* add */
-    if (write_spindle.head == NULL) {
-        write_spindle.head = rn;
-    } else {
-        write_spindle.tail->next = rn;
+        write_spindle.tail = rn;
+        write_spindle.complete = 0;
     }
-    write_spindle.tail = rn;
-    write_spindle.complete = 0;
-    return 1;
 }
 
 static int do_luacprint(lua_State * L, int partial, int deftable)
@@ -125,85 +93,49 @@ static int do_luacprint(lua_State * L, i
             cattable = lua_tointeger(L, 1);
             startstrings = 2;
             if (cattable != -1 && cattable != -2 && !valid_catcode_table(cattable)) {
-                cattable = DEFAULT_CAT_TABLE;
-            }
+       cattable = DEFAULT_CAT_TABLE;
+     }
         }
     }
     if (lua_type(L, startstrings) == LUA_TTABLE) {
         int i;
         for (i = 1;; i++) {
             lua_rawgeti(L, startstrings, i);
-            if (luac_store(L, -1, partial, cattable)) {
+            if (lua_isstring(L,-1)) { /* or number */
+                luac_store(L, -1, partial, cattable);
                 lua_pop(L, 1);
             } else {
-                lua_pop(L, 1);
                 break;
             }
         }
     } else {
         int i;
         for (i = startstrings; i <= n; i++) {
+            if (!lua_isstring(L,i)) { /* or number */
+                luaL_error(L, "no string to print");
+            }
             luac_store(L, i, partial, cattable);
         }
-    }
-    return 0;
-}
-
-/* the next one writes a raw token (number) */
-
-/*
-
-int luatwrite(lua_State * L)
-{
-    int top = lua_gettop(L);
-    if (top>0) {
-        rope *rn = xmalloc(sizeof(rope)); // overkill
-        int i = 1 ;
-        luacstrings++; // should be luactokens
-        rn->text = NULL;
-        rn->tsize = 0;
-        rn->partial = 0;
-        rn->cattable = DEFAULT_CAT_TABLE;
-        rn->next = NULL;
-        rn->tok = 0;
-        rn->nod = 0;
-        if (write_spindle.head == NULL) {
-            write_spindle.head = rn;
+        /* hh: We could use this but it makes not much different, apart from allocating more ropes so less
+           memory. To be looked into: lua 5.2 buffer mechanism as now we still hash the concatination. This
+           test was part of the why-eis-luajit-so-slow on crited experiments. */
+        /*
+        if (startstrings == n) {
+            luac_store(L, n, partial, cattable);
         } else {
-            write_spindle.tail->next = rn;
-        }
-        write_spindle.tail = rn;
-        write_spindle.complete = 0;
-        while (1) {
-            rn->tok = lua_tointeger(L,i);
-            if (i<top) {
-                rope *r = xmalloc(sizeof(rope)); // overkill
-                r->text = NULL;
-                r->tsize = 0;
-                r->partial = 0;
-                r->cattable = DEFAULT_CAT_TABLE;
-                r->next = NULL;
-                r->tok = 0;
-                r->nod = 0;
-                rn->next = r;
-                rn = r;
-                write_spindle.tail = rn;
-                i++;
-            } else {
-                break;
-            }
+            lua_concat(L,n-startstrings+1);
+            luac_store(L, startstrings, partial, cattable);
         }
+        */
     }
     return 0;
 }
 
-*/
-
-/* the next one writes a raw node (number) */
-
 /*
 
-int luanwrite(lua_State * L)
+// some first experiments .. somewhat tricky at the other end
+
+int luatwrite(lua_State * L)
 {
     int top = lua_gettop(L);
     if (top>0) {
@@ -216,7 +148,6 @@ int luanwrite(lua_State * L)
         rn->cattable = DEFAULT_CAT_TABLE;
         rn->next = NULL;
         rn->tok = 0;
-        rn->nod = 0;
         if (write_spindle.head == NULL) {
             write_spindle.head = rn;
         } else {
@@ -225,7 +156,7 @@ int luanwrite(lua_State * L)
         write_spindle.tail = rn;
         write_spindle.complete = 0;
         while (1) {
-            rn->nod = lua_tointeger(L,i);
+            rn->tok = lua_tointeger(L,i);
             if (i<top) {
                 rope *r = xmalloc(sizeof(rope)); // overkill
                 r->text = NULL;
@@ -234,7 +165,6 @@ int luanwrite(lua_State * L)
                 r->cattable = DEFAULT_CAT_TABLE;
                 r->next = NULL;
                 r->tok = 0;
-                r->nod = 0;
                 rn->next = r;
                 rn = r;
                 write_spindle.tail = rn;
@@ -249,29 +179,21 @@ int luanwrite(lua_State * L)
 
 */
 
-/* lua.write */
-
 static int luacwrite(lua_State * L)
 {
     return do_luacprint(L, FULL_LINE, NO_CAT_TABLE);
 }
 
-/* lua.print */
-
 static int luacprint(lua_State * L)
 {
     return do_luacprint(L, FULL_LINE, DEFAULT_CAT_TABLE);
 }
 
-/* lua.sprint */
-
 static int luacsprint(lua_State * L)
 {
     return do_luacprint(L, PARTIAL_LINE, DEFAULT_CAT_TABLE);
 }
 
-/* lua.cprint */
-
 static int luaccprint(lua_State * L)
 {
     /* so a negative value is a specific catcode with offset 1 */
@@ -285,10 +207,10 @@ static int luaccprint(lua_State * L)
         int i;
         for (i = 1;; i++) {
             lua_rawgeti(L, 2, i);
-            if (luac_store(L, -1, PARTIAL_LINE, cattable)) {
+            if (lua_isstring(L,-1)) { /* or number */
+                luac_store(L, -1, PARTIAL_LINE, cattable);
                 lua_pop(L, 1);
             } else {
-                lua_pop(L, 1);
                 break;
             }
         }
@@ -296,14 +218,15 @@ static int luaccprint(lua_State * L)
         int i;
         int n = lua_gettop(L);
         for (i = 2; i <= n; i++) {
+            if (!lua_isstring(L,i)) { /* or number */
+                luaL_error(L, "no string to print");
+            }
             luac_store(L, i, PARTIAL_LINE, cattable);
         }
     }
     return 0;
 }
 
-/* lua.tprint */
-
 static int luactprint(lua_State * L)
 {
     int i, j;
@@ -315,7 +238,7 @@ static int luactprint(lua_State * L)
         if (lua_type(L, i) != LUA_TTABLE) {
             luaL_error(L, "no string to print");
         }
-        lua_pushvalue(L, i); /* push the table */
+        lua_pushvalue(L, i);    /* push the table */
         lua_pushinteger(L, 1);
         lua_gettable(L, -2);
         if (lua_type(L, -1) == LUA_TNUMBER) {
@@ -329,14 +252,15 @@ static int luactprint(lua_State * L)
         for (j = startstrings;; j++) {
             lua_pushinteger(L, j);
             lua_gettable(L, -2);
-            if (luac_store(L, -1, PARTIAL_LINE, cattable)) {
+            if (lua_isstring(L, -1)) { /* or number */
+                luac_store(L, -1, PARTIAL_LINE, cattable);
                 lua_pop(L, 1);
             } else {
                 lua_pop(L, 1);
                 break;
             }
         }
-        lua_pop(L, 1); /* pop the table */
+        lua_pop(L, 1);          /* pop the table */
     }
     return 0;
 }
@@ -356,7 +280,7 @@ int luacstring_final_line(void)
     return (read_spindle.tail->next == NULL);
 }
 
-int luacstring_input(halfword *n)
+int luacstring_input(void)
 {
     rope *t = read_spindle.head;
     int ret = 1 ;
@@ -384,15 +308,12 @@ int luacstring_input(halfword *n)
         }
         free(t->text);
         t->text = NULL;
+    /*
     } else if (t->tok > 0) {
-        *n = t->tok;
-        ret = 2;
-    } else if (t->nod > 0) {
-        *n = t->nod;
-        ret = 3;
+        ret = - t->tok;
+    */
     }
-    if (read_spindle.tail != NULL) {
-        /* not a one-liner */
+    if (read_spindle.tail != NULL) {    /* not a one-liner */
         free(read_spindle.tail);
     }
     read_spindle.tail = t;
@@ -401,13 +322,11 @@ int luacstring_input(halfword *n)
 }
 
 /* open for reading, and make a new one for writing */
-
 void luacstring_start(int n)
 {
-    (void) n; /* for -W */
+    (void) n;                   /* for -W */
     spindle_index++;
-    if (spindle_size == spindle_index) {
-        /* add a new one */
+    if (spindle_size == spindle_index) {        /* add a new one */
         spindles = xrealloc(spindles, (unsigned) (sizeof(spindle) * (unsigned) (spindle_size + 1)));
         spindles[spindle_index].head = NULL;
         spindles[spindle_index].tail = NULL;
@@ -421,7 +340,7 @@ void luacstring_start(int n)
 void luacstring_close(int n)
 {
     rope *next, *t;
-    (void) n; /* for -W */
+    (void) n;                   /* for -W */
     next = read_spindle.head;
     while (next != NULL) {
         if (next->text != NULL)
@@ -459,15 +378,15 @@ void luacstring_close(int n)
 
 static const char *scan_integer_part(lua_State * L, const char *ss, int *ret, int *radix_ret)
 {
-    boolean negative = false; /* should the answer be negated? */
-    int m = 214748364;        /* |$2^{31}$ / radix|, the threshold of danger */
-    int d;                    /* the digit just scanned */
-    boolean vacuous = true;   /* have no digits appeared? */
-    boolean OK_so_far = true; /* has an error message been issued? */
-    int radix1 = 10;          /* the radix of the integer */
-    int c = 0;                /* the current character */
-    const char *s;            /* where we stopped in the string |ss| */
-    integer val = 0;          /* return value */
+    boolean negative = false;   /* should the answer be negated? */
+    int m = 214748364;          /* |$2^{31}$ / radix|, the threshold of danger */
+    int d;                      /* the digit just scanned */
+    boolean vacuous = true;     /* have no digits appeared? */
+    boolean OK_so_far = true;   /* has an error message been issued? */
+    int radix1 = 10;            /* the radix of the integer */
+    int c = 0;                  /* the current character */
+    const char *s;              /* where we stopped in the string |ss| */
+    integer val = 0;            /* return value */
     s = ss;
     do {
         do {
@@ -529,9 +448,9 @@ static const char *scan_integer_part(lua
 
 #define set_conversion(A,B) do { num=(A); denom=(B); } while(0)
 
-/* sets |cur_val| to a dimension */
 
 static const char *scan_dimen_part(lua_State * L, const char *ss, int *ret)
+/* sets |cur_val| to a dimension */
 {
     boolean negative = false;   /* should the answer be negated? */
     int f = 0;                  /* numerator of a fraction whose denominator is $2^{16}$ */
@@ -541,7 +460,7 @@ static const char *scan_dimen_part(lua_S
     int save_cur_val;           /* temporary storage of |cur_val| */
     int c;                      /* the current character */
     const char *s = ss;         /* where we are in the string */
-    int radix1 = 0;             /* the current radix */
+    int radix1 = 0;              /* the current radix */
     int rdig[18];               /* to save the |dig[]| array */
     int saved_tex_remainder;    /* to save |tex_remainder|  */
     int saved_arith_error;      /* to save |arith_error|  */
@@ -549,9 +468,9 @@ static const char *scan_dimen_part(lua_S
     saved_tex_remainder = tex_remainder;
     saved_arith_error = arith_error;
     saved_cur_val = cur_val;
-    /* get the next non-blank non-sign */
+    /* Get the next non-blank non-sign... */
     do {
-        /* get the next non-blank non-call token */
+        /* Get the next non-blank non-call token */
         do {
             c = *s++;
         } while (c && c == ' ');
@@ -574,18 +493,16 @@ static const char *scan_dimen_part(lua_S
     if (c == ',')
         c = '.';
     if ((radix1 == 10) && (c == '.')) {
-        /* scan decimal fraction */
+        /* Scan decimal fraction */
         for (k = 0; k < 18; k++)
             rdig[k] = dig[k];
         k = 0;
-        s++;
-        /* get rid of the '.' */
+        s++;                    /* get rid of the '.' */
         while (1) {
             c = *s++;
             if ((c > '0' + 9) || (c < '0'))
                 break;
-            if (k < 17) {
-                /* digits for |k>=17| cannot affect the result */
+            if (k < 17) {       /* digits for |k>=17| cannot affect the result */
                 dig[k++] = c - '0';
             }
         }
@@ -599,10 +516,8 @@ static const char *scan_dimen_part(lua_S
         negative = !negative;
         cur_val = -cur_val;
     }
-    /*
-        Scan for (u)units that are internal dimensions; |goto attach_sign| with
-        |cur_val| set if found.
-    */
+    /* Scan for (u)units that are internal dimensions;
+       |goto attach_sign| with |cur_val| set if found */
     save_cur_val = cur_val;
     /* Get the next non-blank non-call... */
     do {
@@ -655,10 +570,8 @@ static const char *scan_dimen_part(lua_S
         s += 2;
         goto ATTACH_FRACTION;   /* the easy case */
     }
-    /*
-        Scan for (a)all other units and adjust |cur_val| and |f| accordingly; |goto done|
-        in the case of scaled points
-    */
+    /* Scan for (a)all other units and adjust |cur_val| and |f| accordingly;
+       |goto done| in the case of scaled points */
     if (strncmp(s, "mm", 2) == 0) {
         s += 2;
         set_conversion(7227, 2540);
@@ -802,7 +715,7 @@ static int get_item_index(lua_State * L,
             s = lua_tolstring(L, i, &kk);
             cur_cs1 = string_lookup(s, kk);
             if (cur_cs1 == undefined_control_sequence || cur_cs1 == undefined_cs_cmd)
-                k = -1; /* guarandeed invalid */
+                k = -1;             /* guarandeed invalid */
             else
                 k = (equiv(cur_cs1) - base);
             break;
@@ -811,7 +724,7 @@ static int get_item_index(lua_State * L,
             break;
         default:
             luaL_error(L, "argument must be a string or a number");
-            k = -1; /* not a valid index */
+            k = -1;                 /* not a valid index */
     }
     return k;
 }
@@ -1398,7 +1311,7 @@ static int vsetbox(lua_State * L, int is
     } else if (t == LUA_TNIL) {
         j = null;
     } else {
-        j = nodelist_from_lua(L,-1);
+        j = nodelist_from_lua(L);
         if (j != null && type(j) != hlist_node && type(j) != vlist_node) {
             luaL_error(L, "setbox: incompatible node type (%s)\n", get_node_name(type(j), subtype(j)));
             return 0;
@@ -2199,7 +2112,6 @@ static int gettex(lua_State * L)
             case assign_int_cmd:
             case assign_attr_cmd:
             case assign_dir_cmd:
-            case assign_direction_cmd:
             case assign_dimen_cmd:
             case set_aux_cmd:
             case set_prev_graf_cmd:
@@ -2229,9 +2141,8 @@ static int gettex(lua_State * L)
 static int getlist(lua_State * L)
 {
     const char *str;
-    int top = lua_gettop(L);
-    if (lua_type(L,top) == LUA_TSTRING) {
-        str = lua_tostring(L, top);
+    if (lua_type(L,2) == LUA_TSTRING) {
+        str = lua_tostring(L, 2);
         if (lua_key_eq(str,page_ins_head)) {
             if (vlink(page_ins_head) == page_ins_head)
                 lua_pushinteger(L, null);
@@ -2292,18 +2203,17 @@ static int getlist(lua_State * L)
 
 static int setlist(lua_State * L)
 {
-    int top = (lua_type(L,1) == LUA_TTABLE) ? 2 : 1 ;
-    if (lua_type(L,top) == LUA_TSTRING) {
-        const char *str = lua_tostring(L, top);
+    if (lua_type(L,2) == LUA_TSTRING) {
+        const char *str = lua_tostring(L, 2);
         if (lua_key_eq(str,best_size)) {
-            best_size = (int) lua_tointeger(L, top+1);
+            best_size = (int) lua_tointeger(L, 3);
         } else if (lua_key_eq(str,least_page_cost)) {
-            least_page_cost = (int) lua_tointeger(L, top+1);
+            least_page_cost = (int) lua_tointeger(L, 3);
         } else {
             halfword *n_ptr;
             halfword n = 0;
-            if (!lua_isnil(L, top+1)) {
-                n_ptr = check_isnode(L, top+1);
+            if (!lua_isnil(L, 3)) {
+                n_ptr = check_isnode(L, 3);
                 n = *n_ptr;
             }
             if (lua_key_eq(str,page_ins_head)) {
@@ -2449,32 +2359,24 @@ static void init_nest_lib(lua_State * L)
 static int getnest(lua_State * L)
 {
     list_state_record **nestitem;
-    int n = lua_gettop(L);
-    int p = -1 ;
-    if (n == 0) {
-        p = nest_ptr;
-    } else {
-        int t = lua_type(L, n);
-        if (t == LUA_TNUMBER) {
-            int ptr = lua_tointeger(L, n);
-            if (ptr >= 0 && ptr <= nest_ptr) {
-                p = ptr;
-            }
-        } else if (t == LUA_TSTRING) {
-            const char *s = lua_tostring(L, n);
-            if (lua_key_eq(s,top)) {
-                p = nest_ptr;
-            } else if (lua_key_eq(s,ptr)) {
-                lua_pushinteger(L, nest_ptr);
-                return 1;
-            }
+    int t = lua_type(L, 2);
+    if (t == LUA_TNUMBER) {
+        int ptr = lua_tointeger(L, 2);
+        if (ptr >= 0 && ptr <= nest_ptr) {
+            nestitem = lua_newuserdata(L, sizeof(list_state_record *));
+            *nestitem = &nest[ptr];
+            luaL_getmetatable(L, NEST_METATABLE);
+            lua_setmetatable(L, -2);
+        } else {
+            lua_pushnil(L);
+        }
+    } else if (t == LUA_TSTRING) {
+        const char *s = lua_tostring(L, 2);
+        if (lua_key_eq(s,ptr)) {
+            lua_pushinteger(L, nest_ptr);
+        } else {
+            lua_pushnil(L);
         }
-    }
-    if (p > -1) {
-        nestitem = lua_newuserdata(L, sizeof(list_state_record *));
-        *nestitem = &nest[p];
-        luaL_getmetatable(L, NEST_METATABLE);
-        lua_setmetatable(L, -2);
     } else {
         lua_pushnil(L);
     }
@@ -2484,7 +2386,7 @@ static int getnest(lua_State * L)
 static int setnest(lua_State * L)
 {
     luaL_error(L, "You can't modify the semantic nest array directly");
-    return 0;
+    return 2;
 }
 
 static int do_integer_error(double m)
@@ -2957,7 +2859,7 @@ static int tex_run_linebreak(lua_State *
     }
     lua_key_rawgeti(pardir);
     if (lua_type(L, -1) == LUA_TSTRING) {
-        paragraph_dir = nodelib_getdir(L, -1);
+        paragraph_dir = nodelib_getdir(L, -1, 1);
     }
     lua_pop(L, 1);
 
@@ -3215,21 +3117,8 @@ static int tex_save_box_resource(lua_Sta
     int type = 0;
     int margin = pdf_xform_margin;
     boolean immediate = false;
-    /* more or less same as scanner variant */
-    if (lua_type(L,1) == LUA_TNUMBER) {
-        halfword boxnumber = lua_tointeger(L,1);
-        boxdata = box(boxnumber);
-        box(boxnumber) = null;
-    } else {
-        boxdata = nodelist_from_lua(L,1);
-        if (type(boxdata) != hlist_node && type(boxdata) != vlist_node) {
-            normal_error("pdf backend", "xforms can only be used with a box or [h|v]list");
-        }
-    }
-    if (boxdata == null) {
-        normal_error("pdf backend", "xforms cannot be used with a void box or empty [h|v]list");
-    }
     /* box attributes resources */
+    halfword boxnumber = lua_tointeger(L,1);
     if (lua_type(L,2) == LUA_TSTRING) {
         lua_pushvalue(L, 2);
         attributes = luaL_ref(L, LUA_REGISTRYINDEX);
@@ -3247,6 +3136,10 @@ static int tex_save_box_resource(lua_Sta
     if (lua_type(L,6) == LUA_TNUMBER) {
         margin = lua_tointeger(L, 6);
     }
+    /* more or less same as scanner variant */
+    boxdata = box(boxnumber);
+    if (boxdata == null)
+        normal_error("pdf backend", "xforms cannot be used with a void box");
     static_pdf->xform_count++;
     index = pdf_create_obj(static_pdf, obj_type_xform, static_pdf->xform_count);
     set_obj_data_ptr(static_pdf, index, pdf_get_mem(static_pdf, pdfmem_xform_size));
@@ -3260,6 +3153,7 @@ static int tex_save_box_resource(lua_Sta
     set_obj_xform_depth(static_pdf, index, depth(boxdata));
     set_obj_xform_type(static_pdf, index, type);
     set_obj_xform_margin(static_pdf, index, margin);
+    box(boxnumber) = null;
     last_saved_box_index = index;
     lua_pushinteger(L, index);
     if (immediate) {
@@ -3335,35 +3229,12 @@ static int tex_get_box_resource_dimensio
     return 4;
 }
 
-static int tex_get_box_resource_box(lua_State * L)
-{
-    /* no checking yet as this might go */
-    halfword b;
-    int index = lua_tointeger(L,1);
-    check_obj_type(static_pdf, obj_type_xform, index);
-    b = obj_xform_box(static_pdf, index);
-    nodelist_to_lua(L, b);
-    return 1;
-}
-
 static int tex_build_page(lua_State * L)
 {
     build_page();
     return 0;
 }
 
-static int lua_get_page_state(lua_State * L)
-{
-    lua_pushinteger(L,page_contents);
-    return 1;
-}
-
-static int lua_get_local_level(lua_State * L)
-{
-    lua_pushinteger(L,current_local_level());
-    return 1;
-}
-
 /* synctex */
 
 static int lua_set_synctex_mode(lua_State * L)
@@ -3425,82 +3296,6 @@ static int lua_set_synctex_no_files(lua_
     return 0;
 }
 
-/*
-    This is experimental and might change. In version 10 we hope to have the
-    final version available. It actually took quite a bit of time to understand
-    the implications of mixing lua prints in here. The current variant is (so far)
-    the most robust (wrt crashes and side effects).
-*/
-
-#define mode mode_par
-
-/*
-    When we add save levels then we can get crashes when one flushed bad
-    groups due to out of order flushing. So we play safe! But still we can
-    have issues so best make sure you're in hmode.
-*/
-
-static int forcehmode(lua_State * L)
-{
-    if (abs(mode) == vmode) {
-        if (lua_type(L,1) == LUA_TBOOLEAN) {
-            new_graf(lua_toboolean(L,1));
-        } else {
-            new_graf(1);
-        }
-    }
-    return 0;
-}
-
-static int runtoks(lua_State * L)
-{
-    if (lua_type(L,1) == LUA_TFUNCTION) {
-        int old_mode = mode;
-        int ref;
-        pointer r = get_avail();
-        pointer t = get_avail();
-        token_info(r) = token_val(extension_cmd,end_local_code);
-        lua_pushvalue(L, 1);
-        ref = luaL_ref(L,LUA_REGISTRYINDEX);
-        token_info(t) = token_val(lua_local_call_cmd, ref);
-        begin_token_list(r,inserted);
-        begin_token_list(t,inserted);
-        if (luacstrings > 0) {
-            lua_string_start();
-        }
-        if (tracing_nesting_par > 2) {
-            local_control_message("entering token scanner via function");
-        }
-        mode = -hmode;
-        local_control();
-        mode = old_mode;
-        luaL_unref(L,LUA_REGISTRYINDEX,ref);
-    } else {
-        int k = get_item_index(L, lua_gettop(L), toks_base);
-        halfword t = toks(k);
-        check_index_range(k, "gettoks");
-        if (t != null) {
-            int old_mode = mode;
-            pointer r = get_avail();
-            token_info(r) = token_val(extension_cmd,end_local_code);
-            begin_token_list(r,inserted);
-            /* new_save_level(semi_simple_group); */
-            begin_token_list(t,local_text);
-            if (luacstrings > 0) {
-                lua_string_start();
-            }
-            if (tracing_nesting_par > 2) {
-                local_control_message("entering token scanner via register");
-            }
-            mode = -hmode;
-            local_control();
-            mode = old_mode;
-            /* unsave(); */
-        }
-    }
-    return 0;
-}
-
 /* till here */
 
 void init_tex_table(lua_State * L)
@@ -3520,14 +3315,10 @@ static const struct luaL_Reg texlib[] =
     { "finish", tex_run_end },    /* may be needed  */
     { "write", luacwrite },
     { "print", luacprint },
-    { "sprint", luacsprint },
     { "tprint", luactprint },
     { "cprint", luaccprint },
-    /*
-    { "twrite", luatwrite },
-    { "nwrite", luanwrite },
-    */
     { "error", texerror },
+    { "sprint", luacsprint },
     { "set", settex },
     { "get", gettex },
     { "isdimen", isdimen },
@@ -3536,13 +3327,11 @@ static const struct luaL_Reg texlib[] =
     { "isskip", isskip },
     { "setskip", setskip },
     { "getskip", getskip },
-    { "isglue", isskip },
     { "setglue", setglue },
     { "getglue", getglue },
     { "ismuskip", ismuskip },
     { "setmuskip", setmuskip },
     { "getmuskip", getmuskip },
-    { "ismuglue", ismuskip },
     { "setmuglue", setmuglue },
     { "getmuglue", getmuglue },
     { "isattribute", isattribute },
@@ -3561,7 +3350,7 @@ static const struct luaL_Reg texlib[] =
     { "splitbox", splitbox },
     { "setlist", setlist },
     { "getlist", getlist },
-    { "setnest", setnest }, /* only a message */
+    { "setnest", setnest },
     { "getnest", getnest },
     { "setcatcode", setcatcode },
     { "getcatcode", getcatcode },
@@ -3606,12 +3395,8 @@ static const struct luaL_Reg texlib[] =
     { "saveboxresource", tex_save_box_resource },
     { "useboxresource", tex_use_box_resource },
     { "getboxresourcedimensions", tex_get_box_resource_dimensions },
-    /* might go, used when sanitizing backend */
-    { "getboxresourcebox", tex_get_box_resource_box },
     /* just for testing: it will probably stay but maybe with options */
     { "triggerbuildpage", tex_build_page },
-    { "getpagestate", lua_get_page_state },
-    { "getlocallevel", lua_get_local_level },
     /* not the best place but better than in node */
     { "set_synctex_mode", lua_set_synctex_mode },
     { "get_synctex_mode", lua_get_synctex_mode },
@@ -3622,9 +3407,6 @@ static const struct luaL_Reg texlib[] =
     { "force_synctex_line", lua_force_synctex_line },
     { "set_synctex_line", lua_set_synctex_line },
     { "get_synctex_line", lua_get_synctex_line },
-    /* test */
-    { "runtoks", runtoks },
-    { "forcehmode", forcehmode },
     /* sentinel */
     { NULL, NULL }
 };
@@ -3669,8 +3451,6 @@ int luaopen_tex(lua_State * L)
     spindles[0].tail = NULL;
     spindle_size = 1;
     /* a somewhat odd place for this assert, maybe */
-    if (command_names[data_cmd].id != data_cmd) {
-        fatal_error("mismatch between tex and lua command name tables");
-    };
+    assert(command_names[data_cmd].command_offset == data_cmd);
     return 1;
 }
--- texlive-bin.orig/texk/web2c/luatexdir/lua/luatex-api.h
+++ texlive-bin/texk/web2c/luatexdir/lua/luatex-api.h
@@ -35,10 +35,8 @@ extern int draft_mode_value;
 /* get_o_mode translates from output_mode to output_mode_used */
 /* fix_o_mode freezes output_mode as soon as anything goes through the backend */
 
-/*
 extern output_mode get_o_mode(void);
 extern void fix_o_mode(void);
-*/
 
 /* till here */
 
@@ -68,7 +66,8 @@ typedef struct LoadS {
 
 extern lua_State *Luas;
 
-extern void make_table(lua_State * L, const char *tab, const char *mttab, const char *getfunc, const char *setfunc);
+extern void make_table(lua_State * L, const char *tab, const char *mttab, const char *getfunc,
+                       const char *setfunc);
 
 extern int luac_main(int argc, char *argv[]);
 
@@ -77,8 +76,6 @@ extern int luaopen_pdf(lua_State * L);
 extern int luaopen_texio(lua_State * L);
 extern int luaopen_lang(lua_State * L);
 
-extern int luapdfprint(lua_State * L);
-
 #  define LUA_TEXFILEHANDLE "TEXFILE*"
 
 extern lua_State *luatex_error(lua_State * L, int fatal);
@@ -88,7 +85,6 @@ extern int luaopen_zip(lua_State * L);
 extern int luaopen_lfs(lua_State * L);
 extern int luaopen_lpeg(lua_State * L);
 extern int luaopen_md5(lua_State * L);
-extern int luaopen_sha2(lua_State * L);
 
 #ifndef LuajitTeX
  extern int luaopen_ffi(lua_State * L);
@@ -105,13 +101,14 @@ extern void luatex_socketlua_open(lua_St
 
 extern int luaopen_img(lua_State * L);
 extern int l_new_image(lua_State * L);
-extern int luaopen_pdfe(lua_State * L);
+extern int luaopen_epdf(lua_State * L);
 extern int luaopen_pdfscanner(lua_State * L);
 extern int luaopen_mplib(lua_State * L);
 extern int luaopen_fio(lua_State * L);
 
 extern void open_oslibext(lua_State * L);
 extern void open_strlibext(lua_State * L);
+extern void open_lfslibext(lua_State * L);
 
 extern void initfilecallbackids(int max);
 extern void setinputfilecallbackid(int n, int i);
@@ -121,8 +118,6 @@ extern int getreadfilecallbackid(int n);
 
 extern void lua_initialize(int ac, char **av);
 
-extern void luacall_vf(int p, int f, int c);
-
 extern int luaopen_kpse(lua_State * L);
 
 extern int luaopen_callback(lua_State * L);
@@ -143,12 +138,12 @@ extern void tokenlist_to_luastring(lua_S
 extern int tokenlist_from_lua(lua_State * L);
 
 extern void lua_nodelib_push(lua_State * L);
-extern int nodelib_getdir(lua_State * L, int n);
+extern int nodelib_getdir(lua_State * L, int n, int absolute_only);
 extern int nodelib_getlist(lua_State * L, int n);
 
 extern int luaopen_node(lua_State * L);
 extern void nodelist_to_lua(lua_State * L, int n);
-extern int nodelist_from_lua(lua_State * L, int n);
+extern int nodelist_from_lua(lua_State * L);
 
 extern int dimen_to_number(lua_State * L, const char *s);
 
@@ -163,6 +158,8 @@ extern const char *lc_ctype;
 extern const char *lc_collate;
 extern const char *lc_numeric;
 
+
+
 #ifdef LuajitTeX
 extern int luajiton;
 extern char *jithash_hashname ;
@@ -180,9 +177,9 @@ extern void unhide_lua_value(lua_State *
 extern int hide_lua_value(lua_State * lua, const char *name, const char *item);
 
 typedef struct command_item_ {
-    int id;
-    const char *name;
-    int lua;
+    const char *cmd_name;
+    int command_offset;
+    const char **commands;
 } command_item;
 
 extern command_item command_names[];
@@ -196,9 +193,6 @@ extern int luastate_bytes;
 
 extern int callback_count;
 extern int saved_callback_count;
-extern int direct_callback_count;
-extern int late_callback_count;
-extern int function_callback_count;
 
 extern const char *luatex_banner;
 extern const char *engine_name;
@@ -262,13 +256,7 @@ extern char **environ;
 }
 #endif
 
-typedef struct lua_token {
-    int token;
-    int origin;
-} lua_token;
-
 extern int luatwrite(lua_State * L);
-extern int luanwrite(lua_State * L);
 
 /*
     Same as in lnodelib.c, but with prefix G_ for now.
@@ -354,58 +342,22 @@ preassign these at startup time. */
 #define LOCAL_PAR_SIZE        5
 #define MATH_STYLE_NAME_SIZE  8
 #define APPEND_LIST_SIZE      5
-#define DIR_PAR_SIZE          4
-#define DIR_TEXT_SIZE         4
+#define DIR_PAR_SIZE          8
+#define DIR_TEXT_SIZE         8
 
 extern int l_pack_type_index       [PACK_TYPE_SIZE];
 extern int l_group_code_index      [GROUP_CODE_SIZE];
 extern int l_local_par_index       [LOCAL_PAR_SIZE];
 extern int l_math_style_name_index [MATH_STYLE_NAME_SIZE];
 extern int l_dir_par_index         [DIR_PAR_SIZE];
-extern int l_dir_text_index_normal [DIR_TEXT_SIZE];
-extern int l_dir_text_index_cancel [DIR_TEXT_SIZE];
+extern int l_dir_text_index        [DIR_TEXT_SIZE];
 
 #define lua_push_pack_type(L,pack_type)        lua_rawgeti(L, LUA_REGISTRYINDEX, l_pack_type_index[pack_type] );
 #define lua_push_group_code(L,group_code)      lua_rawgeti(L, LUA_REGISTRYINDEX, l_group_code_index[group_code]);
 #define lua_push_local_par_mode(L,par_mode)    lua_rawgeti(L, LUA_REGISTRYINDEX, l_local_par_index[par_mode]);
 #define lua_push_math_style_name(L,style_name) lua_rawgeti(L, LUA_REGISTRYINDEX, l_math_style_name_index[style_name]);
-
-#define lua_push_direction(L,direction) \
-    if (direction < 0) { \
-        lua_pushnil(L); \
-    } else { \
-        lua_pushinteger(L,direction); \
-    }
-
-#define lua_push_dir_par(L,dir) \
-    if (dir < 0) { \
-        lua_pushnil(L); \
-    } else { \
-        lua_rawgeti(L, LUA_REGISTRYINDEX, l_dir_par_index[dir]); \
-    }
-
-#define lua_push_dir_text_normal(L,dir) \
-    if (dir < 0) { \
-        lua_pushnil(L); \
-    } else { \
-        lua_rawgeti(L, LUA_REGISTRYINDEX, l_dir_text_index_normal[dir]); \
-    }
-
-#define lua_push_dir_text_cancel(L,dir) \
-    if (dir < 0) { \
-        lua_pushnil(L); \
-    } else { \
-        lua_rawgeti(L, LUA_REGISTRYINDEX, l_dir_text_index_cancel[dir]); \
-    }
-
-#define lua_push_dir_text(L,dir,sub) \
-    if (dir < 0) { \
-        lua_pushnil(L); \
-    } else if (sub) { \
-        lua_rawgeti(L, LUA_REGISTRYINDEX, l_dir_text_index_cancel[dir]); \
-    } else { \
-        lua_rawgeti(L, LUA_REGISTRYINDEX, l_dir_text_index_normal[dir]); \
-    }
+#define lua_push_dir_par(L,dir)                lua_rawgeti(L, LUA_REGISTRYINDEX, l_dir_par_index[dir+dir_swap])
+#define lua_push_dir_text(L,dir)               lua_rawgeti(L, LUA_REGISTRYINDEX, l_dir_text_index[dir+dir_swap])
 
 #define lua_push_string_by_index(L,index)      lua_rawgeti(L, LUA_REGISTRYINDEX, index)
 #define lua_push_string_by_name(L,index)       lua_rawgeti(L, LUA_REGISTRYINDEX, lua_key_index(index))
@@ -462,17 +414,21 @@ l_math_style_name_index[cramped_script_s
 l_dir_par_index[dir_TLT]   = lua_key_index(TLT);\
 l_dir_par_index[dir_TRT]   = lua_key_index(TRT);\
 l_dir_par_index[dir_LTL]   = lua_key_index(LTL);\
-l_dir_par_index[dir_RTT]   = lua_key_index(RTT);
+l_dir_par_index[dir_RTT]   = lua_key_index(RTT);\
+l_dir_par_index[dir_TLT+4] = lua_key_index(TLT);\
+l_dir_par_index[dir_TRT+4] = lua_key_index(TRT);\
+l_dir_par_index[dir_LTL+4] = lua_key_index(LTL);\
+l_dir_par_index[dir_RTT+4] = lua_key_index(RTT);\
 
 #define set_l_dir_text_index \
-l_dir_text_index_normal[dir_TLT] = lua_key_index(pTLT);\
-l_dir_text_index_normal[dir_TRT] = lua_key_index(pTRT);\
-l_dir_text_index_normal[dir_LTL] = lua_key_index(pLTL);\
-l_dir_text_index_normal[dir_RTT] = lua_key_index(pRTT);\
-l_dir_text_index_cancel[dir_TLT] = lua_key_index(mTLT);\
-l_dir_text_index_cancel[dir_TRT] = lua_key_index(mTRT);\
-l_dir_text_index_cancel[dir_LTL] = lua_key_index(mLTL);\
-l_dir_text_index_cancel[dir_RTT] = lua_key_index(mRTT);
+l_dir_text_index[dir_TLT]   = lua_key_index(mTLT);\
+l_dir_text_index[dir_TRT]   = lua_key_index(mTRT);\
+l_dir_text_index[dir_LTL]   = lua_key_index(mLTL);\
+l_dir_text_index[dir_RTT]   = lua_key_index(mRTT);\
+l_dir_text_index[dir_TLT+4] = lua_key_index(pTLT);\
+l_dir_text_index[dir_TRT+4] = lua_key_index(pTRT);\
+l_dir_text_index[dir_LTL+4] = lua_key_index(pLTL);\
+l_dir_text_index[dir_RTT+4] = lua_key_index(pRTT);\
 
 #define img_parms_max     25
 #define img_pageboxes_max  6
@@ -482,7 +438,6 @@ extern int img_pageboxes [img_pageboxes_
 
 # define set_l_img_keys_index \
 img_parms[ 0] = lua_key_index(attr); \
-img_parms[ 0] = lua_key_index(attribute_list); \
 img_parms[ 1] = lua_key_index(bbox); \
 img_parms[ 2] = lua_key_index(colordepth); \
 img_parms[ 3] = lua_key_index(colorspace); \
@@ -519,16 +474,17 @@ img_pageboxes[5] = lua_key_index(art); \
 #define lua_push_img_key(L,key)     lua_rawgeti(L, LUA_REGISTRYINDEX, img_parms[key] );
 #define lua_push_img_pagebox(L,box) lua_rawgeti(L, LUA_REGISTRYINDEX, img_pageboxes[box]);
 
-extern int lua_show_valid_list(lua_State *L, const char **list, int offset, int max);
+extern int lua_show_valid_list(lua_State *L, const char **list, int max);
 extern int lua_show_valid_keys(lua_State *L, int *list, int max);
 
 #define set_make_keys \
-make_lua_key(__index);\
-make_lua_key(above);\
-make_lua_key(abovedisplayshortskip);\
-make_lua_key(abovedisplayskip);\
+make_lua_key(cmdname);make_lua_key(expandable);make_lua_key(protected);\
+make_lua_key(LTL);\
+make_lua_key(MathConstants);\
+make_lua_key(RTT);\
+make_lua_key(TLT);\
+make_lua_key(TRT);\
 make_lua_key(accent);\
-make_lua_key(accentkern);\
 make_lua_key(action);\
 make_lua_key(action_id);\
 make_lua_key(action_type);\
@@ -540,107 +496,53 @@ make_lua_key(adjust_head);\
 make_lua_key(adjusted_hbox);\
 make_lua_key(adjustspacing);\
 make_lua_key(advance);\
-make_lua_key(after_assignment);\
 make_lua_key(after_display);\
-make_lua_key(after_group);\
 make_lua_key(after_output);\
-make_lua_key(afterdisplaypenalty);\
 make_lua_key(align);\
 make_lua_key(align_head);\
-make_lua_key(align_record);\
 make_lua_key(align_set);\
-make_lua_key(align_stack);\
 make_lua_key(alignment);\
-make_lua_key(always);\
 make_lua_key(annot);\
 make_lua_key(area);\
 make_lua_key(art);\
-make_lua_key(assign_attr);\
-make_lua_key(assign_box_dir);\
-make_lua_key(assign_box_direction);\
-make_lua_key(assign_dimen);\
-make_lua_key(assign_dir);\
-make_lua_key(assign_direction);\
-make_lua_key(assign_font_dimen);\
-make_lua_key(assign_font_int);\
-make_lua_key(assign_glue);\
-make_lua_key(assign_hang_indent);\
-make_lua_key(assign_int);\
-make_lua_key(assign_local_box);\
-make_lua_key(assign_mu_glue);\
-make_lua_key(assign_toks);\
 make_lua_key(attr);\
-make_lua_key(attribute);\
-make_lua_key(attribute_list);\
 make_lua_key(attributes);\
-make_lua_key(automatic);\
-make_lua_key(baselineskip);\
 make_lua_key(bbox);\
 make_lua_key(before_display);\
-make_lua_key(beforedisplaypenalty);\
-make_lua_key(begin_group);\
-make_lua_key(beginmath);\
-make_lua_key(belowdisplayshortskip);\
-make_lua_key(belowdisplayskip);\
 make_lua_key(best_ins_ptr);\
 make_lua_key(best_page_break);\
 make_lua_key(best_size);\
-make_lua_key(bin);\
 make_lua_key(bleed);\
 make_lua_key(bot);\
 make_lua_key(bot_accent);\
-make_lua_key(bothflexible);\
 make_lua_key(bottom_left);\
 make_lua_key(bottom_right);\
 make_lua_key(boundary);\
 make_lua_key(box);\
 make_lua_key(box_left);\
 make_lua_key(box_left_width);\
-make_lua_key(box_ref);\
 make_lua_key(box_right);\
 make_lua_key(box_right_width);\
-make_lua_key(box_there);\
-make_lua_key(break_penalty);\
 make_lua_key(broken_ins);\
 make_lua_key(broken_ptr);\
 make_lua_key(brokenpenalty);\
 make_lua_key(cache);\
 make_lua_key(cal_expand_ratio);\
-make_lua_key(call);\
-make_lua_key(cancel);\
-make_lua_key(car_ret);\
-make_lua_key(case_shift);\
-make_lua_key(Catalog);\
 make_lua_key(catalog);\
-make_lua_key(cell);\
 make_lua_key(char);\
-make_lua_key(char_ghost);\
-make_lua_key(char_given);\
-make_lua_key(char_num);\
-make_lua_key(character);\
 make_lua_key(characters);\
 make_lua_key(checksum);\
-make_lua_key(choice);\
 make_lua_key(cidinfo);\
 make_lua_key(class);\
-make_lua_key(cleaders);\
-make_lua_key(close);\
 make_lua_key(clubpenalty);\
-make_lua_key(cmd);\
-make_lua_key(cmdname);\
-make_lua_key(color_stack);\
 make_lua_key(colordepth);\
 make_lua_key(colorspace);\
-make_lua_key(combinetoks);\
 make_lua_key(command);\
 make_lua_key(commands);\
 make_lua_key(comment);\
 make_lua_key(components);\
 make_lua_key(compresslevel);\
-make_lua_key(conditionalmathskip);\
 make_lua_key(contrib_head);\
-make_lua_key(convert);\
-make_lua_key(copy_font);\
 make_lua_key(core);\
 make_lua_key(cost);\
 make_lua_key(count);\
@@ -649,21 +551,11 @@ make_lua_key(crampedscript);\
 make_lua_key(crampedscriptscript);\
 make_lua_key(crampedtext);\
 make_lua_key(crop);\
-make_lua_key(cs_name);\
 make_lua_key(csname);\
-make_lua_key(current);\
 make_lua_key(data);\
-make_lua_key(def);\
-make_lua_key(def_char_code);\
-make_lua_key(def_del_code);\
-make_lua_key(def_family);\
-make_lua_key(def_font);\
-make_lua_key(def_lua_call);\
 make_lua_key(degree);\
 make_lua_key(delim);\
-make_lua_key(delim_num);\
 make_lua_key(delimptr);\
-make_lua_key(delta);\
 make_lua_key(demerits);\
 make_lua_key(denom);\
 make_lua_key(depth);\
@@ -676,92 +568,46 @@ make_lua_key(direct);\
 make_lua_key(direction);\
 make_lua_key(dirs);\
 make_lua_key(disc);\
-make_lua_key(discretionary);\
 make_lua_key(display);\
-make_lua_key(divide);\
-make_lua_key(dont_expand);\
 make_lua_key(doublehyphendemerits);\
 make_lua_key(down);\
 make_lua_key(embedding);\
 make_lua_key(emergencystretch);\
-make_lua_key(empty);\
 make_lua_key(empty_string);\
 make_lua_key(encodingbytes);\
 make_lua_key(encodingname);\
 make_lua_key(end);\
-make_lua_key(end_cs_name);\
-make_lua_key(end_group);\
-make_lua_key(end_template);\
-make_lua_key(endmath);\
-make_lua_key(endv);\
-make_lua_key(eq_no);\
+make_lua_key(etex);\
 make_lua_key(equation);\
 make_lua_key(equation_number);\
-make_lua_key(equationnumber);\
-make_lua_key(equationnumberpenalty);\
-make_lua_key(etex);\
-make_lua_key(ex_space);\
 make_lua_key(exactly);\
-make_lua_key(expand_after);\
-make_lua_key(expand_font);\
-make_lua_key(expandable);\
 make_lua_key(expansion_factor);\
-make_lua_key(explicit);\
-make_lua_key(expr_stack);\
 make_lua_key(ext);\
-make_lua_key(extdef_del_code);\
-make_lua_key(extdef_math_code);\
 make_lua_key(extend);\
 make_lua_key(extender);\
 make_lua_key(extensible);\
-make_lua_key(extension);\
 make_lua_key(extra_space);\
 make_lua_key(fam);\
 make_lua_key(fast);\
-make_lua_key(feedback);\
 make_lua_key(fence);\
-make_lua_key(fi);\
-make_lua_key(fi_or_else);\
-make_lua_key(fil);\
 make_lua_key(file);\
 make_lua_key(filename);\
 make_lua_key(filepath);\
 make_lua_key(fill);\
-make_lua_key(filll);\
-make_lua_key(fillll);\
 make_lua_key(fin_row);\
 make_lua_key(finalhyphendemerits);\
-make_lua_key(finalpenalty);\
-make_lua_key(first);\
-make_lua_key(fit);\
-make_lua_key(fitb);\
-make_lua_key(fitbh);\
-make_lua_key(fitbv);\
-make_lua_key(fith);\
-make_lua_key(fitr);\
-make_lua_key(fitv);\
-make_lua_key(fixedboth);\
-make_lua_key(fixedbottom);\
-make_lua_key(fixedtop);\
 make_lua_key(font);\
-make_lua_key(fontkern);\
 make_lua_key(fonts);\
 make_lua_key(format);\
 make_lua_key(fraction);\
 make_lua_key(fullname);\
-make_lua_key(ghost);\
-make_lua_key(gleaders);\
 make_lua_key(global);\
 make_lua_key(glue);\
 make_lua_key(glue_order);\
-make_lua_key(glue_ref);\
 make_lua_key(glue_set);\
 make_lua_key(glue_sign);\
-make_lua_key(glue_spec);\
 make_lua_key(glyph);\
-make_lua_key(goto);\
 make_lua_key(h);\
-make_lua_key(halign);\
 make_lua_key(hangafter);\
 make_lua_key(hangindent);\
 make_lua_key(hbox);\
@@ -769,37 +615,20 @@ make_lua_key(head);\
 make_lua_key(height);\
 make_lua_key(hlist);\
 make_lua_key(hmode_par);\
-make_lua_key(hmove);\
 make_lua_key(hold_head);\
 make_lua_key(horiz_variants);\
-make_lua_key(hrule);\
 make_lua_key(hsize);\
-make_lua_key(hskip);\
-make_lua_key(hyph_data);\
-make_lua_key(hyphenated);\
 make_lua_key(hyphenchar);\
 make_lua_key(id);\
 make_lua_key(identity);\
-make_lua_key(if_stack);\
-make_lua_key(if_test);\
-make_lua_key(ignore_spaces);\
 make_lua_key(image);\
 make_lua_key(imagetype);\
 make_lua_key(immediate);\
-make_lua_key(in_stream);\
-make_lua_key(indent);\
 make_lua_key(index);\
 make_lua_key(info);\
-make_lua_key(Info);\
-make_lua_key(inner);\
-make_lua_key(input);\
-make_lua_key(ins);\
 make_lua_key(insert);\
-make_lua_key(inserts_only);\
 make_lua_key(interlinepenalty);\
-make_lua_key(ital_corr);\
 make_lua_key(italic);\
-make_lua_key(italiccorrection);\
 make_lua_key(keepopen);\
 make_lua_key(kern);\
 make_lua_key(kerns);\
@@ -807,191 +636,95 @@ make_lua_key(lang);\
 make_lua_key(large_char);\
 make_lua_key(large_fam);\
 make_lua_key(last_ins_ptr);\
-make_lua_key(last_item);\
 make_lua_key(lastlinefit);\
-make_lua_key(late_lua);\
 make_lua_key(leader);\
-make_lua_key(leader_ship);\
-make_lua_key(leaders);\
 make_lua_key(least_page_cost);\
 make_lua_key(left);\
 make_lua_key(left_boundary);\
-make_lua_key(left_brace);\
 make_lua_key(left_protruding);\
-make_lua_key(left_right);\
 make_lua_key(leftskip);\
-make_lua_key(let);\
-make_lua_key(letter);\
-make_lua_key(letterspace_font);\
 make_lua_key(level);\
-make_lua_key(ligature);\
 make_lua_key(ligatures);\
-make_lua_key(limit_switch);\
-make_lua_key(line);\
-make_lua_key(linebreakpenalty);\
 make_lua_key(linepenalty);\
-make_lua_key(lineskip);\
 make_lua_key(link_attr);\
 make_lua_key(list);\
 make_lua_key(local_box);\
-make_lua_key(local_par);\
 make_lua_key(log);\
-make_lua_key(long_call);\
-make_lua_key(long_outer_call);\
 make_lua_key(looseness);\
-make_lua_key(LTL);\
 make_lua_key(lua);\
-make_lua_key(lua_bytecode_call);\
 make_lua_key(lua_bytecodes_indirect);\
-make_lua_key(lua_call);\
-make_lua_key(lua_expandable_call);\
-make_lua_key(lua_local_call);\
-make_lua_key(lua_function_call);\
 make_lua_key(lua_functions);\
 make_lua_key(luatex);\
 make_lua_key(luatex_node);\
 make_lua_key(luatex_token);\
-make_lua_key(luatex_pdfe);\
-make_lua_key(luatex_pdfe_dictionary);\
-make_lua_key(luatex_pdfe_array);\
-make_lua_key(luatex_pdfe_stream);\
-make_lua_key(luatex_pdfe_reference);\
-make_lua_key(mac_param);\
-make_lua_key(make_box);\
-make_lua_key(margin_kern);\
+make_lua_key(mLTL);\
+make_lua_key(mRTT);\
+make_lua_key(mTLT);\
+make_lua_key(mTRT);\
 make_lua_key(marginkern);\
 make_lua_key(mark);\
 make_lua_key(math);\
-make_lua_key(math_accent);\
-make_lua_key(math_char);\
-make_lua_key(math_char_num);\
 make_lua_key(math_choice);\
-make_lua_key(math_comp);\
-make_lua_key(math_given);\
 make_lua_key(math_left);\
 make_lua_key(math_shift);\
-make_lua_key(math_shift_cs);\
-make_lua_key(math_style);\
-make_lua_key(math_sub_box);\
-make_lua_key(math_sub_mlist);\
-make_lua_key(math_text_char);\
-make_lua_key(MathConstants);\
 make_lua_key(mathdir);\
 make_lua_key(mathkern);\
-make_lua_key(mathskip);\
 make_lua_key(mathstyle);\
 make_lua_key(media);\
-make_lua_key(medmuskip);\
-make_lua_key(message);\
 make_lua_key(mid);\
 make_lua_key(middle);\
-make_lua_key(mkern);\
-make_lua_key(mLTL);\
 make_lua_key(mode);\
 make_lua_key(modeline);\
-make_lua_key(movement_stack);\
-make_lua_key(mRTT);\
-make_lua_key(mskip);\
-make_lua_key(mTLT);\
-make_lua_key(mTRT);\
-make_lua_key(muglue);\
-make_lua_key(multiply);\
 make_lua_key(name);\
 make_lua_key(named_id);\
 make_lua_key(names);\
-make_lua_key(nested_list);\
-make_lua_key(new);\
 make_lua_key(new_graf);\
 make_lua_key(new_window);\
 make_lua_key(next);\
 make_lua_key(no);\
-make_lua_key(nolength);\
 make_lua_key(no_align);\
-make_lua_key(no_expand);\
-make_lua_key(no_super_sub_script);\
 make_lua_key(noad);\
-make_lua_key(noadpenalty);\
 make_lua_key(node);\
 make_lua_key(node_properties);\
 make_lua_key(node_properties_indirect);\
-make_lua_key(nohrule);\
 make_lua_key(nomath);\
-make_lua_key(non_script);\
 make_lua_key(none);\
-make_lua_key(nonew);\
 make_lua_key(nop);\
-make_lua_key(normal);\
-make_lua_key(novrule);\
 make_lua_key(nucleus);\
 make_lua_key(num);\
 make_lua_key(number);\
 make_lua_key(objcompression);\
 make_lua_key(objnum);\
 make_lua_key(oldmath);\
-make_lua_key(omit);\
-make_lua_key(opdisplaylimits);\
-make_lua_key(open);\
-make_lua_key(oplimits);\
-make_lua_key(opnolimits);\
-make_lua_key(option);\
-make_lua_key(options);\
-make_lua_key(ord);\
 make_lua_key(ordering);\
+make_lua_key(options);\
 make_lua_key(orientation);\
 make_lua_key(origin);\
-make_lua_key(other_char);\
-make_lua_key(outer_call);\
-make_lua_key(outline);\
 make_lua_key(output);\
-make_lua_key(over);\
 make_lua_key(overlay_accent);\
-make_lua_key(ownerpassword);\
+make_lua_key(pLTL);\
+make_lua_key(pRTT);\
+make_lua_key(pTLT);\
+make_lua_key(pTRT);\
 make_lua_key(page);\
+make_lua_key(pages);\
 make_lua_key(page_discards_head);\
 make_lua_key(page_head);\
 make_lua_key(page_ins_head);\
-make_lua_key(page_insert);\
 make_lua_key(pageattributes);\
 make_lua_key(pagebox);\
 make_lua_key(pageresources);\
-make_lua_key(pages);\
-make_lua_key(Pages);\
 make_lua_key(pagesattributes);\
-make_lua_key(pagestate);\
-make_lua_key(par_end);\
 make_lua_key(parameters);\
 make_lua_key(pardir);\
-make_lua_key(parfillskip);\
 make_lua_key(parshape);\
-make_lua_key(parskip);\
-make_lua_key(passive);\
 make_lua_key(pdf);\
-make_lua_key(pdfe);\
-make_lua_key(pdf_action);\
-make_lua_key(pdf_annot);\
-make_lua_key(pdf_colorstack);\
 make_lua_key(pdf_data);\
-make_lua_key(pdf_dest);\
 make_lua_key(pdf_destination);\
-make_lua_key(pdf_end_link);\
-make_lua_key(pdf_end_thread);\
-make_lua_key(pdf_link_data);\
 make_lua_key(pdf_literal);\
-make_lua_key(pdf_refobj);\
-make_lua_key(pdf_restore);\
-make_lua_key(pdf_save);\
-make_lua_key(pdf_setmatrix);\
-make_lua_key(pdf_setobj);\
-make_lua_key(pdf_start);\
-make_lua_key(pdf_start_link);\
-make_lua_key(pdf_start_thread);\
-make_lua_key(pdf_thread);\
-make_lua_key(pdf_thread_data);\
-make_lua_key(pdf_window);\
 make_lua_key(pen_broken);\
 make_lua_key(pen_inter);\
 make_lua_key(penalty);\
-make_lua_key(pLTL);\
 make_lua_key(pop);\
 make_lua_key(post);\
 make_lua_key(post_linebreak);\
@@ -1001,71 +734,35 @@ make_lua_key(pre_adjust_head);\
 make_lua_key(pre_align);\
 make_lua_key(pre_box);\
 make_lua_key(preamble);\
-make_lua_key(prefix);\
 make_lua_key(pretolerance);\
 make_lua_key(prev);\
 make_lua_key(prevdepth);\
 make_lua_key(prevgraf);\
-make_lua_key(protected);\
 make_lua_key(protrudechars);\
-make_lua_key(protrusion);\
-make_lua_key(pRTT);\
-make_lua_key(pseudo_file);\
-make_lua_key(pseudo_line);\
 make_lua_key(psname);\
-make_lua_key(pTLT);\
 make_lua_key(ptr);\
-make_lua_key(pTRT);\
-make_lua_key(punct);\
 make_lua_key(push);\
 make_lua_key(quad);\
 make_lua_key(radical);\
 make_lua_key(raw);\
-make_lua_key(read_to_cs);\
-make_lua_key(recompress);\
 make_lua_key(ref_count);\
 make_lua_key(reg);\
-make_lua_key(register);\
 make_lua_key(registry);\
-make_lua_key(regular);\
-make_lua_key(rel);\
-make_lua_key(relax);\
-make_lua_key(remove_item);\
 make_lua_key(renew);\
 make_lua_key(rep);\
 make_lua_key(replace);\
 make_lua_key(resources);\
 make_lua_key(right);\
 make_lua_key(right_boundary);\
-make_lua_key(right_brace);\
 make_lua_key(right_protruding);\
 make_lua_key(rightskip);\
 make_lua_key(rotation);\
-make_lua_key(RTT);\
 make_lua_key(rule);\
-make_lua_key(save_pos);\
 make_lua_key(scale);\
 make_lua_key(script);\
 make_lua_key(scriptscript);\
-make_lua_key(second);\
 make_lua_key(semi_simple);\
-make_lua_key(set);\
-make_lua_key(set_aux);\
-make_lua_key(set_box);\
-make_lua_key(set_box_dimen);\
-make_lua_key(set_etex_shape);\
-make_lua_key(set_font);\
-make_lua_key(set_font_id);\
-make_lua_key(set_interaction);\
-make_lua_key(set_math_param);\
-make_lua_key(set_page_dimen);\
-make_lua_key(set_page_int);\
-make_lua_key(set_prev_graf);\
-make_lua_key(set_tex_shape);\
-make_lua_key(shape);\
-make_lua_key(shape_ref);\
 make_lua_key(shift);\
-make_lua_key(shorthand_def);\
 make_lua_key(shrink);\
 make_lua_key(shrink_order);\
 make_lua_key(simple);\
@@ -1079,22 +776,13 @@ make_lua_key(space);\
 make_lua_key(space_shrink);\
 make_lua_key(space_stretch);\
 make_lua_key(spacefactor);\
-make_lua_key(spacer);\
-make_lua_key(spaceskip);\
-make_lua_key(span);\
-make_lua_key(spec);\
 make_lua_key(special);\
 make_lua_key(split_discards_head);\
-make_lua_key(split_insert);\
 make_lua_key(split_keep);\
 make_lua_key(split_off);\
-make_lua_key(splittopskip);\
-make_lua_key(squeeze);\
 make_lua_key(stack);\
 make_lua_key(start);\
-make_lua_key(start_par);\
 make_lua_key(step);\
-make_lua_key(stop);\
 make_lua_key(stream);\
 make_lua_key(streamfile);\
 make_lua_key(streamprovider);\
@@ -1103,122 +791,72 @@ make_lua_key(stretch_order);\
 make_lua_key(string);\
 make_lua_key(style);\
 make_lua_key(sub);\
-make_lua_key(sub_box);\
-make_lua_key(sub_mark);\
-make_lua_key(sub_mlist);\
 make_lua_key(subst_ex_font);\
 make_lua_key(subtype);\
 make_lua_key(sup);\
-make_lua_key(sup_mark);\
-make_lua_key(super_sub_script);\
 make_lua_key(supplement);\
 make_lua_key(surround);\
-make_lua_key(tab_mark);\
-make_lua_key(tabskip);\
 make_lua_key(tail);\
-make_lua_key(temp);\
 make_lua_key(temp_head);\
 make_lua_key(term);\
 make_lua_key(term_and_log);\
 make_lua_key(tex);\
 make_lua_key(text);\
-make_lua_key(the);\
-make_lua_key(thickmuskip);\
-make_lua_key(thinmuskip);\
-make_lua_key(thread);\
 make_lua_key(thread_attr);\
 make_lua_key(thread_id);\
-make_lua_key(TLT);\
+make_lua_key(tolerance);\
 make_lua_key(tok);\
 make_lua_key(token);\
-make_lua_key(toks_register);\
-make_lua_key(tolerance);\
 make_lua_key(top);\
 make_lua_key(top_accent);\
-make_lua_key(top_bot_mark);\
 make_lua_key(top_left);\
 make_lua_key(top_right);\
-make_lua_key(topskip);\
 make_lua_key(tounicode);\
 make_lua_key(tracingparagraphs);\
 make_lua_key(trailer);\
-make_lua_key(Trailer);\
 make_lua_key(trailerid);\
 make_lua_key(transform);\
 make_lua_key(trim);\
-make_lua_key(TRT);\
 make_lua_key(type);\
 make_lua_key(uchyph);\
-make_lua_key(udelimiterover);\
-make_lua_key(udelimiterunder);\
-make_lua_key(un_hbox);\
-make_lua_key(un_vbox);\
-make_lua_key(undefined_cs);\
-make_lua_key(under);\
-make_lua_key(unhyphenated);\
 make_lua_key(units_per_em);\
-make_lua_key(unknown);\
-make_lua_key(unset);\
-make_lua_key(uoverdelimiter);\
-make_lua_key(uradical);\
-make_lua_key(uroot);\
 make_lua_key(used);\
-make_lua_key(user);\
-make_lua_key(userpassword);\
-make_lua_key(user_defined);\
 make_lua_key(user_id);\
-make_lua_key(userkern);\
-make_lua_key(userpenalty);\
-make_lua_key(userskip);\
-make_lua_key(uunderdelimiter);\
 make_lua_key(v);\
-make_lua_key(vadjust);\
-make_lua_key(valign);\
 make_lua_key(value);\
-make_lua_key(variable);\
 make_lua_key(vbox);\
 make_lua_key(vcenter);\
 make_lua_key(version);\
 make_lua_key(vert_italic);\
 make_lua_key(vert_variants);\
+make_lua_key(vmode_par);\
 make_lua_key(visiblefilename);\
 make_lua_key(vlist);\
-make_lua_key(vmode_par);\
-make_lua_key(vmove);\
-make_lua_key(vrule);\
-make_lua_key(vskip);\
 make_lua_key(vtop);\
-make_lua_key(whatsit);\
 make_lua_key(widowpenalty);\
 make_lua_key(width);\
-make_lua_key(word);\
-make_lua_key(wordpenalty);\
-make_lua_key(write); \
-make_lua_key(writingmode); \
 make_lua_key(x_height);\
 make_lua_key(xadvance);\
-make_lua_key(xformattributes);\
 make_lua_key(xformresources);\
-make_lua_key(xleaders);\
-make_lua_key(xmath_given);\
+make_lua_key(xformattributes);\
 make_lua_key(xoffset);\
-make_lua_key(xray);\
 make_lua_key(xres);\
 make_lua_key(xsize);\
-make_lua_key(xspaceskip);\
-make_lua_key(xyz);\
 make_lua_key(xyz_zoom);\
 make_lua_key(yoffset); \
 make_lua_key(yres); \
-make_lua_key(ysize);
+make_lua_key(ysize); \
+make_lua_key(writingmode); \
+make_lua_key(__index)
 
 #define set_init_keys \
-init_lua_key(__index);\
-init_lua_key(above);\
-init_lua_key(abovedisplayshortskip);\
-init_lua_key(abovedisplayskip);\
+init_lua_key(cmdname);init_lua_key(expandable);init_lua_key(protected);\
+init_lua_key(LTL);\
+init_lua_key(MathConstants);\
+init_lua_key(RTT);\
+init_lua_key(TLT);\
+init_lua_key(TRT);\
 init_lua_key(accent);\
-init_lua_key(accentkern);\
 init_lua_key(action);\
 init_lua_key(action_id);\
 init_lua_key(action_type);\
@@ -1230,107 +868,53 @@ init_lua_key(adjust_head);\
 init_lua_key(adjusted_hbox);\
 init_lua_key(adjustspacing);\
 init_lua_key(advance);\
-init_lua_key(after_assignment);\
 init_lua_key(after_display);\
-init_lua_key(after_group);\
 init_lua_key(after_output);\
-init_lua_key(afterdisplaypenalty);\
 init_lua_key(align);\
 init_lua_key(align_head);\
-init_lua_key(align_record);\
 init_lua_key(align_set);\
-init_lua_key(align_stack);\
 init_lua_key(alignment);\
-init_lua_key(always);\
 init_lua_key(annot);\
 init_lua_key(area);\
 init_lua_key(art);\
-init_lua_key(assign_attr);\
-init_lua_key(assign_box_dir);\
-init_lua_key(assign_box_direction);\
-init_lua_key(assign_dimen);\
-init_lua_key(assign_dir);\
-init_lua_key(assign_direction);\
-init_lua_key(assign_font_dimen);\
-init_lua_key(assign_font_int);\
-init_lua_key(assign_glue);\
-init_lua_key(assign_hang_indent);\
-init_lua_key(assign_int);\
-init_lua_key(assign_local_box);\
-init_lua_key(assign_mu_glue);\
-init_lua_key(assign_toks);\
 init_lua_key(attr);\
-init_lua_key(attribute);\
-init_lua_key(attribute_list);\
 init_lua_key(attributes);\
-init_lua_key(automatic);\
-init_lua_key(baselineskip);\
 init_lua_key(bbox);\
 init_lua_key(before_display);\
-init_lua_key(beforedisplaypenalty);\
-init_lua_key(begin_group);\
-init_lua_key(beginmath);\
-init_lua_key(belowdisplayshortskip);\
-init_lua_key(belowdisplayskip);\
 init_lua_key(best_ins_ptr);\
 init_lua_key(best_page_break);\
 init_lua_key(best_size);\
-init_lua_key(bin);\
 init_lua_key(bleed);\
 init_lua_key(bot);\
 init_lua_key(bot_accent);\
-init_lua_key(bothflexible);\
 init_lua_key(bottom_left);\
 init_lua_key(bottom_right);\
 init_lua_key(boundary);\
 init_lua_key(box);\
 init_lua_key(box_left);\
 init_lua_key(box_left_width);\
-init_lua_key(box_ref);\
 init_lua_key(box_right);\
 init_lua_key(box_right_width);\
-init_lua_key(box_there);\
-init_lua_key(break_penalty);\
 init_lua_key(broken_ins);\
 init_lua_key(broken_ptr);\
 init_lua_key(brokenpenalty);\
 init_lua_key(cache);\
 init_lua_key(cal_expand_ratio);\
-init_lua_key(call);\
-init_lua_key(cancel);\
-init_lua_key(car_ret);\
-init_lua_key(case_shift);\
-init_lua_key(Catalog);\
 init_lua_key(catalog);\
-init_lua_key(cell);\
 init_lua_key(char);\
-init_lua_key(char_ghost);\
-init_lua_key(char_given);\
-init_lua_key(char_num);\
-init_lua_key(character);\
 init_lua_key(characters);\
 init_lua_key(checksum);\
-init_lua_key(choice);\
 init_lua_key(cidinfo);\
 init_lua_key(class);\
-init_lua_key(cleaders);\
-init_lua_key(close);\
 init_lua_key(clubpenalty);\
-init_lua_key(cmd);\
-init_lua_key(cmdname);\
-init_lua_key(color_stack);\
 init_lua_key(colordepth);\
 init_lua_key(colorspace);\
-init_lua_key(combinetoks);\
 init_lua_key(command);\
 init_lua_key(commands);\
 init_lua_key(comment);\
 init_lua_key(components);\
 init_lua_key(compresslevel);\
-init_lua_key(conditionalmathskip);\
 init_lua_key(contrib_head);\
-init_lua_key(convert);\
-init_lua_key(copy_font);\
 init_lua_key(core);\
 init_lua_key(cost);\
 init_lua_key(count);\
@@ -1339,21 +923,11 @@ init_lua_key(crampedscript);\
 init_lua_key(crampedscriptscript);\
 init_lua_key(crampedtext);\
 init_lua_key(crop);\
-init_lua_key(cs_name);\
 init_lua_key(csname);\
-init_lua_key(current);\
 init_lua_key(data);\
-init_lua_key(def);\
-init_lua_key(def_char_code);\
-init_lua_key(def_del_code);\
-init_lua_key(def_family);\
-init_lua_key(def_font);\
-init_lua_key(def_lua_call);\
 init_lua_key(degree);\
 init_lua_key(delim);\
-init_lua_key(delim_num);\
 init_lua_key(delimptr);\
-init_lua_key(delta);\
 init_lua_key(demerits);\
 init_lua_key(denom);\
 init_lua_key(depth);\
@@ -1366,91 +940,45 @@ init_lua_key(direct);\
 init_lua_key(direction);\
 init_lua_key(dirs);\
 init_lua_key(disc);\
-init_lua_key(discretionary);\
 init_lua_key(display);\
-init_lua_key(divide);\
-init_lua_key(dont_expand);\
 init_lua_key(doublehyphendemerits);\
 init_lua_key(down);\
 init_lua_key(embedding);\
 init_lua_key(emergencystretch);\
-init_lua_key(empty);\
 init_lua_key(encodingbytes);\
 init_lua_key(encodingname);\
 init_lua_key(end);\
-init_lua_key(end_cs_name);\
-init_lua_key(end_group);\
-init_lua_key(end_template);\
-init_lua_key(endmath);\
-init_lua_key(endv);\
-init_lua_key(eq_no);\
+init_lua_key(etex);\
 init_lua_key(equation);\
 init_lua_key(equation_number);\
-init_lua_key(equationnumber);\
-init_lua_key(equationnumberpenalty);\
-init_lua_key(etex);\
-init_lua_key(ex_space);\
 init_lua_key(exactly);\
-init_lua_key(expand_after);\
-init_lua_key(expand_font);\
-init_lua_key(expandable);\
 init_lua_key(expansion_factor);\
-init_lua_key(explicit);\
-init_lua_key(expr_stack);\
 init_lua_key(ext);\
-init_lua_key(extdef_del_code);\
-init_lua_key(extdef_math_code);\
 init_lua_key(extend);\
 init_lua_key(extender);\
 init_lua_key(extensible);\
-init_lua_key(extension);\
 init_lua_key(extra_space);\
 init_lua_key(fam);\
 init_lua_key(fast);\
-init_lua_key(feedback);\
 init_lua_key(fence);\
-init_lua_key(fi);\
-init_lua_key(fi_or_else);\
-init_lua_key(fil);\
 init_lua_key(file);\
 init_lua_key(filename);\
 init_lua_key(filepath);\
 init_lua_key(fill);\
-init_lua_key(filll);\
-init_lua_key(fillll);\
 init_lua_key(fin_row);\
 init_lua_key(finalhyphendemerits);\
-init_lua_key(finalpenalty);\
-init_lua_key(first);\
-init_lua_key(fit);\
-init_lua_key(fitb);\
-init_lua_key(fitbh);\
-init_lua_key(fitbv);\
-init_lua_key(fith);\
-init_lua_key(fitr);\
-init_lua_key(fitv);\
-init_lua_key(fixedboth);\
-init_lua_key(fixedbottom);\
-init_lua_key(fixedtop);\
 init_lua_key(font);\
-init_lua_key(fontkern);\
 init_lua_key(fonts);\
 init_lua_key(format);\
 init_lua_key(fraction);\
 init_lua_key(fullname);\
-init_lua_key(ghost);\
-init_lua_key(gleaders);\
 init_lua_key(global);\
 init_lua_key(glue);\
 init_lua_key(glue_order);\
-init_lua_key(glue_ref);\
 init_lua_key(glue_set);\
 init_lua_key(glue_sign);\
-init_lua_key(glue_spec);\
 init_lua_key(glyph);\
-init_lua_key(goto);\
 init_lua_key(h);\
-init_lua_key(halign);\
 init_lua_key(hangafter);\
 init_lua_key(hangindent);\
 init_lua_key(hbox);\
@@ -1458,37 +986,20 @@ init_lua_key(head);\
 init_lua_key(height);\
 init_lua_key(hlist);\
 init_lua_key(hmode_par);\
-init_lua_key(hmove);\
 init_lua_key(hold_head);\
 init_lua_key(horiz_variants);\
-init_lua_key(hrule);\
 init_lua_key(hsize);\
-init_lua_key(hskip);\
-init_lua_key(hyph_data);\
-init_lua_key(hyphenated);\
 init_lua_key(hyphenchar);\
 init_lua_key(id);\
 init_lua_key(identity);\
-init_lua_key(if_stack);\
-init_lua_key(if_test);\
-init_lua_key(ignore_spaces);\
 init_lua_key(image);\
 init_lua_key(imagetype);\
 init_lua_key(immediate);\
-init_lua_key(in_stream);\
-init_lua_key(indent);\
 init_lua_key(index);\
 init_lua_key(info);\
-init_lua_key(Info);\
-init_lua_key(inner);\
-init_lua_key(input);\
-init_lua_key(ins);\
 init_lua_key(insert);\
-init_lua_key(inserts_only);\
 init_lua_key(interlinepenalty);\
-init_lua_key(ital_corr);\
 init_lua_key(italic);\
-init_lua_key(italiccorrection);\
 init_lua_key(keepopen);\
 init_lua_key(kern);\
 init_lua_key(kerns);\
@@ -1496,179 +1007,82 @@ init_lua_key(lang);\
 init_lua_key(large_char);\
 init_lua_key(large_fam);\
 init_lua_key(last_ins_ptr);\
-init_lua_key(last_item);\
 init_lua_key(lastlinefit);\
-init_lua_key(late_lua);\
+init_lua_key(leftskip);\
 init_lua_key(leader);\
-init_lua_key(leader_ship);\
-init_lua_key(leaders);\
 init_lua_key(least_page_cost);\
 init_lua_key(left);\
 init_lua_key(left_boundary);\
-init_lua_key(left_brace);\
 init_lua_key(left_protruding);\
-init_lua_key(left_right);\
 init_lua_key(leftskip);\
-init_lua_key(let);\
-init_lua_key(letter);\
-init_lua_key(letterspace_font);\
 init_lua_key(level);\
-init_lua_key(ligature);\
 init_lua_key(ligatures);\
-init_lua_key(limit_switch);\
-init_lua_key(line);\
-init_lua_key(linebreakpenalty);\
+init_lua_key(leftskip);\
 init_lua_key(linepenalty);\
-init_lua_key(lineskip);\
 init_lua_key(link_attr);\
 init_lua_key(list);\
 init_lua_key(local_box);\
-init_lua_key(local_par);\
 init_lua_key(log);\
-init_lua_key(long_call);\
-init_lua_key(long_outer_call);\
 init_lua_key(looseness);\
-init_lua_key(LTL);\
 init_lua_key(lua);\
-init_lua_key(lua_bytecode_call);\
 init_lua_key(lua_bytecodes_indirect);\
-init_lua_key(lua_call);\
-init_lua_key(lua_expandable_call);\
-init_lua_key(lua_local_call);\
-init_lua_key(lua_function_call);\
 init_lua_key(lua_functions);\
 init_lua_key(luatex);\
 init_lua_key(luatex_node);\
 init_lua_key(luatex_token);\
-init_lua_key(luatex_pdfe);\
-init_lua_key(luatex_pdfe_dictionary);\
-init_lua_key(luatex_pdfe_array);\
-init_lua_key(luatex_pdfe_stream);\
-init_lua_key(luatex_pdfe_reference);\
-init_lua_key(mac_param);\
-init_lua_key(make_box);\
-init_lua_key(margin_kern);\
 init_lua_key(marginkern);\
 init_lua_key(mark);\
 init_lua_key(math);\
-init_lua_key(math_accent);\
-init_lua_key(math_char);\
-init_lua_key(math_char_num);\
 init_lua_key(math_choice);\
-init_lua_key(math_comp);\
-init_lua_key(math_given);\
 init_lua_key(math_left);\
 init_lua_key(math_shift);\
-init_lua_key(math_shift_cs);\
-init_lua_key(math_style);\
-init_lua_key(math_sub_box);\
-init_lua_key(math_sub_mlist);\
-init_lua_key(math_text_char);\
-init_lua_key(MathConstants);\
 init_lua_key(mathdir);\
 init_lua_key(mathkern);\
-init_lua_key(mathskip);\
 init_lua_key(mathstyle);\
 init_lua_key(media);\
-init_lua_key(medmuskip);\
-init_lua_key(message);\
 init_lua_key(mid);\
 init_lua_key(middle);\
-init_lua_key(mkern);\
 init_lua_key(mode);\
 init_lua_key(modeline);\
-init_lua_key(movement_stack);\
-init_lua_key(mskip);\
-init_lua_key(muglue);\
-init_lua_key(multiply);\
 init_lua_key(name);\
 init_lua_key(named_id);\
 init_lua_key(names);\
-init_lua_key(nested_list);\
-init_lua_key(new);\
 init_lua_key(new_graf);\
 init_lua_key(new_window);\
 init_lua_key(next);\
 init_lua_key(no);\
-init_lua_key(nolength);\
 init_lua_key(no_align);\
-init_lua_key(no_expand);\
-init_lua_key(no_super_sub_script);\
 init_lua_key(noad);\
-init_lua_key(noadpenalty);\
 init_lua_key(node);\
-init_lua_key(nohrule);\
 init_lua_key(nomath);\
-init_lua_key(non_script);\
 init_lua_key(none);\
-init_lua_key(nonew);\
 init_lua_key(nop);\
-init_lua_key(normal);\
-init_lua_key(novrule);\
 init_lua_key(nucleus);\
 init_lua_key(num);\
 init_lua_key(number);\
 init_lua_key(objcompression);\
 init_lua_key(objnum);\
 init_lua_key(oldmath);\
-init_lua_key(omit);\
-init_lua_key(opdisplaylimits);\
-init_lua_key(open);\
-init_lua_key(oplimits);\
-init_lua_key(opnolimits);\
-init_lua_key(option);\
 init_lua_key(options);\
-init_lua_key(ord);\
-init_lua_key(ordering);\
 init_lua_key(orientation);\
 init_lua_key(origin);\
-init_lua_key(other_char);\
-init_lua_key(outer_call);\
-init_lua_key(outline);\
+init_lua_key(ordering);\
 init_lua_key(output);\
-init_lua_key(over);\
 init_lua_key(overlay_accent);\
-init_lua_key(ownerpassword);\
 init_lua_key(page);\
+init_lua_key(pages);\
 init_lua_key(page_discards_head);\
 init_lua_key(page_head);\
 init_lua_key(page_ins_head);\
-init_lua_key(page_insert);\
 init_lua_key(pageattributes);\
 init_lua_key(pagebox);\
 init_lua_key(pageresources);\
-init_lua_key(pages);\
-init_lua_key(Pages);\
 init_lua_key(pagesattributes);\
-init_lua_key(pagestate);\
-init_lua_key(par_end);\
 init_lua_key(parameters);\
 init_lua_key(pardir);\
-init_lua_key(parfillskip);\
 init_lua_key(parshape);\
-init_lua_key(parskip);\
-init_lua_key(passive);\
-init_lua_key(pdfe);\
-init_lua_key(pdf_action);\
-init_lua_key(pdf_annot);\
-init_lua_key(pdf_colorstack);\
-init_lua_key(pdf_dest);\
 init_lua_key(pdf_destination);\
-init_lua_key(pdf_end_link);\
-init_lua_key(pdf_end_thread);\
-init_lua_key(pdf_link_data);\
 init_lua_key(pdf_literal);\
-init_lua_key(pdf_refobj);\
-init_lua_key(pdf_restore);\
-init_lua_key(pdf_save);\
-init_lua_key(pdf_setmatrix);\
-init_lua_key(pdf_setobj);\
-init_lua_key(pdf_start);\
-init_lua_key(pdf_start_link);\
-init_lua_key(pdf_start_thread);\
-init_lua_key(pdf_thread);\
-init_lua_key(pdf_thread_data);\
-init_lua_key(pdf_window);\
 init_lua_key(pen_broken);\
 init_lua_key(pen_inter);\
 init_lua_key(penalty);\
@@ -1681,68 +1095,35 @@ init_lua_key(pre_adjust_head);\
 init_lua_key(pre_align);\
 init_lua_key(pre_box);\
 init_lua_key(preamble);\
-init_lua_key(prefix);\
 init_lua_key(pretolerance);\
 init_lua_key(prev);\
 init_lua_key(prevdepth);\
 init_lua_key(prevgraf);\
-init_lua_key(protected);\
 init_lua_key(protrudechars);\
-init_lua_key(protrusion);\
-init_lua_key(pseudo_file);\
-init_lua_key(pseudo_line);\
 init_lua_key(psname);\
 init_lua_key(ptr);\
-init_lua_key(punct);\
 init_lua_key(push);\
 init_lua_key(quad);\
 init_lua_key(radical);\
 init_lua_key(raw);\
-init_lua_key(read_to_cs);\
 init_lua_key(ref_count);\
-init_lua_key(recompress);\
 init_lua_key(reg);\
-init_lua_key(register);\
 init_lua_key(registry);\
-init_lua_key(regular);\
-init_lua_key(rel);\
-init_lua_key(relax);\
-init_lua_key(remove_item);\
 init_lua_key(renew);\
 init_lua_key(rep);\
 init_lua_key(replace);\
 init_lua_key(resources);\
 init_lua_key(right);\
 init_lua_key(right_boundary);\
-init_lua_key(right_brace);\
 init_lua_key(right_protruding);\
 init_lua_key(rightskip);\
 init_lua_key(rotation);\
-init_lua_key(RTT);\
 init_lua_key(rule);\
-init_lua_key(save_pos);\
 init_lua_key(scale);\
 init_lua_key(script);\
 init_lua_key(scriptscript);\
-init_lua_key(second);\
 init_lua_key(semi_simple);\
-init_lua_key(set);\
-init_lua_key(set_aux);\
-init_lua_key(set_box);\
-init_lua_key(set_box_dimen);\
-init_lua_key(set_etex_shape);\
-init_lua_key(set_font);\
-init_lua_key(set_font_id);\
-init_lua_key(set_interaction);\
-init_lua_key(set_math_param);\
-init_lua_key(set_page_dimen);\
-init_lua_key(set_page_int);\
-init_lua_key(set_prev_graf);\
-init_lua_key(set_tex_shape);\
-init_lua_key(shape);\
-init_lua_key(shape_ref);\
 init_lua_key(shift);\
-init_lua_key(shorthand_def);\
 init_lua_key(shrink);\
 init_lua_key(shrink_order);\
 init_lua_key(simple);\
@@ -1756,22 +1137,13 @@ init_lua_key(space);\
 init_lua_key(space_shrink);\
 init_lua_key(space_stretch);\
 init_lua_key(spacefactor);\
-init_lua_key(spacer);\
-init_lua_key(spaceskip);\
-init_lua_key(span);\
-init_lua_key(spec);\
 init_lua_key(special);\
 init_lua_key(split_discards_head);\
-init_lua_key(split_insert);\
 init_lua_key(split_keep);\
 init_lua_key(split_off);\
-init_lua_key(splittopskip);\
-init_lua_key(squeeze);\
 init_lua_key(stack);\
 init_lua_key(start);\
-init_lua_key(start_par);\
 init_lua_key(step);\
-init_lua_key(stop);\
 init_lua_key(stream);\
 init_lua_key(streamfile);\
 init_lua_key(streamprovider);\
@@ -1780,123 +1152,67 @@ init_lua_key(stretch_order);\
 init_lua_key(string);\
 init_lua_key(style);\
 init_lua_key(sub);\
-init_lua_key(sub_box);\
-init_lua_key(sub_mark);\
-init_lua_key(sub_mlist);\
 init_lua_key(subst_ex_font);\
 init_lua_key(subtype);\
 init_lua_key(sup);\
-init_lua_key(sup_mark);\
-init_lua_key(super_sub_script);\
 init_lua_key(supplement);\
 init_lua_key(surround);\
-init_lua_key(tab_mark);\
-init_lua_key(tabskip);\
 init_lua_key(tail);\
-init_lua_key(temp);\
 init_lua_key(temp_head);\
 init_lua_key(term);\
 init_lua_key(tex);\
 init_lua_key(text);\
-init_lua_key(the);\
-init_lua_key(thickmuskip);\
-init_lua_key(thinmuskip);\
-init_lua_key(thread);\
 init_lua_key(thread_attr);\
 init_lua_key(thread_id);\
-init_lua_key(TLT);\
+init_lua_key(tolerance);\
 init_lua_key(tok);\
 init_lua_key(token);\
-init_lua_key(toks_register);\
-init_lua_key(tolerance);\
 init_lua_key(top);\
 init_lua_key(top_accent);\
-init_lua_key(top_bot_mark);\
 init_lua_key(top_left);\
 init_lua_key(top_right);\
-init_lua_key(topskip);\
 init_lua_key(tounicode);\
 init_lua_key(tracingparagraphs);\
 init_lua_key(trailer);\
-init_lua_key(Trailer);\
 init_lua_key(trailerid);\
 init_lua_key(transform);\
 init_lua_key(trim);\
-init_lua_key(TRT);\
 init_lua_key(type);\
 init_lua_key(uchyph);\
-init_lua_key(udelimiterover);\
-init_lua_key(udelimiterunder);\
-init_lua_key(un_hbox);\
-init_lua_key(un_vbox);\
-init_lua_key(undefined_cs);\
-init_lua_key(under);\
-init_lua_key(unhyphenated);\
 init_lua_key(units_per_em);\
-init_lua_key(unknown);\
-init_lua_key(unset);\
-init_lua_key(uoverdelimiter);\
-init_lua_key(uradical);\
-init_lua_key(uroot);\
 init_lua_key(used);\
-init_lua_key(user);\
-init_lua_key(userpassword);\
-init_lua_key(user_defined);\
 init_lua_key(user_id);\
-init_lua_key(userkern);\
-init_lua_key(userpenalty);\
-init_lua_key(userskip);\
-init_lua_key(uunderdelimiter);\
 init_lua_key(v);\
-init_lua_key(vadjust);\
-init_lua_key(valign);\
 init_lua_key(value);\
-init_lua_key(variable);\
 init_lua_key(vbox);\
 init_lua_key(vcenter);\
 init_lua_key(version);\
 init_lua_key(vert_italic);\
 init_lua_key(vert_variants);\
+init_lua_key(vmode_par);\
 init_lua_key(visiblefilename);\
 init_lua_key(vlist);\
-init_lua_key(vmode_par);\
-init_lua_key(vmove);\
-init_lua_key(vrule);\
-init_lua_key(vskip);\
 init_lua_key(vtop);\
-init_lua_key(whatsit);\
 init_lua_key(widowpenalty);\
 init_lua_key(width);\
-init_lua_key(word);\
-init_lua_key(wordpenalty);\
-init_lua_key(write);\
-init_lua_key(writingmode);\
 init_lua_key(x_height);\
 init_lua_key(xadvance);\
-init_lua_key(xformattributes);\
 init_lua_key(xformresources);\
-init_lua_key(xleaders);\
-init_lua_key(xmath_given);\
+init_lua_key(xformattributes);\
 init_lua_key(xoffset);\
-init_lua_key(xray);\
 init_lua_key(xres);\
 init_lua_key(xsize);\
-init_lua_key(xspaceskip);\
-init_lua_key(xyz);\
 init_lua_key(xyz_zoom);\
 init_lua_key(yoffset);\
 init_lua_key(yres);\
 init_lua_key(ysize);\
+init_lua_key(writingmode);\
+init_lua_key(__index);\
 init_lua_key_alias(empty_string,"");\
 init_lua_key_alias(lua_bytecodes_indirect,"lua.bytecodes.indirect");\
 init_lua_key_alias(lua_functions,"lua.functions");\
 init_lua_key_alias(luatex_node, "luatex.node");\
 init_lua_key_alias(luatex_token, "luatex.token");\
-init_lua_key_alias(luatex_pdfe, "luatex.pdfe");\
-init_lua_key_alias(luatex_pdfe_dictionary, "luatex.pdfe.dictionary");\
-init_lua_key_alias(luatex_pdfe_array, "luatex.pdfe.array");\
-init_lua_key_alias(luatex_pdfe_stream, "luatex.pdfe.stream");\
-init_lua_key_alias(luatex_pdfe_reference, "luatex.pdfe.reference");\
 init_lua_key_alias(mLTL,"-LTL");\
 init_lua_key_alias(mRTT,"-RTT");\
 init_lua_key_alias(mTLT,"-TLT");\
@@ -1952,12 +1268,14 @@ extern FILE *_cairo_win_tmpfile( void );
 /* These keys have to available to different files */
 /*                                                 */
 
-use_lua_key(__index);
-use_lua_key(above);
-use_lua_key(abovedisplayshortskip);
-use_lua_key(abovedisplayskip);
+use_lua_key(cmdname);use_lua_key(expandable);use_lua_key(protected);
+
+use_lua_key(LTL);
+use_lua_key(MathConstants);
+use_lua_key(RTT);
+use_lua_key(TLT);
+use_lua_key(TRT);
 use_lua_key(accent);
-use_lua_key(accentkern);
 use_lua_key(action);
 use_lua_key(action_id);
 use_lua_key(action_type);
@@ -1969,107 +1287,53 @@ use_lua_key(adjust_head);
 use_lua_key(adjusted_hbox);
 use_lua_key(adjustspacing);
 use_lua_key(advance);
-use_lua_key(after_assignment);
 use_lua_key(after_display);
-use_lua_key(after_group);
 use_lua_key(after_output);
-use_lua_key(afterdisplaypenalty);
 use_lua_key(align);
 use_lua_key(align_head);
-use_lua_key(align_record);
 use_lua_key(align_set);
-use_lua_key(align_stack);
 use_lua_key(alignment);
-use_lua_key(always);
 use_lua_key(annot);
 use_lua_key(area);
 use_lua_key(art);
-use_lua_key(assign_attr);
-use_lua_key(assign_box_dir);
-use_lua_key(assign_box_direction);
-use_lua_key(assign_dimen);
-use_lua_key(assign_dir);
-use_lua_key(assign_direction);
-use_lua_key(assign_font_dimen);
-use_lua_key(assign_font_int);
-use_lua_key(assign_glue);
-use_lua_key(assign_hang_indent);
-use_lua_key(assign_int);
-use_lua_key(assign_local_box);
-use_lua_key(assign_mu_glue);
-use_lua_key(assign_toks);
 use_lua_key(attr);
-use_lua_key(attribute);
-use_lua_key(attribute_list);
 use_lua_key(attributes);
-use_lua_key(automatic);
-use_lua_key(baselineskip);
 use_lua_key(bbox);
 use_lua_key(before_display);
-use_lua_key(beforedisplaypenalty);
-use_lua_key(begin_group);
-use_lua_key(beginmath);
-use_lua_key(belowdisplayshortskip);
-use_lua_key(belowdisplayskip);
 use_lua_key(best_ins_ptr);
 use_lua_key(best_page_break);
 use_lua_key(best_size);
-use_lua_key(bin);
 use_lua_key(bleed);
 use_lua_key(bot);
 use_lua_key(bot_accent);
-use_lua_key(bothflexible);
 use_lua_key(bottom_left);
 use_lua_key(bottom_right);
 use_lua_key(boundary);
 use_lua_key(box);
 use_lua_key(box_left);
 use_lua_key(box_left_width);
-use_lua_key(box_ref);
 use_lua_key(box_right);
 use_lua_key(box_right_width);
-use_lua_key(box_there);
-use_lua_key(break_penalty);
 use_lua_key(broken_ins);
 use_lua_key(broken_ptr);
 use_lua_key(brokenpenalty);
 use_lua_key(cache);
 use_lua_key(cal_expand_ratio);
-use_lua_key(call);
-use_lua_key(cancel);
-use_lua_key(car_ret);
-use_lua_key(case_shift);
-use_lua_key(Catalog);
 use_lua_key(catalog);
-use_lua_key(cell);
 use_lua_key(char);
-use_lua_key(char_ghost);
-use_lua_key(char_given);
-use_lua_key(char_num);
-use_lua_key(character);
 use_lua_key(characters);
 use_lua_key(checksum);
-use_lua_key(choice);
 use_lua_key(cidinfo);
 use_lua_key(class);
-use_lua_key(cleaders);
-use_lua_key(close);
 use_lua_key(clubpenalty);
-use_lua_key(cmd);
-use_lua_key(cmdname);
-use_lua_key(color_stack);
 use_lua_key(colordepth);
 use_lua_key(colorspace);
-use_lua_key(combinetoks);
 use_lua_key(command);
 use_lua_key(commands);
 use_lua_key(comment);
 use_lua_key(components);
 use_lua_key(compresslevel);
-use_lua_key(conditionalmathskip);
 use_lua_key(contrib_head);
-use_lua_key(convert);
-use_lua_key(copy_font);
 use_lua_key(core);
 use_lua_key(cost);
 use_lua_key(count);
@@ -2078,21 +1342,11 @@ use_lua_key(crampedscript);
 use_lua_key(crampedscriptscript);
 use_lua_key(crampedtext);
 use_lua_key(crop);
-use_lua_key(cs_name);
 use_lua_key(csname);
-use_lua_key(current);
 use_lua_key(data);
-use_lua_key(def);
-use_lua_key(def_char_code);
-use_lua_key(def_del_code);
-use_lua_key(def_family);
-use_lua_key(def_font);
-use_lua_key(def_lua_call);
 use_lua_key(degree);
 use_lua_key(delim);
-use_lua_key(delim_num);
 use_lua_key(delimptr);
-use_lua_key(delta);
 use_lua_key(demerits);
 use_lua_key(denom);
 use_lua_key(depth);
@@ -2105,92 +1359,46 @@ use_lua_key(direct);
 use_lua_key(direction);
 use_lua_key(dirs);
 use_lua_key(disc);
-use_lua_key(discretionary);
 use_lua_key(display);
-use_lua_key(divide);
-use_lua_key(dont_expand);
 use_lua_key(doublehyphendemerits);
 use_lua_key(down);
 use_lua_key(embedding);
 use_lua_key(emergencystretch);
-use_lua_key(empty);
 use_lua_key(empty_string);
 use_lua_key(encodingbytes);
 use_lua_key(encodingname);
 use_lua_key(end);
-use_lua_key(end_cs_name);
-use_lua_key(end_group);
-use_lua_key(end_template);
-use_lua_key(endmath);
-use_lua_key(endv);
-use_lua_key(eq_no);
+use_lua_key(etex);
 use_lua_key(equation);\
 use_lua_key(equation_number);\
-use_lua_key(equationnumber);
-use_lua_key(equationnumberpenalty);
-use_lua_key(etex);
-use_lua_key(ex_space);
 use_lua_key(exactly);
-use_lua_key(expand_after);
-use_lua_key(expand_font);
-use_lua_key(expandable);
 use_lua_key(expansion_factor);
-use_lua_key(explicit);
-use_lua_key(expr_stack);
 use_lua_key(ext);
-use_lua_key(extdef_del_code);
-use_lua_key(extdef_math_code);
 use_lua_key(extend);
 use_lua_key(extender);
 use_lua_key(extensible);
-use_lua_key(extension);
 use_lua_key(extra_space);
 use_lua_key(fam);
 use_lua_key(fast);
-use_lua_key(feedback);
 use_lua_key(fence);
-use_lua_key(fi);
-use_lua_key(fi_or_else);
-use_lua_key(fil);
 use_lua_key(file);
 use_lua_key(filename);
 use_lua_key(filepath);
 use_lua_key(fill);
-use_lua_key(filll);
-use_lua_key(fillll);
 use_lua_key(fin_row);
 use_lua_key(finalhyphendemerits);
-use_lua_key(finalpenalty);
-use_lua_key(first);
-use_lua_key(fit);
-use_lua_key(fitb);
-use_lua_key(fitbh);
-use_lua_key(fitbv);
-use_lua_key(fith);
-use_lua_key(fitr);
-use_lua_key(fitv);
-use_lua_key(fixedboth);
-use_lua_key(fixedbottom);
-use_lua_key(fixedtop);
 use_lua_key(font);
-use_lua_key(fontkern);
 use_lua_key(fonts);
 use_lua_key(format);
 use_lua_key(fraction);
 use_lua_key(fullname);
-use_lua_key(ghost);
-use_lua_key(gleaders);
 use_lua_key(global);
 use_lua_key(glue);
 use_lua_key(glue_order);
-use_lua_key(glue_ref);
 use_lua_key(glue_set);
 use_lua_key(glue_sign);
-use_lua_key(glue_spec);
 use_lua_key(glyph);
-use_lua_key(goto);
 use_lua_key(h);
-use_lua_key(halign);
 use_lua_key(hangafter);
 use_lua_key(hangindent);
 use_lua_key(hbox);
@@ -2198,37 +1406,20 @@ use_lua_key(head);
 use_lua_key(height);
 use_lua_key(hlist);
 use_lua_key(hmode_par);
-use_lua_key(hmove);
 use_lua_key(hold_head);
 use_lua_key(horiz_variants);
-use_lua_key(hrule);
 use_lua_key(hsize);
-use_lua_key(hskip);
-use_lua_key(hyph_data);
-use_lua_key(hyphenated);
 use_lua_key(hyphenchar);
 use_lua_key(id);
 use_lua_key(identity);
-use_lua_key(if_stack);
-use_lua_key(if_test);
-use_lua_key(ignore_spaces);
 use_lua_key(image);
 use_lua_key(imagetype);
 use_lua_key(immediate);
-use_lua_key(in_stream);
-use_lua_key(indent);
 use_lua_key(index);
 use_lua_key(info);
-use_lua_key(Info);
-use_lua_key(inner);
-use_lua_key(input);
-use_lua_key(ins);
 use_lua_key(insert);
-use_lua_key(inserts_only);
 use_lua_key(interlinepenalty);
-use_lua_key(ital_corr);
 use_lua_key(italic);
-use_lua_key(italiccorrection);
 use_lua_key(keepopen);
 use_lua_key(kern);
 use_lua_key(kerns);
@@ -2236,191 +1427,95 @@ use_lua_key(lang);
 use_lua_key(large_char);
 use_lua_key(large_fam);
 use_lua_key(last_ins_ptr);
-use_lua_key(last_item);
 use_lua_key(lastlinefit);
-use_lua_key(late_lua);
 use_lua_key(leader);
-use_lua_key(leader_ship);
-use_lua_key(leaders);
 use_lua_key(least_page_cost);
 use_lua_key(left);
 use_lua_key(left_boundary);
-use_lua_key(left_brace);
 use_lua_key(left_protruding);
-use_lua_key(left_right);
 use_lua_key(leftskip);
-use_lua_key(let);
-use_lua_key(letter);
-use_lua_key(letterspace_font);
 use_lua_key(level);
-use_lua_key(ligature);
 use_lua_key(ligatures);
-use_lua_key(limit_switch);
-use_lua_key(line);
-use_lua_key(linebreakpenalty);
 use_lua_key(linepenalty);
-use_lua_key(lineskip);
 use_lua_key(link_attr);
 use_lua_key(list);
 use_lua_key(local_box);
-use_lua_key(local_par);
 use_lua_key(log);
-use_lua_key(long_call);
-use_lua_key(long_outer_call);
 use_lua_key(looseness);
-use_lua_key(LTL);
 use_lua_key(lua);
-use_lua_key(lua_bytecode_call);
 use_lua_key(lua_bytecodes_indirect);
-use_lua_key(lua_call);
-use_lua_key(lua_expandable_call);
-use_lua_key(lua_local_call);
-use_lua_key(lua_function_call);
 use_lua_key(lua_functions);
 use_lua_key(luatex);
 use_lua_key(luatex_node);
 use_lua_key(luatex_token);
-use_lua_key(luatex_pdfe);
-use_lua_key(luatex_pdfe_dictionary);
-use_lua_key(luatex_pdfe_array);
-use_lua_key(luatex_pdfe_stream);
-use_lua_key(luatex_pdfe_reference);
-use_lua_key(mac_param);
-use_lua_key(make_box);
-use_lua_key(margin_kern);
+use_lua_key(mLTL);
+use_lua_key(mRTT);
+use_lua_key(mTLT);
+use_lua_key(mTRT);
 use_lua_key(marginkern);
 use_lua_key(mark);
 use_lua_key(math);
-use_lua_key(math_accent);
-use_lua_key(math_char);
-use_lua_key(math_char_num);
 use_lua_key(math_choice);
-use_lua_key(math_comp);
-use_lua_key(math_given);
 use_lua_key(math_left);
 use_lua_key(math_shift);
-use_lua_key(math_shift_cs);
-use_lua_key(math_style);
-use_lua_key(math_sub_box);
-use_lua_key(math_sub_mlist);
-use_lua_key(math_text_char);
-use_lua_key(MathConstants);
 use_lua_key(mathdir);
 use_lua_key(mathkern);
-use_lua_key(mathskip);
 use_lua_key(mathstyle);
 use_lua_key(media);
-use_lua_key(medmuskip);
-use_lua_key(message);
 use_lua_key(mid);
 use_lua_key(middle);
-use_lua_key(mkern);
-use_lua_key(mLTL);
 use_lua_key(mode);
 use_lua_key(modeline);
-use_lua_key(movement_stack);
-use_lua_key(mRTT);
-use_lua_key(mskip);
-use_lua_key(mTLT);
-use_lua_key(mTRT);
-use_lua_key(muglue);
-use_lua_key(multiply);
 use_lua_key(name);
 use_lua_key(named_id);
 use_lua_key(names);
-use_lua_key(nested_list);
-use_lua_key(new);
 use_lua_key(new_graf);
 use_lua_key(new_window);
 use_lua_key(next);
 use_lua_key(no);
-use_lua_key(nolength);
 use_lua_key(no_align);
-use_lua_key(no_expand);
-use_lua_key(no_super_sub_script);
 use_lua_key(noad);
-use_lua_key(noadpenalty);
 use_lua_key(node);
 use_lua_key(node_properties);
 use_lua_key(node_properties_indirect);
-use_lua_key(nohrule);
 use_lua_key(nomath);
-use_lua_key(non_script);
 use_lua_key(none);
-use_lua_key(nonew);
 use_lua_key(nop);
-use_lua_key(normal);
-use_lua_key(novrule);
 use_lua_key(nucleus);
 use_lua_key(num);
 use_lua_key(number);
 use_lua_key(objcompression);
 use_lua_key(objnum);
 use_lua_key(oldmath);
-use_lua_key(omit);
-use_lua_key(opdisplaylimits);
-use_lua_key(open);
-use_lua_key(oplimits);
-use_lua_key(opnolimits);
-use_lua_key(option);
 use_lua_key(options);
-use_lua_key(ord);
-use_lua_key(ordering);
 use_lua_key(orientation);
 use_lua_key(origin);
-use_lua_key(other_char);
-use_lua_key(outer_call);
-use_lua_key(outline);
+use_lua_key(ordering);
 use_lua_key(output);
-use_lua_key(over);
 use_lua_key(overlay_accent);
-use_lua_key(ownerpassword);
+use_lua_key(pLTL);
+use_lua_key(pRTT);
+use_lua_key(pTLT);
+use_lua_key(pTRT);
 use_lua_key(page);
+use_lua_key(pages);
 use_lua_key(page_discards_head);
 use_lua_key(page_head);
 use_lua_key(page_ins_head);
-use_lua_key(page_insert);
-use_lua_key(pageattributes);
 use_lua_key(pagebox);
+use_lua_key(pageattributes);
 use_lua_key(pageresources);
-use_lua_key(pages);
-use_lua_key(Pages);
 use_lua_key(pagesattributes);
-use_lua_key(pagestate);
-use_lua_key(par_end);
 use_lua_key(parameters);
 use_lua_key(pardir);
-use_lua_key(parfillskip);
 use_lua_key(parshape);
-use_lua_key(parskip);
-use_lua_key(passive);
 use_lua_key(pdf);
-use_lua_key(pdfe);
-use_lua_key(pdf_action);
-use_lua_key(pdf_annot);
-use_lua_key(pdf_colorstack);
 use_lua_key(pdf_data);
-use_lua_key(pdf_dest);
 use_lua_key(pdf_destination);
-use_lua_key(pdf_end_link);
-use_lua_key(pdf_end_thread);
-use_lua_key(pdf_link_data);
 use_lua_key(pdf_literal);
-use_lua_key(pdf_refobj);
-use_lua_key(pdf_restore);
-use_lua_key(pdf_save);
-use_lua_key(pdf_setmatrix);
-use_lua_key(pdf_setobj);
-use_lua_key(pdf_start);
-use_lua_key(pdf_start_link);
-use_lua_key(pdf_start_thread);
-use_lua_key(pdf_thread);
-use_lua_key(pdf_thread_data);
-use_lua_key(pdf_window);
 use_lua_key(pen_broken);
 use_lua_key(pen_inter);
 use_lua_key(penalty);
-use_lua_key(pLTL);
 use_lua_key(pop);
 use_lua_key(post);
 use_lua_key(post_linebreak);
@@ -2430,71 +1525,35 @@ use_lua_key(pre_adjust_head);
 use_lua_key(pre_align);
 use_lua_key(pre_box);
 use_lua_key(preamble);
-use_lua_key(prefix);
 use_lua_key(pretolerance);
 use_lua_key(prev);
 use_lua_key(prevdepth);
 use_lua_key(prevgraf);
-use_lua_key(protected);
 use_lua_key(protrudechars);
-use_lua_key(protrusion);
-use_lua_key(pRTT);
-use_lua_key(pseudo_file);
-use_lua_key(pseudo_line);
 use_lua_key(psname);
-use_lua_key(pTLT);
 use_lua_key(ptr);
-use_lua_key(pTRT);
-use_lua_key(punct);
 use_lua_key(push);
 use_lua_key(quad);
 use_lua_key(radical);
 use_lua_key(raw);
-use_lua_key(read_to_cs);
 use_lua_key(ref_count);
-use_lua_key(recompress);
 use_lua_key(reg);
-use_lua_key(register);
 use_lua_key(registry);
-use_lua_key(regular);
-use_lua_key(rel);
-use_lua_key(relax);
-use_lua_key(remove_item);
 use_lua_key(renew);
 use_lua_key(rep);
 use_lua_key(replace);
 use_lua_key(resources);
 use_lua_key(right);
 use_lua_key(right_boundary);
-use_lua_key(right_brace);
 use_lua_key(right_protruding);
 use_lua_key(rightskip);
 use_lua_key(rotation);
-use_lua_key(RTT);
 use_lua_key(rule);
-use_lua_key(save_pos);
 use_lua_key(scale);
 use_lua_key(script);
 use_lua_key(scriptscript);
-use_lua_key(second);
 use_lua_key(semi_simple);
-use_lua_key(set);
-use_lua_key(set_aux);
-use_lua_key(set_box);
-use_lua_key(set_box_dimen);
-use_lua_key(set_etex_shape);
-use_lua_key(set_font);
-use_lua_key(set_font_id);
-use_lua_key(set_interaction);
-use_lua_key(set_math_param);
-use_lua_key(set_page_dimen);
-use_lua_key(set_page_int);
-use_lua_key(set_prev_graf);
-use_lua_key(set_tex_shape);
-use_lua_key(shape);
-use_lua_key(shape_ref);
 use_lua_key(shift);
-use_lua_key(shorthand_def);
 use_lua_key(shrink);
 use_lua_key(shrink_order);
 use_lua_key(simple);
@@ -2508,22 +1567,13 @@ use_lua_key(space);
 use_lua_key(space_shrink);
 use_lua_key(space_stretch);
 use_lua_key(spacefactor);
-use_lua_key(spacer);
-use_lua_key(spaceskip);
-use_lua_key(span);
-use_lua_key(spec);
 use_lua_key(special);
 use_lua_key(split_discards_head);
-use_lua_key(split_insert);
 use_lua_key(split_keep);
 use_lua_key(split_off);
-use_lua_key(splittopskip);
-use_lua_key(squeeze);
 use_lua_key(stack);
 use_lua_key(start);
-use_lua_key(start_par);
 use_lua_key(step);
-use_lua_key(stop);
 use_lua_key(stream);
 use_lua_key(streamfile);
 use_lua_key(streamprovider);
@@ -2532,111 +1582,60 @@ use_lua_key(stretch_order);
 use_lua_key(string);
 use_lua_key(style);
 use_lua_key(sub);
-use_lua_key(sub_box);
-use_lua_key(sub_mark);
-use_lua_key(sub_mlist);
 use_lua_key(subst_ex_font);
 use_lua_key(subtype);
 use_lua_key(sup);
-use_lua_key(sup_mark);
-use_lua_key(super_sub_script);
 use_lua_key(supplement);
 use_lua_key(surround);
-use_lua_key(tab_mark);
-use_lua_key(tabskip);
 use_lua_key(tail);
-use_lua_key(temp);
 use_lua_key(temp_head);
 use_lua_key(term);
 use_lua_key(term_and_log);
 use_lua_key(tex);
 use_lua_key(text);
-use_lua_key(the);
-use_lua_key(thickmuskip);
-use_lua_key(thinmuskip);
-use_lua_key(thread);
 use_lua_key(thread_attr);
 use_lua_key(thread_id);
-use_lua_key(TLT);
+use_lua_key(tolerance);
 use_lua_key(tok);
 use_lua_key(token);
-use_lua_key(toks_register);
-use_lua_key(tolerance);
 use_lua_key(top);
 use_lua_key(top_accent);
-use_lua_key(top_bot_mark);
 use_lua_key(top_left);
 use_lua_key(top_right);
-use_lua_key(topskip);
 use_lua_key(tounicode);
 use_lua_key(tracingparagraphs);
 use_lua_key(trailer);
-use_lua_key(Trailer);
 use_lua_key(trailerid);
 use_lua_key(transform);
 use_lua_key(trim);
-use_lua_key(TRT);
 use_lua_key(type);
 use_lua_key(uchyph);
-use_lua_key(udelimiterover);
-use_lua_key(udelimiterunder);
-use_lua_key(un_hbox);
-use_lua_key(un_vbox);
-use_lua_key(undefined_cs);
-use_lua_key(under);
-use_lua_key(unhyphenated);
 use_lua_key(units_per_em);
-use_lua_key(unknown);
-use_lua_key(unset);
-use_lua_key(uoverdelimiter);
-use_lua_key(uradical);
-use_lua_key(uroot);
 use_lua_key(used);
-use_lua_key(user);
-use_lua_key(userpassword);
-use_lua_key(user_defined);
 use_lua_key(user_id);
-use_lua_key(userkern);
-use_lua_key(userpenalty);
-use_lua_key(userskip);
-use_lua_key(uunderdelimiter);
 use_lua_key(v);
-use_lua_key(vadjust);
-use_lua_key(valign);
 use_lua_key(value);
-use_lua_key(variable);
 use_lua_key(vbox);
 use_lua_key(vcenter);
 use_lua_key(version);
 use_lua_key(vert_italic);
 use_lua_key(vert_variants);
+use_lua_key(vmode_par);
 use_lua_key(visiblefilename);
 use_lua_key(vlist);
-use_lua_key(vmode_par);
-use_lua_key(vmove);
-use_lua_key(vrule);
-use_lua_key(vskip);
 use_lua_key(vtop);
-use_lua_key(whatsit);
 use_lua_key(widowpenalty);
 use_lua_key(width);
-use_lua_key(word);
-use_lua_key(wordpenalty);
-use_lua_key(write);
-use_lua_key(writingmode);
 use_lua_key(x_height);
 use_lua_key(xadvance);
-use_lua_key(xformattributes);
 use_lua_key(xformresources);
-use_lua_key(xleaders);
-use_lua_key(xmath_given);
+use_lua_key(xformattributes);
 use_lua_key(xoffset);
-use_lua_key(xray);
 use_lua_key(xres);
 use_lua_key(xsize);
-use_lua_key(xspaceskip);
-use_lua_key(xyz);
 use_lua_key(xyz_zoom);
 use_lua_key(yoffset);
 use_lua_key(yres);
 use_lua_key(ysize);
+use_lua_key(writingmode);
+use_lua_key(__index);
--- texlive-bin.orig/texk/web2c/luatexdir/lua/luatex-core.c
+++ texlive-bin/texk/web2c/luatexdir/lua/luatex-core.c
@@ -17,7 +17,7 @@ int load_luatex_core_lua (lua_State * L)
     0x6f, 0x64, 0x75, 0x6c, 0x65, 0x73, 0x20, 0x5b, 0x27, 0x6c, 0x75, 0x61, 0x74, 0x65, 0x78, 0x2d,
     0x63, 0x6f, 0x72, 0x65, 0x27, 0x5d, 0x20, 0x3d, 0x20, 0x7b, 0x0a, 0x2d, 0x2d, 0x20, 0x20, 0x20,
     0x20, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x31, 0x2e,
-    0x30, 0x38, 0x30, 0x2c, 0x0a, 0x2d, 0x2d, 0x20, 0x20, 0x20, 0x20, 0x20, 0x63, 0x6f, 0x6d, 0x6d,
+    0x30, 0x30, 0x35, 0x2c, 0x0a, 0x2d, 0x2d, 0x20, 0x20, 0x20, 0x20, 0x20, 0x63, 0x6f, 0x6d, 0x6d,
     0x65, 0x6e, 0x74, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x27, 0x63, 0x6f, 0x6d, 0x70, 0x61, 0x6e, 0x69,
     0x6f, 0x6e, 0x20, 0x74, 0x6f, 0x20, 0x6c, 0x75, 0x61, 0x74, 0x65, 0x78, 0x27, 0x2c, 0x0a, 0x2d,
     0x2d, 0x20, 0x20, 0x20, 0x20, 0x20, 0x61, 0x75, 0x74, 0x68, 0x6f, 0x72, 0x20, 0x20, 0x20, 0x20,
@@ -27,609 +27,536 @@ int load_luatex_core_lua (lua_State * L)
     0x3d, 0x20, 0x27, 0x4c, 0x75, 0x61, 0x54, 0x65, 0x58, 0x20, 0x44, 0x65, 0x76, 0x65, 0x6c, 0x6f,
     0x70, 0x6d, 0x65, 0x6e, 0x74, 0x20, 0x54, 0x65, 0x61, 0x6d, 0x27, 0x2c, 0x0a, 0x2d, 0x2d, 0x20,
     0x7d, 0x0a, 0x0a, 0x4c, 0x55, 0x41, 0x54, 0x45, 0x58, 0x43, 0x4f, 0x52, 0x45, 0x56, 0x45, 0x52,
-    0x53, 0x49, 0x4f, 0x4e, 0x20, 0x3d, 0x20, 0x31, 0x2e, 0x30, 0x38, 0x30, 0x20, 0x2d, 0x2d, 0x20,
-    0x77, 0x65, 0x20, 0x72, 0x65, 0x66, 0x6c, 0x65, 0x63, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x6c,
-    0x75, 0x61, 0x74, 0x65, 0x78, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x20, 0x77, 0x68,
-    0x65, 0x72, 0x65, 0x20, 0x63, 0x68, 0x61, 0x6e, 0x67, 0x65, 0x73, 0x20, 0x68, 0x61, 0x70, 0x70,
-    0x65, 0x6e, 0x65, 0x64, 0x0a, 0x0a, 0x2d, 0x2d, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x66, 0x69,
-    0x6c, 0x65, 0x20, 0x6f, 0x76, 0x65, 0x72, 0x6c, 0x6f, 0x61, 0x64, 0x73, 0x20, 0x73, 0x6f, 0x6d,
-    0x65, 0x20, 0x4c, 0x75, 0x61, 0x20, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e,
-    0x20, 0x54, 0x68, 0x65, 0x20, 0x72, 0x65, 0x61, 0x64, 0x6c, 0x69, 0x6e, 0x65, 0x20, 0x76, 0x61,
-    0x72, 0x69, 0x61, 0x6e, 0x74, 0x73, 0x20, 0x70, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x20, 0x74,
-    0x68, 0x65, 0x20, 0x73, 0x61, 0x6d, 0x65, 0x0a, 0x2d, 0x2d, 0x20, 0x66, 0x75, 0x6e, 0x63, 0x74,
-    0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x69, 0x74, 0x79, 0x20, 0x61, 0x73, 0x20, 0x4c, 0x75, 0x61, 0x54,
-    0x65, 0x58, 0x20, 0x3c, 0x3d, 0x20, 0x31, 0x2e, 0x30, 0x34, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x64,
-    0x6f, 0x69, 0x6e, 0x67, 0x20, 0x69, 0x74, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x77, 0x61, 0x79,
-    0x20, 0x70, 0x65, 0x72, 0x6d, 0x69, 0x74, 0x73, 0x20, 0x75, 0x73, 0x20, 0x74, 0x6f, 0x20, 0x6b,
-    0x65, 0x65, 0x70, 0x20, 0x74, 0x68, 0x65, 0x0a, 0x2d, 0x2d, 0x20, 0x6f, 0x72, 0x69, 0x67, 0x69,
-    0x6e, 0x61, 0x6c, 0x20, 0x69, 0x6f, 0x20, 0x6c, 0x69, 0x62, 0x72, 0x61, 0x72, 0x69, 0x65, 0x73,
-    0x20, 0x63, 0x6c, 0x65, 0x61, 0x6e, 0x2e, 0x20, 0x50, 0x65, 0x72, 0x66, 0x6f, 0x72, 0x6d, 0x61,
-    0x6e, 0x63, 0x65, 0x20, 0x69, 0x73, 0x20, 0x70, 0x72, 0x6f, 0x62, 0x61, 0x62, 0x6c, 0x79, 0x20,
-    0x65, 0x76, 0x65, 0x6e, 0x20, 0x61, 0x20, 0x62, 0x69, 0x74, 0x20, 0x62, 0x65, 0x74, 0x74, 0x65,
-    0x72, 0x20, 0x6e, 0x6f, 0x77, 0x2e, 0x0a, 0x0a, 0x2d, 0x2d, 0x20, 0x57, 0x65, 0x20, 0x74, 0x65,
-    0x73, 0x74, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73,
-    0x20, 0x61, 0x6c, 0x72, 0x65, 0x61, 0x64, 0x79, 0x20, 0x62, 0x65, 0x69, 0x6e, 0x67, 0x20, 0x64,
-    0x65, 0x66, 0x69, 0x6e, 0x65, 0x64, 0x20, 0x73, 0x6f, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x77,
-    0x65, 0x20, 0x64, 0x6f, 0x6e, 0x27, 0x74, 0x20, 0x6f, 0x76, 0x65, 0x72, 0x6c, 0x6f, 0x61, 0x64,
-    0x20, 0x6f, 0x6e, 0x65, 0x73, 0x20, 0x74, 0x68, 0x61, 0x74, 0x0a, 0x2d, 0x2d, 0x20, 0x61, 0x72,
-    0x65, 0x20, 0x70, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x64, 0x20, 0x69, 0x6e, 0x20, 0x74, 0x68,
-    0x65, 0x20, 0x73, 0x74, 0x61, 0x72, 0x74, 0x75, 0x70, 0x20, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74,
-    0x2e, 0x0a, 0x0a, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x74, 0x79, 0x70, 0x65, 0x2c, 0x20, 0x6e,
-    0x65, 0x78, 0x74, 0x2c, 0x20, 0x67, 0x65, 0x74, 0x6d, 0x65, 0x74, 0x61, 0x74, 0x61, 0x62, 0x6c,
-    0x65, 0x2c, 0x20, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x20, 0x3d, 0x20, 0x74, 0x79, 0x70,
-    0x65, 0x2c, 0x20, 0x6e, 0x65, 0x78, 0x74, 0x2c, 0x20, 0x67, 0x65, 0x74, 0x6d, 0x65, 0x74, 0x61,
-    0x74, 0x61, 0x62, 0x6c, 0x65, 0x2c, 0x20, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x0a, 0x6c,
-    0x6f, 0x63, 0x61, 0x6c, 0x20, 0x66, 0x69, 0x6e, 0x64, 0x2c, 0x20, 0x67, 0x73, 0x75, 0x62, 0x2c,
-    0x20, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x20, 0x3d, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67,
-    0x2e, 0x66, 0x69, 0x6e, 0x64, 0x2c, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x2e, 0x67, 0x73,
-    0x75, 0x62, 0x2c, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x2e, 0x66, 0x6f, 0x72, 0x6d, 0x61,
-    0x74, 0x0a, 0x0a, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x69, 0x6f, 0x5f, 0x6f, 0x70, 0x65, 0x6e,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x69,
-    0x6f, 0x2e, 0x6f, 0x70, 0x65, 0x6e, 0x0a, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x69, 0x6f, 0x5f,
-    0x70, 0x6f, 0x70, 0x65, 0x6e, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x3d, 0x20, 0x69, 0x6f, 0x2e, 0x70, 0x6f, 0x70, 0x65, 0x6e, 0x0a, 0x6c, 0x6f, 0x63, 0x61,
-    0x6c, 0x20, 0x69, 0x6f, 0x5f, 0x6c, 0x69, 0x6e, 0x65, 0x73, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x69, 0x6f, 0x2e, 0x6c, 0x69, 0x6e, 0x65, 0x73,
-    0x0a, 0x0a, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x66, 0x69, 0x6f, 0x5f, 0x72, 0x65, 0x61, 0x64,
-    0x6c, 0x69, 0x6e, 0x65, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x66, 0x69,
-    0x6f, 0x2e, 0x72, 0x65, 0x61, 0x64, 0x6c, 0x69, 0x6e, 0x65, 0x0a, 0x6c, 0x6f, 0x63, 0x61, 0x6c,
-    0x20, 0x66, 0x69, 0x6f, 0x5f, 0x63, 0x68, 0x65, 0x63, 0x6b, 0x70, 0x65, 0x72, 0x6d, 0x69, 0x73,
-    0x73, 0x69, 0x6f, 0x6e, 0x20, 0x3d, 0x20, 0x66, 0x69, 0x6f, 0x2e, 0x63, 0x68, 0x65, 0x63, 0x6b,
-    0x70, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x0a, 0x6c, 0x6f, 0x63, 0x61, 0x6c,
-    0x20, 0x66, 0x69, 0x6f, 0x5f, 0x72, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x66, 0x69, 0x6c, 0x65, 0x6e,
-    0x61, 0x6d, 0x65, 0x20, 0x20, 0x3d, 0x20, 0x66, 0x69, 0x6f, 0x2e, 0x72, 0x65, 0x63, 0x6f, 0x72,
-    0x64, 0x66, 0x69, 0x6c, 0x65, 0x6e, 0x61, 0x6d, 0x65, 0x0a, 0x0a, 0x6c, 0x6f, 0x63, 0x61, 0x6c,
-    0x20, 0x6d, 0x74, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x67, 0x65, 0x74, 0x6d, 0x65, 0x74, 0x61, 0x74, 0x61,
-    0x62, 0x6c, 0x65, 0x28, 0x69, 0x6f, 0x2e, 0x73, 0x74, 0x64, 0x65, 0x72, 0x72, 0x29, 0x0a, 0x6c,
-    0x6f, 0x63, 0x61, 0x6c, 0x20, 0x6d, 0x74, 0x5f, 0x6c, 0x69, 0x6e, 0x65, 0x73, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x6d, 0x74, 0x2e, 0x6c, 0x69,
-    0x6e, 0x65, 0x73, 0x0a, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x73, 0x61, 0x66, 0x65, 0x72, 0x6f,
-    0x70, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20,
-    0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x2e, 0x73, 0x61, 0x66, 0x65, 0x72, 0x5f, 0x6f, 0x70, 0x74,
-    0x69, 0x6f, 0x6e, 0x0a, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x73, 0x68, 0x65, 0x6c, 0x6c, 0x65,
-    0x73, 0x63, 0x61, 0x70, 0x65, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20,
-    0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x2e, 0x73, 0x68, 0x65, 0x6c, 0x6c, 0x5f, 0x65, 0x73, 0x63,
-    0x61, 0x70, 0x65, 0x20, 0x2d, 0x2d, 0x20, 0x30, 0x20, 0x28, 0x64, 0x69, 0x73, 0x61, 0x62, 0x6c,
-    0x65, 0x64, 0x29, 0x20, 0x31, 0x20, 0x28, 0x61, 0x6e, 0x79, 0x74, 0x68, 0x69, 0x6e, 0x67, 0x29,
-    0x20, 0x32, 0x20, 0x28, 0x72, 0x65, 0x73, 0x74, 0x72, 0x69, 0x63, 0x74, 0x65, 0x64, 0x29, 0x0a,
-    0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x6b, 0x70, 0x73, 0x65, 0x75, 0x73, 0x65, 0x64, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x73, 0x74, 0x61, 0x74,
-    0x75, 0x73, 0x2e, 0x6b, 0x70, 0x73, 0x65, 0x5f, 0x75, 0x73, 0x65, 0x64, 0x20, 0x20, 0x20, 0x20,
-    0x2d, 0x2d, 0x20, 0x30, 0x20, 0x31, 0x0a, 0x0a, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x77, 0x72,
-    0x69, 0x74, 0x65, 0x5f, 0x6e, 0x6c, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x3d, 0x20, 0x74, 0x65, 0x78, 0x69, 0x6f, 0x2e, 0x77, 0x72, 0x69, 0x74, 0x65, 0x5f,
-    0x6e, 0x6c, 0x0a, 0x0a, 0x69, 0x6f, 0x2e, 0x73, 0x61, 0x76, 0x65, 0x64, 0x5f, 0x6c, 0x69, 0x6e,
-    0x65, 0x73, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20,
-    0x69, 0x6f, 0x5f, 0x6c, 0x69, 0x6e, 0x65, 0x73, 0x20, 0x2d, 0x2d, 0x20, 0x61, 0x6c, 0x77, 0x61,
-    0x79, 0x73, 0x20, 0x72, 0x65, 0x61, 0x64, 0x6f, 0x6e, 0x6c, 0x79, 0x0a, 0x6d, 0x74, 0x2e, 0x73,
-    0x61, 0x76, 0x65, 0x64, 0x5f, 0x6c, 0x69, 0x6e, 0x65, 0x73, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x6d, 0x74, 0x5f, 0x6c, 0x69, 0x6e, 0x65, 0x73,
-    0x20, 0x2d, 0x2d, 0x20, 0x61, 0x6c, 0x77, 0x61, 0x79, 0x73, 0x20, 0x72, 0x65, 0x61, 0x64, 0x6f,
-    0x6e, 0x6c, 0x79, 0x0a, 0x0a, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x66, 0x75, 0x6e, 0x63, 0x74,
-    0x69, 0x6f, 0x6e, 0x20, 0x6c, 0x75, 0x61, 0x74, 0x65, 0x78, 0x5f, 0x69, 0x6f, 0x5f, 0x6f, 0x70,
-    0x65, 0x6e, 0x28, 0x6e, 0x61, 0x6d, 0x65, 0x2c, 0x68, 0x6f, 0x77, 0x29, 0x0a, 0x20, 0x20, 0x20,
-    0x20, 0x69, 0x66, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x68, 0x6f, 0x77, 0x20, 0x74, 0x68, 0x65, 0x6e,
-    0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x68, 0x6f, 0x77, 0x20, 0x3d, 0x20, 0x27,
-    0x72, 0x27, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x65, 0x6e, 0x64, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x6c,
-    0x6f, 0x63, 0x61, 0x6c, 0x20, 0x66, 0x20, 0x3d, 0x20, 0x69, 0x6f, 0x5f, 0x6f, 0x70, 0x65, 0x6e,
-    0x28, 0x6e, 0x61, 0x6d, 0x65, 0x2c, 0x68, 0x6f, 0x77, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x69,
+    0x53, 0x49, 0x4f, 0x4e, 0x20, 0x3d, 0x20, 0x31, 0x2e, 0x30, 0x30, 0x35, 0x0a, 0x0a, 0x2d, 0x2d,
+    0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x66, 0x69, 0x6c, 0x65, 0x20, 0x6f, 0x76, 0x65, 0x72, 0x6c,
+    0x6f, 0x61, 0x64, 0x73, 0x20, 0x73, 0x6f, 0x6d, 0x65, 0x20, 0x4c, 0x75, 0x61, 0x20, 0x66, 0x75,
+    0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2e, 0x20, 0x54, 0x68, 0x65, 0x20, 0x72, 0x65, 0x61,
+    0x64, 0x6c, 0x69, 0x6e, 0x65, 0x20, 0x76, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74, 0x73, 0x20, 0x70,
+    0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73, 0x61, 0x6d, 0x65, 0x0a,
+    0x2d, 0x2d, 0x20, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x69, 0x74, 0x79,
+    0x20, 0x61, 0x73, 0x20, 0x4c, 0x75, 0x61, 0x54, 0x65, 0x58, 0x20, 0x3c, 0x3d, 0x20, 0x31, 0x2e,
+    0x30, 0x34, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x64, 0x6f, 0x69, 0x6e, 0x67, 0x20, 0x69, 0x74, 0x20,
+    0x74, 0x68, 0x69, 0x73, 0x20, 0x77, 0x61, 0x79, 0x20, 0x70, 0x65, 0x72, 0x6d, 0x69, 0x74, 0x73,
+    0x20, 0x75, 0x73, 0x20, 0x74, 0x6f, 0x20, 0x6b, 0x65, 0x65, 0x70, 0x20, 0x74, 0x68, 0x65, 0x0a,
+    0x2d, 0x2d, 0x20, 0x6f, 0x72, 0x69, 0x67, 0x69, 0x6e, 0x61, 0x6c, 0x20, 0x69, 0x6f, 0x20, 0x6c,
+    0x69, 0x62, 0x72, 0x61, 0x72, 0x69, 0x65, 0x73, 0x20, 0x63, 0x6c, 0x65, 0x61, 0x6e, 0x2e, 0x20,
+    0x50, 0x65, 0x72, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x6e, 0x63, 0x65, 0x20, 0x69, 0x73, 0x20, 0x70,
+    0x72, 0x6f, 0x62, 0x61, 0x62, 0x6c, 0x79, 0x20, 0x65, 0x76, 0x65, 0x6e, 0x20, 0x61, 0x20, 0x62,
+    0x69, 0x74, 0x20, 0x62, 0x65, 0x74, 0x74, 0x65, 0x72, 0x20, 0x6e, 0x6f, 0x77, 0x2e, 0x0a, 0x0a,
+    0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x74, 0x79, 0x70, 0x65, 0x2c, 0x20, 0x6e, 0x65, 0x78, 0x74,
+    0x2c, 0x20, 0x67, 0x65, 0x74, 0x6d, 0x65, 0x74, 0x61, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x2c, 0x20,
+    0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x20, 0x3d, 0x20, 0x74, 0x79, 0x70, 0x65, 0x2c, 0x20,
+    0x6e, 0x65, 0x78, 0x74, 0x2c, 0x20, 0x67, 0x65, 0x74, 0x6d, 0x65, 0x74, 0x61, 0x74, 0x61, 0x62,
+    0x6c, 0x65, 0x2c, 0x20, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x0a, 0x6c, 0x6f, 0x63, 0x61,
+    0x6c, 0x20, 0x66, 0x69, 0x6e, 0x64, 0x2c, 0x20, 0x67, 0x73, 0x75, 0x62, 0x2c, 0x20, 0x66, 0x6f,
+    0x72, 0x6d, 0x61, 0x74, 0x20, 0x3d, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x2e, 0x66, 0x69,
+    0x6e, 0x64, 0x2c, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x2e, 0x67, 0x73, 0x75, 0x62, 0x2c,
+    0x20, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x2e, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x0a, 0x0a,
+    0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x69, 0x6f, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x20, 0x20, 0x20,
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x69, 0x6f, 0x2e, 0x6f,
+    0x70, 0x65, 0x6e, 0x0a, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x69, 0x6f, 0x5f, 0x70, 0x6f, 0x70,
+    0x65, 0x6e, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20,
+    0x69, 0x6f, 0x2e, 0x70, 0x6f, 0x70, 0x65, 0x6e, 0x0a, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x69,
+    0x6f, 0x5f, 0x6c, 0x69, 0x6e, 0x65, 0x73, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+    0x20, 0x20, 0x20, 0x3d, 0x20, 0x69, 0x6f, 0x2e, 0x6c, 0x69, 0x6e, 0x65, 0x73, 0x0a, 0x0a, 0x6c,
+    0x6f, 0x63, 0x61, 0x6c, 0x20, 0x66, 0x69, 0x6f, 0x5f, 0x72, 0x65, 0x61, 0x64, 0x6c, 0x69, 0x6e,
+    0x65, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x66, 0x69, 0x6f, 0x2e, 0x72,
+    0x65, 0x61, 0x64, 0x6c, 0x69, 0x6e, 0x65, 0x0a, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x66, 0x69,
+    0x6f, 0x5f, 0x63, 0x68, 0x65, 0x63, 0x6b, 0x70, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f,
+    0x6e, 0x20, 0x3d, 0x20, 0x66, 0x69, 0x6f, 0x2e, 0x63, 0x68, 0x65, 0x63, 0x6b, 0x70, 0x65, 0x72,
+    0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x0a, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x66, 0x69,
+    0x6f, 0x5f, 0x72, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x66, 0x69, 0x6c, 0x65, 0x6e, 0x61, 0x6d, 0x65,
+    0x20, 0x20, 0x3d, 0x20, 0x66, 0x69, 0x6f, 0x2e, 0x72, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x66, 0x69,
+    0x6c, 0x65, 0x6e, 0x61, 0x6d, 0x65, 0x0a, 0x0a, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x6d, 0x74,
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+    0x20, 0x20, 0x3d, 0x20, 0x67, 0x65, 0x74, 0x6d, 0x65, 0x74, 0x61, 0x74, 0x61, 0x62, 0x6c, 0x65,
+    0x28, 0x69, 0x6f, 0x2e, 0x73, 0x74, 0x64, 0x65, 0x72, 0x72, 0x29, 0x0a, 0x6c, 0x6f, 0x63, 0x61,
+    0x6c, 0x20, 0x6d, 0x74, 0x5f, 0x6c, 0x69, 0x6e, 0x65, 0x73, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x6d, 0x74, 0x2e, 0x6c, 0x69, 0x6e, 0x65, 0x73,
+    0x0a, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x73, 0x61, 0x66, 0x65, 0x72, 0x6f, 0x70, 0x74, 0x69,
+    0x6f, 0x6e, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x73, 0x74, 0x61,
+    0x74, 0x75, 0x73, 0x2e, 0x73, 0x61, 0x66, 0x65, 0x72, 0x5f, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e,
+    0x0a, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x73, 0x68, 0x65, 0x6c, 0x6c, 0x65, 0x73, 0x63, 0x61,
+    0x70, 0x65, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x73, 0x74, 0x61,
+    0x74, 0x75, 0x73, 0x2e, 0x73, 0x68, 0x65, 0x6c, 0x6c, 0x5f, 0x65, 0x73, 0x63, 0x61, 0x70, 0x65,
+    0x20, 0x2d, 0x2d, 0x20, 0x30, 0x20, 0x28, 0x64, 0x69, 0x73, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x29,
+    0x20, 0x31, 0x20, 0x28, 0x61, 0x6e, 0x79, 0x74, 0x68, 0x69, 0x6e, 0x67, 0x29, 0x20, 0x32, 0x20,
+    0x28, 0x72, 0x65, 0x73, 0x74, 0x72, 0x69, 0x63, 0x74, 0x65, 0x64, 0x29, 0x0a, 0x6c, 0x6f, 0x63,
+    0x61, 0x6c, 0x20, 0x6b, 0x70, 0x73, 0x65, 0x75, 0x73, 0x65, 0x64, 0x20, 0x20, 0x20, 0x20, 0x20,
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x2e,
+    0x6b, 0x70, 0x73, 0x65, 0x5f, 0x75, 0x73, 0x65, 0x64, 0x20, 0x20, 0x20, 0x20, 0x2d, 0x2d, 0x20,
+    0x30, 0x20, 0x31, 0x0a, 0x0a, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x77, 0x72, 0x69, 0x74, 0x65,
+    0x5f, 0x6e, 0x6c, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3d,
+    0x20, 0x74, 0x65, 0x78, 0x69, 0x6f, 0x2e, 0x77, 0x72, 0x69, 0x74, 0x65, 0x5f, 0x6e, 0x6c, 0x0a,
+    0x0a, 0x69, 0x6f, 0x2e, 0x73, 0x61, 0x76, 0x65, 0x64, 0x5f, 0x6c, 0x69, 0x6e, 0x65, 0x73, 0x20,
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x69, 0x6f, 0x5f,
+    0x6c, 0x69, 0x6e, 0x65, 0x73, 0x20, 0x2d, 0x2d, 0x20, 0x61, 0x6c, 0x77, 0x61, 0x79, 0x73, 0x20,
+    0x72, 0x65, 0x61, 0x64, 0x6f, 0x6e, 0x6c, 0x79, 0x0a, 0x6d, 0x74, 0x2e, 0x73, 0x61, 0x76, 0x65,
+    0x64, 0x5f, 0x6c, 0x69, 0x6e, 0x65, 0x73, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+    0x20, 0x20, 0x20, 0x3d, 0x20, 0x6d, 0x74, 0x5f, 0x6c, 0x69, 0x6e, 0x65, 0x73, 0x20, 0x2d, 0x2d,
+    0x20, 0x61, 0x6c, 0x77, 0x61, 0x79, 0x73, 0x20, 0x72, 0x65, 0x61, 0x64, 0x6f, 0x6e, 0x6c, 0x79,
+    0x0a, 0x0a, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e,
+    0x20, 0x6c, 0x75, 0x61, 0x74, 0x65, 0x78, 0x5f, 0x69, 0x6f, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x28,
+    0x6e, 0x61, 0x6d, 0x65, 0x2c, 0x68, 0x6f, 0x77, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x69, 0x66,
+    0x20, 0x6e, 0x6f, 0x74, 0x20, 0x68, 0x6f, 0x77, 0x20, 0x74, 0x68, 0x65, 0x6e, 0x0a, 0x20, 0x20,
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x68, 0x6f, 0x77, 0x20, 0x3d, 0x20, 0x27, 0x72, 0x27, 0x0a,
+    0x20, 0x20, 0x20, 0x20, 0x65, 0x6e, 0x64, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x6c, 0x6f, 0x63, 0x61,
+    0x6c, 0x20, 0x66, 0x20, 0x3d, 0x20, 0x69, 0x6f, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x28, 0x6e, 0x61,
+    0x6d, 0x65, 0x2c, 0x68, 0x6f, 0x77, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x69, 0x66, 0x20, 0x66,
+    0x20, 0x74, 0x68, 0x65, 0x6e, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x69, 0x66,
+    0x20, 0x74, 0x79, 0x70, 0x65, 0x28, 0x68, 0x6f, 0x77, 0x29, 0x20, 0x3d, 0x3d, 0x20, 0x27, 0x73,
+    0x74, 0x72, 0x69, 0x6e, 0x67, 0x27, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x66, 0x69, 0x6e, 0x64, 0x28,
+    0x68, 0x6f, 0x77, 0x2c, 0x27, 0x77, 0x27, 0x29, 0x20, 0x74, 0x68, 0x65, 0x6e, 0x0a, 0x20, 0x20,
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x66, 0x69, 0x6f, 0x5f, 0x72, 0x65,
+    0x63, 0x6f, 0x72, 0x64, 0x66, 0x69, 0x6c, 0x65, 0x6e, 0x61, 0x6d, 0x65, 0x28, 0x6e, 0x61, 0x6d,
+    0x65, 0x2c, 0x27, 0x77, 0x27, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x65,
+    0x6c, 0x73, 0x65, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+    0x66, 0x69, 0x6f, 0x5f, 0x72, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x66, 0x69, 0x6c, 0x65, 0x6e, 0x61,
+    0x6d, 0x65, 0x28, 0x6e, 0x61, 0x6d, 0x65, 0x2c, 0x27, 0x72, 0x27, 0x29, 0x0a, 0x20, 0x20, 0x20,
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x65, 0x6e, 0x64, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x65, 0x6e, 0x64,
+    0x0a, 0x20, 0x20, 0x20, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x20, 0x66, 0x0a, 0x65, 0x6e,
+    0x64, 0x0a, 0x0a, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f,
+    0x6e, 0x20, 0x6c, 0x75, 0x61, 0x74, 0x65, 0x78, 0x5f, 0x69, 0x6f, 0x5f, 0x6f, 0x70, 0x65, 0x6e,
+    0x5f, 0x72, 0x65, 0x61, 0x64, 0x6f, 0x6e, 0x6c, 0x79, 0x28, 0x6e, 0x61, 0x6d, 0x65, 0x2c, 0x68,
+    0x6f, 0x77, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x69, 0x66, 0x20, 0x68, 0x6f, 0x77, 0x20, 0x74,
+    0x68, 0x65, 0x6e, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x68, 0x6f, 0x77, 0x20,
+    0x3d, 0x20, 0x27, 0x72, 0x27, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x65, 0x6c, 0x73, 0x65, 0x0a, 0x20,
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x68, 0x6f, 0x77, 0x20, 0x3d, 0x20, 0x67, 0x73, 0x75,
+    0x62, 0x28, 0x68, 0x6f, 0x77, 0x2c, 0x27, 0x5b, 0x5e, 0x72, 0x62, 0x5d, 0x27, 0x2c, 0x27, 0x27,
+    0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x69, 0x66, 0x20, 0x68, 0x6f, 0x77,
+    0x20, 0x3d, 0x3d, 0x20, 0x27, 0x27, 0x20, 0x74, 0x68, 0x65, 0x6e, 0x0a, 0x20, 0x20, 0x20, 0x20,
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x68, 0x6f, 0x77, 0x20, 0x3d, 0x20, 0x27, 0x72,
+    0x27, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x65, 0x6e, 0x64, 0x0a, 0x20, 0x20,
+    0x20, 0x20, 0x65, 0x6e, 0x64, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20,
+    0x66, 0x20, 0x3d, 0x20, 0x69, 0x6f, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x28, 0x6e, 0x61, 0x6d, 0x65,
+    0x2c, 0x68, 0x6f, 0x77, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x69, 0x66, 0x20, 0x66, 0x20, 0x74,
+    0x68, 0x65, 0x6e, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x66, 0x69, 0x6f, 0x5f,
+    0x72, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x66, 0x69, 0x6c, 0x65, 0x6e, 0x61, 0x6d, 0x65, 0x28, 0x6e,
+    0x61, 0x6d, 0x65, 0x2c, 0x27, 0x72, 0x27, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x65, 0x6e, 0x64,
+    0x0a, 0x20, 0x20, 0x20, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x20, 0x66, 0x0a, 0x65, 0x6e,
+    0x64, 0x0a, 0x0a, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f,
+    0x6e, 0x20, 0x6c, 0x75, 0x61, 0x74, 0x65, 0x78, 0x5f, 0x69, 0x6f, 0x5f, 0x70, 0x6f, 0x70, 0x65,
+    0x6e, 0x28, 0x6e, 0x61, 0x6d, 0x65, 0x2c, 0x2e, 0x2e, 0x2e, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20,
+    0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x6f, 0x6b, 0x61, 0x79, 0x2c, 0x20, 0x66, 0x6f, 0x75, 0x6e,
+    0x64, 0x20, 0x3d, 0x20, 0x66, 0x69, 0x6f, 0x5f, 0x63, 0x68, 0x65, 0x63, 0x6b, 0x70, 0x65, 0x72,
+    0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x28, 0x6e, 0x61, 0x6d, 0x65, 0x29, 0x0a, 0x20, 0x20,
+    0x20, 0x20, 0x69, 0x66, 0x20, 0x6f, 0x6b, 0x61, 0x79, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x66, 0x6f,
+    0x75, 0x6e, 0x64, 0x20, 0x74, 0x68, 0x65, 0x6e, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+    0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x20, 0x69, 0x6f, 0x5f, 0x70, 0x6f, 0x70, 0x65, 0x6e,
+    0x28, 0x66, 0x6f, 0x75, 0x6e, 0x64, 0x2c, 0x2e, 0x2e, 0x2e, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20,
+    0x65, 0x6e, 0x64, 0x0a, 0x65, 0x6e, 0x64, 0x0a, 0x0a, 0x2d, 0x2d, 0x20, 0x6c, 0x6f, 0x63, 0x61,
+    0x6c, 0x20, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x6c, 0x75, 0x61, 0x74, 0x65,
+    0x78, 0x5f, 0x69, 0x6f, 0x5f, 0x6c, 0x69, 0x6e, 0x65, 0x73, 0x28, 0x6e, 0x61, 0x6d, 0x65, 0x2c,
+    0x68, 0x6f, 0x77, 0x29, 0x0a, 0x2d, 0x2d, 0x20, 0x20, 0x20, 0x20, 0x20, 0x69, 0x66, 0x20, 0x6e,
+    0x61, 0x6d, 0x65, 0x20, 0x74, 0x68, 0x65, 0x6e, 0x0a, 0x2d, 0x2d, 0x20, 0x20, 0x20, 0x20, 0x20,
+    0x20, 0x20, 0x20, 0x20, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x66, 0x20, 0x3d, 0x20, 0x69, 0x6f,
+    0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x28, 0x6e, 0x61, 0x6d, 0x65, 0x2c, 0x68, 0x6f, 0x77, 0x20, 0x6f,
+    0x72, 0x20, 0x27, 0x72, 0x27, 0x29, 0x0a, 0x2d, 0x2d, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+    0x20, 0x20, 0x69, 0x66, 0x20, 0x66, 0x20, 0x74, 0x68, 0x65, 0x6e, 0x0a, 0x2d, 0x2d, 0x20, 0x20,
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72,
+    0x6e, 0x20, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x28, 0x29, 0x0a, 0x2d, 0x2d, 0x20,
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+    0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x20, 0x66, 0x69, 0x6f, 0x5f, 0x72, 0x65, 0x61, 0x64, 0x6c,
+    0x69, 0x6e, 0x65, 0x28, 0x66, 0x29, 0x0a, 0x2d, 0x2d, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x65, 0x6e, 0x64, 0x0a, 0x2d, 0x2d, 0x20, 0x20, 0x20, 0x20,
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x65, 0x6e, 0x64, 0x0a, 0x2d, 0x2d, 0x20, 0x20, 0x20, 0x20, 0x20,
+    0x65, 0x6c, 0x73, 0x65, 0x0a, 0x2d, 0x2d, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+    0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x20, 0x69, 0x6f, 0x5f, 0x6c, 0x69, 0x6e, 0x65, 0x73, 0x28,
+    0x29, 0x0a, 0x2d, 0x2d, 0x20, 0x20, 0x20, 0x20, 0x20, 0x65, 0x6e, 0x64, 0x0a, 0x2d, 0x2d, 0x20,
+    0x65, 0x6e, 0x64, 0x0a, 0x0a, 0x2d, 0x2d, 0x20, 0x46, 0x6f, 0x72, 0x20, 0x73, 0x6f, 0x6d, 0x65,
+    0x20, 0x72, 0x65, 0x61, 0x73, 0x6f, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x67, 0x63, 0x20, 0x64,
+    0x6f, 0x65, 0x73, 0x6e, 0x27, 0x74, 0x20, 0x6b, 0x69, 0x63, 0x6b, 0x20, 0x69, 0x6e, 0x20, 0x73,
+    0x6f, 0x20, 0x77, 0x65, 0x20, 0x6e, 0x65, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20, 0x63, 0x6c, 0x6f,
+    0x73, 0x65, 0x20, 0x65, 0x78, 0x70, 0x6c, 0x69, 0x74, 0x6c, 0x79, 0x0a, 0x2d, 0x2d, 0x20, 0x73,
+    0x6f, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x68, 0x61, 0x6e, 0x64, 0x6c,
+    0x65, 0x20, 0x69, 0x73, 0x20, 0x66, 0x6c, 0x75, 0x73, 0x68, 0x65, 0x64, 0x2e, 0x0a, 0x0a, 0x6c,
+    0x6f, 0x63, 0x61, 0x6c, 0x20, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x2c, 0x20, 0x74, 0x79, 0x70, 0x65,
+    0x20, 0x3d, 0x20, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x2c, 0x20, 0x74, 0x79, 0x70, 0x65, 0x0a, 0x0a,
+    0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x6c,
+    0x75, 0x61, 0x74, 0x65, 0x78, 0x5f, 0x69, 0x6f, 0x5f, 0x6c, 0x69, 0x6e, 0x65, 0x73, 0x28, 0x6e,
+    0x61, 0x6d, 0x65, 0x2c, 0x68, 0x6f, 0x77, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x69, 0x66, 0x20,
+    0x74, 0x79, 0x70, 0x65, 0x28, 0x6e, 0x61, 0x6d, 0x65, 0x29, 0x20, 0x3d, 0x3d, 0x20, 0x22, 0x73,
+    0x74, 0x72, 0x69, 0x6e, 0x67, 0x22, 0x20, 0x74, 0x68, 0x65, 0x6e, 0x0a, 0x20, 0x20, 0x20, 0x20,
+    0x20, 0x20, 0x20, 0x20, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x66, 0x20, 0x3d, 0x20, 0x69, 0x6f,
+    0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x28, 0x6e, 0x61, 0x6d, 0x65, 0x2c, 0x68, 0x6f, 0x77, 0x20, 0x6f,
+    0x72, 0x20, 0x27, 0x72, 0x27, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x69,
     0x66, 0x20, 0x66, 0x20, 0x74, 0x68, 0x65, 0x6e, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x69, 0x66, 0x20, 0x74, 0x79, 0x70, 0x65, 0x28, 0x68, 0x6f, 0x77, 0x29, 0x20, 0x3d, 0x3d,
-    0x20, 0x27, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x27, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x66, 0x69,
-    0x6e, 0x64, 0x28, 0x68, 0x6f, 0x77, 0x2c, 0x27, 0x77, 0x27, 0x29, 0x20, 0x74, 0x68, 0x65, 0x6e,
-    0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x66, 0x69, 0x6f,
-    0x5f, 0x72, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x66, 0x69, 0x6c, 0x65, 0x6e, 0x61, 0x6d, 0x65, 0x28,
-    0x6e, 0x61, 0x6d, 0x65, 0x2c, 0x27, 0x77, 0x27, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x20, 0x66, 0x75, 0x6e, 0x63,
+    0x74, 0x69, 0x6f, 0x6e, 0x28, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x6c, 0x20, 0x3d,
+    0x20, 0x66, 0x69, 0x6f, 0x5f, 0x72, 0x65, 0x61, 0x64, 0x6c, 0x69, 0x6e, 0x65, 0x28, 0x66, 0x29,
+    0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+    0x20, 0x69, 0x66, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x6c, 0x20, 0x74, 0x68, 0x65, 0x6e, 0x0a, 0x20,
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+    0x20, 0x20, 0x20, 0x66, 0x3a, 0x63, 0x6c, 0x6f, 0x73, 0x65, 0x28, 0x29, 0x0a, 0x20, 0x20, 0x20,
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x65, 0x6e, 0x64,
+    0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+    0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x20, 0x6c, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x65, 0x6e, 0x64, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
     0x20, 0x20, 0x65, 0x6c, 0x73, 0x65, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x66, 0x69, 0x6f, 0x5f, 0x72, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x66, 0x69, 0x6c,
-    0x65, 0x6e, 0x61, 0x6d, 0x65, 0x28, 0x6e, 0x61, 0x6d, 0x65, 0x2c, 0x27, 0x72, 0x27, 0x29, 0x0a,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x65, 0x6e, 0x64, 0x0a, 0x20, 0x20, 0x20, 0x20,
-    0x65, 0x6e, 0x64, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x20, 0x66,
+    0x20, 0x20, 0x20, 0x2d, 0x2d, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x74, 0x68, 0x6f, 0x73, 0x65, 0x20,
+    0x77, 0x68, 0x6f, 0x20, 0x6c, 0x69, 0x6b, 0x65, 0x20, 0x69, 0x74, 0x20, 0x74, 0x68, 0x69, 0x73,
+    0x20, 0x77, 0x61, 0x79, 0x3a, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+    0x20, 0x20, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x28, 0x22, 0x70, 0x61, 0x74, 0x63, 0x68, 0x65, 0x64,
+    0x20, 0x27, 0x69, 0x6f, 0x2e, 0x6c, 0x69, 0x6e, 0x65, 0x73, 0x27, 0x20, 0x63, 0x61, 0x6e, 0x27,
+    0x74, 0x20, 0x6f, 0x70, 0x65, 0x6e, 0x20, 0x27, 0x22, 0x20, 0x2e, 0x2e, 0x20, 0x6e, 0x61, 0x6d,
+    0x65, 0x20, 0x2e, 0x2e, 0x20, 0x22, 0x27, 0x22, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+    0x20, 0x20, 0x65, 0x6e, 0x64, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x65, 0x6c, 0x73, 0x65, 0x0a, 0x20,
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x20, 0x69, 0x6f,
+    0x5f, 0x6c, 0x69, 0x6e, 0x65, 0x73, 0x28, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x65, 0x6e, 0x64,
     0x0a, 0x65, 0x6e, 0x64, 0x0a, 0x0a, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x66, 0x75, 0x6e, 0x63,
-    0x74, 0x69, 0x6f, 0x6e, 0x20, 0x6c, 0x75, 0x61, 0x74, 0x65, 0x78, 0x5f, 0x69, 0x6f, 0x5f, 0x6f,
-    0x70, 0x65, 0x6e, 0x5f, 0x72, 0x65, 0x61, 0x64, 0x6f, 0x6e, 0x6c, 0x79, 0x28, 0x6e, 0x61, 0x6d,
-    0x65, 0x2c, 0x68, 0x6f, 0x77, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x69, 0x66, 0x20, 0x68, 0x6f,
-    0x77, 0x20, 0x74, 0x68, 0x65, 0x6e, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x68,
-    0x6f, 0x77, 0x20, 0x3d, 0x20, 0x27, 0x72, 0x27, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x65, 0x6c, 0x73,
-    0x65, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x68, 0x6f, 0x77, 0x20, 0x3d, 0x20,
-    0x67, 0x73, 0x75, 0x62, 0x28, 0x68, 0x6f, 0x77, 0x2c, 0x27, 0x5b, 0x5e, 0x72, 0x62, 0x5d, 0x27,
-    0x2c, 0x27, 0x27, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x69, 0x66, 0x20,
-    0x68, 0x6f, 0x77, 0x20, 0x3d, 0x3d, 0x20, 0x27, 0x27, 0x20, 0x74, 0x68, 0x65, 0x6e, 0x0a, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x68, 0x6f, 0x77, 0x20, 0x3d,
-    0x20, 0x27, 0x72, 0x27, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x65, 0x6e, 0x64,
-    0x0a, 0x20, 0x20, 0x20, 0x20, 0x65, 0x6e, 0x64, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x6c, 0x6f, 0x63,
-    0x61, 0x6c, 0x20, 0x66, 0x20, 0x3d, 0x20, 0x69, 0x6f, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x28, 0x6e,
-    0x61, 0x6d, 0x65, 0x2c, 0x68, 0x6f, 0x77, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x69, 0x66, 0x20,
-    0x66, 0x20, 0x74, 0x68, 0x65, 0x6e, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x66,
-    0x69, 0x6f, 0x5f, 0x72, 0x65, 0x63, 0x6f, 0x72, 0x64, 0x66, 0x69, 0x6c, 0x65, 0x6e, 0x61, 0x6d,
-    0x65, 0x28, 0x6e, 0x61, 0x6d, 0x65, 0x2c, 0x27, 0x72, 0x27, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20,
-    0x65, 0x6e, 0x64, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x20, 0x66,
-    0x0a, 0x65, 0x6e, 0x64, 0x0a, 0x0a, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x66, 0x75, 0x6e, 0x63,
-    0x74, 0x69, 0x6f, 0x6e, 0x20, 0x6c, 0x75, 0x61, 0x74, 0x65, 0x78, 0x5f, 0x69, 0x6f, 0x5f, 0x70,
-    0x6f, 0x70, 0x65, 0x6e, 0x28, 0x6e, 0x61, 0x6d, 0x65, 0x2c, 0x2e, 0x2e, 0x2e, 0x29, 0x0a, 0x20,
-    0x20, 0x20, 0x20, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x6f, 0x6b, 0x61, 0x79, 0x2c, 0x20, 0x66,
-    0x6f, 0x75, 0x6e, 0x64, 0x20, 0x3d, 0x20, 0x66, 0x69, 0x6f, 0x5f, 0x63, 0x68, 0x65, 0x63, 0x6b,
-    0x70, 0x65, 0x72, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x28, 0x6e, 0x61, 0x6d, 0x65, 0x29,
-    0x0a, 0x20, 0x20, 0x20, 0x20, 0x69, 0x66, 0x20, 0x6f, 0x6b, 0x61, 0x79, 0x20, 0x61, 0x6e, 0x64,
-    0x20, 0x66, 0x6f, 0x75, 0x6e, 0x64, 0x20, 0x74, 0x68, 0x65, 0x6e, 0x0a, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x20, 0x69, 0x6f, 0x5f, 0x70, 0x6f,
-    0x70, 0x65, 0x6e, 0x28, 0x66, 0x6f, 0x75, 0x6e, 0x64, 0x2c, 0x2e, 0x2e, 0x2e, 0x29, 0x0a, 0x20,
-    0x20, 0x20, 0x20, 0x65, 0x6e, 0x64, 0x0a, 0x65, 0x6e, 0x64, 0x0a, 0x0a, 0x2d, 0x2d, 0x20, 0x6c,
-    0x6f, 0x63, 0x61, 0x6c, 0x20, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x6c, 0x75,
-    0x61, 0x74, 0x65, 0x78, 0x5f, 0x69, 0x6f, 0x5f, 0x6c, 0x69, 0x6e, 0x65, 0x73, 0x28, 0x6e, 0x61,
-    0x6d, 0x65, 0x2c, 0x68, 0x6f, 0x77, 0x29, 0x0a, 0x2d, 0x2d, 0x20, 0x20, 0x20, 0x20, 0x20, 0x69,
-    0x66, 0x20, 0x6e, 0x61, 0x6d, 0x65, 0x20, 0x74, 0x68, 0x65, 0x6e, 0x0a, 0x2d, 0x2d, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x66, 0x20, 0x3d,
-    0x20, 0x69, 0x6f, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x28, 0x6e, 0x61, 0x6d, 0x65, 0x2c, 0x68, 0x6f,
-    0x77, 0x20, 0x6f, 0x72, 0x20, 0x27, 0x72, 0x27, 0x29, 0x0a, 0x2d, 0x2d, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x69, 0x66, 0x20, 0x66, 0x20, 0x74, 0x68, 0x65, 0x6e, 0x0a, 0x2d,
-    0x2d, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x72, 0x65,
-    0x74, 0x75, 0x72, 0x6e, 0x20, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x28, 0x29, 0x0a,
-    0x2d, 0x2d, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x20, 0x66, 0x69, 0x6f, 0x5f, 0x72, 0x65,
-    0x61, 0x64, 0x6c, 0x69, 0x6e, 0x65, 0x28, 0x66, 0x29, 0x0a, 0x2d, 0x2d, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x65, 0x6e, 0x64, 0x0a, 0x2d, 0x2d, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x65, 0x6e, 0x64, 0x0a, 0x2d, 0x2d, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x65, 0x6c, 0x73, 0x65, 0x0a, 0x2d, 0x2d, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x20, 0x69, 0x6f, 0x5f, 0x6c, 0x69, 0x6e,
-    0x65, 0x73, 0x28, 0x29, 0x0a, 0x2d, 0x2d, 0x20, 0x20, 0x20, 0x20, 0x20, 0x65, 0x6e, 0x64, 0x0a,
-    0x2d, 0x2d, 0x20, 0x65, 0x6e, 0x64, 0x0a, 0x0a, 0x2d, 0x2d, 0x20, 0x46, 0x6f, 0x72, 0x20, 0x73,
-    0x6f, 0x6d, 0x65, 0x20, 0x72, 0x65, 0x61, 0x73, 0x6f, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x67,
-    0x63, 0x20, 0x64, 0x6f, 0x65, 0x73, 0x6e, 0x27, 0x74, 0x20, 0x6b, 0x69, 0x63, 0x6b, 0x20, 0x69,
-    0x6e, 0x20, 0x73, 0x6f, 0x20, 0x77, 0x65, 0x20, 0x6e, 0x65, 0x65, 0x64, 0x20, 0x74, 0x6f, 0x20,
-    0x63, 0x6c, 0x6f, 0x73, 0x65, 0x20, 0x65, 0x78, 0x70, 0x6c, 0x69, 0x74, 0x6c, 0x79, 0x0a, 0x2d,
-    0x2d, 0x20, 0x73, 0x6f, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20, 0x74, 0x68, 0x65, 0x20, 0x68, 0x61,
-    0x6e, 0x64, 0x6c, 0x65, 0x20, 0x69, 0x73, 0x20, 0x66, 0x6c, 0x75, 0x73, 0x68, 0x65, 0x64, 0x2e,
-    0x0a, 0x0a, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x2c, 0x20, 0x74,
-    0x79, 0x70, 0x65, 0x20, 0x3d, 0x20, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x2c, 0x20, 0x74, 0x79, 0x70,
-    0x65, 0x0a, 0x0a, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f,
-    0x6e, 0x20, 0x6c, 0x75, 0x61, 0x74, 0x65, 0x78, 0x5f, 0x69, 0x6f, 0x5f, 0x6c, 0x69, 0x6e, 0x65,
-    0x73, 0x28, 0x6e, 0x61, 0x6d, 0x65, 0x2c, 0x68, 0x6f, 0x77, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20,
-    0x69, 0x66, 0x20, 0x74, 0x79, 0x70, 0x65, 0x28, 0x6e, 0x61, 0x6d, 0x65, 0x29, 0x20, 0x3d, 0x3d,
-    0x20, 0x22, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x22, 0x20, 0x74, 0x68, 0x65, 0x6e, 0x0a, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x66, 0x20, 0x3d,
-    0x20, 0x69, 0x6f, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x28, 0x6e, 0x61, 0x6d, 0x65, 0x2c, 0x68, 0x6f,
-    0x77, 0x20, 0x6f, 0x72, 0x20, 0x27, 0x72, 0x27, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x69, 0x66, 0x20, 0x66, 0x20, 0x74, 0x68, 0x65, 0x6e, 0x0a, 0x20, 0x20, 0x20, 0x20,
+    0x74, 0x69, 0x6f, 0x6e, 0x20, 0x6c, 0x75, 0x61, 0x74, 0x65, 0x78, 0x5f, 0x69, 0x6f, 0x5f, 0x72,
+    0x65, 0x61, 0x64, 0x6c, 0x69, 0x6e, 0x65, 0x28, 0x66, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x72,
+    0x65, 0x74, 0x75, 0x72, 0x6e, 0x20, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x28, 0x29,
+    0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x20,
+    0x66, 0x69, 0x6f, 0x5f, 0x72, 0x65, 0x61, 0x64, 0x6c, 0x69, 0x6e, 0x65, 0x28, 0x66, 0x29, 0x0a,
+    0x20, 0x20, 0x20, 0x20, 0x65, 0x6e, 0x64, 0x0a, 0x65, 0x6e, 0x64, 0x0a, 0x0a, 0x69, 0x6f, 0x2e,
+    0x6c, 0x69, 0x6e, 0x65, 0x73, 0x20, 0x3d, 0x20, 0x6c, 0x75, 0x61, 0x74, 0x65, 0x78, 0x5f, 0x69,
+    0x6f, 0x5f, 0x6c, 0x69, 0x6e, 0x65, 0x73, 0x0a, 0x6d, 0x74, 0x2e, 0x6c, 0x69, 0x6e, 0x65, 0x73,
+    0x20, 0x3d, 0x20, 0x6c, 0x75, 0x61, 0x74, 0x65, 0x78, 0x5f, 0x69, 0x6f, 0x5f, 0x72, 0x65, 0x61,
+    0x64, 0x6c, 0x69, 0x6e, 0x65, 0x0a, 0x0a, 0x2d, 0x2d, 0x20, 0x57, 0x65, 0x20, 0x61, 0x73, 0x73,
+    0x75, 0x6d, 0x65, 0x20, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x20, 0x74,
+    0x6f, 0x20, 0x62, 0x65, 0x20, 0x70, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x64, 0x20, 0x62, 0x79,
+    0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x70, 0x6c, 0x61, 0x63, 0x65, 0x6d, 0x65, 0x6e, 0x74,
+    0x20, 0x6f, 0x66, 0x20, 0x6b, 0x70, 0x73, 0x65, 0x2e, 0x20, 0x54, 0x68, 0x69, 0x73, 0x20, 0x69,
+    0x73, 0x20, 0x74, 0x68, 0x65, 0x0a, 0x2d, 0x2d, 0x20, 0x63, 0x61, 0x73, 0x65, 0x20, 0x69, 0x6e,
+    0x20, 0x43, 0x6f, 0x6e, 0x54, 0x65, 0x58, 0x74, 0x2e, 0x0a, 0x0a, 0x69, 0x66, 0x20, 0x6b, 0x70,
+    0x73, 0x65, 0x75, 0x73, 0x65, 0x64, 0x20, 0x3d, 0x3d, 0x20, 0x31, 0x20, 0x74, 0x68, 0x65, 0x6e,
+    0x0a, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x69, 0x6f, 0x2e, 0x6f, 0x70, 0x65, 0x6e, 0x20, 0x20, 0x3d,
+    0x20, 0x6c, 0x75, 0x61, 0x74, 0x65, 0x78, 0x5f, 0x69, 0x6f, 0x5f, 0x6f, 0x70, 0x65, 0x6e, 0x0a,
+    0x20, 0x20, 0x20, 0x20, 0x69, 0x6f, 0x2e, 0x70, 0x6f, 0x70, 0x65, 0x6e, 0x20, 0x3d, 0x20, 0x6c,
+    0x75, 0x61, 0x74, 0x65, 0x78, 0x5f, 0x69, 0x6f, 0x5f, 0x70, 0x6f, 0x70, 0x65, 0x6e, 0x0a, 0x0a,
+    0x65, 0x6e, 0x64, 0x0a, 0x0a, 0x69, 0x66, 0x20, 0x73, 0x61, 0x66, 0x65, 0x72, 0x6f, 0x70, 0x74,
+    0x69, 0x6f, 0x6e, 0x20, 0x3d, 0x3d, 0x20, 0x31, 0x20, 0x74, 0x68, 0x65, 0x6e, 0x0a, 0x0a, 0x20,
+    0x20, 0x20, 0x20, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f,
+    0x6e, 0x20, 0x69, 0x6e, 0x73, 0x74, 0x61, 0x6c, 0x6c, 0x64, 0x75, 0x6d, 0x6d, 0x79, 0x28, 0x73,
+    0x74, 0x72, 0x2c, 0x66, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x6c, 0x6f,
+    0x63, 0x61, 0x6c, 0x20, 0x72, 0x65, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x20, 0x3d, 0x20, 0x66,
+    0x61, 0x6c, 0x73, 0x65, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x72, 0x65, 0x74,
+    0x75, 0x72, 0x6e, 0x20, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x28, 0x2e, 0x2e, 0x2e,
+    0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x69, 0x66,
+    0x20, 0x6e, 0x6f, 0x74, 0x20, 0x72, 0x65, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x20, 0x74, 0x68,
+    0x65, 0x6e, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+    0x20, 0x20, 0x20, 0x77, 0x72, 0x69, 0x74, 0x65, 0x5f, 0x6e, 0x6c, 0x28, 0x66, 0x6f, 0x72, 0x6d,
+    0x61, 0x74, 0x28, 0x22, 0x73, 0x61, 0x66, 0x65, 0x72, 0x20, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e,
+    0x20, 0x73, 0x65, 0x74, 0x2c, 0x20, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x25,
+    0x71, 0x20, 0x69, 0x73, 0x20, 0x25, 0x73, 0x22, 0x2c, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x73, 0x74,
+    0x72, 0x2c, 0x66, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x22, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x65, 0x64,
+    0x22, 0x20, 0x6f, 0x72, 0x20, 0x22, 0x64, 0x69, 0x73, 0x61, 0x62, 0x6c, 0x65, 0x64, 0x22, 0x29,
+    0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+    0x20, 0x20, 0x72, 0x65, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x20, 0x3d, 0x20, 0x74, 0x72, 0x75,
+    0x65, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x65, 0x6e,
+    0x64, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x69, 0x66,
+    0x20, 0x66, 0x20, 0x74, 0x68, 0x65, 0x6e, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
     0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x20, 0x66,
-    0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x28, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20,
-    0x6c, 0x20, 0x3d, 0x20, 0x66, 0x69, 0x6f, 0x5f, 0x72, 0x65, 0x61, 0x64, 0x6c, 0x69, 0x6e, 0x65,
-    0x28, 0x66, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x69, 0x66, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x6c, 0x20, 0x74, 0x68, 0x65,
-    0x6e, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x66, 0x3a, 0x63, 0x6c, 0x6f, 0x73, 0x65, 0x28, 0x29, 0x0a,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x65, 0x6e, 0x64, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x20, 0x6c, 0x0a, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x65, 0x6e, 0x64, 0x0a, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x65, 0x6c, 0x73, 0x65, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x2d, 0x2d, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x74, 0x68, 0x6f,
-    0x73, 0x65, 0x20, 0x77, 0x68, 0x6f, 0x20, 0x6c, 0x69, 0x6b, 0x65, 0x20, 0x69, 0x74, 0x20, 0x74,
-    0x68, 0x69, 0x73, 0x20, 0x77, 0x61, 0x79, 0x3a, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x65, 0x72, 0x72, 0x6f, 0x72, 0x28, 0x22, 0x70, 0x61, 0x74, 0x63,
-    0x68, 0x65, 0x64, 0x20, 0x27, 0x69, 0x6f, 0x2e, 0x6c, 0x69, 0x6e, 0x65, 0x73, 0x27, 0x20, 0x63,
-    0x61, 0x6e, 0x27, 0x74, 0x20, 0x6f, 0x70, 0x65, 0x6e, 0x20, 0x27, 0x22, 0x20, 0x2e, 0x2e, 0x20,
-    0x6e, 0x61, 0x6d, 0x65, 0x20, 0x2e, 0x2e, 0x20, 0x22, 0x27, 0x22, 0x29, 0x0a, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x65, 0x6e, 0x64, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x65, 0x6c, 0x73,
-    0x65, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e,
-    0x20, 0x69, 0x6f, 0x5f, 0x6c, 0x69, 0x6e, 0x65, 0x73, 0x28, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20,
-    0x65, 0x6e, 0x64, 0x0a, 0x65, 0x6e, 0x64, 0x0a, 0x0a, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x66,
-    0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x6c, 0x75, 0x61, 0x74, 0x65, 0x78, 0x5f, 0x69,
-    0x6f, 0x5f, 0x72, 0x65, 0x61, 0x64, 0x6c, 0x69, 0x6e, 0x65, 0x28, 0x66, 0x29, 0x0a, 0x20, 0x20,
-    0x20, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x20, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f,
-    0x6e, 0x28, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x72, 0x65, 0x74, 0x75,
-    0x72, 0x6e, 0x20, 0x66, 0x69, 0x6f, 0x5f, 0x72, 0x65, 0x61, 0x64, 0x6c, 0x69, 0x6e, 0x65, 0x28,
-    0x66, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x65, 0x6e, 0x64, 0x0a, 0x65, 0x6e, 0x64, 0x0a, 0x0a,
-    0x69, 0x6f, 0x2e, 0x6c, 0x69, 0x6e, 0x65, 0x73, 0x20, 0x3d, 0x20, 0x6c, 0x75, 0x61, 0x74, 0x65,
-    0x78, 0x5f, 0x69, 0x6f, 0x5f, 0x6c, 0x69, 0x6e, 0x65, 0x73, 0x0a, 0x6d, 0x74, 0x2e, 0x6c, 0x69,
-    0x6e, 0x65, 0x73, 0x20, 0x3d, 0x20, 0x6c, 0x75, 0x61, 0x74, 0x65, 0x78, 0x5f, 0x69, 0x6f, 0x5f,
-    0x72, 0x65, 0x61, 0x64, 0x6c, 0x69, 0x6e, 0x65, 0x0a, 0x0a, 0x2d, 0x2d, 0x20, 0x57, 0x65, 0x20,
-    0x61, 0x73, 0x73, 0x75, 0x6d, 0x65, 0x20, 0x6d, 0x61, 0x6e, 0x61, 0x67, 0x65, 0x6d, 0x65, 0x6e,
-    0x74, 0x20, 0x74, 0x6f, 0x20, 0x62, 0x65, 0x20, 0x70, 0x72, 0x6f, 0x76, 0x69, 0x64, 0x65, 0x64,
-    0x20, 0x62, 0x79, 0x20, 0x74, 0x68, 0x65, 0x20, 0x72, 0x65, 0x70, 0x6c, 0x61, 0x63, 0x65, 0x6d,
-    0x65, 0x6e, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x6b, 0x70, 0x73, 0x65, 0x2e, 0x20, 0x54, 0x68, 0x69,
-    0x73, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68, 0x65, 0x0a, 0x2d, 0x2d, 0x20, 0x63, 0x61, 0x73, 0x65,
-    0x20, 0x69, 0x6e, 0x20, 0x43, 0x6f, 0x6e, 0x54, 0x65, 0x58, 0x74, 0x2e, 0x0a, 0x0a, 0x69, 0x66,
-    0x20, 0x6b, 0x70, 0x73, 0x65, 0x75, 0x73, 0x65, 0x64, 0x20, 0x3d, 0x3d, 0x20, 0x31, 0x20, 0x74,
-    0x68, 0x65, 0x6e, 0x0a, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x69, 0x6f, 0x2e, 0x6f, 0x70, 0x65, 0x6e,
-    0x20, 0x20, 0x3d, 0x20, 0x6c, 0x75, 0x61, 0x74, 0x65, 0x78, 0x5f, 0x69, 0x6f, 0x5f, 0x6f, 0x70,
-    0x65, 0x6e, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x69, 0x6f, 0x2e, 0x70, 0x6f, 0x70, 0x65, 0x6e, 0x20,
-    0x3d, 0x20, 0x6c, 0x75, 0x61, 0x74, 0x65, 0x78, 0x5f, 0x69, 0x6f, 0x5f, 0x70, 0x6f, 0x70, 0x65,
-    0x6e, 0x0a, 0x0a, 0x65, 0x6e, 0x64, 0x0a, 0x0a, 0x69, 0x66, 0x20, 0x73, 0x61, 0x66, 0x65, 0x72,
-    0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x3d, 0x3d, 0x20, 0x31, 0x20, 0x74, 0x68, 0x65, 0x6e,
-    0x0a, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x66, 0x75, 0x6e, 0x63,
-    0x74, 0x69, 0x6f, 0x6e, 0x20, 0x69, 0x6e, 0x73, 0x74, 0x61, 0x6c, 0x6c, 0x64, 0x75, 0x6d, 0x6d,
-    0x79, 0x28, 0x73, 0x74, 0x72, 0x2c, 0x66, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x72, 0x65, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x20,
-    0x3d, 0x20, 0x66, 0x61, 0x6c, 0x73, 0x65, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x20, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x28,
-    0x2e, 0x2e, 0x2e, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x69, 0x66, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x72, 0x65, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64,
-    0x20, 0x74, 0x68, 0x65, 0x6e, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x77, 0x72, 0x69, 0x74, 0x65, 0x5f, 0x6e, 0x6c, 0x28, 0x66,
-    0x6f, 0x72, 0x6d, 0x61, 0x74, 0x28, 0x22, 0x73, 0x61, 0x66, 0x65, 0x72, 0x20, 0x6f, 0x70, 0x74,
-    0x69, 0x6f, 0x6e, 0x20, 0x73, 0x65, 0x74, 0x2c, 0x20, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f,
-    0x6e, 0x20, 0x25, 0x71, 0x20, 0x69, 0x73, 0x20, 0x25, 0x73, 0x22, 0x2c, 0x0a, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x73, 0x74, 0x72, 0x2c, 0x66, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x22, 0x6c, 0x69, 0x6d, 0x69,
-    0x74, 0x65, 0x64, 0x22, 0x20, 0x6f, 0x72, 0x20, 0x22, 0x64, 0x69, 0x73, 0x61, 0x62, 0x6c, 0x65,
-    0x64, 0x22, 0x29, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x72, 0x65, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x20, 0x3d, 0x20,
-    0x74, 0x72, 0x75, 0x65, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x65, 0x6e, 0x64, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x69, 0x66, 0x20, 0x66, 0x20, 0x74, 0x68, 0x65, 0x6e, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72,
-    0x6e, 0x20, 0x66, 0x28, 0x2e, 0x2e, 0x2e, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x65, 0x6e, 0x64, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x65, 0x6e, 0x64, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x65, 0x6e, 0x64, 0x0a, 0x0a, 0x20, 0x20,
-    0x20, 0x20, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e,
-    0x20, 0x69, 0x6e, 0x73, 0x74, 0x61, 0x6c, 0x6c, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x28, 0x73, 0x74,
-    0x72, 0x2c, 0x66, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x6c, 0x6f, 0x63,
-    0x61, 0x6c, 0x20, 0x72, 0x65, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x20, 0x3d, 0x20, 0x66, 0x61,
-    0x6c, 0x73, 0x65, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x65, 0x6e, 0x64, 0x0a, 0x0a, 0x20, 0x20, 0x20,
-    0x20, 0x6f, 0x73, 0x2e, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x65, 0x20, 0x3d, 0x20, 0x69, 0x6e,
-    0x73, 0x74, 0x61, 0x6c, 0x6c, 0x64, 0x75, 0x6d, 0x6d, 0x79, 0x28, 0x22, 0x6f, 0x73, 0x2e, 0x65,
-    0x78, 0x65, 0x63, 0x75, 0x74, 0x65, 0x22, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x6f, 0x73, 0x2e,
-    0x73, 0x70, 0x61, 0x77, 0x6e, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x69, 0x6e, 0x73, 0x74, 0x61, 0x6c,
-    0x6c, 0x64, 0x75, 0x6d, 0x6d, 0x79, 0x28, 0x22, 0x6f, 0x73, 0x2e, 0x73, 0x70, 0x61, 0x77, 0x6e,
-    0x22, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x6f, 0x73, 0x2e, 0x65, 0x78, 0x65, 0x63, 0x20, 0x20,
-    0x20, 0x20, 0x3d, 0x20, 0x69, 0x6e, 0x73, 0x74, 0x61, 0x6c, 0x6c, 0x64, 0x75, 0x6d, 0x6d, 0x79,
-    0x28, 0x22, 0x6f, 0x73, 0x2e, 0x65, 0x78, 0x65, 0x63, 0x22, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20,
-    0x6f, 0x73, 0x2e, 0x73, 0x65, 0x74, 0x65, 0x6e, 0x76, 0x20, 0x20, 0x3d, 0x20, 0x69, 0x6e, 0x73,
-    0x74, 0x61, 0x6c, 0x6c, 0x64, 0x75, 0x6d, 0x6d, 0x79, 0x28, 0x22, 0x6f, 0x73, 0x2e, 0x73, 0x65,
-    0x74, 0x65, 0x6e, 0x76, 0x22, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x6f, 0x73, 0x2e, 0x74, 0x65,
-    0x6d, 0x70, 0x64, 0x69, 0x72, 0x20, 0x3d, 0x20, 0x69, 0x6e, 0x73, 0x74, 0x61, 0x6c, 0x6c, 0x64,
-    0x75, 0x6d, 0x6d, 0x79, 0x28, 0x22, 0x6f, 0x73, 0x2e, 0x74, 0x65, 0x6d, 0x70, 0x64, 0x69, 0x72,
-    0x22, 0x29, 0x0a, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x69, 0x6f, 0x2e, 0x70, 0x6f, 0x70, 0x65, 0x6e,
-    0x20, 0x20, 0x20, 0x3d, 0x20, 0x69, 0x6e, 0x73, 0x74, 0x61, 0x6c, 0x6c, 0x64, 0x75, 0x6d, 0x6d,
-    0x79, 0x28, 0x22, 0x69, 0x6f, 0x2e, 0x70, 0x6f, 0x70, 0x65, 0x6e, 0x22, 0x29, 0x0a, 0x20, 0x20,
-    0x20, 0x20, 0x69, 0x6f, 0x2e, 0x6f, 0x70, 0x65, 0x6e, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x69,
-    0x6e, 0x73, 0x74, 0x61, 0x6c, 0x6c, 0x64, 0x75, 0x6d, 0x6d, 0x79, 0x28, 0x22, 0x69, 0x6f, 0x2e,
-    0x6f, 0x70, 0x65, 0x6e, 0x22, 0x2c, 0x6c, 0x75, 0x61, 0x74, 0x65, 0x78, 0x5f, 0x69, 0x6f, 0x5f,
-    0x6f, 0x70, 0x65, 0x6e, 0x5f, 0x72, 0x65, 0x61, 0x64, 0x6f, 0x6e, 0x6c, 0x79, 0x29, 0x0a, 0x0a,
-    0x20, 0x20, 0x20, 0x20, 0x6f, 0x73, 0x2e, 0x72, 0x65, 0x6e, 0x61, 0x6d, 0x65, 0x20, 0x20, 0x3d,
+    0x28, 0x2e, 0x2e, 0x2e, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+    0x20, 0x20, 0x65, 0x6e, 0x64, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x65, 0x6e,
+    0x64, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x65, 0x6e, 0x64, 0x0a, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x6c,
+    0x6f, 0x63, 0x61, 0x6c, 0x20, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x69, 0x6e,
+    0x73, 0x74, 0x61, 0x6c, 0x6c, 0x6c, 0x69, 0x6d, 0x69, 0x74, 0x28, 0x73, 0x74, 0x72, 0x2c, 0x66,
+    0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20,
+    0x72, 0x65, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64, 0x20, 0x3d, 0x20, 0x66, 0x61, 0x6c, 0x73, 0x65,
+    0x0a, 0x20, 0x20, 0x20, 0x20, 0x65, 0x6e, 0x64, 0x0a, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x6f, 0x73,
+    0x2e, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x65, 0x20, 0x3d, 0x20, 0x69, 0x6e, 0x73, 0x74, 0x61,
+    0x6c, 0x6c, 0x64, 0x75, 0x6d, 0x6d, 0x79, 0x28, 0x22, 0x6f, 0x73, 0x2e, 0x65, 0x78, 0x65, 0x63,
+    0x75, 0x74, 0x65, 0x22, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x6f, 0x73, 0x2e, 0x73, 0x70, 0x61,
+    0x77, 0x6e, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x69, 0x6e, 0x73, 0x74, 0x61, 0x6c, 0x6c, 0x64, 0x75,
+    0x6d, 0x6d, 0x79, 0x28, 0x22, 0x6f, 0x73, 0x2e, 0x73, 0x70, 0x61, 0x77, 0x6e, 0x22, 0x29, 0x0a,
+    0x20, 0x20, 0x20, 0x20, 0x6f, 0x73, 0x2e, 0x65, 0x78, 0x65, 0x63, 0x20, 0x20, 0x20, 0x20, 0x3d,
     0x20, 0x69, 0x6e, 0x73, 0x74, 0x61, 0x6c, 0x6c, 0x64, 0x75, 0x6d, 0x6d, 0x79, 0x28, 0x22, 0x6f,
-    0x73, 0x2e, 0x72, 0x65, 0x6e, 0x61, 0x6d, 0x65, 0x22, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x6f,
-    0x73, 0x2e, 0x72, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x20, 0x20, 0x3d, 0x20, 0x69, 0x6e, 0x73, 0x74,
-    0x61, 0x6c, 0x6c, 0x64, 0x75, 0x6d, 0x6d, 0x79, 0x28, 0x22, 0x6f, 0x73, 0x2e, 0x72, 0x65, 0x6d,
-    0x6f, 0x76, 0x65, 0x22, 0x29, 0x0a, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x69, 0x6f, 0x2e, 0x74, 0x6d,
-    0x70, 0x66, 0x69, 0x6c, 0x65, 0x20, 0x3d, 0x20, 0x69, 0x6e, 0x73, 0x74, 0x61, 0x6c, 0x6c, 0x64,
-    0x75, 0x6d, 0x6d, 0x79, 0x28, 0x22, 0x69, 0x6f, 0x2e, 0x74, 0x6d, 0x70, 0x66, 0x69, 0x6c, 0x65,
-    0x22, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x69, 0x6f, 0x2e, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74,
-    0x20, 0x20, 0x3d, 0x20, 0x69, 0x6e, 0x73, 0x74, 0x61, 0x6c, 0x6c, 0x64, 0x75, 0x6d, 0x6d, 0x79,
-    0x28, 0x22, 0x69, 0x6f, 0x2e, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x22, 0x29, 0x0a, 0x0a, 0x20,
-    0x20, 0x20, 0x20, 0x6c, 0x66, 0x73, 0x2e, 0x63, 0x68, 0x64, 0x69, 0x72, 0x20, 0x20, 0x3d, 0x20,
-    0x69, 0x6e, 0x73, 0x74, 0x61, 0x6c, 0x6c, 0x64, 0x75, 0x6d, 0x6d, 0x79, 0x28, 0x22, 0x6c, 0x66,
-    0x73, 0x2e, 0x63, 0x68, 0x64, 0x69, 0x72, 0x22, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x6c, 0x66,
-    0x73, 0x2e, 0x6c, 0x6f, 0x63, 0x6b, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x69, 0x6e, 0x73, 0x74, 0x61,
-    0x6c, 0x6c, 0x64, 0x75, 0x6d, 0x6d, 0x79, 0x28, 0x22, 0x6c, 0x66, 0x73, 0x2e, 0x6c, 0x6f, 0x63,
-    0x6b, 0x22, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x6c, 0x66, 0x73, 0x2e, 0x74, 0x6f, 0x75, 0x63,
-    0x68, 0x20, 0x20, 0x3d, 0x20, 0x69, 0x6e, 0x73, 0x74, 0x61, 0x6c, 0x6c, 0x64, 0x75, 0x6d, 0x6d,
-    0x79, 0x28, 0x22, 0x6c, 0x66, 0x73, 0x2e, 0x74, 0x6f, 0x75, 0x63, 0x68, 0x22, 0x29, 0x0a, 0x20,
-    0x20, 0x20, 0x20, 0x6c, 0x66, 0x73, 0x2e, 0x72, 0x6d, 0x64, 0x69, 0x72, 0x20, 0x20, 0x3d, 0x20,
-    0x69, 0x6e, 0x73, 0x74, 0x61, 0x6c, 0x6c, 0x64, 0x75, 0x6d, 0x6d, 0x79, 0x28, 0x22, 0x6c, 0x66,
-    0x73, 0x2e, 0x72, 0x6d, 0x64, 0x69, 0x72, 0x22, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x6c, 0x66,
-    0x73, 0x2e, 0x6d, 0x6b, 0x64, 0x69, 0x72, 0x20, 0x20, 0x3d, 0x20, 0x69, 0x6e, 0x73, 0x74, 0x61,
-    0x6c, 0x6c, 0x64, 0x75, 0x6d, 0x6d, 0x79, 0x28, 0x22, 0x6c, 0x66, 0x73, 0x2e, 0x6d, 0x6b, 0x64,
-    0x69, 0x72, 0x22, 0x29, 0x0a, 0x0a, 0x65, 0x6e, 0x64, 0x0a, 0x0a, 0x69, 0x66, 0x20, 0x73, 0x61,
-    0x66, 0x65, 0x72, 0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x3d, 0x3d, 0x20, 0x31, 0x20, 0x6f,
-    0x72, 0x20, 0x73, 0x68, 0x65, 0x6c, 0x6c, 0x65, 0x73, 0x63, 0x61, 0x70, 0x65, 0x20, 0x7e, 0x3d,
-    0x20, 0x31, 0x20, 0x74, 0x68, 0x65, 0x6e, 0x0a, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x66, 0x66, 0x69,
-    0x20, 0x3d, 0x20, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x28, 0x27, 0x66, 0x66, 0x69, 0x27,
-    0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x6b, 0x2c, 0x20, 0x76, 0x20, 0x69,
-    0x6e, 0x20, 0x6e, 0x65, 0x78, 0x74, 0x2c, 0x20, 0x66, 0x66, 0x69, 0x20, 0x64, 0x6f, 0x0a, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x69, 0x66, 0x20, 0x6b, 0x20, 0x7e, 0x3d, 0x20, 0x27,
-    0x67, 0x63, 0x27, 0x20, 0x74, 0x68, 0x65, 0x6e, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x66, 0x66, 0x69, 0x5b, 0x6b, 0x5d, 0x20, 0x3d, 0x20, 0x6e, 0x69,
-    0x6c, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x65, 0x6e, 0x64, 0x0a, 0x20, 0x20,
-    0x20, 0x20, 0x65, 0x6e, 0x64, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x66, 0x66, 0x69, 0x20, 0x3d, 0x20,
-    0x6e, 0x69, 0x6c, 0x0a, 0x0a, 0x65, 0x6e, 0x64, 0x0a, 0x0a, 0x2d, 0x2d, 0x20, 0x6f, 0x73, 0x2e,
-    0x5b, 0x65, 0x78, 0x65, 0x63, 0x75, 0x74, 0x65, 0x7c, 0x6f, 0x73, 0x2e, 0x73, 0x70, 0x61, 0x77,
-    0x6e, 0x7c, 0x6f, 0x73, 0x2e, 0x65, 0x78, 0x65, 0x63, 0x5d, 0x20, 0x61, 0x6c, 0x72, 0x65, 0x61,
-    0x64, 0x79, 0x20, 0x61, 0x72, 0x65, 0x20, 0x73, 0x68, 0x65, 0x6c, 0x6c, 0x65, 0x73, 0x63, 0x61,
-    0x70, 0x65, 0x20, 0x61, 0x77, 0x61, 0x72, 0x65, 0x29, 0x0a, 0x0a, 0x0a, 0x69, 0x66, 0x20, 0x6d,
-    0x64, 0x35, 0x20, 0x74, 0x68, 0x65, 0x6e, 0x0a, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x6c, 0x6f, 0x63,
-    0x61, 0x6c, 0x20, 0x73, 0x75, 0x6d, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x6d, 0x64, 0x35, 0x2e,
-    0x73, 0x75, 0x6d, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x67, 0x73,
-    0x75, 0x62, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x2e, 0x67, 0x73,
-    0x75, 0x62, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x66, 0x6f, 0x72,
-    0x6d, 0x61, 0x74, 0x20, 0x3d, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x2e, 0x66, 0x6f, 0x72,
-    0x6d, 0x61, 0x74, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x62, 0x79,
-    0x74, 0x65, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x2e, 0x62, 0x79,
-    0x74, 0x65, 0x0a, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x69, 0x66, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x6d,
-    0x64, 0x35, 0x2e, 0x73, 0x75, 0x6d, 0x68, 0x65, 0x78, 0x61, 0x20, 0x74, 0x68, 0x65, 0x6e, 0x0a,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e,
-    0x20, 0x6d, 0x64, 0x35, 0x2e, 0x73, 0x75, 0x6d, 0x68, 0x65, 0x78, 0x61, 0x28, 0x6b, 0x29, 0x0a,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x72, 0x65, 0x74, 0x75,
-    0x72, 0x6e, 0x20, 0x28, 0x67, 0x73, 0x75, 0x62, 0x28, 0x73, 0x75, 0x6d, 0x28, 0x6b, 0x29, 0x2c,
-    0x20, 0x22, 0x2e, 0x22, 0x2c, 0x20, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x28, 0x63,
-    0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+    0x73, 0x2e, 0x65, 0x78, 0x65, 0x63, 0x22, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x6f, 0x73, 0x2e,
+    0x73, 0x65, 0x74, 0x65, 0x6e, 0x76, 0x20, 0x20, 0x3d, 0x20, 0x69, 0x6e, 0x73, 0x74, 0x61, 0x6c,
+    0x6c, 0x64, 0x75, 0x6d, 0x6d, 0x79, 0x28, 0x22, 0x6f, 0x73, 0x2e, 0x73, 0x65, 0x74, 0x65, 0x6e,
+    0x76, 0x22, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x6f, 0x73, 0x2e, 0x74, 0x65, 0x6d, 0x70, 0x64,
+    0x69, 0x72, 0x20, 0x3d, 0x20, 0x69, 0x6e, 0x73, 0x74, 0x61, 0x6c, 0x6c, 0x64, 0x75, 0x6d, 0x6d,
+    0x79, 0x28, 0x22, 0x6f, 0x73, 0x2e, 0x74, 0x65, 0x6d, 0x70, 0x64, 0x69, 0x72, 0x22, 0x29, 0x0a,
+    0x0a, 0x20, 0x20, 0x20, 0x20, 0x69, 0x6f, 0x2e, 0x70, 0x6f, 0x70, 0x65, 0x6e, 0x20, 0x20, 0x20,
+    0x3d, 0x20, 0x69, 0x6e, 0x73, 0x74, 0x61, 0x6c, 0x6c, 0x64, 0x75, 0x6d, 0x6d, 0x79, 0x28, 0x22,
+    0x69, 0x6f, 0x2e, 0x70, 0x6f, 0x70, 0x65, 0x6e, 0x22, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x69,
+    0x6f, 0x2e, 0x6f, 0x70, 0x65, 0x6e, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x69, 0x6e, 0x73, 0x74,
+    0x61, 0x6c, 0x6c, 0x64, 0x75, 0x6d, 0x6d, 0x79, 0x28, 0x22, 0x69, 0x6f, 0x2e, 0x6f, 0x70, 0x65,
+    0x6e, 0x22, 0x2c, 0x6c, 0x75, 0x61, 0x74, 0x65, 0x78, 0x5f, 0x69, 0x6f, 0x5f, 0x6f, 0x70, 0x65,
+    0x6e, 0x5f, 0x72, 0x65, 0x61, 0x64, 0x6f, 0x6e, 0x6c, 0x79, 0x29, 0x0a, 0x0a, 0x20, 0x20, 0x20,
+    0x20, 0x6f, 0x73, 0x2e, 0x72, 0x65, 0x6e, 0x61, 0x6d, 0x65, 0x20, 0x20, 0x3d, 0x20, 0x69, 0x6e,
+    0x73, 0x74, 0x61, 0x6c, 0x6c, 0x64, 0x75, 0x6d, 0x6d, 0x79, 0x28, 0x22, 0x6f, 0x73, 0x2e, 0x72,
+    0x65, 0x6e, 0x61, 0x6d, 0x65, 0x22, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x6f, 0x73, 0x2e, 0x72,
+    0x65, 0x6d, 0x6f, 0x76, 0x65, 0x20, 0x20, 0x3d, 0x20, 0x69, 0x6e, 0x73, 0x74, 0x61, 0x6c, 0x6c,
+    0x64, 0x75, 0x6d, 0x6d, 0x79, 0x28, 0x22, 0x6f, 0x73, 0x2e, 0x72, 0x65, 0x6d, 0x6f, 0x76, 0x65,
+    0x22, 0x29, 0x0a, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x69, 0x6f, 0x2e, 0x74, 0x6d, 0x70, 0x66, 0x69,
+    0x6c, 0x65, 0x20, 0x3d, 0x20, 0x69, 0x6e, 0x73, 0x74, 0x61, 0x6c, 0x6c, 0x64, 0x75, 0x6d, 0x6d,
+    0x79, 0x28, 0x22, 0x69, 0x6f, 0x2e, 0x74, 0x6d, 0x70, 0x66, 0x69, 0x6c, 0x65, 0x22, 0x29, 0x0a,
+    0x20, 0x20, 0x20, 0x20, 0x69, 0x6f, 0x2e, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x20, 0x20, 0x3d,
+    0x20, 0x69, 0x6e, 0x73, 0x74, 0x61, 0x6c, 0x6c, 0x64, 0x75, 0x6d, 0x6d, 0x79, 0x28, 0x22, 0x69,
+    0x6f, 0x2e, 0x6f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x22, 0x29, 0x0a, 0x0a, 0x20, 0x20, 0x20, 0x20,
+    0x6c, 0x66, 0x73, 0x2e, 0x63, 0x68, 0x64, 0x69, 0x72, 0x20, 0x20, 0x3d, 0x20, 0x69, 0x6e, 0x73,
+    0x74, 0x61, 0x6c, 0x6c, 0x64, 0x75, 0x6d, 0x6d, 0x79, 0x28, 0x22, 0x6c, 0x66, 0x73, 0x2e, 0x63,
+    0x68, 0x64, 0x69, 0x72, 0x22, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x6c, 0x66, 0x73, 0x2e, 0x6c,
+    0x6f, 0x63, 0x6b, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x69, 0x6e, 0x73, 0x74, 0x61, 0x6c, 0x6c, 0x64,
+    0x75, 0x6d, 0x6d, 0x79, 0x28, 0x22, 0x6c, 0x66, 0x73, 0x2e, 0x6c, 0x6f, 0x63, 0x6b, 0x22, 0x29,
+    0x0a, 0x20, 0x20, 0x20, 0x20, 0x6c, 0x66, 0x73, 0x2e, 0x74, 0x6f, 0x75, 0x63, 0x68, 0x20, 0x20,
+    0x3d, 0x20, 0x69, 0x6e, 0x73, 0x74, 0x61, 0x6c, 0x6c, 0x64, 0x75, 0x6d, 0x6d, 0x79, 0x28, 0x22,
+    0x6c, 0x66, 0x73, 0x2e, 0x74, 0x6f, 0x75, 0x63, 0x68, 0x22, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20,
+    0x6c, 0x66, 0x73, 0x2e, 0x72, 0x6d, 0x64, 0x69, 0x72, 0x20, 0x20, 0x3d, 0x20, 0x69, 0x6e, 0x73,
+    0x74, 0x61, 0x6c, 0x6c, 0x64, 0x75, 0x6d, 0x6d, 0x79, 0x28, 0x22, 0x6c, 0x66, 0x73, 0x2e, 0x72,
+    0x6d, 0x64, 0x69, 0x72, 0x22, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x6c, 0x66, 0x73, 0x2e, 0x6d,
+    0x6b, 0x64, 0x69, 0x72, 0x20, 0x20, 0x3d, 0x20, 0x69, 0x6e, 0x73, 0x74, 0x61, 0x6c, 0x6c, 0x64,
+    0x75, 0x6d, 0x6d, 0x79, 0x28, 0x22, 0x6c, 0x66, 0x73, 0x2e, 0x6d, 0x6b, 0x64, 0x69, 0x72, 0x22,
+    0x29, 0x0a, 0x0a, 0x65, 0x6e, 0x64, 0x0a, 0x0a, 0x69, 0x66, 0x20, 0x73, 0x61, 0x66, 0x65, 0x72,
+    0x6f, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x3d, 0x3d, 0x20, 0x31, 0x20, 0x6f, 0x72, 0x20, 0x73,
+    0x68, 0x65, 0x6c, 0x6c, 0x65, 0x73, 0x63, 0x61, 0x70, 0x65, 0x20, 0x7e, 0x3d, 0x20, 0x31, 0x20,
+    0x74, 0x68, 0x65, 0x6e, 0x0a, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x66, 0x66, 0x69, 0x20, 0x3d, 0x20,
+    0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x28, 0x27, 0x66, 0x66, 0x69, 0x27, 0x29, 0x0a, 0x20,
+    0x20, 0x20, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x6b, 0x2c, 0x20, 0x76, 0x20, 0x69, 0x6e, 0x20, 0x6e,
+    0x65, 0x78, 0x74, 0x2c, 0x20, 0x66, 0x66, 0x69, 0x20, 0x64, 0x6f, 0x0a, 0x20, 0x20, 0x20, 0x20,
+    0x20, 0x20, 0x20, 0x20, 0x69, 0x66, 0x20, 0x6b, 0x20, 0x7e, 0x3d, 0x20, 0x27, 0x67, 0x63, 0x27,
+    0x20, 0x74, 0x68, 0x65, 0x6e, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+    0x20, 0x20, 0x66, 0x66, 0x69, 0x5b, 0x6b, 0x5d, 0x20, 0x3d, 0x20, 0x6e, 0x69, 0x6c, 0x0a, 0x20,
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x65, 0x6e, 0x64, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x65,
+    0x6e, 0x64, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x66, 0x66, 0x69, 0x20, 0x3d, 0x20, 0x6e, 0x69, 0x6c,
+    0x0a, 0x0a, 0x65, 0x6e, 0x64, 0x0a, 0x0a, 0x2d, 0x2d, 0x20, 0x6f, 0x73, 0x2e, 0x5b, 0x65, 0x78,
+    0x65, 0x63, 0x75, 0x74, 0x65, 0x7c, 0x6f, 0x73, 0x2e, 0x73, 0x70, 0x61, 0x77, 0x6e, 0x7c, 0x6f,
+    0x73, 0x2e, 0x65, 0x78, 0x65, 0x63, 0x5d, 0x20, 0x61, 0x6c, 0x72, 0x65, 0x61, 0x64, 0x79, 0x20,
+    0x61, 0x72, 0x65, 0x20, 0x73, 0x68, 0x65, 0x6c, 0x6c, 0x65, 0x73, 0x63, 0x61, 0x70, 0x65, 0x20,
+    0x61, 0x77, 0x61, 0x72, 0x65, 0x29, 0x0a, 0x0a, 0x0a, 0x69, 0x66, 0x20, 0x6d, 0x64, 0x35, 0x20,
+    0x74, 0x68, 0x65, 0x6e, 0x0a, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20,
+    0x73, 0x75, 0x6d, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x6d, 0x64, 0x35, 0x2e, 0x73, 0x75, 0x6d,
+    0x0a, 0x20, 0x20, 0x20, 0x20, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x67, 0x73, 0x75, 0x62, 0x20,
+    0x20, 0x20, 0x3d, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x2e, 0x67, 0x73, 0x75, 0x62, 0x0a,
+    0x20, 0x20, 0x20, 0x20, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74,
+    0x20, 0x3d, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x2e, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74,
+    0x0a, 0x20, 0x20, 0x20, 0x20, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x62, 0x79, 0x74, 0x65, 0x20,
+    0x20, 0x20, 0x3d, 0x20, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x2e, 0x62, 0x79, 0x74, 0x65, 0x0a,
+    0x0a, 0x20, 0x20, 0x20, 0x20, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x6d, 0x64,
+    0x35, 0x2e, 0x73, 0x75, 0x6d, 0x68, 0x65, 0x78, 0x61, 0x28, 0x6b, 0x29, 0x0a, 0x20, 0x20, 0x20,
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x20, 0x28, 0x67, 0x73, 0x75,
+    0x62, 0x28, 0x73, 0x75, 0x6d, 0x28, 0x6b, 0x29, 0x2c, 0x20, 0x22, 0x2e, 0x22, 0x2c, 0x20, 0x66,
+    0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x28, 0x63, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20,
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x20, 0x66, 0x6f,
+    0x72, 0x6d, 0x61, 0x74, 0x28, 0x22, 0x25, 0x30, 0x32, 0x78, 0x22, 0x2c, 0x62, 0x79, 0x74, 0x65,
+    0x28, 0x63, 0x29, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x65, 0x6e, 0x64,
+    0x29, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x65, 0x6e, 0x64, 0x0a, 0x0a, 0x20, 0x20, 0x20, 0x20,
+    0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x6d, 0x64, 0x35, 0x2e, 0x73, 0x75, 0x6d,
+    0x48, 0x45, 0x58, 0x41, 0x28, 0x6b, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+    0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x20, 0x28, 0x67, 0x73, 0x75, 0x62, 0x28, 0x73, 0x75, 0x6d,
+    0x28, 0x6b, 0x29, 0x2c, 0x20, 0x22, 0x2e, 0x22, 0x2c, 0x20, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69,
+    0x6f, 0x6e, 0x28, 0x63, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
     0x20, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x20, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x28,
-    0x22, 0x25, 0x30, 0x32, 0x78, 0x22, 0x2c, 0x62, 0x79, 0x74, 0x65, 0x28, 0x63, 0x29, 0x29, 0x0a,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x65, 0x6e, 0x64, 0x29,
-    0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x65, 0x6e, 0x64, 0x0a, 0x20, 0x20,
-    0x20, 0x20, 0x65, 0x6e, 0x64, 0x0a, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x69, 0x66, 0x20, 0x6e, 0x6f,
-    0x74, 0x20, 0x6d, 0x64, 0x35, 0x2e, 0x73, 0x75, 0x6d, 0x48, 0x45, 0x58, 0x41, 0x20, 0x74, 0x68,
-    0x65, 0x6e, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x66, 0x75, 0x6e, 0x63, 0x74,
-    0x69, 0x6f, 0x6e, 0x20, 0x6d, 0x64, 0x35, 0x2e, 0x73, 0x75, 0x6d, 0x48, 0x45, 0x58, 0x41, 0x28,
-    0x6b, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x72,
-    0x65, 0x74, 0x75, 0x72, 0x6e, 0x20, 0x28, 0x67, 0x73, 0x75, 0x62, 0x28, 0x73, 0x75, 0x6d, 0x28,
-    0x6b, 0x29, 0x2c, 0x20, 0x22, 0x2e, 0x22, 0x2c, 0x20, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f,
-    0x6e, 0x28, 0x63, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x20, 0x66, 0x6f, 0x72, 0x6d,
-    0x61, 0x74, 0x28, 0x22, 0x25, 0x30, 0x32, 0x58, 0x22, 0x2c, 0x62, 0x79, 0x74, 0x65, 0x28, 0x63,
-    0x29, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x65,
-    0x6e, 0x64, 0x29, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x65, 0x6e, 0x64,
-    0x0a, 0x20, 0x20, 0x20, 0x20, 0x65, 0x6e, 0x64, 0x0a, 0x0a, 0x65, 0x6e, 0x64, 0x0a, 0x0a, 0x2d,
+    0x22, 0x25, 0x30, 0x32, 0x58, 0x22, 0x2c, 0x62, 0x79, 0x74, 0x65, 0x28, 0x63, 0x29, 0x29, 0x0a,
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x65, 0x6e, 0x64, 0x29, 0x29, 0x0a, 0x20, 0x20,
+    0x20, 0x20, 0x65, 0x6e, 0x64, 0x0a, 0x0a, 0x65, 0x6e, 0x64, 0x0a, 0x0a, 0x2d, 0x2d, 0x20, 0x63,
+    0x6f, 0x6d, 0x70, 0x61, 0x74, 0x69, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79, 0x3a, 0x20, 0x74, 0x68,
+    0x69, 0x73, 0x20, 0x6d, 0x69, 0x67, 0x68, 0x74, 0x20, 0x67, 0x6f, 0x20, 0x61, 0x77, 0x61, 0x79,
+    0x0a, 0x0a, 0x69, 0x66, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x75, 0x6e, 0x70, 0x61, 0x63, 0x6b, 0x20,
+    0x74, 0x68, 0x65, 0x6e, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x75, 0x6e, 0x70, 0x61, 0x63, 0x6b, 0x20,
+    0x3d, 0x20, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x2e, 0x75, 0x6e, 0x70, 0x61, 0x63, 0x6b, 0x0a, 0x65,
+    0x6e, 0x64, 0x0a, 0x0a, 0x69, 0x66, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x70, 0x61, 0x63, 0x6b, 0x61,
+    0x67, 0x65, 0x2e, 0x6c, 0x6f, 0x61, 0x64, 0x65, 0x72, 0x73, 0x20, 0x74, 0x68, 0x65, 0x6e, 0x0a,
+    0x20, 0x20, 0x20, 0x20, 0x70, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65, 0x2e, 0x6c, 0x6f, 0x61, 0x64,
+    0x65, 0x72, 0x73, 0x20, 0x3d, 0x20, 0x70, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65, 0x2e, 0x73, 0x65,
+    0x61, 0x72, 0x63, 0x68, 0x65, 0x72, 0x73, 0x0a, 0x65, 0x6e, 0x64, 0x0a, 0x0a, 0x69, 0x66, 0x20,
+    0x6e, 0x6f, 0x74, 0x20, 0x6c, 0x6f, 0x61, 0x64, 0x73, 0x74, 0x72, 0x69, 0x6e, 0x67, 0x20, 0x74,
+    0x68, 0x65, 0x6e, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x6c, 0x6f, 0x61, 0x64, 0x73, 0x74, 0x72, 0x69,
+    0x6e, 0x67, 0x20, 0x3d, 0x20, 0x6c, 0x6f, 0x61, 0x64, 0x0a, 0x65, 0x6e, 0x64, 0x0a, 0x0a, 0x2d,
     0x2d, 0x20, 0x63, 0x6f, 0x6d, 0x70, 0x61, 0x74, 0x69, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79, 0x3a,
-    0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x6d, 0x69, 0x67, 0x68, 0x74, 0x20, 0x67, 0x6f, 0x20, 0x61,
-    0x77, 0x61, 0x79, 0x0a, 0x0a, 0x69, 0x66, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x75, 0x6e, 0x70, 0x61,
-    0x63, 0x6b, 0x20, 0x74, 0x68, 0x65, 0x6e, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x75, 0x6e, 0x70, 0x61,
-    0x63, 0x6b, 0x20, 0x3d, 0x20, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x2e, 0x75, 0x6e, 0x70, 0x61, 0x63,
-    0x6b, 0x0a, 0x65, 0x6e, 0x64, 0x0a, 0x0a, 0x69, 0x66, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x70, 0x61,
-    0x63, 0x6b, 0x61, 0x67, 0x65, 0x2e, 0x6c, 0x6f, 0x61, 0x64, 0x65, 0x72, 0x73, 0x20, 0x74, 0x68,
-    0x65, 0x6e, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x70, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65, 0x2e, 0x6c,
-    0x6f, 0x61, 0x64, 0x65, 0x72, 0x73, 0x20, 0x3d, 0x20, 0x70, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65,
-    0x2e, 0x73, 0x65, 0x61, 0x72, 0x63, 0x68, 0x65, 0x72, 0x73, 0x0a, 0x65, 0x6e, 0x64, 0x0a, 0x0a,
-    0x69, 0x66, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x6c, 0x6f, 0x61, 0x64, 0x73, 0x74, 0x72, 0x69, 0x6e,
-    0x67, 0x20, 0x74, 0x68, 0x65, 0x6e, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x6c, 0x6f, 0x61, 0x64, 0x73,
-    0x74, 0x72, 0x69, 0x6e, 0x67, 0x20, 0x3d, 0x20, 0x6c, 0x6f, 0x61, 0x64, 0x0a, 0x65, 0x6e, 0x64,
-    0x0a, 0x0a, 0x2d, 0x2d, 0x20, 0x63, 0x6f, 0x6d, 0x70, 0x61, 0x74, 0x69, 0x62, 0x69, 0x6c, 0x69,
-    0x74, 0x79, 0x3a, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x6d, 0x69, 0x67, 0x68, 0x74, 0x20, 0x73,
-    0x74, 0x61, 0x79, 0x0a, 0x0a, 0x69, 0x66, 0x20, 0x62, 0x69, 0x74, 0x33, 0x32, 0x20, 0x74, 0x68,
-    0x65, 0x6e, 0x0a, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x2d, 0x2d, 0x20, 0x6c, 0x75, 0x61, 0x20, 0x35,
-    0x2e, 0x32, 0x3a, 0x20, 0x77, 0x65, 0x27, 0x72, 0x65, 0x20, 0x6f, 0x6b, 0x61, 0x79, 0x0a, 0x0a,
-    0x65, 0x6c, 0x73, 0x65, 0x69, 0x66, 0x20, 0x75, 0x74, 0x66, 0x38, 0x20, 0x74, 0x68, 0x65, 0x6e,
-    0x0a, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x2d, 0x2d, 0x20, 0x6c, 0x75, 0x61, 0x20, 0x35, 0x2e, 0x33,
-    0x3a, 0x20, 0x20, 0x62, 0x69, 0x74, 0x77, 0x69, 0x73, 0x65, 0x2e, 0x6c, 0x75, 0x61, 0x2c, 0x20,
-    0x76, 0x20, 0x31, 0x2e, 0x32, 0x34, 0x20, 0x32, 0x30, 0x31, 0x34, 0x2f, 0x31, 0x32, 0x2f, 0x32,
-    0x36, 0x20, 0x31, 0x37, 0x3a, 0x32, 0x30, 0x3a, 0x35, 0x33, 0x20, 0x72, 0x6f, 0x62, 0x65, 0x72,
-    0x74, 0x6f, 0x0a, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x62, 0x69, 0x74, 0x33, 0x32, 0x20, 0x3d, 0x20,
-    0x6c, 0x6f, 0x61, 0x64, 0x20, 0x28, 0x20, 0x5b, 0x5b, 0x0a, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20,
-    0x73, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x20, 0x3d, 0x20, 0x73, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x20,
-    0x2d, 0x2d, 0x20, 0x69, 0x6e, 0x73, 0x74, 0x65, 0x61, 0x64, 0x20, 0x6f, 0x66, 0x3a, 0x20, 0x61,
-    0x72, 0x67, 0x20, 0x3d, 0x20, 0x7b, 0x20, 0x2e, 0x2e, 0x2e, 0x20, 0x7d, 0x0a, 0x0a, 0x62, 0x69,
-    0x74, 0x33, 0x32, 0x20, 0x3d, 0x20, 0x7b, 0x0a, 0x20, 0x20, 0x62, 0x6e, 0x6f, 0x74, 0x20, 0x3d,
-    0x20, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x28, 0x61, 0x29, 0x0a, 0x20, 0x20,
-    0x20, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x20, 0x7e, 0x61, 0x20, 0x26, 0x20, 0x30, 0x78,
-    0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x0a, 0x20, 0x20, 0x65, 0x6e, 0x64, 0x2c, 0x0a,
-    0x20, 0x20, 0x62, 0x61, 0x6e, 0x64, 0x20, 0x3d, 0x20, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f,
+    0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x6d, 0x69, 0x67, 0x68, 0x74, 0x20, 0x73, 0x74, 0x61, 0x79,
+    0x0a, 0x0a, 0x69, 0x66, 0x20, 0x62, 0x69, 0x74, 0x33, 0x32, 0x20, 0x74, 0x68, 0x65, 0x6e, 0x0a,
+    0x0a, 0x20, 0x20, 0x20, 0x20, 0x2d, 0x2d, 0x20, 0x6c, 0x75, 0x61, 0x20, 0x35, 0x2e, 0x32, 0x3a,
+    0x20, 0x77, 0x65, 0x27, 0x72, 0x65, 0x20, 0x6f, 0x6b, 0x61, 0x79, 0x0a, 0x0a, 0x65, 0x6c, 0x73,
+    0x65, 0x69, 0x66, 0x20, 0x75, 0x74, 0x66, 0x38, 0x20, 0x74, 0x68, 0x65, 0x6e, 0x0a, 0x0a, 0x20,
+    0x20, 0x20, 0x20, 0x2d, 0x2d, 0x20, 0x6c, 0x75, 0x61, 0x20, 0x35, 0x2e, 0x33, 0x3a, 0x20, 0x20,
+    0x62, 0x69, 0x74, 0x77, 0x69, 0x73, 0x65, 0x2e, 0x6c, 0x75, 0x61, 0x2c, 0x20, 0x76, 0x20, 0x31,
+    0x2e, 0x32, 0x34, 0x20, 0x32, 0x30, 0x31, 0x34, 0x2f, 0x31, 0x32, 0x2f, 0x32, 0x36, 0x20, 0x31,
+    0x37, 0x3a, 0x32, 0x30, 0x3a, 0x35, 0x33, 0x20, 0x72, 0x6f, 0x62, 0x65, 0x72, 0x74, 0x6f, 0x0a,
+    0x0a, 0x20, 0x20, 0x20, 0x20, 0x62, 0x69, 0x74, 0x33, 0x32, 0x20, 0x3d, 0x20, 0x6c, 0x6f, 0x61,
+    0x64, 0x20, 0x28, 0x20, 0x5b, 0x5b, 0x0a, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x73, 0x65, 0x6c,
+    0x65, 0x63, 0x74, 0x20, 0x3d, 0x20, 0x73, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x20, 0x2d, 0x2d, 0x20,
+    0x69, 0x6e, 0x73, 0x74, 0x65, 0x61, 0x64, 0x20, 0x6f, 0x66, 0x3a, 0x20, 0x61, 0x72, 0x67, 0x20,
+    0x3d, 0x20, 0x7b, 0x20, 0x2e, 0x2e, 0x2e, 0x20, 0x7d, 0x0a, 0x0a, 0x62, 0x69, 0x74, 0x33, 0x32,
+    0x20, 0x3d, 0x20, 0x7b, 0x0a, 0x20, 0x20, 0x62, 0x6e, 0x6f, 0x74, 0x20, 0x3d, 0x20, 0x66, 0x75,
+    0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x28, 0x61, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x72,
+    0x65, 0x74, 0x75, 0x72, 0x6e, 0x20, 0x7e, 0x61, 0x20, 0x26, 0x20, 0x30, 0x78, 0x46, 0x46, 0x46,
+    0x46, 0x46, 0x46, 0x46, 0x46, 0x0a, 0x20, 0x20, 0x65, 0x6e, 0x64, 0x2c, 0x0a, 0x20, 0x20, 0x62,
+    0x61, 0x6e, 0x64, 0x20, 0x3d, 0x20, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x28,
+    0x78, 0x2c, 0x20, 0x79, 0x2c, 0x20, 0x7a, 0x2c, 0x20, 0x2e, 0x2e, 0x2e, 0x29, 0x0a, 0x20, 0x20,
+    0x20, 0x20, 0x69, 0x66, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x7a, 0x20, 0x74, 0x68, 0x65, 0x6e, 0x0a,
+    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x20, 0x28, 0x28, 0x78,
+    0x20, 0x6f, 0x72, 0x20, 0x2d, 0x31, 0x29, 0x20, 0x26, 0x20, 0x28, 0x79, 0x20, 0x6f, 0x72, 0x20,
+    0x2d, 0x31, 0x29, 0x29, 0x20, 0x26, 0x20, 0x30, 0x78, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46,
+    0x46, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x65, 0x6c, 0x73, 0x65, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20,
+    0x20, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x72, 0x65, 0x73, 0x20, 0x3d, 0x20, 0x78, 0x20, 0x26,
+    0x20, 0x79, 0x20, 0x26, 0x20, 0x7a, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x66, 0x6f, 0x72,
+    0x20, 0x69, 0x3d, 0x31, 0x2c, 0x73, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x28, 0x22, 0x23, 0x22, 0x2c,
+    0x2e, 0x2e, 0x2e, 0x29, 0x20, 0x64, 0x6f, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+    0x72, 0x65, 0x73, 0x20, 0x3d, 0x20, 0x72, 0x65, 0x73, 0x20, 0x26, 0x20, 0x73, 0x65, 0x6c, 0x65,
+    0x63, 0x74, 0x28, 0x69, 0x2c, 0x2e, 0x2e, 0x2e, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+    0x65, 0x6e, 0x64, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e,
+    0x20, 0x72, 0x65, 0x73, 0x20, 0x26, 0x20, 0x30, 0x78, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46,
+    0x46, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x65, 0x6e, 0x64, 0x0a, 0x20, 0x20, 0x65, 0x6e, 0x64, 0x2c,
+    0x0a, 0x20, 0x20, 0x62, 0x6f, 0x72, 0x20, 0x3d, 0x20, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f,
     0x6e, 0x20, 0x28, 0x78, 0x2c, 0x20, 0x79, 0x2c, 0x20, 0x7a, 0x2c, 0x20, 0x2e, 0x2e, 0x2e, 0x29,
     0x0a, 0x20, 0x20, 0x20, 0x20, 0x69, 0x66, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x7a, 0x20, 0x74, 0x68,
     0x65, 0x6e, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x20,
-    0x28, 0x28, 0x78, 0x20, 0x6f, 0x72, 0x20, 0x2d, 0x31, 0x29, 0x20, 0x26, 0x20, 0x28, 0x79, 0x20,
-    0x6f, 0x72, 0x20, 0x2d, 0x31, 0x29, 0x29, 0x20, 0x26, 0x20, 0x30, 0x78, 0x46, 0x46, 0x46, 0x46,
+    0x28, 0x28, 0x78, 0x20, 0x6f, 0x72, 0x20, 0x30, 0x29, 0x20, 0x7c, 0x20, 0x28, 0x79, 0x20, 0x6f,
+    0x72, 0x20, 0x30, 0x29, 0x29, 0x20, 0x26, 0x20, 0x30, 0x78, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46,
+    0x46, 0x46, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x65, 0x6c, 0x73, 0x65, 0x0a, 0x20, 0x20, 0x20, 0x20,
+    0x20, 0x20, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x72, 0x65, 0x73, 0x20, 0x3d, 0x20, 0x78, 0x20,
+    0x7c, 0x20, 0x79, 0x20, 0x7c, 0x20, 0x7a, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x66, 0x6f,
+    0x72, 0x20, 0x69, 0x3d, 0x31, 0x2c, 0x73, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x28, 0x22, 0x23, 0x22,
+    0x2c, 0x2e, 0x2e, 0x2e, 0x29, 0x20, 0x64, 0x6f, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+    0x20, 0x72, 0x65, 0x73, 0x20, 0x3d, 0x20, 0x72, 0x65, 0x73, 0x20, 0x7c, 0x20, 0x73, 0x65, 0x6c,
+    0x65, 0x63, 0x74, 0x28, 0x69, 0x2c, 0x2e, 0x2e, 0x2e, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20,
+    0x20, 0x65, 0x6e, 0x64, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72,
+    0x6e, 0x20, 0x72, 0x65, 0x73, 0x20, 0x26, 0x20, 0x30, 0x78, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46,
+    0x46, 0x46, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x65, 0x6e, 0x64, 0x0a, 0x20, 0x20, 0x65, 0x6e, 0x64,
+    0x2c, 0x0a, 0x20, 0x20, 0x62, 0x78, 0x6f, 0x72, 0x20, 0x3d, 0x20, 0x66, 0x75, 0x6e, 0x63, 0x74,
+    0x69, 0x6f, 0x6e, 0x20, 0x28, 0x78, 0x2c, 0x20, 0x79, 0x2c, 0x20, 0x7a, 0x2c, 0x20, 0x2e, 0x2e,
+    0x2e, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x69, 0x66, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x7a, 0x20,
+    0x74, 0x68, 0x65, 0x6e, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72,
+    0x6e, 0x20, 0x28, 0x28, 0x78, 0x20, 0x6f, 0x72, 0x20, 0x30, 0x29, 0x20, 0x7e, 0x20, 0x28, 0x79,
+    0x20, 0x6f, 0x72, 0x20, 0x30, 0x29, 0x29, 0x20, 0x26, 0x20, 0x30, 0x78, 0x46, 0x46, 0x46, 0x46,
     0x46, 0x46, 0x46, 0x46, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x65, 0x6c, 0x73, 0x65, 0x0a, 0x20, 0x20,
     0x20, 0x20, 0x20, 0x20, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x72, 0x65, 0x73, 0x20, 0x3d, 0x20,
-    0x78, 0x20, 0x26, 0x20, 0x79, 0x20, 0x26, 0x20, 0x7a, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+    0x78, 0x20, 0x7e, 0x20, 0x79, 0x20, 0x7e, 0x20, 0x7a, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
     0x66, 0x6f, 0x72, 0x20, 0x69, 0x3d, 0x31, 0x2c, 0x73, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x28, 0x22,
     0x23, 0x22, 0x2c, 0x2e, 0x2e, 0x2e, 0x29, 0x20, 0x64, 0x6f, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x72, 0x65, 0x73, 0x20, 0x3d, 0x20, 0x72, 0x65, 0x73, 0x20, 0x26, 0x20, 0x73,
+    0x20, 0x20, 0x20, 0x72, 0x65, 0x73, 0x20, 0x3d, 0x20, 0x72, 0x65, 0x73, 0x20, 0x7e, 0x20, 0x73,
     0x65, 0x6c, 0x65, 0x63, 0x74, 0x28, 0x69, 0x2c, 0x2e, 0x2e, 0x2e, 0x29, 0x0a, 0x20, 0x20, 0x20,
     0x20, 0x20, 0x20, 0x65, 0x6e, 0x64, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x72, 0x65, 0x74,
     0x75, 0x72, 0x6e, 0x20, 0x72, 0x65, 0x73, 0x20, 0x26, 0x20, 0x30, 0x78, 0x46, 0x46, 0x46, 0x46,
     0x46, 0x46, 0x46, 0x46, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x65, 0x6e, 0x64, 0x0a, 0x20, 0x20, 0x65,
-    0x6e, 0x64, 0x2c, 0x0a, 0x20, 0x20, 0x62, 0x6f, 0x72, 0x20, 0x3d, 0x20, 0x66, 0x75, 0x6e, 0x63,
-    0x74, 0x69, 0x6f, 0x6e, 0x20, 0x28, 0x78, 0x2c, 0x20, 0x79, 0x2c, 0x20, 0x7a, 0x2c, 0x20, 0x2e,
-    0x2e, 0x2e, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x69, 0x66, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x7a,
-    0x20, 0x74, 0x68, 0x65, 0x6e, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x72, 0x65, 0x74, 0x75,
-    0x72, 0x6e, 0x20, 0x28, 0x28, 0x78, 0x20, 0x6f, 0x72, 0x20, 0x30, 0x29, 0x20, 0x7c, 0x20, 0x28,
-    0x79, 0x20, 0x6f, 0x72, 0x20, 0x30, 0x29, 0x29, 0x20, 0x26, 0x20, 0x30, 0x78, 0x46, 0x46, 0x46,
-    0x46, 0x46, 0x46, 0x46, 0x46, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x65, 0x6c, 0x73, 0x65, 0x0a, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x72, 0x65, 0x73, 0x20, 0x3d,
-    0x20, 0x78, 0x20, 0x7c, 0x20, 0x79, 0x20, 0x7c, 0x20, 0x7a, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x66, 0x6f, 0x72, 0x20, 0x69, 0x3d, 0x31, 0x2c, 0x73, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x28,
-    0x22, 0x23, 0x22, 0x2c, 0x2e, 0x2e, 0x2e, 0x29, 0x20, 0x64, 0x6f, 0x0a, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x72, 0x65, 0x73, 0x20, 0x3d, 0x20, 0x72, 0x65, 0x73, 0x20, 0x7c, 0x20,
-    0x73, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x28, 0x69, 0x2c, 0x2e, 0x2e, 0x2e, 0x29, 0x0a, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x65, 0x6e, 0x64, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x72, 0x65,
-    0x74, 0x75, 0x72, 0x6e, 0x20, 0x72, 0x65, 0x73, 0x20, 0x26, 0x20, 0x30, 0x78, 0x46, 0x46, 0x46,
-    0x46, 0x46, 0x46, 0x46, 0x46, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x65, 0x6e, 0x64, 0x0a, 0x20, 0x20,
-    0x65, 0x6e, 0x64, 0x2c, 0x0a, 0x20, 0x20, 0x62, 0x78, 0x6f, 0x72, 0x20, 0x3d, 0x20, 0x66, 0x75,
+    0x6e, 0x64, 0x2c, 0x0a, 0x20, 0x20, 0x62, 0x74, 0x65, 0x73, 0x74, 0x20, 0x3d, 0x20, 0x66, 0x75,
     0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x28, 0x78, 0x2c, 0x20, 0x79, 0x2c, 0x20, 0x7a, 0x2c,
     0x20, 0x2e, 0x2e, 0x2e, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x69, 0x66, 0x20, 0x6e, 0x6f, 0x74,
     0x20, 0x7a, 0x20, 0x74, 0x68, 0x65, 0x6e, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x72, 0x65,
-    0x74, 0x75, 0x72, 0x6e, 0x20, 0x28, 0x28, 0x78, 0x20, 0x6f, 0x72, 0x20, 0x30, 0x29, 0x20, 0x7e,
-    0x20, 0x28, 0x79, 0x20, 0x6f, 0x72, 0x20, 0x30, 0x29, 0x29, 0x20, 0x26, 0x20, 0x30, 0x78, 0x46,
-    0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x65, 0x6c, 0x73, 0x65,
-    0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x72, 0x65, 0x73,
-    0x20, 0x3d, 0x20, 0x78, 0x20, 0x7e, 0x20, 0x79, 0x20, 0x7e, 0x20, 0x7a, 0x0a, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x69, 0x3d, 0x31, 0x2c, 0x73, 0x65, 0x6c, 0x65, 0x63,
-    0x74, 0x28, 0x22, 0x23, 0x22, 0x2c, 0x2e, 0x2e, 0x2e, 0x29, 0x20, 0x64, 0x6f, 0x0a, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x72, 0x65, 0x73, 0x20, 0x3d, 0x20, 0x72, 0x65, 0x73, 0x20,
-    0x7e, 0x20, 0x73, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x28, 0x69, 0x2c, 0x2e, 0x2e, 0x2e, 0x29, 0x0a,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x65, 0x6e, 0x64, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x20, 0x72, 0x65, 0x73, 0x20, 0x26, 0x20, 0x30, 0x78, 0x46,
-    0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x65, 0x6e, 0x64, 0x0a,
-    0x20, 0x20, 0x65, 0x6e, 0x64, 0x2c, 0x0a, 0x20, 0x20, 0x62, 0x74, 0x65, 0x73, 0x74, 0x20, 0x3d,
-    0x20, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x28, 0x78, 0x2c, 0x20, 0x79, 0x2c,
-    0x20, 0x7a, 0x2c, 0x20, 0x2e, 0x2e, 0x2e, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x69, 0x66, 0x20,
-    0x6e, 0x6f, 0x74, 0x20, 0x7a, 0x20, 0x74, 0x68, 0x65, 0x6e, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x20, 0x28, 0x28, 0x28, 0x78, 0x20, 0x6f, 0x72, 0x20,
-    0x2d, 0x31, 0x29, 0x20, 0x26, 0x20, 0x28, 0x79, 0x20, 0x6f, 0x72, 0x20, 0x2d, 0x31, 0x29, 0x29,
-    0x20, 0x26, 0x20, 0x30, 0x78, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x29, 0x20, 0x7e,
-    0x3d, 0x20, 0x30, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x65, 0x6c, 0x73, 0x65, 0x0a, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x72, 0x65, 0x73, 0x20, 0x3d, 0x20, 0x78,
-    0x20, 0x26, 0x20, 0x79, 0x20, 0x26, 0x20, 0x7a, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x66,
-    0x6f, 0x72, 0x20, 0x69, 0x3d, 0x31, 0x2c, 0x73, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x28, 0x22, 0x23,
-    0x22, 0x2c, 0x2e, 0x2e, 0x2e, 0x29, 0x20, 0x64, 0x6f, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x72, 0x65, 0x73, 0x20, 0x3d, 0x20, 0x72, 0x65, 0x73, 0x20, 0x26, 0x20,
-    0x73, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x28, 0x69, 0x2c, 0x2e, 0x2e, 0x2e, 0x29, 0x0a, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x65, 0x6e, 0x64, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x72, 0x65,
-    0x74, 0x75, 0x72, 0x6e, 0x20, 0x28, 0x72, 0x65, 0x73, 0x20, 0x26, 0x20, 0x30, 0x78, 0x46, 0x46,
-    0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x29, 0x20, 0x7e, 0x3d, 0x20, 0x30, 0x0a, 0x20, 0x20, 0x20,
-    0x20, 0x65, 0x6e, 0x64, 0x0a, 0x20, 0x20, 0x65, 0x6e, 0x64, 0x2c, 0x0a, 0x20, 0x20, 0x6c, 0x73,
-    0x68, 0x69, 0x66, 0x74, 0x20, 0x3d, 0x20, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20,
-    0x28, 0x61, 0x2c, 0x20, 0x62, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72,
-    0x6e, 0x20, 0x28, 0x28, 0x61, 0x20, 0x26, 0x20, 0x30, 0x78, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46,
-    0x46, 0x46, 0x29, 0x20, 0x3c, 0x3c, 0x20, 0x62, 0x29, 0x20, 0x26, 0x20, 0x30, 0x78, 0x46, 0x46,
-    0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x0a, 0x20, 0x20, 0x65, 0x6e, 0x64, 0x2c, 0x0a, 0x20, 0x20,
+    0x74, 0x75, 0x72, 0x6e, 0x20, 0x28, 0x28, 0x28, 0x78, 0x20, 0x6f, 0x72, 0x20, 0x2d, 0x31, 0x29,
+    0x20, 0x26, 0x20, 0x28, 0x79, 0x20, 0x6f, 0x72, 0x20, 0x2d, 0x31, 0x29, 0x29, 0x20, 0x26, 0x20,
+    0x30, 0x78, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x29, 0x20, 0x7e, 0x3d, 0x20, 0x30,
+    0x0a, 0x20, 0x20, 0x20, 0x20, 0x65, 0x6c, 0x73, 0x65, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+    0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x72, 0x65, 0x73, 0x20, 0x3d, 0x20, 0x78, 0x20, 0x26, 0x20,
+    0x79, 0x20, 0x26, 0x20, 0x7a, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x66, 0x6f, 0x72, 0x20,
+    0x69, 0x3d, 0x31, 0x2c, 0x73, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x28, 0x22, 0x23, 0x22, 0x2c, 0x2e,
+    0x2e, 0x2e, 0x29, 0x20, 0x64, 0x6f, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+    0x20, 0x72, 0x65, 0x73, 0x20, 0x3d, 0x20, 0x72, 0x65, 0x73, 0x20, 0x26, 0x20, 0x73, 0x65, 0x6c,
+    0x65, 0x63, 0x74, 0x28, 0x69, 0x2c, 0x2e, 0x2e, 0x2e, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20,
+    0x20, 0x65, 0x6e, 0x64, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72,
+    0x6e, 0x20, 0x28, 0x72, 0x65, 0x73, 0x20, 0x26, 0x20, 0x30, 0x78, 0x46, 0x46, 0x46, 0x46, 0x46,
+    0x46, 0x46, 0x46, 0x29, 0x20, 0x7e, 0x3d, 0x20, 0x30, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x65, 0x6e,
+    0x64, 0x0a, 0x20, 0x20, 0x65, 0x6e, 0x64, 0x2c, 0x0a, 0x20, 0x20, 0x6c, 0x73, 0x68, 0x69, 0x66,
+    0x74, 0x20, 0x3d, 0x20, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x28, 0x61, 0x2c,
+    0x20, 0x62, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x20, 0x28,
+    0x28, 0x61, 0x20, 0x26, 0x20, 0x30, 0x78, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x29,
+    0x20, 0x3c, 0x3c, 0x20, 0x62, 0x29, 0x20, 0x26, 0x20, 0x30, 0x78, 0x46, 0x46, 0x46, 0x46, 0x46,
+    0x46, 0x46, 0x46, 0x0a, 0x20, 0x20, 0x65, 0x6e, 0x64, 0x2c, 0x0a, 0x20, 0x20, 0x72, 0x73, 0x68,
+    0x69, 0x66, 0x74, 0x20, 0x3d, 0x20, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x28,
+    0x61, 0x2c, 0x20, 0x62, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e,
+    0x20, 0x28, 0x28, 0x61, 0x20, 0x26, 0x20, 0x30, 0x78, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46,
+    0x46, 0x29, 0x20, 0x3e, 0x3e, 0x20, 0x62, 0x29, 0x20, 0x26, 0x20, 0x30, 0x78, 0x46, 0x46, 0x46,
+    0x46, 0x46, 0x46, 0x46, 0x46, 0x0a, 0x20, 0x20, 0x65, 0x6e, 0x64, 0x2c, 0x0a, 0x20, 0x20, 0x61,
     0x72, 0x73, 0x68, 0x69, 0x66, 0x74, 0x20, 0x3d, 0x20, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f,
-    0x6e, 0x20, 0x28, 0x61, 0x2c, 0x20, 0x62, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x72, 0x65, 0x74,
-    0x75, 0x72, 0x6e, 0x20, 0x28, 0x28, 0x61, 0x20, 0x26, 0x20, 0x30, 0x78, 0x46, 0x46, 0x46, 0x46,
-    0x46, 0x46, 0x46, 0x46, 0x29, 0x20, 0x3e, 0x3e, 0x20, 0x62, 0x29, 0x20, 0x26, 0x20, 0x30, 0x78,
-    0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x0a, 0x20, 0x20, 0x65, 0x6e, 0x64, 0x2c, 0x0a,
-    0x20, 0x20, 0x61, 0x72, 0x73, 0x68, 0x69, 0x66, 0x74, 0x20, 0x3d, 0x20, 0x66, 0x75, 0x6e, 0x63,
-    0x74, 0x69, 0x6f, 0x6e, 0x20, 0x28, 0x61, 0x2c, 0x20, 0x62, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20,
+    0x6e, 0x20, 0x28, 0x61, 0x2c, 0x20, 0x62, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x61, 0x20, 0x3d,
+    0x20, 0x61, 0x20, 0x26, 0x20, 0x30, 0x78, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x0a,
+    0x20, 0x20, 0x20, 0x20, 0x69, 0x66, 0x20, 0x62, 0x20, 0x3c, 0x3d, 0x20, 0x30, 0x20, 0x6f, 0x72,
+    0x20, 0x28, 0x61, 0x20, 0x26, 0x20, 0x30, 0x78, 0x38, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30,
+    0x29, 0x20, 0x3d, 0x3d, 0x20, 0x30, 0x20, 0x74, 0x68, 0x65, 0x6e, 0x0a, 0x20, 0x20, 0x20, 0x20,
+    0x20, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x20, 0x28, 0x61, 0x20, 0x3e, 0x3e, 0x20, 0x62,
+    0x29, 0x20, 0x26, 0x20, 0x30, 0x78, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x0a, 0x20,
+    0x20, 0x20, 0x20, 0x65, 0x6c, 0x73, 0x65, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x72, 0x65,
+    0x74, 0x75, 0x72, 0x6e, 0x20, 0x28, 0x28, 0x61, 0x20, 0x3e, 0x3e, 0x20, 0x62, 0x29, 0x20, 0x7c,
+    0x20, 0x7e, 0x28, 0x30, 0x78, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x20, 0x3e, 0x3e,
+    0x20, 0x62, 0x29, 0x29, 0x20, 0x26, 0x20, 0x30, 0x78, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46,
+    0x46, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x65, 0x6e, 0x64, 0x0a, 0x20, 0x20, 0x65, 0x6e, 0x64, 0x2c,
+    0x0a, 0x20, 0x20, 0x6c, 0x72, 0x6f, 0x74, 0x61, 0x74, 0x65, 0x20, 0x3d, 0x20, 0x66, 0x75, 0x6e,
+    0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x28, 0x61, 0x20, 0x2c, 0x62, 0x29, 0x0a, 0x20, 0x20, 0x20,
+    0x20, 0x62, 0x20, 0x3d, 0x20, 0x62, 0x20, 0x26, 0x20, 0x33, 0x31, 0x0a, 0x20, 0x20, 0x20, 0x20,
     0x61, 0x20, 0x3d, 0x20, 0x61, 0x20, 0x26, 0x20, 0x30, 0x78, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46,
-    0x46, 0x46, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x69, 0x66, 0x20, 0x62, 0x20, 0x3c, 0x3d, 0x20, 0x30,
-    0x20, 0x6f, 0x72, 0x20, 0x28, 0x61, 0x20, 0x26, 0x20, 0x30, 0x78, 0x38, 0x30, 0x30, 0x30, 0x30,
-    0x30, 0x30, 0x30, 0x29, 0x20, 0x3d, 0x3d, 0x20, 0x30, 0x20, 0x74, 0x68, 0x65, 0x6e, 0x0a, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x20, 0x28, 0x61, 0x20, 0x3e,
-    0x3e, 0x20, 0x62, 0x29, 0x20, 0x26, 0x20, 0x30, 0x78, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46,
-    0x46, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x65, 0x6c, 0x73, 0x65, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x20, 0x28, 0x28, 0x61, 0x20, 0x3e, 0x3e, 0x20, 0x62,
-    0x29, 0x20, 0x7c, 0x20, 0x7e, 0x28, 0x30, 0x78, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46,
-    0x20, 0x3e, 0x3e, 0x20, 0x62, 0x29, 0x29, 0x20, 0x26, 0x20, 0x30, 0x78, 0x46, 0x46, 0x46, 0x46,
-    0x46, 0x46, 0x46, 0x46, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x65, 0x6e, 0x64, 0x0a, 0x20, 0x20, 0x65,
-    0x6e, 0x64, 0x2c, 0x0a, 0x20, 0x20, 0x6c, 0x72, 0x6f, 0x74, 0x61, 0x74, 0x65, 0x20, 0x3d, 0x20,
-    0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x28, 0x61, 0x20, 0x2c, 0x62, 0x29, 0x0a,
-    0x20, 0x20, 0x20, 0x20, 0x62, 0x20, 0x3d, 0x20, 0x62, 0x20, 0x26, 0x20, 0x33, 0x31, 0x0a, 0x20,
-    0x20, 0x20, 0x20, 0x61, 0x20, 0x3d, 0x20, 0x61, 0x20, 0x26, 0x20, 0x30, 0x78, 0x46, 0x46, 0x46,
-    0x46, 0x46, 0x46, 0x46, 0x46, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x61, 0x20, 0x3d, 0x20, 0x28, 0x61,
-    0x20, 0x3c, 0x3c, 0x20, 0x62, 0x29, 0x20, 0x7c, 0x20, 0x28, 0x61, 0x20, 0x3e, 0x3e, 0x20, 0x28,
-    0x33, 0x32, 0x20, 0x2d, 0x20, 0x62, 0x29, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x72, 0x65, 0x74,
-    0x75, 0x72, 0x6e, 0x20, 0x61, 0x20, 0x26, 0x20, 0x30, 0x78, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46,
-    0x46, 0x46, 0x0a, 0x20, 0x20, 0x65, 0x6e, 0x64, 0x2c, 0x0a, 0x20, 0x20, 0x72, 0x72, 0x6f, 0x74,
-    0x61, 0x74, 0x65, 0x20, 0x3d, 0x20, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x28,
-    0x61, 0x2c, 0x20, 0x62, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x62, 0x20, 0x3d, 0x20, 0x2d, 0x62,
-    0x20, 0x26, 0x20, 0x33, 0x31, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x61, 0x20, 0x3d, 0x20, 0x61, 0x20,
-    0x26, 0x20, 0x30, 0x78, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x0a, 0x20, 0x20, 0x20,
-    0x20, 0x61, 0x20, 0x3d, 0x20, 0x28, 0x61, 0x20, 0x3c, 0x3c, 0x20, 0x62, 0x29, 0x20, 0x7c, 0x20,
-    0x28, 0x61, 0x20, 0x3e, 0x3e, 0x20, 0x28, 0x33, 0x32, 0x20, 0x2d, 0x20, 0x62, 0x29, 0x29, 0x0a,
-    0x20, 0x20, 0x20, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x20, 0x61, 0x20, 0x26, 0x20, 0x30,
-    0x78, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x0a, 0x20, 0x20, 0x65, 0x6e, 0x64, 0x2c,
-    0x0a, 0x20, 0x20, 0x65, 0x78, 0x74, 0x72, 0x61, 0x63, 0x74, 0x20, 0x3d, 0x20, 0x66, 0x75, 0x6e,
-    0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x28, 0x61, 0x2c, 0x20, 0x66, 0x2c, 0x20, 0x77, 0x29, 0x0a,
-    0x20, 0x20, 0x20, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x20, 0x28, 0x61, 0x20, 0x3e, 0x3e,
-    0x20, 0x66, 0x29, 0x20, 0x26, 0x20, 0x7e, 0x28, 0x2d, 0x31, 0x20, 0x3c, 0x3c, 0x20, 0x28, 0x77,
-    0x20, 0x6f, 0x72, 0x20, 0x31, 0x29, 0x29, 0x0a, 0x20, 0x20, 0x65, 0x6e, 0x64, 0x2c, 0x0a, 0x20,
-    0x20, 0x72, 0x65, 0x70, 0x6c, 0x61, 0x63, 0x65, 0x20, 0x3d, 0x20, 0x66, 0x75, 0x6e, 0x63, 0x74,
-    0x69, 0x6f, 0x6e, 0x20, 0x28, 0x61, 0x2c, 0x20, 0x76, 0x2c, 0x20, 0x66, 0x2c, 0x20, 0x77, 0x29,
-    0x0a, 0x20, 0x20, 0x20, 0x20, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x6d, 0x61, 0x73, 0x6b, 0x20,
-    0x3d, 0x20, 0x7e, 0x28, 0x2d, 0x31, 0x20, 0x3c, 0x3c, 0x20, 0x28, 0x77, 0x20, 0x6f, 0x72, 0x20,
-    0x31, 0x29, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x20, 0x28,
-    0x28, 0x61, 0x20, 0x26, 0x20, 0x7e, 0x28, 0x6d, 0x61, 0x73, 0x6b, 0x20, 0x3c, 0x3c, 0x20, 0x66,
-    0x29, 0x29, 0x20, 0x7c, 0x20, 0x28, 0x28, 0x76, 0x20, 0x26, 0x20, 0x6d, 0x61, 0x73, 0x6b, 0x29,
-    0x20, 0x3c, 0x3c, 0x20, 0x66, 0x29, 0x29, 0x20, 0x26, 0x20, 0x30, 0x78, 0x46, 0x46, 0x46, 0x46,
-    0x46, 0x46, 0x46, 0x46, 0x0a, 0x20, 0x20, 0x65, 0x6e, 0x64, 0x2c, 0x0a, 0x7d, 0x0a, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5d, 0x5d, 0x20, 0x29, 0x0a, 0x0a, 0x65, 0x6c, 0x73, 0x65,
-    0x69, 0x66, 0x20, 0x62, 0x69, 0x74, 0x20, 0x74, 0x68, 0x65, 0x6e, 0x0a, 0x0a, 0x20, 0x20, 0x20,
-    0x20, 0x2d, 0x2d, 0x20, 0x6c, 0x75, 0x61, 0x6a, 0x69, 0x74, 0x20, 0x28, 0x66, 0x6f, 0x72, 0x20,
-    0x6e, 0x6f, 0x77, 0x29, 0x0a, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x62, 0x69, 0x74, 0x33, 0x32, 0x20,
-    0x3d, 0x20, 0x6c, 0x6f, 0x61, 0x64, 0x20, 0x28, 0x20, 0x5b, 0x5b, 0x0a, 0x6c, 0x6f, 0x63, 0x61,
-    0x6c, 0x20, 0x62, 0x61, 0x6e, 0x64, 0x2c, 0x20, 0x62, 0x6e, 0x6f, 0x74, 0x2c, 0x20, 0x72, 0x73,
-    0x68, 0x69, 0x66, 0x74, 0x2c, 0x20, 0x6c, 0x73, 0x68, 0x69, 0x66, 0x74, 0x20, 0x3d, 0x20, 0x62,
-    0x69, 0x74, 0x2e, 0x62, 0x61, 0x6e, 0x64, 0x2c, 0x20, 0x62, 0x69, 0x74, 0x2e, 0x62, 0x6e, 0x6f,
-    0x74, 0x2c, 0x20, 0x62, 0x69, 0x74, 0x2e, 0x72, 0x73, 0x68, 0x69, 0x66, 0x74, 0x2c, 0x20, 0x62,
-    0x69, 0x74, 0x2e, 0x6c, 0x73, 0x68, 0x69, 0x66, 0x74, 0x0a, 0x0a, 0x62, 0x69, 0x74, 0x33, 0x32,
-    0x20, 0x3d, 0x20, 0x7b, 0x0a, 0x20, 0x20, 0x61, 0x72, 0x73, 0x68, 0x69, 0x66, 0x74, 0x20, 0x3d,
-    0x20, 0x62, 0x69, 0x74, 0x2e, 0x61, 0x72, 0x73, 0x68, 0x69, 0x66, 0x74, 0x2c, 0x0a, 0x20, 0x20,
-    0x62, 0x61, 0x6e, 0x64, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x62, 0x61, 0x6e, 0x64, 0x2c, 0x0a,
-    0x20, 0x20, 0x62, 0x6e, 0x6f, 0x74, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x62, 0x6e, 0x6f, 0x74,
-    0x2c, 0x0a, 0x20, 0x20, 0x62, 0x6f, 0x72, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x62, 0x69,
-    0x74, 0x2e, 0x62, 0x6f, 0x72, 0x2c, 0x0a, 0x20, 0x20, 0x62, 0x78, 0x6f, 0x72, 0x20, 0x20, 0x20,
-    0x20, 0x3d, 0x20, 0x62, 0x69, 0x74, 0x2e, 0x62, 0x78, 0x6f, 0x72, 0x2c, 0x0a, 0x20, 0x20, 0x62,
-    0x74, 0x65, 0x73, 0x74, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f,
-    0x6e, 0x28, 0x2e, 0x2e, 0x2e, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72,
-    0x6e, 0x20, 0x62, 0x61, 0x6e, 0x64, 0x28, 0x2e, 0x2e, 0x2e, 0x29, 0x20, 0x7e, 0x3d, 0x20, 0x30,
-    0x0a, 0x20, 0x20, 0x65, 0x6e, 0x64, 0x2c, 0x0a, 0x20, 0x20, 0x65, 0x78, 0x74, 0x72, 0x61, 0x63,
-    0x74, 0x20, 0x3d, 0x20, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x28, 0x61, 0x2c, 0x66,
-    0x2c, 0x77, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x20, 0x62,
-    0x61, 0x6e, 0x64, 0x28, 0x72, 0x73, 0x68, 0x69, 0x66, 0x74, 0x28, 0x61, 0x2c, 0x66, 0x29, 0x2c,
-    0x32, 0x5e, 0x28, 0x77, 0x20, 0x6f, 0x72, 0x20, 0x31, 0x29, 0x2d, 0x31, 0x29, 0x0a, 0x20, 0x20,
-    0x65, 0x6e, 0x64, 0x2c, 0x0a, 0x20, 0x20, 0x6c, 0x72, 0x6f, 0x74, 0x61, 0x74, 0x65, 0x20, 0x3d,
-    0x20, 0x62, 0x69, 0x74, 0x2e, 0x72, 0x6f, 0x6c, 0x2c, 0x0a, 0x20, 0x20, 0x6c, 0x73, 0x68, 0x69,
-    0x66, 0x74, 0x20, 0x20, 0x3d, 0x20, 0x6c, 0x73, 0x68, 0x69, 0x66, 0x74, 0x2c, 0x0a, 0x20, 0x20,
-    0x72, 0x65, 0x70, 0x6c, 0x61, 0x63, 0x65, 0x20, 0x3d, 0x20, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69,
-    0x6f, 0x6e, 0x28, 0x61, 0x2c, 0x76, 0x2c, 0x66, 0x2c, 0x77, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20,
-    0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x6d, 0x61, 0x73, 0x6b, 0x20, 0x3d, 0x20, 0x32, 0x5e, 0x28,
-    0x77, 0x20, 0x6f, 0x72, 0x20, 0x31, 0x29, 0x2d, 0x31, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x72, 0x65,
-    0x74, 0x75, 0x72, 0x6e, 0x20, 0x62, 0x61, 0x6e, 0x64, 0x28, 0x61, 0x2c, 0x62, 0x6e, 0x6f, 0x74,
-    0x28, 0x6c, 0x73, 0x68, 0x69, 0x66, 0x74, 0x28, 0x6d, 0x61, 0x73, 0x6b, 0x2c, 0x66, 0x29, 0x29,
-    0x29, 0x2b, 0x6c, 0x73, 0x68, 0x69, 0x66, 0x74, 0x28, 0x62, 0x61, 0x6e, 0x64, 0x28, 0x76, 0x2c,
-    0x6d, 0x61, 0x73, 0x6b, 0x29, 0x2c, 0x66, 0x29, 0x0a, 0x20, 0x20, 0x65, 0x6e, 0x64, 0x2c, 0x0a,
-    0x20, 0x20, 0x72, 0x72, 0x6f, 0x74, 0x61, 0x74, 0x65, 0x20, 0x3d, 0x20, 0x62, 0x69, 0x74, 0x2e,
-    0x72, 0x6f, 0x72, 0x2c, 0x0a, 0x20, 0x20, 0x72, 0x73, 0x68, 0x69, 0x66, 0x74, 0x20, 0x20, 0x3d,
-    0x20, 0x72, 0x73, 0x68, 0x69, 0x66, 0x74, 0x2c, 0x0a, 0x7d, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x5d, 0x5d, 0x20, 0x29, 0x0a, 0x0a, 0x65, 0x6c, 0x73, 0x65, 0x0a, 0x0a, 0x20,
-    0x20, 0x20, 0x20, 0x2d, 0x2d, 0x20, 0x68, 0x6f, 0x70, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x74,
-    0x68, 0x65, 0x20, 0x62, 0x65, 0x73, 0x74, 0x20, 0x6f, 0x72, 0x20, 0x66, 0x61, 0x69, 0x6c, 0x0a,
-    0x0a, 0x20, 0x20, 0x20, 0x20, 0x62, 0x69, 0x74, 0x33, 0x32, 0x20, 0x3d, 0x20, 0x72, 0x65, 0x71,
-    0x75, 0x69, 0x72, 0x65, 0x28, 0x22, 0x62, 0x69, 0x74, 0x33, 0x32, 0x22, 0x29, 0x0a, 0x0a, 0x65,
-    0x6e, 0x64, 0x0a, 0x0a, 0x2d, 0x2d, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x6e,
-    0x65, 0x65, 0x64, 0x65, 0x64, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x67, 0x65, 0x74, 0x74, 0x69, 0x6e,
-    0x67, 0x20, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x28, 0x22, 0x73, 0x6f, 0x63, 0x6b, 0x65,
-    0x74, 0x22, 0x29, 0x20, 0x72, 0x69, 0x67, 0x68, 0x74, 0x0a, 0x0a, 0x64, 0x6f, 0x0a, 0x0a, 0x20,
-    0x20, 0x20, 0x20, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x6c, 0x6f, 0x61, 0x64, 0x65, 0x64, 0x20,
-    0x3d, 0x20, 0x70, 0x61, 0x63, 0x6b, 0x61, 0x67, 0x65, 0x2e, 0x6c, 0x6f, 0x61, 0x64, 0x65, 0x64,
-    0x0a, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x69, 0x66, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x6c, 0x6f, 0x61,
-    0x64, 0x65, 0x64, 0x2e, 0x73, 0x6f, 0x63, 0x6b, 0x65, 0x74, 0x20, 0x74, 0x68, 0x65, 0x6e, 0x20,
-    0x6c, 0x6f, 0x61, 0x64, 0x65, 0x64, 0x2e, 0x73, 0x6f, 0x63, 0x6b, 0x65, 0x74, 0x20, 0x3d, 0x20,
-    0x6c, 0x6f, 0x61, 0x64, 0x65, 0x64, 0x5b, 0x22, 0x73, 0x6f, 0x63, 0x6b, 0x65, 0x74, 0x2e, 0x63,
-    0x6f, 0x72, 0x65, 0x22, 0x5d, 0x20, 0x65, 0x6e, 0x64, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x69, 0x66,
-    0x20, 0x6e, 0x6f, 0x74, 0x20, 0x6c, 0x6f, 0x61, 0x64, 0x65, 0x64, 0x2e, 0x6d, 0x69, 0x6d, 0x65,
-    0x20, 0x20, 0x20, 0x74, 0x68, 0x65, 0x6e, 0x20, 0x6c, 0x6f, 0x61, 0x64, 0x65, 0x64, 0x2e, 0x6d,
-    0x69, 0x6d, 0x65, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x6c, 0x6f, 0x61, 0x64, 0x65, 0x64, 0x5b, 0x22,
-    0x6d, 0x69, 0x6d, 0x65, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x22, 0x5d, 0x20, 0x20, 0x20, 0x65, 0x6e,
-    0x64, 0x0a, 0x0a, 0x65, 0x6e, 0x64, 0x0a, 0x0a, 0x64, 0x6f, 0x0a, 0x0a, 0x20, 0x20, 0x20, 0x20,
-    0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x6c, 0x66, 0x73, 0x61, 0x74, 0x74, 0x72, 0x69, 0x62, 0x75,
-    0x74, 0x65, 0x73, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x6c, 0x66, 0x73, 0x2e, 0x61, 0x74,
-    0x74, 0x72, 0x69, 0x62, 0x75, 0x74, 0x65, 0x73, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x6c, 0x6f, 0x63,
-    0x61, 0x6c, 0x20, 0x73, 0x79, 0x6d, 0x6c, 0x69, 0x6e, 0x6b, 0x61, 0x74, 0x74, 0x72, 0x69, 0x62,
-    0x75, 0x74, 0x65, 0x73, 0x20, 0x3d, 0x20, 0x6c, 0x66, 0x73, 0x2e, 0x73, 0x79, 0x6d, 0x6c, 0x69,
-    0x6e, 0x6b, 0x61, 0x74, 0x74, 0x72, 0x69, 0x62, 0x75, 0x74, 0x65, 0x73, 0x0a, 0x0a, 0x20, 0x20,
-    0x20, 0x20, 0x2d, 0x2d, 0x20, 0x74, 0x68, 0x65, 0x73, 0x65, 0x20, 0x63, 0x61, 0x6e, 0x20, 0x6e,
-    0x6f, 0x77, 0x20, 0x62, 0x65, 0x20, 0x64, 0x6f, 0x6e, 0x65, 0x20, 0x75, 0x73, 0x69, 0x6e, 0x67,
-    0x20, 0x6c, 0x66, 0x73, 0x20, 0x28, 0x77, 0x61, 0x73, 0x20, 0x64, 0x65, 0x61, 0x64, 0x20, 0x73,
-    0x6c, 0x6f, 0x77, 0x20, 0x62, 0x65, 0x66, 0x6f, 0x72, 0x65, 0x29, 0x0a, 0x0a, 0x20, 0x20, 0x20,
-    0x20, 0x69, 0x66, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x6c, 0x66, 0x73, 0x2e, 0x69, 0x73, 0x66, 0x69,
-    0x6c, 0x65, 0x20, 0x74, 0x68, 0x65, 0x6e, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x6c, 0x66, 0x73, 0x2e, 0x69, 0x73, 0x66,
-    0x69, 0x6c, 0x65, 0x28, 0x6e, 0x61, 0x6d, 0x65, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x6d, 0x20, 0x3d, 0x20,
-    0x6c, 0x66, 0x73, 0x61, 0x74, 0x74, 0x72, 0x69, 0x62, 0x75, 0x74, 0x65, 0x73, 0x28, 0x6e, 0x61,
-    0x6d, 0x65, 0x2c, 0x22, 0x6d, 0x6f, 0x64, 0x65, 0x22, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x20, 0x6d, 0x20,
-    0x3d, 0x3d, 0x20, 0x22, 0x66, 0x69, 0x6c, 0x65, 0x22, 0x20, 0x6f, 0x72, 0x20, 0x6d, 0x20, 0x3d,
-    0x3d, 0x20, 0x22, 0x6c, 0x69, 0x6e, 0x6b, 0x22, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x65, 0x6e, 0x64, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x65, 0x6e, 0x64, 0x0a, 0x0a, 0x20, 0x20,
-    0x20, 0x20, 0x69, 0x66, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x6c, 0x66, 0x73, 0x2e, 0x69, 0x73, 0x64,
-    0x69, 0x72, 0x20, 0x74, 0x68, 0x65, 0x6e, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x6c, 0x66, 0x73, 0x2e, 0x69, 0x73, 0x64,
-    0x69, 0x72, 0x28, 0x6e, 0x61, 0x6d, 0x65, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x6d, 0x20, 0x3d, 0x20, 0x6c,
-    0x66, 0x73, 0x61, 0x74, 0x74, 0x72, 0x69, 0x62, 0x75, 0x74, 0x65, 0x73, 0x28, 0x6e, 0x61, 0x6d,
-    0x65, 0x2c, 0x22, 0x6d, 0x6f, 0x64, 0x65, 0x22, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x20, 0x6d, 0x20, 0x3d,
-    0x3d, 0x20, 0x22, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x79, 0x22, 0x0a, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x65, 0x6e, 0x64, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x65, 0x6e,
-    0x64, 0x0a, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x2d, 0x2d, 0x20, 0x73, 0x68, 0x6f, 0x72, 0x74, 0x6e,
-    0x61, 0x6d, 0x65, 0x73, 0x20, 0x68, 0x61, 0x76, 0x65, 0x20, 0x61, 0x6c, 0x73, 0x6f, 0x20, 0x62,
-    0x65, 0x20, 0x73, 0x6f, 0x72, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x64, 0x72, 0x6f, 0x70, 0x70, 0x65,
-    0x64, 0x20, 0x66, 0x72, 0x6f, 0x6d, 0x20, 0x6b, 0x70, 0x73, 0x65, 0x0a, 0x0a, 0x20, 0x20, 0x20,
-    0x20, 0x69, 0x66, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x6c, 0x66, 0x73, 0x2e, 0x73, 0x68, 0x6f, 0x72,
-    0x74, 0x6e, 0x61, 0x6d, 0x65, 0x20, 0x74, 0x68, 0x65, 0x6e, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x6c, 0x66, 0x73, 0x2e,
-    0x73, 0x68, 0x6f, 0x72, 0x74, 0x6e, 0x61, 0x6d, 0x65, 0x28, 0x6e, 0x61, 0x6d, 0x65, 0x29, 0x0a,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x72, 0x65, 0x74, 0x75,
-    0x72, 0x6e, 0x20, 0x6e, 0x61, 0x6d, 0x65, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x65, 0x6e, 0x64, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x65, 0x6e, 0x64, 0x0a, 0x0a, 0x20, 0x20, 0x20,
-    0x20, 0x2d, 0x2d, 0x20, 0x6e, 0x6f, 0x77, 0x20, 0x74, 0x68, 0x65, 0x72, 0x65, 0x20, 0x69, 0x73,
-    0x20, 0x61, 0x20, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x20, 0x66, 0x69, 0x65, 0x6c, 0x64, 0x2c,
-    0x20, 0x73, 0x6f, 0x20, 0x2e, 0x2e, 0x2e, 0x0a, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x69, 0x66, 0x20,
-    0x6e, 0x6f, 0x74, 0x20, 0x6c, 0x66, 0x73, 0x2e, 0x72, 0x65, 0x61, 0x64, 0x6c, 0x69, 0x6e, 0x6b,
-    0x20, 0x74, 0x68, 0x65, 0x6e, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x66, 0x75,
-    0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x6c, 0x66, 0x73, 0x2e, 0x72, 0x65, 0x61, 0x64, 0x6c,
-    0x69, 0x6e, 0x6b, 0x28, 0x6e, 0x61, 0x6d, 0x65, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
-    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x20, 0x73, 0x79, 0x6d,
-    0x6c, 0x69, 0x6e, 0x6b, 0x61, 0x74, 0x74, 0x72, 0x69, 0x62, 0x75, 0x74, 0x65, 0x73, 0x28, 0x6e,
-    0x61, 0x6d, 0x65, 0x2c, 0x22, 0x74, 0x61, 0x72, 0x67, 0x65, 0x74, 0x22, 0x29, 0x20, 0x6f, 0x72,
-    0x20, 0x6e, 0x69, 0x6c, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x65, 0x6e, 0x64,
-    0x0a, 0x20, 0x20, 0x20, 0x20, 0x65, 0x6e, 0x64, 0x0a, 0x0a, 0x65, 0x6e, 0x64, 0x0a, 0x0a, 0x2d,
-    0x2d, 0x20, 0x73, 0x6f, 0x20, 0x66, 0x61, 0x72, 0x0a, 0x0a, 0x00
+    0x46, 0x46, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x61, 0x20, 0x3d, 0x20, 0x28, 0x61, 0x20, 0x3c, 0x3c,
+    0x20, 0x62, 0x29, 0x20, 0x7c, 0x20, 0x28, 0x61, 0x20, 0x3e, 0x3e, 0x20, 0x28, 0x33, 0x32, 0x20,
+    0x2d, 0x20, 0x62, 0x29, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e,
+    0x20, 0x61, 0x20, 0x26, 0x20, 0x30, 0x78, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x0a,
+    0x20, 0x20, 0x65, 0x6e, 0x64, 0x2c, 0x0a, 0x20, 0x20, 0x72, 0x72, 0x6f, 0x74, 0x61, 0x74, 0x65,
+    0x20, 0x3d, 0x20, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x28, 0x61, 0x2c, 0x20,
+    0x62, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x62, 0x20, 0x3d, 0x20, 0x2d, 0x62, 0x20, 0x26, 0x20,
+    0x33, 0x31, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x61, 0x20, 0x3d, 0x20, 0x61, 0x20, 0x26, 0x20, 0x30,
+    0x78, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x61, 0x20,
+    0x3d, 0x20, 0x28, 0x61, 0x20, 0x3c, 0x3c, 0x20, 0x62, 0x29, 0x20, 0x7c, 0x20, 0x28, 0x61, 0x20,
+    0x3e, 0x3e, 0x20, 0x28, 0x33, 0x32, 0x20, 0x2d, 0x20, 0x62, 0x29, 0x29, 0x0a, 0x20, 0x20, 0x20,
+    0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x20, 0x61, 0x20, 0x26, 0x20, 0x30, 0x78, 0x46, 0x46,
+    0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x0a, 0x20, 0x20, 0x65, 0x6e, 0x64, 0x2c, 0x0a, 0x20, 0x20,
+    0x65, 0x78, 0x74, 0x72, 0x61, 0x63, 0x74, 0x20, 0x3d, 0x20, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69,
+    0x6f, 0x6e, 0x20, 0x28, 0x61, 0x2c, 0x20, 0x66, 0x2c, 0x20, 0x77, 0x29, 0x0a, 0x20, 0x20, 0x20,
+    0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x20, 0x28, 0x61, 0x20, 0x3e, 0x3e, 0x20, 0x66, 0x29,
+    0x20, 0x26, 0x20, 0x7e, 0x28, 0x2d, 0x31, 0x20, 0x3c, 0x3c, 0x20, 0x28, 0x77, 0x20, 0x6f, 0x72,
+    0x20, 0x31, 0x29, 0x29, 0x0a, 0x20, 0x20, 0x65, 0x6e, 0x64, 0x2c, 0x0a, 0x20, 0x20, 0x72, 0x65,
+    0x70, 0x6c, 0x61, 0x63, 0x65, 0x20, 0x3d, 0x20, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e,
+    0x20, 0x28, 0x61, 0x2c, 0x20, 0x76, 0x2c, 0x20, 0x66, 0x2c, 0x20, 0x77, 0x29, 0x0a, 0x20, 0x20,
+    0x20, 0x20, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x6d, 0x61, 0x73, 0x6b, 0x20, 0x3d, 0x20, 0x7e,
+    0x28, 0x2d, 0x31, 0x20, 0x3c, 0x3c, 0x20, 0x28, 0x77, 0x20, 0x6f, 0x72, 0x20, 0x31, 0x29, 0x29,
+    0x0a, 0x20, 0x20, 0x20, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x20, 0x28, 0x28, 0x61, 0x20,
+    0x26, 0x20, 0x7e, 0x28, 0x6d, 0x61, 0x73, 0x6b, 0x20, 0x3c, 0x3c, 0x20, 0x66, 0x29, 0x29, 0x20,
+    0x7c, 0x20, 0x28, 0x28, 0x76, 0x20, 0x26, 0x20, 0x6d, 0x61, 0x73, 0x6b, 0x29, 0x20, 0x3c, 0x3c,
+    0x20, 0x66, 0x29, 0x29, 0x20, 0x26, 0x20, 0x30, 0x78, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46, 0x46,
+    0x46, 0x0a, 0x20, 0x20, 0x65, 0x6e, 0x64, 0x2c, 0x0a, 0x7d, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20,
+    0x20, 0x20, 0x20, 0x5d, 0x5d, 0x20, 0x29, 0x0a, 0x0a, 0x65, 0x6c, 0x73, 0x65, 0x69, 0x66, 0x20,
+    0x62, 0x69, 0x74, 0x20, 0x74, 0x68, 0x65, 0x6e, 0x0a, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x2d, 0x2d,
+    0x20, 0x6c, 0x75, 0x61, 0x6a, 0x69, 0x74, 0x20, 0x28, 0x66, 0x6f, 0x72, 0x20, 0x6e, 0x6f, 0x77,
+    0x29, 0x0a, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x62, 0x69, 0x74, 0x33, 0x32, 0x20, 0x3d, 0x20, 0x6c,
+    0x6f, 0x61, 0x64, 0x20, 0x28, 0x20, 0x5b, 0x5b, 0x0a, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x62,
+    0x61, 0x6e, 0x64, 0x2c, 0x20, 0x62, 0x6e, 0x6f, 0x74, 0x2c, 0x20, 0x72, 0x73, 0x68, 0x69, 0x66,
+    0x74, 0x2c, 0x20, 0x6c, 0x73, 0x68, 0x69, 0x66, 0x74, 0x20, 0x3d, 0x20, 0x62, 0x69, 0x74, 0x2e,
+    0x62, 0x61, 0x6e, 0x64, 0x2c, 0x20, 0x62, 0x69, 0x74, 0x2e, 0x62, 0x6e, 0x6f, 0x74, 0x2c, 0x20,
+    0x62, 0x69, 0x74, 0x2e, 0x72, 0x73, 0x68, 0x69, 0x66, 0x74, 0x2c, 0x20, 0x62, 0x69, 0x74, 0x2e,
+    0x6c, 0x73, 0x68, 0x69, 0x66, 0x74, 0x0a, 0x0a, 0x62, 0x69, 0x74, 0x33, 0x32, 0x20, 0x3d, 0x20,
+    0x7b, 0x0a, 0x20, 0x20, 0x61, 0x72, 0x73, 0x68, 0x69, 0x66, 0x74, 0x20, 0x3d, 0x20, 0x62, 0x69,
+    0x74, 0x2e, 0x61, 0x72, 0x73, 0x68, 0x69, 0x66, 0x74, 0x2c, 0x0a, 0x20, 0x20, 0x62, 0x61, 0x6e,
+    0x64, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x62, 0x61, 0x6e, 0x64, 0x2c, 0x0a, 0x20, 0x20, 0x62,
+    0x6e, 0x6f, 0x74, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x62, 0x6e, 0x6f, 0x74, 0x2c, 0x0a, 0x20,
+    0x20, 0x62, 0x6f, 0x72, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x62, 0x69, 0x74, 0x2e, 0x62,
+    0x6f, 0x72, 0x2c, 0x0a, 0x20, 0x20, 0x62, 0x78, 0x6f, 0x72, 0x20, 0x20, 0x20, 0x20, 0x3d, 0x20,
+    0x62, 0x69, 0x74, 0x2e, 0x62, 0x78, 0x6f, 0x72, 0x2c, 0x0a, 0x20, 0x20, 0x62, 0x74, 0x65, 0x73,
+    0x74, 0x20, 0x20, 0x20, 0x3d, 0x20, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x28, 0x2e,
+    0x2e, 0x2e, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x20, 0x62,
+    0x61, 0x6e, 0x64, 0x28, 0x2e, 0x2e, 0x2e, 0x29, 0x20, 0x7e, 0x3d, 0x20, 0x30, 0x0a, 0x20, 0x20,
+    0x65, 0x6e, 0x64, 0x2c, 0x0a, 0x20, 0x20, 0x65, 0x78, 0x74, 0x72, 0x61, 0x63, 0x74, 0x20, 0x3d,
+    0x20, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x28, 0x61, 0x2c, 0x66, 0x2c, 0x77, 0x29,
+    0x0a, 0x20, 0x20, 0x20, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72, 0x6e, 0x20, 0x62, 0x61, 0x6e, 0x64,
+    0x28, 0x72, 0x73, 0x68, 0x69, 0x66, 0x74, 0x28, 0x61, 0x2c, 0x66, 0x29, 0x2c, 0x32, 0x5e, 0x28,
+    0x77, 0x20, 0x6f, 0x72, 0x20, 0x31, 0x29, 0x2d, 0x31, 0x29, 0x0a, 0x20, 0x20, 0x65, 0x6e, 0x64,
+    0x2c, 0x0a, 0x20, 0x20, 0x6c, 0x72, 0x6f, 0x74, 0x61, 0x74, 0x65, 0x20, 0x3d, 0x20, 0x62, 0x69,
+    0x74, 0x2e, 0x72, 0x6f, 0x6c, 0x2c, 0x0a, 0x20, 0x20, 0x6c, 0x73, 0x68, 0x69, 0x66, 0x74, 0x20,
+    0x20, 0x3d, 0x20, 0x6c, 0x73, 0x68, 0x69, 0x66, 0x74, 0x2c, 0x0a, 0x20, 0x20, 0x72, 0x65, 0x70,
+    0x6c, 0x61, 0x63, 0x65, 0x20, 0x3d, 0x20, 0x66, 0x75, 0x6e, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x28,
+    0x61, 0x2c, 0x76, 0x2c, 0x66, 0x2c, 0x77, 0x29, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x6c, 0x6f, 0x63,
+    0x61, 0x6c, 0x20, 0x6d, 0x61, 0x73, 0x6b, 0x20, 0x3d, 0x20, 0x32, 0x5e, 0x28, 0x77, 0x20, 0x6f,
+    0x72, 0x20, 0x31, 0x29, 0x2d, 0x31, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x72, 0x65, 0x74, 0x75, 0x72,
+    0x6e, 0x20, 0x62, 0x61, 0x6e, 0x64, 0x28, 0x61, 0x2c, 0x62, 0x6e, 0x6f, 0x74, 0x28, 0x6c, 0x73,
+    0x68, 0x69, 0x66, 0x74, 0x28, 0x6d, 0x61, 0x73, 0x6b, 0x2c, 0x66, 0x29, 0x29, 0x29, 0x2b, 0x6c,
+    0x73, 0x68, 0x69, 0x66, 0x74, 0x28, 0x62, 0x61, 0x6e, 0x64, 0x28, 0x76, 0x2c, 0x6d, 0x61, 0x73,
+    0x6b, 0x29, 0x2c, 0x66, 0x29, 0x0a, 0x20, 0x20, 0x65, 0x6e, 0x64, 0x2c, 0x0a, 0x20, 0x20, 0x72,
+    0x72, 0x6f, 0x74, 0x61, 0x74, 0x65, 0x20, 0x3d, 0x20, 0x62, 0x69, 0x74, 0x2e, 0x72, 0x6f, 0x72,
+    0x2c, 0x0a, 0x20, 0x20, 0x72, 0x73, 0x68, 0x69, 0x66, 0x74, 0x20, 0x20, 0x3d, 0x20, 0x72, 0x73,
+    0x68, 0x69, 0x66, 0x74, 0x2c, 0x0a, 0x7d, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
+    0x5d, 0x5d, 0x20, 0x29, 0x0a, 0x0a, 0x65, 0x6c, 0x73, 0x65, 0x0a, 0x0a, 0x20, 0x20, 0x20, 0x20,
+    0x2d, 0x2d, 0x20, 0x68, 0x6f, 0x70, 0x65, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x74, 0x68, 0x65, 0x20,
+    0x62, 0x65, 0x73, 0x74, 0x20, 0x6f, 0x72, 0x20, 0x66, 0x61, 0x69, 0x6c, 0x0a, 0x0a, 0x20, 0x20,
+    0x20, 0x20, 0x62, 0x69, 0x74, 0x33, 0x32, 0x20, 0x3d, 0x20, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72,
+    0x65, 0x28, 0x22, 0x62, 0x69, 0x74, 0x33, 0x32, 0x22, 0x29, 0x0a, 0x0a, 0x65, 0x6e, 0x64, 0x0a,
+    0x0a, 0x2d, 0x2d, 0x20, 0x74, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20, 0x6e, 0x65, 0x65, 0x64,
+    0x65, 0x64, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x67, 0x65, 0x74, 0x74, 0x69, 0x6e, 0x67, 0x20, 0x72,
+    0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x28, 0x22, 0x73, 0x6f, 0x63, 0x6b, 0x65, 0x74, 0x22, 0x29,
+    0x20, 0x72, 0x69, 0x67, 0x68, 0x74, 0x0a, 0x0a, 0x64, 0x6f, 0x0a, 0x0a, 0x20, 0x20, 0x20, 0x20,
+    0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x20, 0x6c, 0x6f, 0x61, 0x64, 0x65, 0x64, 0x20, 0x3d, 0x20, 0x70,
+    0x61, 0x63, 0x6b, 0x61, 0x67, 0x65, 0x2e, 0x6c, 0x6f, 0x61, 0x64, 0x65, 0x64, 0x0a, 0x0a, 0x20,
+    0x20, 0x20, 0x20, 0x69, 0x66, 0x20, 0x6e, 0x6f, 0x74, 0x20, 0x6c, 0x6f, 0x61, 0x64, 0x65, 0x64,
+    0x2e, 0x73, 0x6f, 0x63, 0x6b, 0x65, 0x74, 0x20, 0x74, 0x68, 0x65, 0x6e, 0x20, 0x6c, 0x6f, 0x61,
+    0x64, 0x65, 0x64, 0x2e, 0x73, 0x6f, 0x63, 0x6b, 0x65, 0x74, 0x20, 0x3d, 0x20, 0x6c, 0x6f, 0x61,
+    0x64, 0x65, 0x64, 0x5b, 0x22, 0x73, 0x6f, 0x63, 0x6b, 0x65, 0x74, 0x2e, 0x63, 0x6f, 0x72, 0x65,
+    0x22, 0x5d, 0x20, 0x65, 0x6e, 0x64, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x69, 0x66, 0x20, 0x6e, 0x6f,
+    0x74, 0x20, 0x6c, 0x6f, 0x61, 0x64, 0x65, 0x64, 0x2e, 0x6d, 0x69, 0x6d, 0x65, 0x20, 0x20, 0x20,
+    0x74, 0x68, 0x65, 0x6e, 0x20, 0x6c, 0x6f, 0x61, 0x64, 0x65, 0x64, 0x2e, 0x6d, 0x69, 0x6d, 0x65,
+    0x20, 0x20, 0x20, 0x3d, 0x20, 0x6c, 0x6f, 0x61, 0x64, 0x65, 0x64, 0x5b, 0x22, 0x6d, 0x69, 0x6d,
+    0x65, 0x2e, 0x63, 0x6f, 0x72, 0x65, 0x22, 0x5d, 0x20, 0x20, 0x20, 0x65, 0x6e, 0x64, 0x0a, 0x0a,
+    0x65, 0x6e, 0x64, 0x0a, 0x0a, 0x2d, 0x2d, 0x20, 0x73, 0x6f, 0x20, 0x66, 0x61, 0x72, 0x0a, 0x0a, 0x00
   };
   return luaL_dostring(L, (const char*) luatex_core_lua);
 }
\ No newline at end of file
--- texlive-bin.orig/texk/web2c/luatexdir/lua/luatex-core.lua
+++ texlive-bin/texk/web2c/luatexdir/lua/luatex-core.lua
@@ -1,465 +1,419 @@
--- luatex-core security and io overloads ...........
-
--- if not modules then modules = { } end modules ['luatex-core'] = {
---     version   = 1.080,
---     comment   = 'companion to luatex',
---     author    = 'Hans Hagen & Luigi Scarso',
---     copyright = 'LuaTeX Development Team',
--- }
-
-LUATEXCOREVERSION = 1.080 -- we reflect the luatex version where changes happened
-
--- This file overloads some Lua functions. The readline variants provide the same
--- functionality as LuaTeX <= 1.04 and doing it this way permits us to keep the
--- original io libraries clean. Performance is probably even a bit better now.
-
--- We test for functions already being defined so that we don't overload ones that
--- are provided in the startup script.
-
-local type, next, getmetatable, require = type, next, getmetatable, require
-local find, gsub, format = string.find, string.gsub, string.format
-
-local io_open             = io.open
-local io_popen            = io.popen
-local io_lines            = io.lines
-
-local fio_readline        = fio.readline
-local fio_checkpermission = fio.checkpermission
-local fio_recordfilename  = fio.recordfilename
-
-local mt                  = getmetatable(io.stderr)
-local mt_lines            = mt.lines
-local saferoption         = status.safer_option
-local shellescape         = status.shell_escape -- 0 (disabled) 1 (anything) 2 (restricted)
-local kpseused            = status.kpse_used    -- 0 1
-
-local write_nl            = texio.write_nl
-
-io.saved_lines            = io_lines -- always readonly
-mt.saved_lines            = mt_lines -- always readonly
-
-local function luatex_io_open(name,how)
-    if not how then
-        how = 'r'
-    end
-    local f = io_open(name,how)
-    if f then
-        if type(how) == 'string' and find(how,'w') then
-            fio_recordfilename(name,'w')
-        else
-            fio_recordfilename(name,'r')
-        end
-    end
-    return f
-end
-
-local function luatex_io_open_readonly(name,how)
-    if how then
-        how = 'r'
-    else
-        how = gsub(how,'[^rb]','')
-        if how == '' then
-            how = 'r'
-        end
-    end
-    local f = io_open(name,how)
-    if f then
-        fio_recordfilename(name,'r')
-    end
-    return f
-end
-
-local function luatex_io_popen(name,...)
-    local okay, found = fio_checkpermission(name)
-    if okay and found then
-        return io_popen(found,...)
-    end
-end
-
--- local function luatex_io_lines(name,how)
---     if name then
---         local f = io_open(name,how or 'r')
---         if f then
---             return function()
---                 return fio_readline(f)
---             end
---         end
---     else
---         return io_lines()
---     end
--- end
-
--- For some reason the gc doesn't kick in so we need to close explitly
--- so that the handle is flushed.
-
-local error, type = error, type
-
-local function luatex_io_lines(name,how)
-    if type(name) == "string" then
-        local f = io_open(name,how or 'r')
-        if f then
-            return function()
-                local l = fio_readline(f)
-                if not l then
-                    f:close()
-                end
-                return l
-            end
-        else
-            -- for those who like it this way:
-            error("patched 'io.lines' can't open '" .. name .. "'")
-        end
-    else
-        return io_lines()
-    end
-end
-
-local function luatex_io_readline(f)
-    return function()
-        return fio_readline(f)
-    end
-end
-
-io.lines = luatex_io_lines
-mt.lines = luatex_io_readline
-
--- We assume management to be provided by the replacement of kpse. This is the
--- case in ConTeXt.
-
-if kpseused == 1 then
-
-    io.open  = luatex_io_open
-    io.popen = luatex_io_popen
-
-end
-
-if saferoption == 1 then
-
-    local function installdummy(str,f)
-        local reported = false
-        return function(...)
-            if not reported then
-                write_nl(format("safer option set, function %q is %s",
-                    str,f and "limited" or "disabled"))
-                reported = true
-            end
-            if f then
-                return f(...)
-            end
-        end
-    end
-
-    local function installlimit(str,f)
-        local reported = false
-    end
-
-    os.execute = installdummy("os.execute")
-    os.spawn   = installdummy("os.spawn")
-    os.exec    = installdummy("os.exec")
-    os.setenv  = installdummy("os.setenv")
-    os.tempdir = installdummy("os.tempdir")
-
-    io.popen   = installdummy("io.popen")
-    io.open    = installdummy("io.open",luatex_io_open_readonly)
-
-    os.rename  = installdummy("os.rename")
-    os.remove  = installdummy("os.remove")
-
-    io.tmpfile = installdummy("io.tmpfile")
-    io.output  = installdummy("io.output")
-
-    lfs.chdir  = installdummy("lfs.chdir")
-    lfs.lock   = installdummy("lfs.lock")
-    lfs.touch  = installdummy("lfs.touch")
-    lfs.rmdir  = installdummy("lfs.rmdir")
-    lfs.mkdir  = installdummy("lfs.mkdir")
-
-end
-
-if saferoption == 1 or shellescape ~= 1 then
-
-    ffi = require('ffi')
-    for k, v in next, ffi do
-        if k ~= 'gc' then
-            ffi[k] = nil
-        end
-    end
-    ffi = nil
-
-end
-
--- os.[execute|os.spawn|os.exec] already are shellescape aware)
-
-
-if md5 then
-
-    local sum    = md5.sum
-    local gsub   = string.gsub
-    local format = string.format
-    local byte   = string.byte
-
-    if not md5.sumhexa then
-        function md5.sumhexa(k)
-            return (gsub(sum(k), ".", function(c)
-                return format("%02x",byte(c))
-            end))
-        end
-    end
-
-    if not md5.sumHEXA then
-        function md5.sumHEXA(k)
-            return (gsub(sum(k), ".", function(c)
-                return format("%02X",byte(c))
-            end))
-        end
-    end
-
-end
-
--- compatibility: this might go away
-
-if not unpack then
-    unpack = table.unpack
-end
-
-if not package.loaders then
-    package.loaders = package.searchers
-end
-
-if not loadstring then
-    loadstring = load
-end
-
--- compatibility: this might stay
-
-if bit32 then
-
-    -- lua 5.2: we're okay
-
-elseif utf8 then
-
-    -- lua 5.3:  bitwise.lua, v 1.24 2014/12/26 17:20:53 roberto
-
-    bit32 = load ( [[
-local select = select -- instead of: arg = { ... }
-
-bit32 = {
-  bnot = function (a)
-    return ~a & 0xFFFFFFFF
-  end,
-  band = function (x, y, z, ...)
-    if not z then
-      return ((x or -1) & (y or -1)) & 0xFFFFFFFF
-    else
-      local res = x & y & z
-      for i=1,select("#",...) do
-        res = res & select(i,...)
-      end
-      return res & 0xFFFFFFFF
-    end
-  end,
-  bor = function (x, y, z, ...)
-    if not z then
-      return ((x or 0) | (y or 0)) & 0xFFFFFFFF
-    else
-      local res = x | y | z
-      for i=1,select("#",...) do
-        res = res | select(i,...)
-      end
-      return res & 0xFFFFFFFF
-    end
-  end,
-  bxor = function (x, y, z, ...)
-    if not z then
-      return ((x or 0) ~ (y or 0)) & 0xFFFFFFFF
-    else
-      local res = x ~ y ~ z
-      for i=1,select("#",...) do
-        res = res ~ select(i,...)
-      end
-      return res & 0xFFFFFFFF
-    end
-  end,
-  btest = function (x, y, z, ...)
-    if not z then
-      return (((x or -1) & (y or -1)) & 0xFFFFFFFF) ~= 0
-    else
-      local res = x & y & z
-      for i=1,select("#",...) do
-          res = res & select(i,...)
-      end
-      return (res & 0xFFFFFFFF) ~= 0
-    end
-  end,
-  lshift = function (a, b)
-    return ((a & 0xFFFFFFFF) << b) & 0xFFFFFFFF
-  end,
-  rshift = function (a, b)
-    return ((a & 0xFFFFFFFF) >> b) & 0xFFFFFFFF
-  end,
-  arshift = function (a, b)
-    a = a & 0xFFFFFFFF
-    if b <= 0 or (a & 0x80000000) == 0 then
-      return (a >> b) & 0xFFFFFFFF
-    else
-      return ((a >> b) | ~(0xFFFFFFFF >> b)) & 0xFFFFFFFF
-    end
-  end,
-  lrotate = function (a ,b)
-    b = b & 31
-    a = a & 0xFFFFFFFF
-    a = (a << b) | (a >> (32 - b))
-    return a & 0xFFFFFFFF
-  end,
-  rrotate = function (a, b)
-    b = -b & 31
-    a = a & 0xFFFFFFFF
-    a = (a << b) | (a >> (32 - b))
-    return a & 0xFFFFFFFF
-  end,
-  extract = function (a, f, w)
-    return (a >> f) & ~(-1 << (w or 1))
-  end,
-  replace = function (a, v, f, w)
-    local mask = ~(-1 << (w or 1))
-    return ((a & ~(mask << f)) | ((v & mask) << f)) & 0xFFFFFFFF
-  end,
-}
-        ]] )
-
-elseif bit then
-
-    -- luajit (for now)
-
-    bit32 = load ( [[
-local band, bnot, rshift, lshift = bit.band, bit.bnot, bit.rshift, bit.lshift
-
-bit32 = {
-  arshift = bit.arshift,
-  band    = band,
-  bnot    = bnot,
-  bor     = bit.bor,
-  bxor    = bit.bxor,
-  btest   = function(...)
-    return band(...) ~= 0
-  end,
-  extract = function(a,f,w)
-    return band(rshift(a,f),2^(w or 1)-1)
-  end,
-  lrotate = bit.rol,
-  lshift  = lshift,
-  replace = function(a,v,f,w)
-    local mask = 2^(w or 1)-1
-    return band(a,bnot(lshift(mask,f)))+lshift(band(v,mask),f)
-  end,
-  rrotate = bit.ror,
-  rshift  = rshift,
-}
-        ]] )
-
-else
-
-    -- hope for the best or fail
-
-    bit32 = require("bit32")
-
-end
-
--- this is needed for getting require("socket") right
-
-do
-
-    local loaded = package.loaded
-
-    if not loaded.socket then loaded.socket = loaded["socket.core"] end
-    if not loaded.mime   then loaded.mime   = loaded["mime.core"]   end
-
-end
-
-do
-
-    local lfsattributes     = lfs.attributes
-    local symlinkattributes = lfs.symlinkattributes
-
-    -- these can now be done using lfs (was dead slow before)
-
-    if not lfs.isfile then
-        function lfs.isfile(name)
-            local m = lfsattributes(name,"mode")
-            return m == "file" or m == "link"
-        end
-    end
-
-    if not lfs.isdir then
-        function lfs.isdir(name)
-            local m = lfsattributes(name,"mode")
-            return m == "directory"
-        end
-    end
-
-    -- shortnames have also be sort of dropped from kpse
-
-    if not lfs.shortname then
-        function lfs.shortname(name)
-            return name
-        end
-    end
-
-    -- now there is a target field, so ...
-
-    if not lfs.readlink then
-        function lfs.readlink(name)
-            return symlinkattributes(name,"target") or nil
-        end
-    end
-
-end
-
--- so far
-
-if utilities and utilities.merger and utilities.merger.compact then
-
-    local byte, format, gmatch = string.byte, string.format, string.gmatch
-    local concat = table.concat
-
-    local data = gsub(io.loaddata('luatex-core.lua'),'if%s+utilities.*','')
-
-    local t = { }
-    local r = { }
-    local n = 0
-    local d = gsub(data,'\r\n','\n')      -- be nice for unix
-    local s = utilities.merger.compact(d) -- no comments and less spaces
-
-    t[#t+1] = '/* generated from and by luatex-core.lua */'
-    t[#t+1] = ''
- -- t[#t+1] = format('/*\n\n%s\n\n*/',d)
- -- t[#t+1] = ''
-    t[#t+1] = '#include "lua.h"'
-    t[#t+1] = '#include "lauxlib.h"'
-    t[#t+1] = ''
-    t[#t+1] = 'int load_luatex_core_lua (lua_State * L);'
-    t[#t+1] = ''
-    t[#t+1] = 'int load_luatex_core_lua (lua_State * L)'
-    t[#t+1] = '{'
-    t[#t+1] = '  static unsigned char luatex_core_lua[] = {'
-    for c in gmatch(d,'.') do
-        if n == 16 then
-            n = 1
-            t[#t+1] = '    ' .. concat(r,', ') .. ','
-        else
-            n = n + 1
-        end
-        r[n] = format('0x%02x',byte(c))
-    end
-    n = n + 1
-    r[n] = '0x00'
-    t[#t+1] = '    ' .. concat(r,', ',1,n)
-    t[#t+1] = '  };'
- -- t[#t+1] = format('unsigned int luatex_core_lua_len = 0x%x;',#d+1)
-    t[#t+1] = '  return luaL_dostring(L, (const char*) luatex_core_lua);'
-    t[#t+1] = '}'
-
-    io.savedata('luatex-core.c',concat(t,'\n'))
-    io.savedata('luatex-core-stripped.lua',s)
-
-end
+-- luatex-core security and io overloads ...........
+
+-- if not modules then modules = { } end modules ['luatex-core'] = {
+--     version   = 1.005,
+--     comment   = 'companion to luatex',
+--     author    = 'Hans Hagen & Luigi Scarso',
+--     copyright = 'LuaTeX Development Team',
+-- }
+
+LUATEXCOREVERSION = 1.005
+
+-- This file overloads some Lua functions. The readline variants provide the same
+-- functionality as LuaTeX <= 1.04 and doing it this way permits us to keep the
+-- original io libraries clean. Performance is probably even a bit better now.
+
+local type, next, getmetatable, require = type, next, getmetatable, require
+local find, gsub, format = string.find, string.gsub, string.format
+
+local io_open             = io.open
+local io_popen            = io.popen
+local io_lines            = io.lines
+
+local fio_readline        = fio.readline
+local fio_checkpermission = fio.checkpermission
+local fio_recordfilename  = fio.recordfilename
+
+local mt                  = getmetatable(io.stderr)
+local mt_lines            = mt.lines
+local saferoption         = status.safer_option
+local shellescape         = status.shell_escape -- 0 (disabled) 1 (anything) 2 (restricted)
+local kpseused            = status.kpse_used    -- 0 1
+
+local write_nl            = texio.write_nl
+
+io.saved_lines            = io_lines -- always readonly
+mt.saved_lines            = mt_lines -- always readonly
+
+local function luatex_io_open(name,how)
+    if not how then
+        how = 'r'
+    end
+    local f = io_open(name,how)
+    if f then
+        if type(how) == 'string' and find(how,'w') then
+            fio_recordfilename(name,'w')
+        else
+            fio_recordfilename(name,'r')
+        end
+    end
+    return f
+end
+
+local function luatex_io_open_readonly(name,how)
+    if how then
+        how = 'r'
+    else
+        how = gsub(how,'[^rb]','')
+        if how == '' then
+            how = 'r'
+        end
+    end
+    local f = io_open(name,how)
+    if f then
+        fio_recordfilename(name,'r')
+    end
+    return f
+end
+
+local function luatex_io_popen(name,...)
+    local okay, found = fio_checkpermission(name)
+    if okay and found then
+        return io_popen(found,...)
+    end
+end
+
+-- local function luatex_io_lines(name,how)
+--     if name then
+--         local f = io_open(name,how or 'r')
+--         if f then
+--             return function()
+--                 return fio_readline(f)
+--             end
+--         end
+--     else
+--         return io_lines()
+--     end
+-- end
+
+-- For some reason the gc doesn't kick in so we need to close explitly
+-- so that the handle is flushed.
+
+local error, type = error, type
+
+local function luatex_io_lines(name,how)
+    if type(name) == "string" then
+        local f = io_open(name,how or 'r')
+        if f then
+            return function()
+                local l = fio_readline(f)
+                if not l then
+                    f:close()
+                end
+                return l
+            end
+        else
+            -- for those who like it this way:
+            error("patched 'io.lines' can't open '" .. name .. "'")
+        end
+    else
+        return io_lines()
+    end
+end
+
+local function luatex_io_readline(f)
+    return function()
+        return fio_readline(f)
+    end
+end
+
+io.lines = luatex_io_lines
+mt.lines = luatex_io_readline
+
+-- We assume management to be provided by the replacement of kpse. This is the
+-- case in ConTeXt.
+
+if kpseused == 1 then
+
+    io.open  = luatex_io_open
+    io.popen = luatex_io_popen
+
+end
+
+if saferoption == 1 then
+
+    local function installdummy(str,f)
+        local reported = false
+        return function(...)
+            if not reported then
+                write_nl(format("safer option set, function %q is %s",
+                    str,f and "limited" or "disabled"))
+                reported = true
+            end
+            if f then
+                return f(...)
+            end
+        end
+    end
+
+    local function installlimit(str,f)
+        local reported = false
+    end
+
+    os.execute = installdummy("os.execute")
+    os.spawn   = installdummy("os.spawn")
+    os.exec    = installdummy("os.exec")
+    os.setenv  = installdummy("os.setenv")
+    os.tempdir = installdummy("os.tempdir")
+
+    io.popen   = installdummy("io.popen")
+    io.open    = installdummy("io.open",luatex_io_open_readonly)
+
+    os.rename  = installdummy("os.rename")
+    os.remove  = installdummy("os.remove")
+
+    io.tmpfile = installdummy("io.tmpfile")
+    io.output  = installdummy("io.output")
+
+    lfs.chdir  = installdummy("lfs.chdir")
+    lfs.lock   = installdummy("lfs.lock")
+    lfs.touch  = installdummy("lfs.touch")
+    lfs.rmdir  = installdummy("lfs.rmdir")
+    lfs.mkdir  = installdummy("lfs.mkdir")
+
+end
+
+if saferoption == 1 or shellescape ~= 1 then
+
+    ffi = require('ffi')
+    for k, v in next, ffi do
+        if k ~= 'gc' then
+            ffi[k] = nil
+        end
+    end
+    ffi = nil
+
+end
+
+-- os.[execute|os.spawn|os.exec] already are shellescape aware)
+
+
+if md5 then
+
+    local sum    = md5.sum
+    local gsub   = string.gsub
+    local format = string.format
+    local byte   = string.byte
+
+    function md5.sumhexa(k)
+        return (gsub(sum(k), ".", function(c)
+            return format("%02x",byte(c))
+        end))
+    end
+
+    function md5.sumHEXA(k)
+        return (gsub(sum(k), ".", function(c)
+            return format("%02X",byte(c))
+        end))
+    end
+
+end
+
+-- compatibility: this might go away
+
+if not unpack then
+    unpack = table.unpack
+end
+
+if not package.loaders then
+    package.loaders = package.searchers
+end
+
+if not loadstring then
+    loadstring = load
+end
+
+-- compatibility: this might stay
+
+if bit32 then
+
+    -- lua 5.2: we're okay
+
+elseif utf8 then
+
+    -- lua 5.3:  bitwise.lua, v 1.24 2014/12/26 17:20:53 roberto
+
+    bit32 = load ( [[
+local select = select -- instead of: arg = { ... }
+
+bit32 = {
+  bnot = function (a)
+    return ~a & 0xFFFFFFFF
+  end,
+  band = function (x, y, z, ...)
+    if not z then
+      return ((x or -1) & (y or -1)) & 0xFFFFFFFF
+    else
+      local res = x & y & z
+      for i=1,select("#",...) do
+        res = res & select(i,...)
+      end
+      return res & 0xFFFFFFFF
+    end
+  end,
+  bor = function (x, y, z, ...)
+    if not z then
+      return ((x or 0) | (y or 0)) & 0xFFFFFFFF
+    else
+      local res = x | y | z
+      for i=1,select("#",...) do
+        res = res | select(i,...)
+      end
+      return res & 0xFFFFFFFF
+    end
+  end,
+  bxor = function (x, y, z, ...)
+    if not z then
+      return ((x or 0) ~ (y or 0)) & 0xFFFFFFFF
+    else
+      local res = x ~ y ~ z
+      for i=1,select("#",...) do
+        res = res ~ select(i,...)
+      end
+      return res & 0xFFFFFFFF
+    end
+  end,
+  btest = function (x, y, z, ...)
+    if not z then
+      return (((x or -1) & (y or -1)) & 0xFFFFFFFF) ~= 0
+    else
+      local res = x & y & z
+      for i=1,select("#",...) do
+          res = res & select(i,...)
+      end
+      return (res & 0xFFFFFFFF) ~= 0
+    end
+  end,
+  lshift = function (a, b)
+    return ((a & 0xFFFFFFFF) << b) & 0xFFFFFFFF
+  end,
+  rshift = function (a, b)
+    return ((a & 0xFFFFFFFF) >> b) & 0xFFFFFFFF
+  end,
+  arshift = function (a, b)
+    a = a & 0xFFFFFFFF
+    if b <= 0 or (a & 0x80000000) == 0 then
+      return (a >> b) & 0xFFFFFFFF
+    else
+      return ((a >> b) | ~(0xFFFFFFFF >> b)) & 0xFFFFFFFF
+    end
+  end,
+  lrotate = function (a ,b)
+    b = b & 31
+    a = a & 0xFFFFFFFF
+    a = (a << b) | (a >> (32 - b))
+    return a & 0xFFFFFFFF
+  end,
+  rrotate = function (a, b)
+    b = -b & 31
+    a = a & 0xFFFFFFFF
+    a = (a << b) | (a >> (32 - b))
+    return a & 0xFFFFFFFF
+  end,
+  extract = function (a, f, w)
+    return (a >> f) & ~(-1 << (w or 1))
+  end,
+  replace = function (a, v, f, w)
+    local mask = ~(-1 << (w or 1))
+    return ((a & ~(mask << f)) | ((v & mask) << f)) & 0xFFFFFFFF
+  end,
+}
+        ]] )
+
+elseif bit then
+
+    -- luajit (for now)
+
+    bit32 = load ( [[
+local band, bnot, rshift, lshift = bit.band, bit.bnot, bit.rshift, bit.lshift
+
+bit32 = {
+  arshift = bit.arshift,
+  band    = band,
+  bnot    = bnot,
+  bor     = bit.bor,
+  bxor    = bit.bxor,
+  btest   = function(...)
+    return band(...) ~= 0
+  end,
+  extract = function(a,f,w)
+    return band(rshift(a,f),2^(w or 1)-1)
+  end,
+  lrotate = bit.rol,
+  lshift  = lshift,
+  replace = function(a,v,f,w)
+    local mask = 2^(w or 1)-1
+    return band(a,bnot(lshift(mask,f)))+lshift(band(v,mask),f)
+  end,
+  rrotate = bit.ror,
+  rshift  = rshift,
+}
+        ]] )
+
+else
+
+    -- hope for the best or fail
+
+    bit32 = require("bit32")
+
+end
+
+-- this is needed for getting require("socket") right
+
+do
+
+    local loaded = package.loaded
+
+    if not loaded.socket then loaded.socket = loaded["socket.core"] end
+    if not loaded.mime   then loaded.mime   = loaded["mime.core"]   end
+
+end
+
+-- so far
+
+if utilities and utilities.merger and utilities.merger.compact then
+
+    local byte, format, gmatch = string.byte, string.format, string.gmatch
+    local concat = table.concat
+
+    local data = gsub(io.loaddata('luatex-core.lua'),'if%s+utilities.*','')
+
+    local t = { }
+    local r = { }
+    local n = 0
+    local d = gsub(data,'\r\n','\n')      -- be nice for unix
+    local s = utilities.merger.compact(d) -- no comments and less spaces
+
+    t[#t+1] = '/* generated from and by luatex-core.lua */'
+    t[#t+1] = ''
+ -- t[#t+1] = format('/*\n\n%s\n\n*/',d)
+ -- t[#t+1] = ''
+    t[#t+1] = '#include "lua.h"'
+    t[#t+1] = '#include "lauxlib.h"'
+    t[#t+1] = ''
+    t[#t+1] = 'int load_luatex_core_lua (lua_State * L);'
+    t[#t+1] = ''
+    t[#t+1] = 'int load_luatex_core_lua (lua_State * L)'
+    t[#t+1] = '{'
+    t[#t+1] = '  static unsigned char luatex_core_lua[] = {'
+    for c in gmatch(d,'.') do
+        if n == 16 then
+            n = 1
+            t[#t+1] = '    ' .. concat(r,', ') .. ','
+        else
+            n = n + 1
+        end
+        r[n] = format('0x%02x',byte(c))
+    end
+    n = n + 1
+    r[n] = '0x00'
+    t[#t+1] = '    ' .. concat(r,', ',1,n)
+    t[#t+1] = '  };'
+ -- t[#t+1] = format('unsigned int luatex_core_lua_len = 0x%x;',#d+1)
+    t[#t+1] = '  return luaL_dostring(L, (const char*) luatex_core_lua);'
+    t[#t+1] = '}'
+
+    io.savedata('luatex-core.c',concat(t,'\n'))
+    io.savedata('luatex-core-stripped.lua',s)
+
+end
--- texlive-bin.orig/texk/web2c/luatexdir/luafontloader/fontforge/fontforge/parsepfa.c
+++ texlive-bin/texk/web2c/luatexdir/luafontloader/fontforge/fontforge/parsepfa.c
@@ -2667,9 +2667,9 @@ static void FontInfoFree(struct fontinfo
 void PSFontFree(FontDict *fd) {
     int i;
 
-    /*if ( fd->encoding!=NULL ): useless: fd->encoding is *char[256] */
-    for ( i=0; i<256; ++i )
-       free( fd->encoding[i]);
+    if ( fd->encoding!=NULL )
+	for ( i=0; i<256; ++i )
+	    free( fd->encoding[i]);
     free(fd->fontname);
     free(fd->cidfontname);
     free(fd->registry);
--- texlive-bin.orig/texk/web2c/luatexdir/luafontloader/src/luafflib.c
+++ texlive-bin/texk/web2c/luatexdir/luafontloader/src/luafflib.c
@@ -358,7 +358,7 @@ static void dump_intfield(lua_State * L,
 {
     lua_checkstack(L, 2);
     lua_pushstring(L, name);
-    lua_pushinteger(L, field);
+    lua_pushnumber(L, field);
     lua_rawset(L, -3);
 }
 
@@ -366,7 +366,7 @@ static void dump_uintfield(lua_State * L
 {
     lua_checkstack(L, 2);
     lua_pushstring(L, name);
-    lua_pushinteger(L, field);
+    lua_pushnumber(L, field);
     lua_rawset(L, -3);
 }
 
@@ -465,7 +465,7 @@ static void dump_subtable_name(lua_State
     next = b; \
     while (next != NULL) { \
         lua_checkstack(L,2); \
-        lua_pushinteger(L,k); k++; \
+        lua_pushnumber(L,k); k++; \
         lua_createtable(L,0,c); \
         a(L, next); \
         lua_rawset(L,-3); \
@@ -478,7 +478,7 @@ static void dump_subtable_name(lua_State
     next = b; \
     while (next != NULL) { \
         lua_checkstack(L,2); \
-        lua_pushinteger(L,k); k++; \
+        lua_pushnumber(L,k); k++; \
         lua_createtable(L,0,d); \
         if (a(L, next, c)) \
             lua_rawset(L,-3); \
@@ -498,7 +498,7 @@ static void do_handle_scriptlanglist(lua
     lua_newtable(L);
     for (k = 0; k < MAX_LANG; k++) {
         if (sl->langs[k] != 0) {
-            lua_pushinteger(L, (k + 1));
+            lua_pushnumber(L, (k + 1));
             lua_pushstring(L, make_tag_string(sl->langs[k]));
             lua_rawset(L, -3);
         }
@@ -506,7 +506,7 @@ static void do_handle_scriptlanglist(lua
 
     if (sl->lang_cnt >= MAX_LANG) {
         for (k = MAX_LANG; k < sl->lang_cnt; k++) {
-            lua_pushinteger(L, (k + 1));
+            lua_pushnumber(L, (k + 1));
             lua_pushstring(L, make_tag_string(sl->morelangs[k - MAX_LANG]));
             lua_rawset(L, -3);
         }
@@ -672,7 +672,7 @@ static void handle_splinecharlist(lua_St
     lua_checkstack(L, 10);
     while (next != NULL) {
         if (next->sc != NULL) {
-            lua_pushinteger(L, k);
+            lua_pushnumber(L, k);
             k++;
             lua_pushstring(L, next->sc->name);
             lua_rawset(L, -3);
@@ -772,8 +772,8 @@ static void do_handle_generic_pst(lua_St
         }
     } else if (pst->type == pst_lcaret) {
         for (k = 0; k < pst->u.lcaret.cnt; k++) {
-            lua_pushinteger(L, (k + 1));
-            lua_pushinteger(L, pst->u.lcaret.carets[k]);
+            lua_pushnumber(L, (k + 1));
+            lua_pushnumber(L, pst->u.lcaret.carets[k]);
             lua_rawset(L, -3);
         }
     }
@@ -800,7 +800,7 @@ static void handle_generic_pst(lua_State
                 lua_getfield(L, -1, next->subtable->subtable_name);
             }
             k = lua_rawlen(L, -1) + 1;
-            lua_pushinteger(L, k);
+            lua_pushnumber(L, k);
             lua_createtable(L, 0, 4);
             do_handle_generic_pst(L, next);
             lua_rawset(L, -3);
@@ -808,7 +808,7 @@ static void handle_generic_pst(lua_State
             lua_pop(L, 1);      /* pop the subtable */
         } else {
             /* Found a pst without subtable, or without subtable name */
-            lua_pushinteger(L, l);
+            lua_pushnumber(L, l);
             l++;
             lua_createtable(L, 0, 4);
             do_handle_generic_pst(L, next);
@@ -970,17 +970,17 @@ static void handle_splinechar(lua_State
     dump_stringfield(L, "name", glyph->name);
     dump_intfield(L, "unicode", glyph->unicodeenc);
     lua_createtable(L, 4, 0);
-    lua_pushinteger(L, 1);
-    lua_pushinteger(L, glyph->xmin);
+    lua_pushnumber(L, 1);
+    lua_pushnumber(L, glyph->xmin);
     lua_rawset(L, -3);
-    lua_pushinteger(L, 2);
-    lua_pushinteger(L, glyph->ymin);
+    lua_pushnumber(L, 2);
+    lua_pushnumber(L, glyph->ymin);
     lua_rawset(L, -3);
-    lua_pushinteger(L, 3);
-    lua_pushinteger(L, glyph->xmax);
+    lua_pushnumber(L, 3);
+    lua_pushnumber(L, glyph->xmax);
     lua_rawset(L, -3);
-    lua_pushinteger(L, 4);
-    lua_pushinteger(L, glyph->ymax);
+    lua_pushnumber(L, 4);
+    lua_pushnumber(L, glyph->ymax);
     lua_rawset(L, -3);
     lua_setfield(L, -2, "boundingbox");
     if (hasvmetrics) {
@@ -1260,21 +1260,21 @@ static void handle_pfminfo(lua_State * L
     dump_intfield(L, "os2_breakchar", pfm.os2_breakchar);
     if (pfm.hascodepages) {
         lua_newtable(L);
-        lua_pushinteger(L, pfm.codepages[0]);
+        lua_pushnumber(L, pfm.codepages[0]);
         lua_rawseti(L, -2, 1);
-        lua_pushinteger(L, pfm.codepages[1]);
+        lua_pushnumber(L, pfm.codepages[1]);
         lua_rawseti(L, -2, 2);
         lua_setfield(L, -2, "codepages");
     }
     if (pfm.hasunicoderanges) {
         lua_newtable(L);
-        lua_pushinteger(L, pfm.unicoderanges[0]);
+        lua_pushnumber(L, pfm.unicoderanges[0]);
         lua_rawseti(L, -2, 1);
-        lua_pushinteger(L, pfm.unicoderanges[1]);
+        lua_pushnumber(L, pfm.unicoderanges[1]);
         lua_rawseti(L, -2, 2);
-        lua_pushinteger(L, pfm.unicoderanges[2]);
+        lua_pushnumber(L, pfm.unicoderanges[2]);
         lua_rawseti(L, -2, 3);
-        lua_pushinteger(L, pfm.unicoderanges[3]);
+        lua_pushnumber(L, pfm.unicoderanges[3]);
         lua_rawseti(L, -2, 4);
         lua_setfield(L, -2, "unicoderanges");
     }
@@ -1292,8 +1292,8 @@ static char *do_handle_enc(lua_State * L
     if (enc->char_cnt && enc->unicode != NULL) {
         lua_createtable(L, enc->char_cnt, 1);
         for (i = 0; i < enc->char_cnt; i++) {
-            lua_pushinteger(L, i);
-            lua_pushinteger(L, enc->unicode[i]);
+            lua_pushnumber(L, i);
+            lua_pushnumber(L, enc->unicode[i]);
             lua_rawset(L, -3);
         }
         lua_setfield(L, -2, "unicode");
@@ -1302,7 +1302,7 @@ static char *do_handle_enc(lua_State * L
     if (enc->char_cnt && enc->psnames != NULL) {
         lua_createtable(L, enc->char_cnt, 1);
         for (i = 0; i < enc->char_cnt; i++) {
-            lua_pushinteger(L, i);
+            lua_pushnumber(L, i);
             lua_pushstring(L, enc->psnames[i]);
             lua_rawset(L, -3);
         }
@@ -1363,13 +1363,13 @@ static void handle_encmap(lua_State * L,
         for (i = 0; i < map->encmax; i++) {
             if (map->map[i] != -1) {
                 int l = map->map[i];
-                lua_pushinteger(L, i);
+                lua_pushnumber(L, i);
                 /*
                 if (l < notdef_loc)
-                    lua_pushinteger(L, (l + 1));
+                    lua_pushnumber(L, (l + 1));
                 else
                 */
-                    lua_pushinteger(L, l);
+                    lua_pushnumber(L, l);
                 lua_rawset(L, -3);
             }
         }
@@ -1382,11 +1382,11 @@ static void handle_encmap(lua_State * L,
             if (map->backmap[i] != -1) {
                 /*
                 if (i < notdef_loc)
-                    lua_pushinteger(L, (i + 1));
+                    lua_pushnumber(L, (i + 1));
                 else
                 */
-                    lua_pushinteger(L, i);
-                lua_pushinteger(L, map->backmap[i]);
+                    lua_pushnumber(L, i);
+                lua_pushnumber(L, map->backmap[i]);
                 lua_rawset(L, -3);
             }
         }
@@ -1488,7 +1488,7 @@ static int do_handle_kernclass(lua_State
     lua_checkstack(L, 4);
     lua_createtable(L, kerns->first_cnt, 1);
     for (k = 0; k < kerns->first_cnt; k++) {
-        lua_pushinteger(L, (k + 1));
+        lua_pushnumber(L, (k + 1));
         lua_pushstring(L, kerns->firsts[k]);
         lua_rawset(L, -3);
     }
@@ -1496,7 +1496,7 @@ static int do_handle_kernclass(lua_State
 
     lua_createtable(L, kerns->second_cnt, 1);
     for (k = 0; k < kerns->second_cnt; k++) {
-        lua_pushinteger(L, (k + 1));
+        lua_pushnumber(L, (k + 1));
         lua_pushstring(L, kerns->seconds[k]);
         lua_rawset(L, -3);
     }
@@ -1508,8 +1508,8 @@ static int do_handle_kernclass(lua_State
     lua_createtable(L, kerns->second_cnt * kerns->first_cnt, 1);
     for (k = 0; k < (kerns->second_cnt * kerns->first_cnt); k++) {
         if (kerns->offsets[k] != 0) {
-            lua_pushinteger(L, (k + 1));
-            lua_pushinteger(L, kerns->offsets[k]);
+            lua_pushnumber(L, (k + 1));
+            lua_pushnumber(L, kerns->offsets[k]);
             lua_rawset(L, -3);
         }
     }
@@ -1529,8 +1529,8 @@ static void handle_kernclass(lua_State *
       int kk;							\
       lua_newtable(L);					\
       for (kk=0;kk<cnt;kk++) {			\
-		lua_pushinteger(L,(kk+1));		\
-		lua_pushinteger(L,item[kk]);		\
+		lua_pushnumber(L,(kk+1));		\
+		lua_pushnumber(L,item[kk]);		\
 		lua_rawset(L,-3); }				\
       lua_setfield(L,-2,s); } }
 
@@ -1540,7 +1540,7 @@ static void handle_kernclass(lua_State *
       int kk;							\
       lua_newtable(L);					\
       for (kk=0;kk<cnt;kk++) {			\
-		lua_pushinteger(L,(kk+1));		\
+		lua_pushnumber(L,(kk+1));		\
 		lua_pushstring(L,item[kk]);		\
 		lua_rawset(L,-3); }				\
       lua_setfield(L,-2,s); } }
@@ -1550,7 +1550,7 @@ static void handle_kernclass(lua_State *
       int kk;								  \
       lua_newtable(L);						  \
       for (kk=0;kk<cnt;kk++) {				  \
-		lua_pushinteger(L,(kk));				  \
+		lua_pushnumber(L,(kk));				  \
 		lua_pushstring(L,item[kk]);			  \
 		lua_rawset(L,-3); }					  \
       lua_setfield(L,-2,s); } }
@@ -1609,7 +1609,7 @@ static void handle_fpst_rule(lua_State *
     if (rule->lookup_cnt > 0) {
         lua_newtable(L);
         for (k = 0; k < rule->lookup_cnt; k++) {
-            lua_pushinteger(L, (rule->lookups[k].seq + 1));
+            lua_pushnumber(L, (rule->lookups[k].seq + 1));
             if (rule->lookups[k].lookup != NULL) {
                 lua_pushstring(L, rule->lookups[k].lookup->lookup_name);
             } else {
@@ -1650,7 +1650,7 @@ static void do_handle_generic_fpst(lua_S
     if (fpst->rule_cnt > 0) {
         lua_createtable(L, fpst->rule_cnt, 1);
         for (k = 0; k < fpst->rule_cnt; k++) {
-            lua_pushinteger(L, (k + 1));
+            lua_pushnumber(L, (k + 1));
             lua_newtable(L);
             handle_fpst_rule(L, &(fpst->rules[k]), fpst->format);
             lua_rawset(L, -3);
@@ -1668,7 +1668,7 @@ static void handle_generic_fpst(lua_Stat
     if (fpst->subtable != NULL && fpst->subtable->subtable_name != NULL) {
         lua_pushstring(L, fpst->subtable->subtable_name);
     } else {
-        lua_pushinteger(L, k);
+        lua_pushnumber(L, k);
         k++;
     }
     lua_createtable(L, 0, 10);
@@ -1680,7 +1680,7 @@ static void handle_generic_fpst(lua_Stat
         if (next->subtable != NULL && next->subtable->subtable_name != NULL) {
             lua_pushstring(L, next->subtable->subtable_name);
         } else {
-            lua_pushinteger(L, k);
+            lua_pushnumber(L, k);
             k++;
         }
         lua_createtable(L, 0, 10);
@@ -1801,9 +1801,9 @@ static void handle_base(lua_State * L, s
             lua_newtable(L);
             for (i = 0; i < Base->baseline_cnt; i++) {
                 if (next->baseline_pos != NULL) /* default omitted */
-                    lua_pushinteger(L, next->baseline_pos[i]);
+                    lua_pushnumber(L, next->baseline_pos[i]);
                 else
-                    lua_pushinteger(L, 0);
+                    lua_pushnumber(L, 0);
                 lua_rawseti(L, -2, (i + 1));
             }
             lua_setfield(L, -2, "baseline");
@@ -1823,13 +1823,13 @@ static void handle_axismap(lua_State * L
     lua_checkstack(L, 3);
     lua_newtable(L);
     for (i = 0; i < am->points; i++) {
-        lua_pushinteger(L, am->blends[i]);
+        lua_pushnumber(L, am->blends[i]);
         lua_rawseti(L, -2, (i + 1));
     }
     lua_setfield(L, -2, "blends");
     lua_newtable(L);
     for (i = 0; i < am->points; i++) {
-        lua_pushinteger(L, am->designs[i]);
+        lua_pushnumber(L, am->designs[i]);
         lua_rawseti(L, -2, (i + 1));
     }
     lua_setfield(L, -2, "designs");
@@ -1853,7 +1853,7 @@ static void handle_mmset(lua_State * L,
     if (mm->instance_count > 0) {
         lua_newtable(L);
         for (i = 0; i < mm->instance_count * mm->axis_count; i++) {
-            lua_pushinteger(L, mm->positions[i]);
+            lua_pushnumber(L, mm->positions[i]);
             lua_rawseti(L, -2, (i + 1));
         }
         lua_setfield(L, -2, "positions");
@@ -1878,7 +1878,7 @@ static void handle_mmset(lua_State * L,
 
         lua_newtable(L);
         for (i = 0; i < mm->instance_count; i++) {
-            lua_pushinteger(L, mm->defweights[i]);
+            lua_pushnumber(L, mm->defweights[i]);
             lua_rawseti(L, -2, (i + 1));
         }
         lua_setfield(L, -2, "defweights");
@@ -1980,14 +1980,14 @@ static void handle_splinefont(lua_State
         }
         for (k = 0; k < l; k++) {
             if (sf->glyphs[k]) {
-                lua_pushinteger(L, (k + 1));
+                lua_pushnumber(L, (k + 1));
                 lua_createtable(L, 0, 12);
                 handle_splinechar(L, sf->glyphs[k], sf->hasvmetrics);
                 lua_rawset(L, -3);
             }
         }
         if (sf->glyphs != NULL && l < sf->glyphcnt) {
-            lua_pushinteger(L, 0);
+            lua_pushnumber(L, 0);
             if (sf->glyphs[l]) {
                 lua_createtable(L, 0, 12);
                 handle_splinechar(L, sf->glyphs[l], sf->hasvmetrics);
@@ -2000,7 +2000,7 @@ static void handle_splinefont(lua_State
     if ((l + 1) < sf->glyphcnt) {
         for (k = (l + 1); k < sf->glyphcnt; k++) {
             if (sf->glyphs[k]) {
-                lua_pushinteger(L, k);
+                lua_pushnumber(L, k);
                 lua_createtable(L, 0, 12);
                 handle_splinechar(L, sf->glyphs[k], sf->hasvmetrics);
                 lua_rawset(L, -3);
@@ -2098,8 +2098,8 @@ static void handle_splinefont(lua_State
         dump_enumfield(L, "type", sf->texdata.type, tex_type_enum);
         lua_newtable(L);
         for (k = 0; k < 22; k++) {
-            lua_pushinteger(L, k);
-            lua_pushinteger(L, sf->texdata.params[k]);
+            lua_pushnumber(L, k);
+            lua_pushnumber(L, sf->texdata.params[k]);
             lua_rawset(L, -3);
         }
         lua_setfield(L, -2, "params");
@@ -2590,7 +2590,7 @@ static int ff_glyph_index(lua_State * L)
             lua_pushstring(L, glyph->name);
             break;
         case GK_unicode:
-            lua_pushinteger(L, glyph->unicodeenc);
+            lua_pushnumber(L, glyph->unicodeenc);
             break;
         case GK_boundingbox:
             if (glyph->xmax == 0 && glyph->ymax == 0 && glyph->xmin == 0 && glyph->ymin == 0) {
@@ -2602,27 +2602,27 @@ static int ff_glyph_index(lua_State * L)
                 glyph->ymax = bb.maxy;
             }
             lua_createtable(L, 4, 0);
-            lua_pushinteger(L, 1);
-            lua_pushinteger(L, glyph->xmin);
+            lua_pushnumber(L, 1);
+            lua_pushnumber(L, glyph->xmin);
             lua_rawset(L, -3);
-            lua_pushinteger(L, 2);
-            lua_pushinteger(L, glyph->ymin);
+            lua_pushnumber(L, 2);
+            lua_pushnumber(L, glyph->ymin);
             lua_rawset(L, -3);
-            lua_pushinteger(L, 3);
-            lua_pushinteger(L, glyph->xmax);
+            lua_pushnumber(L, 3);
+            lua_pushnumber(L, glyph->xmax);
             lua_rawset(L, -3);
-            lua_pushinteger(L, 4);
-            lua_pushinteger(L, glyph->ymax);
+            lua_pushnumber(L, 4);
+            lua_pushnumber(L, glyph->ymax);
             lua_rawset(L, -3);
             break;
         case GK_vwidth:
-            lua_pushinteger(L, glyph->vwidth);
+            lua_pushnumber(L, glyph->vwidth);
             break;
         case GK_width:
-            lua_pushinteger(L, glyph->width);
+            lua_pushnumber(L, glyph->width);
             break;
         case GK_lsidebearing:
-            lua_pushinteger(L, glyph->lsidebearing);
+            lua_pushnumber(L, glyph->lsidebearing);
             break;
         case GK_class:
             if (glyph->glyph_class > 0) {
@@ -2692,31 +2692,31 @@ static int ff_glyph_index(lua_State * L)
             break;
         case GK_tex_height:
             if (glyph->tex_height != TEX_UNDEF) {
-                lua_pushinteger(L, glyph->tex_height);
+                lua_pushnumber(L, glyph->tex_height);
             } else {
                 lua_pushnil(L);
             }
             break;
         case GK_tex_depth:
             if (glyph->tex_height != TEX_UNDEF) {
-                lua_pushinteger(L, glyph->tex_depth);
+                lua_pushnumber(L, glyph->tex_depth);
             } else {
                 lua_pushnil(L);
             }
             break;
         case GK_is_extended_shape:
-            lua_pushinteger(L, glyph->is_extended_shape);
+            lua_pushnumber(L, glyph->is_extended_shape);
             break;
         case GK_italic_correction:
             if (glyph->italic_correction != TEX_UNDEF) {
-                lua_pushinteger(L, glyph->italic_correction);
+                lua_pushnumber(L, glyph->italic_correction);
             } else {
                 lua_pushnil(L);
             }
             break;
         case GK_top_accent:
             if (glyph->top_accent_horiz != TEX_UNDEF) {
-                lua_pushinteger(L, glyph->top_accent_horiz);
+                lua_pushnumber(L, glyph->top_accent_horiz);
             } else {
                 lua_pushnil(L);
             }
@@ -2794,38 +2794,38 @@ static int ff_index(lua_State * L)
             lua_pushstring(L, sf->version);
             break;
         case FK_italicangle:
-            lua_pushinteger(L, sf->italicangle);
+            lua_pushnumber(L, sf->italicangle);
             break;
         case FK_upos:
-            lua_pushinteger(L, sf->upos);
+            lua_pushnumber(L, sf->upos);
             break;
         case FK_uwidth:
-            lua_pushinteger(L, sf->uwidth);
+            lua_pushnumber(L, sf->uwidth);
             break;
         case FK_ascent:
-            lua_pushinteger(L, sf->ascent);
+            lua_pushnumber(L, sf->ascent);
             break;
         case FK_descent:
-            lua_pushinteger(L, sf->descent);
+            lua_pushnumber(L, sf->descent);
             break;
         case FK_uniqueid:
-            lua_pushinteger(L, sf->uniqueid);
+            lua_pushnumber(L, sf->uniqueid);
             break;
         case FK_glyphcnt:
             if (sf->glyphcnt > 0) {
-                lua_pushinteger(L, sf->glyphmax - sf->glyphmin + 1);
+                lua_pushnumber(L, sf->glyphmax - sf->glyphmin + 1);
             } else {
-                lua_pushinteger(L, 0);
+                lua_pushnumber(L, 0);
             }
             break;
         case FK_glyphmax:
-            lua_pushinteger(L, sf->glyphmax - 1);
+            lua_pushnumber(L, sf->glyphmax - 1);
             break;
         case FK_glyphmin:
-            lua_pushinteger(L, sf->glyphmin);
+            lua_pushnumber(L, sf->glyphmin);
             break;
         case FK_units_per_em:
-            lua_pushinteger(L, sf->units_per_em);
+            lua_pushnumber(L, sf->units_per_em);
             break;
         case FK_lookups:
             if (sf->possub != NULL) {
@@ -2844,34 +2844,34 @@ static int ff_index(lua_State * L)
             lua_setmetatable(L, -2);        /* assign the metatable */
             break;
         case FK_hasvmetrics:
-            lua_pushinteger(L, sf->hasvmetrics);
+            lua_pushnumber(L, sf->hasvmetrics);
             break;
         case FK_onlybitmaps:
-            lua_pushinteger(L, sf->onlybitmaps);
+            lua_pushnumber(L, sf->onlybitmaps);
             break;
         case FK_serifcheck:
-            lua_pushinteger(L, sf->serifcheck);
+            lua_pushnumber(L, sf->serifcheck);
             break;
         case FK_isserif:
-            lua_pushinteger(L, sf->isserif);
+            lua_pushnumber(L, sf->isserif);
             break;
         case FK_issans:
-            lua_pushinteger(L, sf->issans);
+            lua_pushnumber(L, sf->issans);
             break;
         case FK_encodingchanged:
-            lua_pushinteger(L, sf->encodingchanged);
+            lua_pushnumber(L, sf->encodingchanged);
             break;
         case FK_strokedfont:
-            lua_pushinteger(L, sf->strokedfont);
+            lua_pushnumber(L, sf->strokedfont);
             break;
         case FK_use_typo_metrics:
-            lua_pushinteger(L, sf->use_typo_metrics);
+            lua_pushnumber(L, sf->use_typo_metrics);
             break;
         case FK_weight_width_slope_only:
-            lua_pushinteger(L, sf->weight_width_slope_only);
+            lua_pushnumber(L, sf->weight_width_slope_only);
             break;
         case FK_head_optimized_for_cleartype:
-            lua_pushinteger(L, sf->head_optimized_for_cleartype);
+            lua_pushnumber(L, sf->head_optimized_for_cleartype);
             break;
         case FK_uni_interp:
             lua_pushstring(L, uni_interp_enum[(sf->uni_interp + 1)]);
@@ -2967,8 +2967,8 @@ static int ff_index(lua_State * L)
                 dump_enumfield(L, "type", sf->texdata.type, tex_type_enum);
                 lua_newtable(L);
                 for (k = 0; k < 22; k++) {
-                    lua_pushinteger(L, k);
-                    lua_pushinteger(L, sf->texdata.params[k]);
+                    lua_pushnumber(L, k);
+                    lua_pushnumber(L, sf->texdata.params[k]);
                     lua_rawset(L, -3);
                 }
                 lua_setfield(L, -2, "params");
@@ -3028,16 +3028,16 @@ static int ff_index(lua_State * L)
             lua_pushstring(L, sf->chosenname);
             break;
         case FK_macstyle:
-            lua_pushinteger(L, sf->macstyle);
+            lua_pushnumber(L, sf->macstyle);
             break;
         case FK_fondname:
             lua_pushstring(L, sf->fondname);
             break;
         case FK_design_size:
-            lua_pushinteger(L, sf->design_size);
+            lua_pushnumber(L, sf->design_size);
             break;
         case FK_fontstyle_id:
-            lua_pushinteger(L, sf->fontstyle_id);
+            lua_pushnumber(L, sf->fontstyle_id);
             break;
         case FK_fontstyle_name:
             if (sf->fontstyle_name != NULL) {
@@ -3048,13 +3048,13 @@ static int ff_index(lua_State * L)
             }
             break;
         case FK_design_range_bottom:
-            lua_pushinteger(L, sf->design_range_bottom);
+            lua_pushnumber(L, sf->design_range_bottom);
             break;
         case FK_design_range_top:
-            lua_pushinteger(L, sf->design_range_top);
+            lua_pushnumber(L, sf->design_range_top);
             break;
         case FK_strokewidth:
-            lua_pushinteger(L, sf->strokewidth);
+            lua_pushnumber(L, sf->strokewidth);
             break;
         case FK_mark_classes:
             if (sf->mark_class_cnt > 0) {
@@ -3071,16 +3071,16 @@ static int ff_index(lua_State * L)
             }
             break;
         case FK_creationtime:
-            lua_pushinteger(L, sf->creationtime);
+            lua_pushnumber(L, sf->creationtime);
             break;
         case FK_modificationtime:
-            lua_pushinteger(L, sf->modificationtime);
+            lua_pushnumber(L, sf->modificationtime);
             break;
         case FK_os2_version:
-            lua_pushinteger(L, sf->os2_version);
+            lua_pushnumber(L, sf->os2_version);
             break;
         case FK_sfd_version:
-            lua_pushinteger(L, sf->sfd_version);
+            lua_pushnumber(L, sf->sfd_version);
             break;
         case FK_math:
             if (sf->MATH != NULL) {
@@ -3157,7 +3157,7 @@ static int ff_index(lua_State * L)
             }
             break;
         case FK_extrema_bound:
-            lua_pushinteger(L, sf->extrema_bound);
+            lua_pushnumber(L, sf->extrema_bound);
             break;
         case FK_notdef_loc:
             lua_pushinteger(L, notdef_loc(sf));
--- texlive-bin.orig/texk/web2c/luatexdir/luamd5/md5lib.c
+++ texlive-bin/texk/web2c/luatexdir/luamd5/md5lib.c
@@ -5,6 +5,7 @@
 *  @author  Roberto Ierusalimschy
 */
 
+
 #include <stdlib.h>
 #include <string.h>
 #include <time.h>
@@ -14,21 +15,22 @@
 
 #include "luamd5.h"
 
+
 /**
 *  Hash function. Returns a hash for a given string.
 *  @param message: arbitrary binary string.
 *  @return  A 128-bit hash string.
 */
-
 static int lmd5 (lua_State *L) {
-    char buff[16];
-    size_t l;
-    const char *message = luaL_checklstring(L, 1, &l);
-    md5(message, l, buff);
-    lua_pushlstring(L, buff, 16L);
-    return 1;
+  char buff[16];
+  size_t l;
+  const char *message = luaL_checklstring(L, 1, &l);
+  md5(message, l, buff);
+  lua_pushlstring(L, buff, 16L);
+  return 1;
 }
 
+
 /**
 *  X-Or. Does a bit-a-bit exclusive-or of two strings.
 *  @param s1: arbitrary binary string.
@@ -36,73 +38,78 @@ static int lmd5 (lua_State *L) {
 *  @return  a binary string with same length as s1 and s2,
 *   where each bit is the exclusive-or of the corresponding bits in s1-s2.
 */
-
 static int ex_or (lua_State *L) {
-    size_t l1, l2;
-    const char *s1 = luaL_checklstring(L, 1, &l1);
-    const char *s2 = luaL_checklstring(L, 2, &l2);
-    luaL_Buffer b;
-    luaL_argcheck( L, l1 == l2, 2, "lengths must be equal" );
-    luaL_buffinit(L, &b);
-    while (l1--)
-        luaL_addchar(&b, (*s1++)^(*s2++));
-    luaL_pushresult(&b);
-    return 1;
+  size_t l1, l2;
+  const char *s1 = luaL_checklstring(L, 1, &l1);
+  const char *s2 = luaL_checklstring(L, 2, &l2);
+  luaL_Buffer b;
+  luaL_argcheck( L, l1 == l2, 2, "lengths must be equal" );
+  luaL_buffinit(L, &b);
+  while (l1--) luaL_addchar(&b, (*s1++)^(*s2++));
+  luaL_pushresult(&b);
+  return 1;
 }
 
+
 static void checkseed (lua_State *L) {
-    if (lua_isnone(L, 3)) {  /* no seed? */
-        time_t tm = time(NULL);  /* for `random' seed */
-        lua_pushlstring(L, (char *)&tm, sizeof(tm));
-    }
+  if (lua_isnone(L, 3)) {  /* no seed? */
+    time_t tm = time(NULL);  /* for `random' seed */
+    lua_pushlstring(L, (char *)&tm, sizeof(tm));
+  }
 }
 
-#define MAXKEY    256
-#define BLOCKSIZE  16
+
+#define MAXKEY	256
+#define BLOCKSIZE	16
+
+
 
 static int initblock (lua_State *L, const char *seed, int lseed, char *block) {
-    size_t lkey;
-    const char *key = luaL_checklstring(L, 2, &lkey);
-    if (lkey > MAXKEY)
-        luaL_error(L, "key too long (> %d)", MAXKEY);
-    memset(block, 0, BLOCKSIZE);
-    memcpy(block, seed, lseed);
-    memcpy(block+BLOCKSIZE, key, lkey);
-    return (int)lkey+BLOCKSIZE;
+  size_t lkey;
+  const char *key = luaL_checklstring(L, 2, &lkey);
+  if (lkey > MAXKEY)
+    luaL_error(L, "key too long (> %d)", MAXKEY);
+  memset(block, 0, BLOCKSIZE);
+  memcpy(block, seed, lseed);
+  memcpy(block+BLOCKSIZE, key, lkey);
+  return (int)lkey+BLOCKSIZE;
 }
 
+
 static void codestream (lua_State *L, const char *msg, size_t lmsg,
                                       char *block, int lblock) {
-    luaL_Buffer b;
-    luaL_buffinit(L, &b);
-    while (lmsg > 0) {
-        char code[BLOCKSIZE];
-        int i;
-        md5(block, lblock, code);
-        for (i=0; i<BLOCKSIZE && lmsg > 0; i++, lmsg--)
-            code[i] ^= *msg++;
-        luaL_addlstring(&b, code, i);
-        memcpy(block, code, i); /* update seed */
-    }
-    luaL_pushresult(&b);
+  luaL_Buffer b;
+  luaL_buffinit(L, &b);
+  while (lmsg > 0) {
+    char code[BLOCKSIZE];
+    int i;
+    md5(block, lblock, code);
+    for (i=0; i<BLOCKSIZE && lmsg > 0; i++, lmsg--)
+      code[i] ^= *msg++;
+    luaL_addlstring(&b, code, i); 
+    memcpy(block, code, i); /* update seed */
+  }
+  luaL_pushresult(&b);
 }
 
+
 static void decodestream (lua_State *L, const char *cypher, size_t lcypher,
                           char *block, int lblock) {
-    luaL_Buffer b;
-    luaL_buffinit(L, &b);
-    while (lcypher > 0) {
-        char code[BLOCKSIZE];
-        int i;
-        md5(block, lblock, code);  /* update seed */
-        for (i=0; i<BLOCKSIZE && lcypher > 0; i++, lcypher--)
-            code[i] ^= *cypher++;
-        luaL_addlstring(&b, code, i);
-        memcpy(block, cypher-i, i);
-    }
-    luaL_pushresult(&b);
+  luaL_Buffer b;
+  luaL_buffinit(L, &b);
+  while (lcypher > 0) {
+    char code[BLOCKSIZE];
+    int i;
+    md5(block, lblock, code);  /* update seed */
+    for (i=0; i<BLOCKSIZE && lcypher > 0; i++, lcypher--)
+      code[i] ^= *cypher++;
+    luaL_addlstring(&b, code, i); 
+    memcpy(block, cypher-i, i);
+  }
+  luaL_pushresult(&b);
 }
 
+
 /**
 *  Encrypts a string. Uses the hash function md5 in CFB (Cipher-feedback
 *  mode).
@@ -110,29 +117,28 @@ static void decodestream (lua_State *L,
 *  @param key: arbitrary binary string to be used as a key.
 *  @param [seed]: optional arbitrary binary string to be used as a seed.
 *  if no seed is provided, the function uses the result of
-*  <code>time()</code> as a seed.
+*  <code>time()</code> as a seed.  
 *  @return  The cyphertext (as a binary string).
 */
-
 static int crypt (lua_State *L) {
-    size_t lmsg;
-    const char *msg = luaL_checklstring(L, 1, &lmsg);
-    size_t lseed;
-    const char *seed;
-    int lblock;
-    char block[BLOCKSIZE+MAXKEY];
-    checkseed(L);
-    seed = luaL_checklstring(L, 3, &lseed);
-    if (lseed > BLOCKSIZE)
-        luaL_error(L, "seed too long (> %d)", BLOCKSIZE);
-      /* put seed and seed length at the beginning of result */
-    block[0] = (char)lseed;
-    memcpy(block+1, seed, lseed);
-    lua_pushlstring(L, block, lseed+1);  /* to concat with result */
-    lblock = initblock(L, seed, lseed, block);
-    codestream(L, msg, lmsg, block, lblock);
-    lua_concat(L, 2);
-    return 1;
+  size_t lmsg;
+  const char *msg = luaL_checklstring(L, 1, &lmsg);
+  size_t lseed;
+  const char *seed;
+  int lblock;
+  char block[BLOCKSIZE+MAXKEY];
+  checkseed(L);
+  seed = luaL_checklstring(L, 3, &lseed);
+  if (lseed > BLOCKSIZE)
+    luaL_error(L, "seed too long (> %d)", BLOCKSIZE);
+  /* put seed and seed length at the beginning of result */
+  block[0] = (char)lseed;
+  memcpy(block+1, seed, lseed);
+  lua_pushlstring(L, block, lseed+1);  /* to concat with result */
+  lblock = initblock(L, seed, lseed, block);
+  codestream(L, msg, lmsg, block, lblock);
+  lua_concat(L, 2);
+  return 1;
 }
 
 
@@ -145,104 +151,33 @@ static int crypt (lua_State *L) {
 *  @return  The plaintext.
 */
 static int decrypt (lua_State *L) {
-    size_t lcyphertext;
-    const char *cyphertext = luaL_checklstring(L, 1, &lcyphertext);
-    size_t lseed = cyphertext[0];
-    const char *seed = cyphertext+1;
-    int lblock;
-    char block[BLOCKSIZE+MAXKEY];
-    luaL_argcheck(L, lcyphertext >= lseed+1 && lseed <= BLOCKSIZE, 1,
-        "invalid cyphered string");
-    cyphertext += lseed+1;
-    lcyphertext -= lseed+1;
-    lblock = initblock(L, seed, lseed, block);
-    decodestream(L, cyphertext, lcyphertext, block, lblock);
-    return 1;
-}
-
-/* not now .. doesn't compile anyway
-
-#include "../luapplib/util/utilmd5.h"
-
-static int pdfelib_md_5(lua_State * L)
-{
-    if (lua_type(L,1) == LUA_TSTRING) {
-        uint8_t result[16];
-        size_t size = 0;
-        const char *data = lua_tolstring(L,1,&size);
-        md5(data,size,result);
-        lua_pushlstring(L,(const char *)result,16);
-        return 1;
-    }
-    return 0;
+  size_t lcyphertext;
+  const char *cyphertext = luaL_checklstring(L, 1, &lcyphertext);
+  size_t lseed = cyphertext[0];
+  const char *seed = cyphertext+1;
+  int lblock;
+  char block[BLOCKSIZE+MAXKEY];
+  luaL_argcheck(L, lcyphertext >= lseed+1 && lseed <= BLOCKSIZE, 1,
+                 "invalid cyphered string");
+  cyphertext += lseed+1;
+  lcyphertext -= lseed+1;
+  lblock = initblock(L, seed, lseed, block);
+  decodestream(L, cyphertext, lcyphertext, block, lblock);
+  return 1;
 }
 
-*/
 
 static struct luaL_Reg md5lib[] = {
-    { "sum",     lmd5},
-    { "exor",    ex_or},
-    { "crypt",   crypt},
-    { "decrypt", decrypt},
-    { NULL,      NULL}
+  {"sum", lmd5},
+  {"exor", ex_or},
+  {"crypt", crypt},
+  {"decrypt", decrypt},
+  {NULL, NULL}
 };
 
-int luaopen_md5(lua_State *L) {
-    luaL_openlib(L, "md5",  md5lib,  0);
-    return 1;
-}
-
-/* We could use a different file but this is as easy. */
-
-#include "../luapplib/util/utilsha.h"
-
-static int sha2_256(lua_State * L)
-{
-    if (lua_type(L,1) == LUA_TSTRING) {
-        uint8_t result[SHA256_DIGEST_LENGTH];
-        size_t size = 0;
-        const char *data = lua_tolstring(L,1,&size);
-        sha256(data,size,result);
-        lua_pushlstring(L,(const char *)result,SHA256_DIGEST_LENGTH);
-        return 1;
-    }
-    return 0;
-}
-
-static int sha2_384(lua_State * L)
-{
-    if (lua_type(L,1) == LUA_TSTRING) {
-        size_t size = 0;
-        uint8_t result[SHA384_DIGEST_LENGTH];
-        const char *data = lua_tolstring(L,1,&size);
-        sha384(data,size,result);
-        lua_pushlstring(L,(const char *)result,SHA384_DIGEST_LENGTH);
-        return 1;
-    }
-    return 0;
-}
-
-static int sha2_512(lua_State * L)
-{
-    if (lua_type(L,1) == LUA_TSTRING) {
-        uint8_t result[SHA512_DIGEST_LENGTH];
-        size_t size = 0;
-        const char *data = lua_tolstring(L,1,&size);
-        sha512(data,size,result);
-        lua_pushlstring(L,(const char *)result,SHA512_DIGEST_LENGTH);
-        return 1;
-    }
-    return 0;
-}
-
-static struct luaL_Reg sha2lib[] = {
-    { "digest256", sha2_256 },
-    { "digest384", sha2_384 },
-    { "digest512", sha2_512 },
-    { NULL,        NULL}
-};
 
-int luaopen_sha2(lua_State *L) {
-    luaL_openlib(L, "sha2", sha2lib, 0);
-    return 1;
+int luaopen_md5 (lua_State *L) {
+  luaL_openlib(L, "md5", md5lib, 0);
+  return 1;
 }
+
--- texlive-bin.orig/texk/web2c/luatexdir/luasocket/src/lua_preload.c
+++ texlive-bin/texk/web2c/luatexdir/luasocket/src/lua_preload.c
@@ -15,7 +15,6 @@ int luatex_http_lua_open(lua_State*);
 int luatex_ftp_lua_open(lua_State*);
 
 
-extern void luatex_socketlua_open (lua_State *) ;
 #include "ftp_lua.c"
 #include "headers_lua.c" 
 #include "http_lua.c"
--- texlive-bin.orig/texk/web2c/luatexdir/luasocket/src/options.c
+++ texlive-bin/texk/web2c/luatexdir/luasocket/src/options.c
@@ -37,7 +37,7 @@ int opt_meth_setoption(lua_State *L, p_o
     while (opt->name && strcmp(name, opt->name))
         opt++;
     if (!opt->func) {
-        char msg[57];
+        char msg[45];
         sprintf(msg, "unsupported option `%.35s'", name);
         luaL_argerror(L, 2, msg);
     }
@@ -50,7 +50,7 @@ int opt_meth_getoption(lua_State *L, p_o
     while (opt->name && strcmp(name, opt->name))
         opt++;
     if (!opt->func) {
-        char msg[57];
+        char msg[45];
         sprintf(msg, "unsupported option `%.35s'", name);
         luaL_argerror(L, 2, msg);
     }
--- texlive-bin.orig/texk/web2c/luatexdir/luasocket/src/serial.c
+++ texlive-bin/texk/web2c/luatexdir/luasocket/src/serial.c
@@ -31,44 +31,44 @@ have only one object type.
 /*=========================================================================*\
 * Internal function prototypes
 \*=========================================================================*/
-/*static int global_create(lua_State *L);*/
-/* static int meth_send(lua_State *L); */
-/* static int meth_receive(lua_State *L); */
-/* static int meth_close(lua_State *L); */
-/* static int meth_settimeout(lua_State *L); */
-/* static int meth_getfd(lua_State *L); */
-/* static int meth_setfd(lua_State *L); */
-/* static int meth_dirty(lua_State *L); */
-/* static int meth_getstats(lua_State *L); */
-/* static int meth_setstats(lua_State *L); */
+static int global_create(lua_State *L);
+static int meth_send(lua_State *L);
+static int meth_receive(lua_State *L);
+static int meth_close(lua_State *L);
+static int meth_settimeout(lua_State *L);
+static int meth_getfd(lua_State *L);
+static int meth_setfd(lua_State *L);
+static int meth_dirty(lua_State *L);
+static int meth_getstats(lua_State *L);
+static int meth_setstats(lua_State *L);
 
 /* serial object methods */
-/* static luaL_Reg serial_methods[] = { */
-/*     {"__gc",        meth_close}, */
-/*     {"__tostring",  auxiliar_tostring}, */
-/*     {"close",       meth_close}, */
-/*     {"dirty",       meth_dirty}, */
-/*     {"getfd",       meth_getfd}, */
-/*     {"getstats",    meth_getstats}, */
-/*     {"setstats",    meth_setstats}, */
-/*     {"receive",     meth_receive}, */
-/*     {"send",        meth_send}, */
-/*     {"setfd",       meth_setfd}, */
-/*     {"settimeout",  meth_settimeout}, */
-/*     {NULL,          NULL} */
-/* }; */
-
-/*-------------------------------------------------------------------------*\
-* Initializes module (luatex extension, unused )
-\*-------------------------------------------------------------------------*/
-/* LUASOCKET_API int luaopen_socket_serial(lua_State *L) { */
-/*     /\* create classes *\/ */
-/*     auxiliar_newclass(L, "serial{client}", serial_methods); */
-/*     /\* create class groups *\/ */
-/*     auxiliar_add2group(L, "serial{client}", "serial{any}"); */
-/*     lua_pushcfunction(L, global_create); */
-/*     return 1; */
-/* } */
+static luaL_Reg serial_methods[] = {
+    {"__gc",        meth_close},
+    {"__tostring",  auxiliar_tostring},
+    {"close",       meth_close},
+    {"dirty",       meth_dirty},
+    {"getfd",       meth_getfd},
+    {"getstats",    meth_getstats},
+    {"setstats",    meth_setstats},
+    {"receive",     meth_receive},
+    {"send",        meth_send},
+    {"setfd",       meth_setfd},
+    {"settimeout",  meth_settimeout},
+    {NULL,          NULL}
+};
+
+/*-------------------------------------------------------------------------*\
+* Initializes module
+\*-------------------------------------------------------------------------*/
+LUASOCKET_API int luaopen_socket_serial(lua_State *L) {
+    /* create classes */
+    auxiliar_newclass(L, "serial{client}", serial_methods);
+    /* create class groups */
+    auxiliar_add2group(L, "serial{client}", "serial{any}");
+    lua_pushcfunction(L, global_create);
+    return 1;
+}
 
 /*=========================================================================*\
 * Lua methods
@@ -76,67 +76,67 @@ have only one object type.
 /*-------------------------------------------------------------------------*\
 * Just call buffered IO methods
 \*-------------------------------------------------------------------------*/
-/* static int meth_send(lua_State *L) { */
-/*     p_unix un = (p_unix) auxiliar_checkclass(L, "serial{client}", 1); */
-/*     return buffer_meth_send(L, &un->buf); */
-/* } */
-
-/* static int meth_receive(lua_State *L) { */
-/*     p_unix un = (p_unix) auxiliar_checkclass(L, "serial{client}", 1); */
-/*     return buffer_meth_receive(L, &un->buf); */
-/* } */
-
-/* static int meth_getstats(lua_State *L) { */
-/*     p_unix un = (p_unix) auxiliar_checkclass(L, "serial{client}", 1); */
-/*     return buffer_meth_getstats(L, &un->buf); */
-/* } */
-
-/* static int meth_setstats(lua_State *L) { */
-/*     p_unix un = (p_unix) auxiliar_checkclass(L, "serial{client}", 1); */
-/*     return buffer_meth_setstats(L, &un->buf); */
-/* } */
+static int meth_send(lua_State *L) {
+    p_unix un = (p_unix) auxiliar_checkclass(L, "serial{client}", 1);
+    return buffer_meth_send(L, &un->buf);
+}
+
+static int meth_receive(lua_State *L) {
+    p_unix un = (p_unix) auxiliar_checkclass(L, "serial{client}", 1);
+    return buffer_meth_receive(L, &un->buf);
+}
+
+static int meth_getstats(lua_State *L) {
+    p_unix un = (p_unix) auxiliar_checkclass(L, "serial{client}", 1);
+    return buffer_meth_getstats(L, &un->buf);
+}
+
+static int meth_setstats(lua_State *L) {
+    p_unix un = (p_unix) auxiliar_checkclass(L, "serial{client}", 1);
+    return buffer_meth_setstats(L, &un->buf);
+}
 
 /*-------------------------------------------------------------------------*\
 * Select support methods
 \*-------------------------------------------------------------------------*/
-/* static int meth_getfd(lua_State *L) { */
-/*     p_unix un = (p_unix) auxiliar_checkgroup(L, "serial{any}", 1); */
-/*     lua_pushnumber(L, (int) un->sock); */
-/*     return 1; */
-/* } */
-
-/* /\* this is very dangerous, but can be handy for those that are brave enough *\/ */
-/* static int meth_setfd(lua_State *L) { */
-/*     p_unix un = (p_unix) auxiliar_checkgroup(L, "serial{any}", 1); */
-/*     un->sock = (t_socket) luaL_checknumber(L, 2); */
-/*     return 0; */
-/* } */
-
-/* static int meth_dirty(lua_State *L) { */
-/*     p_unix un = (p_unix) auxiliar_checkgroup(L, "serial{any}", 1); */
-/*     lua_pushboolean(L, !buffer_isempty(&un->buf)); */
-/*     return 1; */
-/* } */
+static int meth_getfd(lua_State *L) {
+    p_unix un = (p_unix) auxiliar_checkgroup(L, "serial{any}", 1);
+    lua_pushnumber(L, (int) un->sock);
+    return 1;
+}
+
+/* this is very dangerous, but can be handy for those that are brave enough */
+static int meth_setfd(lua_State *L) {
+    p_unix un = (p_unix) auxiliar_checkgroup(L, "serial{any}", 1);
+    un->sock = (t_socket) luaL_checknumber(L, 2);
+    return 0;
+}
+
+static int meth_dirty(lua_State *L) {
+    p_unix un = (p_unix) auxiliar_checkgroup(L, "serial{any}", 1);
+    lua_pushboolean(L, !buffer_isempty(&un->buf));
+    return 1;
+}
 
 /*-------------------------------------------------------------------------*\
 * Closes socket used by object
 \*-------------------------------------------------------------------------*/
-/* static int meth_close(lua_State *L) */
-/* { */
-/*     p_unix un = (p_unix) auxiliar_checkgroup(L, "serial{any}", 1); */
-/*     socket_destroy(&un->sock); */
-/*     lua_pushnumber(L, 1); */
-/*     return 1; */
-/* } */
+static int meth_close(lua_State *L)
+{
+    p_unix un = (p_unix) auxiliar_checkgroup(L, "serial{any}", 1);
+    socket_destroy(&un->sock);
+    lua_pushnumber(L, 1);
+    return 1;
+}
 
 
 /*-------------------------------------------------------------------------*\
 * Just call tm methods
 \*-------------------------------------------------------------------------*/
-/* static int meth_settimeout(lua_State *L) { */
-/*     p_unix un = (p_unix) auxiliar_checkgroup(L, "serial{any}", 1); */
-/*     return timeout_meth_settimeout(L, &un->tm); */
-/* } */
+static int meth_settimeout(lua_State *L) {
+    p_unix un = (p_unix) auxiliar_checkgroup(L, "serial{any}", 1);
+    return timeout_meth_settimeout(L, &un->tm);
+}
 
 /*=========================================================================*\
 * Library functions
@@ -146,35 +146,35 @@ have only one object type.
 /*-------------------------------------------------------------------------*\
 * Creates a serial object
 \*-------------------------------------------------------------------------*/
-/* static int global_create(lua_State *L) { */
-/*     const char* path = luaL_checkstring(L, 1); */
+static int global_create(lua_State *L) {
+    const char* path = luaL_checkstring(L, 1);
 
-/*     /\* allocate unix object *\/ */
-/*     p_unix un = (p_unix) lua_newuserdata(L, sizeof(t_unix)); */
+    /* allocate unix object */
+    p_unix un = (p_unix) lua_newuserdata(L, sizeof(t_unix));
 
-/*     /\* open serial device *\/ */
-/* #if defined(_WIN32) */
-/*     t_socket sock = open(path, O_RDWR); */
-/* #else */
-/*     t_socket sock = open(path, O_NOCTTY|O_RDWR); */
-/* #endif */
-
-/*     /\*printf("open %s on %d\n", path, sock);*\/ */
-
-/*     if (sock < 0)  { */
-/*         lua_pushnil(L); */
-/*         lua_pushstring(L, socket_strerror(errno)); */
-/*         lua_pushnumber(L, errno); */
-/*         return 3; */
-/*     } */
-/*     /\* set its type as client object *\/ */
-/*     auxiliar_setclass(L, "serial{client}", -1); */
-/*     /\* initialize remaining structure fields *\/ */
-/*     socket_setnonblocking(&sock); */
-/*     un->sock = sock; */
-/*     io_init(&un->io, (p_send) socket_write, (p_recv) socket_read, */
-/*             (p_error) socket_ioerror, &un->sock); */
-/*     timeout_init(&un->tm, -1, -1); */
-/*     buffer_init(&un->buf, &un->io, &un->tm); */
-/*     return 1; */
-/* } */
+    /* open serial device */
+#if defined(_WIN32)
+    t_socket sock = open(path, O_RDWR);
+#else
+    t_socket sock = open(path, O_NOCTTY|O_RDWR);
+#endif
+
+    /*printf("open %s on %d\n", path, sock);*/
+
+    if (sock < 0)  {
+        lua_pushnil(L);
+        lua_pushstring(L, socket_strerror(errno));
+        lua_pushnumber(L, errno);
+        return 3;
+    }
+    /* set its type as client object */
+    auxiliar_setclass(L, "serial{client}", -1);
+    /* initialize remaining structure fields */
+    socket_setnonblocking(&sock);
+    un->sock = sock;
+    io_init(&un->io, (p_send) socket_write, (p_recv) socket_read,
+            (p_error) socket_ioerror, &un->sock);
+    timeout_init(&un->tm, -1, -1);
+    buffer_init(&un->buf, &un->io, &un->tm);
+    return 1;
+}
--- texlive-bin.orig/texk/web2c/luatexdir/luatex.c
+++ texlive-bin/texk/web2c/luatexdir/luatex.c
@@ -32,9 +32,9 @@
     stick to "0" upto "9" so users can expect a number represented as string.
 */
 
-int luatex_version = 109;
+int luatex_version = 107;
 int luatex_revision = '0';
-const char *luatex_version_string = "1.09.0";
+const char *luatex_version_string = "1.07.0";
 const char *engine_name = my_name;
 
 #include <kpathsea/c-ctype.h>
--- texlive-bin.orig/texk/web2c/luatexdir/luatex_svnversion.h
+++ texlive-bin/texk/web2c/luatexdir/luatex_svnversion.h
@@ -1 +1 @@
-#define luatex_svn_revision 6924
+#define luatex_svn_revision 6686
--- texlive-bin.orig/texk/web2c/luatexdir/luatexcallbackids.h
+++ texlive-bin/texk/web2c/luatexdir/luatexcallbackids.h
@@ -68,13 +68,8 @@ typedef enum {
     call_edit_callback,
     build_page_insert_callback,
     glyph_stream_provider_callback,
-    font_descriptor_objnum_provider_callback,
     finish_synctex_callback,
-    wrapup_run_callback,
-    new_graf_callback,
-    page_objnum_provider_callback,
-    make_extensible_callback,
-    total_callbacks,
+    total_callbacks
 } callback_callback_types;
 
 /* lcallbacklib.c */
@@ -101,6 +96,7 @@ extern void get_lua_boolean(const char *
 extern void get_lua_number(const char *table, const char *name, int *target);
 extern void get_lua_string(const char *table, const char *name, char **target);
 
+extern int lua_reader_callback(int callback_id, pointer *buffloc);
 
 extern char *get_lua_name(int i);
 
--- texlive-bin.orig/texk/web2c/luatexdir/pdf/pdfgen.h
+++ texlive-bin/texk/web2c/luatexdir/pdf/pdfgen.h
@@ -114,19 +114,6 @@ printing ones but the output is going to
     pdf_out(pdf, '\n'); \
 } while (0)
 
-#define pdf_check_space(pdf) do { \
-    if (pdf->cave > 0) { \
-        pdf_out(pdf, ' '); \
-        pdf->cave = 0; \
-    } \
-} while (0)
-
-#define pdf_set_space(pdf) \
-    pdf->cave = 1;
-
-#define pdf_reset_space(pdf) \
-    pdf->cave = 0;
-
 extern __attribute__ ((format(printf, 2, 3)))
 void pdf_printf(PDF, const char *, ...);
 
@@ -138,7 +125,6 @@ extern void pdf_print_str(PDF, const cha
 extern void pdf_add_null(PDF);
 extern void pdf_add_bool(PDF, int i);
 extern void pdf_add_int(PDF, int i);
-extern void pdf_add_real(PDF, double d);
 extern void pdf_add_longint(PDF, longinteger n);
 extern void pdf_add_ref(PDF, int num);
 extern void pdf_add_string(PDF, const char *s);
@@ -154,18 +140,6 @@ extern void pdf_dict_add_streaminfo(PDF)
 extern void pdf_begin_stream(PDF);
 extern void pdf_end_stream(PDF);
 
-typedef unsigned char BYTE;
-typedef unsigned long ULONG;
-
-typedef struct {
-    ULONG length;
-    BYTE *data;
-} pdf_obj;
-
-extern pdf_obj *pdf_new_stream(void);
-extern void pdf_add_stream(pdf_obj * stream, unsigned char *buf, long len);
-extern void pdf_release_obj(pdf_obj * stream);
-
 extern void pdf_add_bp(PDF, scaled);
 
 extern strbuf_s *new_strbuf(size_t size, size_t limit);
@@ -217,6 +191,8 @@ extern char *convertStringToPDFString(co
 extern void initialize_start_time(PDF);
 extern char *getcreationdate(PDF);
 
+extern void check_o_mode(PDF pdf, const char *s, int o_mode, boolean errorflag);
+
 extern void set_job_id(PDF, int, int, int, int);
 extern char *get_resname_prefix(PDF);
 extern void pdf_begin_page(PDF pdf);
@@ -225,10 +201,6 @@ extern void print_pdf_table_string(PDF p
 extern const char *get_pdf_table_string(const char *s);
 extern int get_pdf_table_bool(PDF, const char *, int);
 
-extern void pdf_open_file(PDF pdf);
-extern void pdf_write_header(PDF pdf);
-extern void pdf_finish_file(PDF pdf, int fatal_error);
-
 extern void ensure_output_state(PDF pdf, output_state s);
 extern PDF init_pdf_struct(PDF pdf);
 
@@ -238,18 +210,8 @@ extern halfword pdf_catalog_openaction;
 extern halfword pdf_names_toks;         /* additional keys of Names dictionary */
 extern halfword pdf_trailer_toks;       /* additional keys of Trailer dictionary */
 extern void scan_pdfcatalog(PDF pdf);
+extern void finish_pdf_file(PDF pdf, int luatex_version, str_number luatex_revision);
 
 extern shipping_mode_e global_shipping_mode;
 
-extern void pdf_push_list(PDF pdf, scaledpos *saved_pos, int *saved_loc);
-extern void pdf_pop_list(PDF pdf, scaledpos *saved_pos, int *saved_loc);
-
-extern void pdf_set_reference_point(PDF pdf, posstructure *refpoint);
-
-/* not pdf specific */
-
-extern void check_o_mode(PDF pdf, const char *s, int o_mode, boolean errorflag);
-extern void ensure_output_file_open(PDF pdf, const char *ext);
-
-
 #endif
--- texlive-bin.orig/texk/web2c/luatexdir/pdf/pdflistout.h
+++ texlive-bin/texk/web2c/luatexdir/pdf/pdflistout.h
@@ -21,12 +21,28 @@
 #ifndef PDFLISTOUT_H
 #  define PDFLISTOUT_H
 
-#define pos_right(A) pdf->posstruct->pos.h = pdf->posstruct->pos.h + (A)
-#define pos_left(A)  pdf->posstruct->pos.h = pdf->posstruct->pos.h - (A)
-#define pos_up(A)    pdf->posstruct->pos.v = pdf->posstruct->pos.v + (A)
-#define pos_down(A)  pdf->posstruct->pos.v = pdf->posstruct->pos.v - (A)
+#  define pos_right(A) pdf->posstruct->pos.h = pdf->posstruct->pos.h + (A)
+#  define pos_left(A)  pdf->posstruct->pos.h = pdf->posstruct->pos.h - (A)
+#  define pos_up(A)    pdf->posstruct->pos.v = pdf->posstruct->pos.v + (A)
+#  define pos_down(A)  pdf->posstruct->pos.v = pdf->posstruct->pos.v - (A)
+
+typedef void (*backend_function) (); /* variadic arguments  */
+
+typedef struct {
+    char *name;                    /* name of the backend */
+    backend_function *node_fu;     /* array of node output functions */
+    backend_function *whatsit_fu;  /* array of whatsit output functions */
+} backend_struct;
+
+extern pos_info_structure pos_info;
+
+extern backend_function *backend_out;
+extern backend_function *backend_out_whatsit;
+
+extern void init_backend_functionpointers(output_mode o_mode);
 
 extern void hlist_out(PDF pdf, halfword this_box, int rule_callback_id);
 extern void vlist_out(PDF pdf, halfword this_box, int rule_callback_id);
+extern void out_what(PDF pdf, halfword p);
 
 #endif
--- texlive-bin.orig/texk/web2c/luatexdir/pdf/pdfobj.h
+++ texlive-bin/texk/web2c/luatexdir/pdf/pdfobj.h
@@ -35,7 +35,6 @@
 
 #  define OBJ_FLAG_ISSTREAM              (1 << 0)
 #  define OBJ_FLAG_ISFILE                (1 << 1)
-#  define OBJ_FLAG_NOLENGTH              (1 << 2)
 
 #  define obj_obj_is_stream(pdf,A)       ((obj_obj_flags((pdf), (A)) & OBJ_FLAG_ISSTREAM) != 0)
 #  define set_obj_obj_is_stream(pdf,A)   ((obj_obj_flags((pdf), (A)) |= OBJ_FLAG_ISSTREAM))
@@ -45,10 +44,6 @@
 #  define set_obj_obj_is_file(pdf,A)     ((obj_obj_flags((pdf), (A)) |= OBJ_FLAG_ISFILE))
 #  define unset_obj_obj_is_file(pdf,A)   ((obj_obj_flags((pdf), (A)) &= ~OBJ_FLAG_ISFILE))
 
-#  define obj_obj_no_length(pdf,A)       ((obj_obj_flags((pdf), (A)) & OBJ_FLAG_NOLENGTH) != 0)
-#  define set_obj_obj_no_length(pdf,A)   ((obj_obj_flags((pdf), (A)) |= OBJ_FLAG_NOLENGTH))
-#  define unset_obj_obj_no_length(pdf,A) ((obj_obj_flags((pdf), (A)) &= ~OBJ_FLAG_NOLENGTH))
-
 extern void init_obj_obj(PDF pdf, int k);
 extern void pdf_write_obj(PDF pdf, int n);
 extern void scan_obj(PDF pdf);
--- texlive-bin.orig/texk/web2c/luatexdir/pdf/pdftables.h
+++ texlive-bin/texk/web2c/luatexdir/pdf/pdftables.h
@@ -139,8 +139,6 @@ typedef enum {
     c_pdf_pk_fixed_dpi,
     c_pdf_suppress_optional_info,
     c_pdf_omit_cidset,
-    c_pdf_recompress,
-    c_pdf_omit_charset,
 } pdf_backend_counters ;
 
 typedef enum {
@@ -189,8 +187,6 @@ extern int pdf_cur_form;
 #  define pdf_pk_fixed_dpi              get_tex_extension_count_register(c_pdf_pk_fixed_dpi)
 #  define pdf_suppress_optional_info    get_tex_extension_count_register(c_pdf_suppress_optional_info)
 #  define pdf_omit_cidset               get_tex_extension_count_register(c_pdf_omit_cidset)
-#  define pdf_omit_charset              get_tex_extension_count_register(c_pdf_omit_charset)
-#  define pdf_recompress                get_tex_extension_count_register(c_pdf_recompress)
 
 #  define pdf_h_origin                  get_tex_extension_dimen_register(d_pdf_h_origin)
 #  define pdf_v_origin                  get_tex_extension_dimen_register(d_pdf_v_origin)
@@ -212,9 +208,7 @@ extern int pdf_cur_form;
 #  define set_pdf_compress_level(i)     set_tex_extension_count_register(c_pdf_compress_level,i)
 #  define set_pdf_obj_compress_level(i) set_tex_extension_count_register(c_pdf_obj_compress_level,i)
 #  define set_pdf_omit_cidset(i)        set_tex_extension_count_register(c_pdf_omit_cidset,i)
-#  define set_pdf_omit_charset(i)       set_tex_extension_count_register(c_pdf_omit_charset,i)
 #  define set_pdf_gen_tounicode(i)      set_tex_extension_count_register(c_pdf_gen_tounicode,i)
-#  define set_pdf_recompress(i)         set_tex_extension_count_register(c_pdf_recompress,i)
 
 #  define set_pdf_decimal_digits(i)     set_tex_extension_count_register(c_pdf_decimal_digits,i)
 #  define set_pdf_pk_resolution(i)      set_tex_extension_count_register(c_pdf_pk_resolution,i)
--- texlive-bin.orig/texk/web2c/luatexdir/pdf/pdftypes.h
+++ texlive-bin/texk/web2c/luatexdir/pdf/pdftypes.h
@@ -90,7 +90,10 @@ typedef struct {
 typedef struct scaledpos_ {
     int64_t h;
     int64_t v;
-} scaledpos;
+ } scaledpos;
+
+
+
 
 typedef struct scaled_whd_ {
     scaled wd; /* TeX width */
@@ -103,11 +106,11 @@ typedef struct posstructure_ {
     int dir;       /* direction of stuff to be put onto the page */
 } posstructure;
 
-/* typedef struct {         */
-/*     scaledpos curpos;    */ /* \pdflastpos position */
-/*     posstructure boxpos; */ /* box dir and position of the box origin on the page */
-/*     scaled_whd boxdim;   */ /* box dimensions (in hlist/vlist coordinate system) */
-/* } pos_info_structure;    */
+typedef struct {
+    scaledpos curpos;    /* \pdflastpos position */
+    posstructure boxpos; /* box dir and position of the box origin on the page */
+    scaled_whd boxdim;   /* box dimensions (in hlist/vlist coordinate system) */
+} pos_info_structure;
 
 typedef enum {
     PMODE_NONE,
@@ -156,10 +159,6 @@ typedef struct {
     int need_tf;                /* flag whether Tf needs to be set */
     int need_tm;                /* flag whether Tm needs to be set */
     int cur_ex;                 /* the current glyph ex factor */
-    int need_width;
-    int need_mode;
-    int done_width;
-    int done_mode;
 } pdfstructure;
 
 typedef struct obj_entry_ {
@@ -293,11 +292,9 @@ typedef struct pdf_output_file_ {
     int decimal_digits;
     int gen_tounicode;
     int omit_cidset;
-    int omit_charset;
     int inclusion_copy_font;
     int major_version;          /* fixed major part of the PDF version */
     int minor_version;          /* fixed minor part of the PDF version */
-    int recompress;
     int compress_level;         /* level for zlib object stream compression */
     int objcompresslevel;       /* fixed level for activating PDF object streams */
     char *job_id_string;        /* the full job string */
@@ -354,8 +351,6 @@ typedef struct pdf_output_file_ {
     int xform_count;
     int ximage_count;
 
-    int force_file;
-
     pdf_resource_struct *page_resources;
 
     scaledpos page_size;        /* width and height of page being shipped */
--- texlive-bin.orig/texk/web2c/luatexdir/ptexlib.h
+++ texlive-bin/texk/web2c/luatexdir/ptexlib.h
@@ -153,8 +153,7 @@ size_t          T##_limit
 #  include "tex/expand.h"
 #  include "tex/conditional.h"
 
-#  include "pdf/pdftypes.h" /* the backend data structure, shared between dvi and pdf (might move to |tex/backend| */
-#  include "tex/backend.h"  /* more backend data  */
+#  include "pdf/pdftypes.h" /* the backend data structure, shared between dvi and pdf */
 
 #  include "synctex.h"
 
@@ -255,7 +254,7 @@ int lua_appendtovlist_callback(
     halfword box, int location, halfword prev_depth, boolean is_mirrored,
     halfword * result, int * next_depth, boolean * prev_set);
 
-void lua_pdf_literal(PDF pdf, int i, int noline);
+void lua_pdf_literal(PDF pdf, int i);
 void copy_pdf_literal(pointer r, pointer p);
 void free_pdf_literal(pointer p);
 void show_pdf_literal(pointer p);
@@ -278,7 +277,7 @@ void undump_luac_registers(void);
 void luacstring_start(int n);
 void luacstring_close(int n);
 int luacstring_cattable(void);
-int luacstring_input(halfword *n);
+int luacstring_input(void);
 int luacstring_partial(void);
 int luacstring_final_line(void);
 
@@ -294,7 +293,6 @@ void flush_loggable_info(void);
 
 /* lua/luastuff.w  */
 void luafunctioncall(int slot);
-void luabytecodecall(int slot);
 
 /* lua/luastuff.c */
 void luatokencall(int p, int nameptr);
--- texlive-bin.orig/texk/web2c/luatexdir/tex/commands.h
+++ texlive-bin/texk/web2c/luatexdir/tex/commands.h
@@ -89,7 +89,6 @@ typedef enum {
     char_num_cmd,                         /* character specified numerically ( \.{\\char} ) */
     math_char_num_cmd,                    /* explicit math code ( \.{\\mathchar} ) */
     mark_cmd,                             /* mark definition ( \.{\\mark} ) */
-    node_cmd,
     xray_cmd,                             /* peek inside of \TeX\ ( \.{\\show}, \.{\\showbox}, etc.~) */
     make_box_cmd,                         /* make a box ( \.{\\box}, \.{\\copy}, \.{\\hbox}, etc.~) */
     hmove_cmd,                            /* horizontal motion ( \.{\\moveleft}, \.{\\moveright} ) */
@@ -135,9 +134,6 @@ typedef enum {
     normal_cmd,                           /* general extensions to \TeX\ that don't fit into a category */
     extension_cmd,                        /* extensions to \TeX\ ( \.{\\write}, \.{\\special}, etc.~) */
     option_cmd,
-    lua_function_call_cmd,
-    lua_bytecode_call_cmd,
-    lua_call_cmd,
     in_stream_cmd,                        /* files for reading ( \.{\\openin}, \.{\\closein} ) */
     begin_group_cmd,                      /* begin local grouping ( \.{\\begingroup} ) */
     end_group_cmd,                        /* end local grouping ( \.{\\endgroup} ) */
@@ -183,9 +179,7 @@ typedef enum {
     set_font_cmd,                         /* set current font ( font identifiers ) */
     def_font_cmd,                         /* define a font file ( \.{\\font} ) */
     register_cmd,                         /* internal register ( \.{\\count}, \.{\\dimen}, etc.~) */
-    assign_box_direction_cmd,             /* (\.{\\boxdirection}) */
     assign_box_dir_cmd,                   /* (\.{\\boxdir}) */
-    assign_direction_cmd,                 /* (\.{\\pagedirection}, \.{\\textdirection}) */
     assign_dir_cmd,                       /* (\.{\\pagedir}, \.{\\textdir}) */
 # define max_internal_cmd assign_dir_cmd  /* the largest code that can follow \.{\\the} */
     advance_cmd,                          /* advance a register or parameter ( \.{\\advance} ) */
@@ -194,7 +188,6 @@ typedef enum {
     prefix_cmd,                           /* qualify a definition ( \.{\\global}, \.{\\long}, \.{\\outer} ) */
     let_cmd,                              /* assign a command code ( \.{\\let}, \.{\\futurelet} ) */
     shorthand_def_cmd,                    /* code definition ( \.{\\chardef}, \.{\\countdef}, etc.~) */
-    def_lua_call_cmd,
     read_to_cs_cmd,                       /* read into a control sequence ( \.{\\read} ) */
     def_cmd,                              /* macro definition ( \.{\\def}, \.{\\gdef}, \.{\\xdef}, \.{\\edef} ) */
     set_box_cmd,                          /* set a box ( \.{\\setbox} ) */
@@ -208,8 +201,6 @@ typedef enum {
     expand_after_cmd,                     /* special expansion ( \.{\\expandafter} ) */
     no_expand_cmd,                        /* special nonexpansion ( \.{\\noexpand} ) */
     input_cmd,                            /* input a source file ( \.{\\input}, \.{\\endinput} or \.{\\scantokens} or \.{\\scantextokens} ) */
-    lua_expandable_call_cmd,
-    lua_local_call_cmd,
     if_test_cmd,                          /* conditional text ( \.{\\if}, \.{\\ifcase}, etc.~) */
     fi_or_else_cmd,                       /* delimiters for conditionals ( \.{\\else}, etc.~) */
     cs_name_cmd,                          /* make a control sequence from tokens ( \.{\\csname} ) */
@@ -245,12 +236,9 @@ typedef enum {
 
 typedef enum {
     number_code = 0,            /* command code for \.{\\number} */
-    lua_code,                   /* command code for \.{\\directlua} */
     lua_function_code,          /* command code for \.{\\luafunction} */
-    lua_bytecode_code,          /* command code for \.{\\luabytecode} */
+    lua_code,                   /* command code for \.{\\directlua} */
     expanded_code,              /* command code for \.{\\expanded} */
-    immediate_assignment_code,  /* command code for \.{\\immediateassignment} */
-    immediate_assigned_code,    /* command code for \.{\\assigned} */
     math_style_code,            /* command code for \.{\\mathstyle} */
     string_code,                /* command code for \.{\\string} */
     cs_string_code,             /* command code for \.{\\csstring} */
@@ -336,7 +324,6 @@ typedef enum {
     set_random_seed_code,
     save_pos_code,
     late_lua_code,
-    late_lua_call_code,
     expand_font_code,
 } normal_codes;
 
--- texlive-bin.orig/texk/web2c/luatexdir/tex/conditional.h
+++ texlive-bin/texk/web2c/luatexdir/tex/conditional.h
@@ -24,31 +24,30 @@
 #  define unless_code 32        /* amount added for `\.{\\unless}' prefix */
 
 typedef enum {
-    if_char_code       =  0, /* \.{\\if}          */
-    if_cat_code        =  1, /* \.{\\ifcat}       */
-    if_int_code        =  2, /* \.{\\ifnum}       */
-    if_dim_code        =  3, /* \.{\\ifdim}       */
-    if_odd_code        =  4, /* \.{\\ifodd}       */
-    if_vmode_code      =  5, /* \.{\\ifvmode}     */
-    if_hmode_code      =  6, /* \.{\\ifhmode}     */
-    if_mmode_code      =  7, /* \.{\\ifmmode}     */
-    if_inner_code      =  8, /* \.{\\ifinner}     */
-    if_void_code       =  9, /* \.{\\ifvoid}      */
-    if_hbox_code       = 10, /* \.{\\ifhbox}      */
-    if_vbox_code       = 11, /* \.{\\ifvbox}      */
-    if_x_code          = 12, /* \.{\\ifx}         */
-    if_eof_code        = 13, /* \.{\\ifeof}       */
-    if_true_code       = 14, /* \.{\\iftrue}      */
-    if_false_code      = 15, /* \.{\\iffalse}     */
-    if_case_code       = 16, /* \.{\\ifcase}      */
-    if_def_code        = 17, /* \.{\\ifdefined}   */
-    if_cs_code         = 18, /* \.{\\ifcsname}    */
-    if_font_char_code  = 19, /* \.{\\iffontchar}  */
-    if_in_csname_code  = 20, /* \.{\\ifincsname}  */
-    if_primitive_code  = 21, /* \.{\\ifprimitive} */
-    if_abs_num_code    = 22, /* \.{\\ifabsnum}    */
-    if_abs_dim_code    = 23, /* \.{\\ifabsdim}    */
-    if_condition_code  = 24, /* \.{\\ifcondition} */
+    if_char_code      =  0, /* \.{\\if}          */
+    if_cat_code       =  1, /* \.{\\ifcat}       */
+    if_int_code       =  2, /* \.{\\ifnum}       */
+    if_dim_code       =  3, /* \.{\\ifdim}       */
+    if_odd_code       =  4, /* \.{\\ifodd}       */
+    if_vmode_code     =  5, /* \.{\\ifvmode}     */
+    if_hmode_code     =  6, /* \.{\\ifhmode}     */
+    if_mmode_code     =  7, /* \.{\\ifmmode}     */
+    if_inner_code     =  8, /* \.{\\ifinner}     */
+    if_void_code      =  9, /* \.{\\ifvoid}      */
+    if_hbox_code      = 10, /* \.{\\ifhbox}      */
+    if_vbox_code      = 11, /* \.{\\ifvbox}      */
+    ifx_code          = 12, /* \.{\\ifx}         */
+    if_eof_code       = 13, /* \.{\\ifeof}       */
+    if_true_code      = 14, /* \.{\\iftrue}      */
+    if_false_code     = 15, /* \.{\\iffalse}     */
+    if_case_code      = 16, /* \.{\\ifcase}      */
+    if_def_code       = 17, /* \.{\\ifdefined}   */
+    if_cs_code        = 18, /* \.{\\ifcsname}    */
+    if_font_char_code = 19, /* \.{\\iffontchar}  */
+    if_in_csname_code = 20, /* \.{\\ifincsname}  */
+    if_primitive_code = 21, /* \.{\\ifprimitive} */
+    if_abs_num_code   = 22, /* \.{\\ifabsnum}    */
+    if_abs_dim_code   = 23, /* \.{\\ifabsdim}    */
 } if_type_codes;
 
 #  define if_limit_subtype(A) subtype((A)+1)
--- texlive-bin.orig/texk/web2c/luatexdir/tex/directions.h
+++ texlive-bin/texk/web2c/luatexdir/tex/directions.h
@@ -22,19 +22,43 @@
 #  define DIRECTIONS_H
 
 /*
-#define dir_swap 4
+    #  define dir_TLT  0
+    #  define dir_TRT  4
+    #  define dir_LTL  9
+    #  define dir_RTT  24
+
+    extern const char *dir_strings[128];
 */
 
-#define dir_min_value 0
-#define dir_max_value 3
+extern const char *dir_strings[8];
+
+extern int dir_swap;
+
+/*
+#  define RETURN_DIR_VALUES(a)       \
+    if (s==luaS_##a##_ptr) {         \
+        return (dir_##a);            \
+    } else if (!absolute_only)  {    \
+        if (s==luaS_p##a##_ptr)      \
+            return (dir_##a);        \
+        else if (s==luaS_m##a##_ptr) \
+            return ((dir_##a)-4);    \
+    }
+*/
 
-#define check_dir_value(d) \
-    if ((d < dir_min_value) || (d > dir_max_value)) \
-        d = dir_min_value;
+#  define RETURN_DIR_VALUES(a)    \
+    if (s==lua_key(a)) {          \
+        return (dir_##a);         \
+    } else if (!absolute_only)  { \
+        if (s==lua_key_plus(a))        \
+            return (dir_##a);     \
+        else if (s==lua_key_minus(a))   \
+            return ((dir_##a)-4); \
+    }
 
-#define is_mirrored(a) 0
+#  define is_mirrored(a) 0
 
-#define is_rotated(a) (a == dir_RTT)
+#  define is_rotated(a) (a == dir_RTT)
 
 /*
 
@@ -66,12 +90,10 @@
         (a == dir_RTT && b == dir_TRT) \
     )
 
-    # define dir_TLT_or_TRT(a) (a == dir_TLT || a == dir_TRT)
-    # define dir_LTL_or_RTT(a) (a == dir_LTL || a == dir_RTT)
-
 */
 
-/* TLT TRT LTL RTT */
+/* # define dir_TLT_or_TRT(a) (a == dir_TLT || a == dir_TRT) */
+/* # define dir_LTL_or_RTT(a) (a == dir_LTL || a == dir_RTT) */
 
 # define dir_TLT_or_TRT(a) (a < 2)
 # define dir_LTL_or_RTT(a) (a > 1)
@@ -152,8 +174,7 @@ extern void initialize_directions(void);
 extern halfword new_dir(int s);
 
 extern const char *string_dir(int d);
-extern void print_dir_par(int d);
-extern void print_dir_text(halfword d);
+extern void print_dir(int d);
 
 extern void scan_direction(void);
 
--- texlive-bin.orig/texk/web2c/luatexdir/tex/equivalents.h
+++ texlive-bin/texk/web2c/luatexdir/tex/equivalents.h
@@ -38,10 +38,10 @@ distinction.
 #  define biggest_reg              65535  /* the largest allowed register number; must be |< max_quarterword| */
 #  define number_regs              65536  /* |biggest_reg+1| */
 #  define number_attrs             65536  /* total numbeer of attributes */
-#  define biggest_char           1114111  /* 0x10FFFF, the largest allowed character number; must be |< max_halfword| */
-#  define too_big_char   (biggest_char+1) /* 1114112, |biggest_char+1| */
-#  define special_char   (biggest_char+2) /* 1114113, |biggest_char+2| */
-#  define number_chars   (biggest_char+3) /* 1114112, |biggest_char+1| */
+#  define biggest_char           1114111  /* the largest allowed character number; must be |< max_halfword| */
+#  define too_big_char           1114112  /* |biggest_char+1| */
+#  define special_char           1114113  /* |biggest_char+2| */
+#  define number_chars           1114112  /* |biggest_char+1| */
 #  define number_fonts (5535-font_base+1)
 #  define biggest_lang             32767
 #  define too_big_lang             32768
@@ -292,22 +292,15 @@ the |number_regs| \.{\\dimen} registers.
 #  define automatic_hyphen_penalty_code 101
 #  define explicit_hyphen_penalty_code 102
 #  define automatic_hyphen_mode_code 103
-#  define compound_hyphen_mode_code 104
-#  define break_after_dir_mode_code 105
-#  define exception_penalty_code 106
-
-#  define pre_bin_op_penalty_code 107
-#  define pre_rel_penalty_code 108
-#  define math_penalties_mode_code 109
-#  define math_delimiters_mode_code 110
-#  define math_script_box_mode_code 111
-#  define math_script_char_mode_code 112
-#  define math_rule_thickness_mode_code 113
-#  define math_flatten_mode_code 114
-
-#  define copy_lua_input_nodes_code 115
-#  define suppress_primitive_error_code 116
-#  define fixup_boxes_code 117
+#  define break_after_dir_mode_code 104
+
+#  define pre_bin_op_penalty_code 105
+#  define pre_rel_penalty_code 106
+#  define math_penalties_mode_code 107
+#  define math_delimiters_mode_code 108
+#  define math_script_box_mode_code 109
+
+#  define suppress_primitive_error_code 110
 
 #  define math_option_code (suppress_primitive_error_code+1)
 
@@ -448,8 +441,7 @@ We use the notation |saved(k)| to stand
 #  define saved_boxspec 14
 #  define saved_boxdir 15
 #  define saved_boxattr 16
-#  define saved_boxpack 17
-#  define saved_attrlist 18
+#  define saved_boxpack 18
 #  define saved_eqtb 19
 
 extern void print_save_stack(void);
@@ -461,9 +453,10 @@ extern void print_save_stack(void);
 
 typedef enum {
     c_mathoption_old_code = 0,                  /* this one is stable */
-    /*
-    c_mathoption_umathcode_meaning_code,
-    */
+    c_mathoption_no_italic_compensation_code,   /* just for tracing, can change */
+    c_mathoption_no_char_italic_code,           /* just for tracing, can change */
+    c_mathoption_use_old_fraction_scaling_code, /* just for tracing, can change */
+    c_mathoption_umathcode_meaning_code,        /* this one is stable */
 } math_option_codes ;
 
 #  define mathoption_int_par(A) eqtb[mathoption_int_base+(A)].cint
@@ -532,7 +525,7 @@ typedef enum {
     cramped_script_script_style, /* |subtype| for \.{\\crampedscriptscriptstyle} */
 } math_style_subtypes;
 
-typedef enum { /* this could move to directions.h */
+typedef enum {
     dir_TLT = 0,
     dir_TRT,
     dir_LTL,
@@ -670,9 +663,6 @@ extern halfword last_cs_name;
 #define math_penalties_mode_par            int_par(math_penalties_mode_code)
 #define math_delimiters_mode_par           int_par(math_delimiters_mode_code)
 #define math_script_box_mode_par           int_par(math_script_box_mode_code)
-#define math_script_char_mode_par          int_par(math_script_char_mode_code)
-#define math_rule_thickness_mode_par       int_par(math_rule_thickness_mode_code)
-#define math_flatten_mode_par              int_par(math_flatten_mode_code)
 #define null_delimiter_space_par           dimen_par(null_delimiter_space_code)
 #define disable_lig_par                    int_par(disable_lig_code)
 #define disable_kern_par                   int_par(disable_kern_code)
@@ -767,13 +757,12 @@ extern halfword last_cs_name;
 #define suppress_ifcsname_error_par        int_par(suppress_ifcsname_error_code)
 #define suppress_primitive_error_par       int_par(suppress_primitive_error_code)
 #define error_context_lines_par            int_par(error_context_lines_code)
-#define copy_lua_input_nodes_par           int_par(copy_lua_input_nodes_code)
 
 #define math_old_par                       mathoption_int_par(c_mathoption_old_code)
-
-/*
+#define math_no_italic_compensation_par    mathoption_int_par(c_mathoption_no_italic_compensation_code)
+#define math_no_char_italic_par            mathoption_int_par(c_mathoption_no_char_italic_code)
+#define math_use_old_fraction_scaling_par  mathoption_int_par(c_mathoption_use_old_fraction_scaling_code)
 #define math_umathcode_meaning_par         mathoption_int_par(c_mathoption_umathcode_meaning_code)
-*/
 
 #define math_pre_display_gap_factor_par    int_par(math_pre_display_gap_factor_code)
 
@@ -801,15 +790,11 @@ extern halfword last_cs_name;
 #define automatic_hyphen_penalty_par       int_par(automatic_hyphen_penalty_code)
 #define explicit_hyphen_penalty_par        int_par(explicit_hyphen_penalty_code)
 #define automatic_hyphen_mode_par          int_par(automatic_hyphen_mode_code)
-#define compound_hyphen_mode_par           int_par(compound_hyphen_mode_code)
 #define break_after_dir_mode_par           int_par(break_after_dir_mode_code)
-#define exception_penalty_par              int_par(exception_penalty_code)
 
 #define cur_lang_par                       int_par(cur_lang_code)
 #define cur_font_par                       equiv(cur_font_loc)
 
-#define fixup_boxes_par                    int_par(fixup_boxes_code)
-
 /* */
 
 #define math_use_current_family_code 7
--- texlive-bin.orig/texk/web2c/luatexdir/tex/extensions.h
+++ texlive-bin/texk/web2c/luatexdir/tex/extensions.h
@@ -136,12 +136,9 @@ typedef enum {
     use_box_resource_code,
     save_image_resource_code,
     use_image_resource_code,
-    end_local_code,
     /* backend */
     dvi_extension_code,
     pdf_extension_code,
 } extension_codes ;
 
-extern void wrapup_leader(halfword p);
-
 #endif
--- texlive-bin.orig/texk/web2c/luatexdir/tex/inputstack.h
+++ texlive-bin/texk/web2c/luatexdir/tex/inputstack.h
@@ -306,7 +306,6 @@ typedef enum {
     mark_text = 14,             /* |token_type| code for \.{\\topmark}, etc. */
     every_eof_text = 15,        /* |token_type| code for \.{\\everyeof} */
     write_text = 16,            /* |token_type| code for \.{\\write} */
-    local_text = 17,            /* |token_type| code for special purposed */
 } token_types;
 
 extern pointer *param_stack;
--- texlive-bin.orig/texk/web2c/luatexdir/tex/linebreak.h
+++ texlive-bin/texk/web2c/luatexdir/tex/linebreak.h
@@ -20,6 +20,9 @@
 #ifndef LINEBREAK_H
 #  define LINEBREAK_H
 
+#  define left_side 0
+#  define right_side 1
+
 extern halfword just_box;       /* the |hlist_node| for the last line of the new paragraph */
 
 extern void line_break(boolean d, int line_break_context);
--- texlive-bin.orig/texk/web2c/luatexdir/tex/mainbody.h
+++ texlive-bin/texk/web2c/luatexdir/tex/mainbody.h
@@ -139,9 +139,6 @@ extern int filelineerrorstylep;
 extern int haltonerrorp;
 extern boolean quoted_filename;
 
-extern int total_pages;
-extern int dead_cycles;
-
 /*
 In order to make efficient use of storage space, \TeX\ bases its major data
 structures on a |memory_word|, which contains either a (signed) integer,
--- texlive-bin.orig/texk/web2c/luatexdir/tex/maincontrol.h
+++ texlive-bin/texk/web2c/luatexdir/tex/maincontrol.h
@@ -151,7 +151,6 @@ extern void do_endv(void);
 extern void cs_error(void);
 extern void prefixed_command(void);
 extern void fixup_directions(void);
-extern void fixup_directions_only(void);
 
 
 /* Assignments from Lua need helpers. */
@@ -206,12 +205,5 @@ extern void show_whatever(void);
 
 extern void initialize(void);   /* this procedure gets things started properly */
 
-/*extern int local_level;*/
-
-extern void local_control(void);
-extern halfword local_scan_box(void);
-extern int current_local_level(void);
-extern void end_local_control(void);
-extern void local_control_message(const char *s);
 
 #endif
--- texlive-bin.orig/texk/web2c/luatexdir/tex/mlist.h
+++ texlive-bin/texk/web2c/luatexdir/tex/mlist.h
@@ -31,6 +31,5 @@ extern void fixup_math_parameters(int fa
 extern scaled get_math_quad_style(int a);
 extern scaled get_math_quad_size(int a);
 
-extern pointer make_extensible(internal_font_number fnt, halfword chr, scaled v, scaled min_overlap, int horizontal, halfword att);
 
 #endif
--- texlive-bin.orig/texk/web2c/luatexdir/tex/packaging.h
+++ texlive-bin/texk/web2c/luatexdir/tex/packaging.h
@@ -143,8 +143,7 @@ latter two are used denote \.{\\vbox} an
 #  define global_box_flag     (box_flag+number_regs)        /* context code for `\.{\\global\\setbox0}' */
 #  define max_global_box_flag (global_box_flag+number_regs)
 #  define ship_out_flag       (max_global_box_flag+1)       /* context code for `\.{\\shipout}' */
-#  define lua_scan_flag       (max_global_box_flag+2)       /* context code for |scan_list| */
-#  define leader_flag         (max_global_box_flag+3)       /* context code for `\.{\\leaders}' */
+#  define leader_flag         ship_out_flag+1               /* context code for `\.{\\leaders}' */
 
 extern void begin_box(int box_context);
 
--- texlive-bin.orig/texk/web2c/luatexdir/tex/printing.h
+++ texlive-bin/texk/web2c/luatexdir/tex/printing.h
@@ -77,7 +77,7 @@ extern void print_esc(str_number s);
 extern void print_the_digs(eight_bits k);
 extern void print_int(longinteger n);
 extern void print_two(int n);
-extern void print_qhex(int n);
+extern void print_hex(int n);
 extern void print_roman_int(int n);
 extern void print_current_string(void);
 
--- texlive-bin.orig/texk/web2c/luatexdir/tex/scanning.h
+++ texlive-bin/texk/web2c/luatexdir/tex/scanning.h
@@ -63,13 +63,9 @@ extern void scan_fifty_one_bit_int(void)
 #  define hex_token (other_token+'"')               /* double quote, indicates a hex constant */
 #  define alpha_token (other_token+'`')             /* reverse apostrophe, precedes alpha constants */
 #  define point_token (other_token+'.')             /* decimal point */
-#  define comma_token (other_token+',')             /* decimal comma */
-#  define plus_token (other_token + '+')
-#  define minus_token (other_token + '-')
 #  define continental_point_token (other_token+',') /* decimal point, Eurostyle */
 #  define infinity 017777777777                     /* the largest positive value that \TeX\ knows */
 #  define zero_token (other_token+'0')              /* zero, the smallest digit */
-#  define nine_token (other_token+'9')              /* zero, the smallest digit */
 #  define A_token (letter_token+'A')                /* the smallest special hex digit */
 #  define other_A_token (other_token+'A')           /* special hex digit of type |other_char| */
 extern int radix;
@@ -82,6 +78,7 @@ extern int cur_order;
 
 extern void scan_dimen(boolean mu, boolean inf, boolean shortcut);
 extern void scan_glue(int level);
+extern void scan_scaled(void);
 
 extern halfword the_toks(void);
 extern str_number the_scanned_result(void);
--- texlive-bin.orig/texk/web2c/luatexdir/tex/stringpool.h
+++ texlive-bin/texk/web2c/luatexdir/tex/stringpool.h
@@ -1,5 +1,5 @@
 /* stringpool.h
-
+   
    Copyright 2009 Taco Hoekwater <taco@luatex.org>
 
    This file is part of LuaTeX.
@@ -43,10 +43,9 @@ extern str_number init_str_ptr;
 
 #  define get_nullstr() STRING_OFFSET
 
-#  define biggest_char           1114111  /* 0x10FFFF, the largest allowed character number; must be |< max_halfword| */
-#  define too_big_char   (biggest_char+1) /* 1114112, |biggest_char+1| */
-#  define special_char   (biggest_char+2) /* 1114113, |biggest_char+2| */
-#  define number_chars   (biggest_char+3) /* 1114112, |biggest_char+1| */
+#  define biggest_char 1114111
+#  define number_chars 1114112
+#  define special_char 1114113  /* |biggest_char+2| */
 
 /*
   Several of the elementary string operations are performed using
--- texlive-bin.orig/texk/web2c/luatexdir/tex/texmath.h
+++ texlive-bin/texk/web2c/luatexdir/tex/texmath.h
@@ -38,6 +38,22 @@ extern halfword new_sub_box(halfword);
 
 #  define default_code 010000000000     /* denotes |default_rule_thickness| */
 
+typedef enum {
+    ord_noad_type = 0,
+    op_noad_type_normal,
+    op_noad_type_limits,
+    op_noad_type_no_limits,
+    bin_noad_type,
+    rel_noad_type,
+    open_noad_type,
+    close_noad_type,
+    punct_noad_type,
+    inner_noad_type,
+    under_noad_type,
+    over_noad_type,
+    vcenter_noad_type,
+} noad_types;
+
 extern void initialize_math(void);
 extern void initialize_math_spacing(void);
 extern halfword math_vcenter_group(halfword);
--- texlive-bin.orig/texk/web2c/luatexdir/tex/texnodes.h
+++ texlive-bin/texk/web2c/luatexdir/tex/texnodes.h
@@ -97,30 +97,8 @@ extern halfword do_set_attribute(halfwor
 #  define list_offset 6
 
 typedef enum {
-    user_skip_glue,
-    line_skip_glue,
-    baseline_skip_glue,
-    par_skip_glue,
-    above_display_skip_glue,
-    below_display_skip_glue,
-    above_display_short_skip_glue,
-    below_display_short_skip_glue,
-    left_skip_glue,
-    right_skip_glue,
-    top_skip_glue,
-    split_top_skip_glue,
-    tab_skip_glue,
-    space_skip_glue,
-    xspace_skip_glue,
-    par_fill_skip_glue,
-    math_skip_glue,
-    thin_mu_skip_glue,
-    med_mu_skip_glue,
-    thick_mu_skip_glue,
-    /* math */
     cond_math_glue = 98,        /* special |subtype| to suppress glue in the next node */
     mu_glue,                    /* |subtype| for math glue */
-    /* leaders */
     a_leaders,                  /* |subtype| for aligned leaders */
     c_leaders,                  /* |subtype| for centered leaders */
     x_leaders,                  /* |subtype| for expanded leaders */
@@ -221,7 +199,7 @@ typedef enum {
 #  define disc_penalty(a)     vlink((a)+2)
 #  define pre_break(a)        vinfo((a)+3)
 #  define post_break(a)       vlink((a)+3)
-#  define no_break(a)         vlink((a)+4) /* we have vinfo((a)+4) for later usage */
+#  define no_break(a)         vlink((a)+4)
 
 #  define vlink_pre_break(a)  vlink(pre_break_head(a))
 #  define vlink_post_break(a) vlink(post_break_head(a))
@@ -286,17 +264,14 @@ typedef enum {
     math_under_rule,
     math_fraction_rule,
     math_radical_rule,
-    outline_rule,
 } rule_subtypes;
 
-#  define rule_node_size       9
+#  define rule_node_size       8
 #  define rule_dir(a)          vlink((a)+5)
 #  define rule_index(a)        vinfo((a)+6)
 #  define rule_transform(a)    vlink((a)+6)
-#  define rule_left(a)         vinfo((a)+7)
-#  define rule_right(a)        vlink((a)+7)
-#  define synctex_tag_rule(a)  vinfo((a)+8)
-#  define synctex_line_rule(a) vlink((a)+8)
+#  define synctex_tag_rule(a)  vinfo((a)+7)
+#  define synctex_line_rule(a) vlink((a)+7)
 
 #  define rule_math_size       rule_index
 #  define rule_math_font       rule_transform
@@ -317,7 +292,7 @@ typedef enum {
 #  define x_displace(a)         vinfo((a)+4)
 #  define y_displace(a)         vlink((a)+4)
 #  define ex_glyph(a)           vinfo((a)+5)  /* expansion factor (hz) */
-#  define glyph_node_data(a)    vlink((a)+5)
+#  define x_advance(a)          vlink((a)+5)  /* obsolete, can become user field */
 #  define synctex_tag_glyph(a)  vinfo((a)+6)
 #  define synctex_line_glyph(a) vlink((a)+6)
 
@@ -343,15 +318,11 @@ typedef enum {
 
 /*@# {|subtype| of marginal kerns}*/
 
-typedef enum {
-    left_side = 0,
-    right_side
-} margin_kern_subtypes ;
+#  define left_side  0
+#  define right_side 1
 
-typedef enum {
-    before = 0,
-    after
-} math_subtypes ;
+#  define before     0 /* |subtype| for math node that introduces a formula */
+#  define after      1 /* |subtype| for math node that winds up a formula */
 
 #  define math_node_size       7
 /* define width(a)             vinfo((a)+2) */
@@ -516,24 +487,6 @@ typedef enum {
 #  define noadextra3(a)  vlink((a)+7) /* see (!) below */
 #  define noadextra4(a)  vinfo((a)+7) /* used to store samesize */
 
-#  define noad_fam(a)    vlink((a)+6) /* noadextra1 */
-
-typedef enum {
-    ord_noad_type = 0,
-    op_noad_type_normal,
-    op_noad_type_limits,
-    op_noad_type_no_limits,
-    bin_noad_type,
-    rel_noad_type,
-    open_noad_type,
-    close_noad_type,
-    punct_noad_type,
-    inner_noad_type,
-    under_noad_type,
-    over_noad_type,
-    vcenter_noad_type,
-} noad_types;
-
 /* accent noads */
 
 #  define accent_noad_size      8
@@ -542,13 +495,6 @@ typedef enum {
 #  define overlay_accent_chr(a) vinfo((a)+7) /* the |overlay_accent_chr| field of an accent noad */
 #  define accentfraction(a)     vlink((a)+7)
 
-typedef enum {
-    bothflexible_accent,
-    fixedtop_accent,
-    fixedbottom_accent,
-    fixedboth_accent,
-} math_accent_subtypes ;
-
 /* left and right noads */
 
 #  define fence_noad_size      8            /* needs to match noad size */
@@ -594,36 +540,22 @@ typedef enum {
     noad_delimiter_mode_noshift = 0x01,
     noad_delimiter_mode_italics = 0x02,
     noad_delimiter_mode_ordinal = 0x04,
-    noad_delimiter_mode_samenos = 0x08,
-    noad_delimiter_mode_charnos = 0x10,
 } delimiter_modes ;
 
 #  define delimitermodenoshift ((math_delimiters_mode_par & noad_delimiter_mode_noshift) == noad_delimiter_mode_noshift)
 #  define delimitermodeitalics ((math_delimiters_mode_par & noad_delimiter_mode_italics) == noad_delimiter_mode_italics)
 #  define delimitermodeordinal ((math_delimiters_mode_par & noad_delimiter_mode_ordinal) == noad_delimiter_mode_ordinal)
-#  define delimitermodesamenos ((math_delimiters_mode_par & noad_delimiter_mode_samenos) == noad_delimiter_mode_samenos)
-#  define delimitermodecharnos ((math_delimiters_mode_par & noad_delimiter_mode_charnos) == noad_delimiter_mode_charnos)
 
 /* subtype of fence noads */
 
-/*
 #  define left_noad_side   1
 #  define middle_noad_side 2
 #  define right_noad_side  3
 #  define no_noad_side     4
-*/
-
-typedef enum {
-    unset_noad_side  = 0,
-    left_noad_side   = 1,
-    middle_noad_side = 2,
-    right_noad_side  = 3,
-    no_noad_side     = 4,
-} fence_subtypes ;
 
 /* fraction noads */
 
-#  define fraction_noad_size  8
+#  define fraction_noad_size  7
 #  define thickness(a)        vlink((a)+2) /* |thickness| field in a fraction noad */
 #  define numerator(a)        vlink((a)+3) /* |numerator| field in a fraction noad */
 #  define denominator(a)      vinfo((a)+3) /* |denominator| field in a fraction noad */
@@ -631,7 +563,6 @@ typedef enum {
 #  define right_delimiter(a)  vinfo((a)+5) /* second delimiter field of a fraction noad */
 #  define middle_delimiter(a) vlink((a)+6)
 #  define fractionoptions(a)  vinfo((a)+6)
-#  define fraction_fam(a)     vlink((a)+7)
 
 #  define fractionoptionset(a) ((fractionoptions(a) & noad_option_set    ) == noad_option_set    )
 #  define fractionexact(a)     ((fractionoptions(a) & noad_option_exact  ) == noad_option_exact  )
@@ -651,16 +582,6 @@ typedef enum {
 #  define radicalmiddle(a)    ((radicaloptions(a) & noad_option_middle) == noad_option_middle)
 #  define radicalright(a)     ((radicaloptions(a) & noad_option_right ) == noad_option_right)
 
-typedef enum {
-    radical_noad_type,
-    uradical_noad_type,
-    uroot_noad_type,
-    uunderdelimiter_noad_type,
-    uoverdelimiter_noad_type,
-    udelimiterunder_noad_type,
-    udelimiterover_noad_type,
-} radical_subtypes;
-
 /* accessors for the |nucleus|-style node fields */
 
 #  define math_kernel_node_size 3
@@ -738,15 +659,6 @@ typedef enum {
 #  define GLYPH_LEFT          (1 << 3)
 #  define GLYPH_RIGHT         (1 << 4)
 
-typedef enum {
-    glyph_unset     = 0,
-    glyph_character = GLYPH_CHARACTER,
-    glyph_ligature  = GLYPH_LIGATURE,
-    glyph_ghost     = GLYPH_GHOST,
-    glyph_left      = GLYPH_LEFT,
-    glyph_right     = GLYPH_RIGHT,
-} glyph_subtypes;
-
 #  define is_character(p)        ((subtype(p)) & GLYPH_CHARACTER)
 #  define is_ligature(p)         ((subtype(p)) & GLYPH_LIGATURE )
 #  define is_ghost(p)            ((subtype(p)) & GLYPH_GHOST    )
@@ -786,11 +698,6 @@ typedef enum {
 
 #  define special_node_size 3
 
-typedef enum {
-    normal_dir = 0,
-    cancel_dir,
-} dir_subtypes ;
-
 #  define dir_node_size 5
 #  define dir_dir(a)       vinfo((a)+2)
 #  define dir_level(a)     vlink((a)+2)
@@ -830,7 +737,6 @@ typedef enum {
 /* type of literal data */
 
 #  define lua_refid_literal 1 /* not a |normal| string */
-#  define lua_refid_call    2 /* not a |normal| string */
 
 /* begin of pdf backend nodes */
 
@@ -993,60 +899,40 @@ extern void print_short_node_contents(ha
 extern void show_node_list(int i);
 extern pointer actual_box_width(pointer r, scaled base_width);
 
-typedef struct _subtype_info {
-    int id;
-    const char *name;
-    int lua;
-} subtype_info;
-
-typedef struct _field_info {
-    const char *name;
-    int lua;
-} field_info;
+/* from luanode.c */
 
 typedef struct _node_info {
     int id;
     int size;
-    subtype_info *subtypes;
-    field_info *fields;
+    const char **fields;
     const char *name;
     int etex;
-    int lua;
 } node_info;
 
 extern node_info node_data[];
 extern node_info whatsit_node_data[];
 
-extern subtype_info node_subtypes_dir[];
-extern subtype_info node_subtypes_glue[];
-extern subtype_info node_subtypes_mathglue[];
-extern subtype_info node_subtypes_leader[];
-extern subtype_info node_subtypes_boundary[];
-extern subtype_info node_subtypes_penalty[];
-extern subtype_info node_subtypes_kern[];
-extern subtype_info node_subtypes_rule[];
-extern subtype_info node_subtypes_glyph[];
-extern subtype_info node_subtypes_disc[];
-extern subtype_info node_subtypes_marginkern[];
-extern subtype_info node_subtypes_list[];
-extern subtype_info node_subtypes_adjust[];
-extern subtype_info node_subtypes_math[];
-extern subtype_info node_subtypes_noad[];
-extern subtype_info node_subtypes_radical[];
-extern subtype_info node_subtypes_accent[];
-extern subtype_info node_subtypes_fence[];
-
-extern subtype_info node_values_pdf_destination[];
-extern subtype_info node_values_pdf_literal[];
-extern subtype_info node_values_pdf_literal[];
-extern subtype_info node_values_pdf_action[];
-extern subtype_info node_values_pdf_window[];
-
-extern subtype_info node_values_fill[];
-extern subtype_info node_values_dir[];
-extern subtype_info node_values_color_stack[];
+extern const char *node_subtypes_glue[];
+extern const char *node_subtypes_mathglue[];
+extern const char *node_subtypes_leader[];
+extern const char *node_subtypes_fill[];
+extern const char *node_subtypes_boundary[];
+extern const char *node_subtypes_penalty[];
+extern const char *node_subtypes_kern[];
+extern const char *node_subtypes_rule[];
+extern const char *node_subtypes_glyph[];
+extern const char *node_subtypes_disc[];
+extern const char *node_subtypes_marginkern[];
+extern const char *node_subtypes_list[];
+extern const char *node_subtypes_adjust[];
+extern const char *node_subtypes_math[];
+extern const char *node_subtypes_noad[];
+extern const char *node_subtypes_radical[];
+extern const char *node_subtypes_accent[];
+extern const char *node_subtypes_fence[];
 
-extern subtype_info other_values_page_states[];
+extern const char *node_subtypes_pdf_destination[];
+extern const char *node_subtypes_pdf_literal[];
 
 extern halfword new_node(int i, int j);
 extern void flush_node_list(halfword);
@@ -1072,7 +958,7 @@ extern void show_node_wrapup_dvi(halfwor
 extern void show_node_wrapup_pdf(halfword);
 
 typedef enum {
-    normal_g = 0, /* normal */
+    normal_g = 0,
     sfi,
     fil,
     fill,
@@ -1151,8 +1037,5 @@ extern void synctex_set_no_files(int fla
 extern int synctex_get_no_files(void);
 extern int synctex_get_line(void);
 
-extern void l_set_node_data(void) ;
-extern void l_set_whatsit_data(void) ;
-
 #endif
 
--- texlive-bin.orig/texk/web2c/luatexdir/tex/textoken.h
+++ texlive-bin/texk/web2c/luatexdir/tex/textoken.h
@@ -25,19 +25,19 @@
 #  define null 0
 #  define cs_token_flag 0x1FFFFFFF
 
-#  define left_brace_token  0x0200000  /* $2^{21}\cdot|left_brace|$ */
-#  define right_brace_token 0x0400000  /* $2^{21}\cdot|right_brace|$ */
-#  define left_brace_limit  0x0400000  /* $2^{21}\cdot(|left_brace|+1)$ */
-#  define right_brace_limit 0x0600000  /* $2^{21}\cdot(|right_brace|+1)$ */
-#  define math_shift_token  0x0600000  /* $2^{21}\cdot|math_shift|$ */
-#  define tab_token         0x0800000  /* $2^{21}\cdot|tab_mark|$ */
-#  define out_param_token   0x0A00000  /* $2^{21}\cdot|out_param|$ */
-#  define space_token       0x1400020  /* $2^{21}\cdot|spacer|+|" "|$ */
-#  define letter_token      0x1600000  /* $2^{21}\cdot|letter|$ */
-#  define other_token       0x1800000  /* $2^{21}\cdot|other_char|$ */
-#  define match_token       0x1A00000  /* $2^{21}\cdot|match|$ */
-#  define end_match_token   0x1C00000  /* $2^{21}\cdot|end_match|$ */
-#  define protected_token   0x1C00001  /* $2^{21}\cdot|end_match|+1$ */
+#  define left_brace_token 0x200000     /* $2^{21}\cdot|left_brace|$ */
+#  define right_brace_token 0x400000    /* $2^{21}\cdot|right_brace|$ */
+#  define left_brace_limit 0x400000     /* $2^{21}\cdot(|left_brace|+1)$ */
+#  define right_brace_limit 0x600000    /* $2^{21}\cdot(|right_brace|+1)$ */
+#  define math_shift_token 0x600000     /* $2^{21}\cdot|math_shift|$ */
+#  define tab_token 0x800000    /* $2^{21}\cdot|tab_mark|$ */
+#  define out_param_token 0xA00000      /* $2^{21}\cdot|out_param|$ */
+#  define space_token 0x1400020 /* $2^{21}\cdot|spacer|+|" "|$ */
+#  define letter_token 0x1600000        /* $2^{21}\cdot|letter|$ */
+#  define other_token 0x1800000 /* $2^{21}\cdot|other_char|$ */
+#  define match_token 0x1A00000 /* $2^{21}\cdot|match|$ */
+#  define end_match_token 0x1C00000     /* $2^{21}\cdot|end_match|$ */
+#  define protected_token 0x1C00001     /* $2^{21}\cdot|end_match|+1$ */
 
 #  include "tex/stringpool.h"
 
@@ -126,7 +126,6 @@ extern void make_token_table(lua_State *
 extern void get_next(void);
 extern void check_outer_validity(void);
 extern boolean scan_keyword(const char *);
-extern boolean scan_keyword_case_sensitive(const char *);
 extern halfword active_to_cs(int, int);
 extern void get_token_lua(void);
 halfword string_to_toks(const char *);
@@ -184,6 +183,4 @@ extern void free_lstring(lstring * ls);
 #  define token_chr(A) ((A) & (STRING_OFFSET - 1))
 #  define token_val(A,B) (((A)<<STRING_OFFSET_BITS)+(B))
 
-extern void l_set_token_data(void) ;
-
 #endif
--- texlive-bin.orig/texk/web2c/luatexdir/unilib/gwwiconv.c
+++ texlive-bin/texk/web2c/luatexdir/unilib/gwwiconv.c
@@ -46,8 +46,7 @@ struct gww_iconv_t {
     enum encoding to;
 };
 
-/*enum extended_encoding { e_jisgbpk = e_encodingmax };*/
-#define e_jisgbpk e_encodingmax 
+enum extended_encoding { e_jisgbpk = e_encodingmax };
 
 static enum endian { end_big, end_little, end_unknown } endian = end_unknown;
 
--- texlive-bin.orig/texk/web2c/mplibdir/ChangeLog
+++ texlive-bin/texk/web2c/mplibdir/ChangeLog
@@ -1,7 +1,3 @@
-2018-08-27  Luigi Scarso  <luigi.scarso@gmail.com>
-	* separation of mpmathbinary from the the core
-
-
 2018-02-19  Luigi Scarso  <luigi.scarso@gmail.com>
 	* Small cleanup of the code
 	* Bump to version 2.0rc2: the current version is 2.00
--- texlive-bin.orig/texk/web2c/mplibdir/am/libmplib.am
+++ texlive-bin/texk/web2c/mplibdir/am/libmplib.am
@@ -5,18 +5,15 @@
 
 ## libmplib.a, used by MetaPost and luaTeX
 ##
-EXTRA_LIBRARIES += libmplibcore.a libmplibextramath.a libmplibbackends.a 
+EXTRA_LIBRARIES += libmplibcore.a libmplibbackends.a 
 
-
-libmplibcore_a_CPPFLAGS =  $(LIBPNG_INCLUDES) $(ZLIB_INCLUDES) $(AM_CPPFLAGS) -I$(srcdir)/mplibdir
-libmplibextramath_a_CPPFLAGS = $(MPFR_INCLUDES) $(GMP_INCLUDES) -I${top_builddir}/../../libs   $(AM_CPPFLAGS) -I$(srcdir)/mplibdir
+libmplibcore_a_CPPFLAGS = $(MPFR_INCLUDES) $(GMP_INCLUDES) $(LIBPNG_INCLUDES) $(ZLIB_INCLUDES) $(AM_CPPFLAGS) -I$(srcdir)/mplibdir
 libmplibbackends_a_CPPFLAGS = $(MPFR_INCLUDES) $(GMP_INCLUDES) $(CAIRO_INCLUDES) $(PIXMAN_INCLUDES) \
 	$(LIBPNG_INCLUDES) $(ZLIB_INCLUDES) $(AM_CPPFLAGS) -I$(srcdir)/mplibdir
 
-## libmplib C sources core + extramath + backends
-nodist_libmplibcore_a_SOURCES = tfmin.c $(mp_c_h) $(mpmath_c_h) $(mpmathdecimal_c_h) \
+## libmplib C sources core + backends
+nodist_libmplibcore_a_SOURCES = tfmin.c $(mp_c_h) $(mpmath_c_h) $(mpmathbinary_c_h) $(mpmathdecimal_c_h) \
 	$(mpmathdouble_c_h) $(mpstrings_c_h) $(psout_c_h) 
-nodist_libmplibextramath_a_SOURCES = $(mpmathbinary_c_h)
 nodist_libmplibbackends_a_SOURCES = $(pngout_c_h)  $(svgout_c_h)
 
 
@@ -87,16 +84,15 @@ libmplib_web += mplibdir/mpmath.w mplibd
 libmplib_web += mplibdir/mpmathdouble.w mplibdir/mpstrings.w mplibdir/tfmin.w
 
 ## core need headers backends
-$(nodist_libmplibcore_a_SOURCES): $(mpmathbinary_c_h) $(svgout_c_h) $(pngout_c_h)
+$(nodist_libmplibcore_a_SOURCES): $(svgout_c_h) $(pngout_c_h)
 
-$(libmplibcore_a_OBJECTS): $(nodist_libmplibcore_a_SOURCES) $(KPATHSEA_DEPEND)  
-$(libmplibextramath_a_OBJECTS): $(nodist_libmplibextramath_a_SOURCES) $(KPATHSEA_DEPEND)  $(MPFR_DEPEND)
+$(libmplibcore_a_OBJECTS): $(nodist_libmplibcore_a_SOURCES) $(KPATHSEA_DEPEND)  $(MPFR_DEPEND)
 $(libmplibbackends_a_OBJECTS): $(nodist_libmplibbackends_a_SOURCES) $(KPATHSEA_DEPEND) $(CAIRO_DEPEND) $(MPFR_DEPEND)
 
 
 EXTRA_DIST += $(libmplib_web)
 
-DISTCLEANFILES += $(nodist_libmplibcore_a_SOURCES) $(nodist_libmplibextramath_a_SOURCES) $(nodist_libmplibbackends_a_SOURCES) \
-	mp-tangle mpmath-tangle mpmathdecimal-tangle mpmathdouble-tangle \
+DISTCLEANFILES += $(nodist_libmplibcore_a_SOURCES) $(nodist_libmplibbackends_a_SOURCES)	\
+	mp-tangle mpmath-tangle mpmathbinary-tangle mpmathdecimal-tangle mpmathdouble-tangle \
 	mpstrings-tangle psout-tangle svgout-tangle pngout-tangle
 
--- texlive-bin.orig/texk/web2c/mplibdir/am/mplib.am
+++ texlive-bin/texk/web2c/mplibdir/am/mplib.am
@@ -18,7 +18,9 @@ endif MP
 EXTRA_PROGRAMS += mpost
 
 mpost_CPPFLAGS = $(AM_CPPFLAGS) $(ZLIB_INCLUDES) $(LIBPNG_INCLUDES) -I$(srcdir)/mplibdir
-mpost_LDADD = libmplibcore.a libmplibextramath.a libmplibbackends.a  $(KPATHSEA_LIBS) $(MPFR_LIBS) $(GMP_LIBS) \
+#mpost_LDADD = libmplib.a $(KPATHSEA_LIBS) $(MPFR_LIBS) $(GMP_LIBS) \
+#	$(CAIRO_LIBS) $(PIXMAN_LIBS) $(LIBPNG_LIBS) $(ZLIB_LIBS) libmputil.a
+mpost_LDADD = libmplibcore.a libmplibbackends.a  $(KPATHSEA_LIBS) $(MPFR_LIBS) $(GMP_LIBS) \
 	$(CAIRO_LIBS) $(PIXMAN_LIBS) $(LIBPNG_LIBS) $(ZLIB_LIBS) libmputil.a
 
 
@@ -58,7 +60,7 @@ mpxout-tangle: ctangle$(EXEEXT) mplibdir
 mpost_web = mplibdir/mpost.w mplibdir/mpxout.w
 
 #$(mpost_OBJECTS): $(nodist_mpost_SOURCES) libmplib.a $(LIBPNG_DEPEND)
-$(mpost_OBJECTS): $(nodist_mpost_SOURCES) libmplibcore.a libmplibextramath.a libmplibbackends.a $(LIBPNG_DEPEND)
+$(mpost_OBJECTS): $(nodist_mpost_SOURCES) libmplibcore.a libmplibbackends.a $(LIBPNG_DEPEND)
 
 EXTRA_DIST += mplibdir/ChangeLog $(mpost_web)
 
--- texlive-bin.orig/texk/web2c/mplibdir/lmplib.c
+++ texlive-bin/texk/web2c/mplibdir/lmplib.c
@@ -15,9 +15,7 @@
    License for more details.
 
    You should have received a copy of the GNU Lesser General Public License along
-   with LuaTeX; if not, see <http://www.gnu.org/licenses/>.
-
-*/
+   with LuaTeX; if not, see <http://www.gnu.org/licenses/>. */
 
 #include <w2c/config.h>
 #include <stdlib.h>
@@ -25,7 +23,7 @@
 #ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
-#include <math.h>
+#include <math.h> /* temporary */
 
 #ifndef pdfTeX
 #  include <lua.h>
@@ -43,23 +41,20 @@
 #define luaL_reg luaL_Reg
 #endif
 
+
 #ifndef lua_objlen
 #define lua_objlen lua_rawlen
 #endif
 
+
 #include "mplib.h"
 #include "mplibps.h"
 #include "mplibsvg.h"
 #include "mplibpng.h"
 
-int luaopen_mplib(lua_State * L);
+int luaopen_mplib(lua_State * L); /* forward */
 
-/*tex
-
-    We need a few metatable identifiers in order to access the metatables for the
-    main object and result userdata.
-
-*/
+/* metatable identifiers and tests */
 
 #define MPLIB_METATABLE     "MPlib.meta"
 #define MPLIB_FIG_METATABLE "MPlib.fig"
@@ -69,33 +64,25 @@ int luaopen_mplib(lua_State * L);
 #define is_fig(L,b) (struct mp_edge_object **)luaL_checkudata(L,b,MPLIB_FIG_METATABLE)
 #define is_gr_object(L,b) (struct mp_graphic_object **)luaL_checkudata(L,b,MPLIB_GR_METATABLE)
 
-/*tex
+/* Lua string pre-hashing */
 
-    We pre-hash the \LUA\ strings which is much faster. The approach is similar to the one
-    used at the \TEX\ end.
+#define mplib_init_S(a) do {                                            \
+    lua_pushliteral(L,#a);                                              \
+    mplib_##a##_ptr = lua_tostring(L,-1);				\
+    mplib_##a##_index = luaL_ref (L,LUA_REGISTRYINDEX);                 \
+  } while (0)
 
-*/
+#define mplib_push_S(a) do {                                    \
+    lua_rawgeti(L,LUA_REGISTRYINDEX,mplib_##a##_index);         \
+  } while (0)
 
-#define mplib_init_S(a) do {                            \
-    lua_pushliteral(L,#a);                              \
-    mplib_##a##_ptr = lua_tostring(L,-1);               \
-    mplib_##a##_index = luaL_ref (L,LUA_REGISTRYINDEX); \
-} while (0)
-
-#define mplib_push_S(a) do {                            \
-    lua_rawgeti(L,LUA_REGISTRYINDEX,mplib_##a##_index); \
-} while (0)
-
-#define mplib_is_S(a,i) \
-    (mplib_##a##_ptr==lua_tostring(L,i))
-
-#define mplib_make_S(a)                     \
-    static int mplib_##a##_index = 0;         \
-    static const char *mplib_##a##_ptr = NULL
+#define mplib_is_S(a,i) (mplib_##a##_ptr==lua_tostring(L,i))
 
-/*tex In the next array entry 0 is not used */
+#define mplib_make_S(a)                                                 \
+  static int mplib_##a##_index = 0;                                     \
+  static const char *mplib_##a##_ptr = NULL
 
-static int mplib_type_Ses[mp_special_code + 1] = { 0 };
+static int mplib_type_Ses[mp_special_code + 1] = { 0 }; /* [0] is not used */
 
 mplib_make_S(term);
 mplib_make_S(error);
@@ -107,7 +94,6 @@ mplib_make_S(memory);
 mplib_make_S(hash);
 mplib_make_S(params);
 mplib_make_S(open);
-mplib_make_S(cycle);
 
 mplib_make_S(offset);
 mplib_make_S(dashes);
@@ -167,7 +153,6 @@ static void mplib_init_Ses(lua_State * L
     mplib_init_S(hash);
     mplib_init_S(params);
     mplib_init_S(open);
-    mplib_init_S(cycle);
 
     mplib_init_S(offset);
     mplib_init_S(dashes);
@@ -225,15 +210,11 @@ static void mplib_init_Ses(lua_State * L
     mplib_init_S(elliptical);
 }
 
-/*tex
-
-    Here are some enumeration arrays to map MPlib enums to \LUA\ strings. If needed
-    we can also predefine keys here, as we do with nodes.
 
-*/
+/* Enumeration arrays to map MPlib enums to Lua strings */
 
 static const char *math_options[] =
-    { "scaled", "double", "binary", "decimal", NULL };
+  { "scaled", "double", "binary", "decimal", NULL };
 
 static const char *interaction_options[] =
     { "unknown", "batch", "nonstop", "scroll", "errorstop", NULL };
@@ -274,34 +255,18 @@ static const char *stop_clip_fields[] =
 static const char *no_fields[] =
     { NULL };
 
-/*tex
 
-    The list of supported MPlib options (not all make sense).
-
-*/
+/* The list of supported MPlib options (not all make sense) */
 
 typedef enum {
-    P_ERROR_LINE,
-    P_MAX_LINE,
-    P_RANDOM_SEED,
-    P_MATH_MODE,
-    P_INTERACTION,
-    P_INI_VERSION,
-    P_MEM_NAME,
-    P_JOB_NAME,
-    P_FIND_FILE,
-    P_RUN_SCRIPT,
-    P_MAKE_TEXT,
-    P_SCRIPT_ERROR,
-    P_EXTENSIONS,
-    P__SENTINEL
-} mplib_parm_idx;
+    P_ERROR_LINE, P_MAX_LINE, P_RANDOM_SEED, P_MATH_MODE,
+    P_INTERACTION, P_INI_VERSION, P_MEM_NAME, P_JOB_NAME, P_FIND_FILE,
+    P_RUN_SCRIPT, P_MAKE_TEXT, P_SCRIPT_ERROR, P_EXTENSIONS,
+    P__SENTINEL } mplib_parm_idx;
 
 typedef struct {
-    /*tex parameter name */
-    const char *name;
-    /*tex parameter index */
-    mplib_parm_idx idx;
+    const char *name;           /* parameter name */
+    mplib_parm_idx idx;         /* parameter index */
 } mplib_parm_struct;
 
 static mplib_parm_struct mplib_parms[] = {
@@ -319,11 +284,10 @@ static mplib_parm_struct mplib_parms[] =
     {NULL,           P__SENTINEL    }
 };
 
-/*tex
 
-    We start by defining the needed callback routines for the library.
+/* Start by defining the needed callback routines for the library  */
 
-*/
+/* todo: make subtable in registry, beware, for all mp instances */
 
 static char *mplib_find_file(MP mp, const char *fname, const char *fmode, int ftype)
 {
@@ -336,7 +300,7 @@ static char *mplib_find_file(MP mp, cons
         lua_pushstring(L, fname);
         lua_pushstring(L, fmode);
         if (ftype >= mp_filetype_text) {
-            lua_pushinteger(L, (ftype - mp_filetype_text));
+          lua_pushnumber(L, (lua_Number)(ftype - mp_filetype_text));
         } else {
             lua_pushstring(L, mplib_filetype_names[ftype]);
         }
@@ -347,8 +311,7 @@ static char *mplib_find_file(MP mp, cons
         x = lua_tostring(L, -1);
         if (x != NULL)
             s = strdup(x);
-        /*tex pop the string */
-        lua_pop(L, 1);
+        lua_pop(L, 1);          /* pop the string */
         return s;
     } else {
         lua_pop(L, 1);
@@ -362,8 +325,7 @@ static char *mplib_find_file(MP mp, cons
 static int mplib_find_file_function(lua_State * L)
 {
     if (!(lua_isfunction(L, -1) || lua_isnil(L, -1))) {
-        /*tex An error. */
-        return 1;
+        return 1;               /* error */
     }
     lua_pushstring(L, "mplib.file_finder");
     lua_pushvalue(L, -2);
@@ -371,11 +333,6 @@ static int mplib_find_file_function(lua_
     return 0;
 }
 
-static void mplib_warning(const char *str)
-{
-    fprintf(stdout,"mplib warning: %s\n",str);
-}
-
 static void mplib_script_error(MP mp, const char *str)
 {
     lua_State *L = (lua_State *)mp_userdata(mp);
@@ -383,10 +340,9 @@ static void mplib_script_error(MP mp, co
     lua_getfield(L, LUA_REGISTRYINDEX, "mplib.script_error");
     if (lua_isfunction(L, -1)) {
         lua_pushstring(L, str);
-        /*tex We assume that the function is okay. */
-        lua_pcall(L, 1, 0, 0);
+        lua_pcall(L, 1, 0, 0); /* assume the function is ok */
     } else {
-        mplib_warning(str);
+        fprintf(stdout,"Error in script: %s\n",str);
         lua_pop(L, 1);
     }
 }
@@ -394,8 +350,7 @@ static void mplib_script_error(MP mp, co
 static int mplib_script_error_function(lua_State * L)
 {
     if (!(lua_isfunction(L, -1) || lua_isnil(L, -1))) {
-        /*tex An error. */
-        return 1;
+        return 1;               /* error */
     }
     lua_pushstring(L, "mplib.script_error");
     lua_pushvalue(L, -2);
@@ -413,14 +368,13 @@ static char *mplib_run_script(MP mp, con
         const char *x = NULL;
         lua_pushstring(L, str);
         if (lua_pcall(L, 1, 1, 0) != 0) {
-            fprintf(stdout,"mplib warning: error in script: %s\n",lua_tostring(L, -1));
+            mplib_script_error(mp, lua_tostring(L, -1));
             return NULL;
         }
         x = lua_tostring(L, -1);
         if (x != NULL)
             s = strdup(x);
-        /*tex Pop the string. */
-        lua_pop(L, 1);
+        lua_pop(L, 1);          /* pop the string */
         return s;
     } else {
         lua_pop(L, 1);
@@ -431,7 +385,7 @@ static char *mplib_run_script(MP mp, con
 static int mplib_run_script_function(lua_State * L)
 {
     if (!(lua_isfunction(L, -1) || lua_isnil(L, -1))) {
-        return 1; /* error */
+        return 1;               /* error */
     }
     lua_pushstring(L, "mplib.run_script");
     lua_pushvalue(L, -2);
@@ -456,8 +410,7 @@ static char *mplib_make_text(MP mp, cons
         x = lua_tostring(L, -1);
         if (x != NULL)
             s = strdup(x);
-        /*tex Pop the string. */
-        lua_pop(L, 1);
+        lua_pop(L, 1);          /* pop the string */
         return s;
     } else {
         lua_pop(L, 1);
@@ -468,8 +421,7 @@ static char *mplib_make_text(MP mp, cons
 static int mplib_make_text_function(lua_State * L)
 {
     if (!(lua_isfunction(L, -1) || lua_isnil(L, -1))) {
-        /*tex An error. */
-        return 1;
+        return 1;               /* error */
     }
     lua_pushstring(L, "mplib.make_text");
     lua_pushvalue(L, -2);
@@ -535,8 +487,7 @@ static int mplib_new(lua_State * L)
         int i;
         struct MP_options *options = mp_options();
         options->userdata = (void *) L;
-        /*tex Required: */
-        options->noninteractive = 1;
+        options->noninteractive = 1;    /* required ! */
         options->extensions = 0 ;
         options->find_file = mplib_find_file;
         options->run_script = mplib_run_script;
@@ -549,59 +500,56 @@ static int mplib_new(lua_State * L)
                 lua_getfield(L, 1, mplib_parms[i].name);
                 if (lua_isnil(L, -1)) {
                     lua_pop(L, 1);
-                    continue;
+                    continue;   /* skip unset */
                 }
                 switch (mplib_parms[i].idx) {
-                    case P_ERROR_LINE:
-                        options->error_line = (int)lua_tointeger(L, -1);
-                        if (options->error_line < 60)
-                            options->error_line = 60;
-                        if (options->error_line > 250)
-                            options->error_line = 250;
-                        options->half_error_line = (options->error_line/2)+10;
-                        break;
-                    case P_MAX_LINE:
-                        options->max_print_line = (int)lua_tointeger(L, -1);
-                        if (options->max_print_line < 60)
-                            options->max_print_line = 60;
-                        break;
-                    case P_RANDOM_SEED:
-                        options->random_seed = (int)lua_tointeger(L, -1);
-                        break;
-                    case P_INTERACTION:
-                        options->interaction = luaL_checkoption(L, -1, "errorstopmode", interaction_options);
-                        break;
-                    case P_MATH_MODE:
-                        options->math_mode = luaL_checkoption(L, -1, "scaled", math_options);
-                        break;
-                    case P_JOB_NAME:
-                        options->job_name = strdup(lua_tostring(L, -1));
-                        break;
-                    case P_FIND_FILE:
-                        if (mplib_find_file_function(L)) {
-                            mplib_warning("function expected for 'find_file'");
-                        }
-                        break;
-                    case P_RUN_SCRIPT:
-                        if (mplib_run_script_function(L)) {
-                            mplib_warning("function expected for 'run_script'");
-                        }
-                        break;
-                    case P_MAKE_TEXT:
-                        if (mplib_make_text_function(L)) {
-                            mplib_warning("function expected for 'make_text'");
-                        }
-                        break;
-                    case P_SCRIPT_ERROR:
-                        if (mplib_script_error_function(L)) {
-                            mplib_warning("function expected for 'script_error'");
-                        }
-                        break;
-                    case P_EXTENSIONS:
-                        options->extensions = (int)lua_tointeger(L, -1);
-                        break;
-                    default:
-                        break;
+                case P_ERROR_LINE:
+                  options->error_line = (int)lua_tointeger(L, -1);
+                    if (options->error_line<60) options->error_line =60;
+                    if (options->error_line>250) options->error_line = 250;
+                    options->half_error_line = (options->error_line/2)+10;
+                    break;
+                case P_MAX_LINE:
+                    options->max_print_line = (int)lua_tointeger(L, -1);
+                    if (options->max_print_line<60) options->max_print_line = 60;
+                    break;
+                case P_RANDOM_SEED:
+                    options->random_seed = (int)lua_tointeger(L, -1);
+                    break;
+                case P_INTERACTION:
+                    options->interaction = luaL_checkoption(L, -1, "errorstopmode", interaction_options);
+                    break;
+                case P_MATH_MODE:
+                    options->math_mode = luaL_checkoption(L, -1, "scaled", math_options);
+                    break;
+                case P_JOB_NAME:
+                    options->job_name = strdup(lua_tostring(L, -1));
+                    break;
+                case P_FIND_FILE:
+                    if (mplib_find_file_function(L)) {  /* error here */
+                        fprintf(stdout,"Invalid arguments to mp.new { find_file = ... }\n");
+                    }
+                    break;
+                case P_RUN_SCRIPT:
+                    if (mplib_run_script_function(L)) {  /* error here */
+                        fprintf(stdout,"Invalid arguments to mp.new { run_script = ... }\n");
+                    }
+                    break;
+                case P_MAKE_TEXT:
+                    if (mplib_make_text_function(L)) {  /* error here */
+                        fprintf(stdout,"Invalid arguments to mp.new { make_text = ... }\n");
+                    }
+                    break;
+                case P_SCRIPT_ERROR:
+                    if (mplib_script_error_function(L)) {  /* error here */
+                        fprintf(stdout,"Invalid arguments to mp.new { script_error = ... }\n");
+                    }
+                    break;
+                case P_EXTENSIONS:
+                    options->extensions = (int)lua_tointeger(L, -1);
+                    break;
+                default:
+                    break;
                 }
                 lua_pop(L, 1);
             }
@@ -678,7 +626,7 @@ static int mplib_wrapresults(lua_State *
         res->edges = NULL;
     }
     mplib_push_S(status);
-    lua_pushinteger(L, status);
+    lua_pushnumber(L, (lua_Number)status);
     lua_rawset(L,-3);
     return 1;
 }
@@ -768,16 +716,16 @@ static int mplib_statistics(lua_State *
     if (*mp_ptr != NULL) {
         lua_newtable(L);
         mplib_push_S(memory);
-        lua_pushinteger(L, mp_memory_usage(*mp_ptr));
+        lua_pushnumber(L, (lua_Number)mp_memory_usage(*mp_ptr));
         lua_rawset(L,-3);
         mplib_push_S(hash);
-        lua_pushinteger(L, mp_hash_usage(*mp_ptr));
+        lua_pushnumber(L, (lua_Number)mp_hash_usage(*mp_ptr));
         lua_rawset(L,-3);
         mplib_push_S(params);
-        lua_pushinteger(L, mp_param_usage(*mp_ptr));
+        lua_pushnumber(L, (lua_Number)mp_param_usage(*mp_ptr));
         lua_rawset(L,-3);
         mplib_push_S(open);
-        lua_pushinteger(L, mp_open_usage(*mp_ptr));
+        lua_pushnumber(L, (lua_Number)mp_open_usage(*mp_ptr));
         lua_rawset(L,-3);
     } else {
         lua_pushnil(L);
@@ -785,6 +733,7 @@ static int mplib_statistics(lua_State *
     return 1;
 }
 
+
 static int set_direction (lua_State * L, MP mp, mp_knot p) {
     double direction_x = 0, direction_y = 0;
     direction_x = (double)lua_tonumber(L,-1);
@@ -872,8 +821,8 @@ static int set_right_control (lua_State
     return 1;
 }
 
-#if 0
 
+#if 0
 #define ROUNDED_ZERO(v) (fabs((v))<0.00001 ? 0 : (v))
 #define PI 3.1415926535897932384626433832795028841971
 #define RADIANS(a) (mp_number_as_double(mp,(a)) / 16.0) * PI/180.0
@@ -966,7 +915,6 @@ void mp_dump_path (MP mp, mp_knot h) {
         printf("cycle");
     printf (";\n");
 }
-
 #endif
 
 static int mplib_solve_path(lua_State * L)
@@ -990,8 +938,10 @@ static int mplib_solve_path(lua_State *
     mp = *mp_ptr;
     cyclic = lua_toboolean(L,3);
     lua_pop(L,1);
-    /*tex We build up the path. */
+
+    /* build up the path */
     numpoints = lua_objlen(L,2);
+
     first = p = NULL;
     for (i=1;i<=numpoints;i++) {
         int left_set = 0, right_set = 0;
@@ -1001,6 +951,7 @@ static int mplib_solve_path(lua_State *
             errormsg = "Wrong argument types";
             goto BAD;
         }
+
         mplib_push_S(x_coord);
         lua_rawget(L,-2);
         if (!lua_isnumber(L,-1)) {
@@ -1009,6 +960,7 @@ static int mplib_solve_path(lua_State *
         }
         x_coord = (double)lua_tonumber(L,-1);
         lua_pop(L,1);
+
         mplib_push_S(y_coord);
         lua_rawget(L,-2);
         if (!lua_isnumber(L,-1)) {
@@ -1017,14 +969,11 @@ static int mplib_solve_path(lua_State *
         }
         y_coord = (double)lua_tonumber(L,-1);
         lua_pop(L,1);
+
         q = p;
         if (q!=NULL) {
-            /*tex
-
-                We have to save the right_tension because |mp_append_knot|
-                trashes it, believing that it is as yet uninitialized.
-
-            */
+            /* we have to save the right_tension because |mp_append_knot| trashes
+               it, believing that it is as yet uninitialized */
             double saved_tension = mp_number_as_double(mp, mp_knot_right_tension(mp,p));
             p = mp_append_knot(mp, p, x_coord, y_coord);
             if ( ! p ) {
@@ -1039,8 +988,10 @@ static int mplib_solve_path(lua_State *
                 goto BAD;
             }
         }
+
         if (first == NULL)
             first = p;
+
         mplib_push_S(left_curl);
         lua_rawget(L,-2);
         if (lua_isnumber(L,-1)) {
@@ -1050,9 +1001,9 @@ static int mplib_solve_path(lua_State *
             }
             left_set  = 1;
         } else {
-            /*tex A |nil| value. */
-            lua_pop(L,1);
+            lua_pop(L,1); /* a nil value */
         }
+
         mplib_push_S(left_tension);
         lua_rawget(L,-2);
         if (lua_isnumber(L,-1)) {
@@ -1067,9 +1018,9 @@ static int mplib_solve_path(lua_State *
                 left_set  = 1;
             }
         } else {
-            /*tex A |nil| value. */
-            lua_pop(L,1);
+            lua_pop(L,1); /* a nil value */
         }
+
         mplib_push_S(left_x);
         lua_rawget(L,-2);
         if (lua_isnumber(L,-1)) {
@@ -1085,6 +1036,7 @@ static int mplib_solve_path(lua_State *
         } else {
             lua_pop(L,1);
         }
+
         mplib_push_S(right_curl);
         lua_rawget(L,-2);
         if (lua_isnumber(L,-1)) {
@@ -1094,9 +1046,9 @@ static int mplib_solve_path(lua_State *
             }
             right_set  = 1;
         } else {
-            /*tex A |nil| value. */
-            lua_pop(L,1);
+            lua_pop(L,1); /* a nil value */
         }
+
         mplib_push_S(right_tension);
         lua_rawget(L,-2);
         if (lua_isnumber(L,-1)) {
@@ -1113,6 +1065,7 @@ static int mplib_solve_path(lua_State *
         } else {
             lua_pop(L,1);
         }
+
         mplib_push_S(right_x);
         lua_rawget(L,-2);
         if (lua_isnumber(L,-1)) {
@@ -1128,6 +1081,7 @@ static int mplib_solve_path(lua_State *
         } else {
             lua_pop(L,1);
         }
+
         mplib_push_S(direction_x);
         lua_rawget(L,-2);
         if (lua_isnumber(L,-1)) {
@@ -1136,12 +1090,12 @@ static int mplib_solve_path(lua_State *
                 goto BAD;
             }
         } else {
-            /*tex A |nil| value. */
-            lua_pop(L,1);
+            lua_pop(L,1); /* a nil value */
         }
-        /*tex Up the next item */
-        lua_pop(L,1);
+
+        lua_pop(L,1); /* done with this item */
     }
+
     if (cyclic) {
         mp_close_path_cycle (mp, p, first);
     } else {
@@ -1150,12 +1104,12 @@ static int mplib_solve_path(lua_State *
 #if 0
     mp_dump_path(mp,first);
 #endif
-    /*tex We're finished reading arguments. */
+    /* finished reading arguments */
     if (!mp_solve_path(mp,first)) {
         errormsg = "Failed to solve the path";
         goto BAD;
     }
-    /*tex Squeeze the new values back into the table. */
+    /* squeeze the new values back into the table */
     p = first;
     for (i=1;i<=numpoints;i++) {
         lua_rawgeti(L,-1, i);
@@ -1163,14 +1117,14 @@ static int mplib_solve_path(lua_State *
         mplib_push_S(left_y);  lua_pushnumber(L, mp_number_as_double(mp, mp_knot_left_y(mp, p)));  lua_rawset(L,-3);
         mplib_push_S(right_x); lua_pushnumber(L, mp_number_as_double(mp, mp_knot_right_x(mp, p))); lua_rawset(L,-3);
         mplib_push_S(right_y); lua_pushnumber(L, mp_number_as_double(mp, mp_knot_right_y(mp, p))); lua_rawset(L,-3);
-        /*tex This is a bit overkill \unknown */
-        mplib_push_S(left_tension);  lua_pushnil(L); lua_rawset(L,-3);
-        mplib_push_S(right_tension); lua_pushnil(L); lua_rawset(L,-3);
-        mplib_push_S(left_curl);     lua_pushnil(L); lua_rawset(L,-3);
-        mplib_push_S(right_curl);    lua_pushnil(L); lua_rawset(L,-3);
-        mplib_push_S(direction_x);   lua_pushnil(L); lua_rawset(L,-3);
-        mplib_push_S(direction_y);   lua_pushnil(L); lua_rawset(L,-3);
-        /*tex \unknown\ till here. */
+        /* is this really needed */
+            mplib_push_S(left_tension);  lua_pushnil(L); lua_rawset(L,-3);
+            mplib_push_S(right_tension); lua_pushnil(L); lua_rawset(L,-3);
+            mplib_push_S(left_curl);     lua_pushnil(L); lua_rawset(L,-3);
+            mplib_push_S(right_curl);    lua_pushnil(L); lua_rawset(L,-3);
+            mplib_push_S(direction_x);   lua_pushnil(L); lua_rawset(L,-3);
+            mplib_push_S(direction_y);   lua_pushnil(L); lua_rawset(L,-3);
+        /* till here */
         mplib_push_S(left_type);  lua_pushstring(L, knot_type_enum[mp_knot_left_type(mp, p)]);  lua_rawset(L, -3);
         mplib_push_S(right_type); lua_pushstring(L, knot_type_enum[mp_knot_right_type(mp, p)]); lua_rawset(L, -3);
         lua_pop(L,1);
@@ -1178,7 +1132,7 @@ static int mplib_solve_path(lua_State *
     }
     lua_pushboolean(L, 1);
     return 1;
-  BAD:
+BAD:
     if (p != NULL) {
         mp_close_path (mp, p, first);
         mp_free_path (mp, p);
@@ -1188,11 +1142,7 @@ static int mplib_solve_path(lua_State *
     return 2;
 }
 
-/*tex
-
-    The next methods are for collecting the results from |fig|.
-
-*/
+/* figure methods */
 
 static int mplib_fig_collect(lua_State * L)
 {
@@ -1221,8 +1171,7 @@ static int mplib_fig_body(lua_State * L)
         i++;
         p = p->next;
     }
-    /*tex Prevent a double free: */
-    (*hh)->body = NULL;
+    (*hh)->body = NULL;         /* prevent double free */
     return 1;
 }
 
@@ -1284,6 +1233,7 @@ static int mplib_fig_svg(lua_State * L)
     return 1;
 }
 
+
 static int mplib_fig_png(lua_State * L)
 {
     mp_run_data *res;
@@ -1366,6 +1316,8 @@ static int mplib_fig_charcode(lua_State
     return 1;
 }
 
+
+
 static int mplib_fig_bb(lua_State * L)
 {
     struct mp_edge_object **hh = is_fig(L, 1);
@@ -1381,11 +1333,7 @@ static int mplib_fig_bb(lua_State * L)
     return 1;
 }
 
-/*tex
-
-    The methods for the figure objects plus a few helpers.
-
-*/
+/* object methods */
 
 static int mplib_gr_collect(lua_State * L)
 {
@@ -1465,6 +1413,7 @@ static double coord_range_y (mp_gr_knot
     return (zhi - zlo <= dz ? aspect_bound : aspect_default);
 }
 
+
 static int mplib_gr_peninfo(lua_State * L) {
     double x_coord, y_coord, left_x, left_y, right_x, right_y;
     double wx, wy;
@@ -1532,13 +1481,6 @@ static int mplib_gr_peninfo(lua_State *
     return 1;
 }
 
-/*tex
-
-    Here is a helper that reports the valid field names of the possible
-    objects.
-
-*/
-
 static int mplib_gr_fields(lua_State * L)
 {
     const char **fields;
@@ -1584,6 +1526,7 @@ static int mplib_gr_fields(lua_State * L
     return 1;
 }
 
+
 #define mplib_push_number(L,x) lua_pushnumber(L,(lua_Number)(x))
 
 #define MPLIB_PATH 0
@@ -1591,7 +1534,7 @@ static int mplib_gr_fields(lua_State * L
 
 static void mplib_push_path(lua_State * L, mp_gr_knot h, int is_pen)
 {
-    mp_gr_knot p;
+    mp_gr_knot p;          /* for scanning the path */
     int i = 1;
     p = h;
     if (p != NULL) {
@@ -1640,63 +1583,16 @@ static void mplib_push_path(lua_State *
     }
 }
 
-static int mplib_get_path(lua_State * L)
-{
-    MP *mp = is_mp(L, 1);
-    if (*mp != NULL) {
-        size_t l;
-        const char *s = lua_tolstring(L, 2, &l);
-        if (s != NULL) {
-            mp_knot p = mp_get_path_value(*mp,s,l) ;
-            if (p != NULL) {
-                int i = 1;
-                mp_knot h = p;
-                lua_newtable(L);
-                do {
-                    lua_createtable(L, 6, 1);
-                    mplib_push_number(L, mp_number_as_double(*mp,p->x_coord));
-                    lua_rawseti(L,-2,1);
-                    mplib_push_number(L, mp_number_as_double(*mp,p->y_coord));
-                    lua_rawseti(L,-2,2);
-                    mplib_push_number(L, mp_number_as_double(*mp,p->left_x));
-                    lua_rawseti(L,-2,3);
-                    mplib_push_number(L, mp_number_as_double(*mp,p->left_y));
-                    lua_rawseti(L,-2,4);
-                    mplib_push_number(L, mp_number_as_double(*mp,p->right_x));
-                    lua_rawseti(L,-2,5);
-                    mplib_push_number(L, mp_number_as_double(*mp,p->right_y));
-                    lua_rawseti(L,-2,6);
-                    lua_rawseti(L,-2, i);
-                    i++;
-                    if (p->data.types.right_type == mp_endpoint) {
-                        mplib_push_S(cycle);
-                        lua_pushboolean(L,0);
-                        lua_rawset(L,-3);
-                        return 1;
-                    }
-                    p = p->next;
-                } while (p != h);
-                mplib_push_S(cycle);
-                lua_pushboolean(L,1);
-                lua_rawset(L,-3);
-                return 1;
-            }
-        }
-    }
-    return 0;
-}
-
-/*tex
-
-    This assumes that the top of the stack is a table or nil already in the case.
+/* this assumes that the top of the stack is a table
+   or nil already in the case
 */
 
 static void mplib_push_pentype(lua_State * L, mp_gr_knot h)
 {
-    mp_gr_knot p;
+    mp_gr_knot p;          /* for scanning the path */
     p = h;
     if (p == NULL) {
-        /*tex Do nothing. */
+        /* do nothing */
     } else if (p == p->next) {
         mplib_push_S(type);
         mplib_push_S(elliptical);
@@ -1747,11 +1643,7 @@ static void mplib_push_color(lua_State *
     }
 }
 
-/*tex
-
-    The dash scale is not exported, the field has no external value.
-
-*/
+/* the dash scale is not exported, the field has no external value */
 
 static void mplib_push_dash(lua_State * L, struct mp_stroked_object *h)
 {
@@ -1919,6 +1811,7 @@ static int mplib_gr_index(lua_State * L)
     struct mp_graphic_object **hh = is_gr_object(L, 1);
     if (*hh) {
         struct mp_graphic_object *h = *hh;
+
         if (mplib_is_S(type, 2)) {
             lua_rawgeti(L, LUA_REGISTRYINDEX, mplib_type_Ses[h->type]);
         } else {
@@ -1954,77 +1847,61 @@ static int mplib_gr_index(lua_State * L)
 }
 
 static const struct luaL_reg mplib_meta[] = {
-    { "__gc",       mplib_collect },
-    { "__tostring", mplib_tostring },
-    /*tex sentinel */
-    { NULL,         NULL}
+    {"__gc", mplib_collect},
+    {"__tostring", mplib_tostring},
+    {NULL, NULL} /* sentinel */
 };
 
 static const struct luaL_reg mplib_fig_meta[] = {
-    { "__gc",         mplib_fig_collect },
-    { "__tostring",   mplib_fig_tostring },
-    { "objects",      mplib_fig_body },
-    { "copy_objects", mplib_fig_copy_body },
-    { "filename",     mplib_fig_filename },
-    { "postscript",   mplib_fig_postscript },
-    { "png",          mplib_fig_png },
-    { "svg",          mplib_fig_svg },
-    { "boundingbox",  mplib_fig_bb },
-    { "width",        mplib_fig_width },
-    { "height",       mplib_fig_height },
-    { "depth",        mplib_fig_depth },
-    { "italcorr",     mplib_fig_italcorr },
-    { "charcode",     mplib_fig_charcode },
-    /*tex sentinel */
-    { NULL,           NULL}
+    {"__gc",         mplib_fig_collect},
+    {"__tostring",   mplib_fig_tostring},
+    {"objects",      mplib_fig_body},
+    {"copy_objects", mplib_fig_copy_body},
+    {"filename",     mplib_fig_filename},
+    {"postscript",   mplib_fig_postscript},
+    {"png",          mplib_fig_png},
+    {"svg",          mplib_fig_svg},
+    {"boundingbox",  mplib_fig_bb},
+    {"width",        mplib_fig_width},
+    {"height",       mplib_fig_height},
+    {"depth",        mplib_fig_depth},
+    {"italcorr",     mplib_fig_italcorr},
+    {"charcode",     mplib_fig_charcode},
+    {NULL, NULL}                /* sentinel */
 };
 
 static const struct luaL_reg mplib_gr_meta[] = {
-    { "__gc",       mplib_gr_collect},
-    { "__tostring", mplib_gr_tostring},
-    { "__index",    mplib_gr_index},
-    /*tex sentinel */
-    { NULL,         NULL}
+    {"__gc", mplib_gr_collect},
+    {"__tostring", mplib_gr_tostring},
+    {"__index", mplib_gr_index},
+    {NULL, NULL} /* sentinel */
 };
 
 static const struct luaL_reg mplib_d[] = {
-    { "execute",     mplib_execute },
-    { "finish",      mplib_finish },
-    { "char_width",  mplib_charwidth },
-    { "char_height", mplib_charheight },
-    { "char_depth",  mplib_chardepth },
-    { "statistics",  mplib_statistics },
-    { "solve_path",  mplib_solve_path },
-    { "get_numeric", mplib_get_numeric },
-    { "get_number",  mplib_get_numeric },
-    { "get_boolean", mplib_get_boolean },
-    { "get_string",  mplib_get_string },
-    { "get_path",    mplib_get_path },
-    /*tex sentinel */
-    {NULL,           NULL }
+    {"execute", mplib_execute},
+    {"finish", mplib_finish},
+    {"char_width", mplib_charwidth},
+    {"char_height", mplib_charheight},
+    {"char_depth", mplib_chardepth},
+    {"statistics", mplib_statistics},
+    {"solve_path", mplib_solve_path},
+    {"get_numeric", mplib_get_numeric},
+    {"get_number", mplib_get_numeric},
+    {"get_boolean", mplib_get_boolean},
+    {"get_string", mplib_get_string},
+    {NULL, NULL} /* sentinel */
 };
 
 static const struct luaL_reg mplib_m[] = {
-    { "new",         mplib_new },
-    { "version",     mplib_version },
-    { "fields",      mplib_gr_fields },
-    /* indirect */
-    { "execute",     mplib_execute },
-    { "finish",      mplib_finish },
-    { "char_width",  mplib_charwidth },
-    { "char_height", mplib_charheight },
-    { "char_depth",  mplib_chardepth },
-    { "statistics",  mplib_statistics },
-    { "solve_path",  mplib_solve_path },
-    /* helpers */
-    { "pen_info",    mplib_gr_peninfo },
-    { "get_numeric", mplib_get_numeric },
-    { "get_number",  mplib_get_numeric },
-    { "get_boolean", mplib_get_boolean },
-    { "get_string",  mplib_get_string },
-    { "get_path",    mplib_get_path },
-    /*tex sentinel */
-    { NULL,          NULL}
+    {"new", mplib_new},
+    {"version",    mplib_version},
+    {"fields", mplib_gr_fields},
+    {"pen_info", mplib_gr_peninfo},
+    {"get_numeric", mplib_get_numeric},
+    {"get_number", mplib_get_numeric},
+    {"get_boolean", mplib_get_boolean},
+    {"get_string", mplib_get_string},
+    {NULL, NULL} /* sentinel */
 };
 
 int luaopen_mplib(lua_State * L)
@@ -2032,23 +1909,22 @@ int luaopen_mplib(lua_State * L)
     mplib_init_Ses(L);
 
     luaL_newmetatable(L, MPLIB_GR_METATABLE);
-    lua_pushvalue(L, -1);
-    lua_setfield(L, -2, "__index");
-    luaL_register(L, NULL, mplib_gr_meta);
+    lua_pushvalue(L, -1);                       /* push metatable */
+    lua_setfield(L, -2, "__index");             /* metatable.__index = metatable */
+    luaL_register(L, NULL, mplib_gr_meta);      /* object meta methods */
     lua_pop(L, 1);
 
     luaL_newmetatable(L, MPLIB_FIG_METATABLE);
-    lua_pushvalue(L, -1);
-    lua_setfield(L, -2, "__index");
-    luaL_register(L, NULL, mplib_fig_meta);
+    lua_pushvalue(L, -1);                       /* push metatable */
+    lua_setfield(L, -2, "__index");             /* metatable.__index = metatable */
+    luaL_register(L, NULL, mplib_fig_meta);     /* figure meta methods */
     lua_pop(L, 1);
 
     luaL_newmetatable(L, MPLIB_METATABLE);
-    lua_pushvalue(L, -1);
-    lua_setfield(L, -2, "__index");
-    luaL_register(L, NULL, mplib_meta);
-    luaL_register(L, NULL, mplib_d);
-    luaL_register(L, "mplib", mplib_m);
-
+    lua_pushvalue(L, -1);                       /* push metatable */
+    lua_setfield(L, -2, "__index");             /* metatable.__index = metatable */
+    luaL_register(L, NULL, mplib_meta);         /* meta methods */
+    luaL_register(L, NULL, mplib_d);            /* dict methods */
+    luaL_register(L, "mplib", mplib_m);         /* module functions */
     return 1;
 }
--- texlive-bin.orig/texk/web2c/mplibdir/mp.w
+++ texlive-bin/texk/web2c/mplibdir/mp.w
@@ -139,7 +139,7 @@ typedef struct MP_instance {
 
 @ @c
 /*\#define DEBUGENVELOPE */
-#ifdef DEBUGENVELOPE
+#ifdef DEBUGENVELOPE 
 static int DEBUGENVELOPECOUNTER=0;
 #define dbg_str(A)	  printf("\n--[==[%03d DEBUGENVELOPE ]==] %s",		   DEBUGENVELOPECOUNTER++, #A)
 #define dbg_n(A) 	  printf("\n--[==[%03d DEBUGENVELOPE ]==] ['%s']=%s, ",	   DEBUGENVELOPECOUNTER++, #A, number_tostring(A))
@@ -176,8 +176,8 @@ static int DEBUGENVELOPECOUNTER=0;
 #include <png.h>                /* for |PNG_LIBPNG_VER_STRING|, |png_libpng_ver| */
 /*\#include <pixman.h>*/             /* for |PIXMAN_VERSION_STRING|, |pixman_version_string()| */
 /*\#include <cairo.h>*/              /* for |CAIRO_VERSION_STRING|, |cairo_version_string()| */
-/*\#include <gmp.h>*/                /* for |gmp_version| */
-/*\#include <mpfr.h>*/               /* for |MPFR_VERSION_STRING|, |mpfr_get_version()| */
+#include <gmp.h>                /* for |gmp_version| */
+#include <mpfr.h>               /* for |MPFR_VERSION_STRING|, |mpfr_get_version()| */
 #include "mplib.h"
 #include "mplibps.h"            /* external header */
 /*\#include "mplibsvg.h" */          /* external header */
@@ -189,7 +189,7 @@ static int DEBUGENVELOPECOUNTER=0;
 #include "mpmath.h"             /* internal header */
 #include "mpmathdouble.h"       /* internal header */
 #include "mpmathdecimal.h"      /* internal header */
-/*#include "mpmathbinary.h"*/       /* internal header */
+#include "mpmathbinary.h"       /* internal header */
 #include "mpstrings.h"          /* internal header */
 /* BEGIN PATCH */
 mp_number dx_ap;    /* approximation of dx */
@@ -200,19 +200,12 @@ mp_number ueps_ap;  /* epsilon for above
 boolean is_dxdy, is_dxindyin;
 /* END PATCH */
 
-@ We move the {\tt cairo} and {\tt pixman} libraries outside {\tt mp.w},
+@ We move the {\tt cairo} and {\tt pixman} libraries outside {\tt mp.w}, 
 to minimize dependencies.
 
 @c
 extern const char *COMPILED_CAIRO_VERSION_STRING;
 extern const char* cairo_version_string (void);
-extern const char *COMPILED_MPFR_VERSION_STRING;
-extern const char* mpfr_get_version (void);
-extern void * mp_initialize_binary_math (MP mp) ;
-extern int COMPILED__GNU_MP_VERSION;
-extern int COMPILED__GNU_MP_VERSION_MINOR;
-extern int COMPILED__GNU_MP_VERSION_PATCHLEVEL;
-extern const char * const COMPILED_gmp_version;
 extern const char *COMPILED_PIXMAN_VERSION_STRING;
 extern const char* pixman_version_string (void);
 extern void mp_png_backend_initialize (MP mp);
@@ -2635,7 +2628,7 @@ void mp_new_randoms (MP mp) {
   mp->j_random = 54;
 }
 
-@ To consume a random fraction, the program below will say `|next_random|'.
+@ To consume a random fraction, the program below will say `|next_random|'. 
 Now each number system has its own implementation,
 true to the original as much as possibile.
 
@@ -2664,7 +2657,7 @@ As said before, now each number system h
 @c
 /*Unused.
 static void mp\_unif\_rand (MP mp, mp\_number *ret, mp\_number x\_orig) {
-  mp\_number y;     // trial value
+  mp\_number y;     // trial value 
   mp\_number x, abs\_x;
   mp\_number u;
   new\_fraction (y);
@@ -2903,7 +2896,7 @@ void *do_alloc_node (MP mp, size_t size)
 
 @c
 void mp_xfree (void *x) {
-  if (x != NULL)
+  if (x != NULL) 
     free (x);
 }
 void *mp_xrealloc (MP mp, void *p, size_t nmem, size_t size) {
@@ -3242,7 +3235,8 @@ mp_random_seed, /* initialize random num
 mp_message_command, /* communicate to user (\&{message}, \&{errmessage}) */
 mp_every_job_command, /* designate a starting token (\&{everyjob}) */
 mp_delimiters, /* define a pair of delimiters (\&{delimiters}) */
-mp_special_command, /* output special info (\&{special}) or font map info (\&{fontmapfile}, \&{fontmapline}) */
+mp_special_command, /* output special info (\&{special})
+                       or font map info (\&{fontmapfile}, \&{fontmapline}) */
 mp_write_command, /* write text to a file (\&{write}) */
 mp_type_name, /* declare a type (\&{numeric}, \&{pair}, etc.) */
 mp_left_delimiter, /* the left delimiter of a matching pair */
@@ -3281,13 +3275,15 @@ mp_left_bracket, /* the operator `\.[' *
 mp_right_bracket, /* the operator `\.]' */
 mp_right_brace, /* the operator `\.{\char`\}}' */
 mp_with_option, /* option for filling (\&{withpen}, \&{withweight}, etc.) */
-mp_thing_to_add, /* variant of \&{addto} (\&{contour}, \&{doublepath}, \&{also}) */
+mp_thing_to_add,
+  /* variant of \&{addto} (\&{contour}, \&{doublepath}, \&{also}) */
 mp_of_token, /* the operator `\&{of}' */
 mp_to_token, /* the operator `\&{to}' */
 mp_step_token, /* the operator `\&{step}' */
 mp_until_token, /* the operator `\&{until}' */
 mp_within_token, /* the operator `\&{within}' */
-mp_lig_kern_token, /* the operators `\&{kern}' and `\.{=:}' and `\.{=:\char'174}', etc. */
+mp_lig_kern_token,
+  /* the operators `\&{kern}' and `\.{=:}' and `\.{=:\char'174}', etc. */
 mp_assignment, /* the operator `\.{:=}' */
 mp_skip_to, /* the operation `\&{skipto}' */
 mp_bchar_label, /* the operator `\.{\char'174\char'174:}' */
@@ -4050,7 +4046,6 @@ enum mp_given_internal {
   mp_pausing,                   /* positive to display lines on the terminal before they are read */
   mp_showstopping,              /* positive to stop after each \&{show} command */
   mp_fontmaking,                /* positive if font metric output is to be produced */
-  mp_texscriptmode,             /* controls spacing in texmode */
   mp_linejoin,                  /* as in \ps: 0 for mitered, 1 for round, 2 for beveled */
   mp_linecap,                   /* as in \ps: 0 for butt, 1 for round, 2 for square */
   mp_miterlimit,                /* controls miter length as in \ps */
@@ -4201,8 +4196,6 @@ mp_primitive (mp, "showstopping", mp_int
 @:mp_showstopping_}{\&{showstopping} primitive@>;
 mp_primitive (mp, "fontmaking", mp_internal_quantity, mp_fontmaking);
 @:mp_fontmaking_}{\&{fontmaking} primitive@>;
-mp_primitive (mp, "texscriptmode", mp_internal_quantity, mp_texscriptmode);
-@:mp_texscriptmode_}{\&{texscriptmode} primitive@>;
 mp_primitive (mp, "linejoin", mp_internal_quantity, mp_linejoin);
 @:mp_linejoin_}{\&{linejoin} primitive@>;
 mp_primitive (mp, "linecap", mp_internal_quantity, mp_linecap);
@@ -4221,7 +4214,8 @@ mp_primitive (mp, "mpprocset", mp_intern
 @:mp_procset_}{\&{mpprocset} primitive@>;
 mp_primitive (mp, "troffmode", mp_internal_quantity, mp_gtroffmode);
 @:troffmode_}{\&{troffmode} primitive@>;
-mp_primitive (mp, "defaultcolormodel", mp_internal_quantity, mp_default_color_model);
+mp_primitive (mp, "defaultcolormodel", mp_internal_quantity,
+              mp_default_color_model);
 @:mp_default_color_model_}{\&{defaultcolormodel} primitive@>;
 mp_primitive (mp, "restoreclipcolor", mp_internal_quantity, mp_restore_clip_color);
 @:mp_restore_clip_color_}{\&{restoreclipcolor} primitive@>;
@@ -4279,7 +4273,6 @@ set_internal_string (mp_output_format, m
 set_internal_string (mp_output_format_options, mp_intern (mp, ""));
 set_internal_string (mp_number_system, mp_intern (mp, "scaled"));
 set_internal_from_number (mp_number_precision, precision_default);
-set_internal_from_number (mp_texscriptmode, unity_t);
 #if DEBUG
 number_clone (internal_value (mp_tracing_titles), three_t);
 number_clone (internal_value (mp_tracing_equations), three_t);
@@ -4327,7 +4320,6 @@ set_internal_name (mp_design_size, xstrd
 set_internal_name (mp_pausing, xstrdup ("pausing"));
 set_internal_name (mp_showstopping, xstrdup ("showstopping"));
 set_internal_name (mp_fontmaking, xstrdup ("fontmaking"));
-set_internal_name (mp_texscriptmode, xstrdup ("texscriptmode"));
 set_internal_name (mp_linejoin, xstrdup ("linejoin"));
 set_internal_name (mp_linecap, xstrdup ("linecap"));
 set_internal_name (mp_miterlimit, xstrdup ("miterlimit"));
@@ -4451,8 +4443,6 @@ class numbers in nonstandard extensions
 @d invalid_class 20 /* bad character in the input */
 @d max_class 20 /* the largest class number */
 
-@d semicolon_class 6 /* the ; */
-
 @<Glob...@>=
 #define digit_class 0 /* the class number of \.{0123456789} */
 int char_class[256];    /* the class numbers */
@@ -4853,26 +4843,10 @@ char *mp_get_string_value (MP mp, const
    return NULL;
 }
 
-mp_knot mp_get_path_value (MP mp, const char *s, size_t l) {
-    char *ss = mp_xstrdup(mp,s);
-    if (ss) {
-        mp_sym sym = mp_id_lookup(mp,ss,l,false);
-        if (sym != NULL) {
-            if (mp_type(sym->v.data.node) == mp_path_type) {
-                mp_xfree (ss);
-                return (mp_knot) sym->v.data.node->data.p;
-            }
-        }
-    }
-    mp_xfree (ss);
-    return NULL;
-}
-
 @ @<Exported function headers@>=
 double mp_get_numeric_value(MP mp,const char *s,size_t l);
 int mp_get_boolean_value(MP mp,const char *s,size_t l);
 char *mp_get_string_value(MP mp,const char *s,size_t l);
-mp_knot mp_get_path_value(MP mp,const char *s,size_t l);
 
 @ We need to put \MP's ``primitive'' symbolic tokens into the hash
 table, together with their command code (which will be the |eq_type|)
@@ -13296,26 +13270,26 @@ static mp_knot mp_offset_prep (MP mp, mp
   c0 = c;
   k_needed = 0;
 #ifdef DEBUGENVELOPE
-dbg_nl;dbg_str(--[==[BEGIN]==]);dbg_nl;
-dbg_str(return {);dbg_nl;
+dbg_nl;dbg_str(--[==[BEGIN]==]);dbg_nl; 
+dbg_str(return {);dbg_nl; 
 dbg_n(w0->x_coord);
 dbg_n(w0->y_coord);
 #endif
  do {
     q = mp_next_knot (p);
 #ifdef DEBUGENVELOPE
-dbg_nl;dbg_open_t;dbg_str(--[==[begin loop]==]);dbg_nl;
+dbg_nl;dbg_open_t;dbg_str(--[==[begin loop]==]);dbg_nl; 
 dbg_n(p->x_coord);dbg_n(p->y_coord);
 dbg_n(p->right_x);dbg_n(p->right_y);
 dbg_n(q->left_x);dbg_n(q->left_y);
 dbg_n(q->x_coord);dbg_n(q->y_coord);
 dbg_n(w0->x_coord);
 dbg_n(w0->y_coord);
-#endif
+#endif 
     @<Split the cubic between |p| and |q|, if necessary, into cubics
       associated with single offsets, after which |q| should
       point to the end of the final such cubic@>;
-#ifdef DEBUGENVELOPE
+#ifdef DEBUGENVELOPE   
 dbg_key(end Split the cubic between |p| and |q|);dbg_open_t;dbg_nl;
 dbg_n(w->x_coord);dbg_n(w->y_coord);
 dbg_n(w0->x_coord);dbg_n(w0->y_coord);
@@ -13327,7 +13301,7 @@ dbg_close_t; dbg_comma;dbg_nl;
 #ifdef DEBUGENVELOPE
 dbg_n(w0->x_coord);dbg_n(w0->y_coord);
 dbg_str(--[==[end loop]==]);dbg_nl; dbg_close_t;dbg_comma;dbg_nl;
-#endif
+#endif 
   } while (q != c);
 #ifdef DEBUGENVELOPE
  dbg_key(Fix the offset change);dbg_open_t;dbg_nl;
@@ -13338,7 +13312,7 @@ dbg_str(--[==[end loop]==]);dbg_nl; dbg_
 #endif
   @<Fix the offset change in |mp_knot_info(c)| and set |c| to the return value of
     |offset_prep|@>;
-#ifdef DEBUGENVELOPE
+#ifdef DEBUGENVELOPE  
 dbg_n(p->x_coord);dbg_n(p->y_coord);
 dbg_key_ival(info post,mp_knot_info(p));dbg_comma;dbg_nl;
 dbg_n(c->x_coord);dbg_n(c->y_coord);
@@ -13438,7 +13412,7 @@ the testcase reported by Bogus\l{}aw Jac
 on Sarovar.)
 
 @<Advance |p| to node |q|, removing any ``dead'' cubics...@>=
-#ifdef DEBUGENVELOPE
+#ifdef DEBUGENVELOPE 
 dbg_comment(Advance |p| to node |q|);dbg_nl;
 #endif
 q0 = q;
@@ -13463,11 +13437,11 @@ if ((q != q0) && (q != c || c == c0))
 
 @ @<Remove the cubic following |p| and update the data structures...@>=
 {
- #ifdef DEBUGENVELOPE
+ #ifdef DEBUGENVELOPE 
  dbg_key(Remove the cubic following p);dbg_open_t;dbg_nl;
  dbg_n(p->x_coord);dbg_n(p->y_coord);
  dbg_key_ival(pre info p,mp_knot_info(p));  dbg_close_t;dbg_comma;dbg_nl;
- #endif
+ #endif 
   k_needed = mp_knot_info (p) - zero_off;
   if (r == q) {
     q = p;
@@ -13485,11 +13459,11 @@ if ((q != q0) && (q != c || c == c0))
     mp->spec_p2 = p;
   r = p;
   mp_remove_cubic (mp, p);
-  #ifdef DEBUGENVELOPE
+  #ifdef DEBUGENVELOPE 
   dbg_key(Remove the cubic following p);dbg_open_t;dbg_nl;
   dbg_n(p->x_coord);dbg_n(p->y_coord);
   dbg_key_ival(post info p,mp_knot_info (p)); dbg_close_t;dbg_comma;dbg_nl;
-  #endif
+  #endif 
 }
 
 
@@ -13558,16 +13532,16 @@ We may have to split a cubic into many p
 piece corresponds to a unique offset.
 
 @<Split the cubic between |p| and |q|, if necessary, into cubics...@>=
-#ifdef DEBUGENVELOPE
+#ifdef DEBUGENVELOPE 
 dbg_comment(Split the cubic between |p| and |q|);dbg_nl;
 dbg_key(Split the cubic);dbg_open_t;dbg_nl;
 dbg_key_ival(pre info p,mp_knot_info(p));dbg_comma;
 dbg_n(w0->x_coord);dbg_n(w0->y_coord);
-#endif
+#endif 
 mp_knot_info (p) = zero_off + k_needed;
-#ifdef DEBUGENVELOPE
+#ifdef DEBUGENVELOPE 
 dbg_key_ival(post info p,mp_knot_info(p));dbg_close_t;dbg_comma; dbg_nl;
-#endif
+#endif 
 k_needed = 0;
 @<Prepare for derivative computations;
   |goto not_found| if the current cubic is dead@>;
@@ -13734,7 +13708,7 @@ void mp_fin_offset_prep (MP mp, mp_knot
   new_number(t2);
   new_fraction(s);
   new_fraction(t);
-#ifdef DEBUGENVELOPE
+#ifdef DEBUGENVELOPE 
 dbg_key(mp_fin_offset_prep);dbg_open_t;dbg_nl;
 #endif
   while (1) {
@@ -13742,7 +13716,7 @@ dbg_key(mp_fin_offset_prep);dbg_open_t;d
       ww = mp_next_knot (w);    /* a pointer to $w\k$ */
     else
       ww = mp_prev_knot (w);    /* a pointer to $w_{k-1}$ */
-#ifdef DEBUGENVELOPE
+#ifdef DEBUGENVELOPE 
 dbg_comment(begin iteration);
 dbg_open_t;dbg_nl;
 dbg_n(w->x_coord);dbg_n(w->y_coord);
@@ -13753,11 +13727,11 @@ dbg_in(rise);
 #endif
     @<Compute test coefficients |(t0,t1,t2)|
       for $d(t)$ versus $d_k$ or $d_{k-1}$@>;
-#ifdef DEBUGENVELOPE
+#ifdef DEBUGENVELOPE 
 dbg_comment(crossing_point);
 #endif
     crossing_point (t, t0, t1, t2);
-#ifdef DEBUGENVELOPE
+#ifdef DEBUGENVELOPE 
 dbg_n(t);dbg_n(t0);dbg_n(t1);dbg_n(t2);
 dbg_in(number_greaterequal(t, fraction_one_t));
 dbg_in(turn_amt);
@@ -13769,18 +13743,18 @@ dbg_close_t; dbg_comma;dbg_nl;
       else
         goto RETURN;
     }
-#ifdef DEBUGENVELOPE
+#ifdef DEBUGENVELOPE 
 dbg_comment(Split the cubic at $t$ and split off another cubic if the derivative crosses back);
 #endif
     @<Split the cubic at $t$,
       and split off another cubic if the derivative crosses back@>;
     w = ww;
-#ifdef DEBUGENVELOPE
+#ifdef DEBUGENVELOPE 
 dbg_comment(end iteration);
 #endif
   }
 RETURN:
-#ifdef DEBUGENVELOPE
+#ifdef DEBUGENVELOPE 
 dbg_comment(RETURN);
 dbg_n(t);
 #endif
@@ -13792,7 +13766,7 @@ dbg_n(t);
   free_number (t0);
   free_number (t1);
   free_number (t2);
-#ifdef DEBUGENVELOPE
+#ifdef DEBUGENVELOPE 
 dbg_close_t; dbg_comma;dbg_nl;
 #endif
 }
@@ -13808,7 +13782,7 @@ begins to fail.
   mp_number abs_du, abs_dv;
   new_number (abs_du);
   new_number (abs_dv);
-#ifdef DEBUGENVELOPE
+#ifdef DEBUGENVELOPE 
 dbg_key(Compute test coefficients |(t0,t1,t2)| for $d(t)$ versus...);dbg_open_t;dbg_nl;
 #endif
   set_number_from_substraction(du, ww->x_coord, w->x_coord);
@@ -13817,7 +13791,7 @@ dbg_key(Compute test coefficients |(t0,t
   number_abs(abs_du);
   number_clone(abs_dv, dv);
   number_abs(abs_dv);
-#ifdef DEBUGENVELOPE
+#ifdef DEBUGENVELOPE 
 dbg_CUBIC;
 dbg_n(w->x_coord);dbg_n(w->y_coord);
 dbg_n(ww->x_coord);dbg_n(ww->y_coord);
@@ -13864,7 +13838,7 @@ dbg_in(number_greaterequal(abs_du, abs_d
   free_number (abs_dv);
   if (number_negative(t0))
     set_number_to_zero(t0); /* should be positive without rounding error */
-#ifdef DEBUGENVELOPE
+#ifdef DEBUGENVELOPE 
 dbg_n(t0);dbg_n(t1);dbg_n(t2);
 dbg_close_t; dbg_comma;dbg_nl;
 #endif
@@ -14007,19 +13981,19 @@ if (number_zero(dxin) && number_zero(dyi
 #ifdef DEBUGENVELOPE
 dbg_key(dxin dyin before);dbg_open_t;dbg_nl;
 dbg_n(dxin);dbg_n(dyin);
-dbg_close_t;dbg_comma;
+dbg_close_t;dbg_comma; 
 #endif
 #ifdef DEBUGENVELOPE
 dbg_key(dxin dyin after);dbg_open_t;dbg_nl;
 dbg_n(dxin);dbg_n(dyin);
-dbg_close_t;dbg_comma;
+dbg_close_t;dbg_comma; 
 #endif
 /* BEGIN PATCH */
 #ifdef DEBUGENVELOPE
 dbg_key(dx dy dxin dyin after patch);dbg_open_t;dbg_nl;
 dbg_n(dx);dbg_n(dy);dbg_n(dx_ap);dbg_n(dy_ap);
 dbg_n(dxin);dbg_n(dyin);dbg_n(dxin_ap);dbg_n(dyin_ap);
-dbg_close_t;dbg_comma;
+dbg_close_t;dbg_comma; 
 #endif
 /* END PATCH ****/
 
@@ -14038,13 +14012,13 @@ right.) This code depends on |w0| being
 #ifdef DEBUGENVELOPE
 dbg_nl;
 dbg_comment(Update |mp_knot_info(p)|);dbg_nl;
-dbg_key(mp_get_turn_amt_dx_dy);dbg_open_t;dbg_str(--[==[call mp_get_turn_amt]==]);dbg_nl;
+dbg_key(mp_get_turn_amt_dx_dy);dbg_open_t;dbg_str(--[==[call mp_get_turn_amt]==]);dbg_nl; 
 dbg_n(w0->x_coord);dbg_n(w0->y_coord);dbg_n(dx);dbg_n(dy);dbg_in(number_nonnegative(ab_vs_cd));
 dbg_n(ab_vs_cd);
 #endif
  is_dxdy=true;
  turn_amt = mp_get_turn_amt (mp, w0, dx, dy, number_nonnegative(ab_vs_cd));
- is_dxdy=false;
+ is_dxdy=false; 
 #ifdef DEBUGENVELOPE
 dbg_dn(turn_amt);
 dbg_close_t;dbg_comma;
@@ -14104,20 +14078,20 @@ integer mp_get_turn_amt (MP mp, mp_knot
       ab_vs_cd (t, dy, arg1, dx, arg2);
 #ifdef DEBUGENVELOPE
      dbg_sp;
-     dbg_open_t;dbg_str(--[==[inside mp_get_turn_amt do loop ]==]);dbg_nl;
+     dbg_open_t;dbg_str(--[==[inside mp_get_turn_amt do loop ]==]);dbg_nl; 
      dbg_n(w->x_coord);dbg_n(w->y_coord);dbg_n(ww->x_coord);dbg_n(ww->y_coord);
      dbg_n(t);dbg_n(dy);dbg_n(arg1);dbg_n(dx);dbg_n(arg2);
      dbg_n(t_ap);dbg_n(dy_ap);dbg_n(dx_ap);dbg_n(dyin_ap);dbg_n(dxin_ap);
      dbg_close_t;dbg_comma;
      dbg_in(number_zero(dx) && number_zero(arg1) && number_positive(dy) && number_positive(arg2) && is_dxdy);
-     dbg_in(is_dxdy && number_zero(dx) && number_zero(arg1) && number_negative(dy) && number_negative(arg2)  && number_positive(dyin_ap));
+     dbg_in(is_dxdy && number_zero(dx) && number_zero(arg1) && number_negative(dy) && number_negative(arg2)  && number_positive(dyin_ap)); 
      dbg_in(is_dxindyin && number_zero(dx) && number_zero(arg1) && number_positive(dy) && number_positive(arg2) && number_negative(dyin_ap));
      dbg_in(number_zero(dy) && number_zero(arg2) && number_negative(dx) && number_negative(arg1));
      dbg_in(number_zero(dx) && number_zero(arg1) && number_negative(dy) && number_positive(arg2));
      dbg_in(number_zero(dy) && number_zero(arg2) && number_positive(dx) && number_negative(arg1));
      dbg_nl;
 #endif
-      if (number_negative(t))
+      if (number_negative(t)) 
         break;
       incr (s);
       w = ww;
@@ -14130,7 +14104,7 @@ integer mp_get_turn_amt (MP mp, mp_knot
     ab_vs_cd (t, dy, arg1, dx, arg2);
 #ifdef DEBUGENVELOPE
      dbg_sp;
-     dbg_open_t;dbg_str(--[==[outside mp_get_turn_amt do loop ]==]);dbg_nl;
+     dbg_open_t;dbg_str(--[==[outside mp_get_turn_amt do loop ]==]);dbg_nl; 
      dbg_n(w->x_coord);dbg_n(w->y_coord);dbg_n(ww->x_coord);dbg_n(ww->y_coord);
      dbg_n(t);dbg_n(dy);dbg_n(arg1);dbg_n(dx);dbg_n(arg2);
      dbg_n(t_ap);dbg_n(dy_ap);dbg_n(dx_ap);dbg_n(dyin_ap);dbg_n(dxin_ap);
@@ -14146,7 +14120,7 @@ integer mp_get_turn_amt (MP mp, mp_knot
       ab_vs_cd (t, dy, arg1, dx, arg2);
 #ifdef DEBUGENVELOPE
      dbg_sp;
-     dbg_open_t;dbg_str(--[==[inside mp_get_turn_amt do loop for t<0 ]==]);dbg_nl;
+     dbg_open_t;dbg_str(--[==[inside mp_get_turn_amt do loop for t<0 ]==]);dbg_nl; 
      dbg_n(w->x_coord);dbg_n(w->y_coord);dbg_n(ww->x_coord);dbg_n(ww->y_coord);
      dbg_n(t);dbg_n(dy);dbg_n(arg1);dbg_n(dx);dbg_n(arg2);
      dbg_n(t_ap);dbg_n(dy_ap);dbg_n(dx_ap);
@@ -14199,14 +14173,14 @@ with respect to $d_{k-1}$, and apply |fi
 
 @<Complete the offset splitting process@>=
 ww = mp_prev_knot (w);
-#ifdef DEBUGENVELOPE
+#ifdef DEBUGENVELOPE 
 dbg_key(Complete the offset splitting process);dbg_open_t;dbg_nl;
 dbg_n(w->x_coord);dbg_n(w->y_coord);
 dbg_n(ww->x_coord);dbg_n(ww->y_coord);
 dbg_close_t; dbg_comma;dbg_nl;
 #endif
 @<Compute test coeff...@>;
-#ifdef DEBUGENVELOPE
+#ifdef DEBUGENVELOPE 
 dbg_key(after Compute test coeff);dbg_open_t;dbg_nl;
 dbg_n(w->x_coord);dbg_n(w->y_coord);
 dbg_n(ww->x_coord);dbg_n(ww->y_coord);
@@ -14215,7 +14189,7 @@ dbg_close_t; dbg_comma;dbg_nl;
 @<Find the first |t| where $d(t)$ crosses $d_{k-1}$ or set
   |t:=fraction_one+1|@>;
 if (number_greater(t, fraction_one_t)) {
-#ifdef DEBUGENVELOPE
+#ifdef DEBUGENVELOPE 
 dbg_key(t > fraction_one_t);dbg_open_t;dbg_nl;
 dbg_n(p->x_coord);dbg_n(p->y_coord);
 dbg_n(w->x_coord);dbg_n(w->y_coord);
@@ -14233,7 +14207,7 @@ dbg_close_t; dbg_comma;dbg_nl;
   set_number_from_of_the_way(y1a, t, y0, y1);
   set_number_from_of_the_way(y1,  t, y1, y2);
   set_number_from_of_the_way(y2a, t, y1a, y1);
-#ifdef DEBUGENVELOPE
+#ifdef DEBUGENVELOPE 
 dbg_key(t <= fraction_one_t);dbg_open_t;dbg_nl;
 dbg_n(p->x_coord);dbg_n(p->y_coord);
 dbg_n(t);
@@ -14271,7 +14245,7 @@ dbg_close_t; dbg_comma;dbg_nl;
     mp_fin_offset_prep (mp, r, ww, x0, x1, x2, y0, y1, y2, -1, (-1 - turn_amt));
   }
 }
-#ifdef DEBUGENVELOPE
+#ifdef DEBUGENVELOPE 
 dbg_key(end Complete the offset splitting process);dbg_open_t;dbg_nl;
 dbg_n(w->x_coord);dbg_n(w->y_coord);
 dbg_n(w0->x_coord);dbg_n(w0->y_coord);
@@ -14304,7 +14278,7 @@ crossing and the first crossing cannot b
 @<Find the first |t| where $d(t)$ crosses $d_{k-1}$ or set...@>=
 #ifdef DEBUGENVELOPE
 dbg_key(Find the first |t| where);dbg_open_t;dbg_nl;
-#endif
+#endif 
 crossing_point (t, t0, t1, t2);
 if (turn_amt >= 0) {
   if (number_negative(t2)) {
@@ -14342,7 +14316,7 @@ if (turn_amt >= 0) {
 #ifdef DEBUGENVELOPE
 dbg_n(t);
 dbg_close_t; dbg_comma;dbg_nl;
-#endif
+#endif 
 
 
 @ @<Other local variables for |offset_prep|@>=
@@ -19871,7 +19845,6 @@ is less than |loop_text|.
 @ @<Run a script@>=
 if (s != NULL) {
     int k ;
-    mp_value new_expr;
     size_t size = strlen(s);
     memset(&new_expr,0,sizeof(mp_value));
     new_number(new_expr.data.n);
@@ -19887,6 +19860,7 @@ if (s != NULL) {
     }
     limit = (halfword) k;
     (void) memcpy ((mp->buffer + mp->first), s, size);
+    free(s);
     mp->buffer[limit] = xord ('%');
     mp->first = (size_t) (limit + 1);
     loc = start;
@@ -19917,42 +19891,26 @@ if (s != NULL) {
     } else {
         mp_back_input (mp);
         if (cur_exp_str ()->len > 0) {
+            mp_value new_expr;
             char *s = mp->run_script(mp,(const char*) cur_exp_str()->str) ;
             @<Run a script@>
-            free(s);
         }
     }
 }
 
-@ The |texscriptmode| parameter controls how spaces and newlines get honoured in
-|btex| or |verbatimtex| ... |etex|. The default value is~1. Possible values are:
-0: no newlines, 1: newlines in |verbatimtex|, 2: newlines in |verbatimtex| and
-|etex|, 3: no leading and trailing strip in |verbatimtex|, 4: no leading and
-trailing strip in |verbatimtex| and |btex|. That way the Lua handler can do what
-it likes. An |etex| has to be followed by a space or |;| or be at the end of a
-line and preceded by a space or at the beginning of a line.
-
-@<Pass btex ... etex to script@>=
-{
-    char *txt = NULL;
-    char *ptr = NULL;
-    int slin = line;
-    int size = 0;
-    int done = 0;
-    int mode = round_unscaled(internal_value(mp_texscriptmode)) ; /* default: 1 */
-    int verb = cur_mod() == verbatim_code;
-    int first;
-    /* we had a (mandate) trailing space */
-    if (loc <= limit && mp->char_class[mp->buffer[loc]] == space_class) {
+@ @<Pass btex ... etex to script@>=
+{
+    int first ;
+    while ((loc < limit - 4) && (mp->buffer[loc] == ' ')) {
         incr(loc);
-    } else {
-        /* maybe issue an error message and quit */
     }
-    /* we loop over lines */
-    first = loc;
-    while (1) {
-        /* we don't need to check when we have less than 4 characters left */
-        if (loc < limit - 4) {
+    first = loc ;
+    if (mp->buffer[loc-1] == ' ') {
+        decr(loc);
+    }
+    while (loc < limit - 5) {
+        if (mp->buffer[loc] == ' ') {
+            incr(loc);
             if (mp->buffer[loc] == 'e') {
                 incr(loc);
                 if (mp->buffer[loc] == 't') {
@@ -19960,135 +19918,39 @@ line and preceded by a space or at the b
                     if (mp->buffer[loc] == 'e') {
                         incr(loc) ;
                         if (mp->buffer[loc] == 'x') {
-                            /* let's see if we have the right boundary */
-                            if (first == (loc - 3)) {
-                                /* when we're at the start of a line no leading space is required */
-                                done = 1;
-                            } else if (mp->char_class[mp->buffer[loc - 4]] == space_class) {
-                                /* when we're beyond the start of a line a leading space is required */
-                                done = 2;
-                            }
-                            if (done) {
-                                if ((loc + 1) <= limit) {
-                                    quarterword c = mp->char_class[mp->buffer[loc + 1]] ;
-                                    if (c != letter_class) {
-                                        incr(loc) ;
-                                        /* we're past the 'x' */
-                                        break;
-                                    } else {
-                                        /* this is no valid etex */
-                                        done = 0;
-                                    }
-                                } else {
-                                    /* when we're at the end of a line we're ok */
-                                    incr(loc) ;
-                                    /* we're past the 'x' */
-                                    break;
+                            /* start action */
+                            char *s, *txt ;
+                            int size ;
+                            mp_value new_expr;
+                            size = loc - first + 1 - 4 ;
+                            if (size < 0) {
+                                size = 0 ;
+                            } else {
+                                while ((size > 1) && (mp->buffer[first+size-1] == ' ')) {
+                                    decr(size);
                                 }
                             }
+                            txt = malloc(size+1);
+                            if (size > 0) {
+                                (void) memcpy (txt, mp->buffer + first, size);
+                            }
+                            txt[size] = '\0';
+                            incr(loc);
+                            s = mp->make_text(mp,txt,(cur_mod() == verbatim_code)) ; /* we could pass the size */
+                            @<Run a script@>
+                            /* done */
+                            free(txt);
+                            break ;
+                        } else {
+                      //      decr(loc) ;
                         }
                     }
                 }
             }
-        }
-        /* no etex seen (yet) */
-        if (loc >= limit) {
-            if (size) {
-                txt = realloc(txt, size + limit - first + 1);
-            } else {
-                txt = malloc(limit - first + 1);
-            }
-            (void) memcpy (txt + size, mp->buffer + first, limit - first);
-            size += limit - first + 1;
-            if (mode <= 0) {
-                txt[size - 1] = ' ';
-            } else if (verb) {
-                /* modes >= 1 permit a newline in verbatimtex */
-                txt[size - 1] = '\n';
-            } else if (mode >= 2) {
-                /* modes >= 2 permit a newline in btex */
-                txt[size - 1] = '\n';
-            } else {
-                txt[size - 1] = ' ';
-            }
-            if (move_to_next_line(mp)) {
-                /* we abort the scanning */
-                goto FATAL_ERROR;
-            }
-            first = loc;
         } else {
             incr(loc);
         }
     }
-    if (done) {
-        /* we're past the 'x' */
-        int l = loc - 5 ; // 4
-        int n = l - first + 1 ;
-        /* we're before the 'etex' */
-        if (done == 2) {
-            /* we had ' etex' */
-            l -= 1;
-            n -= 1;
-            /* we're before the ' etex' */
-        }
-        if (size) {
-            txt = realloc(txt, size + n + 1);
-        } else {
-            txt = malloc(n + 1);
-        }
-        (void) memcpy (txt + size, mp->buffer + first, n); /* 0 */
-        size += n;
-        if (verb && mode >= 3) {
-            /* don't strip verbatimtex */
-            txt[size] = '\0';
-            ptr = txt;
-        } else if (mode >= 4) {
-            /* don't strip btex */
-            txt[size] = '\0';
-            ptr = txt;
-        } else {
-            /* strip trailing whitespace, we have a \0 so we're one off  */
-         /* while ((size > 1) && (mp->char_class[(ASCII_code) txt[size-2]] == space_class || txt[size-2] == '\n')) { */
-            while ((size > 1) && (mp->char_class[(ASCII_code) txt[size-1]] == space_class || txt[size-1] == '\n')) {
-                decr(size);
-            }
-            /* prune the string */
-            txt[size] = '\0';
-            /* strip leading whitespace */
-            ptr = txt;
-            while ((size > 1) && (mp->char_class[(ASCII_code) ptr[0]] == space_class || ptr[0] == '\n')) {
-                incr(ptr);
-                decr(size);
-            }
-        }
-        /* action */
-        {
-            char *s = mp->make_text(mp,ptr,verb) ;
-            @<Run a script@>
-            free(s);
-        }
-        free(txt);
-        /* really needed */
-        mp_get_next(mp);
-        return;
-    }
-    /*
-        we don't recover because in practice the graphic will be broken anyway and
-        we're not really interacting in mplib .. just fix the input
-    */
-    FATAL_ERROR:
-    {
-        /* line numbers are not always meaningfull so we can get a 0 reported */
-        char msg[256];
-        const char *hlp[] = { "An 'etex' is missing at this input level, nothing gets done.", NULL };
-        if (slin > 0) {
-            mp_snprintf(msg, 256, "No matching 'etex' for '%stex'.", verb ? "verbatim" : "b");
-        } else {
-            mp_snprintf(msg, 256, "No matching 'etex' for '%stex' in line %d.", verb ? "verbatim" : "b",slin);
-        }
-        mp_error (mp, msg, hlp, false);
-        free(txt);
-    }
 }
 
 @ @<Put a maketext result string into the input buffer@>=
@@ -20102,7 +19964,7 @@ line and preceded by a space or at the b
         mp_value new_expr;
         const char *hlp[] = {
            "I'm going to flush this expression, since",
-           "maketext should be followed by a known string.",
+           "makete should be followed by a known string.",
            NULL };
         memset(&new_expr,0,sizeof(mp_value));
         new_number(new_expr.data.n);
@@ -20114,9 +19976,9 @@ line and preceded by a space or at the b
     } else {
         mp_back_input (mp);
         if (cur_exp_str ()->len > 0) {
+            mp_value new_expr;
             char *s = mp->make_text(mp,(const char*) cur_exp_str()->str,0) ;
             @<Run a script@>
-            free(s);
         }
     }
 }
@@ -23433,7 +23295,7 @@ RESTART:
 
       q = mp_get_value_node (mp);
       mp_name_type (q) = mp_capsule;
-      if (cur_cmd() == mp_comma) {
+      if (cur_cmd() == mp_comma) { 
         mp_init_color_node (mp, q);
         r = value_node (q);
         mp_stash_in (mp, y_part (r));
@@ -23459,7 +23321,7 @@ RESTART:
         }
         mp_stash_in (mp, blue_part (r));
 
-        if (cur_cmd() == mp_comma) {
+        if (cur_cmd() == mp_comma) { 
           mp_node t;      /* a token */
           mp_init_cmykcolor_node (mp, q);
           t = value_node (q);
@@ -23475,13 +23337,13 @@ RESTART:
             set_dep_list (cyan_part(t),dep_list ((mp_value_node) red_part(r)));
             set_prev_dep (cyan_part(t),prev_dep ((mp_value_node) red_part(r)));
             set_mp_link (prev_dep (cyan_part(t)), (mp_node) cyan_part(t));
-          }
+          }		
 	  if ( ((mp_type (magenta_part (t))) != mp_independent) && ((mp_type (magenta_part (t))) != mp_known) ) {
      	     /* Copy the dep list */
             set_dep_list (magenta_part(t),dep_list ((mp_value_node) green_part(r)));
             set_prev_dep (magenta_part(t),prev_dep ((mp_value_node) green_part(r)));
             set_mp_link (prev_dep (magenta_part(t)), (mp_node) magenta_part(t));
-          }
+          }		
 	  if ( ((mp_type (yellow_part (t))) != mp_independent) && ((mp_type (yellow_part (t))) != mp_known)) {
      	     /* Copy the dep list */
             set_dep_list (yellow_part(t),dep_list ((mp_value_node) blue_part(r)));
@@ -29123,7 +28985,7 @@ static void mp_set_up_boundingpath (MP m
   unsigned char ljoin, lcap;
   mp_number miterlim;
   mp_knot q = mp_copy_path (mp, cur_exp_knot ());       /* the original path */
-  mp_knot pen;
+  mp_knot pen; 
   mp_knot qq;
 
   new_number(miterlim);
@@ -30809,8 +30671,8 @@ void mp_show_library_versions (void) {
   fprintf(stdout, "Compiled with pixman %s; using %s\n",COMPILED_PIXMAN_VERSION_STRING, pixman_version_string());
   fprintf(stdout, "Compiled with libpng %s; using %s\n", PNG_LIBPNG_VER_STRING, png_libpng_ver);
   fprintf(stdout, "Compiled with zlib %s; using %s\n", ZLIB_VERSION, zlibVersion());
-  fprintf(stdout, "Compiled with mpfr %s; using %s\n", COMPILED_MPFR_VERSION_STRING, mpfr_get_version());
-  fprintf(stdout, "Compiled with gmp %d.%d.%d; using %s\n\n", COMPILED__GNU_MP_VERSION, COMPILED__GNU_MP_VERSION_MINOR, COMPILED__GNU_MP_VERSION_PATCHLEVEL, COMPILED_gmp_version);
+  fprintf(stdout, "Compiled with mpfr %s; using %s\n", MPFR_VERSION_STRING, mpfr_get_version());
+  fprintf(stdout, "Compiled with gmp %d.%d.%d; using %s\n\n", __GNU_MP_VERSION, __GNU_MP_VERSION_MINOR, __GNU_MP_VERSION_PATCHLEVEL, gmp_version);
 }
 
 @ @<Exported function headers@>=
@@ -33368,7 +33230,7 @@ We may need to cancel skips that span mo
 
 
 @ The header could contain ASCII zeroes, so can't use |strdup|.
-The index |j| can be beyond the index |header_last|, hence we
+The index |j| can be beyond the index |header_last|, hence we 
 have to sure  to update the end of stream marker to reflect the
 actual position.
 
@@ -34693,9 +34555,8 @@ extreme cases so it may have to be short
 
 @<Use |c| to compute the file extension |s|@>=
 {
-  s = xmalloc (12, 1);
-  mp_snprintf (s, 12, ".%i", (int) c);
-  s[7]='\0';
+  s = xmalloc (7, 1);
+  mp_snprintf (s, 7, ".%i", (int) c);
 }
 
 
--- texlive-bin.orig/texk/web2c/mplibdir/mpmath.w
+++ texlive-bin/texk/web2c/mplibdir/mpmath.w
@@ -1,4 +1,4 @@
-% $Id: mpmath.w 2118 2017-02-15 17:49:54Z luigi $
+% $Id$
 %
 % This file is part of MetaPost;
 % the MetaPost program is in the public domain.
--- texlive-bin.orig/texk/web2c/mplibdir/mpmathbinary.w
+++ texlive-bin/texk/web2c/mplibdir/mpmathbinary.w
@@ -39,19 +39,6 @@
 #include "mpmp.h" /* internal header */
 #include <gmp.h>
 #include <mpfr.h>
-
-#ifdef HAVE_CONFIG_H
-#include <gmp/config.h>
-const char * const COMPILED_gmp_version  = VERSION;
-#else
-const char * const COMPILED_gmp_version  = "unknown";
-#endif
-
-const char *COMPILED_MPFR_VERSION_STRING = MPFR_VERSION_STRING;
-int COMPILED__GNU_MP_VERSION = __GNU_MP_VERSION ;
-int COMPILED__GNU_MP_VERSION_MINOR = __GNU_MP_VERSION_MINOR ;
-int COMPILED__GNU_MP_VERSION_PATCHLEVEL = __GNU_MP_VERSION_PATCHLEVEL ;
-
 @<Internal library declarations@>;
 #endif
 
--- texlive-bin.orig/texk/web2c/mplibdir/mpmathdouble.w
+++ texlive-bin/texk/web2c/mplibdir/mpmathdouble.w
@@ -1,4 +1,4 @@
-% $Id: mpmathdouble.w 2118 2017-02-15 17:49:54Z luigi $
+% $Id$
 %
 % This file is part of MetaPost;
 % the MetaPost program is in the public domain.
