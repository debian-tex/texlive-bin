Index: texlive-bin-2020.20200327.54578/texk/web2c/luatexdir/lua/loslibext.c
===================================================================
--- texlive-bin-2020.20200327.54578.orig/texk/web2c/luatexdir/lua/loslibext.c
+++ texlive-bin-2020.20200327.54578/texk/web2c/luatexdir/lua/loslibext.c
@@ -1034,6 +1034,59 @@ static int os_execute(lua_State * L)
     return ret;
 }
 
+/* socket.sleep and socket.gettime      */
+/* are duplicated here, and they are    */
+/* always available (the socket library */
+/* can  be nil in some setups)          */
+#ifdef _WIN32
+static int socket_timeout_lua_sleep(lua_State *L)
+{
+    double n = luaL_checknumber(L, 1);
+    if (n < 0.0) n = 0.0;
+    if (n < DBL_MAX/1000.0) n *= 1000.0;
+    if (n > INT_MAX) n = INT_MAX;
+    Sleep((int)n);
+    return 0;
+}
+static double socket_timeout_gettime(void) {
+    FILETIME ft;
+    double t;
+    GetSystemTimeAsFileTime(&ft);
+    /* Windows file time (time since January 1, 1601 (UTC)) */
+    t  = ft.dwLowDateTime/1.0e7 + ft.dwHighDateTime*(4294967296.0/1.0e7);
+    /* convert to Unix Epoch time (time since January 1, 1970 (UTC)) */
+    return (t - 11644473600.0);
+}
+#else
+static int socket_timeout_lua_sleep(lua_State *L)
+{
+    double n = luaL_checknumber(L, 1);
+    struct timespec t, r;
+    if (n < 0.0) n = 0.0;
+    if (n > INT_MAX) n = INT_MAX;
+    t.tv_sec = (int) n;
+    n -= t.tv_sec;
+    t.tv_nsec = (int) (n * 1000000000);
+    if (t.tv_nsec >= 1000000000) t.tv_nsec = 999999999;
+    while (nanosleep(&t, &r) != 0) {
+        t.tv_sec = r.tv_sec;
+        t.tv_nsec = r.tv_nsec;
+    }
+    return 0;
+}
+static double socket_timeout_gettime(void) {
+    struct timeval v;
+    gettimeofday(&v, (struct timezone *) NULL);
+    /* Unix Epoch time (time since January 1, 1970 (UTC)) */
+    return v.tv_sec + v.tv_usec/1.0e6;
+}
+#endif
+static int socket_timeout_lua_gettime(lua_State *L)
+{
+    lua_pushnumber(L, socket_timeout_gettime());
+    return 1;
+}
+
 
 /*
 ** ======================================================
@@ -1173,8 +1226,16 @@ void open_oslibext(lua_State * L)
     lua_setfield(L, -2, "execute");
     lua_pushcfunction(L, os_tmpdir);
     lua_setfield(L, -2, "tmpdir");
+
     lua_pushcfunction(L, io_kpse_popen);
     lua_setfield(L, -2, "kpsepopen");
 
+    lua_pushcfunction(L, socket_timeout_lua_sleep);
+    lua_setfield(L, -2, "socketsleep");
+
+    lua_pushcfunction(L, socket_timeout_lua_gettime);
+    lua_setfield(L, -2, "socketgettime");
+
+
     lua_pop(L, 1);              /* pop the table */
 }
Index: texlive-bin-2020.20200327.54578/texk/web2c/luatexdir/lua/luainit.c
===================================================================
--- texlive-bin-2020.20200327.54578.orig/texk/web2c/luatexdir/lua/luainit.c
+++ texlive-bin-2020.20200327.54578/texk/web2c/luatexdir/lua/luainit.c
@@ -83,6 +83,8 @@ const_string LUATEX_IHELP[] = {
     "   --lua=FILE                    load and execute a lua initialization script",
     "   --[no-]mktex=FMT              disable/enable mktexFMT generation (FMT=tex/tfm)",
     "   --nosocket                    disable the lua socket library",
+    "   --no-socket                   disable the lua socket library",
+    "   --socket                      enable the lua socket library",
     "   --output-comment=STRING       use STRING for DVI file comment instead of date (no effect for PDF)",
     "   --output-directory=DIR        use existing DIR as the directory to write files in",
     "   --output-format=FORMAT        use FORMAT for job output; FORMAT is 'dvi' or 'pdf'",
@@ -210,9 +212,30 @@ char *jithash_hashname = NULL;
 #endif
 
 int safer_option = 0;
-int nosocket_option = 0;
+int nosocket_option = 1; 
+int nosocket_cli_option = 0; 
+int yessocket_cli_option = 0; 
+int socket_bitmask = 0; 
 int utc_option = 0;
 
+/*tex We use a bitmask for the socket library: |0000| and |1xxx| implies |--nosocket|,
+  otherwise the socket library is enabled. Default value is |0000|, i.e. |--nosocket|.
+*/
+#define UPDATE_SOCKET_STATUS() do {                                                              \
+ socket_bitmask = 0;                                                                             \
+ socket_bitmask = safer_option==1?                             (8+socket_bitmask):socket_bitmask;\
+ socket_bitmask = nosocket_cli_option==1?                      (4+socket_bitmask):socket_bitmask;\
+ socket_bitmask = (shellenabledp == 1 && restrictedshell == 0)?(2+socket_bitmask):socket_bitmask;\
+ socket_bitmask = yessocket_cli_option==1?                     (1+socket_bitmask):socket_bitmask;\
+ if( socket_bitmask==0) {                                                                        \
+   nosocket_option = 1;                                                                          \
+ } else if ( socket_bitmask<4) {                                                                 \
+   nosocket_option = 0;                                                                          \
+ } else {                                                                                        \
+   nosocket_option = 1;                                                                          \
+ }                                                                                               \
+} while (0)
+
 /*tex
 
 Test whether getopt found an option ``A''. Assumes the option index is in the
@@ -240,7 +263,9 @@ static struct option long_options[] = {
 #endif
     {"safer", 0, &safer_option, 1},
     {"utc", 0, &utc_option, 1},
-    {"nosocket", 0, &nosocket_option, 1},
+    {"nosocket", 0, &nosocket_cli_option, 1},
+    {"no-socket", 0, &nosocket_cli_option, 1},
+    {"socket", 0, &yessocket_cli_option, 1},
     {"help", 0, 0, 0},
     {"ini", 0, &ini_version, 1},
     {"interaction", 1, 0, 0},
@@ -519,14 +544,11 @@ static void parse_options(int ac, char *
                 input_name = xstrdup(sargv[sargc-1]);
             sargv[sargc-1] = normalize_quotes(input_name, "argument");
         }
-        if (safer_option)      /* --safer implies --nosocket */
-            nosocket_option = 1;
+	UPDATE_SOCKET_STATUS();
         return;
 #endif
     }
-    /*tex |--safer| implies |--nosocket| */
-    if (safer_option)
-        nosocket_option = 1;
+    UPDATE_SOCKET_STATUS();
     /*tex Finalize the input filename. */
     if (input_name != NULL) {
         argv[optind] = normalize_quotes(input_name, "argument");
@@ -975,6 +997,7 @@ void lua_initialize(int ac, char **av)
         shellenabledp = true;
         restrictedshell = false;
         safer_option = 0;
+	nosocket_option = 0;
     }
     /*tex
         Get the current locale (it should be |C|) and save |LC_CTYPE|, |LC_COLLATE|
@@ -1143,6 +1166,7 @@ void lua_initialize(int ac, char **av)
             }
             free(v1);
         }
+	UPDATE_SOCKET_STATUS();
         /*tex If shell escapes are restricted, get allowed cmds from cnf.  */
         if (shellenabledp && restrictedshell == 1) {
             v1 = NULL;
Index: texlive-bin-2020.20200327.54578/texk/web2c/luatexdir/lua/luastuff.c
===================================================================
--- texlive-bin-2020.20200327.54578.orig/texk/web2c/luatexdir/lua/luastuff.c
+++ texlive-bin-2020.20200327.54578/texk/web2c/luatexdir/lua/luastuff.c
@@ -323,7 +323,8 @@ void luainterpreter(void)
     /*tex
         The socket and mime libraries are a bit tricky to open because they use a
         load-time dependency that has to be worked around for luatex, where the C
-        module is loaded way before the lua module.
+        module is loaded way before the lua module. 
+        The mime library is always available, even if the socket library is not enabled.
     */
     if (!nosocket_option) {
         /* todo: move this to common */
@@ -348,6 +349,23 @@ void luainterpreter(void)
         lua_pop(L, 2);
         /*tex preload the pure \LUA\ modules */
         luatex_socketlua_open(L);
+    } else {
+        lua_getglobal(L, "package");
+        lua_getfield(L, -1, "loaded");
+        if (!lua_istable(L, -1)) {
+            lua_newtable(L);
+            lua_setfield(L, -2, "loaded");
+            lua_getfield(L, -1, "loaded");
+        }
+        /*tex |package.loaded.mime = nil| */
+        luaopen_mime_core(L);
+        lua_setfield(L, -2, "mime.core");
+        lua_pushnil(L);
+        lua_setfield(L, -2, "mime");
+        /*tex pop the table */
+        lua_pop(L, 1);
+        /*tex preload the pure \LUA\ mime module */
+        luatex_socketlua_safe_open(L);
     }
     luaopen_zlib(L);
     luaopen_gzip(L);
Index: texlive-bin-2020.20200327.54578/texk/web2c/luatexdir/lua/luatex-api.h
===================================================================
--- texlive-bin-2020.20200327.54578.orig/texk/web2c/luatexdir/lua/luatex-api.h
+++ texlive-bin-2020.20200327.54578/texk/web2c/luatexdir/lua/luatex-api.h
@@ -123,6 +123,7 @@ extern int luaopen_profiler(lua_State *
 extern int luaopen_socket_core(lua_State * L);
 extern int luaopen_mime_core(lua_State * L);
 extern void luatex_socketlua_open(lua_State * L);
+extern void luatex_socketlua_safe_open(lua_State * L);
 
 extern int luaopen_img(lua_State * L);
 extern int l_new_image(lua_State * L);
Index: texlive-bin-2020.20200327.54578/texk/web2c/luatexdir/luasocket/src/lua_preload.c
===================================================================
--- texlive-bin-2020.20200327.54578.orig/texk/web2c/luatexdir/luasocket/src/lua_preload.c
+++ texlive-bin-2020.20200327.54578/texk/web2c/luatexdir/luasocket/src/lua_preload.c
@@ -16,6 +16,7 @@ int luatex_ftp_lua_open(lua_State*);
 
 
 extern void luatex_socketlua_open (lua_State *) ;
+extern void luatex_socketlua_safe_open (lua_State *) ;
 #include "ftp_lua.c"
 #include "headers_lua.c" 
 #include "http_lua.c"
@@ -47,3 +48,11 @@ luatex_socketlua_open (lua_State *L) {
     TEST(luatex_http_lua_open(L));
     TEST(luatex_ftp_lua_open(L));
 }
+
+/* luatex_socketlua_safe_open: load safe modules */
+/* of luasocket ( mime ).                        */
+void
+luatex_socketlua_safe_open (lua_State *L) {
+    TEST(luatex_ltn12_lua_open(L));
+    TEST(luatex_mime_lua_open(L));
+}
