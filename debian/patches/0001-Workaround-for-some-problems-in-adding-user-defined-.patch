From b17e7380acdbbaaa1fb4686a4d23a3dd4b6f13a1 Mon Sep 17 00:00:00 2001
From: Akira Kakuto <kakuto@fuk.kindai.ac.jp>
Date: Fri, 16 Aug 2019 22:35:33 +0000
Subject: [PATCH 1/3] Workaround for some problems in adding user defined
 resources. (S. Hirata)

git-svn-id: svn://tug.org/texlive/trunk/Build/source@51889 c570f23f-e606-0410-a88d-b1316a301751
---
 texk/dvipdfm-x/ChangeLog    |   8 ++
 texk/dvipdfm-x/configure    |  22 ++---
 texk/dvipdfm-x/configure.ac |   2 +-
 texk/dvipdfm-x/pdfdoc.c     |   5 ++
 texk/dvipdfm-x/spc_pdfm.c   | 159 +++++++++++++++++++++++-------------
 5 files changed, 129 insertions(+), 67 deletions(-)

diff --git a/texk/dvipdfm-x/ChangeLog b/texk/dvipdfm-x/ChangeLog
index cb00f7915..de3e908f7 100644
--- a/texk/dvipdfm-x/ChangeLog
+++ b/texk/dvipdfm-x/ChangeLog
@@ -1,3 +1,11 @@
+2019-08-17  Shunsaku Hirata  <shunsaku.hirata74@gmail.com>
+
+	* pdfdoc.c, spc_pdfm.c: Workaround for some problems reported
+	in https://tug.org/pipermail/dvipdfmx/2019-August/000021.html.
+	Try to deref page resource dictionary when adding page resources.
+	Allow direct objects for page resources.
+	* configure.ac: Version 20190817.
+
 2019-08-05  Shunsaku Hirata  <shunsaku.hirata74@gmail.com>
 
 	* pdfobj.c: Ignore zlib error while uncompressing data.
diff --git a/texk/dvipdfm-x/configure b/texk/dvipdfm-x/configure
index 574d6400a..dc1306c67 100755
--- a/texk/dvipdfm-x/configure
+++ b/texk/dvipdfm-x/configure
@@ -1,6 +1,6 @@
 #! /bin/sh
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.69 for dvipdfm-x (TeX Live) 20190805.
+# Generated by GNU Autoconf 2.69 for dvipdfm-x (TeX Live) 20190817.
 #
 # Report bugs to <dvipdfmx@tug.org>.
 #
@@ -590,8 +590,8 @@ MAKEFLAGS=
 # Identity of this package.
 PACKAGE_NAME='dvipdfm-x (TeX Live)'
 PACKAGE_TARNAME='dvipdfm-x--tex-live-'
-PACKAGE_VERSION='20190805'
-PACKAGE_STRING='dvipdfm-x (TeX Live) 20190805'
+PACKAGE_VERSION='20190817'
+PACKAGE_STRING='dvipdfm-x (TeX Live) 20190817'
 PACKAGE_BUGREPORT='dvipdfmx@tug.org'
 PACKAGE_URL=''
 
@@ -1350,7 +1350,7 @@ if test "$ac_init_help" = "long"; then
   # Omit some internal or obsolete options to make the list less imposing.
   # This message is too long to be a string in the A/UX 3.1 sh.
   cat <<_ACEOF
-\`configure' configures dvipdfm-x (TeX Live) 20190805 to adapt to many kinds of systems.
+\`configure' configures dvipdfm-x (TeX Live) 20190817 to adapt to many kinds of systems.
 
 Usage: $0 [OPTION]... [VAR=VALUE]...
 
@@ -1421,7 +1421,7 @@ fi
 
 if test -n "$ac_init_help"; then
   case $ac_init_help in
-     short | recursive ) echo "Configuration of dvipdfm-x (TeX Live) 20190805:";;
+     short | recursive ) echo "Configuration of dvipdfm-x (TeX Live) 20190817:";;
    esac
   cat <<\_ACEOF
 
@@ -1551,7 +1551,7 @@ fi
 test -n "$ac_init_help" && exit $ac_status
 if $ac_init_version; then
   cat <<\_ACEOF
-dvipdfm-x (TeX Live) configure 20190805
+dvipdfm-x (TeX Live) configure 20190817
 generated by GNU Autoconf 2.69
 
 Copyright (C) 2012 Free Software Foundation, Inc.
@@ -2390,7 +2390,7 @@ cat >config.log <<_ACEOF
 This file contains any messages produced by compilers while
 running configure, to aid debugging if configure makes a mistake.
 
-It was created by dvipdfm-x (TeX Live) $as_me 20190805, which was
+It was created by dvipdfm-x (TeX Live) $as_me 20190817, which was
 generated by GNU Autoconf 2.69.  Invocation command line was
 
   $ $0 $@
@@ -8077,7 +8077,7 @@ fi
 
 # Define the identity of the package.
  PACKAGE='dvipdfm-x--tex-live-'
- VERSION='20190805'
+ VERSION='20190817'
 
 
 cat >>confdefs.h <<_ACEOF
@@ -14746,7 +14746,7 @@ Usage: $0 [OPTIONS]
 Report bugs to <bug-libtool@gnu.org>."
 
 lt_cl_version="\
-dvipdfm-x (TeX Live) config.lt 20190805
+dvipdfm-x (TeX Live) config.lt 20190817
 configured by $0, generated by GNU Autoconf 2.69.
 
 Copyright (C) 2011 Free Software Foundation, Inc.
@@ -16636,7 +16636,7 @@ cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
 # report actual input values of CONFIG_FILES etc. instead of their
 # values after options handling.
 ac_log="
-This file was extended by dvipdfm-x (TeX Live) $as_me 20190805, which was
+This file was extended by dvipdfm-x (TeX Live) $as_me 20190817, which was
 generated by GNU Autoconf 2.69.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
@@ -16706,7 +16706,7 @@ _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 ac_cs_config="`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`"
 ac_cs_version="\\
-dvipdfm-x (TeX Live) config.status 20190805
+dvipdfm-x (TeX Live) config.status 20190817
 configured by $0, generated by GNU Autoconf 2.69,
   with options \\"\$ac_cs_config\\"
 
diff --git a/texk/dvipdfm-x/configure.ac b/texk/dvipdfm-x/configure.ac
index a8fd6fdbc..357c86f8b 100644
--- a/texk/dvipdfm-x/configure.ac
+++ b/texk/dvipdfm-x/configure.ac
@@ -7,7 +7,7 @@ dnl   This file is free software; the copyright holder
 dnl   gives unlimited permission to copy and/or distribute it,
 dnl   with or without modifications, as long as this notice is preserved.
 dnl
-AC_INIT([dvipdfm-x (TeX Live)], [20190805], [dvipdfmx@tug.org])
+AC_INIT([dvipdfm-x (TeX Live)], [20190817], [dvipdfmx@tug.org])
 AC_PREREQ([2.65])
 AC_CONFIG_SRCDIR([agl.c])
 AC_CONFIG_AUX_DIR([../../build-aux])
diff --git a/texk/dvipdfm-x/pdfdoc.c b/texk/dvipdfm-x/pdfdoc.c
index 8299af94e..76a4ada1c 100644
--- a/texk/dvipdfm-x/pdfdoc.c
+++ b/texk/dvipdfm-x/pdfdoc.c
@@ -520,6 +520,9 @@ pdf_doc_get_page_resources (pdf_doc *p, const char *category)
   if (!resources) {
     resources = pdf_new_dict();
     pdf_add_dict(res_dict, pdf_new_name(category), resources);
+  } else if (pdf_obj_typeof(resources) == PDF_INDIRECT) {
+    resources = pdf_deref_obj(resources); /* FIXME: deref_obj increment link count */
+    pdf_release_obj(resources); /* FIXME: just to decrement link count */
   }
 
   return resources;
@@ -533,10 +536,12 @@ pdf_doc_add_page_resource (const char *category,
   pdf_obj *resources;
   pdf_obj *duplicate;
 
+#if 0
   if (!PDF_OBJ_INDIRECTTYPE(resource_ref)) {
     WARN("Passed non indirect reference...");
     resource_ref = pdf_ref_obj(resource_ref); /* leak */
   }
+#endif
   resources = pdf_doc_get_page_resources(p, category);
   duplicate = pdf_lookup_dict(resources, resource_name);
   if (duplicate && pdf_compare_reference(duplicate, resource_ref)) {
diff --git a/texk/dvipdfm-x/spc_pdfm.c b/texk/dvipdfm-x/spc_pdfm.c
index aa80a6ba5..f084243cb 100644
--- a/texk/dvipdfm-x/spc_pdfm.c
+++ b/texk/dvipdfm-x/spc_pdfm.c
@@ -198,6 +198,51 @@ spc_pdfm_at_end_document (void)
   return  spc_handler_pdfm__clean(sd);
 }
 
+/* Why should we have this kind of things? */
+static int
+safeputresdent (pdf_obj *kp, pdf_obj *vp, void *dp)
+{
+  char  *key;
+
+  ASSERT(kp && vp && dp);
+
+  key = pdf_name_value(kp);
+  if (pdf_lookup_dict(dp, key))
+    WARN("Object \"%s\" already defined in dict! (ignored)", key);
+  else {
+    pdf_add_dict(dp,
+                 pdf_link_obj(kp), pdf_link_obj(vp));
+  }
+  return 0;
+}
+
+static int
+safeputresdict (pdf_obj *kp, pdf_obj *vp, void *dp)
+{
+  char    *key;
+  pdf_obj *dict;
+
+  ASSERT(kp && vp && dp);
+
+  key  = pdf_name_value(kp);
+  dict = pdf_lookup_dict(dp, key);
+
+  if (pdf_obj_typeof(vp) == PDF_INDIRECT) {
+    pdf_add_dict(dp, pdf_new_name(key), pdf_link_obj(vp));
+  } else if (pdf_obj_typeof(vp) == PDF_DICT) {
+    if (dict)
+      pdf_foreach_dict(vp, safeputresdent, dict);
+    else {
+      pdf_add_dict(dp, pdf_new_name(key), pdf_link_obj(vp));
+    }
+  } else {
+    WARN("Invalid type (not DICT) for page/form resource dict entry: key=\"%s\"", key);
+    return  -1;
+  }
+
+  return 0;
+}
+
 static
 int putpageresources (pdf_obj *kp, pdf_obj *vp, void *dp)
 {
@@ -206,7 +251,7 @@ int putpageresources (pdf_obj *kp, pdf_obj *vp, void *dp)
   ASSERT(kp && vp);
 
   resource_name = pdf_name_value(kp);
-  pdf_doc_add_page_resource(dp, resource_name, pdf_ref_obj(vp));
+  pdf_doc_add_page_resource(dp, resource_name, pdf_link_obj(vp));
 
   return 0;
 }
@@ -214,16 +259,65 @@ int putpageresources (pdf_obj *kp, pdf_obj *vp, void *dp)
 static
 int forallresourcecategory (pdf_obj *kp, pdf_obj *vp, void *dp)
 {
+  int   r = -1;
   char *category;
 
   ASSERT(kp && vp);
 
   category = pdf_name_value(kp);
-  if (!PDF_OBJ_DICTTYPE(vp)) {
-    return -1;
+  switch (pdf_obj_typeof(vp)) {
+  case PDF_DICT:
+    r = pdf_foreach_dict(vp, putpageresources, category);
+    break;
+  case PDF_INDIRECT:
+    {
+      /* In case pdf:pageresouces << /Category @res >> */
+      pdf_obj *obj;
+      obj = pdf_deref_obj(vp);
+      if (!obj) {
+        WARN("Can't deref object for page resource: %s", category);
+        r = -1;
+      } else if (pdf_obj_typeof(obj) != PDF_DICT) {
+        WARN("Invalid object type for page resource: %s", category);
+        r = -1;
+      } else {
+        pdf_obj *res_dict, *dict;
+
+        res_dict = pdf_doc_current_page_resources();
+        dict     = pdf_lookup_dict(res_dict, category);
+        if (!dict) {
+          pdf_add_dict(res_dict, pdf_new_name(category), pdf_link_obj(vp));
+        } else {
+          if (pdf_obj_typeof(dict) == PDF_INDIRECT) {
+            dict = pdf_deref_obj(dict);
+            pdf_release_obj(dict); /* FIXME: jus to decrement link counter */
+          }
+#if 1
+          /* This will leave garbage (object "res") since object "res"
+           * supplied as resource dictionary will have label but we copy the
+           * content of res here and never use reference to it.
+           */
+          pdf_foreach_dict(obj, safeputresdent, dict);
+#else
+          /* With the below code resource dictionary is replaced by user
+           * supplied one, @res. However, there is a problem that all
+           * resources including internally generated one may go into single
+           * dictionary referenced by @res, and will be visible from any
+           * subsequent pages. 
+           */
+          pdf_foreach_dict(dict, safeputresdent, obj);
+          pdf_add_dict(res_dict, pdf_new_name(category), pdf_link_obj(vp));
+#endif
+        }
+        pdf_release_obj(obj);
+      }
+    }
+    break;
+  default:
+    WARN("Invalid object type for page resource specified for \"%s\"", category);
   }
 
-  return pdf_foreach_dict(vp, putpageresources, category);
+  return r;
 }
 
 int
@@ -268,56 +362,6 @@ spc_handler_pdfm_eop (struct spc_env *spe, struct spc_arg *args)
 #define streamfiltered(o) \
   (pdf_lookup_dict(pdf_stream_dict((o)), "Filter") ? 1 : 0)
 
-/* Why should we have this kind of things? */
-static int
-safeputresdent (pdf_obj *kp, pdf_obj *vp, void *dp)
-{
-  char  *key;
-
-  ASSERT(kp && vp && dp);
-
-  key = pdf_name_value(kp);
-  if (pdf_lookup_dict(dp, key))
-    WARN("Object \"%s\" already defined in dict! (ignored)", key);
-  else {
-    pdf_add_dict(dp,
-                 pdf_link_obj(kp), pdf_link_obj(vp));
-  }
-  return 0;
-}
-
-#ifndef pdf_obj_isaref
-#define pdf_obj_isaref(o) (pdf_obj_typeof((o)) == PDF_INDIRECT)
-#endif
-
-static int
-safeputresdict (pdf_obj *kp, pdf_obj *vp, void *dp)
-{
-  char    *key;
-  pdf_obj *dict;
-
-  ASSERT(kp && vp && dp);
-
-  key  = pdf_name_value(kp);
-  dict = pdf_lookup_dict(dp, key);
-
-  if (pdf_obj_isaref(vp)) {
-    pdf_add_dict(dp, pdf_new_name(key), pdf_link_obj(vp));
-  } else if (pdf_obj_typeof(vp) == PDF_DICT) {
-    if (dict)
-      pdf_foreach_dict(vp, safeputresdent, dict);
-    else {
-      pdf_add_dict(dp, pdf_new_name(key), pdf_link_obj(vp));
-    }
-  } else {
-    WARN("Invalid type (not DICT) for page/form resource dict entry: key=\"%s\"", key);
-    return  -1;
-  }
-
-  return 0;
-}
-
-
 /* Think what happens if you do
  *
  *  pdf:put @resources << /Font << >> >>
@@ -1716,7 +1760,8 @@ spc_handler_pdfm_bform (struct spc_env *spe, struct spc_arg *args)
 static int
 spc_handler_pdfm_eform (struct spc_env *spe, struct spc_arg *args)
 {
-  pdf_obj   *attrib = NULL;
+  pdf_obj         *attrib = NULL;
+  struct spc_pdf_ *sd     = &_pdf_stat;
 
   skip_white(&args->curptr, args->endptr);
 
@@ -1727,6 +1772,10 @@ spc_handler_pdfm_eform (struct spc_env *spe, struct spc_arg *args)
       attrib = NULL;
     }
   }
+  /* pageresources here too */
+  if (sd->pageresources) {
+    pdf_foreach_dict(sd->pageresources, forallresourcecategory, NULL);
+  }
   pdf_doc_end_grabbing(attrib);
 
   return 0;
-- 
2.23.0

