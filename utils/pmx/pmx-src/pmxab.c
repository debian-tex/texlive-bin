#line 1 ""
/*  -- translated by f2c (version 20200916).
   You must link the resulting object file with libf2c:
	on Microsoft Windows system, link with libf2c.lib;
	on Linux or Unix systems, link with .../path/to/libf2c.a -lm
	or, if you install libf2c.a in a standard place, with -lf2c -lm
	-- in that order, at the end of the command line, as in
		cc *.o -lf2c -lm
	Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,

		http://www.netlib.org/f2c/libf2c.zip
*/

#include "f2c.h"

#line 1 ""
/* Common Block Declarations */

struct {
    char versionc[5];
} comver_;

#define comver_1 comver_

struct {
    integer miditime, lasttime;
} comevent_;

#define comevent_1 comevent_

struct {
    integer levson[25], levsoff[25], imidso[25], naccbl[25], laccbl[250]	
	    /* was [25][10] */, jaccbl[250]	/* was [25][10] */, nusebl;
    logical slmon[25], dbltie;
} comslm_;

#define comslm_1 comslm_

struct {
    integer imidi[25];
    real trest[25];
    integer mcpitch[20], mgap, iacclo[150]	/* was [25][6] */, iacchi[150]
	    	/* was [25][6] */, midinst[24], nmidcrd, midchan[48]	/* 
	    was [24][2] */, numchan, naccim[25], laccim[250]	/* was [25][
	    10] */, jaccim[250]	/* was [25][10] */;
    logical crdacc, notmain, restpend[25], relacc, twoline[24], ismidi;
    shortint mmidi[614400]	/* was [25][24576] */;
    logical debugmidi;
} commidi_;

#define commidi_1 commidi_

union {
    struct {
	integer midivel[24], midvelc[25], midibal[24], midbc[25], miditran[24]
		, midtc[25], noinst;
	shortint iinsiv[24];
    } _1;
    struct {
	integer midivel[24], midvelc[25], midibal[24], midbc[25], miditran[24]
		, midtc[25], noinstdum;
	shortint iinsiv[24];
    } _2;
} commvel_;

#define commvel_1 (commvel_._1)
#define commvel_2 (commvel_._2)

struct {
    integer ipbuf, ilbuf, nlbuf;
    shortint lbuf[9600];
    char bufq[131072];
} inbuff_;

#define inbuff_1 inbuff_

struct {
    integer musize;
    real whead20;
} commus_;

#define commus_1 commus_

union {
    struct {
	integer iv, ivxo[600], ipo[600];
	real to[600], tno[600];
	integer nnl[24], nv, ibar, mtrnuml, nodur[4800]	/* was [24][200] */, 
		lenbar, iccount, idum, itsofar[24], nib[360]	/* was [24][
		15] */, nn[24];
	logical rest[4800]	/* was [24][200] */;
	integer lenbr0, lenbr1;
	logical firstline, newmeter;
    } _1;
    struct {
	integer iv, ivxo[600], ipo[600];
	real to[600], tno[600];
	integer nnl[24], nv, ibar, mtrnuml, nodur[4800]	/* was [24][200] */, 
		lenbar, iccount, nbars, itsofar[24], nib[360]	/* was [24][
		15] */, nn[24];
	logical rest[4800]	/* was [24][200] */;
	integer lenbr0, lenbr1;
	logical firstline, newmeter;
    } _2;
} a1ll_;

#define a1ll_1 (a1ll_._1)
#define a1ll_2 (a1ll_._2)

struct {
    integer n69[25], n34[25];
} comdiag_;

#define comdiag_1 comdiag_

struct {
    integer mmacstrt[500]	/* was [25][20] */, mmacend[500]	/* 
	    was [25][20] */, immac, mmactime[20], nmidsec, msecstrt[1500]	
	    /* was [25][60] */, msecend[1500]	/* was [25][60] */;
    logical mmacrec, gottempo;
} commmac_;

#define commmac_1 commmac_

struct {
    integer linewcom[20000];
} truelinecount_;

#define truelinecount_1 truelinecount_

struct {
    logical lastchar, fbon, issegno;
    integer ihead;
    logical isheadr;
    integer nline;
    logical isvolt;
    real fracindent;
    integer nsperi[24], linesinpmxmod, line1pmxmod, lenbuf0;
} c1omget_;

#define c1omget_1 c1omget_

struct {
    integer naskb;
    real task[40], wask[40], elask[40];
} comas1_;

#define comas1_1 comas1_

struct {
    real udsp[50], tudsp[50];
    integer nudsp;
    real udoff[480]	/* was [24][20] */;
    integer nudoff[24];
} comudsp_;

#define comudsp_1 comudsp_

struct comtol_1_ {
    real tol;
};

#define comtol_1 (*(struct comtol_1_ *) &comtol_)

struct {
    shortint ipslon[25], lusebl[10], jusebl[10];
} comips_;

#define comips_1 comips_

struct {
    logical islast, usevshrink;
} comlast_;

#define comlast_1 comlast_

union {
    struct {
	real space[80];
	integer nb;
	real prevtn[24], flgndv[24], flgndb, eskgnd, ptsgnd;
	integer ivmxsav[48]	/* was [24][2] */, nvmxsav[24];
    } _1;
    struct {
	real space[80];
	integer nb;
	real prevtn[24], flgndv[24];
	logical flgndb;
	real eskgnd, ptsgnd;
	integer ivmxsav[48]	/* was [24][2] */, nvmxsav[24];
    } _2;
} comnsp_;

#define comnsp_1 (comnsp_._1)
#define comnsp_2 (comnsp_._2)

union {
    struct {
	integer mult[4800]	/* was [24][200] */, iv, nnl[24], nv, ibar, 
		ivxo[600], ipo[600];
	real to[600], tno[600], tnote[600], eskz[4800]	/* was [24][200] */;
	integer ipl[4800]	/* was [24][200] */, ibm1[216]	/* was [24][9]
		 */, ibm2[216]	/* was [24][9] */, nolev[4800]	/* was [24][
		200] */, ibmcnt[24], nodur[4800]	/* was [24][200] */, 
		jn, lenbar, iccount, nbars, itsofar[24], nacc[4800]	/* 
		was [24][200] */, nib[360]	/* was [24][15] */, nn[24], 
		lenb0, lenb1;
	real slfac;
	integer musicsize;
	real stemmax, stemmin, stemlen;
	integer mtrnuml, mtrdenl, mtrnmp, mtrdnp, islur[4800]	/* was [24][
		200] */, ifigdr[250]	/* was [2][125] */, iline;
	logical figbass, figchk[2], firstgulp;
	integer irest[4800]	/* was [24][200] */, iornq[4824]	/* 
		was [24][201] */, isdat1[202], isdat2[202], nsdat, isdat3[202]
		, isdat4[202];
	logical beamon[24], isfig[400]	/* was [2][200] */;
	char sepsymq[24], sq[1], ulq[216]	/* was [24][9] */;
    } _1;
    struct {
	integer mult[4800]	/* was [24][200] */, jv, nnl[24], nv, ibar, 
		ivxo[600], ipo[600];
	real to[600], tno[600], tnote[600], eskz[4800]	/* was [24][200] */;
	integer ipl[4800]	/* was [24][200] */, ibm1[216]	/* was [24][9]
		 */, ibm2[216]	/* was [24][9] */, nolev[4800]	/* was [24][
		200] */, ibmcnt[24], nodur[4800]	/* was [24][200] */, 
		jn, lenbar, iccount, nbars, itsofar[24], nacc[4800]	/* 
		was [24][200] */, nib[360]	/* was [24][15] */, nn[24], 
		lenb0, lenb1;
	real slfac;
	integer musicsize;
	real stemmax, stemmin, stemlen;
	integer mtrnuml, mtrdenl, mtrnmp, mtrdnp, islur[4800]	/* was [24][
		200] */, ifigdr[250]	/* was [2][125] */, iline;
	logical figbass, figchk[2], firstgulp;
	integer irest[4800]	/* was [24][200] */, iornq[4824]	/* 
		was [24][201] */, isdat1[202], isdat2[202], nsdat, isdat3[202]
		, isdat4[202];
	logical beamon[24], isfig[400]	/* was [2][200] */;
	char sepsymq[24], sq[1], ulq[216]	/* was [24][9] */;
    } _2;
} all_;

#define all_1 (all_._1)
#define all_2 (all_._2)

struct {
    real eskz2[4800]	/* was [24][200] */;
} comeskz2_;

#define comeskz2_1 comeskz2_

struct {
    integer ntot;
} comntot_;

#define comntot_1 comntot_

struct {
    real hpttot[176];
} comhsp_;

#define comhsp_1 comhsp_

struct {
    logical ispoi;
} compoi_;

#define compoi_1 compoi_

struct {
    logical isbbm;
} combbm_;

#define combbm_1 combbm_

struct {
    real ask[2500];
    integer iask;
    logical topmods;
} comas3_;

#define comas3_1 comas3_

struct {
    integer ivbj1, ivbj2;
    logical isbjmp, isbj2;
    integer multbj1;
} combjmp_;

#define combjmp_1 combjmp_

struct {
    integer noctup;
} comoct_;

#define comoct_1 comoct_

union {
    struct {
	integer ixtup;
	logical vxtup[24];
	integer ntupv[216]	/* was [24][9] */, nolev1[24], mtupv[216]	
		/* was [24][9] */, nxtinbm[24], islope[24];
	real xelsk[24], eloff[216]	/* was [24][9] */;
	integer nssb[24], issb[24], lev1ssb[480]	/* was [24][20] */;
    } _1;
    struct {
	integer ixtup;
	logical vxtup[24];
	integer ntupv[216]	/* was [24][9] */, nolev1[24], mtupv[216]	
		/* was [24][9] */, nxtinbm[24], islope[24];
	real xels11[24], eloff[216]	/* was [24][9] */;
	integer nssb[24], issb[24], lev1ssb[480]	/* was [24][20] */;
    } _2;
} comxtup_;

#define comxtup_1 (comxtup_._1)
#define comxtup_2 (comxtup_._2)

struct {
    logical drawbm[24];
} comdraw_;

#define comdraw_1 comdraw_

struct {
    integer nvmx[24], ivmx[48]	/* was [24][2] */, ivx;
} commvl_;

#define commvl_1 commvl_

struct {
    integer ihnum3;
    logical flipend[24];
    integer ixrest[24];
} strtmid_;

#define strtmid_1 strtmid_

struct {
    logical bar1syst;
    real fixednew, scaldold, wheadpt, fbar, poenom;
} comask_;

#define comask_1 comask_

struct {
    integer itopfacteur, ibotfacteur, interfacteur, isig0, isig, lastisig;
    real fracindent, widthpt, height, hoffpt, voffpt;
    integer idsig, lnam[24];
    char inameq[1896];
} comtop_;

#define comtop_1 comtop_

struct {
    integer ntrill, ivtrill[24], iptrill[24];
    real xnsktr[24];
    integer ncrd, icrdat[193], icrdot[193], icrdorn[193], nudorn, kudorn[63];
    real ornhshft[63];
    integer minlev, maxlev, icrd1, icrd2;
} comtrill_;

#define comtrill_1 comtrill_

struct {
    integer nnb;
    real sumx, sumy;
    integer ipb[24];
    real smed;
} comipb_;

#define comipb_1 comipb_

union {
    struct {
	logical novshrinktop, cstuplet;
    } _1;
    struct {
	logical novshrinktop;
	real cstuplte;
    } _2;
} comnvst_;

#define comnvst_1 (comnvst_._1)
#define comnvst_2 (comnvst_._2)

union {
    struct {
	integer itfig[148]	/* was [2][74] */;
	char figq[1480]	/* was [2][74] */;
	integer ivupfig[148]	/* was [2][74] */, nfigs[2];
	real fullsize[24];
	integer ivxfig2, ivvfig[148]	/* was [2][74] */;
    } _1;
    struct {
	integer itfig[148]	/* was [2][74] */;
	char figqq[1480]	/* was [2][74] */;
	integer ivupfig[148]	/* was [2][74] */, nfigs[2];
	real fullsize[24];
	integer ivxfig2, ivvfig[148]	/* was [2][74] */;
    } _2;
} comfig_;

#define comfig_1 (comfig_._1)
#define comfig_2 (comfig_._2)

struct {
    integer nbrests;
} xjbeambrests_;

#define xjbeambrests_1 xjbeambrests_

struct {
    logical bigslope, novbm;
} comslope_;

#define comslope_1 comslope_

struct comtrans_1_ {
    char cheadq[60];
};

#define comtrans_1 (*(struct comtrans_1_ *) &comtrans_)

struct compage_1_ {
    real widthpt, ptheight, hoffpt, voffpt;
    integer nsyst, nflb, ibarflb[41], isysflb[41], npages, nfpb, ipagfpb[19], 
	    isysfpb[19];
    logical usefig;
    real fintstf, gintstf, fracsys[30];
    integer nmovbrk, isysmb[31], nistaff[41];
};

#define compage_1 (*(struct compage_1_ *) &compage_)

struct cblock_1_ {
    real etatop, etabot, etait, etatc, etacs1, hgtin, hgtti, hgtco, xilbn, 
	    xilbtc, xilhdr, xilfig, a, b;
    integer inhnoh;
};

#define cblock_1 (*(struct cblock_1_ *) &cblock_)

struct cominbot_1_ {
    integer inbothd;
};

#define cominbot_1 (*(struct cominbot_1_ *) &cominbot_)

struct comstart_1_ {
    real facmtr;
};

#define comstart_1 (*(struct comstart_1_ *) &comstart_)

struct comtitl_1_ {
    char instrq[120], titleq[120], compoq[120];
    logical headlog;
    integer inskip, ncskip, inhead;
};

#define comtitl_1 (*(struct comtitl_1_ *) &comtitl_)

struct spfacs_1_ {
    real grafac, acgfac, accfac, xspfac, xb4fac, clefac, emgfac, flagfac, 
	    dotfac, bacfac, agc1fac, gslfac, arpfac, rptfac;
    integer lrrptfac;
    real dbarfac, ddbarfac, dotsfac, upstmfac, rtshfac;
};

#define spfacs_1 (*(struct spfacs_1_ *) &spfacs_)

struct combmh_1_ {
    real bmhgt, clefend;
};

#define combmh_1 (*(struct combmh_1_ *) &combmh_)

struct comdyn_1_ {
    integer ndyn, idyndat[99], levdsav[24], ivowg[12];
    real hoh1[12], hoh2[12], hoh2h1[2];
    integer ntxtdyn, ivxiptxt[41];
    char txtdynq[5248];
    integer idynda2[99], levhssav[24], listcresc, listdecresc;
};

#define comdyn_1 (*(struct comdyn_1_ *) &comdyn_)

struct comkbdrests_1_ {
    integer levbotr[8], levtopr[8];
    logical kbdrests;
};

#define comkbdrests_1 (*(struct comkbdrests_1_ *) &comkbdrests_)

struct cominsttrans_1_ {
    integer iinsttrans[24], itranskey[24], itransamt[24], instno[24], 
	    ninsttrans;
    logical earlytranson, laterinsttrans;
};

#define cominsttrans_1 (*(struct cominsttrans_1_ *) &cominsttrans_)

struct comsize_1_ {
    integer isize[24];
};

#define comsize_1 (*(struct comsize_1_ *) &comsize_)

struct {
    integer nnodur;
    real wminnh[3999];
    integer nnpd[9600];
    real durb[9600];
    integer iddot, nptr[3999], ibarcnt, mbrest, ibarmbr, ibaroff;
    real udsp[3999], wheadpt, sqzb[9600];
} c1omnotes_;

#define c1omnotes_1 c1omnotes_

struct {
    integer narp;
    real tar[8];
    integer ivar1[8], ipar1[8], levar1[8], ncmar1[8];
    real xinsnow;
    logical lowdot;
} comarp_;

#define comarp_1 comarp_

struct {
    integer midisig;
} commidisig_;

#define commidisig_1 commidisig_

struct {
    integer ncc[24];
    real tcc[240]	/* was [24][10] */;
    integer ncmidcc[240]	/* was [24][10] */, maxdotmv[24], ndotmv[24];
    real updot[480]	/* was [24][20] */, rtdot[480]	/* was [24][20] */;
} comcc_;

#define comcc_1 comcc_

struct {
    integer listslur;
    logical upslur[48]	/* was [24][2] */;
    integer ndxslur;
    logical fontslur, wrotepsslurdefaults;
    real slurcurve;
} comslur_;

#define comslur_1 comslur_

union {
    struct {
	integer ihairuse, idhair[24];
    } _1;
    struct {
	integer idhairuse, idhair[24];
    } _2;
} comhair_;

#define comhair_1 (comhair_._1)
#define comhair_2 (comhair_._2)

struct {
    integer ivg[37], ipg[37], nolevg[74], itoff[148]	/* was [2][74] */;
    real aftshft;
    integer nng[37], ngstrt[37], ibarmbr, mbrest;
    real xb4mbr;
    integer noffseg, ngrace, nvolt, ivlit[83], iplit[83], nlit;
    real graspace[37];
    integer lenlit[83], multg[37];
    logical upg[37], slurg[37], slashg[37];
    integer naccg[74];
    char voltxtq[120], litq[10624];
} comgrace_;

#define comgrace_1 comgrace_

struct {
    integer is1n1, is2n1, irzbnd, isnx;
} comsln_;

#define comsln_1 comsln_

struct {
    real eonk, ewmxk;
} comeon_;

#define comeon_1 comeon_

struct {
    integer ipl2[4800]	/* was [24][200] */;
} comipl2_;

#define comipl2_1 comipl2_

struct {
    integer ibmtyp;
} combeam_;

#define combeam_1 combeam_

struct {
    integer macnum;
    logical mrecord, mplay;
    integer macuse, icchold;
    char lnholdq[128];
    logical endmac;
} commac_;

#define commac_1 commac_

struct {
    integer nvmx[24], ivmx[48]	/* was [24][2] */, ivx;
    real fbar;
    integer nacc[4800]	/* was [24][200] */;
} c1ommvl_;

#define c1ommvl_1 c1ommvl_

union {
    struct {
	integer nkeys, ibrkch[18], newkey[18];
	logical iskchb;
	integer idsig, isig1, mbrestsav;
	logical kchmid[18], ornrpt, shifton, barend;
	integer noinst;
	logical stickys;
    } _1;
    struct {
	integer nkeys, ibrkch[18], newkey[18];
	logical iskchb;
	integer idumm1, isig1, mbrestsav;
	logical kchmid[18], logdumm1, logdumm2, barend;
	integer noinst;
	logical logdumm3;
    } _2;
} comkeys_;

#define comkeys_1 (comkeys_._1)
#define comkeys_2 (comkeys_._2)

struct {
    logical isligfont;
} comligfont_;

#define comligfont_1 comligfont_

struct {
    logical is4bignv, aiset;
} comis4bignv_;

#define comis4bignv_1 comis4bignv_

struct {
    real shortfrac, codafrac;
    integer ishort, mbrsum, nmbr;
    logical nocodabn;
    real poefa[125];
} comshort_;

#define comshort_1 comshort_

struct {
    logical lastchar, rptnd1, sluron[48]	/* was [24][2] */, fbon, 
	    ornrpt, stickys;
    integer movbrk, movnmp, movdnp, movgap;
    real parmov, fintstf, gintstf;
    logical rptprev, equalize;
    char rptfq1[1], rptfq2[1];
} comget_;

#define comget_1 comget_

struct {
    integer mbrhgt;
    logical newmbrhgt, ignorenats;
} comignorenats_;

#define comignorenats_1 comignorenats_

struct {
    integer nnodur, lastlev, ndlev[48]	/* was [24][2] */;
    logical shifton, setis, notcrd;
    integer npreslur;
    logical was2[24];
    integer ninow;
    logical nobar1;
    integer nsystp[75], ipage;
    logical optlinebreakties, headerspecial;
} comnotes_;

#define comnotes_1 comnotes_

struct {
    integer ihdht;
    logical lower;
    char headrq[80], lowerq[80];
    integer ihdvrt;
} comhead_;

#define comhead_1 comhead_

struct {
    integer nfb[24];
    real t1fb[960]	/* was [24][40] */, t2fb[960]	/* was [24][40] */;
    char ulfbq[960]	/* was [24][40] */;
    integer ifb;
    real tautofb;
    logical autofbon;
    real t1autofb;
} comfb_;

#define comfb_1 comfb_

struct {
    logical bcspec;
} combc_;

#define combc_1 combc_

struct {
    integer nsperi[24], nspern[24];
    logical rename;
    integer iiorig[24];
} comnvi_;

#define comnvi_1 comnvi_

struct {
    integer ip1mac[20], il1mac[20], ip2mac[20], il2mac[20], ic1mac[20], ilmac,
	     iplmac;
} c1ommac_;

#define c1ommac_1 c1ommac_

struct {
    char clefq[24];
} comclefq_;

#define comclefq_1 comclefq_

struct {
    integer numarpshift, ivarpshift[20], iparpshift[20];
    real arpshift[20];
} comarpshift_;

#define comarpshift_1 comarpshift_

struct {
    integer ibarcnt;
} combibarcnt_;

#define combibarcnt_1 combibarcnt_

struct {
    logical inputmlyr;
} comlyr_;

#define comlyr_1 comlyr_

struct {
    real botamt, topamt;
    logical bottopgap;
} combottop_;

#define combottop_1 combottop_

struct {
    integer ivxudorn[63];
} comivxudorn_;

#define comivxudorn_1 comivxudorn_

struct {
    integer nbc, ibcdata[36];
} comcb_;

#define comcb_1 comcb_

struct {
    integer nasksys;
    real wasksys[800], elasksys[800];
} comas2_;

#define comas2_1 comas2_

struct {
    logical cwrferm[24];
} comcwrf_;

#define comcwrf_1 comcwrf_

struct {
    logical centrests;
} comclefrests_;

#define comclefrests_1 comclefrests_

struct {
    logical c8flag[24];
} comc8flag_;

#define comc8flag_1 comc8flag_

struct {
    real elskb, tnminb[3999];
} linecom_;

#define linecom_1 linecom_

/* Initialized data */

struct {
    char e_1[60];
    } comtrans_ = { "                                                       "
	    "     " };

struct {
    real e_1[4];
    integer fill_2[127];
    real e_3[30];
    integer fill_4[73];
    } compage_ = { 524.f, 740.f, 0.f, 0.f, {0}, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 
	    0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 
	    0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f, 0.f };

struct {
    real e_1[14];
    integer e_2;
    } cblock_ = { .5f, .25f, .4f, .4f, .2f, 12.f, 21.f, 12.f, 4.f, 1.6f, 5.f, 
	    5.7f, 1.071f, 2.714f, 16 };

struct {
    integer e_1;
    } cominbot_ = { 16 };

struct {
    real e_1;
    } comstart_ = { .55f };

struct {
    char e_1[360];
    logical e_2;
    integer fill_3[3];
    } comtitl_ = { "                                                        "
	    "                                                                "
	    "                                                                "
	    "                                                                "
	    "                                                                "
	    "                                                ", FALSE_ };

struct {
    real e_1[14];
    integer e_2;
    real e_3[5];
    } spfacs_ = { 1.3333f, .4f, .7f, .3f, .2f, 2.f, 1.f, .7f, .7f, .9f, .5f, 
	    9.f, 1.7f, 1.32f, 2, .47f, .83f, .17f, .5f, 1.f };

struct {
    real e_1[2];
    } combmh_ = { 1.1f, 2.3f };

struct {
    integer fill_1[124];
    integer e_2[12];
    real e_3[26];
    integer fill_4[1479];
    } comdyn_ = { {0}, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 2.2f, 1.7f, 1.2f, 
	    .7f, 1.3f, 1.3f, .4f, .8f, 1.2f, .8f, 1.2f, 1.6f, -2.7f, -2.2f, 
	    -1.7f, -1.2f, -2.3f, -2.1f, -1.f, -1.7f, -2.1f, -1.6f, -1.9f, 
	    -2.3f, -.3f, .3f };

struct {
    integer e_1[16];
    logical e_2;
    } comkbdrests_ = { 0, 0, 0, 2, 1, 4, 5, 4, 9, 7, 5, 5, 7, 5, 6, 6, FALSE_ 
	    };

struct {
    integer e_1[24];
    integer fill_2[24];
    integer e_3[24];
    integer fill_4[25];
    logical e_5[2];
    } cominsttrans_ = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, {0}, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
	    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, {0}, FALSE_, FALSE_ };

struct {
    integer e_1[24];
    } comsize_ = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	     0, 0, 0, 0 };

struct {
    real e_1;
    } comtol_ = { .001f };


/* Table of constant values */

static integer c__9 = 9;
static integer c__1 = 1;
static integer c__44 = 44;
static integer c__2 = 2;
static integer c__4 = 4;
static integer c__128 = 128;
static integer c__3 = 3;
static integer c__47 = 47;
static logical c_true = TRUE_;
static logical c_false = FALSE_;
static integer c__92 = 92;
static integer c__11 = 11;
static integer c__12 = 12;
static integer c__17 = 17;
static integer c__14 = 14;
static integer c__129 = 129;
static integer c__5 = 5;
static integer c__13 = 13;
static integer c__6 = 6;
static integer c__7 = 7;
static integer c__22 = 22;
static integer c__0 = 0;
static integer c__27 = 27;
static integer c__34 = 34;
static integer c__10 = 10;
static integer c__20 = 20;
static integer c__26 = 26;
static real c_b1019 = -2.f;
static real c_b1020 = 0.f;
static real c_b1065 = 1.f;
static integer c__8 = 8;
static integer c__16 = 16;
static integer c__23 = 23;
static integer c__39 = 39;
static integer c__96 = 96;
static integer c__21 = 21;
static integer c__19 = 19;
static integer c__24 = 24;
static integer c__28 = 28;
static integer c__18 = 18;
static real c_b1913 = 2.f;
static integer c__30 = 30;
static integer c__60 = 60;
static integer c__80 = 80;
static integer c__256 = 256;
static integer c__120 = 120;
static integer c__240 = 240;
static integer c__255 = 255;

/* Main program */ int MAIN__(void)
{
    /* Initialized data */

    static char date[9] = "7 Feb 23 ";
    static char version[5] = "3.00 ";
    static integer maxit = 200;
    static integer ncalls = 0;
    static logical isfirst = TRUE_;

    /* System generated locals */
    address a__1[2], a__2[4], a__3[3];
    integer i__1, i__2, i__3[2], i__4[4], i__5[3], i__6;
    real r__1;
    char ch__1[48], ch__2[64], ch__3[37], ch__4[55], ch__5[1], ch__6[56];
    olist o__1;
    cllist cl__1;
    inlist ioin__1;

    /* Builtin functions */
    /* Subroutine */ int s_copy(char *, char *, ftnlen, ftnlen);
    integer s_wsle(cilist *), do_lio(integer *, integer *, char *, ftnlen), 
	    e_wsle(void), s_rsfe(cilist *), do_fio(integer *, char *, ftnlen),
	     e_rsfe(void), s_cmp(char *, char *, ftnlen, ftnlen), i_indx(char 
	    *, char *, ftnlen, ftnlen);
    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
    integer f_inqu(inlist *), f_open(olist *), f_clos(cllist *);
    /* Subroutine */ int s_stop(char *, ftnlen);
    integer s_wsfe(cilist *), e_wsfe(void);

    /* Local variables */
    static real devnorm0;
    static logical optimize;
    extern /* Subroutine */ int poestats_(integer *, real *, real *, real *), 
	    writemidi_(char *, integer *, ftnlen);
    static integer ncomments, ip1, ilb, icm;
    static real poe[125];
    static integer ivt, ivx;
    static real poe0[125];
    extern /* Character */ VOID chax_(char *, ftnlen, integer *);
    static integer ljob, ipoe[125];
    extern /* Subroutine */ int pmxa_(char *, integer *, logical *, integer *,
	     integer *, logical *, ftnlen), pmxb_(logical *, real *, integer *
	    , logical *);
    static integer ivtt, isys, ljob4;
    extern /* Subroutine */ int stop1_(void);
    extern integer iargc_(void);
    static integer nbari[125], nbars[125], iinst, isysd, numit, isyst, isysu, 
	    nsyst, nbars0[125];
    static real poebar;
    extern /* Subroutine */ int getarg_(integer *, char *, ftnlen);
    static integer idnord, iplast;
    static logical fexist;
    static real devpmx;
    static integer iupord;
    extern integer lenstr_(char *, integer *, ftnlen);
    extern /* Subroutine */ int printl_(char *, ftnlen);
    static integer ndxpmx;
    static real poebar0;
    static char jobname[44], infileq[47], lnholdq[128];
    static real devnorm;
    static integer numargs, nstaves;
    extern /* Subroutine */ int sortpoe_(integer *, real *, integer *);

    /* Fortran I/O blocks */
    static cilist io___10 = { 0, 6, 0, 0, 0 };
    static cilist io___11 = { 0, 6, 0, 0, 0 };
    static cilist io___12 = { 0, 5, 0, "(a)", 0 };
    static cilist io___15 = { 0, 6, 0, 0, 0 };
    static cilist io___16 = { 0, 6, 0, 0, 0 };
    static cilist io___17 = { 0, 6, 0, 0, 0 };
    static cilist io___21 = { 0, 6, 0, 0, 0 };
    static cilist io___24 = { 0, 18, 1, "(a)", 0 };
    static cilist io___26 = { 0, 6, 0, 0, 0 };
    static cilist io___34 = { 0, 6, 0, 0, 0 };
    static cilist io___35 = { 0, 15, 0, 0, 0 };
    static cilist io___39 = { 0, 6, 0, 0, 0 };
    static cilist io___40 = { 0, 15, 0, 0, 0 };
    static cilist io___42 = { 0, 15, 0, 0, 0 };
    static cilist io___51 = { 0, 6, 0, 0, 0 };
    static cilist io___52 = { 0, 15, 0, 0, 0 };
    static cilist io___60 = { 0, 6, 0, 0, 0 };
    static cilist io___61 = { 0, 15, 0, 0, 0 };
    static cilist io___62 = { 0, 6, 0, "(5x,20i3)", 0 };
    static cilist io___63 = { 0, 15, 0, "(5x,20i3)", 0 };
    static cilist io___64 = { 0, 6, 0, 0, 0 };
    static cilist io___65 = { 0, 15, 0, 0, 0 };
    static cilist io___66 = { 0, 6, 0, 0, 0 };
    static cilist io___67 = { 0, 15, 0, 0, 0 };
    static cilist io___68 = { 0, 6, 0, 0, 0 };
    static cilist io___69 = { 0, 15, 0, 0, 0 };
    static cilist io___70 = { 0, 6, 0, "(5x,20i3)", 0 };
    static cilist io___71 = { 0, 15, 0, "(5x,20i3)", 0 };
    static cilist io___72 = { 0, 6, 0, "(5x,20i3)", 0 };
    static cilist io___73 = { 0, 15, 0, "(5x,20i3)", 0 };



/* This program, PMX, developed by Don Simons */
/* (dsimons@roadrunner.com), is a preprocessor for MusiXTeX. In concert with */
/* MusiXTeX and TeX, its purpose is to allow the user to create high-quality */
/* typeset musical scores by including a sequence of PMX commands in an ASCII */
/* input file. */

/* This program is free software: you can redistribute it and/or modify */
/* it under the terms of the GNU General Public License as published by */
/* the Free Software Foundation, either version 3 of the License, or */
/* (at your option) any later version. */

/* This program is distributed in the hope that it will be useful, */
/* but WITHOUT ANY WARRANTY; without even the implied warranty of */
/* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the */
/* GNU General Public License for more details. */

/* You should have received a copy of the GNU General Public License */
/* along with this program.  If not, see <http://www.gnu.org/licenses/>. */



/* To compile with gfortran: */
/*   1. Merge all files using copy *.for epmx[nnnn].for */
/*   2. Search and replace all character*65536 with character*131072 */
/*   3. Comment/uncomment getarg lines */
/*   4. gfortran -O pmx[nnnn].for -o pmxab.exe */

/* To do */
/*   Correct Rainer's email address in manual */
/*   Linesplit (\\) in h */
/*   Tt at start of a movement. */
/*   Toggle midi on or off; allow midi only. */
/*   Page number printed on 1st page even if 1 system. */
/*   Still need inserted space for chordal accidentals */
/*   Voicewise transposition. */
/*   better segno */
/*   coda */
/*   duevolte */
/*   Fix xtup bracket direction in 2-line staves?? (maybe leave as is) */
/*   Sticky ornaments with shifts. */
/*   Deal with Werner's vertical spacing thing associated with title. */
/*   Multiple ties in midi */
/*   Werner's missing c in MIDI due to start/stop ties on same note. */
/*   Beams with single 64ths */
/*   128ths and/or dotted 64ths */
/*   Close out MIDI with integral # of beats? */
/*   Increase ast dimensions or redo logic. */
/*   Does slur direction get set for user-defined single-note stem dir'ns? */
/*   Transpose by sections. */
/*   Optimization loop over sections only */
/*   Command-line option to read nbarss in. Write out nbarss when optimizing. */
/*     (or just read from .plg?) */
/*   Beams over bar lines. */
/*   2-digit figures */
/*   A real coule (slanted line between notes in a chord) */
/*   Dotted slurs for grace notes. */
/*   Undotted chord notes with dotted main note. */
/*   Forced line break without line number */
/*   Fix dot moving when 2nds in chord get flipped */
/*   To do: increase length on notexq in dodyn */


/* 3.00 */
/*  Provides an option to remove the limit of 9 on forced */
/*  beams. A side benefit of selecting the option is that all */
/*  beams are vectorized and 2-digit figured bass figures are allowed. */
/* 2.98 */
/*  Fix beaming in 6/2 time by setting mapfb(5) and (6) = 0 in make1bar(...) */
/* 2.97 */
/*   Fix problem with beaming after new movement command */
/* 2.96 and 2.95 */
/*   replace and '\','/'. and '"' with chax(); */
/*   eliminate do loops with shared last line */
/*   delete superfluous comments in source */
/* 2.94 */
/*   Allow moving dots on main and chord note in 2-note termolos */
/*   Add definitions of \hbp and \hbpp to pmx.tex */
/* 2.91 */
/*   Tweak: insert \stdstemfalse before every user-shortened or lengthened stem. */
/*     This cancels defaul extensions to middle line and also (with 'L') allows */
/*     stems that are longer than 4.66 but still don't reach middle line. */
/*   Allow alteration of number height in multibar rest, option n. */
/*   Fix bug introduced in 2.89 so that the "o" in "mo800" is now OK. */
/* 2.90 */
/*   Many tweaks to allow gaps at end or middle of a system using */
/*     L[n]S[x] and LC[y]. New pmx.tex. */
/* 2.88 */
/*   Comment out print*,"Changed pathname to..." since it was going */
/*     iteration when optimizing linebreaks with the undocumented option Ao. */
/*   Add nv back in as argument for getmidi, so loop transferring data */
/*     from midivel to midvelc can be executed. This corrects bug and */
/*     allows per-instrument change in midi velocities at the start */
/*     of any block */
/*   Add subroutine inst2chan to transfer midi data as noted above. Works with */
/*     Iv but buggy when used with IT and Ib */
/* 2.87 */
/*   Allow changes to and from octave treble clef. Instrument with it */
/*     must only have one staff. */
/*   Some fixes for beam multiplicity changes at staff jumps. Must still */
/*     use inline for mult. increase at downward staff jump. See sjb.pmx. */
/* 2.84 */
/*   Bug fix: dots in chordal seconds */
/*   Bug fix: Initialize ihornb for non-beamed, down xtup */
/*   Bug fix: When using "AT" with 2-note x3c rD. */
/* 2.83 */
/*   Fix problems when changing to or from octave treble clef. */
/*   Fix beaming (or not) and number location for xtups with */
/*     multiple rests. Still some problems with number height but */
/*     can be band-aided with number height tweak option. */
/*   Tweak error messages for options on "R" command. */
/*   Allow forced beam height and slope tweaks with 2-note tremolos */
/*   Allow chordal note with 2-note tremolos, adding dots as needed. */
/*   Fix call to ncmid in beamstrt when setting start height for beam of */
/*     2-note trem, by changing arg from ivx to iv */
/* 2.82 */
/*   bugfix: beams with rests, not confused with xtups. */
/*   x option after slur index to allow slurs to go from one voice to another. */
/*   x option also for ties */
/* 2.81 */
/*   Allow string of rests to end xtup */
/*   in chordal half-note 2-note tremolo, make chord notes open. */
/* 2.80 */
/*   Add 2-note tremolos */
/* 2.78 */
/*   Expand bufq to 131072 bytes */
/*   Expand maxblks tp 9600 */
/*   Allow up to 75 pages */
/*   Index postscript hairpins from 1 up instead of by voice #. */
/*   Add option 'o' to forced beam for open notehead (\hb); set ipl(3) */
/*   Add option T[n], n=1,2,3 for single stem tremolo */
/* 2.77 */
/*   Enable AV+/-x+/-y to add vskip bigh before or after \eject */
/* 2.76 */
/* 2.75 */
/*   Bugfix: unbeamed xtups with dots: in beamn1 and beamid allow dotted 16th, and */
/*     2 or 3 flags on shortened note. */
/* 2.74 */
/*   Bugfix: allow "0" as argument of @ command on lyrics string. */
/*   Check for and allow "\ in centered page headings with P command. */
/*   Check for and allow "\ in text dynamics with D command. */
/*   For lyrics string starting in xtuplet, insert check for inputting musixlyr. */
/*   For staff-crossing beamed xtuplet chords, if 2nd segment of a joined beam */
/*     starts with a blank rest, put '\sk' into the TeX. */
/*     To enable high-to-both beamed etup staff-crossing chord, for blank */
/*     rest at start of forced beam, shift \sk's from before to after \ib..; */
/*     so \ib is at start and note in upper voice has a beam to connect to. */
/*   Expand range of vertical xtup number shift, now stored in mult(16-22) */
/*   Check for and allow \" within lyrics strings, for umlauts. */
/* 2.73 (160121) */
/*   Dirk's "..." command, to convert "text" into \pmxlyr{text}\ and insert as */
/*     inline TeX. Replace all '~' inside "..." and not preceded with '\', by */
/*     '\lk '. Right after 2nd ", replace @[a,b][+,-]n with \at{[a,b][+,-]n}\ */
/*     Include definitions of \ly and \at in pmx.tex (2 Feb 16). After first ", */
/*     add (as type 2 string) '\\input musixlyr \' */
/*   After inputting pathname, change any '\' to '/', for Linux compatibility. */
/* 2.72 (160110) */
/*   Really finalize \mbrest...go back to 3 args to deal with clef changes. */
/*   Fine tune centered whole bar rests to deal with clef changes */
/*   Fix bug in wsclef when >1 staff per instrument, since \setclef */
/*     needs to know instrument and specify clefs on all staves for that */
/*     instrument. Ones that were not changed by user will not be printed, */
/*     and will be kept the same as before. */
/*   Fix bug with arpegii from one voice to another in same staff. */
/* 2.71 (151226) */
/*   Finalize mbrest mods */
/* 2.705 */
/*   Fix error message */
/* 2.704 (140614) */
/*   Octave treble clef */
/*   Make horizontal ornament shift (ornhshft) floating */
/* 2.703 (140323) */
/*   Option v[-]n at end of any figure will alter figdrop for rest of system */
/* 2.702 */
/*   Stem slurs. Only for ps, assume no other pos'n adjustments. Option "v" */
/* 2.701 */
/*   oC = coda (\code{10}) */
/*     Move iornq(29) (blank barline) to ipl(0) (changes in pmxb, getnote) */
/*   oG = new seqno */
/*   To do: fix grace note spacing problem (partially done) */
/* 2.622 */
/*   Redefine midtc(..) and miditran(..); clean up all transpositions/key changes */
/*   Kn[+/-...] \ignorenats at signature changes */
/*   Fix tie checks in doslur() and dopsslur() to subtract iTransAmt from nolevs */
/*     before checking and setting pitch levels levson() and levsoff() */
/*   Define midisig separately from isig. Put in common commidisig. */
/*     Use for explicit midi signature and for accid corrections to midi piches */
/*     in addmidi. */
/* 2.621 */
/*   Make keyboard rest option work in xtuplets. Created subroutine */
/*     chkkbdrests, modified make2bar to include calls to chkkbdrests as rqd. */
/* 2.620 */
/*   Allow user-defined rest height tweaks at start of beam. */
/* 2.619 */
/*   At movement break, change \nbinstruments in \newmovement macro; add */
/*     3rd arg to \newmovement in pmx.tex; modify pmxb.for and getnote.for */
/*     to remove call to newnoi and change call to \newmovement */
/* 2.618 */
/*   Add option Ac[l,4] to set vert and horiz size and offsets to properly */
/*     center page for letter or a4 paper. */
/* 2.617 */
/*   In g1etnote, change if-check for note to use index(...) instead */
/*     of ichar(charq) since it was messing up gfortran optimizer */
/*   After pmxa, search for and remove penultimate line <blank><blank>/ */
/*     because it was screwing up linux-compiled versions */
/*   Bugfix: Increase dimension of kicrd from 7 to 10 in crdaccs(...) */
/* 2.616 (111110) */
/*   Allow hairpins to span multiple notes groups (gulps). */
/* 2.615+ (110810) */
/*   Fix midi when some instruments are transposed, by subtracting */
/*     iTransAmt(instno(iv)) from pitch values sent to via addmidi in */
/*     make2bar.for (for main notes) and docrd (for chord notes) */
/* 2.615 (110725) */
/*   Fig bug with size-setting (in topfile) when instrument has >1 staves */
/* 2.615 (110724) */
/*   Make AS[0|-|s|t]... really set sizes */
/* 2.614 */
/*   Mod notex.for to fix Terry's bug with raised dotted rests (caused */
/*     by double-hboxing). */
/* 2.613 */
/*   Bugfix: In pmxa, change "do while" limit to keep from overwriting instno. */
/* 2.612 */
/*   Enhance AS to allow s or t for smallsize or tinysize */
/* 2.611 */
/*   Error trap for "D" before any notes in a block. */
/* 2.610 */
/*   Instrument-wise key changes and transposition (incomplete) */
/* 2.603 */
/*   101211 In getpmxmod.for, decreased nline by 2 to fix locating errors */
/*     following reading in an include file. */
/*   101121 Added some error messages in g1etset.for setup data */
/* 2.602 */
/*   Correct slur indexing in linebreakslurs. */
/*   Account for comment lines in line count for error messages */
/* 2.601 */
/*   Bug fix: allow 24 slurs with graces */
/* 2.60 Changes made make it really big */
/*   increase mv (size of midi) ? Note: MIDI can't have >16 voices w/o */
/*     major reprogramming, and 16 may also be a problem (icmm) */
/*   nm=24 (voices) done */
/*   24 slurs done */
/*   24 simultaneous beams (Replace index 24 by 0, so get 0-23) */
/*   bufq*131072 (gfortran only) */
/*   getarg syntax (gfortran only) */
/* 2.523+ */
/*   Fix voice numbering for normal dynamics and text dynamics */
/* 2.523 */
/*   Version of bigpmx first posted to Hiroaki's web site. */
/* 2.522 */
/*   5/26/10 Replace ipl bits 0-7 with ipl2, add new common for it. */
/*   With 2.521+ as starting version, incorporate bigpmx mods to allow 24 voices. */
/*   5/13/10 Fix log2 function */
/*   5/15/10 Fix bitwise storage for dynamics, fix segnoo string length. */
/* 2.521+ */
/*   091025 Enable dotting 2nd part of linebreak slur or tie. */
/*   To adjust barno height due to linebreak slur, use \bnrs instead of */
/*     explicitly redefining \raisebarno (pmxb) */
/* 2.521 */
/*   Bugfix */
/* 2.520 */
/*   090519 Enable ligfonts (special figured bass characters) */
/* 2.519 */
/*   Fix another bug which kept \sk from being output so misaligned some notes. */
/* 2.518 */
/*   Fix bugs: referencing fig data, char declaration for member of */
/*      common/comfig/ */
/* 2.517 */
/*   Allow figures in voice 1 + any one other. */
/* 2.516 */
/*   Allow figures in voice #2 */
/* 2.515+ to do: Change manual and activate rule against clef change in voice #2. */
/* 2.515 */
/*   071222 Changes in getnote to allow auto forced beams to start anywhere. */
/*   071206 In make2bar, shift fermataup7 to left over centered pause. */
/*   070901 In doslur, check for nolev <=2 in case slur ends on rest in 2-line */
/*       staff (it was screwing up vertical justification). */
/*   n34 for tweaks to midi durations of quarter note septuplets. */
/*   To do: In ref250.tex, the tables where 's,t,)' is explained, the line */
/*       [+,- i]   ... Vertical adjustment of the start of second segment */
/*     should it be replaced by */
/*       [s +,- i]   ... Vertical adjustment of the start of second segment */
/* 2.514 */
/*   Changes in make2bar to get horizontal spacing right when normal grace */
/*     follows after grace */
/*   Changes in dograce to get octaves right for any material entered inside */
/*     \gaft, which shields transpose register changes from the outside world. */
/* 2.513 */
/*   In make1bar, near end, for forced beams starting with a rest, copy hgt and */
/*     slope tweaks to ALL notes after first, not just the second one, so if */
/*     there's more than one rest at start the tweaks are still observed. */
/*   In beamid and beamend, add stand-alone triply-flagged notes for xtups. */
/* 2.512 */
/*   Near end of pmxb, fix error trap to allow redundant 'RD' */
/*   Enable multiplicity down-up '][' within xtup. */
/* 2.511 */
/*   Introduce eskz2 for xtup #'s and bracket lengths, to remove bug caused by */
/*     adjusteskz as in bar 7 of barsant. */
/* 2.510a */
/*   Test: remove restriction on tempo changes in MIDI macros */
/*     Send to CM for beta testing. */
/* 2.509+ */
/*   To do: Correct manual on AS. "-" is for smaller staves. */
/* 2.510 */
/*   Forgot to declare litq, voltxtq as character in subroutine getgrace */
/* 2.509 */
/*   Corrected small bug in arpeggio shifting (ivx <= iv in call putarp) */
/* 2.508 */
/*   Allow graces in xtups. New subroutine getgrace. */
/* 2.507 */
/*   To do: Raise/lower figures. */
/*   To do: Add 24, 29 to list of musicsizes in manual */
/*   New sub adjusteskz to account for ask's when computing lengths of */
/*     brackets for unbeamed xtups, slopes and horizontal posn's of number */
/*   Bug fix: in beamn1, beamid, and beamend, allow unbeamed xtups w/ 2 flags */
/*   Add look-left option for keyboard rests, "L" in rest command, set iornq(30) */
/* 2.506 */
/*   Fix bug with AK, when simultaneous rests have same duration, use defaults. */
/* 2.505 */
/*   Keyboard rests AK */
/* 2.504 */
/*   Space after normal grace: option X[n] */
/*   Fixed og when nv .ne. noinst, by using sepsymq instead of '&' */
/*   (To do) length of xtup bracket when there is added non-collision space. */
/*   Trap musicsize if .ne. 16,20,24,29. */
/* 2.503 */
/*   Enable arpeggio left shift with ?-x */
/*   To do: In manual, arpeggio over 2 staves. */
/*   Allow musicsize of 24 and 29. Had to define meter font size explicitly, */
/*     also change font size for text dynamics, but not much else so far. */
/*   Bugfix in beamstrt, introduced in 2415, ip was changed before putxtn */
/*     was called, causing error in printing replacement number. */
/* 2.502 */
/*   Incorporate Dirk Laurie's patch to use { , } , for ties. */
/*   Figure height adjustment: append +[n] */
/*   Change ec font stuff in pmx.tex per Olivier Vogel's comment (CM email?) */
/* 2.501 */
/*   Readjust horizontal offset back to .8 in LineBreakTies */
/*   Fix zero-subscript (iudorn) in putorn */
/* 2.50 */
/*   Increase number of text-dynamics (dimension of txtdynq) per block */
/*     from 12 to 41. */
/*   Slur option n to override altered default curvature. */
/*   Allow default ps slur curvature tweaks with Ap+/-c */
/* 2.416 */
/*   Increase length of textdynq from 24 to 128 */
/*   (Todo) Add comment in manual about blank lines at end. */
/*   Configuration file: Define subroutine getpmxmod, check path in environment */
/*     variable pmxmoddir, check existence, read lines into bufq after setup. */
/*   Increase dimension on idynn in dodyn from 4 to 10 for max number */
/*     of marks in a bar */
/*   Increase allowable # of lines from 2000 to 4000. */
/*   (To do) Replace definition of \liftpausc per Olivier. */
/*   (To do) Fix extraneous error message if RD is placed at very end. */
/* 2.415 */
/*   Fix "AT" option: replace putxtn,topfile,beamstrt,beamid to use \xnumt */
/*     instead of redefining \xnum. Change font used to \smallfont (as for */
/*     normal xtups, */
/*   Allow slur to start on rest. */
/* 2.414 */
/*   Correct bug in crdacc when adding accidental to boundary causes number of */
/*     segments to decrease */
/*   Special rule for 3-accidental chords: If no 2nds, place them in order */
/*     top, bottom, middle. */
/* 2.413 */
/*   Correct bugs in chordal accidentals, related to left-shifted noteheads */
/*     (a) Special problems with downstem when main note needs shifting */
/*     (b) Assign 0 rank to boundary segs due to left-shifted noteheads */
/* 2.412 */
/*   Change default horiz shift of start of seg 2 of linebreak slurs: */
/*     -.7 for slurs, -1.2 for ties, */
/*   Use height of start of seg 1 slur itself for end of 1 and start of 2. */
/* 2.411 */
/*   "Apl" activates special treatment of linebreak slur/tie's; breaks all in 2. */
/*   "s" option in start of slur/tie as precursor to vert/horiz tweaks for end */
/*      of seg 1. of linebreak slur/tie, 2nd "s" for start of seg2. */
/*   With "Apl", curvature adjustments on starting slur command apply to seg 1, */
/*      those on ending command to seg 2. */
/* 2.410 */
/*   "AT" to allow Col. S.'s tuplet option. Simply input tuplet.tex and redefine */
/*      \xnum, \unbkt, \ovbkt. */
/*   "s" option in main xtup input after "x": slope tweak for bracket. mult(4) is */
/*      flag, mult(5-9) is tweak value+16 */
/* 2.409 */
/*   Bugfix in docrd for MIDI: Use original pitch in case main/chord were */
/*     switched due to 2nds. */
/*   Remove "o" from error message for "A" command. */
/*   New syntax: optional instrument number separator ":" in movement */
/*     break command to precede a 2-digit instrument. */
/*   Conditional output formats for \setname at movement break to allow */
/*     instrument numbers >9. */
/*   Bugfix in coding to raise barno due to slur over line break (pmxb) */
/*   Move date/version data statement in pmxab to a better place. */
/* 2.408 */
/*   Allow pnotes{x} when x>9.995 (mod is only to format stmt in make2bar). */
/*   Bug fix in \liftPAusep in notex.for and in pmx.tex */
/*   Character variables for version and date */
/*   For up-stem single graces slurred to down-stem, shift slur start left by */
/*     0.8 so slur doesn't get too short. */
/*   Initialize and slide mult, same as other full-program variables in /all/. */
/* 2.407 */
/*   Allow AN[n]"[partname]" to be parsed by scor2prt as filename for part n, */
/* 2.406 */
/*   Alter PMX: put \dnstrut into \znotes in \starteq (for system spacing */
/*     equalization). */
/*   Put dimensions of double sharps and flats in crdacc (for chords). */
/*   Bugfix: Use sepsymq in LineBreakTies(..) instead of '&' */
/*   Use only first 4 bits of mult for multiplicity+8, so rest can be used */
/*     for other stuff. */
/*   Move stemlength stuff in nacc(27-30) to mult(27-30) to remove conflict. */
/* 2.405: Not published but saved for safety. */
/*   Option Aph to write \special{header=psslurs.pro} top of each page, so */
/*     dviselec will work OK. */
/* 2.404 */
/*   Allow slur to end on rest, but not start on a rest.  Efaults height */
/*     of ending is default height of start (before any automatic or user- */
/*     defined djustments). User may adjust height as normal from default. */
/* 2.403 */
/*   Bugfix: turn off repeated beaming patterns.at end of non-last voice. */
/* 2.402 */
/*   Automatic repeated forced beams.  Start with "[:"  End with next explicit */
/*     forced beam or end of input block. */
/*   Increase # of forced beams per line of music per input block from 20 to 40 */
/* 2.401 */
/*   Optional K-Postscript Linebreak Ties, Apl. New subroutine LineBreakTies. */
/*     Makes 1st part normal shape, and starts 2nd part a little further left. */
/*   Enable arpeggios in xtuplets.  Had to make time itar(narp) a real. */
/* 2.40 */
/*   Set up WrotePsslurDefaults (logical) so only write defaults on 1st Ap. */
/*   Fix non-ps-slur input to \midslur (third signed integer). Do not reverse */
/*     sign for down-slurs. */
/* 2.359 */
/*   Add error exit subroutine stop1 to make exit status g77-compatible.. */
/*   Absolute octave on xtup chord note was 2 octave too high, fixed in getnote */
/*   Fermata on vertically shifted rest: special trap in putorn() to set height. */
/*   Correct multiple grace note spacing for small staves (in dograce, */
/*        define wheadpt1 depending on staff size) */
/* 2.358 */
/*   Allow curvature corrections at start of postscript slur, in dopsslur() */
/*   Local slur options p[+|-][s|t] for [nos|s]luradjust,[not|t]ieadjust */
/*   Options for [Nos|S]luradjust,[Not|T]ieadjust,[noh|h]alfties: Ap[+|-][s|t|h] */
/*   Make t[ID] act like s[ID]t, most mods in spsslur(). */
/*   Add spsslur() to read in data for ps slurs, call from getnote. */
/*   In beamstrt, save args for SetupB in common comipb to save them for */
/*      2nd call when xtup starts with rest */
/*   Add spacing for ornament ")" as if it were accidental, in make2bar(). */
/*   Horiz shift start and end of ps ties, dep. on stem dir'n, in dopsslur() */
/*   Horiz. shift start of ps grace slur, 2 places in dograce(). */
/*   Horiz shift end of grace slur in endslur() */
/*   Make st slurs into postscript ties.  Separate subroutine dopsslur(), */
/*   Non-beamed xtup: "a" in 1st note or rest, before "x" (sets drawbm=.false.) */
/*   Allow two D"x" on same note. Introduced jtxtdyn1 in dodyn. */
/* 2.357a */
/*   Fix missing "end" in backfill.com, too-long lines in g1etnote, getnote */
/* 2.357 */
/*   Increase dimension for # of lit TeX strings from 52 to 83. */
/*   Allow blank rest in middle of xtuplet. Only mods in g*etnote(). */
/* 2.356 */
/*   Increased some dimensions from 30 to 40 to allow up to 40 pages. */
/*   In unbeamed xtups, "n" did not suppress bracket.  Fixed in beamstrt(). */
/*   Fix parsing of "f,h,H,HH" in sslur. */
/*   Fix bug with cdot, note-level for slur termination (in getnote) */
/* 2.355 */
/*   Midi transposition:  IT[+|-][n1][+|-][n2]...[+|-][n(noinst)], */
/*      n=# of half-steps.  Restrict to mult. of 12 now, to avoid key-sig issues */
/*   Make midi recognize ps ties in doslur. */
/*   Correct ttieforsl so that it eats 2nd argument properly, using \zcharnote */
/*      to get octave right. */
/* 2.354 */
/*   With postscript slurs, make t-slurs real ties by inserting replacement */
/*     macros \tieforisu, etc, defined in pmx.tex */
/*   Check for open cresc or decresc at end of input block, using list[de]cresc */
/*   Hairpin syntax conditional on postscript slurs. Backup to fill in start */
/*     level, using new backfill(...).  Separate height tweaks for */
/*     start and finish. */
/* 2.353 */
/*   K-0+n to transpose by half step (rather than just change key) */
/*   Allow "rm[n]" when nv>1.  Require it in all parts. Just write a stack of */
/*     \mbrest's */
/*   Enable "Rz"; define \setzalaligne in pmx.tex. Special treatment at end */
/*     of input block before movement break, and at start of block after */
/*     movement break, using \newmovement rather than \setzalaligne, since */
/*     former already redefines \stoppiece. In second case, set rptfg2='z'. */
/*   Make clefq(nm) common between pmxb and getnote; change references in */
/*     getnote at 'M' to array elements, setting all new clefs as you go. */
/* 2.352 */
/*   Remove \parskip redefinition from pmx.tex; write it into TeX file when */
/*     "Ae" is invoked. */
/*   Ap to activate postscript slurs. Add macro \psforts to pmx.tex to redefine */
/*     \tslur in case \midslur was used.  Allow slur inputs 'f','h','H','HH', */
/*     translate them thru mapping to (1,4,5,6) as \midslur params, then let */
/*     \psforts translate them back to ps slur macors. */
/* 2.351 */
/*   Number slurs from 0 up instead of 11 down, anticipating postscript slurs. */
/*   Write "\eightrm" instead of "\cmr8" for \figfont with small baseline size. */
/*   Increase length of basenameq to 44 characters everywhere. */
/*   Increase dimension of mcpitch (midi-chord-pitch) to 20. */
/*   Set default systems per page to 1 if nv>7 */
/*   In pmxb, move place where isystpg is reset to 0, so that \eject gets */
/*     written when there is just one system per page. */
/* 2.35 */
/*   Cautionary accidentals with 'c' anywhere in note symbol. */
/*   NEW pmx.tex with \resetsize to set size to normal or small depending on */
/*     current \internote.  Used with new coding in dograce() to get right */
/*     new size in case user has \setsize'ed some lines to \smallvalue. For */
/*     \smallvalue-sized staves, redefine \tinynotesize to give 11-pt font. */
/*     Affects pmx.tex. */
/*   Continuation figure with fractional length. May now mix with other figures. */
/*     If another figure follow Cont-fig, separate with colon. */
/* 2.342 */
/*   Bugfix in getnote to recognize relative octave shift in grace at start of */
/*     input block. */
/*   In make2bar, initialize islhgt=0 earlier than before (possible solution */
/*     to Suse g77 compile problem that I could not reproduce).. */
/*   Bugfix in beamstrt & beamn1 for r2x6 c4D d d d */
/* 2.341 */
/*   Syntax check: Forced page break page number must be > than previous. */
/*   Bugfix: Define ivx when "sliding down" breath/caesure data in pmxb. */
/* 2.34 */
/*   New pmx.tex with redefined liftpausc */
/*   Bug fix with dotted, non-beamed xtups. */
/* 2.332 */
/*   Fix bugs in horizonal shifts, spacing, for accid's, graces, noteheads. */
/*   Allow arbitrary pos. input to W in g1etnote and getnote. */
/* 2.331 */
/*   Bug-fix in dodyn(..): typo on length of arg of txtdyn */
/* 2.33 */
/*   Caesura (oc), breath (ob).  Set iornq(28), store rest of data in ibcdata() */
/* 2.321 */
/*   Rescale accidental shifts. Still use 7 bits but now map (0,127) */
/*      onto (-1.,5.35) */
/*   Fix ihornb bug in dodyn, seen with dynamics on lower-voice non-beamed xtups */
/* 2.32 (Noticed after posting) */
/*   Prohibit "/" as figure. */
/* 2.32 (Posted) */
/*   Tidied up accidentals in chords, do spacing. */
/*   Still to do: */
/*       check for "(" on chord notes in spacing algo */
/*       small accids */
/*       double accids */
/*       autoshift slurs */
/* 2.310 */
/*   Extra call to precrd ahead of spacing chk, and single-note crd/acc */
/*      shifts seem OK, but not multiple.  crd/acc shifts not recorded 1st time. */
/* 2.309 */
/*   Alternate algo for accid shifts in chords. */
/* 2.308 */
/*   Auto horiz. notehead shifting added to precrd. */
/* 2.307 */
/*   Auto shifting of multiple accidentals in chords. */
/*   "Ao" in main chord note to keep accidentals in order. Set nacc(28). */
/*   If there are any manual main or chord note shifts, then */
/*      If any manual shift is preceded by "A" then */
/*         1. Auto-shifting proceeds */
/*         2. "A"-shifts add to autoshifts */
/*         3. non-"A" shifts are ignored! */
/*      Else (>0 man shifts, none has "A") */
/*         No auto-ordering, No autoshifts, */
/*      End if */
/*   End if */
/* 2.306 */
/*   Initialize legacy note level to middle C in case user forgets to set */
/*     octave. */
/*   Shift xtup note? */
/*   Shift in elemskips rather than noteheads? */
/* 2.305 */
/*   Stop pmxb from multiple endvolta's at start of new page. */
/* 2.304 */
/*   "Sx" in a note means shorten stemlength by x \internotes.  "Sx:" turn on */
/*       for multiple notes in the voice, "S:" last shortened note. */
/* 2.303 */
/*   vshrink stuff all OK? Description is in pmxb. */
/* 2.302 */
/*   Toggle vshrink with "Av". vshrink normally kicks in when \interstaff */
/*     hits 20. This still needs work. */
/*   Add " /" to last line if last char is not % or /. */
/* 2.301 */
/*   Check in beamn1 for single note before multiplicity down-up. */
/*   allow '.PMX' as well as '.pmx' */
/* 2.299 */
/*   Correct typo in pmxb involving PMXbarnotrue. */
/*   Replacement printed number for xtup: Unsigned integer after 'n' after 'x' */
/*   Minor upgrade parsing xtuplet options 'x...' */
/*   Correct dimension of nxtinbm in make2bar. */
/* 2.298 */
/*   Account for doubled xtup notes in subroutine getx (user-defined spaces), */
/*     by adding ndoub as an argument.. */
/* 2.297 */
/*   Created and solved compiler problem.  Put drawbm(NM) in its own common. */
/*   Add new def'ns [\a|PA]usc, \lift[pa|PA]usc to pmx.tex, use them in make2bar */
/*     when \centerbar is used. */
/*   Modify \mbrest & \CenterBar in pmx.tex to use \volta@endcor etc.  Have PMX */
/*     use right 2nd and 3rd args for \mbrest when key, meter, or clef changes. */
/* 2.296 */
/*   Correct printed numbers for forced beams with multiple xtups. For each beam */
/*     make list in setupb by voice of eloff (h-offset) and mtupv (printed #) */
/*   Increase lengths of jobname and infileq by 20 characters */
/*   Enable whole notes and breves as 1st or last note of xtup in beamn1 and */
/*     beamend, and wholes in beamid. */
/* 2.295 */
/*   Midi balance Ib[n1]:[n2]:...[nn] */
/*   Single-slope beam groups [...]-[...] */
/*   Trap "i" unless after accidental (main notes, xtups, chord notes) */
/* 2.294 */
/*   Unequal xtups with "D" to double a note in an xtup. */
/*   As above, "F" will (a) increase multiplicity by 1 for marked note and next */
/*     one and (b) add a dot to the first one. */
/*   Fix bug with e.g. c84 [ .d e.f ] by checking whether forced beam is on */
/*     when "." is encountered, then correcting beam start time.(end of getnote) */
/*   MIDI velocity (volume) set: Iv[n1]:[n2]:[n3]... */
/* 2.293 */
/*   Check for single notes spanning bar lines. */
/*   Correct various bugs with staff-jumping beams. (1) for 2nd segment, vxtup */
/*     must be set in make2bar since beamstrt is not called, fixing problem with */
/*     dot at end. (2) add ivjb2 to flag which voice has 2nd segment and fix */
/*     problem when >2 staves. */
/*   Add nodur to args of dodyn, so can check if stemless and avoid height tweak */
/*   Correct bug in getdyn setting flag in idynda2(0) for manual horiz. tweak */
/* 2.292a */
/*   Undo syntax check for Type 2 or 3 TeX string starting in column 1. */
/*     Meanwhile, Werner's problem with a mid-line Type 3 string has gone away?! */
/* 2.292 */
/*   Allow comments in xtuplets */
/*   Enable multiple octave jumps in grace notes. */
/*   Allow dynamics in xtuplets. */
/*   Fix bug in getdyn searching for end of text string (correct length of lineq */
/*     to 128) */
/*   Fix bug in dodyn, must ignore horiz. interaction tweak for */
/*     user-text (idno = 0) */
/*   Syntax check for Type 2 or 3 TeX string starting in column 1 */
/*     (NOTE: later undone!) */
/*   Syntax check for page number > npages at forced line break. */
/* 2.291 */
/*   Fix error in AS command (accid spacing for small systems), making only */
/*     one spec per staff, nv total. */
/*   Stop using MIDI channel 10 */
/* 2.29 */
/*   Fix error in console output format for # of bytes used in MIDI file. */
/*   Fix bug in dograce so no space is added between grace and main note when */
/*       there is a MIDI-only accidental. */
/*   Fix bug so oes?+4 works.  It was too ugly to explain. */
/*     ...Different ways of storing accidental specs on input and output. */
/*   No longer zap \writezbarno in special situations. */
/*   Fix bug in dyntxt level on rest */
/*   Line spacing equalization.  Add macros \starteq, \endeq, \spread, etc. */
/*     Activate with Ae.  (Maybe later could input alternate values for */
/*     \upamt, \dnamt, \parskip).  Put \starteq on 1st note in voice 1 */
/*     in the page, and \endeq on 1st note of next-to-last line in page. */
/* 2.28 */
/*   Flip direction of forced beam "[f..." */
/*   Fix beam numbering for staff jumping beams. Uses irest(23,24,29,30) */
/*   Fix bug in sliding ip's for txtdyn's */
/*   In dyn's allow vert. offsets +/-64, horiz +/-25.6 (store in idnyda2(1-99) */
/* 2.27 */
/*   Comment out lines in dodyn checking number of dynamic marks found.  Voice */
/*     order may not be monotonic if two lines on a staff. */
/*   Literal dynamic: D"[text]" */
/* 2.26 */
/*   Allow hairpin start-stop on same note by disabling auto-tweaks in dodyn, */
/*     increasing dimension of idynn to 4 to allow 4 symbols on same note. */
/*   Increase voltxtq length from 10 to 20. */
/*   AS[-/0][-/0]...  to inform PMX that "-" voices are small, and rough */
/*      accounting for ast's is done by defining effective headwidth */
/*      whead1 in makebar2 to be 0.8*whead. */
/* 2.25 */
/*   Fix logic bug with sepsym's when # of instruments changes. */
/*   Slight increases in default offsets for hairpin starts after "p" */
/* 2.24 */
/*   Hairpins D< or D> as toggle. */
/*   Many automatic position tweaks for letter-group dynamics and hairpins. */
/* 2.23 */
/*   Continued rhythmic shortcuts: space followed by "." or "," */
/* 2.22 */
/*   In call to doslur, change tno(...) to tnote(...).  This was only */
/*     used when checking to slurs per stem directions, and should have been */
/*     the note duration all along. */
/*   MIDI-only accidental, bit 17 in nacc, or 27 in icrdat. */
/*       Use "i" anywhere in note symbol. */
/* 2.21 */
/*   Increase from 20 to 30 dimensions for movement breaks and midi sections. */
/*   Fix out-of-order declarations per mutex comments */
/*   Add "Bad error" and "Kluging" messages to log file. */
/* 2.197 */
/*   add /comips/ to save tie-check midi variables */
/*   For spacing of clef changes at start of input block, changed integer time */
/*     lastnodur to prevtn, so it works with xtups. Possible incompatibility! */
/* 2.196 */
/*   Fix Ickbug with time check in ncmid() */
/*   Interchange \fermataup7 and \pausec to get proper alignment */
/*   Enable French violin clef "f",  number 7 in PMX, but 9 in MusiXTeX. */
/*   Add defn's of \hsp, \hspp to pmx.tex */
/*   Fix pre-slurs on xtup chord notes. */
/*   Fixed raised PAuse, define \liftPAuse */
/*   Replace \zbreve\sk with \breve. */
/*   Made "1" work as mtrdenl by doubling it and mtrnuml.  BUT WAIT...what */
/*     about "o" and 1 as shorthand for 16???? Search for "Kluge" */
/*   Added "vo" (voice) as MIDI instrument 55 */
/*   Allow 3-digit page numbers (search for "toppageno") */
/*   Fix bug caused by prior fix (cancelling accid after bar line was ignored). */
/*   Fix double accids in chords */
/* 2.194 */
/*   Fix bug with accid/tie/barline/chord in addmidi by restructuring accid if */
/*     block. */
/*   Add meter to MIDI file with every pause */
/*   Purify FORTRAN? */
/* 2.193 */
/*   Increased # of in-line TeX strings from 36 to 52. */
/*   Fix entry of # of bytes in header of tempo/meter/key track to allow >255. */
/* 2.191 */
/*   Event track: Tempos, meters, keys all together.  Data in comevent */
/* 2.15 */
/*   Pretty good midi capability.  Still no attention to slurs on chord notes. */
/* 2.11 */
/*   11 Dec 99 c   rm1 */
/*   11 Dec 99 "oes?", "oe?" */
/*   11 Dec 99 Cancel slur horizontal tweaks with non-stemmed notes */
/*   11 Dec 99 Error message for shifted, repeated ornaments. */
/* 2.10 (Version 2.1) */
/*   Fix bug with lowdot and xtuplets */
/* 2.09 */
/*   Fix bug with multiple ornament heights over beams, when one is . or _ */
/*   Error message from pmxa if rest on last note of xtup. */
/*   Enable 12 slurs. */
/*   Reinstate multiple rests at start of xtup. */
/* 2.07 */
/*   Combine consecutive type-1 TeX strings. */
/*   \midslur and \curve as 3rd signed digit in slur termination, + 2 opt.int's. */
/*   Fixed breve chord notes in docrd */
/*   Check irest(28) as well as vxtup when setting nodur for chord notes, since */
/*     vxtup isn't set until 1st *main* note in xtup */
/*   Vectorize nolev1, slope, ixrest.  Klug fix for xtups with variable spacing. */
/* 2.06+ */
/*   Make deterministic the beam slope calculation when there are an even # of */
/*     slopes in list and middle two are equal magnitude but opposite sign. */
/*   pmxa Trap for "o:" before 1st note in block */
/*   Partial bug fix for 64th notes in xtuplets. */
/*   Make ixrest a vector, since with new time scheme may not finish xtup in */
/*     same notes block. */
/*   Increase max # of pages from 20 to 30 (dimensions of nsystp,..., in pmxb) */
/* 2.06 */
/*   Account for changes in nv when computing \interstaff. Add a counter */
/*     nistaff(iflb) = # of interstaff spaces per system = nv-1.  Set whenever */
/*     setting isysflb(iflb). Note nv can only change at a forced line break. */
/*     Note also, iflb starts at 0! */
/* 2.05 */
/*   Automatic start of new notes group with part 2 of staff-jump beam */
/*     In make1bar, set irest bit 29 of lowest-voice note at same time, */
/*     use as flag when making notes groups. */
/*   For now, remove dummy blank line at end...it zaps terminal repeats. */
/* 2.02 */
/*   Fixed slur-counting bug for multiple, slurred, aftergraces. */
/* 2.01 */
/*  Increase to ask(1400) */
/*  Increase max forced page breaks to 18 */
/*  Define pausc for centered pause */
/* 2.0a */
/*  Insert dummy blank line at very end to handle input files w/o terminal CR-LF */
/* pmx03r */
/*   Option m[n] in S symbol to change musicsize (for parts) */
/*   Double dotted rests now work. */
/*   Write file name to log file */
/*   Check existence of input file */
/*   Allow 24-char jobname, may end with ".pmx" */
/*   Comment out time stuff */
/*   Replace 3-argument getarg with 2-argument + iargc */
/*   Fix bug with negative noinst due to nint<=int replacement */
/*   move lovation of iv in isdat1 to allow iv>7. */
/*   Set nm=12 */
/* pmx03q */
/*   replace int(x+.001) with nint(x) */
/*   Write TeX file name to screen and to pml. */
/*   Replace char(...) with chax(...) to sovle msdev bug. */
/*   Bug fix: macro terminations when M is on a line by itself. */
/*   Bug fix: don't accumulate space for XS in pmxa. */
/*   Streamline Macros: use pointers to bufq instead of scratch files */
/* pmx03p */
/*   Store input file in single character array bufq. */
/*     lbuf(i)*2 is length of line i */
/*     ipbuf is position just before next line to be read. */
/* pmx03 */
/*   Optimize read/writes */
/* pmx02 */
/*   Fix line count (for errors) when there are saved macros */
/* pmx01 */
/*   In optimize mode, open/close macros (Watch out for residual zz files!) */
/*   Command line input */
/*   Option Ao to optimize, otherwise normal processing */

/* cccccc */

/* Added 130302 only to get nsperi from g1etnote, for use in midi setup */


/*  immac(i) is the index of i-th macro, i=1,nmac.  Also make a list containing */
/*   nmidsec  section starts and stops based on PLAYING macros (not recording). */

/* cccccccccccccccccccccccc */


/* cccccccccccccccccccccccc */
/*      itstart = mytime() */
#line 853 ""
    s_copy(comver_1.versionc, version, (ftnlen)5, (ftnlen)5);

/*  Initialize midi parameters */

#line 857 ""
    commmac_1.gottempo = FALSE_;
#line 858 ""
    commidi_1.ismidi = FALSE_;
#line 859 ""
    commidi_1.debugmidi = FALSE_;
#line 860 ""
    commidi_1.relacc = FALSE_;
#line 861 ""
    commmac_1.mmacrec = FALSE_;
#line 862 ""
    commmac_1.nmidsec = 1;
#line 863 ""
    commidi_1.mgap = 10;
#line 864 ""
    comevent_1.miditime = 0;
#line 865 ""
    comevent_1.lasttime = 0;
#line 866 ""
    commidi_1.nmidcrd = 0;
#line 867 ""
    comslm_1.nusebl = 0;
#line 868 ""
    commidi_1.notmain = FALSE_;
#line 869 ""
    for (ivx = 1; ivx <= 24; ++ivx) {
#line 870 ""
	commidi_1.twoline[ivx - 1] = FALSE_;
#line 871 ""
	commidi_1.midinst[ivx - 1] = 6;
#line 872 ""
	commvel_1.midivel[ivx - 1] = 127;
#line 873 ""
	commvel_1.midibal[ivx - 1] = 64;
#line 874 ""
	commvel_1.miditran[ivx - 1] = 0;
#line 875 ""
/* L3: */
#line 875 ""
    }
#line 876 ""
    for (icm = 0; icm <= 24; ++icm) {
#line 877 ""
	commidi_1.imidi[icm] = 0;
#line 878 ""
	commidi_1.restpend[icm] = FALSE_;
#line 879 ""
	commidi_1.trest[icm] = 0.f;
#line 880 ""
	comslm_1.levson[icm] = 0;
#line 881 ""
	comslm_1.levsoff[icm] = 0;
#line 882 ""
	comslm_1.slmon[icm] = FALSE_;
#line 883 ""
	comslm_1.naccbl[icm] = 0;
#line 884 ""
	comdiag_1.n69[icm] = 0;
#line 885 ""
	comdiag_1.n34[icm] = 0;
#line 886 ""
	commmac_1.msecstrt[icm] = 1;
#line 887 ""
/* L12: */
#line 887 ""
    }

/*  End of midi parameter initialization */

#line 891 ""
    commus_1.musize = 0;
#line 892 ""
    optimize = FALSE_;
#line 893 ""
    numargs = iargc_();
#line 894 ""
    if (numargs == 0) {
#line 895 ""
	s_wsle(&io___10);
#line 895 ""
	do_lio(&c__9, &c__1, "You could have entered a jobname on the comman"\
		"d line,", (ftnlen)53);
#line 895 ""
	e_wsle();
#line 896 ""
	s_wsle(&io___11);
#line 896 ""
	do_lio(&c__9, &c__1, "      but you may enter one now:", (ftnlen)32);
#line 896 ""
	e_wsle();
#line 897 ""
	s_rsfe(&io___12);
#line 897 ""
	do_fio(&c__1, jobname, (ftnlen)44);
#line 897 ""
	e_rsfe();
#line 898 ""
	numargs = 1;
#line 899 ""
    } else {
/*        call getarg(1,jobname,idum) ! May need to replace this w/ next line */
#line 901 ""
	getarg_(&c__1, jobname, (ftnlen)44);
#line 902 ""
    }
#line 903 ""
L10:
#line 903 ""
    ljob = lenstr_(jobname, &c__44, (ftnlen)44);
#line 904 ""
    if (ljob > 44) {
#line 905 ""
	s_wsle(&io___15);
#line 905 ""
	do_lio(&c__9, &c__1, "Jobname is too long. Try again.", (ftnlen)31);
#line 905 ""
	e_wsle();
#line 906 ""
	stop1_();
#line 907 ""
    } else if (ljob == 0) {
#line 908 ""
	s_wsle(&io___16);
#line 908 ""
	do_lio(&c__9, &c__1, "No was jobname entered. Try again.", (ftnlen)34)
		;
#line 908 ""
	e_wsle();
#line 909 ""
	stop1_();
#line 910 ""
    } else if (numargs == 2) {
#line 911 ""
	if (ljob == 2 && s_cmp(jobname, "-o", (ftnlen)2, (ftnlen)2) == 0) {
#line 912 ""
	    optimize = TRUE_;
/*          call getarg(2,jobname,idum) ! May need to replace this w/ next line */
#line 914 ""
	    getarg_(&c__2, jobname, (ftnlen)44);
#line 915 ""
	    numargs = 1;
#line 916 ""
	    goto L10;
#line 917 ""
	} else {
#line 918 ""
	    s_wsle(&io___17);
#line 918 ""
	    do_lio(&c__9, &c__1, "Illegal option on command line", (ftnlen)30)
		    ;
#line 918 ""
	    e_wsle();
#line 919 ""
	    stop1_();
#line 920 ""
	}
#line 921 ""
    }

/*  Strip ".pmx" if necessary */

/* Computing MAX */
#line 925 ""
    i__1 = i_indx(jobname, ".pmx", (ftnlen)44, (ftnlen)4), i__2 = i_indx(
	    jobname, ".PMX", (ftnlen)44, (ftnlen)4);
#line 925 ""
    ndxpmx = max(i__1,i__2);
#line 926 ""
    if (ndxpmx > 0) {
#line 927 ""
	s_copy(jobname, jobname, (ftnlen)44, ndxpmx - 1);
#line 928 ""
	ljob += -4;
#line 929 ""
    }

/*  Check for existence of input file */

/* Writing concatenation */
#line 933 ""
    i__3[0] = ljob, a__1[0] = jobname;
#line 933 ""
    i__3[1] = 4, a__1[1] = ".pmx";
#line 933 ""
    s_cat(infileq, a__1, i__3, &c__2, (ftnlen)47);
#line 934 ""
    ioin__1.inerr = 0;
#line 934 ""
    ioin__1.infilen = 47;
#line 934 ""
    ioin__1.infile = infileq;
#line 934 ""
    ioin__1.inex = &fexist;
#line 934 ""
    ioin__1.inopen = 0;
#line 934 ""
    ioin__1.innum = 0;
#line 934 ""
    ioin__1.innamed = 0;
#line 934 ""
    ioin__1.inname = 0;
#line 934 ""
    ioin__1.inacc = 0;
#line 934 ""
    ioin__1.inseq = 0;
#line 934 ""
    ioin__1.indir = 0;
#line 934 ""
    ioin__1.infmt = 0;
#line 934 ""
    ioin__1.inform = 0;
#line 934 ""
    ioin__1.inunf = 0;
#line 934 ""
    ioin__1.inrecl = 0;
#line 934 ""
    ioin__1.innrec = 0;
#line 934 ""
    ioin__1.inblank = 0;
#line 934 ""
    f_inqu(&ioin__1);
#line 935 ""
    if (! fexist) {
#line 936 ""
	ioin__1.inerr = 0;
#line 936 ""
	ioin__1.infilen = ljob + 4;
/* Writing concatenation */
#line 936 ""
	i__3[0] = ljob, a__1[0] = jobname;
#line 936 ""
	i__3[1] = 4, a__1[1] = ".PMX";
#line 936 ""
	s_cat(ch__1, a__1, i__3, &c__2, (ftnlen)48);
#line 936 ""
	ioin__1.infile = ch__1;
#line 936 ""
	ioin__1.inex = &fexist;
#line 936 ""
	ioin__1.inopen = 0;
#line 936 ""
	ioin__1.innum = 0;
#line 936 ""
	ioin__1.innamed = 0;
#line 936 ""
	ioin__1.inname = 0;
#line 936 ""
	ioin__1.inacc = 0;
#line 936 ""
	ioin__1.inseq = 0;
#line 936 ""
	ioin__1.indir = 0;
#line 936 ""
	ioin__1.infmt = 0;
#line 936 ""
	ioin__1.inform = 0;
#line 936 ""
	ioin__1.inunf = 0;
#line 936 ""
	ioin__1.inrecl = 0;
#line 936 ""
	ioin__1.innrec = 0;
#line 936 ""
	ioin__1.inblank = 0;
#line 936 ""
	f_inqu(&ioin__1);
#line 937 ""
	if (! fexist) {
#line 938 ""
	    s_wsle(&io___21);
/* Writing concatenation */
#line 938 ""
	    i__3[0] = 17, a__1[0] = "Cannot find file ";
#line 938 ""
	    i__3[1] = 47, a__1[1] = infileq;
#line 938 ""
	    s_cat(ch__2, a__1, i__3, &c__2, (ftnlen)64);
#line 938 ""
	    do_lio(&c__9, &c__1, ch__2, (ftnlen)64);
#line 938 ""
	    e_wsle();
#line 939 ""
	    stop1_();
#line 940 ""
	} else {
/* Writing concatenation */
#line 941 ""
	    i__3[0] = ljob, a__1[0] = jobname;
#line 941 ""
	    i__3[1] = 4, a__1[1] = ".PMX";
#line 941 ""
	    s_cat(infileq, a__1, i__3, &c__2, (ftnlen)47);
#line 942 ""
	}
#line 943 ""
    }

/*  Open a log file */

#line 947 ""
    o__1.oerr = 0;
#line 947 ""
    o__1.ounit = 15;
#line 947 ""
    o__1.ofnmlen = ljob + 4;
/* Writing concatenation */
#line 947 ""
    i__3[0] = ljob, a__1[0] = jobname;
#line 947 ""
    i__3[1] = 4, a__1[1] = ".pml";
#line 947 ""
    s_cat(ch__1, a__1, i__3, &c__2, (ftnlen)48);
#line 947 ""
    o__1.ofnm = ch__1;
#line 947 ""
    o__1.orl = 0;
#line 947 ""
    o__1.osta = 0;
#line 947 ""
    o__1.oacc = 0;
#line 947 ""
    o__1.ofm = 0;
#line 947 ""
    o__1.oblnk = 0;
#line 947 ""
    f_open(&o__1);
/* Writing concatenation */
#line 948 ""
    i__4[0] = 21, a__2[0] = "This is PMX, Version ";
#line 948 ""
    i__4[1] = 5, a__2[1] = version;
#line 948 ""
    i__4[2] = 2, a__2[2] = ", ";
#line 948 ""
    i__4[3] = 9, a__2[3] = date;
#line 948 ""
    s_cat(ch__3, a__2, i__4, &c__4, (ftnlen)37);
#line 948 ""
    printl_(ch__3, (ftnlen)37);
#line 949 ""
    ljob4 = ljob;
/* Writing concatenation */
#line 950 ""
    i__3[0] = 8, a__1[0] = "Opening ";
#line 950 ""
    i__3[1] = 47, a__1[1] = infileq;
#line 950 ""
    s_cat(ch__4, a__1, i__3, &c__2, (ftnlen)55);
#line 950 ""
    printl_(ch__4, (ftnlen)55);
#line 951 ""
    o__1.oerr = 0;
#line 951 ""
    o__1.ounit = 18;
#line 951 ""
    o__1.ofnmlen = 47;
#line 951 ""
    o__1.ofnm = infileq;
#line 951 ""
    o__1.orl = 0;
#line 951 ""
    o__1.osta = 0;
#line 951 ""
    o__1.oacc = 0;
#line 951 ""
    o__1.ofm = 0;
#line 951 ""
    o__1.oblnk = 0;
#line 951 ""
    f_open(&o__1);

/*  Copy input file into common buffer */

#line 955 ""
    inbuff_1.ipbuf = 0;
#line 956 ""
    truelinecount_1.linewcom[0] = 1;
#line 957 ""
    for (inbuff_1.ilbuf = 1; inbuff_1.ilbuf <= 9600; ++inbuff_1.ilbuf) {
#line 958 ""
	ncomments = 0;
#line 959 ""
L14:
#line 959 ""
	i__1 = s_rsfe(&io___24);
#line 959 ""
	if (i__1 != 0) {
#line 959 ""
	    goto L9;
#line 959 ""
	}
#line 959 ""
	i__1 = do_fio(&c__1, lnholdq, (ftnlen)128);
#line 959 ""
	if (i__1 != 0) {
#line 959 ""
	    goto L9;
#line 959 ""
	}
#line 959 ""
	i__1 = e_rsfe();
#line 959 ""
	if (i__1 != 0) {
#line 959 ""
	    goto L9;
#line 959 ""
	}
#line 960 ""
	inbuff_1.lbuf[inbuff_1.ilbuf - 1] = (shortint) lenstr_(lnholdq, &
		c__128, (ftnlen)128);
#line 961 ""
	if (inbuff_1.lbuf[inbuff_1.ilbuf - 1] == 0) {

/*  Blank line.  Make it a single blank with length 1 */

#line 965 ""
	    inbuff_1.lbuf[inbuff_1.ilbuf - 1] = 1;
#line 966 ""
	    s_copy(lnholdq, " ", (ftnlen)128, (ftnlen)1);
#line 967 ""
	}

/*  Now line has at least one non blank character. Check for comment */
/*  As of Version 260, do not copy comments into bufq */
/*  But need to count %'s for error messaging */
/*        if (lnholdq(1:1).eq.'%') go to 14 */
#line 973 ""
	if (*(unsigned char *)lnholdq == '%') {
#line 974 ""
	    ++ncomments;
#line 975 ""
	    goto L14;
#line 976 ""
	}

/*  When here, have counted all preceding comments and have a real line */

#line 980 ""
	if (inbuff_1.ilbuf > 1) {
#line 981 ""
	    truelinecount_1.linewcom[inbuff_1.ilbuf - 1] = 
		    truelinecount_1.linewcom[inbuff_1.ilbuf - 2] + 1 + 
		    ncomments;
#line 982 ""
	} else {
#line 983 ""
	    truelinecount_1.linewcom[0] = ncomments + 1;
#line 984 ""
	}
#line 985 ""
	if (inbuff_1.ipbuf + inbuff_1.lbuf[inbuff_1.ilbuf - 1] > 131072) {
#line 986 ""
	    s_wsle(&io___26);
#line 986 ""
	    do_lio(&c__9, &c__1, "Too many characters in file, stopping", (
		    ftnlen)37);
#line 986 ""
	    e_wsle();
#line 987 ""
	    stop1_();
#line 988 ""
	}
#line 989 ""
	i__1 = inbuff_1.ipbuf;
#line 989 ""
	s_copy(inbuff_1.bufq + i__1, lnholdq, inbuff_1.ipbuf + inbuff_1.lbuf[
		inbuff_1.ilbuf - 1] - i__1, (ftnlen)128);
#line 990 ""
	inbuff_1.ipbuf += inbuff_1.lbuf[inbuff_1.ilbuf - 1];
#line 991 ""
/* L8: */
#line 991 ""
    }
#line 992 ""
    printl_("Too many lines in input file", (ftnlen)28);
#line 993 ""
    stop1_();
#line 994 ""
L9:

/*  Insert dummy line to handle input files w/o CR-LF at end. */

#line 998 ""
    inbuff_1.nlbuf = inbuff_1.ilbuf - 1;
/*      nlbuf = ilbuf */
/*      bufq(ipbuf+1:ipbuf+3) = ' / ' */
/*      lbuf(nlbuf) = 3 */
#line 1002 ""
    cl__1.cerr = 0;
#line 1002 ""
    cl__1.cunit = 18;
#line 1002 ""
    cl__1.csta = 0;
#line 1002 ""
    f_clos(&cl__1);
#line 1003 ""
    i__1 = maxit;
#line 1003 ""
    for (numit = 1; numit <= i__1; ++numit) {
#line 1004 ""
	if (optimize) {
#line 1004 ""
	    printl_("Starting an iteration", (ftnlen)21);
#line 1004 ""
	}

/*  When isfirst=.true., pmxa() generates linebreaks normally, output in nbars0. */
/*    Otherwise, nbars0 is the input */
/*  When islast=.false., pmxb only returns poe's, otherwise does whole job */

#line 1010 ""
	pmxa_(jobname, &ljob4, &isfirst, &nsyst, nbars0, &optimize, (ftnlen)
		44);
#line 1011 ""
	if (! optimize) {
#line 1012 ""
	    if (commidi_1.ismidi) {

/*  This was moved here from writemidi 130302 to allow midivel,bal,tran, to be */
/*    set up here as functions of instrument rather than iv (staff). */
/*  Count up staves(iv,nv) vs instruments.  Store instr# for iv in iinsiv(iv) */

#line 1018 ""
		nstaves = 0;
#line 1019 ""
		ivt = 0;
#line 1020 ""
		for (iinst = 1; iinst <= 24; ++iinst) {
#line 1021 ""
		    nstaves += c1omget_1.nsperi[iinst - 1];
#line 1022 ""
		    i__2 = c1omget_1.nsperi[iinst - 1];
#line 1022 ""
		    for (ivtt = 1; ivtt <= i__2; ++ivtt) {
#line 1023 ""
			++ivt;
#line 1024 ""
			commvel_1.iinsiv[ivt - 1] = (shortint) iinst;
#line 1025 ""
/* L17: */
#line 1025 ""
		    }
#line 1026 ""
		    if (nstaves == a1ll_1.nv) {
#line 1026 ""
			goto L18;
#line 1026 ""
		    }
#line 1027 ""
/* L16: */
#line 1027 ""
		}
#line 1028 ""
		s_wsle(&io___34);
#line 1028 ""
		do_lio(&c__9, &c__1, "Screwup!", (ftnlen)8);
#line 1028 ""
		e_wsle();
#line 1029 ""
		stop1_();
#line 1030 ""
L18:

/*  Set up channel numbers for midi. */

#line 1034 ""
		commidi_1.numchan = 0;
#line 1035 ""
		for (a1ll_1.iv = a1ll_1.nv; a1ll_1.iv >= 1; --a1ll_1.iv) {
#line 1036 ""
		    if (commidi_1.twoline[a1ll_1.iv - 1]) {
#line 1037 ""
			commidi_1.midchan[a1ll_1.iv + 23] = commidi_1.numchan;
#line 1038 ""
			++commidi_1.numchan;
#line 1039 ""
		    }
#line 1040 ""
		    commidi_1.midchan[a1ll_1.iv - 1] = commidi_1.numchan;
#line 1041 ""
		    ++commidi_1.numchan;
#line 1042 ""
/* L11: */
#line 1042 ""
		}

/*  numchan will now be the number of channels, but max channel # is numchan-1 */

/*  Set up velocities, balances, and midi-transpositions */

#line 1048 ""
		for (a1ll_1.iv = a1ll_1.nv; a1ll_1.iv >= 1; --a1ll_1.iv) {
#line 1049 ""
		    if (commidi_1.twoline[a1ll_1.iv - 1]) {
/*  130302 Make these functions of instrument rather than staff (iv) */
#line 1051 ""
			commvel_1.midvelc[commidi_1.midchan[a1ll_1.iv + 23]] =
				 commvel_1.midivel[commvel_1.iinsiv[a1ll_1.iv 
				- 1] - 1];
#line 1052 ""
			commvel_1.midbc[commidi_1.midchan[a1ll_1.iv + 23]] = 
				commvel_1.midibal[commvel_1.iinsiv[a1ll_1.iv 
				- 1] - 1];
#line 1053 ""
			commvel_1.midtc[commidi_1.midchan[a1ll_1.iv + 23]] = 
				commvel_1.miditran[commvel_1.iinsiv[a1ll_1.iv 
				- 1] - 1];
#line 1054 ""
		    }
#line 1055 ""
		    commvel_1.midvelc[commidi_1.midchan[a1ll_1.iv - 1]] = 
			    commvel_1.midivel[commvel_1.iinsiv[a1ll_1.iv - 1] 
			    - 1];
#line 1056 ""
		    commvel_1.midbc[commidi_1.midchan[a1ll_1.iv - 1]] = 
			    commvel_1.midibal[commvel_1.iinsiv[a1ll_1.iv - 1] 
			    - 1];
#line 1057 ""
		    commvel_1.midtc[commidi_1.midchan[a1ll_1.iv - 1]] = 
			    commvel_1.miditran[commvel_1.iinsiv[a1ll_1.iv - 1]
			     - 1];
#line 1058 ""
/* L13: */
#line 1058 ""
		}
#line 1059 ""
	    }

/*  TEMPORARY!!! */

#line 1063 ""
	    s_wsle(&io___35);
#line 1063 ""
	    do_lio(&c__9, &c__1, "nlbuf: ", (ftnlen)7);
#line 1063 ""
	    do_lio(&c__3, &c__1, (char *)&inbuff_1.nlbuf, (ftnlen)sizeof(
		    integer));
#line 1063 ""
	    e_wsle();
#line 1064 ""
	    ip1 = 1;
#line 1065 ""
	    i__2 = inbuff_1.nlbuf;
#line 1065 ""
	    for (ilb = 1; ilb <= i__2; ++ilb) {
#line 1066 ""
		ip1 += inbuff_1.lbuf[ilb - 1];
#line 1067 ""
/* L10000: */
#line 1067 ""
	    }
#line 1068 ""
	    iplast = ip1 - 1;

/*  Check to see if (1) last line is "<blank><blank>/" and (2) next to last */
/*    line is "/" */

#line 1073 ""
	    i__2 = iplast + 1 - inbuff_1.lbuf[inbuff_1.nlbuf - 1] - 1;
#line 1073 ""
	    if (s_cmp(inbuff_1.bufq + i__2, "  /", iplast - i__2, (ftnlen)3) 
		    == 0) {
#line 1074 ""
		i__2 = iplast - inbuff_1.lbuf[inbuff_1.nlbuf - 1] - 1;
#line 1074 ""
		chax_(ch__5, (ftnlen)1, &c__47);
#line 1074 ""
		if (s_cmp(inbuff_1.bufq + i__2, ch__5, iplast - inbuff_1.lbuf[
			inbuff_1.nlbuf - 1] - i__2, (ftnlen)1) == 0) {
#line 1075 ""
		    s_wsle(&io___39);
#line 1075 ""
		    do_lio(&c__9, &c__1, "Removing last line of \"<blank><bl"\
			    "ank>/\"", (ftnlen)39);
#line 1075 ""
		    e_wsle();
#line 1076 ""
		    s_wsle(&io___40);
#line 1076 ""
		    do_lio(&c__9, &c__1, "Removing last line of \"<blank><bl"\
			    "ank>/\"", (ftnlen)39);
#line 1076 ""
		    e_wsle();
#line 1077 ""
		    --inbuff_1.nlbuf;
#line 1078 ""
		}
#line 1079 ""
	    }

#line 1081 ""
	    pmxb_(&c_true, poe0, &ncalls, &optimize);
#line 1082 ""
	    if (commidi_1.ismidi) {

/*  Write midi file */

#line 1086 ""
		o__1.oerr = 0;
#line 1086 ""
		o__1.ounit = 51;
#line 1086 ""
		o__1.ofnmlen = ljob + 4;
/* Writing concatenation */
#line 1086 ""
		i__3[0] = ljob, a__1[0] = jobname;
#line 1086 ""
		i__3[1] = 4, a__1[1] = ".mid";
#line 1086 ""
		s_cat(ch__1, a__1, i__3, &c__2, (ftnlen)48);
#line 1086 ""
		o__1.ofnm = ch__1;
#line 1086 ""
		o__1.orl = 0;
#line 1086 ""
		o__1.osta = 0;
#line 1086 ""
		o__1.oacc = 0;
#line 1086 ""
		o__1.ofm = 0;
#line 1086 ""
		o__1.oblnk = 0;
#line 1086 ""
		f_open(&o__1);
#line 1087 ""
		if (commidi_1.debugmidi) {
#line 1087 ""
		    o__1.oerr = 0;
#line 1087 ""
		    o__1.ounit = 52;
#line 1087 ""
		    o__1.ofnmlen = ljob + 4;
/* Writing concatenation */
#line 1087 ""
		    i__3[0] = ljob, a__1[0] = jobname;
#line 1087 ""
		    i__3[1] = 4, a__1[1] = ".dbm";
#line 1087 ""
		    s_cat(ch__1, a__1, i__3, &c__2, (ftnlen)48);
#line 1087 ""
		    o__1.ofnm = ch__1;
#line 1087 ""
		    o__1.orl = 0;
#line 1087 ""
		    o__1.osta = 0;
#line 1087 ""
		    o__1.oacc = 0;
#line 1087 ""
		    o__1.ofm = 0;
#line 1087 ""
		    o__1.oblnk = 0;
#line 1087 ""
		    f_open(&o__1);
#line 1087 ""
		}
#line 1088 ""
		printl_(" ", (ftnlen)1);
/* Writing concatenation */
#line 1089 ""
		i__5[0] = 8, a__3[0] = "Writing ";
#line 1089 ""
		i__5[1] = ljob, a__3[1] = jobname;
#line 1089 ""
		i__5[2] = 4, a__3[2] = ".mid";
#line 1089 ""
		s_cat(ch__6, a__3, i__5, &c__3, (ftnlen)56);
#line 1089 ""
		printl_(ch__6, ljob + 12);
#line 1090 ""
		writemidi_(jobname, &ljob, (ftnlen)44);
#line 1091 ""
	    }
#line 1092 ""
	    cl__1.cerr = 0;
#line 1092 ""
	    cl__1.cunit = 15;
#line 1092 ""
	    cl__1.csta = 0;
#line 1092 ""
	    f_clos(&cl__1);
#line 1093 ""
	    s_stop("", (ftnlen)0);
#line 1094 ""
	}
#line 1095 ""
	s_wsle(&io___42);
#line 1095 ""
	do_lio(&c__9, &c__1, "nlbuf: ", (ftnlen)7);
#line 1095 ""
	do_lio(&c__3, &c__1, (char *)&inbuff_1.nlbuf, (ftnlen)sizeof(integer))
		;
#line 1095 ""
	e_wsle();
#line 1096 ""
	ip1 = 1;
#line 1097 ""
	pmxb_(&c_false, poe0, &ncalls, &optimize);
#line 1098 ""
	poestats_(&nsyst, poe0, &poebar0, &devnorm0);

/*  Save initial deviation and line breaks for later comparison */

#line 1102 ""
	if (numit == 1) {
#line 1103 ""
	    devpmx = devnorm0;
#line 1104 ""
	    i__2 = nsyst;
#line 1104 ""
	    for (isys = 1; isys <= i__2; ++isys) {
#line 1105 ""
		nbari[isys - 1] = nbars0[isys - 1];
#line 1106 ""
/* L20: */
#line 1106 ""
	    }
#line 1107 ""
	}
#line 1108 ""
	sortpoe_(&nsyst, poe0, ipoe);
#line 1109 ""
	for (iupord = nsyst; iupord >= 1; --iupord) {
#line 1110 ""
	    isysu = ipoe[iupord - 1];
#line 1111 ""
	    s_wsle(&io___51);
#line 1111 ""
	    do_lio(&c__9, &c__1, "isysu=", (ftnlen)6);
#line 1111 ""
	    do_lio(&c__3, &c__1, (char *)&isysu, (ftnlen)sizeof(integer));
#line 1111 ""
	    e_wsle();
#line 1112 ""
	    s_wsle(&io___52);
#line 1112 ""
	    do_lio(&c__9, &c__1, "isysu=", (ftnlen)6);
#line 1112 ""
	    do_lio(&c__3, &c__1, (char *)&isysu, (ftnlen)sizeof(integer));
#line 1112 ""
	    e_wsle();

/*  Skip if system isysu has poe0 < avg or isysd has poe0 > avg */

#line 1116 ""
	    if (poe0[isysu - 1] < poebar0) {
#line 1116 ""
		goto L1;
#line 1116 ""
	    }
#line 1117 ""
	    i__2 = nsyst;
#line 1117 ""
	    for (idnord = 1; idnord <= i__2; ++idnord) {
#line 1118 ""
		isysd = ipoe[idnord - 1];
#line 1119 ""
		if (isysu == isysd || nbars0[isysd - 1] == 1 || poe0[isysd - 
			1] > poebar0) {
#line 1119 ""
		    goto L5;
#line 1119 ""
		}
#line 1121 ""
		i__6 = nsyst;
#line 1121 ""
		for (isyst = 1; isyst <= i__6; ++isyst) {
#line 1122 ""
		    nbars[isyst - 1] = nbars0[isyst - 1];
#line 1123 ""
		    if (isyst == isysu) {
#line 1124 ""
			++nbars[isyst - 1];
#line 1125 ""
		    } else if (isyst == isysd) {
#line 1126 ""
			--nbars[isyst - 1];
#line 1127 ""
		    }
#line 1128 ""
/* L2: */
#line 1128 ""
		}
#line 1129 ""
		pmxa_(jobname, &ljob4, &isfirst, &nsyst, nbars, &optimize, (
			ftnlen)44);
#line 1130 ""
		pmxb_(&c_false, poe, &ncalls, &optimize);
#line 1131 ""
		poestats_(&nsyst, poe, &poebar, &devnorm);
#line 1132 ""
		if (devnorm < devnorm0) {
#line 1133 ""
		    devnorm0 = devnorm;
#line 1134 ""
		    poebar0 = poebar;
#line 1135 ""
		    i__6 = nsyst;
#line 1135 ""
		    for (isys = 1; isys <= i__6; ++isys) {
#line 1136 ""
			nbars0[isys - 1] = nbars[isys - 1];
#line 1137 ""
			poe0[isys - 1] = poe[isys - 1];
#line 1138 ""
/* L4: */
#line 1138 ""
		    }
#line 1139 ""
		    s_wsle(&io___60);
#line 1139 ""
		    do_lio(&c__9, &c__1, "Improved with iup,idown,devnorm:", (
			    ftnlen)32);
#line 1139 ""
		    do_lio(&c__3, &c__1, (char *)&isysu, (ftnlen)sizeof(
			    integer));
#line 1139 ""
		    do_lio(&c__3, &c__1, (char *)&isysd, (ftnlen)sizeof(
			    integer));
#line 1139 ""
		    do_lio(&c__4, &c__1, (char *)&devnorm0, (ftnlen)sizeof(
			    real));
#line 1139 ""
		    e_wsle();
#line 1141 ""
		    s_wsle(&io___61);
#line 1141 ""
		    do_lio(&c__9, &c__1, "Improved with iup,idown,devnorm:", (
			    ftnlen)32);
#line 1141 ""
		    do_lio(&c__3, &c__1, (char *)&isysu, (ftnlen)sizeof(
			    integer));
#line 1141 ""
		    do_lio(&c__3, &c__1, (char *)&isysd, (ftnlen)sizeof(
			    integer));
#line 1141 ""
		    do_lio(&c__4, &c__1, (char *)&devnorm0, (ftnlen)sizeof(
			    real));
#line 1141 ""
		    e_wsle();
#line 1143 ""
		    s_wsfe(&io___62);
#line 1143 ""
		    i__6 = nsyst;
#line 1143 ""
		    for (isys = 1; isys <= i__6; ++isys) {
#line 1143 ""
			do_fio(&c__1, (char *)&nbars0[isys - 1], (ftnlen)
				sizeof(integer));
#line 1143 ""
		    }
#line 1143 ""
		    e_wsfe();
#line 1144 ""
		    s_wsfe(&io___63);
#line 1144 ""
		    i__6 = nsyst;
#line 1144 ""
		    for (isys = 1; isys <= i__6; ++isys) {
#line 1144 ""
			do_fio(&c__1, (char *)&nbars0[isys - 1], (ftnlen)
				sizeof(integer));
#line 1144 ""
		    }
#line 1144 ""
		    e_wsfe();
#line 1145 ""
		    sortpoe_(&nsyst, poe0, ipoe);
#line 1146 ""
		    goto L6;
#line 1147 ""
		}
#line 1148 ""
L5:
#line 1148 ""
		;
#line 1148 ""
	    }
#line 1149 ""
L1:
#line 1149 ""
	    ;
#line 1149 ""
	}

/*  If we get here, must have gone thru all switches and found nothing better, */
/*  so done! */

#line 1154 ""
	goto L7;
#line 1155 ""
L6:
#line 1155 ""
	;
#line 1155 ""
    }
#line 1156 ""
L7:
#line 1157 ""
    s_wsle(&io___64);
#line 1157 ""
    do_lio(&c__9, &c__1, "Optimum located, numit:", (ftnlen)23);
#line 1157 ""
    do_lio(&c__3, &c__1, (char *)&numit, (ftnlen)sizeof(integer));
#line 1157 ""
    do_lio(&c__9, &c__1, ",  ncalls:", (ftnlen)10);
#line 1157 ""
    do_lio(&c__3, &c__1, (char *)&ncalls, (ftnlen)sizeof(integer));
#line 1157 ""
    e_wsle();
#line 1158 ""
    s_wsle(&io___65);
#line 1158 ""
    do_lio(&c__9, &c__1, "Optimum located, numit:", (ftnlen)23);
#line 1158 ""
    do_lio(&c__3, &c__1, (char *)&numit, (ftnlen)sizeof(integer));
#line 1158 ""
    do_lio(&c__9, &c__1, ",  ncalls:", (ftnlen)10);
#line 1158 ""
    do_lio(&c__3, &c__1, (char *)&ncalls, (ftnlen)sizeof(integer));
#line 1158 ""
    e_wsle();
#line 1159 ""
    s_wsle(&io___66);
#line 1159 ""
    do_lio(&c__9, &c__1, "Final error:", (ftnlen)12);
#line 1159 ""
    do_lio(&c__4, &c__1, (char *)&devnorm0, (ftnlen)sizeof(real));
#line 1159 ""
    do_lio(&c__9, &c__1, ", initial error:", (ftnlen)16);
#line 1159 ""
    do_lio(&c__4, &c__1, (char *)&devpmx, (ftnlen)sizeof(real));
#line 1159 ""
    e_wsle();
#line 1160 ""
    s_wsle(&io___67);
#line 1160 ""
    do_lio(&c__9, &c__1, "Final error:", (ftnlen)12);
#line 1160 ""
    do_lio(&c__4, &c__1, (char *)&devnorm0, (ftnlen)sizeof(real));
#line 1160 ""
    do_lio(&c__9, &c__1, ", initial error:", (ftnlen)16);
#line 1160 ""
    do_lio(&c__4, &c__1, (char *)&devpmx, (ftnlen)sizeof(real));
#line 1160 ""
    e_wsle();
#line 1161 ""
    s_wsle(&io___68);
#line 1161 ""
    do_lio(&c__9, &c__1, "Percentage improvement:", (ftnlen)23);
#line 1161 ""
    r__1 = (1 - devnorm0 / devpmx) * 100.f;
#line 1161 ""
    do_lio(&c__4, &c__1, (char *)&r__1, (ftnlen)sizeof(real));
#line 1161 ""
    e_wsle();
#line 1162 ""
    s_wsle(&io___69);
#line 1162 ""
    do_lio(&c__9, &c__1, "Percentage improvement:", (ftnlen)23);
#line 1162 ""
    r__1 = (1 - devnorm0 / devpmx) * 100.f;
#line 1162 ""
    do_lio(&c__4, &c__1, (char *)&r__1, (ftnlen)sizeof(real));
#line 1162 ""
    e_wsle();
#line 1163 ""
    printl_("Initial bars/system:", (ftnlen)20);
#line 1164 ""
    s_wsfe(&io___70);
#line 1164 ""
    i__1 = nsyst;
#line 1164 ""
    for (isys = 1; isys <= i__1; ++isys) {
#line 1164 ""
	do_fio(&c__1, (char *)&nbari[isys - 1], (ftnlen)sizeof(integer));
#line 1164 ""
    }
#line 1164 ""
    e_wsfe();
#line 1165 ""
    s_wsfe(&io___71);
#line 1165 ""
    i__1 = nsyst;
#line 1165 ""
    for (isys = 1; isys <= i__1; ++isys) {
#line 1165 ""
	do_fio(&c__1, (char *)&nbari[isys - 1], (ftnlen)sizeof(integer));
#line 1165 ""
    }
#line 1165 ""
    e_wsfe();
#line 1166 ""
    printl_("Final bars/system:", (ftnlen)18);
#line 1167 ""
    s_wsfe(&io___72);
#line 1167 ""
    i__1 = nsyst;
#line 1167 ""
    for (isys = 1; isys <= i__1; ++isys) {
#line 1167 ""
	do_fio(&c__1, (char *)&nbars0[isys - 1], (ftnlen)sizeof(integer));
#line 1167 ""
    }
#line 1167 ""
    e_wsfe();
#line 1168 ""
    s_wsfe(&io___73);
#line 1168 ""
    i__1 = nsyst;
#line 1168 ""
    for (isys = 1; isys <= i__1; ++isys) {
#line 1168 ""
	do_fio(&c__1, (char *)&nbars0[isys - 1], (ftnlen)sizeof(integer));
#line 1168 ""
    }
#line 1168 ""
    e_wsfe();
#line 1169 ""
    pmxa_(jobname, &ljob4, &c_false, &nsyst, nbars0, &optimize, (ftnlen)44);
#line 1170 ""
    pmxb_(&c_true, poe0, &ncalls, &optimize);
#line 1171 ""
    cl__1.cerr = 0;
#line 1171 ""
    cl__1.cunit = 15;
#line 1171 ""
    cl__1.csta = 0;
#line 1171 ""
    f_clos(&cl__1);
#line 1172 ""
    return 0;
} /* MAIN__ */

/* Subroutine */ int accsym_(integer *nacc, char *acsymq, integer *lacc, 
	ftnlen acsymq_len)
{
    /* Builtin functions */
    /* Subroutine */ int s_copy(char *, char *, ftnlen, ftnlen);
    integer s_wsle(cilist *), do_lio(integer *, integer *, char *, ftnlen), 
	    e_wsle(void);

    /* Local variables */
    static integer iacc;

    /* Fortran I/O blocks */
    static cilist io___75 = { 0, 6, 0, 0, 0 };


#line 1175 ""
    iacc = *nacc & 7;
#line 1176 ""
    if (iacc == 1) {
#line 1177 ""
	s_copy(acsymq, "fl", (ftnlen)3, (ftnlen)2);
#line 1178 ""
	*lacc = 2;
#line 1179 ""
    } else if (iacc == 2) {
#line 1180 ""
	s_copy(acsymq, "sh", (ftnlen)3, (ftnlen)2);
#line 1181 ""
	*lacc = 2;
#line 1182 ""
    } else if (iacc == 3) {
#line 1183 ""
	s_copy(acsymq, "na", (ftnlen)3, (ftnlen)2);
#line 1184 ""
	*lacc = 2;
#line 1185 ""
    } else if (iacc == 5) {
#line 1186 ""
	s_copy(acsymq, "dfl", (ftnlen)3, (ftnlen)3);
#line 1187 ""
	*lacc = 3;
#line 1188 ""
    } else if (iacc == 6) {
#line 1189 ""
	s_copy(acsymq, "dsh", (ftnlen)3, (ftnlen)3);
#line 1190 ""
	*lacc = 3;
#line 1191 ""
    } else {
#line 1192 ""
	s_wsle(&io___75);
#line 1192 ""
	do_lio(&c__9, &c__1, "bad accidental: ", (ftnlen)16);
#line 1192 ""
	do_lio(&c__3, &c__1, (char *)&iacc, (ftnlen)sizeof(integer));
#line 1192 ""
	e_wsle();
#line 1193 ""
    }
#line 1194 ""
    return 0;
} /* accsym_ */

/* Subroutine */ int addask_(real *taskn, real *waskn, real *elaskn, real *
	fixednew, real *scaldold, real *tglp1, real *scfac, logical *isudsp)
{
    /* System generated locals */
    integer i__1;
    real r__1;

    /* Builtin functions */
    integer s_wsle(cilist *), do_lio(integer *, integer *, char *, ftnlen), 
	    e_wsle(void);

    /* Local variables */
    static real oldelask;
    extern /* Subroutine */ int stop1_(void);
    static integer iudsp;
    static real scoarg, oldwask;

    /* Fortran I/O blocks */
    static cilist io___78 = { 0, 6, 0, 0, 0 };


#line 1203 ""
    scoarg = *scaldold * *scfac;
#line 1204 ""
    if (*isudsp) {

/*  Find which udsp we're dealing with */

#line 1208 ""
	i__1 = comudsp_1.nudsp;
#line 1208 ""
	for (iudsp = 1; iudsp <= i__1; ++iudsp) {
#line 1209 ""
	    if ((r__1 = *taskn + *tglp1 - comudsp_1.tudsp[iudsp - 1], dabs(
		    r__1)) < comtol_1.tol) {
#line 1209 ""
		goto L2;
#line 1209 ""
	    }
#line 1210 ""
/* L1: */
#line 1210 ""
	}
#line 1211 ""
	s_wsle(&io___78);
#line 1211 ""
	do_lio(&c__9, &c__1, "You should note BEEE here in addask!", (ftnlen)
		36);
#line 1211 ""
	e_wsle();
#line 1212 ""
	stop1_();
#line 1213 ""
L2:

/*  Fixednew and scaldold must not be changed, since udsp's are already included */
/*  in fsyst from pmxa, and udsp don't involve scaled space.. */

#line 1218 ""
	if (comas1_1.naskb > 0 && (r__1 = *taskn - comas1_1.task[max(1,
		comas1_1.naskb) - 1], dabs(r__1)) < comtol_1.tol) {

/*  Must add user-defined space to what's there already. */

#line 1222 ""
	    comas1_1.wask[comas1_1.naskb - 1] += comudsp_1.udsp[iudsp - 1];
#line 1223 ""
	} else {

/*  This place has no other space. */

#line 1227 ""
	    ++comas1_1.naskb;
#line 1228 ""
	    comas1_1.task[comas1_1.naskb - 1] = *taskn;
#line 1229 ""
	    comas1_1.wask[comas1_1.naskb - 1] = comudsp_1.udsp[iudsp - 1];
#line 1230 ""
	    comas1_1.elask[comas1_1.naskb - 1] = 0.f;
#line 1231 ""
	}
#line 1232 ""
    } else {
/* 130330 start */
#line 1234 ""
	oldwask = 0.f;
#line 1235 ""
	oldelask = 0.f;
/* 130330 end */

/*  This is a normal space, no effect if smaller than existing space */

#line 1240 ""
	if (comas1_1.naskb > 0 && (r__1 = *taskn - comas1_1.task[max(1,
		comas1_1.naskb) - 1], dabs(r__1)) < comtol_1.tol) {

/*  We already put in some space at this time */
/*  Check if new one needs more space than old one at same time */

#line 1245 ""
	    if (*waskn > comas1_1.wask[comas1_1.naskb - 1]) {

/* 130330 We were double counting the larger space when it came 2nd */
/* Need to fix but don't see how yet. Assume times came in order and */
/* that last naskb defined spaces that need updating */

#line 1251 ""
		oldwask = comas1_1.wask[comas1_1.naskb - 1];
#line 1252 ""
		oldelask = comas1_1.elask[comas1_1.naskb - 1];
/* End of 130330 insertions */
#line 1254 ""
		--comas1_1.naskb;
#line 1255 ""
	    } else {
#line 1256 ""
		return 0;
#line 1257 ""
	    }
#line 1258 ""
	}
#line 1259 ""
	++comas1_1.naskb;
#line 1260 ""
	comas1_1.task[comas1_1.naskb - 1] = *taskn;
#line 1261 ""
	comas1_1.wask[comas1_1.naskb - 1] = *waskn;
#line 1262 ""
	comas1_1.elask[comas1_1.naskb - 1] = *elaskn;
/* 130330 start */
/*        fixednew = fixednew+waskn */
/*        scaldold = scaldold+elaskn */
#line 1266 ""
	*fixednew = *fixednew + *waskn - oldwask;
#line 1267 ""
	*scaldold = scoarg + *elaskn - oldelask;
/* 130330 end */
#line 1269 ""
    }
#line 1270 ""
    return 0;
} /* addask_ */

/* Subroutine */ int addblank_(char *noteq, integer *lnoten, ftnlen noteq_len)
{
    /* System generated locals */
    address a__1[2];
    integer i__1[2];

    /* Builtin functions */
    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);

    /* Local variables */
    static char tchar[1];

#line 1275 ""
    *(unsigned char *)tchar = *(unsigned char *)noteq;
/* Writing concatenation */
#line 1276 ""
    i__1[0] = 1, a__1[0] = " ";
#line 1276 ""
    i__1[1] = 1, a__1[1] = tchar;
#line 1276 ""
    s_cat(noteq, a__1, i__1, &c__2, (ftnlen)8);
#line 1277 ""
    *lnoten = 2;
#line 1278 ""
    return 0;
} /* addblank_ */

/* Subroutine */ int addfb_(integer *nfb, integer *iv, real *tnew, real *t1fb,
	 real *t2fb, char *ulfbq, integer *ifbadd, ftnlen ulfbq_len)
{
    static integer ifb;

#line 1286 ""
    /* Parameter adjustments */
#line 1286 ""
    ulfbq -= 25;
#line 1286 ""
    t2fb -= 25;
#line 1286 ""
    t1fb -= 25;
#line 1286 ""
    --nfb;
#line 1286 ""

#line 1286 ""
    /* Function Body */
#line 1286 ""
    *ifbadd = 1;
#line 1287 ""
    ++nfb[*iv];
#line 1288 ""
    for (ifb = nfb[*iv] - 1; ifb >= 1; --ifb) {
#line 1289 ""
	if (*tnew < t1fb[*iv + ifb * 24] - comtol_1.tol) {
#line 1290 ""
	    t1fb[*iv + (ifb + 1) * 24] = t1fb[*iv + ifb * 24];
#line 1291 ""
	    t2fb[*iv + (ifb + 1) * 24] = t2fb[*iv + ifb * 24];
#line 1292 ""
	    *(unsigned char *)&ulfbq[*iv + (ifb + 1) * 24] = *(unsigned char *
		    )&ulfbq[*iv + ifb * 24];
#line 1293 ""
	} else {
#line 1294 ""
	    *ifbadd = ifb + 1;
#line 1295 ""
	    goto L2;
#line 1296 ""
	}
#line 1297 ""
/* L1: */
#line 1297 ""
    }
#line 1298 ""
L2:
#line 1299 ""
    t1fb[*iv + *ifbadd * 24] = *tnew;
#line 1300 ""
    *(unsigned char *)&ulfbq[*iv + *ifbadd * 24] = 'x';
#line 1301 ""
    return 0;
} /* addfb_ */

/* Subroutine */ int addmidi_(integer *icm, integer *nolev, integer *iacc, 
	integer *midisig, real *time, logical *rest, logical *endrest)
{
    /* Initialized data */

    static shortint icmm[16] = { 0,1,2,3,4,5,6,7,8,10,11,12,13,14,15,16 };

    /* System generated locals */
    integer i__1, i__2, i__3;
    real r__1;

    /* Builtin functions */
    integer i_nint(real *), s_wsle(cilist *), do_lio(integer *, integer *, 
	    char *, ftnlen), e_wsle(void), i_indx(char *, char *, ftnlen, 
	    ftnlen);

    /* Local variables */
    static logical it1found;
    static integer nsav4tie;
    extern /* Subroutine */ int chkimidi_(integer *);
    static char notenumq[1];
    static integer i__, j, it1;
    extern integer igetvarlen_(shortint *, integer *, integer *, integer *);
    static integer it2;
    extern integer isetvarlen_(integer *, integer *);
    static integer ion;
    static shortint itk[25];
    static integer jacc, kacc, macc, ioff, isav, idur, jsav, idur1;
    extern /* Subroutine */ int stop1_(void);
    static integer imidt, ipsav, ipsav0, nby2on;
    extern integer iashft_(integer *);
    static integer nbytes;
    extern /* Subroutine */ int printl_(char *, ftnlen);
    static integer nby2off;
    static logical eximacc;
    static integer itiesav[500]	/* was [5][100] */, idurvar;

    /* Fortran I/O blocks */
    static cilist io___88 = { 0, 6, 0, 0, 0 };
    static cilist io___100 = { 0, 6, 0, 0, 0 };


/*      subroutine addmidi(icm,nolev,iacc,isig,time,rest,endrest) */
/*      common /commidisig/ midisig(nm) */

/*  Following variables are local but must be saved.  I hope they are. */
/*  (3/18/00) With g77 they are not, so add a common block here. */

/*      integer*2 ipslon(0:nm),lusebl(10),jusebl(10),icmm(0:12) */
/*      data icmm /0,1,2,3,4,5,6,7,8,10,11,12,13/ */

/*  Cancel out barline accidentals if there's a rest. */

#line 1341 ""
    if (*rest) {
#line 1341 ""
	comslm_1.naccbl[(300 + (0 + (*icm - 0 << 2)) - 300) / 4] = 0;
#line 1341 ""
    }

/*  Special path to insert dummy rest at end of a section */

#line 1345 ""
    if (*endrest) {
#line 1345 ""
	goto L20;
#line 1345 ""
    }

#line 1347 ""
    i__1 = commidi_1.nmidcrd;
#line 1347 ""
    for (ion = 0; ion <= i__1; ++ion) {

/*  check if this is only to get pitch of a chord note */

#line 1351 ""
	if (commidi_1.notmain) {
#line 1351 ""
	    goto L6;
#line 1351 ""
	}

/*  check for rest */

#line 1355 ""
	if (*rest) {

/*  Will not put in a note, but must update timing */

#line 1359 ""
	    if (! commidi_1.restpend[*icm]) {

/*  First rest in sequence, save the time */

#line 1363 ""
		commidi_1.restpend[*icm] = TRUE_;
#line 1364 ""
		commidi_1.trest[*icm] = *time;
#line 1365 ""
	    } else {
#line 1366 ""
		commidi_1.trest[*icm] += *time;
#line 1367 ""
	    }

/*  Note: code checkers don't like the above due to calling addmidi(trest(icm)) */
/*    but this only happens if rest at end of section (endrest=.true.) (called */
/*    from getmidi(), in which case these above lines are bypassed. */

#line 1373 ""
	    chkimidi_(icm);
#line 1374 ""
	    return 0;
#line 1375 ""
	}

/*  time tics */

#line 1379 ""
	if (commidi_1.imidi[*icm] > 0 && ion == 0) {
#line 1380 ""
	    idur = commidi_1.mgap;
#line 1381 ""
	} else {
#line 1382 ""
	    idur = 0;
#line 1383 ""
	}
#line 1384 ""
	if (commidi_1.restpend[*icm]) {
#line 1385 ""
	    commidi_1.restpend[*icm] = FALSE_;
#line 1386 ""
	    r__1 = commidi_1.trest[*icm] * 15;
#line 1386 ""
	    idur += i_nint(&r__1);
#line 1387 ""
	}

/*  time to start of note */

#line 1391 ""
	idurvar = isetvarlen_(&idur, &nby2on);
#line 1392 ""
	if (nby2on > 4) {
#line 1393 ""
	    s_wsle(&io___88);
#line 1393 ""
	    do_lio(&c__9, &c__1, "You got >4 bytes, something is bogus.", (
		    ftnlen)37);
#line 1393 ""
	    e_wsle();
#line 1394 ""
	    stop1_();
#line 1395 ""
	}
#line 1396 ""
	++commidi_1.imidi[*icm];
#line 1397 ""
	i__2 = nby2on;
#line 1397 ""
	for (i__ = 1; i__ <= i__2; ++i__) {

/*  imidi points to cell before highest (leftmost) byte.  Start with lowest byte */
/*    at far right, fill in backwards */

#line 1402 ""
	    commidi_1.mmidi[*icm + (commidi_1.imidi[*icm] + nby2on - i__) * 
		    25 - 25] = (shortint) (idurvar % 256);
#line 1403 ""
	    if (nby2on > 1) {
#line 1403 ""
		idurvar /= 256;
#line 1403 ""
	    }
#line 1404 ""
/* L2: */
#line 1404 ""
	}
#line 1405 ""
	commidi_1.imidi[*icm] = commidi_1.imidi[*icm] + nby2on - 1;

/*  Note-on signal */

#line 1409 ""
	++commidi_1.imidi[*icm];
#line 1410 ""
	commidi_1.mmidi[*icm + commidi_1.imidi[*icm] * 25 - 25] = (shortint) (
		icmm[*icm] + 144);

/*  Entry point for chord note pitch determination */

#line 1414 ""
L6:

/*  Get midi pitch.  On chord iteration, only do this first time (main note), */
/*  since pitch was already computed for nonmain chord notes. */

#line 1419 ""
	if (ion == 0) {
#line 1420 ""
	    ipsav = *nolev * 12.f / 7 + 11;
#line 1421 ""
	    ipsav0 = ipsav;
#line 1422 ""
	    if (*midisig != 0) {

/*  Adjust for signature */

#line 1426 ""
		*(unsigned char *)notenumq = (char) (*nolev % 7 + 48);
#line 1427 ""
		if (*midisig >= i_indx("4152630", notenumq, (ftnlen)7, (
			ftnlen)1)) {
#line 1428 ""
		    ++ipsav;
#line 1429 ""
		} else if (-(*midisig) >= i_indx("0362514", notenumq, (ftnlen)
			7, (ftnlen)1)) {
#line 1430 ""
		    --ipsav;
#line 1431 ""
		}
#line 1432 ""
	    }

/*  Deal with accidentals. */

/*  iacc   0   1   2   3   4   5   6   7 */
/* effect  X   fl  sh  na  X  dfl dsh  X */
/* iashft  X   -1  1   0   X  -2   2   X */

#line 1440 ""
	    jacc = 0;
#line 1441 ""
	    eximacc = FALSE_;
#line 1442 ""
	    if (*iacc > 0) {

/*  Adjust key-sig-adjusted pitch for explicit accidental (and exit) */

#line 1446 ""
		jacc = iashft_(iacc);
#line 1447 ""
		eximacc = TRUE_;
#line 1448 ""
		if (! commidi_1.relacc) {
#line 1448 ""
		    jacc = jacc + ipsav0 - ipsav;
#line 1448 ""
		}

/*  (Above) Shift applies to diatonic pitch but will be added to adjusted one */

#line 1452 ""
	    } else if (commidi_1.naccim[*icm] > 0) {

/*  Possible implicit accidental from earlier in the bar */
/*    Check for prior accid in this bar at this note level */

#line 1457 ""
		i__2 = commidi_1.naccim[*icm];
#line 1457 ""
		for (kacc = 1; kacc <= i__2; ++kacc) {
#line 1458 ""
		    if (commidi_1.laccim[*icm + kacc * 25 - 25] == *nolev) {
#line 1459 ""
			jacc = commidi_1.jaccim[*icm + kacc * 25 - 25];
#line 1460 ""
			eximacc = TRUE_;
#line 1461 ""
			if (! commidi_1.relacc) {
#line 1461 ""
			    jacc = jacc + ipsav0 - ipsav;
#line 1461 ""
			}
#line 1462 ""
			goto L4;
#line 1463 ""
		    }
#line 1464 ""
/* L3: */
#line 1464 ""
		}
#line 1465 ""
L4:
#line 1466 ""
		;
#line 1466 ""
	    }

/*  Must split off the following if block from those above because chord */
/*  notes can cause naccim>0, forcing us to miss other chord note's */
/*  accross-bar-line accidental */

#line 1472 ""
	    if (comslm_1.naccbl[*icm] > 0 && ! eximacc) {

/*  Possible carryover accid from prior bar (or prior same-pitch note). */

#line 1476 ""
		i__2 = comslm_1.naccbl[*icm];
#line 1476 ""
		for (kacc = 1; kacc <= i__2; ++kacc) {
#line 1477 ""
		    if (comslm_1.laccbl[*icm + kacc * 25 - 25] == *nolev) {
#line 1478 ""
			jacc = comslm_1.jaccbl[*icm + kacc * 25 - 25];

/*  Since we are *using* the bar-line accid, must flag it to be saved for next. */

#line 1482 ""
			++comslm_1.nusebl;
#line 1483 ""
			comips_1.jusebl[comslm_1.nusebl - 1] = (shortint) 
				jacc;
#line 1484 ""
			comips_1.lusebl[comslm_1.nusebl - 1] = (shortint) (*
				nolev);
#line 1485 ""
			if (! commidi_1.relacc) {
#line 1485 ""
			    jacc = jacc + ipsav0 - ipsav;
#line 1485 ""
			}
#line 1486 ""
			goto L22;
#line 1487 ""
		    }
#line 1488 ""
/* L21: */
#line 1488 ""
		}
#line 1489 ""
L22:
#line 1490 ""
		;
#line 1490 ""
	    }
#line 1491 ""
	    ipsav += jacc;
#line 1492 ""
	}
#line 1493 ""
	if (commidi_1.notmain) {
#line 1494 ""
	    commidi_1.mcpitch[commidi_1.nmidcrd - 1] = ipsav;

/*  Save pitch for tie checks */

#line 1498 ""
	    if (comslm_1.levson[*icm] == *nolev && ! comslm_1.slmon[*icm]) {
#line 1498 ""
		comips_1.ipslon[*icm] = (shortint) ipsav;
#line 1498 ""
	    }
#line 1500 ""
	} else {
#line 1501 ""
	    ++commidi_1.imidi[*icm];
#line 1502 ""
	    if (ion == 0) {
#line 1503 ""
		commidi_1.mmidi[*icm + commidi_1.imidi[*icm] * 25 - 25] = (
			shortint) ipsav;
#line 1504 ""
		if (comslm_1.levson[*icm] == *nolev && ! comslm_1.slmon[*icm])
			 {
#line 1504 ""
		    comips_1.ipslon[*icm] = (shortint) ipsav;
#line 1504 ""
		}
#line 1506 ""
	    } else {
#line 1507 ""
		commidi_1.mmidi[*icm + commidi_1.imidi[*icm] * 25 - 25] = (
			shortint) commidi_1.mcpitch[ion - 1];
#line 1508 ""
	    }
#line 1509 ""
	}
#line 1510 ""
	if (ion == 0) {

/*  Only record accids for non-chords, main chord note during chord iteration */
/*    and chordnotes on first call but not during iteration */

#line 1515 ""
	    if (*iacc > 0) {

/*  Set marker for accidental for possible continuations later this bar */
/*    but first check and clear earlier ones on same note. */

#line 1520 ""
		i__2 = commidi_1.naccim[*icm];
#line 1520 ""
		for (kacc = 1; kacc <= i__2; ++kacc) {
#line 1521 ""
		    if (commidi_1.laccim[*icm + kacc * 25 - 25] == *nolev) {
#line 1522 ""
			i__3 = commidi_1.naccim[*icm] - 1;
#line 1522 ""
			for (macc = kacc; macc <= i__3; ++macc) {
#line 1523 ""
			    commidi_1.laccim[*icm + macc * 25 - 25] = 
				    commidi_1.laccim[*icm + (macc + 1) * 25 - 
				    25];
#line 1524 ""
			    commidi_1.jaccim[*icm + macc * 25 - 25] = 
				    commidi_1.jaccim[*icm + (macc + 1) * 25 - 
				    25];
#line 1525 ""
/* L24: */
#line 1525 ""
			}
#line 1526 ""
			goto L25;
#line 1527 ""
		    }
#line 1528 ""
/* L23: */
#line 1528 ""
		}
#line 1529 ""
		goto L26;
#line 1530 ""
L25:
#line 1531 ""
		--commidi_1.naccim[*icm];
#line 1532 ""
L26:

/*  Flag new accidental */

#line 1536 ""
		++commidi_1.naccim[*icm];
#line 1537 ""
		commidi_1.laccim[*icm + commidi_1.naccim[*icm] * 25 - 25] = *
			nolev;
#line 1538 ""
		commidi_1.jaccim[*icm + commidi_1.naccim[*icm] * 25 - 25] = 
			iashft_(iacc);
#line 1539 ""
	    }

/*  Bail if this is a chord note on the first call (from docrd) */

#line 1543 ""
	    if (commidi_1.notmain) {
#line 1544 ""
		chkimidi_(icm);
#line 1545 ""
		return 0;
#line 1546 ""
	    }
#line 1547 ""
	}

/*  Vel */

#line 1551 ""
	++commidi_1.imidi[*icm];
#line 1552 ""
	commidi_1.mmidi[*icm + commidi_1.imidi[*icm] * 25 - 25] = (shortint) 
		commvel_1.midvelc[*icm];
#line 1553 ""
	chkimidi_(icm);
#line 1554 ""
/* L7: */
#line 1554 ""
    }

/*  For tie checks */

#line 1558 ""
    if (comslm_1.levson[*icm] > 0 && ! comslm_1.slmon[*icm]) {
#line 1558 ""
	comslm_1.imidso[*icm] = commidi_1.imidi[*icm];
#line 1558 ""
    }

/*  Entry point for special rests at section ends (endrest=T) */

#line 1562 ""
L20:

/*  Now insert all the ends */

#line 1566 ""
    i__1 = commidi_1.nmidcrd;
#line 1566 ""
    for (ioff = 0; ioff <= i__1; ++ioff) {
#line 1567 ""
	if (ioff == 0) {

/*  time to end */

#line 1571 ""
	    r__1 = *time * 15;
#line 1571 ""
	    idur1 = i_nint(&r__1);
#line 1572 ""
	    r__1 = commidi_1.trest[*icm] * 15;
#line 1572 ""
	    if (! (*endrest) || comevent_1.miditime == i_nint(&r__1)) {
#line 1573 ""
		idur = idur1 - commidi_1.mgap;
#line 1574 ""
	    } else {
#line 1575 ""
		idur = idur1;
#line 1576 ""
	    }

/*  Deal with roundoff problems with 7-tuplets on half or quarters */

#line 1580 ""
	    if (idur1 == 69) {
#line 1581 ""
		++comdiag_1.n69[*icm];
/*            if (mod(n69(icm)+6,7) .gt. 3) idur = 58 */
#line 1583 ""
		if ((comdiag_1.n69[*icm] + 6) % 7 > 3) {
#line 1583 ""
		    idur = idur1 - commidi_1.mgap - 1;
#line 1583 ""
		}
#line 1584 ""
	    } else if (idur1 == 34) {
#line 1585 ""
		++comdiag_1.n34[*icm];
#line 1586 ""
		if ((comdiag_1.n34[*icm] + 6) % 7 > 4) {
#line 1586 ""
		    idur = idur1 - commidi_1.mgap + 1;
#line 1586 ""
		}
#line 1587 ""
	    }
#line 1588 ""
	    idurvar = isetvarlen_(&idur, &nby2off);
#line 1589 ""
	    if (nby2off > 4) {
#line 1590 ""
		s_wsle(&io___100);
#line 1590 ""
		do_lio(&c__9, &c__1, "You got >4 bytes, something is bogus.", 
			(ftnlen)37);
#line 1590 ""
		e_wsle();
#line 1591 ""
		stop1_();
#line 1592 ""
	    }
#line 1593 ""
	    ++commidi_1.imidi[*icm];
#line 1594 ""
	    chkimidi_(icm);
#line 1595 ""
	    i__2 = nby2off;
#line 1595 ""
	    for (i__ = 1; i__ <= i__2; ++i__) {
#line 1596 ""
		commidi_1.mmidi[*icm + (commidi_1.imidi[*icm] + nby2off - i__)
			 * 25 - 25] = (shortint) (idurvar % 256);
#line 1597 ""
		if (nby2off > 1) {
#line 1597 ""
		    idurvar /= 256;
#line 1597 ""
		}
#line 1598 ""
/* L1: */
#line 1598 ""
	    }
#line 1599 ""
	    commidi_1.imidi[*icm] = commidi_1.imidi[*icm] + nby2off - 1;
#line 1600 ""
	} else {

/*  Inserting end of chord note, delta time is 0 */

#line 1604 ""
	    ++commidi_1.imidi[*icm];
#line 1605 ""
	    commidi_1.mmidi[*icm + commidi_1.imidi[*icm] * 25 - 25] = 0;
#line 1606 ""
	}

/*  Note off */

#line 1610 ""
	++commidi_1.imidi[*icm];
#line 1611 ""
	commidi_1.mmidi[*icm + commidi_1.imidi[*icm] * 25 - 25] = (shortint) (
		icmm[*icm] + 128);

/*  Pitch */

#line 1615 ""
	++commidi_1.imidi[*icm];
#line 1616 ""
	if (ioff == 0) {
#line 1617 ""
	    commidi_1.mmidi[*icm + commidi_1.imidi[*icm] * 25 - 25] = (
		    shortint) ipsav;
#line 1618 ""
	} else {
#line 1619 ""
	    commidi_1.mmidi[*icm + commidi_1.imidi[*icm] * 25 - 25] = (
		    shortint) commidi_1.mcpitch[ioff - 1];
#line 1620 ""
	}

/*  Vel */

#line 1624 ""
	++commidi_1.imidi[*icm];
#line 1625 ""
	commidi_1.mmidi[*icm + commidi_1.imidi[*icm] * 25 - 25] = 0;
#line 1626 ""
	chkimidi_(icm);
#line 1627 ""
	if (*endrest) {
#line 1628 ""
	    return 0;
#line 1629 ""
	}
#line 1630 ""
/* L8: */
#line 1630 ""
    }
#line 1631 ""
    comslm_1.naccbl[*icm] = comslm_1.nusebl;
#line 1632 ""
    if (comslm_1.nusebl > 0) {

/*  Fix tables of "bar-line" accids that are saved due to consecutive notes. */

#line 1636 ""
	i__1 = comslm_1.nusebl;
#line 1636 ""
	for (kacc = 1; kacc <= i__1; ++kacc) {
#line 1637 ""
	    comslm_1.laccbl[*icm + kacc * 25 - 25] = comips_1.lusebl[kacc - 1]
		    ;
#line 1638 ""
	    comslm_1.jaccbl[*icm + kacc * 25 - 25] = comips_1.jusebl[kacc - 1]
		    ;
#line 1639 ""
/* L30: */
#line 1639 ""
	}
#line 1640 ""
	comslm_1.nusebl = 0;
#line 1641 ""
    }

/*  Begin tie checks */

#line 1645 ""
    if (comslm_1.slmon[*icm]) {

/*  Prior note had a slur start */

#line 1649 ""
	if (comslm_1.levson[*icm] == comslm_1.levsoff[*icm] && *iacc == 0) {

/*  We have a tie! (Assumed there would be no accidental on tie-ending note) */
/*  Make a list of times of all events back to the one starting at imidso+1, */
/*    which is at or before where the tie started.  Ident tie start and stop by */
/*    comparing pitches.  Save the 4 pieces of data in itiesav(1...4,nsav4tie) */
/*    Store actual time in itiesav(5,nsav4tie), using itiesav(1,1) as initial */
/*    time. */
#line 1657 ""
	    nsav4tie = 0;
#line 1658 ""
	    imidt = comslm_1.imidso[*icm];
#line 1659 ""
L10:
#line 1659 ""
	    ++nsav4tie;
#line 1660 ""
	    itiesav[nsav4tie * 5 - 5] = igetvarlen_(commidi_1.mmidi, icm, &
		    imidt, &nbytes);
#line 1661 ""
	    imidt += nbytes;
#line 1662 ""
	    for (j = 1; j <= 3; ++j) {
#line 1663 ""
		itiesav[j + 1 + nsav4tie * 5 - 6] = commidi_1.mmidi[*icm + (
			imidt + j) * 25 - 25];
#line 1664 ""
/* L11: */
#line 1664 ""
	    }
#line 1665 ""
	    imidt += 3;
#line 1666 ""
	    if (nsav4tie == 1) {
#line 1667 ""
		itiesav[4] = itiesav[0];
#line 1668 ""
	    } else {
#line 1669 ""
		itiesav[nsav4tie * 5 - 1] = itiesav[nsav4tie * 5 - 5] + 
			itiesav[(nsav4tie - 1) * 5 - 1];
#line 1671 ""
	    }
#line 1672 ""
	    if (imidt != commidi_1.imidi[*icm]) {
#line 1672 ""
		goto L10;
#line 1672 ""
	    }

/*  Find which two pitches agree with saved slur pitch. */

#line 1676 ""
	    it1found = FALSE_;
#line 1677 ""
	    i__1 = nsav4tie;
#line 1677 ""
	    for (it2 = 1; it2 <= i__1; ++it2) {
#line 1678 ""
		if (itiesav[it2 * 5 - 3] == comips_1.ipslon[*icm]) {
#line 1679 ""
		    if (it1found) {
#line 1679 ""
			goto L13;
#line 1679 ""
		    }
#line 1680 ""
		    it1 = it2;
#line 1681 ""
		    it1found = TRUE_;
#line 1682 ""
		}
#line 1683 ""
/* L12: */
#line 1683 ""
	    }
#line 1684 ""
	    printl_("Program error, tied notes, send source to Dr. Don", (
		    ftnlen)49);
#line 1686 ""
	    it1 = nsav4tie + 1;
#line 1687 ""
	    it2 = nsav4tie + 1;
#line 1688 ""
L13:

/*  List the positions we want to keep */

#line 1692 ""
	    jsav = 0;
#line 1693 ""
	    i__1 = nsav4tie;
#line 1693 ""
	    for (isav = 1; isav <= i__1; ++isav) {
#line 1694 ""
		if (isav == it1 || isav == it2) {
#line 1694 ""
		    goto L14;
#line 1694 ""
		}
#line 1695 ""
		++jsav;
#line 1696 ""
		itk[jsav - 1] = (shortint) isav;
#line 1697 ""
L14:
#line 1697 ""
		;
#line 1697 ""
	    }
#line 1698 ""
	    nsav4tie += -2;

/*  Now dump events it1 & it2, recompute times, restack mmidi. */

#line 1702 ""
	    commidi_1.imidi[*icm] = comslm_1.imidso[*icm];
#line 1703 ""
	    i__1 = nsav4tie;
#line 1703 ""
	    for (isav = 1; isav <= i__1; ++isav) {
#line 1704 ""
		if (isav == 1) {
#line 1705 ""
		    idurvar = isetvarlen_(&itiesav[itk[isav - 1] * 5 - 1], &
			    nbytes);
#line 1706 ""
		} else {
#line 1707 ""
		    i__2 = itiesav[itk[isav - 1] * 5 - 1] - itiesav[itk[isav 
			    - 2] * 5 - 1];
#line 1707 ""
		    idurvar = isetvarlen_(&i__2, &nbytes);
#line 1709 ""
		}
#line 1710 ""
		++commidi_1.imidi[*icm];
#line 1711 ""
		i__2 = nbytes;
#line 1711 ""
		for (i__ = 1; i__ <= i__2; ++i__) {
#line 1712 ""
		    commidi_1.mmidi[*icm + (commidi_1.imidi[*icm] + nbytes - 
			    i__) * 25 - 25] = (shortint) (idurvar % 256);
#line 1713 ""
		    if (nbytes > 1) {
#line 1713 ""
			idurvar /= 256;
#line 1713 ""
		    }
#line 1714 ""
/* L16: */
#line 1714 ""
		}
#line 1715 ""
		commidi_1.imidi[*icm] = commidi_1.imidi[*icm] + nbytes - 1;
#line 1716 ""
		for (i__ = 2; i__ <= 4; ++i__) {
#line 1717 ""
		    ++commidi_1.imidi[*icm];
#line 1718 ""
		    commidi_1.mmidi[*icm + commidi_1.imidi[*icm] * 25 - 25] = 
			    (shortint) itiesav[i__ + itk[isav - 1] * 5 - 6];
#line 1719 ""
/* L17: */
#line 1719 ""
		}
#line 1720 ""
/* L15: */
#line 1720 ""
	    }
#line 1721 ""
	}
#line 1722 ""
	comslm_1.slmon[*icm] = FALSE_;
#line 1723 ""
	comslm_1.levsoff[*icm] = 0;
#line 1724 ""
	if (! comslm_1.dbltie) {
#line 1724 ""
	    comslm_1.levson[*icm] = 0;
#line 1724 ""
	}
#line 1725 ""
    }
#line 1726 ""
    if (comslm_1.levson[*icm] > 0) {
#line 1726 ""
	comslm_1.slmon[*icm] = TRUE_;
#line 1726 ""
    }
#line 1727 ""
    if (commidi_1.nmidcrd > 0) {
#line 1727 ""
	commidi_1.nmidcrd = 0;
#line 1727 ""
    }
#line 1728 ""
    chkimidi_(icm);
#line 1729 ""
    return 0;
} /* addmidi_ */

/* Subroutine */ int addstr_(char *notexq, integer *lnote, char *soutq, 
	integer *lsout, ftnlen notexq_len, ftnlen soutq_len)
{
    /* System generated locals */
    address a__1[2];
    integer i__1[2];
    char ch__1[81];

    /* Builtin functions */
    integer s_wsfe(cilist *);
    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
    integer do_fio(integer *, char *, ftnlen), e_wsfe(void);
    /* Subroutine */ int s_copy(char *, char *, ftnlen, ftnlen);

    /* Fortran I/O blocks */
    static cilist io___112 = { 0, 11, 0, "(a)", 0 };


#line 1736 ""
    if (*lsout + *lnote > 72) {
#line 1737 ""
	if (comlast_1.islast) {
#line 1737 ""
	    s_wsfe(&io___112);
/* Writing concatenation */
#line 1737 ""
	    i__1[0] = *lsout, a__1[0] = soutq;
#line 1737 ""
	    i__1[1] = 1, a__1[1] = "%";
#line 1737 ""
	    s_cat(ch__1, a__1, i__1, &c__2, (ftnlen)81);
#line 1737 ""
	    do_fio(&c__1, ch__1, *lsout + 1);
#line 1737 ""
	    e_wsfe();
#line 1737 ""
	}
#line 1738 ""
	*lsout = 0;
#line 1739 ""
    }
#line 1740 ""
    if (*lsout > 0) {
/* Writing concatenation */
#line 1741 ""
	i__1[0] = *lsout, a__1[0] = soutq;
#line 1741 ""
	i__1[1] = *lnote, a__1[1] = notexq;
#line 1741 ""
	s_cat(soutq, a__1, i__1, &c__2, (ftnlen)80);
#line 1742 ""
    } else {
#line 1743 ""
	s_copy(soutq, notexq, (ftnlen)80, (*lnote));
#line 1744 ""
    }
#line 1745 ""
    *lsout += *lnote;
#line 1746 ""
    return 0;
} /* addstr_ */

/* Subroutine */ int adjusteskz_(integer *ib, integer *istart, real *poenom)
{
    /* System generated locals */
    integer i__1, i__2;
    real r__1;

    /* Local variables */
    static integer in, iaskb, inmin;
    static real eskadd;


/*  For block ib, this adds accidental spaces to eskz, for use in getting */
/*  length of xtup bracket and slopes of brackets and beams. */

#line 1772 ""
    /* Parameter adjustments */
#line 1772 ""
    --istart;
#line 1772 ""

#line 1772 ""
    /* Function Body */
#line 1772 ""
    inmin = istart[*ib] + 1;
#line 1773 ""
    i__1 = comas1_1.naskb;
#line 1773 ""
    for (iaskb = 1; iaskb <= i__1; ++iaskb) {
#line 1774 ""
	if (comas1_1.task[iaskb - 1] < all_1.to[istart[*ib] - 1] - 
		comtol_1.tol) {
#line 1774 ""
	    goto L10;
#line 1774 ""
	}
#line 1775 ""
	eskadd = comas1_1.wask[iaskb - 1] / *poenom - comas1_1.elask[iaskb - 
		1];
#line 1776 ""
	i__2 = comntot_1.ntot;
#line 1776 ""
	for (in = inmin; in <= i__2; ++in) {
#line 1777 ""
	    if (all_1.to[in - 1] > comas1_1.task[iaskb - 1] - comtol_1.tol) {
#line 1778 ""
		comeskz2_1.eskz2[all_1.ivxo[in - 1] + all_1.ipo[in - 1] * 24 
			- 25] += eskadd;
#line 1779 ""
		if ((r__1 = all_1.to[in - 1] - comas1_1.task[iaskb - 1], dabs(
			r__1)) < comtol_1.tol) {
#line 1779 ""
		    --inmin;
#line 1779 ""
		}
#line 1780 ""
	    } else {
#line 1781 ""
		++inmin;
#line 1782 ""
	    }
#line 1783 ""
/* L11: */
#line 1783 ""
	}
#line 1784 ""
L10:
#line 1784 ""
	;
#line 1784 ""
    }
#line 1785 ""
    return 0;
} /* adjusteskz_ */

/* Subroutine */ int askfig_(char *pathnameq, integer *lpath, char *basenameq,
	 integer *lbase, logical *figbass, logical *istype0, ftnlen 
	pathnameq_len, ftnlen basenameq_len)
{
    /* System generated locals */
    address a__1[3], a__2[2];
    integer i__1[3], i__2[2], i__3;
    char ch__1[1], ch__2[88], ch__3[15], ch__4[5], ch__5[4];
    olist o__1;
    cllist cl__1;
    alist al__1;

    /* Builtin functions */
    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
    integer f_open(olist *), f_rew(alist *), f_clos(cllist *), s_wsfe(cilist *
	    ), do_fio(integer *, char *, ftnlen), e_wsfe(void), s_rsfe(cilist 
	    *), e_rsfe(void), s_cmp(char *, char *, ftnlen, ftnlen), s_wsfi(
	    icilist *), e_wsfi(void), i_indx(char *, char *, ftnlen, ftnlen);

    /* Local variables */
    static integer il;
    static char sq[1];
    static integer ihs;
    extern /* Character */ VOID chax_(char *, ftnlen, integer *);
    static logical done;
    extern integer llen_(char *, integer *, ftnlen);
    static char outq[129];
    extern /* Subroutine */ int moveln_(integer *, integer *, logical *);
    static integer lenout;
    extern /* Subroutine */ int putast_(real *, integer *, char *, ftnlen);
    static integer indxask;

    /* Fortran I/O blocks */
    static cilist io___120 = { 0, 12, 0, "(a)", 0 };
    static cilist io___121 = { 0, 12, 0, "(a)", 0 };
    static cilist io___123 = { 0, 11, 1, "(a129)", 0 };
    static icilist io___125 = { 0, outq+11, 0, "(f4.1)", 4, 1 };
    static cilist io___128 = { 0, 12, 0, "(a)", 0 };
    static cilist io___129 = { 0, 16, 1, "(a129)", 0 };
    static cilist io___130 = { 0, 12, 0, "(a)", 0 };


#line 1797 ""
    chax_(ch__1, (ftnlen)1, &c__92);
#line 1797 ""
    *(unsigned char *)sq = *(unsigned char *)&ch__1[0];
#line 1798 ""
    o__1.oerr = 0;
#line 1798 ""
    o__1.ounit = 12;
#line 1798 ""
    o__1.ofnmlen = *lpath + *lbase + 4;
/* Writing concatenation */
#line 1798 ""
    i__1[0] = *lpath, a__1[0] = pathnameq;
#line 1798 ""
    i__1[1] = *lbase, a__1[1] = basenameq;
#line 1798 ""
    i__1[2] = 4, a__1[2] = ".tex";
#line 1798 ""
    s_cat(ch__2, a__1, i__1, &c__3, (ftnlen)88);
#line 1798 ""
    o__1.ofnm = ch__2;
#line 1798 ""
    o__1.orl = 0;
#line 1798 ""
    o__1.osta = 0;
#line 1798 ""
    o__1.oacc = 0;
#line 1798 ""
    o__1.ofm = 0;
#line 1798 ""
    o__1.oblnk = 0;
#line 1798 ""
    f_open(&o__1);

/*  Transfer first 5 lines of main internal TeX file */

#line 1802 ""
    for (il = 1; il <= 5; ++il) {
#line 1803 ""
	moveln_(&c__11, &c__12, &done);
#line 1804 ""
/* L11: */
#line 1804 ""
    }
#line 1805 ""
    if (*istype0) {

/*  Transfer literal TeX stuff from special scratch file */

#line 1809 ""
	al__1.aerr = 0;
#line 1809 ""
	al__1.aunit = 17;
#line 1809 ""
	f_rew(&al__1);
#line 1810 ""
L10:
#line 1810 ""
	moveln_(&c__17, &c__12, &done);
#line 1811 ""
	if (! done) {
#line 1811 ""
	    goto L10;
#line 1811 ""
	}
#line 1812 ""
	cl__1.cerr = 0;
#line 1812 ""
	cl__1.cunit = 17;
#line 1812 ""
	cl__1.csta = 0;
#line 1812 ""
	f_clos(&cl__1);
#line 1813 ""
    }

/*  Transfer next 2 lines from main scratch file */

#line 1817 ""
    for (il = 1; il <= 2; ++il) {
#line 1818 ""
	moveln_(&c__11, &c__12, &done);
#line 1819 ""
/* L3: */
#line 1819 ""
    }
#line 1820 ""
    if (compoi_1.ispoi) {
#line 1820 ""
	s_wsfe(&io___120);
/* Writing concatenation */
#line 1820 ""
	i__2[0] = 1, a__2[0] = sq;
#line 1820 ""
	i__2[1] = 14, a__2[1] = "input musixpoi";
#line 1820 ""
	s_cat(ch__3, a__2, i__2, &c__2, (ftnlen)15);
#line 1820 ""
	do_fio(&c__1, ch__3, (ftnlen)15);
#line 1820 ""
	e_wsfe();
#line 1820 ""
    }
#line 1821 ""
    if (combbm_1.isbbm) {
#line 1821 ""
	s_wsfe(&io___121);
/* Writing concatenation */
#line 1821 ""
	i__2[0] = 1, a__2[0] = sq;
#line 1821 ""
	i__2[1] = 14, a__2[1] = "input musixbbm";
#line 1821 ""
	s_cat(ch__3, a__2, i__2, &c__2, (ftnlen)15);
#line 1821 ""
	do_fio(&c__1, ch__3, (ftnlen)15);
#line 1821 ""
	e_wsfe();
#line 1821 ""
    }
#line 1822 ""
    if (*figbass) {

/*  Transfer .fig data from scratch (unit 14) into external .tex (unit 12) */

#line 1826 ""
L4:
#line 1826 ""
	moveln_(&c__14, &c__12, &done);
#line 1827 ""
	if (! done) {
#line 1827 ""
	    goto L4;
#line 1827 ""
	}
#line 1828 ""
	cl__1.cerr = 0;
#line 1828 ""
	cl__1.cunit = 14;
#line 1828 ""
	cl__1.csta = 0;
#line 1828 ""
	f_clos(&cl__1);
#line 1829 ""
    }
#line 1830 ""
    comas3_1.iask = 0;
#line 1831 ""
    ihs = 0;
#line 1832 ""
L1:
#line 1832 ""
    i__3 = s_rsfe(&io___123);
#line 1832 ""
    if (i__3 != 0) {
#line 1832 ""
	goto L999;
#line 1832 ""
    }
#line 1832 ""
    i__3 = do_fio(&c__1, outq, (ftnlen)129);
#line 1832 ""
    if (i__3 != 0) {
#line 1832 ""
	goto L999;
#line 1832 ""
    }
#line 1832 ""
    i__3 = e_rsfe();
#line 1832 ""
    if (i__3 != 0) {
#line 1832 ""
	goto L999;
#line 1832 ""
    }

/*  Hardspaces. */

/* Writing concatenation */
#line 1836 ""
    i__2[0] = 1, a__2[0] = sq;
#line 1836 ""
    i__2[1] = 4, a__2[1] = "xard";
#line 1836 ""
    s_cat(ch__4, a__2, i__2, &c__2, (ftnlen)5);
#line 1836 ""
    if (s_cmp(outq, ch__4, (ftnlen)5, (ftnlen)5) == 0) {
#line 1837 ""
	++ihs;
#line 1838 ""
	*(unsigned char *)&outq[1] = 'h';
#line 1839 ""
	s_wsfi(&io___125);
#line 1839 ""
	do_fio(&c__1, (char *)&comhsp_1.hpttot[ihs - 1], (ftnlen)sizeof(real))
		;
#line 1839 ""
	e_wsfi();
#line 1840 ""
	lenout = 19;
#line 1841 ""
	goto L9;
#line 1842 ""
    }

/*  This part hard-wires ask's into new .tex file as ast's */

#line 1846 ""
L2:
/* Writing concatenation */
#line 1846 ""
    i__2[0] = 1, a__2[0] = sq;
#line 1846 ""
    i__2[1] = 3, a__2[1] = "ask";
#line 1846 ""
    s_cat(ch__5, a__2, i__2, &c__2, (ftnlen)4);
#line 1846 ""
    indxask = i_indx(outq, ch__5, (ftnlen)129, (ftnlen)4);
#line 1847 ""
    if (indxask != 0) {
#line 1848 ""
	++comas3_1.iask;
#line 1849 ""
	putast_(&comas3_1.ask[comas3_1.iask - 1], &indxask, outq, (ftnlen)129)
		;
#line 1850 ""
	goto L2;
#line 1851 ""
    }
#line 1852 ""
    lenout = llen_(outq, &c__129, (ftnlen)129);
#line 1853 ""
L9:
#line 1854 ""
    s_wsfe(&io___128);
#line 1854 ""
    do_fio(&c__1, outq, lenout);
#line 1854 ""
    e_wsfe();

/*  If this is the line with "readmod", check for topmods. */

#line 1858 ""
    if (comas3_1.topmods && s_cmp(outq + 1, "readmod", (ftnlen)7, (ftnlen)7) 
	    == 0) {
#line 1859 ""
	comas3_1.topmods = FALSE_;
#line 1860 ""
	al__1.aerr = 0;
#line 1860 ""
	al__1.aunit = 16;
#line 1860 ""
	f_rew(&al__1);
#line 1861 ""
	for (il = 1; il <= 1000; ++il) {
#line 1862 ""
	    i__3 = s_rsfe(&io___129);
#line 1862 ""
	    if (i__3 != 0) {
#line 1862 ""
		goto L8;
#line 1862 ""
	    }
#line 1862 ""
	    i__3 = do_fio(&c__1, outq, (ftnlen)129);
#line 1862 ""
	    if (i__3 != 0) {
#line 1862 ""
		goto L8;
#line 1862 ""
	    }
#line 1862 ""
	    i__3 = e_rsfe();
#line 1862 ""
	    if (i__3 != 0) {
#line 1862 ""
		goto L8;
#line 1862 ""
	    }
#line 1863 ""
	    lenout = llen_(outq, &c__129, (ftnlen)129);

/*  We inserted the '%' in subroutine littex, to guarantee including blank. */

#line 1867 ""
	    s_wsfe(&io___130);
#line 1867 ""
	    do_fio(&c__1, outq, lenout);
#line 1867 ""
	    e_wsfe();
#line 1868 ""
/* L7: */
#line 1868 ""
	}
#line 1869 ""
L8:
#line 1870 ""
	cl__1.cerr = 0;
#line 1870 ""
	cl__1.cunit = 16;
#line 1870 ""
	cl__1.csta = 0;
#line 1870 ""
	f_clos(&cl__1);
#line 1871 ""
    }
#line 1872 ""
    goto L1;
#line 1873 ""
L999:
#line 1873 ""
    cl__1.cerr = 0;
#line 1873 ""
    cl__1.cunit = 11;
#line 1873 ""
    cl__1.csta = 0;
#line 1873 ""
    f_clos(&cl__1);
#line 1874 ""
    cl__1.cerr = 0;
#line 1874 ""
    cl__1.cunit = 12;
#line 1874 ""
    cl__1.csta = 0;
#line 1874 ""
    f_clos(&cl__1);
#line 1875 ""
    return 0;
} /* askfig_ */

/* Subroutine */ int backfill_(integer *iunit, char *oldq, integer *lenold, 
	char *newq, integer *lennew, ftnlen oldq_len, ftnlen newq_len)
{
    /* System generated locals */
    address a__1[3];
    integer i__1, i__2[3];
    alist al__1;

    /* Builtin functions */
    integer f_back(alist *), s_rsfe(cilist *), do_fio(integer *, char *, 
	    ftnlen), e_rsfe(void), i_indx(char *, char *, ftnlen, ftnlen);
    /* Subroutine */ int s_copy(char *, char *, ftnlen, ftnlen), s_cat(char *,
	     char **, integer *, integer *, ftnlen);
    integer s_wsfe(cilist *), e_wsfe(void);

    /* Local variables */
    static integer linesback, ndx, line;
    static char nowq[128], lineq[128*200];

    /* Fortran I/O blocks */
    static cilist io___132 = { 0, 0, 0, "(a)", 0 };
    static cilist io___137 = { 0, 0, 0, "(a128)", 0 };



/*  In iunit, looks backward for oldq, overwrites newq */
/*  Safest if both are same length! */

#line 1884 ""
    linesback = 0;
#line 1885 ""
L1:
#line 1886 ""
    al__1.aerr = 0;
#line 1886 ""
    al__1.aunit = *iunit;
#line 1886 ""
    f_back(&al__1);
#line 1887 ""
    io___132.ciunit = *iunit;
#line 1887 ""
    s_rsfe(&io___132);
#line 1887 ""
    do_fio(&c__1, nowq, (ftnlen)128);
#line 1887 ""
    e_rsfe();
#line 1888 ""
    ndx = i_indx(nowq, oldq, (ftnlen)128, (*lenold));

/*  Save the line just read */

#line 1892 ""
    ++linesback;
#line 1893 ""
    s_copy(lineq + (linesback - 1 << 7), nowq, (ftnlen)128, (ftnlen)128);
#line 1894 ""
    if (ndx == 0) {
#line 1895 ""
	al__1.aerr = 0;
#line 1895 ""
	al__1.aunit = *iunit;
#line 1895 ""
	f_back(&al__1);
#line 1896 ""
	goto L1;
#line 1897 ""
    }

/*  If here, it's replacement time. */

#line 1901 ""
    i__1 = ndx + *lenold - 1;
/* Writing concatenation */
#line 1901 ""
    i__2[0] = ndx - 1, a__1[0] = nowq;
#line 1901 ""
    i__2[1] = *lennew, a__1[1] = newq;
#line 1901 ""
    i__2[2] = 128 - i__1, a__1[2] = nowq + i__1;
#line 1901 ""
    s_cat(lineq + (linesback - 1 << 7), a__1, i__2, &c__3, (ftnlen)128);
#line 1903 ""
    al__1.aerr = 0;
#line 1903 ""
    al__1.aunit = *iunit;
#line 1903 ""
    f_back(&al__1);
#line 1904 ""
    for (line = linesback; line >= 1; --line) {
#line 1905 ""
	io___137.ciunit = *iunit;
#line 1905 ""
	s_wsfe(&io___137);
#line 1905 ""
	do_fio(&c__1, lineq + (line - 1 << 7), (ftnlen)128);
#line 1905 ""
	e_wsfe();
#line 1906 ""
/* L2: */
#line 1906 ""
    }
#line 1907 ""
    return 0;
} /* backfill_ */

/* Subroutine */ int beamend_(char *notexq, integer *lnote, ftnlen notexq_len)
{
    /* System generated locals */
    address a__1[13], a__2[2], a__3[6], a__4[4], a__5[5], a__6[3], a__7[7];
    integer i__1, i__2[13], i__3[2], i__4[6], i__5[4], i__6[5], i__7[3], i__8[
	    7], i__9;
    real r__1;
    char ch__1[1];

    /* Builtin functions */
    integer pow_ii(integer *, integer *), s_wsfi(icilist *), do_fio(integer *,
	     char *, ftnlen), e_wsfi(void);
    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen),
	     s_copy(char *, char *, ftnlen, ftnlen);
    integer s_wsle(cilist *), e_wsle(void), do_lio(integer *, integer *, char 
	    *, ftnlen);

    /* Local variables */
    extern /* Subroutine */ int addblank_(char *, integer *, ftnlen);
    extern integer igetbits_(integer *, integer *, integer *);
    static integer ip, mp, len, imp;
    extern integer log2_(integer *);
    extern /* Character */ VOID chax_(char *, ftnlen, integer *);
    static integer nole;
    static real slen;
    static char ulqq[1];
    extern /* Subroutine */ int stop1_(void);
    extern integer ncmid_(integer *, integer *);
    static integer ndsav;
    static char tempq[4], noteq[8];
    extern /* Subroutine */ int notex_(char *, integer *, ftnlen);
    static real addoff;
    extern /* Subroutine */ int ntrbbb_(integer *, char *, char *, integer *, 
	    char *, integer *, ftnlen, ftnlen, ftnlen), notefq_(char *, 
	    integer *, integer *, integer *, ftnlen);
    static logical isdotm;
    static integer lnoten, multip, nindent;
    extern /* Subroutine */ int istring_(integer *, char *, integer *, ftnlen)
	    ;

    /* Fortran I/O blocks */
    static icilist io___144 = { 0, tempq, 0, "(f4.1)", 4, 1 };
    static icilist io___145 = { 0, tempq, 0, "(f4.2)", 4, 1 };
    static icilist io___148 = { 0, noteq, 0, "(i2)", 2, 1 };
    static icilist io___150 = { 0, tempq, 0, "(f4.1)", 4, 1 };
    static icilist io___151 = { 0, tempq, 0, "(f4.2)", 4, 1 };
    static icilist io___153 = { 0, tempq, 0, "(f4.1)", 4, 1 };
    static icilist io___154 = { 0, tempq, 0, "(f4.1)", 4, 1 };
    static cilist io___155 = { 0, 6, 0, 0, 0 };
    static cilist io___156 = { 0, 6, 0, 0, 0 };
    static icilist io___160 = { 0, noteq, 0, "(i2)", 2, 1 };


#line 1935 ""
    ip = all_1.ipo[all_1.jn - 1];
#line 1936 ""
    multip = (all_1.mult[commvl_1.ivx + ip * 24 - 25] & 15) - 8;
#line 1937 ""
    *lnote = 0;
#line 1938 ""
    if (strtmid_1.ixrest[commvl_1.ivx - 1] == 4) {

/*  This is the LAST note in the xtup (i.e., all rests before).  Make single. */

#line 1942 ""
	i__1 = 4 - multip;
#line 1942 ""
	all_1.nodur[commvl_1.ivx + ip * 24 - 25] = pow_ii(&c__2, &i__1);
#line 1943 ""
	notex_(notexq, lnote, (ftnlen)79);
#line 1944 ""
	strtmid_1.ixrest[commvl_1.ivx - 1] = 0;
#line 1945 ""
	return 0;
#line 1946 ""
    }
#line 1947 ""
    nole = all_1.nolev[commvl_1.ivx + ip * 24 - 25];

/*  Check for special situations with 2nds (see precrd) */

#line 1951 ""
    if (bit_test(all_1.nacc[commvl_1.ivx + ip * 24 - 25],30)) {
#line 1952 ""
	--nole;
#line 1953 ""
    } else if (bit_test(all_1.nacc[commvl_1.ivx + ip * 24 - 25],31)) {
#line 1954 ""
	++nole;
#line 1955 ""
    }

/*  Terminate indented beams for 2-note tremolo if needed */

#line 1959 ""
    if (bit_test(all_1.irest[commvl_1.ivx + (ip - 1) * 24 - 25],2) && 
	    igetbits_(&all_1.irest[commvl_1.ivx + (ip - 1) * 24 - 25], &c__2, 
	    &c__5) > 0) {
#line 1961 ""
	nindent = igetbits_(&all_1.irest[commvl_1.ivx + (ip - 1) * 24 - 25], &
		c__2, &c__5);
#line 1962 ""
	if (*(unsigned char *)&all_1.ulq[commvl_1.ivx + all_1.ibmcnt[
		commvl_1.ivx - 1] * 24 - 25] == 'u') {
#line 1963 ""
	    addoff = -1 - nindent * .5f;
#line 1964 ""
	} else {
#line 1965 ""
	    addoff = nindent * .5f + 1;
#line 1966 ""
	}
/*        addoff = addoff+(.595-.065*abs(islope(ivx)))*islope(ivx) */
#line 1968 ""
	addoff += comxtup_1.islope[commvl_1.ivx - 1] * .0822f;
#line 1969 ""
	if (addoff < -.05f) {
#line 1970 ""
	    s_wsfi(&io___144);
#line 1970 ""
	    do_fio(&c__1, (char *)&addoff, (ftnlen)sizeof(real));
#line 1970 ""
	    e_wsfi();
#line 1971 ""
	} else {
#line 1972 ""
	    s_wsfi(&io___145);
#line 1972 ""
	    do_fio(&c__1, (char *)&addoff, (ftnlen)sizeof(real));
#line 1972 ""
	    e_wsfi();
#line 1973 ""
	}
/* Writing concatenation */
#line 1974 ""
	i__2[0] = 1, a__1[0] = all_1.sq;
#line 1974 ""
	i__2[1] = 5, a__1[1] = "raise";
#line 1974 ""
	i__2[2] = 4, a__1[2] = tempq;
#line 1974 ""
	i__2[3] = 1, a__1[3] = all_1.sq;
#line 1974 ""
	i__2[4] = 9, a__1[4] = "internote";
#line 1974 ""
	i__2[5] = 1, a__1[5] = all_1.sq;
#line 1974 ""
	i__2[6] = 5, a__1[6] = "hbox{";
#line 1974 ""
	i__2[7] = 1, a__1[7] = all_1.sq;
#line 1974 ""
	i__2[8] = 12, a__1[8] = "loffset{.7}{";
#line 1974 ""
	i__2[9] = 1, a__1[9] = all_1.sq;
#line 1974 ""
	i__2[10] = 2, a__1[10] = "tb";
#line 1974 ""
	i__2[11] = 1, a__1[11] = all_1.ulq + (commvl_1.ivx + all_1.ibmcnt[
		commvl_1.ivx - 1] * 24 - 25);
#line 1974 ""
	i__2[12] = 3, a__1[12] = "0}}";
#line 1974 ""
	s_cat(notexq, a__1, i__2, &c__13, (ftnlen)79);
#line 1977 ""
	*lnote = 46;
#line 1978 ""
    }
#line 1979 ""
    if (! comdraw_1.drawbm[commvl_1.ivx - 1]) {

/*  Xtuplet with no beam, just put in the right kind of note */

#line 1983 ""
	if (bit_test(all_1.irest[commvl_1.ivx + ip * 24 - 25],0)) {

/* Rest at end of unbeamed xtup */

#line 1987 ""
	    *lnote = 3;
#line 1988 ""
	    if (bit_test(all_1.islur[commvl_1.ivx + ip * 24 - 25],29)) {
/* Writing concatenation */
#line 1989 ""
		i__3[0] = 1, a__2[0] = all_1.sq;
#line 1989 ""
		i__3[1] = 2, a__2[1] = "sk";
#line 1989 ""
		s_cat(notexq, a__2, i__3, &c__2, (ftnlen)79);

/*  180106 There was a problem with nolev(ivx,ip) not being set to 0 for */
/*  a blank rest ending xtup, but hopefully returning from here will handle it. */

#line 1994 ""
		return 0;
#line 1995 ""
	    } else if (multip == 0) {
/* Writing concatenation */
#line 1996 ""
		i__3[0] = 1, a__2[0] = all_1.sq;
#line 1996 ""
		i__3[1] = 2, a__2[1] = "qp";
#line 1996 ""
		s_cat(notexq, a__2, i__3, &c__2, (ftnlen)79);
#line 1997 ""
	    } else if (multip == -1) {
/* Writing concatenation */
#line 1998 ""
		i__3[0] = 1, a__2[0] = all_1.sq;
#line 1998 ""
		i__3[1] = 2, a__2[1] = "hp";
#line 1998 ""
		s_cat(notexq, a__2, i__3, &c__2, (ftnlen)79);
#line 1999 ""
	    } else if (multip == 1) {
/* Writing concatenation */
#line 2000 ""
		i__3[0] = 1, a__2[0] = all_1.sq;
#line 2000 ""
		i__3[1] = 2, a__2[1] = "ds";
#line 2000 ""
		s_cat(notexq, a__2, i__3, &c__2, (ftnlen)79);
#line 2001 ""
	    } else if (multip == 2) {
/* Writing concatenation */
#line 2002 ""
		i__3[0] = 1, a__2[0] = all_1.sq;
#line 2002 ""
		i__3[1] = 2, a__2[1] = "qs";
#line 2002 ""
		s_cat(notexq, a__2, i__3, &c__2, (ftnlen)79);
#line 2003 ""
	    } else {
/* Writing concatenation */
#line 2004 ""
		i__3[0] = 1, a__2[0] = all_1.sq;
#line 2004 ""
		i__3[1] = 2, a__2[1] = "hs";
#line 2004 ""
		s_cat(notexq, a__2, i__3, &c__2, (ftnlen)79);
#line 2005 ""
	    }

/* 180106 Deal with possible level tweak */

#line 2009 ""
	    nole = (all_1.nolev[commvl_1.ivx + ip * 24 - 25] + 50) % 100 - 50;
#line 2010 ""
	    if (nole != 0) {
#line 2011 ""
		if (abs(nole) < 10) {
#line 2012 ""
		    i__1 = abs(nole) + 48;
#line 2012 ""
		    chax_(ch__1, (ftnlen)1, &i__1);
#line 2012 ""
		    s_copy(noteq, ch__1, (ftnlen)8, (ftnlen)1);
#line 2013 ""
		    lnoten = 1;
#line 2014 ""
		} else {
#line 2015 ""
		    s_wsfi(&io___148);
#line 2015 ""
		    i__1 = abs(nole);
#line 2015 ""
		    do_fio(&c__1, (char *)&i__1, (ftnlen)sizeof(integer));
#line 2015 ""
		    e_wsfi();
#line 2016 ""
		    lnoten = 2;
#line 2017 ""
		}
#line 2018 ""
		if (nole > 0) {
/* Writing concatenation */
#line 2019 ""
		    i__4[0] = 1, a__3[0] = all_1.sq;
#line 2019 ""
		    i__4[1] = 5, a__3[1] = "raise";
#line 2019 ""
		    i__4[2] = lnoten, a__3[2] = noteq;
#line 2019 ""
		    i__4[3] = 1, a__3[3] = all_1.sq;
#line 2019 ""
		    i__4[4] = 9, a__3[4] = "internote";
#line 2019 ""
		    i__4[5] = *lnote, a__3[5] = notexq;
#line 2019 ""
		    s_cat(notexq, a__3, i__4, &c__6, (ftnlen)79);
#line 2021 ""
		} else {
/* Writing concatenation */
#line 2022 ""
		    i__4[0] = 1, a__3[0] = all_1.sq;
#line 2022 ""
		    i__4[1] = 5, a__3[1] = "lower";
#line 2022 ""
		    i__4[2] = lnoten, a__3[2] = noteq;
#line 2022 ""
		    i__4[3] = 1, a__3[3] = all_1.sq;
#line 2022 ""
		    i__4[4] = 9, a__3[4] = "internote";
#line 2022 ""
		    i__4[5] = *lnote, a__3[5] = notexq;
#line 2022 ""
		    s_cat(notexq, a__3, i__4, &c__6, (ftnlen)79);
#line 2024 ""
		}
#line 2025 ""
		*lnote = lnoten + 16 + *lnote;
#line 2026 ""
	    }
#line 2027 ""
	    return 0;
#line 2028 ""
	}
#line 2029 ""
	if (bit_test(all_1.islur[commvl_1.ivx + ip * 24 - 25],30)) {

/*  Forced stem direction */

#line 2033 ""
	    ndsav = all_1.nodur[commvl_1.ivx + ip * 24 - 25];
#line 2034 ""
	    i__1 = 4 - multip;
#line 2034 ""
	    all_1.nodur[commvl_1.ivx + ip * 24 - 25] = pow_ii(&c__2, &i__1);
#line 2035 ""
	    if (bit_test(all_1.nacc[commvl_1.ivx + (ip - 1) * 24 - 25],27)) {
#line 2035 ""
		all_1.nodur[commvl_1.ivx + ip * 24 - 25] /= 2;
#line 2035 ""
	    }
#line 2037 ""
	    notex_(notexq, lnote, (ftnlen)79);
#line 2038 ""
	    all_1.nodur[commvl_1.ivx + ip * 24 - 25] = ndsav;
#line 2039 ""
	} else {
#line 2040 ""
	    i__1 = ncmid_(&all_1.iv, &ip);
#line 2040 ""
	    notefq_(noteq, &lnoten, &nole, &i__1, (ftnlen)8);
#line 2041 ""
	    if (lnoten == 1) {
#line 2041 ""
		addblank_(noteq, &lnoten, (ftnlen)8);
#line 2041 ""
	    }

/*  To reduce confusion due to this early update of lnote, do it */
/*    below, separately in each case/ */
/*          lnote = lnoten+3 */
#line 2046 ""
	    if (! bit_test(all_1.nacc[commvl_1.ivx + (ip - 1) * 24 - 25],27)) 
		    {

/*  Prior note is not regular-dotted */

#line 2050 ""
		if (bit_test(all_1.irest[commvl_1.ivx + (ip - 1) * 24 - 25],2)
			 && igetbits_(&all_1.irest[commvl_1.ivx + (ip - 1) * 
			24 - 25], &c__2, &c__5) > 0) {

/*  Unbeamed tremolo with indented beams. Put termination in right here */

#line 2055 ""
		    nindent = igetbits_(&all_1.irest[commvl_1.ivx + (ip - 1) *
			     24 - 25], &c__2, &c__5);
#line 2056 ""
		    if (*(unsigned char *)&all_1.ulq[commvl_1.ivx + 
			    all_1.ibmcnt[commvl_1.ivx - 1] * 24 - 25] == 'u') 
			    {
#line 2057 ""
			addoff = -1 - nindent * .5f;
#line 2058 ""
		    } else {
#line 2059 ""
			addoff = nindent * .5f + 1;
#line 2060 ""
		    }

/*  Is there an islope here, for unbeamed? */

#line 2064 ""
		    if (addoff < -.05f) {
#line 2065 ""
			s_wsfi(&io___150);
#line 2065 ""
			do_fio(&c__1, (char *)&addoff, (ftnlen)sizeof(real));
#line 2065 ""
			e_wsfi();
#line 2066 ""
		    } else {
#line 2067 ""
			s_wsfi(&io___151);
#line 2067 ""
			do_fio(&c__1, (char *)&addoff, (ftnlen)sizeof(real));
#line 2067 ""
			e_wsfi();
#line 2068 ""
		    }
/* Writing concatenation */
#line 2069 ""
		    i__2[0] = 1, a__1[0] = all_1.sq;
#line 2069 ""
		    i__2[1] = 5, a__1[1] = "raise";
#line 2069 ""
		    i__2[2] = 4, a__1[2] = tempq;
#line 2069 ""
		    i__2[3] = 1, a__1[3] = all_1.sq;
#line 2069 ""
		    i__2[4] = 9, a__1[4] = "internote";
#line 2069 ""
		    i__2[5] = 1, a__1[5] = all_1.sq;
#line 2069 ""
		    i__2[6] = 5, a__1[6] = "hbox{";
#line 2069 ""
		    i__2[7] = 1, a__1[7] = all_1.sq;
#line 2069 ""
		    i__2[8] = 12, a__1[8] = "loffset{.7}{";
#line 2069 ""
		    i__2[9] = 1, a__1[9] = all_1.sq;
#line 2069 ""
		    i__2[10] = 2, a__1[10] = "tb";
#line 2069 ""
		    i__2[11] = 1, a__1[11] = all_1.ulq + (commvl_1.ivx + 
			    all_1.ibmcnt[commvl_1.ivx - 1] * 24 - 25);
#line 2069 ""
		    i__2[12] = 3, a__1[12] = "0}}";
#line 2069 ""
		    s_cat(notexq, a__1, i__2, &c__13, (ftnlen)79);
#line 2073 ""
		    *lnote = 46;
#line 2074 ""
		}
#line 2075 ""
		if (multip == 0) {
#line 2076 ""
		    if (bit_test(all_1.irest[commvl_1.ivx + (ip - 1) * 24 - 
			    25],2) && all_1.nodur[commvl_1.ivx + ip * 24 - 25]
			     > 24) {

/* 2nd note of unbeamed half-note trem; make open */
/* But it's not clear if unbeamed half-note tremolo is Kosher, */
/*   so don't worry about stem lengths here now. */

#line 2083 ""
			if (*lnote == 0) {
/* Writing concatenation */
#line 2084 ""
			    i__5[0] = 1, a__4[0] = all_1.sq;
#line 2084 ""
			    i__5[1] = 1, a__4[1] = "h";
#line 2084 ""
			    i__5[2] = 1, a__4[2] = all_1.ulq + (commvl_1.ivx 
				    + all_1.ibmcnt[commvl_1.ivx - 1] * 24 - 
				    25);
#line 2084 ""
			    i__5[3] = 8, a__4[3] = noteq;
#line 2084 ""
			    s_cat(notexq, a__4, i__5, &c__4, (ftnlen)79);
#line 2085 ""
			} else {
/* Writing concatenation */
#line 2086 ""
			    i__6[0] = 46, a__5[0] = notexq;
#line 2086 ""
			    i__6[1] = 1, a__5[1] = all_1.sq;
#line 2086 ""
			    i__6[2] = 1, a__5[2] = "h";
#line 2086 ""
			    i__6[3] = 1, a__5[3] = all_1.ulq + (commvl_1.ivx 
				    + all_1.ibmcnt[commvl_1.ivx - 1] * 24 - 
				    25);
#line 2086 ""
			    i__6[4] = 8, a__5[4] = noteq;
#line 2086 ""
			    s_cat(notexq, a__5, i__6, &c__5, (ftnlen)79);
#line 2088 ""
			    *lnote = 46;
#line 2089 ""
			}
#line 2090 ""
		    } else {
#line 2091 ""
			if (bit_test(all_1.irest[commvl_1.ivx + (ip - 1) * 24 
				- 25],2) && all_1.nodur[commvl_1.ivx + ip * 
				24 - 25] == 24 || all_1.nodur[commvl_1.ivx + 
				ip * 24 - 25] == 12) {

/* Need a dot. */

#line 2096 ""
			    *lnote = 46;
#line 2097 ""
			    if (lnoten == 1) {
/* Writing concatenation */
#line 2098 ""
				i__3[0] = 1, a__2[0] = " ";
#line 2098 ""
				i__3[1] = 1, a__2[1] = noteq;
#line 2098 ""
				s_cat(noteq, a__2, i__3, &c__2, (ftnlen)8);
#line 2099 ""
				lnoten = 2;
#line 2100 ""
			    }

/*  Insert stemlength stuff here for unbeamed dotted tremolo. */
/*  May later combine with below to avoid repeat. But need to */
/*    return to normal stem length after note is set. */

#line 2106 ""
			    nindent = igetbits_(&all_1.irest[commvl_1.ivx + (
				    ip - 1) * 24 - 25], &c__2, &c__5);
#line 2107 ""
			    if (*(unsigned char *)&all_1.ulq[commvl_1.ivx + 
				    all_1.ibmcnt[commvl_1.ivx - 1] * 24 - 25] 
				    == 'u') {
#line 2108 ""
				slen = (nindent + 4.5f + comxtup_1.nolev1[
					commvl_1.ivx - 1] - nole + (
					all_1.eskz[commvl_1.ivx + ip * 24 - 
					25] - all_1.eskz[commvl_1.ivx + (ip - 
					1) * 24 - 25] - .7f) * 1.3f * 
					comxtup_1.islope[commvl_1.ivx - 1] / 
					all_1.slfac) * .6667f;
#line 2111 ""
			    } else {
#line 2112 ""
				slen = (nindent + 4.5f - comxtup_1.nolev1[
					commvl_1.ivx - 1] + nole - (
					all_1.eskz[commvl_1.ivx + ip * 24 - 
					25] - all_1.eskz[commvl_1.ivx + (ip - 
					1) * 24 - 25] - .7f) * 1.3f * 
					comxtup_1.islope[commvl_1.ivx - 1] / 
					all_1.slfac) * .6667f;
#line 2115 ""
			    }
#line 2116 ""
			    s_wsfi(&io___153);
#line 2116 ""
			    do_fio(&c__1, (char *)&slen, (ftnlen)sizeof(real))
				    ;
#line 2116 ""
			    e_wsfi();
/* Writing concatenation */
#line 2117 ""
			    i__6[0] = 1, a__5[0] = all_1.sq;
#line 2117 ""
			    i__6[1] = 4, a__5[1] = "slx{";
#line 2117 ""
			    i__6[2] = 4, a__5[2] = tempq;
#line 2117 ""
			    i__6[3] = 1, a__5[3] = "}";
#line 2117 ""
			    i__6[4] = *lnote, a__5[4] = notexq;
#line 2117 ""
			    s_cat(notexq, a__5, i__6, &c__5, (ftnlen)79);
#line 2118 ""
			    *lnote += 10;
#line 2119 ""
			}

/* Next steps are a historical kluge to distinguish dotted unbeamed 2-note trem */
/* (needs \qup) from normal xtup on dotted note (eg e44dx2 f, wants no dot) */

#line 2124 ""
			if (bit_test(all_1.irest[commvl_1.ivx + (ip - 1) * 24 
				- 25],2)) {
#line 2125 ""
			    if (*lnote == 0) {
/*                  notexq = sq//'q'//ulq(ivx,ibmcnt(ivx)) */
/* Writing concatenation */
#line 2127 ""
				i__6[0] = 1, a__5[0] = all_1.sq;
#line 2127 ""
				i__6[1] = 1, a__5[1] = "q";
#line 2127 ""
				i__6[2] = 1, a__5[2] = all_1.ulq + (
					commvl_1.ivx + all_1.ibmcnt[
					commvl_1.ivx - 1] * 24 - 25);
#line 2127 ""
				i__6[3] = 1, a__5[3] = "p";
#line 2127 ""
				i__6[4] = lnoten, a__5[4] = noteq;
#line 2127 ""
				s_cat(notexq, a__5, i__6, &c__5, (ftnlen)79);
#line 2129 ""
			    } else {
/* Writing concatenation */
#line 2130 ""
				i__4[0] = *lnote, a__3[0] = notexq;
#line 2130 ""
				i__4[1] = 1, a__3[1] = all_1.sq;
#line 2130 ""
				i__4[2] = 1, a__3[2] = "q";
#line 2130 ""
				i__4[3] = 1, a__3[3] = all_1.ulq + (
					commvl_1.ivx + all_1.ibmcnt[
					commvl_1.ivx - 1] * 24 - 25);
#line 2130 ""
				i__4[4] = 1, a__3[4] = "p";
#line 2130 ""
				i__4[5] = lnoten, a__3[5] = noteq;
#line 2130 ""
				s_cat(notexq, a__3, i__4, &c__6, (ftnlen)79);
/*     *              //ulq(ivx,ibmcnt(ivx))//noteq(1:lnoten) */
#line 2133 ""
			    }
/*                lnote = lnote+3+lnoten */
#line 2135 ""
			    *lnote = *lnote + 4 + lnoten;
#line 2136 ""
			} else {
#line 2137 ""
			    if (*lnote == 0) {
/* Writing concatenation */
#line 2138 ""
				i__5[0] = 1, a__4[0] = all_1.sq;
#line 2138 ""
				i__5[1] = 1, a__4[1] = "q";
#line 2138 ""
				i__5[2] = 1, a__4[2] = all_1.ulq + (
					commvl_1.ivx + all_1.ibmcnt[
					commvl_1.ivx - 1] * 24 - 25);
#line 2138 ""
				i__5[3] = lnoten, a__4[3] = noteq;
#line 2138 ""
				s_cat(notexq, a__4, i__5, &c__4, (ftnlen)79);
#line 2140 ""
			    } else {
/* Writing concatenation */
#line 2141 ""
				i__6[0] = *lnote, a__5[0] = notexq;
#line 2141 ""
				i__6[1] = 1, a__5[1] = all_1.sq;
#line 2141 ""
				i__6[2] = 1, a__5[2] = "q";
#line 2141 ""
				i__6[3] = 1, a__5[3] = all_1.ulq + (
					commvl_1.ivx + all_1.ibmcnt[
					commvl_1.ivx - 1] * 24 - 25);
#line 2141 ""
				i__6[4] = lnoten, a__5[4] = noteq;
#line 2141 ""
				s_cat(notexq, a__5, i__6, &c__5, (ftnlen)79);
#line 2143 ""
			    }
#line 2144 ""
			    *lnote = *lnote + 3 + lnoten;
#line 2145 ""
			}
#line 2146 ""
			if (bit_test(all_1.irest[commvl_1.ivx + (ip - 1) * 24 
				- 25],2) && all_1.nodur[commvl_1.ivx + ip * 
				24 - 25] == 24 || all_1.nodur[commvl_1.ivx + 
				ip * 24 - 25] == 12) {
/* Writing concatenation */
#line 2148 ""
			    i__7[0] = *lnote, a__6[0] = notexq;
#line 2148 ""
			    i__7[1] = 1, a__6[1] = all_1.sq;
#line 2148 ""
			    i__7[2] = 3, a__6[2] = "slz";
#line 2148 ""
			    s_cat(notexq, a__6, i__7, &c__3, (ftnlen)79);
#line 2149 ""
			    *lnote += 4;
#line 2150 ""
			}
#line 2151 ""
		    }
#line 2152 ""
		} else if (bit_test(all_1.irest[commvl_1.ivx + (ip - 1) * 24 
			- 25],2)) {

/* 2nd note of unbeamed quarter or 8th trem; make quarter note */
/* Get stemlength change */

#line 2157 ""
		    *lnote = 46;
#line 2158 ""
		    nindent = igetbits_(&all_1.irest[commvl_1.ivx + (ip - 1) *
			     24 - 25], &c__2, &c__5);
#line 2159 ""
		    if (*(unsigned char *)&all_1.ulq[commvl_1.ivx + 
			    all_1.ibmcnt[commvl_1.ivx - 1] * 24 - 25] == 'u') 
			    {
#line 2160 ""
			slen = (nindent + 4.5f + comxtup_1.nolev1[
				commvl_1.ivx - 1] - nole + (all_1.eskz[
				commvl_1.ivx + ip * 24 - 25] - all_1.eskz[
				commvl_1.ivx + (ip - 1) * 24 - 25] - .7f) * 
				1.3f * comxtup_1.islope[commvl_1.ivx - 1] / 
				all_1.slfac) * .6667f;
#line 2163 ""
		    } else {
#line 2164 ""
			slen = (nindent + 4.5f - comxtup_1.nolev1[
				commvl_1.ivx - 1] + nole - (all_1.eskz[
				commvl_1.ivx + ip * 24 - 25] - all_1.eskz[
				commvl_1.ivx + (ip - 1) * 24 - 25] - .7f) * 
				1.3f * comxtup_1.islope[commvl_1.ivx - 1] / 
				all_1.slfac) * .6667f;
#line 2167 ""
		    }
#line 2168 ""
		    s_wsfi(&io___154);
#line 2168 ""
		    do_fio(&c__1, (char *)&slen, (ftnlen)sizeof(real));
#line 2168 ""
		    e_wsfi();
/* Writing concatenation */
#line 2169 ""
		    i__6[0] = 46, a__5[0] = notexq;
#line 2169 ""
		    i__6[1] = 1, a__5[1] = all_1.sq;
#line 2169 ""
		    i__6[2] = 4, a__5[2] = "slx{";
#line 2169 ""
		    i__6[3] = 4, a__5[3] = tempq;
#line 2169 ""
		    i__6[4] = 1, a__5[4] = "}";
#line 2169 ""
		    s_cat(notexq, a__5, i__6, &c__5, (ftnlen)79);
#line 2170 ""
		    *lnote += 10;

/* Check for dotted unbeamed tremolo */

#line 2174 ""
		    if ((r__1 = all_1.nodur[commvl_1.ivx + ip * 24 - 25] / 
			    12.f - all_1.nodur[commvl_1.ivx + ip * 24 - 25] / 
			    12, dabs(r__1)) < .001f) {

/* Need a dot */

#line 2178 ""
			if (lnoten == 1) {
/* Writing concatenation */
#line 2179 ""
			    i__3[0] = 1, a__2[0] = " ";
#line 2179 ""
			    i__3[1] = 1, a__2[1] = noteq;
#line 2179 ""
			    s_cat(noteq, a__2, i__3, &c__2, (ftnlen)8);
#line 2180 ""
			    lnoten = 2;
#line 2181 ""
			}
#line 2182 ""
			if (*lnote == 0) {
/* Writing concatenation */
#line 2183 ""
			    i__7[0] = 1, a__6[0] = all_1.sq;
#line 2183 ""
			    i__7[1] = 2, a__6[1] = "pt";
#line 2183 ""
			    i__7[2] = lnoten, a__6[2] = noteq;
#line 2183 ""
			    s_cat(notexq, a__6, i__7, &c__3, (ftnlen)79);
#line 2184 ""
			} else {
/* Writing concatenation */
#line 2185 ""
			    i__5[0] = *lnote, a__4[0] = notexq;
#line 2185 ""
			    i__5[1] = 1, a__4[1] = all_1.sq;
#line 2185 ""
			    i__5[2] = 2, a__4[2] = "pt";
#line 2185 ""
			    i__5[3] = lnoten, a__4[3] = noteq;
#line 2185 ""
			    s_cat(notexq, a__4, i__5, &c__4, (ftnlen)79);
#line 2186 ""
			}
#line 2187 ""
			*lnote = *lnote + 3 + lnoten;
#line 2188 ""
			i__1 = ncmid_(&all_1.iv, &ip);
#line 2188 ""
			notefq_(noteq, &lnoten, &nole, &i__1, (ftnlen)8);
#line 2189 ""
			if (lnoten == 1) {
/* Writing concatenation */
#line 2190 ""
			    i__3[0] = 1, a__2[0] = " ";
#line 2190 ""
			    i__3[1] = 1, a__2[1] = noteq;
#line 2190 ""
			    s_cat(noteq, a__2, i__3, &c__2, (ftnlen)8);
#line 2191 ""
			    lnoten = 2;
#line 2192 ""
			}
#line 2193 ""
		    }
/* Writing concatenation */
#line 2194 ""
		    i__8[0] = *lnote, a__7[0] = notexq;
#line 2194 ""
		    i__8[1] = 1, a__7[1] = all_1.sq;
#line 2194 ""
		    i__8[2] = 1, a__7[2] = "q";
#line 2194 ""
		    i__8[3] = 1, a__7[3] = all_1.ulq + (commvl_1.ivx + 
			    all_1.ibmcnt[commvl_1.ivx - 1] * 24 - 25);
#line 2194 ""
		    i__8[4] = lnoten, a__7[4] = noteq;
#line 2194 ""
		    i__8[5] = 1, a__7[5] = all_1.sq;
#line 2194 ""
		    i__8[6] = 3, a__7[6] = "slz";
#line 2194 ""
		    s_cat(notexq, a__7, i__8, &c__7, (ftnlen)79);
/*     *                  //sq//'stemcut' */
/*              lnote=lnote+3+lnoten+8 */
#line 2199 ""
		    *lnote = *lnote + 3 + lnoten + 4;
#line 2200 ""
		} else if (multip == -1) {
/* Writing concatenation */
#line 2201 ""
		    i__5[0] = 1, a__4[0] = all_1.sq;
#line 2201 ""
		    i__5[1] = 1, a__4[1] = "h";
#line 2201 ""
		    i__5[2] = 1, a__4[2] = all_1.ulq + (commvl_1.ivx + 
			    all_1.ibmcnt[commvl_1.ivx - 1] * 24 - 25);
#line 2201 ""
		    i__5[3] = lnoten, a__4[3] = noteq;
#line 2201 ""
		    s_cat(notexq, a__4, i__5, &c__4, (ftnlen)79);
#line 2202 ""
		    *lnote = lnoten + 3;
#line 2203 ""
		} else if (multip == 1) {
/* Writing concatenation */
#line 2204 ""
		    i__5[0] = 1, a__4[0] = all_1.sq;
#line 2204 ""
		    i__5[1] = 1, a__4[1] = "c";
#line 2204 ""
		    i__5[2] = 1, a__4[2] = all_1.ulq + (commvl_1.ivx + 
			    all_1.ibmcnt[commvl_1.ivx - 1] * 24 - 25);
#line 2204 ""
		    i__5[3] = lnoten, a__4[3] = noteq;
#line 2204 ""
		    s_cat(notexq, a__4, i__5, &c__4, (ftnlen)79);
#line 2205 ""
		    *lnote = lnoten + 3;
#line 2206 ""
		} else if (multip == 2) {
/* Writing concatenation */
#line 2207 ""
		    i__5[0] = 1, a__4[0] = all_1.sq;
#line 2207 ""
		    i__5[1] = 2, a__4[1] = "cc";
#line 2207 ""
		    i__5[2] = 1, a__4[2] = all_1.ulq + (commvl_1.ivx + 
			    all_1.ibmcnt[commvl_1.ivx - 1] * 24 - 25);
#line 2207 ""
		    i__5[3] = lnoten, a__4[3] = noteq;
#line 2207 ""
		    s_cat(notexq, a__4, i__5, &c__4, (ftnlen)79);
#line 2208 ""
		    *lnote = lnoten + 4;
#line 2209 ""
		} else if (multip == 3) {
/* Writing concatenation */
#line 2210 ""
		    i__5[0] = 1, a__4[0] = all_1.sq;
#line 2210 ""
		    i__5[1] = 3, a__4[1] = "ccc";
#line 2210 ""
		    i__5[2] = 1, a__4[2] = all_1.ulq + (commvl_1.ivx + 
			    all_1.ibmcnt[commvl_1.ivx - 1] * 24 - 25);
#line 2210 ""
		    i__5[3] = lnoten, a__4[3] = noteq;
#line 2210 ""
		    s_cat(notexq, a__4, i__5, &c__4, (ftnlen)79);
#line 2211 ""
		    *lnote = lnoten + 5;
#line 2212 ""
		} else if (multip == -2) {
/* Writing concatenation */
#line 2213 ""
		    i__7[0] = 1, a__6[0] = all_1.sq;
#line 2213 ""
		    i__7[1] = 2, a__6[1] = "wh";
#line 2213 ""
		    i__7[2] = lnoten, a__6[2] = noteq;
#line 2213 ""
		    s_cat(notexq, a__6, i__7, &c__3, (ftnlen)79);
#line 2214 ""
		    *lnote = lnoten + 3;
#line 2215 ""
		} else if (multip == -3) {
/* Writing concatenation */
#line 2216 ""
		    i__7[0] = 1, a__6[0] = all_1.sq;
#line 2216 ""
		    i__7[1] = 5, a__6[1] = "breve";
#line 2216 ""
		    i__7[2] = lnoten, a__6[2] = noteq;
#line 2216 ""
		    s_cat(notexq, a__6, i__7, &c__3, (ftnlen)79);
#line 2217 ""
		    *lnote = lnoten + 6;
#line 2218 ""
		} else {
#line 2219 ""
		    s_wsle(&io___155);
#line 2219 ""
		    e_wsle();
#line 2220 ""
		    s_wsle(&io___156);
#line 2220 ""
		    do_lio(&c__9, &c__1, "(Error in beamend, send source to "\
			    "Dr. Don)", (ftnlen)42);
#line 2220 ""
		    e_wsle();
#line 2221 ""
		    stop1_();
#line 2222 ""
		}
#line 2223 ""
	    } else {

/*  Prior note is regular-dotted so this one is halved */

#line 2227 ""
		*lnote = lnoten + 3;
#line 2228 ""
		if (multip == 0) {
/* Writing concatenation */
#line 2229 ""
		    i__5[0] = 1, a__4[0] = all_1.sq;
#line 2229 ""
		    i__5[1] = 1, a__4[1] = "c";
#line 2229 ""
		    i__5[2] = 1, a__4[2] = all_1.ulq + (commvl_1.ivx + 
			    all_1.ibmcnt[commvl_1.ivx - 1] * 24 - 25);
#line 2229 ""
		    i__5[3] = 8, a__4[3] = noteq;
#line 2229 ""
		    s_cat(notexq, a__4, i__5, &c__4, (ftnlen)79);
#line 2230 ""
		} else if (multip == -1) {
/* Writing concatenation */
#line 2231 ""
		    i__5[0] = 1, a__4[0] = all_1.sq;
#line 2231 ""
		    i__5[1] = 1, a__4[1] = "q";
#line 2231 ""
		    i__5[2] = 1, a__4[2] = all_1.ulq + (commvl_1.ivx + 
			    all_1.ibmcnt[commvl_1.ivx - 1] * 24 - 25);
#line 2231 ""
		    i__5[3] = 8, a__4[3] = noteq;
#line 2231 ""
		    s_cat(notexq, a__4, i__5, &c__4, (ftnlen)79);
#line 2232 ""
		} else if (multip == -2) {
/* Writing concatenation */
#line 2233 ""
		    i__5[0] = 1, a__4[0] = all_1.sq;
#line 2233 ""
		    i__5[1] = 1, a__4[1] = "h";
#line 2233 ""
		    i__5[2] = 1, a__4[2] = all_1.ulq + (commvl_1.ivx + 
			    all_1.ibmcnt[commvl_1.ivx - 1] * 24 - 25);
#line 2233 ""
		    i__5[3] = 8, a__4[3] = noteq;
#line 2233 ""
		    s_cat(notexq, a__4, i__5, &c__4, (ftnlen)79);
#line 2234 ""
		} else if (multip == 1) {
/* Writing concatenation */
#line 2235 ""
		    i__5[0] = 1, a__4[0] = all_1.sq;
#line 2235 ""
		    i__5[1] = 2, a__4[1] = "cc";
#line 2235 ""
		    i__5[2] = 1, a__4[2] = all_1.ulq + (commvl_1.ivx + 
			    all_1.ibmcnt[commvl_1.ivx - 1] * 24 - 25);
#line 2235 ""
		    i__5[3] = 8, a__4[3] = noteq;
#line 2235 ""
		    s_cat(notexq, a__4, i__5, &c__4, (ftnlen)79);
#line 2236 ""
		    *lnote = lnoten + 4;
#line 2237 ""
		} else if (multip == 2) {
/* Writing concatenation */
#line 2238 ""
		    i__5[0] = 1, a__4[0] = all_1.sq;
#line 2238 ""
		    i__5[1] = 3, a__4[1] = "ccc";
#line 2238 ""
		    i__5[2] = 1, a__4[2] = all_1.ulq + (commvl_1.ivx + 
			    all_1.ibmcnt[commvl_1.ivx - 1] * 24 - 25);
#line 2238 ""
		    i__5[3] = 8, a__4[3] = noteq;
#line 2238 ""
		    s_cat(notexq, a__4, i__5, &c__4, (ftnlen)79);
#line 2239 ""
		    *lnote = lnoten + 5;
#line 2240 ""
		}
#line 2241 ""
	    }
#line 2242 ""
	}
#line 2243 ""
	return 0;
#line 2244 ""
    }

/* End of block for unbeamed. Problem if beamed but ends w/ rest. Try just */
/* skipping the call in that case. */

#line 2249 ""
    if (! bit_test(all_1.irest[commvl_1.ivx + ip * 24 - 25],0)) {
#line 2250 ""
	i__1 = ncmid_(&all_1.iv, &ip);
#line 2250 ""
	notefq_(noteq, &lnoten, &nole, &i__1, (ftnlen)8);
#line 2251 ""
    }
/*      call notefq(noteq,lnoten,nole,ncmid(iv,ip)) */
/*      lnote = 0 */

/* New way, with flipend, which was computed in beamstrt. */

#line 2257 ""
    if (strtmid_1.flipend[commvl_1.ivx - 1] && bit_test(all_1.ipl[
	    commvl_1.ivx + ip * 24 - 25],30)) {
#line 2258 ""
	i__1 = 225 - *(unsigned char *)&all_1.ulq[commvl_1.ivx + all_1.ibmcnt[
		commvl_1.ivx - 1] * 24 - 25];
#line 2258 ""
	chax_(ch__1, (ftnlen)1, &i__1);
#line 2258 ""
	*(unsigned char *)&all_1.ulq[commvl_1.ivx + all_1.ibmcnt[commvl_1.ivx 
		- 1] * 24 - 25] = *(unsigned char *)&ch__1[0];
#line 2259 ""
	strtmid_1.flipend[commvl_1.ivx - 1] = FALSE_;
#line 2260 ""
    }
#line 2261 ""
    if (ip > all_1.ibm1[commvl_1.ivx + all_1.ibmcnt[commvl_1.ivx - 1] * 24 - 
	    25]) {

/* This is not a one-noter from beam-jump.  Check if multiplicity has increased */

#line 2265 ""
	if (bit_test(all_1.irest[commvl_1.ivx + (ip - 1) * 24 - 25],0)) {

/*  Prior note is a rest, check one before that */

#line 2269 ""
	    mp = (all_1.mult[commvl_1.ivx + (ip - 2) * 24 - 25] & 15) - 8;
#line 2270 ""
	} else {
#line 2271 ""
	    mp = (all_1.mult[commvl_1.ivx + (ip - 1) * 24 - 25] & 15) - 8;
#line 2272 ""
	}
#line 2273 ""
	if (multip > mp) {

/*  Assume 1-3, 2-3, or 1-2 */

#line 2277 ""
	    i__1 = mp + 1;
#line 2277 ""
	    for (imp = multip; imp >= i__1; --imp) {
#line 2278 ""
		ntrbbb_(&imp, "t", all_1.ulq + (commvl_1.ivx + all_1.ibmcnt[
			commvl_1.ivx - 1] * 24 - 25), &commvl_1.ivx, notexq, 
			lnote, (ftnlen)1, (ftnlen)1, (ftnlen)79);
#line 2279 ""
/* L2: */
#line 2279 ""
	    }
#line 2280 ""
	} else if (bit_test(all_1.nacc[commvl_1.ivx + (ip - 1) * 24 - 25],27))
		 {

/*  2nd member of dotted xtup */

#line 2284 ""
	    i__1 = multip + 1;
#line 2284 ""
	    ntrbbb_(&i__1, "t", all_1.ulq + (commvl_1.ivx + all_1.ibmcnt[
		    commvl_1.ivx - 1] * 24 - 25), &commvl_1.ivx, notexq, 
		    lnote, (ftnlen)1, (ftnlen)1, (ftnlen)79);
#line 2286 ""
	}
#line 2287 ""
    }

/* Beam termination and direction analysis */

#line 2291 ""
    if (bit_test(all_1.irest[commvl_1.ivx + ip * 24 - 25],23) && ! 
	    combjmp_1.isbjmp) {

/* This is the end of the first segment in a jump-beam.  ivbj1=ivx will be number */
/*   of the jump-beam.  ivbj2 will be tested along with isbjmp to see if in the */
/*   voice of the 2nd part of jumped beam.  (May need special treatment for */
/*   multi-segment jump-beams */

#line 2298 ""
	combjmp_1.isbjmp = TRUE_;
#line 2299 ""
	combjmp_1.ivbj1 = commvl_1.ivx;
#line 2300 ""
	combjmp_1.multbj1 = 15 & all_1.mult[commvl_1.ivx + ip * 24 - 25] - 8;
#line 2301 ""
	combjmp_1.ivbj2 = 0;
#line 2302 ""
    }
#line 2303 ""
    if (! bit_test(all_1.irest[commvl_1.ivx + ip * 24 - 25],23)) {

/* This is either a normal beamend or end of a sequence of jump-beam segments, */
/* (170409) or rest at end of xtup */
/* so some sort of termination is required */

#line 2309 ""
	*(unsigned char *)ulqq = *(unsigned char *)&all_1.ulq[commvl_1.ivx + 
		all_1.ibmcnt[commvl_1.ivx - 1] * 24 - 25];
#line 2310 ""
	if (! combjmp_1.isbjmp || commvl_1.ivx != combjmp_1.ivbj2) {
#line 2311 ""
	    if (bit_test(all_1.irest[commvl_1.ivx + ip * 24 - 25],0)) {

/* Xtup ends with rest */

#line 2315 ""
		if (multip == 1) {
/* Writing concatenation */
#line 2316 ""
		    i__3[0] = 1, a__2[0] = all_1.sq;
#line 2316 ""
		    i__3[1] = 2, a__2[1] = "ds";
#line 2316 ""
		    s_cat(notexq, a__2, i__3, &c__2, (ftnlen)79);
#line 2317 ""
		    *lnote = 3;
#line 2318 ""
		} else if (multip == 2) {
/* Writing concatenation */
#line 2319 ""
		    i__3[0] = 1, a__2[0] = all_1.sq;
#line 2319 ""
		    i__3[1] = 2, a__2[1] = "qs";
#line 2319 ""
		    s_cat(notexq, a__2, i__3, &c__2, (ftnlen)79);
#line 2320 ""
		    *lnote = 3;
#line 2321 ""
		} else if (multip == 3) {
/* Writing concatenation */
#line 2322 ""
		    i__3[0] = 1, a__2[0] = all_1.sq;
#line 2322 ""
		    i__3[1] = 2, a__2[1] = "hs";
#line 2322 ""
		    s_cat(notexq, a__2, i__3, &c__2, (ftnlen)79);
#line 2323 ""
		    *lnote = 3;
#line 2324 ""
		}

/*  170801 Borrowed from main rest entry way down below to get level adjustment: */
/*  BUT nole is like 102, not 2, so subtracted 100 for nole. Why different??? */
/*  "...  Now raise if necc." */

#line 2330 ""
		if (bit_test(all_1.islur[commvl_1.ivx + ip * 24 - 25],29)) {

/*  Blank rest */

/* Writing concatenation */
#line 2334 ""
		    i__3[0] = 1, a__2[0] = all_1.sq;
#line 2334 ""
		    i__3[1] = 2, a__2[1] = "sk";
#line 2334 ""
		    s_cat(notexq, a__2, i__3, &c__2, (ftnlen)79);
#line 2335 ""
		    *lnote = 3;
#line 2336 ""
		} else if (nole != 0) {

/*  Bandaid. Odd case with rests in xtups + 2 voices where came thru here with */
/*    nolev=-4 but expected 100+/-. Try to fix. */

#line 2341 ""
		    if (abs(nole) < 30) {
#line 2341 ""
			nole += 100;
#line 2341 ""
		    }

#line 2343 ""
		    if ((i__1 = nole - 100, abs(i__1)) < 10) {
#line 2344 ""
			i__9 = (i__1 = nole - 100, abs(i__1)) + 48;
#line 2344 ""
			chax_(ch__1, (ftnlen)1, &i__9);
#line 2344 ""
			s_copy(noteq, ch__1, (ftnlen)8, (ftnlen)1);
#line 2345 ""
			lnoten = 1;
#line 2346 ""
		    } else {
#line 2347 ""
			s_wsfi(&io___160);
#line 2347 ""
			i__9 = (i__1 = nole - 100, abs(i__1));
#line 2347 ""
			do_fio(&c__1, (char *)&i__9, (ftnlen)sizeof(integer));
#line 2347 ""
			e_wsfi();
#line 2348 ""
			lnoten = 2;
#line 2349 ""
		    }
/*  ???              if (nole .gt. 0) then */
#line 2351 ""
		    if (nole > 100) {
/* Writing concatenation */
#line 2352 ""
			i__4[0] = 1, a__3[0] = all_1.sq;
#line 2352 ""
			i__4[1] = 5, a__3[1] = "raise";
#line 2352 ""
			i__4[2] = lnoten, a__3[2] = noteq;
#line 2352 ""
			i__4[3] = 1, a__3[3] = all_1.sq;
#line 2352 ""
			i__4[4] = 9, a__3[4] = "internote";
#line 2352 ""
			i__4[5] = *lnote, a__3[5] = notexq;
#line 2352 ""
			s_cat(notexq, a__3, i__4, &c__6, (ftnlen)79);
#line 2354 ""
		    } else {
/* Writing concatenation */
#line 2355 ""
			i__4[0] = 1, a__3[0] = all_1.sq;
#line 2355 ""
			i__4[1] = 5, a__3[1] = "lower";
#line 2355 ""
			i__4[2] = lnoten, a__3[2] = noteq;
#line 2355 ""
			i__4[3] = 1, a__3[3] = all_1.sq;
#line 2355 ""
			i__4[4] = 9, a__3[4] = "internote";
#line 2355 ""
			i__4[5] = *lnote, a__3[5] = notexq;
#line 2355 ""
			s_cat(notexq, a__3, i__4, &c__6, (ftnlen)79);
#line 2357 ""
		    }
#line 2358 ""
		    *lnote = lnoten + 16 + *lnote;
#line 2359 ""
		}
#line 2360 ""
		return 0;
#line 2361 ""
	    } else {

/* Normal termination */

#line 2365 ""
		i__1 = commvl_1.ivx % 24;
#line 2365 ""
		ntrbbb_(&c__1, "t", ulqq, &i__1, notexq, lnote, (ftnlen)1, (
			ftnlen)1, (ftnlen)79);
#line 2366 ""
	    }
#line 2367 ""
	} else {

/* Terminate a sequence of jump-beam segments. */

#line 2371 ""
	    i__1 = 225 - *(unsigned char *)ulqq;
#line 2371 ""
	    chax_(ch__1, (ftnlen)1, &i__1);
#line 2371 ""
	    *(unsigned char *)ulqq = *(unsigned char *)&ch__1[0];
#line 2372 ""
	    i__1 = combjmp_1.ivbj1 % 24;
#line 2372 ""
	    ntrbbb_(&c__1, "t", ulqq, &i__1, notexq, lnote, (ftnlen)1, (
		    ftnlen)1, (ftnlen)79);
#line 2373 ""
	}
#line 2374 ""
    }

/* Check for end of 2nd seg of staff-jump xtup chord blank rest */

/*      if (isbjmp.and.ivx.eq.ivbj2 */
#line 2379 ""
    if (combjmp_1.isbjmp && bit_test(all_1.islur[commvl_1.ivx + ip * 24 - 25],
	    29)) {
/* Writing concatenation */
#line 2381 ""
	i__7[0] = *lnote, a__6[0] = notexq;
#line 2381 ""
	i__7[1] = 1, a__6[1] = all_1.sq;
#line 2381 ""
	i__7[2] = 2, a__6[2] = "sk";
#line 2381 ""
	s_cat(notexq, a__6, i__7, &c__3, (ftnlen)79);
#line 2382 ""
	return 0;
#line 2383 ""
    }

/*  And now the note, checking for open-head beamed tremolo */

#line 2387 ""
    if (bit_test(all_1.irest[commvl_1.ivx + (ip - 1) * 24 - 25],2)) {

/* Check for dotted tremolo */

#line 2391 ""
	if ((r__1 = all_1.nodur[commvl_1.ivx + ip * 24 - 25] / 12.f - 
		all_1.nodur[commvl_1.ivx + ip * 24 - 25] / 12, dabs(r__1)) < 
		.001f) {

/* Need a dot */

#line 2395 ""
	    if (all_1.nodur[commvl_1.ivx + ip * 24 - 25] == 24 || all_1.nodur[
		    commvl_1.ivx + ip * 24 - 25] == 12) {

/* Solid notehead */

/* Writing concatenation */
#line 2399 ""
		i__7[0] = *lnote, a__6[0] = notexq;
#line 2399 ""
		i__7[1] = 1, a__6[1] = all_1.sq;
#line 2399 ""
		i__7[2] = 3, a__6[2] = "qbp";
#line 2399 ""
		s_cat(notexq, a__6, i__7, &c__3, (ftnlen)79);
#line 2400 ""
	    } else {

/* Assuming open notehead and nodur = 48 */

/* Writing concatenation */
#line 2404 ""
		i__7[0] = *lnote, a__6[0] = notexq;
#line 2404 ""
		i__7[1] = 1, a__6[1] = all_1.sq;
#line 2404 ""
		i__7[2] = 3, a__6[2] = "hbp";
#line 2404 ""
		s_cat(notexq, a__6, i__7, &c__3, (ftnlen)79);
#line 2405 ""
	    }
#line 2406 ""
	    *lnote += 4;
#line 2407 ""
	} else {
#line 2408 ""
	    if (all_1.nodur[commvl_1.ivx + ip * 24 - 25] == 32 || all_1.nodur[
		    commvl_1.ivx + ip * 24 - 25] == 48) {
#line 2409 ""
		if (*lnote > 0) {
/* Writing concatenation */
#line 2410 ""
		    i__7[0] = *lnote, a__6[0] = notexq;
#line 2410 ""
		    i__7[1] = 1, a__6[1] = all_1.sq;
#line 2410 ""
		    i__7[2] = 2, a__6[2] = "hb";
#line 2410 ""
		    s_cat(notexq, a__6, i__7, &c__3, (ftnlen)79);
#line 2411 ""
		} else {
/* Writing concatenation */
#line 2412 ""
		    i__3[0] = 1, a__2[0] = all_1.sq;
#line 2412 ""
		    i__3[1] = 2, a__2[1] = "hb";
#line 2412 ""
		    s_cat(notexq, a__2, i__3, &c__2, (ftnlen)79);
#line 2413 ""
		}
#line 2414 ""
	    } else {
#line 2415 ""
		if (*lnote > 0) {
/* Writing concatenation */
#line 2416 ""
		    i__7[0] = *lnote, a__6[0] = notexq;
#line 2416 ""
		    i__7[1] = 1, a__6[1] = all_1.sq;
#line 2416 ""
		    i__7[2] = 2, a__6[2] = "qb";
#line 2416 ""
		    s_cat(notexq, a__6, i__7, &c__3, (ftnlen)79);
#line 2417 ""
		} else {
/* Writing concatenation */
#line 2418 ""
		    i__3[0] = 1, a__2[0] = all_1.sq;
#line 2418 ""
		    i__3[1] = 2, a__2[1] = "qb";
#line 2418 ""
		    s_cat(notexq, a__2, i__3, &c__2, (ftnlen)79);
#line 2419 ""
		}
#line 2420 ""
	    }
#line 2421 ""
	    *lnote += 3;
#line 2422 ""
	}
#line 2423 ""
    } else {

/* No tremolo */

#line 2427 ""
	if (*lnote > 0) {
/* Writing concatenation */
#line 2428 ""
	    i__7[0] = *lnote, a__6[0] = notexq;
#line 2428 ""
	    i__7[1] = 1, a__6[1] = all_1.sq;
#line 2428 ""
	    i__7[2] = 2, a__6[2] = "qb";
#line 2428 ""
	    s_cat(notexq, a__6, i__7, &c__3, (ftnlen)79);
#line 2429 ""
	} else {
/* Writing concatenation */
#line 2430 ""
	    i__3[0] = 1, a__2[0] = all_1.sq;
#line 2430 ""
	    i__3[1] = 2, a__2[1] = "qb";
#line 2430 ""
	    s_cat(notexq, a__2, i__3, &c__2, (ftnlen)79);
#line 2431 ""
	}
#line 2432 ""
	*lnote += 3;
#line 2433 ""
    }
#line 2434 ""
    isdotm = FALSE_;
#line 2435 ""
    if (! comxtup_1.vxtup[commvl_1.ivx - 1]) {
#line 2436 ""
	i__1 = log2_(&all_1.nodur[commvl_1.ivx + ip * 24 - 25]);
#line 2436 ""
	if (pow_ii(&c__2, &i__1) != all_1.nodur[commvl_1.ivx + ip * 24 - 25]) 
		{
#line 2437 ""
	    if (! bit_test(all_1.iornq[commvl_1.ivx + ip * 24 - 1],13)) {
/* Writing concatenation */
#line 2438 ""
		i__3[0] = *lnote, a__2[0] = notexq;
#line 2438 ""
		i__3[1] = 1, a__2[1] = "p";
#line 2438 ""
		s_cat(notexq, a__2, i__3, &c__2, (ftnlen)79);
#line 2439 ""
	    } else {
/* Writing concatenation */
#line 2440 ""
		i__3[0] = *lnote, a__2[0] = notexq;
#line 2440 ""
		i__3[1] = 1, a__2[1] = "m";
#line 2440 ""
		s_cat(notexq, a__2, i__3, &c__2, (ftnlen)79);
#line 2441 ""
		isdotm = TRUE_;
#line 2442 ""
	    }
#line 2443 ""
	    ++(*lnote);
#line 2444 ""
	}
#line 2445 ""
    }

/*  5/25/08 Allow >12 */
/*  5/9/10 Up to 24; replace 24 with 0 */

#line 2450 ""
    if (! (combjmp_1.isbjmp && commvl_1.ivx == combjmp_1.ivbj2)) {
#line 2451 ""
	i__1 = commvl_1.ivx % 24;
#line 2451 ""
	istring_(&i__1, tempq, &len, (ftnlen)4);
#line 2452 ""
    } else {
#line 2453 ""
	i__1 = combjmp_1.ivbj1 % 24;
#line 2453 ""
	istring_(&i__1, tempq, &len, (ftnlen)4);
#line 2454 ""
    }
#line 2455 ""
    if (combjmp_1.isbjmp && commvl_1.ivx == combjmp_1.ivbj2 && ! bit_test(
	    all_1.irest[commvl_1.ivx + ip * 24 - 25],23)) {
#line 2455 ""
	combjmp_1.isbjmp = FALSE_;
#line 2455 ""
    }
/* Writing concatenation */
#line 2457 ""
    i__3[0] = *lnote, a__2[0] = notexq;
#line 2457 ""
    i__3[1] = len, a__2[1] = tempq;
#line 2457 ""
    s_cat(notexq, a__2, i__3, &c__2, (ftnlen)79);
#line 2458 ""
    *lnote += len;
/* Writing concatenation */
#line 2459 ""
    i__3[0] = *lnote, a__2[0] = notexq;
#line 2459 ""
    i__3[1] = lnoten, a__2[1] = noteq;
#line 2459 ""
    s_cat(notexq, a__2, i__3, &c__2, (ftnlen)79);
#line 2460 ""
    *lnote += lnoten;
#line 2461 ""
    if (isdotm) {
#line 2462 ""
	if (lnoten == 1) {
/* Writing concatenation */
#line 2463 ""
	    i__5[0] = *lnote, a__4[0] = notexq;
#line 2463 ""
	    i__5[1] = 1, a__4[1] = "{";
#line 2463 ""
	    i__5[2] = 1, a__4[2] = noteq;
#line 2463 ""
	    i__5[3] = 1, a__4[3] = "}";
#line 2463 ""
	    s_cat(notexq, a__4, i__5, &c__4, (ftnlen)79);
#line 2464 ""
	    *lnote += 3;
#line 2465 ""
	} else {
#line 2466 ""
	    i__1 = lnoten - 2;
/* Writing concatenation */
#line 2466 ""
	    i__3[0] = *lnote, a__2[0] = notexq;
#line 2466 ""
	    i__3[1] = lnoten - 1 - i__1, a__2[1] = noteq + i__1;
#line 2466 ""
	    s_cat(notexq, a__2, i__3, &c__2, (ftnlen)79);
#line 2467 ""
	    ++(*lnote);
#line 2468 ""
	}
#line 2469 ""
    }
#line 2470 ""
    return 0;
} /* beamend_ */

/* Subroutine */ int beamid_(char *notexq, integer *lnote, ftnlen notexq_len)
{
    /* System generated locals */
    address a__1[3], a__2[2], a__3[4];
    integer i__1, i__2[3], i__3[2], i__4, i__5, i__6[4];
    real r__1;
    char ch__1[1];

    /* Builtin functions */
    integer pow_ii(integer *, integer *);
    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);

    /* Local variables */
    extern /* Subroutine */ int addblank_(char *, integer *, ftnlen);
    extern integer igetbits_(integer *, integer *, integer *);
    extern logical isdotted_(integer *, integer *, integer *);
    static integer im, ip, len, ivb, iud, mua, mub, iup;
    extern /* Character */ VOID chax_(char *, ftnlen, integer *);
    static integer nole;
    static char ulqq[1];
    extern integer ncmid_(integer *, integer *);
    static integer ipmid, iflop, ndsav;
    static char noteq[8], tempq[4];
    extern /* Subroutine */ int notex_(char *, integer *, ftnlen);
    extern integer levrn_(integer *, integer *, integer *, integer *, integer 
	    *);
    static integer nlnum, ipnow, multl, multr;
    extern /* Subroutine */ int ntrbbb_(integer *, char *, char *, integer *, 
	    char *, integer *, ftnlen, ftnlen, ftnlen);
    static integer ipleft;
    extern /* Subroutine */ int notefq_(char *, integer *, integer *, integer 
	    *, ftnlen);
    static real xnlmid;
    static logical isdotm;
    static integer lnoten, mprint, multip;
    extern /* Subroutine */ int putxtn_(integer *, integer *, integer *, 
	    integer *, real *, real *, integer *, integer *, real *, real *, 
	    integer *, integer *, char *, integer *, integer *, real *, 
	    integer *, integer *, integer *, logical *, ftnlen);
    static integer ipright;
    extern /* Subroutine */ int istring_(integer *, char *, integer *, ftnlen)
	    ;

#line 2500 ""
    *lnote = 0;
#line 2501 ""
    ip = all_1.ipo[all_1.jn - 1];
#line 2502 ""
    nole = all_1.nolev[commvl_1.ivx + ip * 24 - 25];

/*  Check for special situations with 2nds (see precrd) */

#line 2506 ""
    if (bit_test(all_1.nacc[commvl_1.ivx + ip * 24 - 25],30)) {
#line 2507 ""
	--nole;
#line 2508 ""
    } else if (bit_test(all_1.nacc[commvl_1.ivx + ip * 24 - 25],31)) {
#line 2509 ""
	++nole;
#line 2510 ""
    }
#line 2511 ""
    if (! bit_test(all_1.irest[commvl_1.ivx + ip * 24 - 25],0)) {
#line 2512 ""
	multip = (all_1.mult[commvl_1.ivx + ip * 24 - 25] & 15) - 8;
/*          if (btest(islur(ivx,ip-1),3)) multip = multip+1 */

/*  (Above test OK since must have ip>1).  Double dotted note preceding */

/*  Move the following, because can't ask for note until after checking for */
/*  embedded xtup with number, due to ordering/octave feature. */

/*         call notefq(noteq,lnoten,nolev(ivx,ip),ncmid(iv,ip)) */
#line 2521 ""
    }
#line 2522 ""
    if (bit_test(all_1.irest[commvl_1.ivx + ip * 24 - 25],28)) {
#line 2522 ""
	comxtup_1.vxtup[commvl_1.ivx - 1] = TRUE_;
#line 2522 ""
    }
#line 2523 ""
    if (comxtup_1.vxtup[commvl_1.ivx - 1]) {

/*  In an xtup */

#line 2527 ""
	if (bit_test(all_1.irest[commvl_1.ivx + ip * 24 - 25],0)) {

/*  Intermediate rest in xtup, put in the rest.  Reset nodur so notex works OK */

#line 2531 ""
	    i__1 = 4 - ((all_1.mult[commvl_1.ivx + ip * 24 - 25] & 15) - 8);
#line 2531 ""
	    all_1.nodur[commvl_1.ivx + ip * 24 - 25] = pow_ii(&c__2, &i__1);
#line 2532 ""
	    notex_(notexq, lnote, (ftnlen)79);

/*  Re-zero so next note does not get confused */

#line 2536 ""
	    all_1.nodur[commvl_1.ivx + ip * 24 - 25] = 0;
#line 2537 ""
	    return 0;
#line 2538 ""
	}
#line 2539 ""
	if (! comdraw_1.drawbm[commvl_1.ivx - 1]) {

/*  Xtuplet with no beam, just put in the right kind of note */

#line 2543 ""
	    if (bit_test(all_1.islur[commvl_1.ivx + ip * 24 - 25],30)) {

/*  Forced stem direction */

#line 2547 ""
		ndsav = all_1.nodur[commvl_1.ivx + ip * 24 - 25];
#line 2548 ""
		i__1 = 4 - multip;
#line 2548 ""
		all_1.nodur[commvl_1.ivx + ip * 24 - 25] = pow_ii(&c__2, &
			i__1);
#line 2549 ""
		if (bit_test(all_1.nacc[commvl_1.ivx + ip * 24 - 25],19) || 
			bit_test(all_1.nacc[commvl_1.ivx + ip * 24 - 25],27)) 
			{
#line 2551 ""
		    all_1.nodur[commvl_1.ivx + ip * 24 - 25] = all_1.nodur[
			    commvl_1.ivx + ip * 24 - 25] * 3 / 2;
#line 2552 ""
		} else if (bit_test(all_1.nacc[commvl_1.ivx + (ip - 1) * 24 - 
			25],27)) {
#line 2553 ""
		    all_1.nodur[commvl_1.ivx + ip * 24 - 25] /= 2;
#line 2554 ""
		}
#line 2555 ""
		notex_(notexq, lnote, (ftnlen)79);
#line 2556 ""
		all_1.nodur[commvl_1.ivx + ip * 24 - 25] = ndsav;
#line 2557 ""
	    } else {

/*  Use ulq for stem direction */

#line 2561 ""
		i__1 = ncmid_(&all_1.iv, &ip);
#line 2561 ""
		notefq_(noteq, &lnoten, &nole, &i__1, (ftnlen)8);
#line 2562 ""
		if (lnoten == 1) {
#line 2562 ""
		    addblank_(noteq, &lnoten, (ftnlen)8);
#line 2562 ""
		}
#line 2563 ""
		*lnote = 3;
#line 2564 ""
		if (! bit_test(all_1.nacc[commvl_1.ivx + (ip - 1) * 24 - 25],
			27)) {

/*  Prior note of xtup is not regular-dotted */

#line 2568 ""
		    if (multip == 0) {
/* Writing concatenation */
#line 2569 ""
			i__2[0] = 1, a__1[0] = all_1.sq;
#line 2569 ""
			i__2[1] = 1, a__1[1] = "q";
#line 2569 ""
			i__2[2] = 1, a__1[2] = all_1.ulq + (commvl_1.ivx + 
				all_1.ibmcnt[commvl_1.ivx - 1] * 24 - 25);
#line 2569 ""
			s_cat(notexq, a__1, i__2, &c__3, (ftnlen)79);
#line 2570 ""
		    } else if (multip == -1) {
/* Writing concatenation */
#line 2571 ""
			i__2[0] = 1, a__1[0] = all_1.sq;
#line 2571 ""
			i__2[1] = 1, a__1[1] = "h";
#line 2571 ""
			i__2[2] = 1, a__1[2] = all_1.ulq + (commvl_1.ivx + 
				all_1.ibmcnt[commvl_1.ivx - 1] * 24 - 25);
#line 2571 ""
			s_cat(notexq, a__1, i__2, &c__3, (ftnlen)79);
#line 2572 ""
		    } else if (multip == 1) {
/* Writing concatenation */
#line 2573 ""
			i__2[0] = 1, a__1[0] = all_1.sq;
#line 2573 ""
			i__2[1] = 1, a__1[1] = "c";
#line 2573 ""
			i__2[2] = 1, a__1[2] = all_1.ulq + (commvl_1.ivx + 
				all_1.ibmcnt[commvl_1.ivx - 1] * 24 - 25);
#line 2573 ""
			s_cat(notexq, a__1, i__2, &c__3, (ftnlen)79);
#line 2574 ""
		    } else if (multip == 2) {
/* Writing concatenation */
#line 2575 ""
			i__2[0] = 1, a__1[0] = all_1.sq;
#line 2575 ""
			i__2[1] = 2, a__1[1] = "cc";
#line 2575 ""
			i__2[2] = 1, a__1[2] = all_1.ulq + (commvl_1.ivx + 
				all_1.ibmcnt[commvl_1.ivx - 1] * 24 - 25);
#line 2575 ""
			s_cat(notexq, a__1, i__2, &c__3, (ftnlen)79);
#line 2576 ""
			*lnote = 4;
#line 2577 ""
		    } else if (multip == 3) {
/* Writing concatenation */
#line 2578 ""
			i__2[0] = 1, a__1[0] = all_1.sq;
#line 2578 ""
			i__2[1] = 3, a__1[1] = "ccc";
#line 2578 ""
			i__2[2] = 1, a__1[2] = all_1.ulq + (commvl_1.ivx + 
				all_1.ibmcnt[commvl_1.ivx - 1] * 24 - 25);
#line 2578 ""
			s_cat(notexq, a__1, i__2, &c__3, (ftnlen)79);
#line 2579 ""
			*lnote = 5;
#line 2580 ""
		    } else if (multip == -2) {
/* Writing concatenation */
#line 2581 ""
			i__3[0] = 1, a__2[0] = all_1.sq;
#line 2581 ""
			i__3[1] = 2, a__2[1] = "wh";
#line 2581 ""
			s_cat(notexq, a__2, i__3, &c__2, (ftnlen)79);
#line 2582 ""
		    }
#line 2583 ""
		    if (bit_test(all_1.nacc[commvl_1.ivx + ip * 24 - 25],27)) 
			    {

/*  This xtup note is regular dotted non-beamed xtup */

/*                  notexq = notexq(1:3)//'p' */
/*                  lnote = 4 */
/* Writing concatenation */
#line 2589 ""
			i__3[0] = *lnote, a__2[0] = notexq;
#line 2589 ""
			i__3[1] = 1, a__2[1] = "p";
#line 2589 ""
			s_cat(notexq, a__2, i__3, &c__2, (ftnlen)79);
#line 2590 ""
			++(*lnote);
#line 2591 ""
		    }
#line 2592 ""
		} else {

/*  Prior note of xtup is regular-dotted so this one is halved */

#line 2596 ""
		    if (multip == 2) {
/* Writing concatenation */
#line 2597 ""
			i__2[0] = 1, a__1[0] = all_1.sq;
#line 2597 ""
			i__2[1] = 3, a__1[1] = "ccc";
#line 2597 ""
			i__2[2] = 1, a__1[2] = all_1.ulq + (commvl_1.ivx + 
				all_1.ibmcnt[commvl_1.ivx - 1] * 24 - 25);
#line 2597 ""
			s_cat(notexq, a__1, i__2, &c__3, (ftnlen)79);
#line 2598 ""
			*lnote = 5;
#line 2599 ""
		    } else if (multip == 1) {
/* Writing concatenation */
#line 2600 ""
			i__2[0] = 1, a__1[0] = all_1.sq;
#line 2600 ""
			i__2[1] = 2, a__1[1] = "cc";
#line 2600 ""
			i__2[2] = 1, a__1[2] = all_1.ulq + (commvl_1.ivx + 
				all_1.ibmcnt[commvl_1.ivx - 1] * 24 - 25);
#line 2600 ""
			s_cat(notexq, a__1, i__2, &c__3, (ftnlen)79);
#line 2601 ""
			*lnote = 4;
#line 2602 ""
		    } else if (multip == 0) {
/* Writing concatenation */
#line 2603 ""
			i__2[0] = 1, a__1[0] = all_1.sq;
#line 2603 ""
			i__2[1] = 1, a__1[1] = "c";
#line 2603 ""
			i__2[2] = 1, a__1[2] = all_1.ulq + (commvl_1.ivx + 
				all_1.ibmcnt[commvl_1.ivx - 1] * 24 - 25);
#line 2603 ""
			s_cat(notexq, a__1, i__2, &c__3, (ftnlen)79);
#line 2604 ""
		    } else if (multip == -1) {
/* Writing concatenation */
#line 2605 ""
			i__2[0] = 1, a__1[0] = all_1.sq;
#line 2605 ""
			i__2[1] = 1, a__1[1] = "q";
#line 2605 ""
			i__2[2] = 1, a__1[2] = all_1.ulq + (commvl_1.ivx + 
				all_1.ibmcnt[commvl_1.ivx - 1] * 24 - 25);
#line 2605 ""
			s_cat(notexq, a__1, i__2, &c__3, (ftnlen)79);
#line 2606 ""
		    } else if (multip == -2) {
/* Writing concatenation */
#line 2607 ""
			i__2[0] = 1, a__1[0] = all_1.sq;
#line 2607 ""
			i__2[1] = 1, a__1[1] = "h";
#line 2607 ""
			i__2[2] = 1, a__1[2] = all_1.ulq + (commvl_1.ivx + 
				all_1.ibmcnt[commvl_1.ivx - 1] * 24 - 25);
#line 2607 ""
			s_cat(notexq, a__1, i__2, &c__3, (ftnlen)79);
#line 2608 ""
		    }
#line 2609 ""
		}
/* Writing concatenation */
#line 2610 ""
		i__3[0] = *lnote, a__2[0] = notexq;
#line 2610 ""
		i__3[1] = 8, a__2[1] = noteq;
#line 2610 ""
		s_cat(notexq, a__2, i__3, &c__2, (ftnlen)79);
#line 2611 ""
		*lnote += lnoten;
#line 2612 ""
	    }
#line 2613 ""
	    return 0;
#line 2614 ""
	} else if (all_1.nodur[commvl_1.ivx + ip * 24 - 25] == 0) {

/*  In the beamed xtup but not the last note */

#line 2618 ""
	    if (all_1.nodur[commvl_1.ivx + (ip - 1) * 24 - 25] > 0) {

/*  Embedded Xtup, mult>0, starts here.  Put in number if needed */

#line 2622 ""
		++comxtup_1.nxtinbm[commvl_1.ivx - 1];
#line 2623 ""
		iud = 1;
#line 2624 ""
		if (*(unsigned char *)&all_1.ulq[commvl_1.ivx + all_1.ibmcnt[
			commvl_1.ivx - 1] * 24 - 25] == 'u') {
#line 2624 ""
		    iud = -1;
#line 2624 ""
		}

/*  Get ip#, notelevel of middle note (or gap) in xtup */

#line 2628 ""
		ipmid = ip + comxtup_1.ntupv[commvl_1.ivx + comxtup_1.nxtinbm[
			commvl_1.ivx - 1] * 24 - 25] / 2;
#line 2629 ""
		i__1 = ncmid_(&all_1.iv, &ipmid);
#line 2629 ""
		i__4 = (15 & all_1.mult[commvl_1.ivx + ipmid * 24 - 25]) - 8;
#line 2629 ""
		xnlmid = (real) levrn_(&all_1.nolev[commvl_1.ivx + ipmid * 24 
			- 25], &all_1.irest[commvl_1.ivx + ipmid * 24 - 25], &
			iud, &i__1, &i__4);
#line 2631 ""
		if (comxtup_1.ntupv[commvl_1.ivx + comxtup_1.nxtinbm[
			commvl_1.ivx - 1] * 24 - 25] % 2 == 0) {
#line 2631 ""
		    i__4 = ipmid - 1;
#line 2631 ""
		    i__1 = ncmid_(&all_1.iv, &i__4);
#line 2631 ""
		    i__5 = (15 & all_1.mult[commvl_1.ivx + (ipmid - 1) * 24 - 
			    25]) - 8;
#line 2631 ""
		    xnlmid = (xnlmid + levrn_(&all_1.nolev[commvl_1.ivx + (
			    ipmid - 1) * 24 - 25], &all_1.irest[commvl_1.ivx 
			    + (ipmid - 1) * 24 - 25], &iud, &i__1, &i__5)) / 
			    2;
#line 2631 ""
		}
#line 2634 ""
		iflop = 0;
#line 2635 ""
		if ((r__1 = xnlmid - ncmid_(&all_1.iv, &ip), dabs(r__1)) < 
			3.f) {
#line 2635 ""
		    iflop = -iud;
#line 2635 ""
		}
#line 2636 ""
		iup = iud + (iflop << 1);
#line 2637 ""
		if (bit_test(all_1.irest[commvl_1.ivx + ip * 24 - 25],14)) {
#line 2638 ""
		    iup = -iup;
#line 2639 ""
		    iflop = 0;
#line 2640 ""
		    if (iud * iup < 0) {
#line 2640 ""
			iflop = iup;
#line 2640 ""
		    }
#line 2641 ""
		}

/*  Place number if needed */

#line 2645 ""
		if (! bit_test(all_1.islur[commvl_1.ivx + ip * 24 - 25],31)) {
#line 2646 ""
		    mprint = igetbits_(&all_1.nacc[commvl_1.ivx + ip * 24 - 
			    25], &c__5, &c__22);
#line 2647 ""
		    if (mprint == 0) {
#line 2647 ""
			mprint = comxtup_1.mtupv[commvl_1.ivx + 
				comxtup_1.nxtinbm[commvl_1.ivx - 1] * 24 - 25]
				;
#line 2647 ""
		    }
#line 2648 ""
		    i__1 = ncmid_(&all_1.iv, &ip);
#line 2648 ""
		    putxtn_(&mprint, &iflop, &multip, &iud, &comask_1.wheadpt,
			     &comask_1.poenom, &comxtup_1.nolev1[commvl_1.ivx 
			    - 1], &comxtup_1.islope[commvl_1.ivx - 1], &
			    all_1.slfac, &xnlmid, &all_1.islur[commvl_1.ivx + 
			    ip * 24 - 25], lnote, notexq, &i__1, &nlnum, &
			    comxtup_1.eloff[commvl_1.ivx + comxtup_1.nxtinbm[
			    commvl_1.ivx - 1] * 24 - 25], &iup, &all_1.irest[
			    commvl_1.ivx + ip * 24 - 25], &all_1.mult[
			    commvl_1.ivx + ip * 24 - 25], &c_false, (ftnlen)
			    79);
#line 2653 ""
		}
#line 2654 ""
		i__1 = ncmid_(&all_1.iv, &ip);
#line 2654 ""
		notefq_(noteq, &lnoten, &nole, &i__1, (ftnlen)8);
#line 2655 ""
	    } else {

/*  Intermediate note of xtup */

#line 2659 ""
		i__1 = ncmid_(&all_1.iv, &ip);
#line 2659 ""
		notefq_(noteq, &lnoten, &nole, &i__1, (ftnlen)8);
#line 2660 ""
	    }
#line 2661 ""
	} else {

/*  Last note of xtup (but not last note of beam!) */

#line 2665 ""
	    i__1 = ncmid_(&all_1.iv, &ip);
#line 2665 ""
	    notefq_(noteq, &lnoten, &nole, &i__1, (ftnlen)8);
#line 2666 ""
	}
#line 2667 ""
    } else if (bit_test(all_1.irest[commvl_1.ivx + ip * 24 - 25],0)) {
#line 2668 ""
	notex_(notexq, lnote, (ftnlen)79);
#line 2669 ""
	return 0;
#line 2670 ""
    } else {
#line 2671 ""
	i__1 = ncmid_(&all_1.iv, &ip);
#line 2671 ""
	notefq_(noteq, &lnoten, &nole, &i__1, (ftnlen)8);
#line 2672 ""
    }

/* Check for string of rests up to and including last note in xtup. */

/* Replace next 2 lines to keep from doing this block */
/*   when in second part of staff-jumping chordal xtup. This fix could */
/*   break some unaccounted non-chordal staff-jum xtup situations. */
/*        if (vxtup(ivx) .and. btest(irest(ivx,ip+1),0) .and. */
/*     *           .not.btest(irest(ivx,ip),0)) then */
#line 2681 ""
    if (comxtup_1.vxtup[commvl_1.ivx - 1] && bit_test(all_1.irest[
	    commvl_1.ivx + (ip + 1) * 24 - 25],0) && ! bit_test(all_1.irest[
	    commvl_1.ivx + ip * 24 - 25],0) && ! (combjmp_1.isbjmp && 
	    commvl_1.ivx == combjmp_1.ivbj2)) {

/* This note is not a rest but next is a rest. Do rests continue to */
/*   end of xtup, where nodur>0 */

#line 2688 ""
	i__1 = ip + 24;
#line 2688 ""
	for (ipnow = ip + 1; ipnow <= i__1; ++ipnow) {
#line 2689 ""
	    if (all_1.nodur[commvl_1.ivx + ipnow * 24 - 25] > 0) {
#line 2689 ""
		goto L4;
#line 2689 ""
	    }
/* This is last of xtup */
#line 2690 ""
	    if (! bit_test(all_1.irest[commvl_1.ivx + (ipnow + 1) * 24 - 25],
		    0)) {
#line 2690 ""
		goto L5;
#line 2690 ""
	    }

/*  If I don't go to 5, know next note IS a rest! */

/* Next is not */
#line 2694 ""
/* L3: */
#line 2694 ""
	}
#line 2695 ""
L4:
#line 2696 ""
	ntrbbb_(&c__1, "t", all_1.ulq + (commvl_1.ivx + all_1.ibmcnt[
		commvl_1.ivx - 1] * 24 - 25), &commvl_1.ivx, notexq, lnote, (
		ftnlen)1, (ftnlen)1, (ftnlen)79);
/* Writing concatenation */
#line 2697 ""
	i__2[0] = *lnote, a__1[0] = notexq;
#line 2697 ""
	i__2[1] = 1, a__1[1] = all_1.sq;
#line 2697 ""
	i__2[2] = 2, a__1[2] = "qb";
#line 2697 ""
	s_cat(notexq, a__1, i__2, &c__3, (ftnlen)79);
#line 2698 ""
	*lnote += 3;
#line 2699 ""
	istring_(&commvl_1.ivx, tempq, &len, (ftnlen)4);
/* Writing concatenation */
#line 2700 ""
	i__3[0] = *lnote, a__2[0] = notexq;
#line 2700 ""
	i__3[1] = len, a__2[1] = tempq;
#line 2700 ""
	s_cat(notexq, a__2, i__3, &c__2, (ftnlen)79);
#line 2701 ""
	*lnote += len;
/* Writing concatenation */
#line 2702 ""
	i__3[0] = *lnote, a__2[0] = notexq;
#line 2702 ""
	i__3[1] = lnoten, a__2[1] = noteq;
#line 2702 ""
	s_cat(notexq, a__2, i__3, &c__2, (ftnlen)79);
#line 2703 ""
	*lnote += lnoten;
#line 2704 ""
	return 0;
#line 2705 ""
L5:

/* Check if multiplicity changes in a way requiring action, */
/* unless (160211) it's blank rest on start of 2nd seg of joined beam */

#line 2710 ""
	;
#line 2710 ""
    } else if (! bit_test(all_1.irest[commvl_1.ivx + (ip - 1) * 24 - 25],24) 
	    || ! bit_test(all_1.islur[commvl_1.ivx + (ip - 1) * 24 - 25],29)) 
	    {
#line 2712 ""
	ipleft = ip - 1;
#line 2713 ""
	if (bit_test(all_1.irest[commvl_1.ivx + ipleft * 24 - 25],0)) {
#line 2713 ""
	    --ipleft;
#line 2713 ""
	}
#line 2714 ""
	if (! bit_test(all_1.islur[commvl_1.ivx + ipleft * 24 - 25],20)) {
#line 2715 ""
	    multl = (15 & all_1.mult[commvl_1.ivx + ipleft * 24 - 25]) - 8;
#line 2716 ""
	} else {
#line 2717 ""
	    multl = 1;
#line 2718 ""
	}
#line 2719 ""
	mub = multip - multl;
#line 2720 ""
	ipright = ip + 1;
#line 2721 ""
	if (bit_test(all_1.irest[commvl_1.ivx + ipright * 24 - 25],0)) {
#line 2721 ""
	    ++ipright;
#line 2721 ""
	}
#line 2722 ""
	if (! bit_test(all_1.islur[commvl_1.ivx + ip * 24 - 25],20)) {
#line 2723 ""
	    multr = (15 & all_1.mult[commvl_1.ivx + ipright * 24 - 25]) - 8;
#line 2724 ""
	} else {
#line 2725 ""
	    multr = 1;
#line 2726 ""
	}
#line 2727 ""
	mua = multr - multip;
#line 2728 ""
	if (mub > 0 || mua < 0) {

/*  Multiplicity has increased from left or will decrease to right. Need action. */

#line 2732 ""
	    if (combjmp_1.isbjmp && commvl_1.ivx == combjmp_1.ivbj2) {
#line 2733 ""
		ivb = combjmp_1.ivbj1;
#line 2734 ""
		i__1 = 225 - *(unsigned char *)&all_1.ulq[commvl_1.ivx + 
			all_1.ibmcnt[commvl_1.ivx - 1] * 24 - 25];
#line 2734 ""
		chax_(ch__1, (ftnlen)1, &i__1);
#line 2734 ""
		*(unsigned char *)ulqq = *(unsigned char *)&ch__1[0];
#line 2735 ""
	    } else {
#line 2736 ""
		ivb = commvl_1.ivx;
#line 2737 ""
		*(unsigned char *)ulqq = *(unsigned char *)&all_1.ulq[
			commvl_1.ivx + all_1.ibmcnt[commvl_1.ivx - 1] * 24 - 
			25];
#line 2738 ""
	    }
#line 2739 ""
	    if (mua >= 0) {
#line 2740 ""
		ntrbbb_(&multip, "n", ulqq, &ivb, notexq, lnote, (ftnlen)1, (
			ftnlen)1, (ftnlen)79);

/*  Test for next note being blank rest, assuming staff-crossing */
/*    xtup chord */

#line 2745 ""
	    } else if (multl >= multr && ! bit_test(all_1.islur[commvl_1.ivx 
		    + (ip + 1) * 24 - 25],29)) {
#line 2747 ""
		i__1 = multr + 1;
#line 2747 ""
		for (im = multip; im >= i__1; --im) {
#line 2748 ""
		    ntrbbb_(&im, "t", ulqq, &ivb, notexq, lnote, (ftnlen)1, (
			    ftnlen)1, (ftnlen)79);
#line 2749 ""
/* L1: */
#line 2749 ""
		}
/*            else */
/*  Test for next note being blank rest, assuming staff-crossing */
/*    xtup chord */

#line 2754 ""
	    } else if (! bit_test(all_1.islur[commvl_1.ivx + (ip + 1) * 24 - 
		    25],29)) {
#line 2755 ""
		i__1 = multip;
#line 2755 ""
		for (im = multr + 1; im <= i__1; ++im) {
#line 2756 ""
		    ntrbbb_(&im, "r", ulqq, &ivb, notexq, lnote, (ftnlen)1, (
			    ftnlen)1, (ftnlen)79);
#line 2757 ""
/* L2: */
#line 2757 ""
		}
#line 2758 ""
		ntrbbb_(&multr, "n", ulqq, &ivb, notexq, lnote, (ftnlen)1, (
			ftnlen)1, (ftnlen)79);
#line 2759 ""
	    }
#line 2760 ""
	} else if (ip > 1) {

/*  Check for 2nd member of dotted xtup */

#line 2764 ""
	    if (bit_test(all_1.nacc[commvl_1.ivx + (ip - 1) * 24 - 25],27)) {
#line 2764 ""
		i__1 = multip + 1;
#line 2764 ""
		ntrbbb_(&i__1, "t", all_1.ulq + (commvl_1.ivx + all_1.ibmcnt[
			commvl_1.ivx - 1] * 24 - 25), &commvl_1.ivx, notexq, 
			lnote, (ftnlen)1, (ftnlen)1, (ftnlen)79);
#line 2764 ""
	    }
#line 2766 ""
	}
#line 2767 ""
    }

/* Now put in the note */

#line 2771 ""
    if (*lnote > 0) {
/* Writing concatenation */
#line 2772 ""
	i__2[0] = *lnote, a__1[0] = notexq;
#line 2772 ""
	i__2[1] = 1, a__1[1] = all_1.sq;
#line 2772 ""
	i__2[2] = 2, a__1[2] = "qb";
#line 2772 ""
	s_cat(notexq, a__1, i__2, &c__3, (ftnlen)79);
#line 2773 ""
    } else {
/* Writing concatenation */
#line 2774 ""
	i__3[0] = 1, a__2[0] = all_1.sq;
#line 2774 ""
	i__3[1] = 2, a__2[1] = "qb";
#line 2774 ""
	s_cat(notexq, a__2, i__3, &c__2, (ftnlen)79);
#line 2775 ""
    }
#line 2776 ""
    *lnote += 3;
#line 2777 ""
    isdotm = FALSE_;
#line 2778 ""
    if (isdotted_(all_1.nodur, &commvl_1.ivx, &ip)) {

/* rule out ')' */

#line 2782 ""
	if (! bit_test(all_1.iornq[commvl_1.ivx + ip * 24 - 1],13)) {
#line 2783 ""
	    if (! bit_test(all_1.islur[commvl_1.ivx + ip * 24 - 25],3)) {
/* Writing concatenation */
#line 2784 ""
		i__3[0] = *lnote, a__2[0] = notexq;
#line 2784 ""
		i__3[1] = 1, a__2[1] = "p";
#line 2784 ""
		s_cat(notexq, a__2, i__3, &c__2, (ftnlen)79);
#line 2785 ""
	    } else {

/*  Double dot */

/* Writing concatenation */
#line 2789 ""
		i__3[0] = *lnote, a__2[0] = notexq;
#line 2789 ""
		i__3[1] = 2, a__2[1] = "pp";
#line 2789 ""
		s_cat(notexq, a__2, i__3, &c__2, (ftnlen)79);
#line 2790 ""
		++(*lnote);
#line 2791 ""
	    }
#line 2792 ""
	} else {
/* Writing concatenation */
#line 2793 ""
	    i__3[0] = *lnote, a__2[0] = notexq;
#line 2793 ""
	    i__3[1] = 1, a__2[1] = "m";
#line 2793 ""
	    s_cat(notexq, a__2, i__3, &c__2, (ftnlen)79);
#line 2794 ""
	    isdotm = TRUE_;
#line 2795 ""
	}
#line 2796 ""
	++(*lnote);
#line 2797 ""
    } else if (bit_test(all_1.nacc[commvl_1.ivx + ip * 24 - 25],19) || 
	    bit_test(all_1.nacc[commvl_1.ivx + ip * 24 - 25],27)) {

/*  Special dotted notation for 2:1 xtup, or normal dot in xtup */

/* Writing concatenation */
#line 2802 ""
	i__3[0] = *lnote, a__2[0] = notexq;
#line 2802 ""
	i__3[1] = 1, a__2[1] = "p";
#line 2802 ""
	s_cat(notexq, a__2, i__3, &c__2, (ftnlen)79);
#line 2803 ""
	++(*lnote);
#line 2804 ""
    }

/* 5/25/08 Allow >12 */

#line 2808 ""
    if (! (combjmp_1.isbjmp && commvl_1.ivx == combjmp_1.ivbj2)) {
/*          call istring(mod(ivx,12),tempq,len) */
#line 2810 ""
	i__1 = commvl_1.ivx % 24;
#line 2810 ""
	istring_(&i__1, tempq, &len, (ftnlen)4);
#line 2811 ""
    } else {
/*          call istring(mod(ivbj1,12),tempq,len) */
#line 2813 ""
	i__1 = combjmp_1.ivbj1 % 24;
#line 2813 ""
	istring_(&i__1, tempq, &len, (ftnlen)4);
#line 2814 ""
    }
/* Writing concatenation */
#line 2815 ""
    i__3[0] = *lnote, a__2[0] = notexq;
#line 2815 ""
    i__3[1] = len, a__2[1] = tempq;
#line 2815 ""
    s_cat(notexq, a__2, i__3, &c__2, (ftnlen)79);
#line 2816 ""
    *lnote += len;
/* Writing concatenation */
#line 2817 ""
    i__3[0] = *lnote, a__2[0] = notexq;
#line 2817 ""
    i__3[1] = lnoten, a__2[1] = noteq;
#line 2817 ""
    s_cat(notexq, a__2, i__3, &c__2, (ftnlen)79);
#line 2818 ""
    *lnote += lnoten;
#line 2819 ""
    if (isdotm) {
#line 2820 ""
	if (lnoten == 2) {
/* Writing concatenation */
#line 2821 ""
	    i__6[0] = *lnote, a__3[0] = notexq;
#line 2821 ""
	    i__6[1] = 1, a__3[1] = "{";
#line 2821 ""
	    i__6[2] = 1, a__3[2] = noteq + 1;
#line 2821 ""
	    i__6[3] = 1, a__3[3] = "}";
#line 2821 ""
	    s_cat(notexq, a__3, i__6, &c__4, (ftnlen)79);
#line 2822 ""
	    *lnote += 3;
#line 2823 ""
	} else {
#line 2824 ""
	    i__1 = lnoten - 2;
/* Writing concatenation */
#line 2824 ""
	    i__3[0] = *lnote, a__2[0] = notexq;
#line 2824 ""
	    i__3[1] = lnoten - 1 - i__1, a__2[1] = noteq + i__1;
#line 2824 ""
	    s_cat(notexq, a__2, i__3, &c__2, (ftnlen)79);
#line 2825 ""
	    ++(*lnote);
#line 2826 ""
	}
#line 2827 ""
    }
#line 2828 ""
    return 0;
} /* beamid_ */

/* Subroutine */ int beamn1_(char *notexq, integer *lnote, ftnlen notexq_len)
{
    /* System generated locals */
    address a__1[3], a__2[2], a__3[5], a__4[7], a__5[4];
    integer i__1, i__2[3], i__3[2], i__4[5], i__5[7], i__6[4];
    real r__1;

    /* Builtin functions */
    integer pow_ii(integer *, integer *);
    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
    integer s_wsfi(icilist *), do_fio(integer *, char *, ftnlen), e_wsfi(void)
	    , s_wsle(cilist *), e_wsle(void), do_lio(integer *, integer *, 
	    char *, ftnlen);

    /* Local variables */
    extern /* Subroutine */ int addblank_(char *, integer *, ftnlen);
    extern integer igetbits_(integer *, integer *, integer *);
    static integer nd, im, ip, ip1, len;
    extern integer log2_(integer *);
    static integer nole;
    static real slen;
    static char numq[8];
    static integer ivxp;
    extern /* Subroutine */ int stop1_(void);
    extern integer ncmid_(integer *, integer *);
    static integer ndsav;
    static char noteq[8], tempq[8];
    extern /* Subroutine */ int notex_(char *, integer *, ftnlen);
    static integer multr;
    extern /* Subroutine */ int ntrbbb_(integer *, char *, char *, integer *, 
	    char *, integer *, ftnlen, ftnlen, ftnlen), notefq_(char *, 
	    integer *, integer *, integer *, ftnlen);
    static logical isdotm;
    static integer lnoten, multip, nindent;
    static logical gotnote;
    extern /* Subroutine */ int istring_(integer *, char *, integer *, ftnlen)
	    ;

    /* Fortran I/O blocks */
    static icilist io___199 = { 0, tempq, 0, "(f4.1)", 8, 1 };
    static icilist io___200 = { 0, tempq, 0, "(f4.1)", 8, 1 };
    static cilist io___201 = { 0, 6, 0, 0, 0 };
    static cilist io___202 = { 0, 6, 0, 0, 0 };


#line 2855 ""
    gotnote = FALSE_;
#line 2856 ""
    lnoten = 0;
#line 2857 ""
    ip1 = all_1.ipo[all_1.jn - 1];
#line 2858 ""
    multip = (15 & all_1.mult[commvl_1.ivx + ip1 * 24 - 25]) - 8;
#line 2859 ""
    if (! comdraw_1.drawbm[commvl_1.ivx - 1] && bit_test(all_1.irest[
	    commvl_1.ivx + ip1 * 24 - 25],0)) {
#line 2860 ""
	*lnote = 0;

/*  The rest was already written in beamstrt, so just get out of here */

#line 2864 ""
	return 0;
#line 2865 ""
    }
#line 2866 ""
    nole = all_1.nolev[commvl_1.ivx + all_1.ipo[all_1.jn - 1] * 24 - 25];

/*  Check for special situations with 2nds (see precrd) */

#line 2870 ""
    if (bit_test(all_1.nacc[commvl_1.ivx + all_1.ipo[all_1.jn - 1] * 24 - 25],
	    30)) {
#line 2871 ""
	--nole;
#line 2872 ""
    } else if (bit_test(all_1.nacc[commvl_1.ivx + all_1.ipo[all_1.jn - 1] * 
	    24 - 25],31)) {
#line 2873 ""
	++nole;
#line 2874 ""
    }
#line 2875 ""
    if (comxtup_1.vxtup[commvl_1.ivx - 1] && ! comdraw_1.drawbm[commvl_1.ivx 
	    - 1]) {

/*  Xtuplet with no beam, just put in the right kind of note */

#line 2879 ""
	if (bit_test(all_1.islur[commvl_1.ivx + ip1 * 24 - 25],30)) {

/*  Forced stem direction */

#line 2883 ""
	    ndsav = all_1.nodur[commvl_1.ivx + ip1 * 24 - 25];
#line 2884 ""
	    i__1 = 4 - multip;
#line 2884 ""
	    all_1.nodur[commvl_1.ivx + ip1 * 24 - 25] = pow_ii(&c__2, &i__1);
#line 2885 ""
	    if (bit_test(all_1.nacc[commvl_1.ivx + ip1 * 24 - 25],19) || 
		    bit_test(all_1.nacc[commvl_1.ivx + ip1 * 24 - 25],27)) {
#line 2885 ""
		all_1.nodur[commvl_1.ivx + ip1 * 24 - 25] = all_1.nodur[
			commvl_1.ivx + ip1 * 24 - 25] * 3 / 2;
#line 2885 ""
	    }
#line 2887 ""
	    notex_(notexq, lnote, (ftnlen)79);
#line 2888 ""
	    all_1.nodur[commvl_1.ivx + ip1 * 24 - 25] = ndsav;
#line 2889 ""
	} else {
#line 2890 ""
	    i__1 = ncmid_(&all_1.iv, &ip1);
#line 2890 ""
	    notefq_(noteq, &lnoten, &nole, &i__1, (ftnlen)8);
#line 2891 ""
	    gotnote = TRUE_;
#line 2892 ""
	    if (lnoten == 1) {
#line 2892 ""
		addblank_(noteq, &lnoten, (ftnlen)8);
#line 2892 ""
	    }
#line 2893 ""
	    *lnote = 3;
#line 2894 ""
	    if (multip <= 0) {
#line 2895 ""
		if (bit_test(all_1.irest[commvl_1.ivx + ip1 * 24 - 25],2) && 
			all_1.nodur[commvl_1.ivx + (ip1 + 1) * 24 - 25] >= 32 
			|| multip == -1) {

/* 1st note of unbeamed half-note trem; make open */

/* Writing concatenation */
#line 2901 ""
		    i__2[0] = 1, a__1[0] = all_1.sq;
#line 2901 ""
		    i__2[1] = 1, a__1[1] = "h";
#line 2901 ""
		    i__2[2] = 1, a__1[2] = all_1.ulq + (commvl_1.ivx + 
			    all_1.ibmcnt[commvl_1.ivx - 1] * 24 - 25);
#line 2901 ""
		    s_cat(notexq, a__1, i__2, &c__3, (ftnlen)79);
#line 2902 ""
		} else if (multip == -2) {
/* Writing concatenation */
#line 2903 ""
		    i__3[0] = 1, a__2[0] = all_1.sq;
#line 2903 ""
		    i__3[1] = 2, a__2[1] = "wh";
#line 2903 ""
		    s_cat(notexq, a__2, i__3, &c__2, (ftnlen)79);
#line 2904 ""
		} else {
/* Writing concatenation */
#line 2905 ""
		    i__2[0] = 1, a__1[0] = all_1.sq;
#line 2905 ""
		    i__2[1] = 1, a__1[1] = "q";
#line 2905 ""
		    i__2[2] = 1, a__1[2] = all_1.ulq + (commvl_1.ivx + 
			    all_1.ibmcnt[commvl_1.ivx - 1] * 24 - 25);
#line 2905 ""
		    s_cat(notexq, a__1, i__2, &c__3, (ftnlen)79);
#line 2906 ""
		}

/*  Check for dot */

#line 2910 ""
		if (bit_test(all_1.irest[commvl_1.ivx + ip1 * 24 - 25],2) && (
			r__1 = all_1.nodur[commvl_1.ivx + (ip1 + 1) * 24 - 25]
			 / 12.f - all_1.nodur[commvl_1.ivx + (ip1 + 1) * 24 - 
			25] / 12, dabs(r__1)) < .001f) {

/* Need a dot. already called addblank for noteq */

#line 2915 ""
		    if (*lnote == 0) {
/* Writing concatenation */
#line 2916 ""
			i__2[0] = 1, a__1[0] = all_1.sq;
#line 2916 ""
			i__2[1] = 2, a__1[1] = "pt";
#line 2916 ""
			i__2[2] = lnoten, a__1[2] = noteq;
#line 2916 ""
			s_cat(notexq, a__1, i__2, &c__3, (ftnlen)79);
#line 2917 ""
			*lnote = lnoten + 3;
#line 2918 ""
		    } else {
/* Writing concatenation */
#line 2919 ""
			i__3[0] = *lnote, a__2[0] = notexq;
#line 2919 ""
			i__3[1] = 1, a__2[1] = "p";
#line 2919 ""
			s_cat(notexq, a__2, i__3, &c__2, (ftnlen)79);
#line 2920 ""
			++(*lnote);
#line 2921 ""
		    }
#line 2922 ""
		}

/*  Insert the stemlength calcs here for dotted, unbeamed. */
/*  Later may combine with below to avoid repeat. */

#line 2927 ""
		if (bit_test(all_1.irest[commvl_1.ivx + ip1 * 24 - 25],2)) {
#line 2928 ""
		    nindent = igetbits_(&all_1.irest[commvl_1.ivx + ip1 * 24 
			    - 25], &c__2, &c__5);
#line 2929 ""
		    if (*(unsigned char *)&all_1.ulq[commvl_1.ivx + 
			    all_1.ibmcnt[commvl_1.ivx - 1] * 24 - 25] == 'u') 
			    {
#line 2930 ""
			slen = (nindent + 4.5f + comxtup_1.nolev1[
				commvl_1.ivx - 1] - nole - comxtup_1.islope[
				commvl_1.ivx - 1] * .4f / all_1.slfac) * 
				.6667f;
#line 2932 ""
		    } else {
#line 2933 ""
			slen = (nindent + 4.5f - comxtup_1.nolev1[
				commvl_1.ivx - 1] + nole + comxtup_1.islope[
				commvl_1.ivx - 1] * .4f / all_1.slfac) * 
				.6667f;
#line 2935 ""
		    }
#line 2936 ""
		    s_wsfi(&io___199);
#line 2936 ""
		    do_fio(&c__1, (char *)&slen, (ftnlen)sizeof(real));
#line 2936 ""
		    e_wsfi();
/* Writing concatenation */
#line 2937 ""
		    i__4[0] = 1, a__3[0] = all_1.sq;
#line 2937 ""
		    i__4[1] = 4, a__3[1] = "slx{";
#line 2937 ""
		    i__4[2] = 4, a__3[2] = tempq;
#line 2937 ""
		    i__4[3] = 1, a__3[3] = "}";
#line 2937 ""
		    i__4[4] = *lnote, a__3[4] = notexq;
#line 2937 ""
		    s_cat(notexq, a__3, i__4, &c__5, (ftnlen)79);
#line 2939 ""
		    *lnote += 10;
#line 2940 ""
		}
#line 2941 ""
	    } else if (bit_test(all_1.irest[commvl_1.ivx + ip1 * 24 - 25],2)) 
		    {

/* 1st note of unbeamed quarter or 8th trem, make a quarter note */

/* Stem length calcs here. The .2 factor is empirical, but */
/*   slfac accounts for musicsize. */

#line 2948 ""
		nindent = igetbits_(&all_1.irest[commvl_1.ivx + ip1 * 24 - 25]
			, &c__2, &c__5);
#line 2949 ""
		if (*(unsigned char *)&all_1.ulq[commvl_1.ivx + all_1.ibmcnt[
			commvl_1.ivx - 1] * 24 - 25] == 'u') {
#line 2950 ""
		    slen = (nindent + 4.5f + comxtup_1.nolev1[commvl_1.ivx - 
			    1] - nole - comxtup_1.islope[commvl_1.ivx - 1] * 
			    .4f / all_1.slfac) * .6667f;
#line 2952 ""
		} else {
#line 2953 ""
		    slen = (nindent + 4.5f - comxtup_1.nolev1[commvl_1.ivx - 
			    1] + nole + comxtup_1.islope[commvl_1.ivx - 1] * 
			    .4f / all_1.slfac) * .6667f;
#line 2955 ""
		}
#line 2956 ""
		s_wsfi(&io___200);
#line 2956 ""
		do_fio(&c__1, (char *)&slen, (ftnlen)sizeof(real));
#line 2956 ""
		e_wsfi();
/* Writing concatenation */
#line 2957 ""
		i__5[0] = 1, a__4[0] = all_1.sq;
#line 2957 ""
		i__5[1] = 4, a__4[1] = "slx{";
#line 2957 ""
		i__5[2] = 4, a__4[2] = tempq;
#line 2957 ""
		i__5[3] = 1, a__4[3] = "}";
#line 2957 ""
		i__5[4] = 1, a__4[4] = all_1.sq;
#line 2957 ""
		i__5[5] = 1, a__4[5] = "q";
#line 2957 ""
		i__5[6] = 1, a__4[6] = all_1.ulq + (commvl_1.ivx + 
			all_1.ibmcnt[commvl_1.ivx - 1] * 24 - 25);
#line 2957 ""
		s_cat(notexq, a__4, i__5, &c__7, (ftnlen)79);
#line 2959 ""
		*lnote = 13;

/* Check for dotted 2-note trem; prepend dot to notexq if needed */

#line 2963 ""
		if (all_1.nodur[commvl_1.ivx + (ip1 + 1) * 24 - 25] == 12 || 
			all_1.nodur[commvl_1.ivx + (ip1 + 1) * 24 - 25] == 24)
			 {
#line 2965 ""
		    if (lnoten == 1) {
/* Writing concatenation */
#line 2966 ""
			i__3[0] = 1, a__2[0] = " ";
#line 2966 ""
			i__3[1] = 1, a__2[1] = noteq;
#line 2966 ""
			s_cat(noteq, a__2, i__3, &c__2, (ftnlen)8);
#line 2967 ""
			lnoten = 2;
#line 2968 ""
		    }
/* Writing concatenation */
#line 2969 ""
		    i__6[0] = 1, a__5[0] = all_1.sq;
#line 2969 ""
		    i__6[1] = 2, a__5[1] = "pt";
#line 2969 ""
		    i__6[2] = lnoten, a__5[2] = noteq;
#line 2969 ""
		    i__6[3] = *lnote, a__5[3] = notexq;
#line 2969 ""
		    s_cat(notexq, a__5, i__6, &c__4, (ftnlen)79);
#line 2970 ""
		    *lnote = *lnote + 3 + lnoten;
#line 2971 ""
		    i__1 = ncmid_(&all_1.iv, &ip1);
#line 2971 ""
		    notefq_(noteq, &lnoten, &nole, &i__1, (ftnlen)8);
#line 2972 ""
		    gotnote = TRUE_;
#line 2973 ""
		    if (lnoten == 1) {
/* Writing concatenation */
#line 2974 ""
			i__3[0] = 1, a__2[0] = " ";
#line 2974 ""
			i__3[1] = 1, a__2[1] = noteq;
#line 2974 ""
			s_cat(noteq, a__2, i__3, &c__2, (ftnlen)8);
#line 2975 ""
			lnoten = 2;
#line 2976 ""
		    }
#line 2977 ""
		}
#line 2978 ""
	    } else if (multip == -1) {
/* Writing concatenation */
#line 2979 ""
		i__2[0] = 1, a__1[0] = all_1.sq;
#line 2979 ""
		i__2[1] = 1, a__1[1] = "h";
#line 2979 ""
		i__2[2] = 1, a__1[2] = all_1.ulq + (commvl_1.ivx + 
			all_1.ibmcnt[commvl_1.ivx - 1] * 24 - 25);
#line 2979 ""
		s_cat(notexq, a__1, i__2, &c__3, (ftnlen)79);
#line 2980 ""
	    } else if (multip == 1) {
/* Writing concatenation */
#line 2981 ""
		i__2[0] = 1, a__1[0] = all_1.sq;
#line 2981 ""
		i__2[1] = 1, a__1[1] = "c";
#line 2981 ""
		i__2[2] = 1, a__1[2] = all_1.ulq + (commvl_1.ivx + 
			all_1.ibmcnt[commvl_1.ivx - 1] * 24 - 25);
#line 2981 ""
		s_cat(notexq, a__1, i__2, &c__3, (ftnlen)79);
#line 2982 ""
	    } else if (multip == 2) {
/* Writing concatenation */
#line 2983 ""
		i__2[0] = 1, a__1[0] = all_1.sq;
#line 2983 ""
		i__2[1] = 2, a__1[1] = "cc";
#line 2983 ""
		i__2[2] = 1, a__1[2] = all_1.ulq + (commvl_1.ivx + 
			all_1.ibmcnt[commvl_1.ivx - 1] * 24 - 25);
#line 2983 ""
		s_cat(notexq, a__1, i__2, &c__3, (ftnlen)79);
#line 2984 ""
		*lnote = 4;
#line 2985 ""
	    } else if (multip == 3) {
/* Writing concatenation */
#line 2986 ""
		i__2[0] = 1, a__1[0] = all_1.sq;
#line 2986 ""
		i__2[1] = 3, a__1[1] = "ccc";
#line 2986 ""
		i__2[2] = 1, a__1[2] = all_1.ulq + (commvl_1.ivx + 
			all_1.ibmcnt[commvl_1.ivx - 1] * 24 - 25);
#line 2986 ""
		s_cat(notexq, a__1, i__2, &c__3, (ftnlen)79);
#line 2987 ""
		*lnote = 5;
#line 2988 ""
	    } else if (multip == -2) {
/* Writing concatenation */
#line 2989 ""
		i__3[0] = 1, a__2[0] = all_1.sq;
#line 2989 ""
		i__3[1] = 2, a__2[1] = "wh";
#line 2989 ""
		s_cat(notexq, a__2, i__3, &c__2, (ftnlen)79);
#line 2990 ""
	    } else if (multip == -3) {
/* Writing concatenation */
#line 2991 ""
		i__3[0] = 1, a__2[0] = all_1.sq;
#line 2991 ""
		i__3[1] = 5, a__2[1] = "breve";
#line 2991 ""
		s_cat(notexq, a__2, i__3, &c__2, (ftnlen)79);
#line 2992 ""
		*lnote = 6;
#line 2993 ""
	    } else {
#line 2994 ""
		s_wsle(&io___201);
#line 2994 ""
		e_wsle();
#line 2995 ""
		s_wsle(&io___202);
#line 2995 ""
		do_lio(&c__9, &c__1, "(Error in beamn1, send source to Dr. D"\
			"on)", (ftnlen)41);
#line 2995 ""
		e_wsle();
#line 2996 ""
		stop1_();
#line 2997 ""
	    }
#line 2998 ""
	    if (bit_test(all_1.nacc[commvl_1.ivx + ip1 * 24 - 25],19) || 
		    bit_test(all_1.nacc[commvl_1.ivx + ip1 * 24 - 25],27)) {
/*            notexq = notexq(1:3)//'p' */
/*            lnote = 4 */
/* Writing concatenation */
#line 3001 ""
		i__3[0] = *lnote, a__2[0] = notexq;
#line 3001 ""
		i__3[1] = 1, a__2[1] = "p";
#line 3001 ""
		s_cat(notexq, a__2, i__3, &c__2, (ftnlen)79);
#line 3002 ""
		++(*lnote);
#line 3003 ""
	    }
/* Writing concatenation */
#line 3004 ""
	    i__3[0] = *lnote, a__2[0] = notexq;
#line 3004 ""
	    i__3[1] = 8, a__2[1] = noteq;
#line 3004 ""
	    s_cat(notexq, a__2, i__3, &c__2, (ftnlen)79);
#line 3005 ""
	    *lnote += lnoten;
#line 3006 ""
	}
#line 3007 ""
	return 0;
#line 3008 ""
    }

/*  Check if mult. decreases from 1st note to 2nd */

#line 3012 ""
    if (all_1.ibm2[commvl_1.ivx + all_1.ibmcnt[commvl_1.ivx - 1] * 24 - 25] > 
	    ip1 || bit_test(all_1.islur[commvl_1.ivx + ip1 * 24 - 25],20)) {

/*  More than one note or single-note before a multiplicity-down-up "][" */

#line 3017 ""
	if (bit_test(all_1.islur[commvl_1.ivx + ip1 * 24 - 25],20)) {
#line 3018 ""
	    multr = 1;
#line 3019 ""
	} else if (! bit_test(all_1.irest[commvl_1.ivx + (ip1 + 1) * 24 - 25],
		0)) {
#line 3020 ""
	    multr = (15 & all_1.mult[commvl_1.ivx + (ip1 + 1) * 24 - 25]) - 8;
#line 3021 ""
	} else {
#line 3022 ""
	    multr = (15 & all_1.mult[commvl_1.ivx + (ip1 + 2) * 24 - 25]) - 8;
#line 3023 ""
	}
#line 3024 ""
	*lnote = 0;

/*  Check if staff-jumper */

#line 3028 ""
	if (combjmp_1.isbjmp && combjmp_1.ivbj2 > 0) {
#line 3029 ""
	    ivxp = combjmp_1.ivbj1;
#line 3030 ""
	} else {
#line 3031 ""
	    ivxp = commvl_1.ivx;
#line 3032 ""
	}
#line 3033 ""
	if (multr < multip) {
#line 3034 ""
	    i__1 = multr + 1;
#line 3034 ""
	    for (im = multip; im >= i__1; --im) {

/* Right-shifted 'termination' */

#line 3038 ""
		if (combjmp_1.isbjmp && combjmp_1.ivbj2 > 0) {

/* Jump beam */

#line 3042 ""
		    ntrbbb_(&im, "t", all_1.ulq + (ivxp + all_1.ibmcnt[
			    commvl_1.ivx - 1] * 24 - 25), &ivxp, notexq, 
			    lnote, (ftnlen)1, (ftnlen)1, (ftnlen)79);
#line 3044 ""
		} else {

/* Same staff */

#line 3048 ""
		    ntrbbb_(&im, "r", all_1.ulq + (commvl_1.ivx + 
			    all_1.ibmcnt[commvl_1.ivx - 1] * 24 - 25), &ivxp, 
			    notexq, lnote, (ftnlen)1, (ftnlen)1, (ftnlen)79);
#line 3049 ""
		}
#line 3050 ""
/* L1: */
#line 3050 ""
	    }
#line 3051 ""
	}
#line 3052 ""
    }

/*  Check for beamed, dotted 2-note tremolo */

#line 3056 ""
    if (bit_test(all_1.irest[commvl_1.ivx + ip1 * 24 - 25],2) && (r__1 = 
	    all_1.nodur[commvl_1.ivx + (ip1 + 1) * 24 - 25] / 12.f - 
	    all_1.nodur[commvl_1.ivx + (ip1 + 1) * 24 - 25] / 12, dabs(r__1)) 
	    < .001f) {
#line 3058 ""
	i__1 = ncmid_(&all_1.iv, &ip);
#line 3058 ""
	notefq_(noteq, &lnoten, &nole, &i__1, (ftnlen)8);
#line 3059 ""
	gotnote = TRUE_;
#line 3060 ""
	if (lnoten == 1) {
/* Writing concatenation */
#line 3061 ""
	    i__3[0] = 1, a__2[0] = " ";
#line 3061 ""
	    i__3[1] = 1, a__2[1] = noteq;
#line 3061 ""
	    s_cat(noteq, a__2, i__3, &c__2, (ftnlen)8);
#line 3062 ""
	    lnoten = 2;
#line 3063 ""
	}
#line 3064 ""
    }

/*  Put in the note, but check first for open-head beamed tremolo. */

#line 3068 ""
    if (bit_test(all_1.irest[commvl_1.ivx + ip1 * 24 - 25],2) && all_1.nodur[
	    commvl_1.ivx + (ip1 + 1) * 24 - 25] >= 32) {

/* 2-note open head tremolo */

#line 3072 ""
	if (*lnote > 0) {
/* Writing concatenation */
#line 3073 ""
	    i__2[0] = *lnote, a__1[0] = notexq;
#line 3073 ""
	    i__2[1] = 1, a__1[1] = all_1.sq;
#line 3073 ""
	    i__2[2] = 2, a__1[2] = "hb";
#line 3073 ""
	    s_cat(notexq, a__1, i__2, &c__3, (ftnlen)79);
#line 3074 ""
	} else {
/* Writing concatenation */
#line 3075 ""
	    i__3[0] = 1, a__2[0] = all_1.sq;
#line 3075 ""
	    i__3[1] = 2, a__2[1] = "hb";
#line 3075 ""
	    s_cat(notexq, a__2, i__3, &c__2, (ftnlen)79);
#line 3076 ""
	}
#line 3077 ""
    } else {
#line 3078 ""
	if (*lnote > 0) {
/* Writing concatenation */
#line 3079 ""
	    i__2[0] = *lnote, a__1[0] = notexq;
#line 3079 ""
	    i__2[1] = 1, a__1[1] = all_1.sq;
#line 3079 ""
	    i__2[2] = 2, a__1[2] = "qb";
#line 3079 ""
	    s_cat(notexq, a__1, i__2, &c__3, (ftnlen)79);
#line 3080 ""
	} else {
/* Writing concatenation */
#line 3081 ""
	    i__3[0] = 1, a__2[0] = all_1.sq;
#line 3081 ""
	    i__3[1] = 2, a__2[1] = "qb";
#line 3081 ""
	    s_cat(notexq, a__2, i__3, &c__2, (ftnlen)79);
#line 3082 ""
	}
#line 3083 ""
    }
#line 3084 ""
    *lnote += 3;
#line 3085 ""
    if (bit_test(all_1.irest[commvl_1.ivx + ip1 * 24 - 25],2) && (all_1.nodur[
	    commvl_1.ivx + (ip1 + 1) * 24 - 25] == 24 || all_1.nodur[
	    commvl_1.ivx + (ip1 + 1) * 24 - 25] == 12 || all_1.nodur[
	    commvl_1.ivx + (ip1 + 1) * 24 - 25] == 48)) {

/* 2-note trem on dotted note */

/* Writing concatenation */
#line 3091 ""
	i__3[0] = *lnote, a__2[0] = notexq;
#line 3091 ""
	i__3[1] = 1, a__2[1] = "p";
#line 3091 ""
	s_cat(notexq, a__2, i__3, &c__2, (ftnlen)79);
#line 3092 ""
	++(*lnote);
#line 3093 ""
    }

/*  Check for dot */

#line 3097 ""
    isdotm = FALSE_;
#line 3098 ""
    if (! comxtup_1.vxtup[commvl_1.ivx - 1]) {
#line 3099 ""
	nd = all_1.nodur[commvl_1.ivx + all_1.ipo[all_1.jn - 1] * 24 - 25];
#line 3100 ""
	if (nd != 0) {
#line 3101 ""
	    i__1 = log2_(&nd);
#line 3101 ""
	    if (pow_ii(&c__2, &i__1) != nd) {
#line 3102 ""
		if (! bit_test(all_1.iornq[commvl_1.ivx + ip1 * 24 - 1],13)) {
#line 3103 ""
		    if (! bit_test(all_1.islur[commvl_1.ivx + ip1 * 24 - 25],
			    3)) {
/* Writing concatenation */
#line 3104 ""
			i__3[0] = *lnote, a__2[0] = notexq;
#line 3104 ""
			i__3[1] = 1, a__2[1] = "p";
#line 3104 ""
			s_cat(notexq, a__2, i__3, &c__2, (ftnlen)79);
#line 3105 ""
		    } else {

/*  Double dot */

/* Writing concatenation */
#line 3109 ""
			i__3[0] = *lnote, a__2[0] = notexq;
#line 3109 ""
			i__3[1] = 2, a__2[1] = "pp";
#line 3109 ""
			s_cat(notexq, a__2, i__3, &c__2, (ftnlen)79);
#line 3110 ""
			++(*lnote);
#line 3111 ""
		    }
#line 3112 ""
		} else {
/* Writing concatenation */
#line 3113 ""
		    i__3[0] = *lnote, a__2[0] = notexq;
#line 3113 ""
		    i__3[1] = 1, a__2[1] = "m";
#line 3113 ""
		    s_cat(notexq, a__2, i__3, &c__2, (ftnlen)79);
#line 3114 ""
		    isdotm = TRUE_;
#line 3115 ""
		}
#line 3116 ""
		++(*lnote);
#line 3117 ""
	    }
#line 3118 ""
	}
#line 3119 ""
    } else if (bit_test(all_1.nacc[commvl_1.ivx + ip1 * 24 - 25],19) || 
	    bit_test(all_1.nacc[commvl_1.ivx + ip1 * 24 - 25],27)) {

/*  In an xtup with special 2:1 notation with a dot on 1st note, or normal dot */

/* Writing concatenation */
#line 3124 ""
	i__3[0] = *lnote, a__2[0] = notexq;
#line 3124 ""
	i__3[1] = 1, a__2[1] = "p";
#line 3124 ""
	s_cat(notexq, a__2, i__3, &c__2, (ftnlen)79);
#line 3125 ""
	++(*lnote);
#line 3126 ""
    }

/*  Do the number; 0 if 12 */
/*  5/25/08 allow >12 */

#line 3131 ""
    if (! bit_test(all_1.irest[commvl_1.ivx + ip1 * 24 - 25],24)) {
#line 3132 ""
	i__1 = commvl_1.ivx % 24;
#line 3132 ""
	istring_(&i__1, numq, &len, (ftnlen)8);
#line 3133 ""
    } else {

/*  1st note of staff-jumping beam */

#line 3137 ""
	i__1 = combjmp_1.ivbj1 % 24;
#line 3137 ""
	istring_(&i__1, numq, &len, (ftnlen)8);
#line 3138 ""
    }
/* Writing concatenation */
#line 3139 ""
    i__3[0] = *lnote, a__2[0] = notexq;
#line 3139 ""
    i__3[1] = len, a__2[1] = numq;
#line 3139 ""
    s_cat(notexq, a__2, i__3, &c__2, (ftnlen)79);
#line 3140 ""
    *lnote += len;
#line 3141 ""
    if (! gotnote) {
#line 3142 ""
	i__1 = ncmid_(&all_1.iv, &ip1);
#line 3142 ""
	notefq_(noteq, &lnoten, &nole, &i__1, (ftnlen)8);
#line 3143 ""
    }
/* Writing concatenation */
#line 3144 ""
    i__3[0] = *lnote, a__2[0] = notexq;
#line 3144 ""
    i__3[1] = lnoten, a__2[1] = noteq;
#line 3144 ""
    s_cat(notexq, a__2, i__3, &c__2, (ftnlen)79);
#line 3145 ""
    *lnote += lnoten;
#line 3146 ""
    if (isdotm) {
#line 3147 ""
	if (lnoten == 1) {
/* Writing concatenation */
#line 3148 ""
	    i__6[0] = *lnote, a__5[0] = notexq;
#line 3148 ""
	    i__6[1] = 1, a__5[1] = "{";
#line 3148 ""
	    i__6[2] = 1, a__5[2] = noteq;
#line 3148 ""
	    i__6[3] = 1, a__5[3] = "}";
#line 3148 ""
	    s_cat(notexq, a__5, i__6, &c__4, (ftnlen)79);
#line 3149 ""
	    *lnote += 3;
#line 3150 ""
	} else {
#line 3151 ""
	    i__1 = lnoten - 2;
/* Writing concatenation */
#line 3151 ""
	    i__3[0] = *lnote, a__2[0] = notexq;
#line 3151 ""
	    i__3[1] = lnoten - 1 - i__1, a__2[1] = noteq + i__1;
#line 3151 ""
	    s_cat(notexq, a__2, i__3, &c__2, (ftnlen)79);
#line 3152 ""
	    ++(*lnote);
#line 3153 ""
	}
#line 3154 ""
    }
#line 3155 ""
    return 0;
} /* beamn1_ */

/* Subroutine */ int beamstrt_(char *notexq, integer *lnote, integer *nornb, 
	integer *ihornb, real *space, real *squez, integer *ib, ftnlen 
	notexq_len)
{
    /* System generated locals */
    address a__1[4], a__2[2], a__3[3], a__4[5];
    integer i__1[4], i__2[2], i__3[3], i__4, i__5, i__6, i__7[5];
    real r__1;
    char ch__1[1];
    icilist ici__1;

    /* Builtin functions */
    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
    integer s_wsfi(icilist *), do_fio(integer *, char *, ftnlen), e_wsfi(void)
	    ;
    /* Subroutine */ int s_copy(char *, char *, ftnlen, ftnlen);
    integer i_nint(real *), pow_ii(integer *, integer *), i_sign(integer *, 
	    integer *), lbit_shift(integer, integer);

    /* Local variables */
    static logical addbrack;
    extern /* Subroutine */ int addblank_(char *, integer *, ftnlen);
    extern integer igetbits_(integer *, integer *, integer *);
    static logical usexnumt;
    static integer nomornlev, ip, levbracket, ibc, inb, iud, imp, isk, ipp, 
	    ivf, iup;
    static logical xto;
    static integer ipb1, iadj;
    static logical writebrests;
    static integer icrd;
    extern /* Character */ VOID chax_(char *, ftnlen, integer *);
    extern doublereal feon_(real *);
    static integer levc, nole, iorn;
    static real ymin, ybot;
    static integer levx;
    static real xnsk;
    extern integer ncmid_(integer *, integer *);
    static real ybeam;
    static integer ipmid, iflop;
    static real bmlev;
    static integer icrdx, multb;
    static char noteq[8], tempq[79];
    static integer ltemp;
    static char restq[40];
    extern integer levrn_(integer *, integer *, integer *, integer *, integer 
	    *);
    static integer nlnum, lrest;
    extern /* Subroutine */ int notex_(char *, integer *, ftnlen);
    static integer isssb;
    static real zmult;
    extern /* Subroutine */ int ntrbbb_(integer *, char *, char *, integer *, 
	    char *, integer *, ftnlen, ftnlen, ftnlen);
    static integer multbb, lnoten;
    static real xnlmid;
    extern /* Subroutine */ int notefq_(char *, integer *, integer *, integer 
	    *, ftnlen), setupb_(real *, integer *, real *, real *, integer *, 
	    real *, integer *);
    static integer mprint;
    static real xslope;
    static integer nvtrem;
    extern /* Subroutine */ int putxtn_(integer *, integer *, integer *, 
	    integer *, real *, real *, integer *, integer *, real *, real *, 
	    integer *, integer *, char *, integer *, integer *, real *, 
	    integer *, integer *, integer *, logical *, ftnlen);
    static integer nindent, maxdrop, numinit;

    /* Fortran I/O blocks */
    static icilist io___223 = { 0, noteq, 0, "(i1)", 8, 1 };
    static icilist io___225 = { 0, noteq, 0, "(a1,i2,a1)", 8, 1 };
    static icilist io___226 = { 0, noteq, 0, "(i1,a1)", 8, 1 };
    static icilist io___227 = { 0, noteq, 0, "(a1,i2,a2)", 8, 1 };
    static icilist io___243 = { 0, tempq, 0, "(i2)", 2, 1 };



/*  The following is just to save the outputs from SetupB for the case of */
/*  xtups starting with a rest, where beamstrt is called twice. */

#line 3209 ""
    /* Parameter adjustments */
#line 3209 ""
    --squez;
#line 3209 ""
    --space;
#line 3209 ""
    ihornb -= 25;
#line 3209 ""
    --nornb;
#line 3209 ""

#line 3209 ""
    /* Function Body */
#line 3209 ""
    writebrests = TRUE_;
#line 3210 ""
    ibc = all_1.ibmcnt[commvl_1.ivx - 1];
#line 3211 ""
    ipb1 = all_1.ibm1[commvl_1.ivx + ibc * 24 - 25];
#line 3212 ""
    multb = (15 & all_1.mult[commvl_1.ivx + ipb1 * 24 - 25]) - 8;
#line 3213 ""
    ip = all_1.ipo[all_1.jn - 1];
#line 3214 ""
    *lnote = 0;
#line 3215 ""
    nvtrem = 0;

/*  Compute slopes and note offsets from start of beam.  Inside SetupB, for each */
/*  xtup in the beam, set eloff,mtupv (in comxtup) for printed number. Also */
/*  gets islope(ivx), transferred in common. */

/* Vertical adjustment beams for tremolo */
#line 3221 ""
    if (strtmid_1.ixrest[commvl_1.ivx - 1] == 0 && ! bit_test(all_1.nacc[
	    commvl_1.ivx + ip * 24 - 25],21)) {
#line 3221 ""
	setupb_(comxtup_1.xelsk, &comipb_1.nnb, &comipb_1.sumx, &
		comipb_1.sumy, comipb_1.ipb, &comipb_1.smed, &
		strtmid_1.ixrest[commvl_1.ivx - 1]);
#line 3221 ""
    }

/* Will always come past here after entering beamstrt for 2-note tremolo, and */
/* slope will have been computed, even for unbeamed. So start the indented */
/* beams here. The indented tremolo bars will be added to the notexq output */
/* string, under the tacet assumption that there is no horizontal shift */
/* enacted by the action just before and after the call to beamstrt. */

#line 3230 ""
    if (bit_test(all_1.irest[commvl_1.ivx + ipb1 * 24 - 25],2) && igetbits_(&
	    all_1.irest[commvl_1.ivx + ipb1 * 24 - 25], &c__2, &c__5) > 0) {
#line 3232 ""
	nindent = igetbits_(&all_1.irest[commvl_1.ivx + ipb1 * 24 - 25], &
		c__2, &c__5);
/* Writing concatenation */
#line 3233 ""
	i__1[0] = 1, a__1[0] = all_1.sq;
#line 3233 ""
	i__1[1] = 12, a__1[1] = "roffset{.7}{";
#line 3233 ""
	i__1[2] = 1, a__1[2] = all_1.sq;
#line 3233 ""
	i__1[3] = 2, a__1[3] = "ib";
#line 3233 ""
	s_cat(tempq, a__1, i__1, &c__4, (ftnlen)79);
#line 3234 ""
	ltemp = 16;
#line 3235 ""
	if (nindent == 2) {
/* Writing concatenation */
#line 3236 ""
	    i__2[0] = 16, a__2[0] = tempq;
#line 3236 ""
	    i__2[1] = 1, a__2[1] = "b";
#line 3236 ""
	    s_cat(tempq, a__2, i__2, &c__2, (ftnlen)79);
#line 3237 ""
	    ltemp = 17;
#line 3238 ""
	} else if (nindent == 3) {
/* Writing concatenation */
#line 3239 ""
	    i__2[0] = 16, a__2[0] = tempq;
#line 3239 ""
	    i__2[1] = 2, a__2[1] = "bb";
#line 3239 ""
	    s_cat(tempq, a__2, i__2, &c__2, (ftnlen)79);
#line 3240 ""
	    ltemp = 18;
#line 3241 ""
	}

/* Use beam # 0 for indented beams */

/* Writing concatenation */
#line 3245 ""
	i__3[0] = ltemp, a__3[0] = tempq;
#line 3245 ""
	i__3[1] = 1, a__3[1] = all_1.ulq + (commvl_1.ivx + ibc * 24 - 25);
#line 3245 ""
	i__3[2] = 1, a__3[2] = "0";
#line 3245 ""
	s_cat(tempq, a__3, i__3, &c__3, (ftnlen)79);
#line 3246 ""
	ltemp += 2;

/* Get adjustment to nolev1 for main beam based on nindent */

#line 3250 ""
	if (*(unsigned char *)&all_1.ulq[commvl_1.ivx + ibc * 24 - 25] == 'u')
		 {
#line 3251 ""
	    nvtrem = nindent - 1;
#line 3252 ""
	} else {
#line 3253 ""
	    nvtrem = 1 - nindent;
#line 3254 ""
	}

/* Get numerical position of initiation for main beam. Will adjust height at */
/*   closing to account for nindent */

#line 3259 ""
	numinit = comxtup_1.nolev1[commvl_1.ivx - 1] - ncmid_(&all_1.iv, &
		ipb1) + 4;

/* Get forced beam height tweak, apply here for indented beams */

#line 3263 ""
	iadj = igetbits_(&all_1.ipl[commvl_1.ivx + ipb1 * 24 - 25], &c__6, &
		c__11) - 30;
#line 3264 ""
	if (iadj != -30) {
#line 3264 ""
	    numinit += iadj;
#line 3264 ""
	}
#line 3265 ""
	if (numinit >= 0 && numinit <= 9) {
#line 3266 ""
	    s_wsfi(&io___223);
#line 3266 ""
	    do_fio(&c__1, (char *)&numinit, (ftnlen)sizeof(integer));
#line 3266 ""
	    e_wsfi();
#line 3267 ""
	    lnoten = 1;
#line 3268 ""
	} else {
#line 3269 ""
	    s_wsfi(&io___225);
#line 3269 ""
	    do_fio(&c__1, "{", (ftnlen)1);
#line 3269 ""
	    do_fio(&c__1, (char *)&numinit, (ftnlen)sizeof(integer));
#line 3269 ""
	    do_fio(&c__1, "}", (ftnlen)1);
#line 3269 ""
	    e_wsfi();
#line 3270 ""
	    lnoten = 4;
#line 3271 ""
	}
/* Writing concatenation */
#line 3272 ""
	i__2[0] = ltemp, a__2[0] = tempq;
#line 3272 ""
	i__2[1] = lnoten, a__2[1] = noteq;
#line 3272 ""
	s_cat(tempq, a__2, i__2, &c__2, (ftnlen)79);
#line 3273 ""
	ltemp += lnoten;

/* Now do the slope. */
/* 170408 Baseline is in islope(ivx). Apply slope tweak if present. */

#line 3278 ""
	numinit = comxtup_1.islope[commvl_1.ivx - 1];
#line 3279 ""
	iadj = igetbits_(&all_1.ipl[commvl_1.ivx + ipb1 * 24 - 25], &c__6, &
		c__17) - 30;
#line 3280 ""
	if (iadj != -30) {
#line 3280 ""
	    numinit += iadj;
#line 3280 ""
	}
#line 3281 ""
	if (numinit >= 0 && numinit <= 9) {
#line 3282 ""
	    s_wsfi(&io___226);
#line 3282 ""
	    do_fio(&c__1, (char *)&numinit, (ftnlen)sizeof(integer));
#line 3282 ""
	    do_fio(&c__1, "}", (ftnlen)1);
#line 3282 ""
	    e_wsfi();
#line 3283 ""
	    lnoten = 2;
#line 3284 ""
	} else {
#line 3285 ""
	    s_wsfi(&io___227);
#line 3285 ""
	    do_fio(&c__1, "{", (ftnlen)1);
#line 3285 ""
	    do_fio(&c__1, (char *)&numinit, (ftnlen)sizeof(integer));
#line 3285 ""
	    do_fio(&c__1, "}}", (ftnlen)2);
#line 3285 ""
	    e_wsfi();
#line 3286 ""
	    lnoten = 5;
#line 3287 ""
	}
/* Writing concatenation */
#line 3288 ""
	i__2[0] = ltemp, a__2[0] = tempq;
#line 3288 ""
	i__2[1] = lnoten, a__2[1] = noteq;
#line 3288 ""
	s_cat(tempq, a__2, i__2, &c__2, (ftnlen)79);
#line 3289 ""
	ltemp += lnoten;
#line 3290 ""
	s_copy(notexq, tempq, (ftnlen)79, (ftnlen)79);
#line 3291 ""
	*lnote = ltemp;
#line 3292 ""
    }
#line 3293 ""
    if (bit_test(all_1.nacc[commvl_1.ivx + ip * 24 - 25],21)) {

/*  This is start of later segment of single-slope beam group so use slope and */
/*    height from prior beam.   Slope is already OK. */

#line 3298 ""
	++comxtup_1.issb[commvl_1.ivx - 1];
#line 3299 ""
	comxtup_1.nolev1[commvl_1.ivx - 1] = comxtup_1.lev1ssb[commvl_1.ivx + 
		comxtup_1.issb[commvl_1.ivx - 1] * 24 - 25];
#line 3300 ""
    }

/*  Move this up to before indented beams for tremolo */
/*      lnote = 0 */
#line 3304 ""
    comdraw_1.drawbm[commvl_1.ivx - 1] = TRUE_;
#line 3305 ""
    if (bit_test(all_1.irest[commvl_1.ivx + ipb1 * 24 - 25],28) && 
	    strtmid_1.ixrest[commvl_1.ivx - 1] != 2) {
#line 3306 ""
	comxtup_1.vxtup[commvl_1.ivx - 1] = TRUE_;
#line 3307 ""
	++comxtup_1.nxtinbm[commvl_1.ivx - 1];

/*  irest(28)=>Xtup starts on this note.  Set up for xtuplet. */
/*  Number goes on notehead side at middle note (or gap) of xtup, unless that */
/*  puts it in staff, then it flops to stem (or beam) side. */
/*               __          __ */
/*         |    |  |   O    |  | */
/*         O      |    |      O */
/*       |___|    O  |__|     | */

/*  iud   -1     -1    1      1    ...stem direction */
/* iflop   0      1   -1      0    ...direction of flop */
/*  iup   -1      1   -1      1    ...direction of number and bracket */

#line 3321 ""
	iud = 1;
#line 3322 ""
	if (*(unsigned char *)&all_1.ulq[commvl_1.ivx + ibc * 24 - 25] == 'u')
		 {
#line 3322 ""
	    iud = -1;
#line 3322 ""
	}

/*  Get ip#, note level of middle note (or gap) in xtup */

#line 3326 ""
	ipmid = ipb1 + comxtup_1.ntupv[commvl_1.ivx + comxtup_1.nxtinbm[
		commvl_1.ivx - 1] * 24 - 25] / 2;

/*  130129 If middle note is a rest, go to next note. Note last note cannot */
/*    be a rest */

#line 3331 ""
L14:
#line 3332 ""
	if (bit_test(all_1.irest[commvl_1.ivx + ipmid * 24 - 25],0)) {
#line 3333 ""
	    ++ipmid;
#line 3334 ""
	    goto L14;
#line 3335 ""
	}
#line 3336 ""
	i__4 = ncmid_(&all_1.iv, &ipmid);
#line 3336 ""
	i__5 = (15 & all_1.mult[commvl_1.ivx + ipmid * 24 - 25]) - 8;
#line 3336 ""
	xnlmid = (real) levrn_(&all_1.nolev[commvl_1.ivx + ipmid * 24 - 25], &
		all_1.irest[commvl_1.ivx + ipmid * 24 - 25], &iud, &i__4, &
		i__5);
#line 3338 ""
	if (comxtup_1.ntupv[commvl_1.ivx + comxtup_1.nxtinbm[commvl_1.ivx - 1]
		 * 24 - 25] % 2 == 0) {
#line 3338 ""
	    i__5 = ipmid - 1;
#line 3338 ""
	    i__4 = ncmid_(&all_1.iv, &i__5);
#line 3338 ""
	    i__6 = (15 & all_1.mult[commvl_1.ivx + (ipmid - 1) * 24 - 25]) - 
		    8;
#line 3338 ""
	    xnlmid = (xnlmid + levrn_(&all_1.nolev[commvl_1.ivx + (ipmid - 1) 
		    * 24 - 25], &all_1.irest[commvl_1.ivx + (ipmid - 1) * 24 
		    - 25], &iud, &i__4, &i__6)) / 2;
#line 3338 ""
	}
#line 3341 ""
	iflop = 0;
#line 3342 ""
	if ((r__1 = xnlmid - ncmid_(&all_1.iv, &ipb1), dabs(r__1)) < 3.f) {
#line 3342 ""
	    iflop = -iud;
#line 3342 ""
	}
#line 3343 ""
	iup = iud + (iflop << 1);
#line 3344 ""
	if (bit_test(all_1.irest[commvl_1.ivx + ipb1 * 24 - 25],14)) {

/*  Alter iud, iflop, iup to flip number/bracket. (Stare at above pic) */

#line 3348 ""
	    iup = -iup;
#line 3349 ""
	    iflop = 0;
#line 3350 ""
	    if (iud * iup < 0) {
#line 3350 ""
		iflop = iup;
#line 3350 ""
	    }
#line 3351 ""
	}

/*  Determine if a beam is to be drawn. */
/*    Had problem w/ half-note 2-note xtups always F, so add a test */

#line 3356 ""
	if (igetbits_(&all_1.irest[commvl_1.ivx + ipb1 * 24 - 25], &c__2, &
		c__3) != 0) {
#line 3357 ""
	    comdraw_1.drawbm[commvl_1.ivx - 1] = TRUE_;
#line 3358 ""
	    goto L6;
#line 3359 ""
	}
#line 3360 ""
	i__4 = all_1.ibm2[commvl_1.ivx + ibc * 24 - 25];
#line 3360 ""
	for (ipp = all_1.ibm1[commvl_1.ivx + ibc * 24 - 25]; ipp <= i__4; 
		++ipp) {
#line 3361 ""
	    if ((15 & all_1.mult[commvl_1.ivx + ipp * 24 - 25]) - 8 <= 0) {
#line 3362 ""
		comdraw_1.drawbm[commvl_1.ivx - 1] = FALSE_;
#line 3363 ""
		goto L6;
#line 3364 ""
	    }
#line 3365 ""
/* L5: */
#line 3365 ""
	}
#line 3366 ""
	comdraw_1.drawbm[commvl_1.ivx - 1] = ! bit_test(all_1.islur[
		commvl_1.ivx + all_1.ibm1[commvl_1.ivx + ibc * 24 - 25] * 24 
		- 25],18);
#line 3367 ""
L6:

/* Are we using tuplet.tex? */

#line 3371 ""
	usexnumt = comnvst_1.cstuplet && ! comdraw_1.drawbm[commvl_1.ivx - 1];

/* Check for single note xtup 171217 */

#line 3375 ""
	if (bit_test(all_1.irest[commvl_1.ivx + ipb1 * 24 - 25],28) && 
		comipb_1.nnb == 1) {
#line 3376 ""
	    comdraw_1.drawbm[commvl_1.ivx - 1] = FALSE_;
#line 3377 ""
	}

/*  Place xtup number if needed */

#line 3381 ""
	if (! bit_test(all_1.islur[commvl_1.ivx + ipb1 * 24 - 25],31) || 
		multb <= 0) {
#line 3382 ""
	    mprint = igetbits_(&all_1.nacc[commvl_1.ivx + ip * 24 - 25], &
		    c__5, &c__22);
#line 3383 ""
	    if (mprint == 0) {
#line 3383 ""
		mprint = comxtup_1.mtupv[commvl_1.ivx + comxtup_1.nxtinbm[
			commvl_1.ivx - 1] * 24 - 25];
#line 3383 ""
	    }
/* Stab in the dark! Note: tried setting unbeam flag islur18 but no go. */
#line 3385 ""
	    if (comipb_1.nnb == 1) {
#line 3386 ""
		xnlmid = (real) comxtup_1.nolev1[commvl_1.ivx - 1];
#line 3387 ""
		comxtup_1.islope[commvl_1.ivx - 1] = 0;

/* Move up, outside number check block, so all 1-note xtups ar unbeamed */
/*            drawbm(ivx) = .false. */

#line 3392 ""
	    }
#line 3393 ""
	    i__4 = ncmid_(&all_1.iv, &ipb1);
#line 3393 ""
	    putxtn_(&mprint, &iflop, &multb, &iud, &comask_1.wheadpt, &
		    comask_1.poenom, &comxtup_1.nolev1[commvl_1.ivx - 1], &
		    comxtup_1.islope[commvl_1.ivx - 1], &all_1.slfac, &xnlmid,
		     &all_1.islur[commvl_1.ivx + ipb1 * 24 - 25], lnote, 
		    notexq, &i__4, &nlnum, &comxtup_1.eloff[commvl_1.ivx + 
		    comxtup_1.nxtinbm[commvl_1.ivx - 1] * 24 - 25], &iup, &
		    all_1.irest[commvl_1.ivx + ipb1 * 24 - 25], &all_1.mult[
		    commvl_1.ivx + ipb1 * 24 - 25], &usexnumt, (ftnlen)79);
#line 3397 ""
	}
#line 3398 ""
	if (! comdraw_1.drawbm[commvl_1.ivx - 1]) {

/*  Xtuplet with no beam */

#line 3402 ""
	    if (! bit_test(all_1.islur[commvl_1.ivx + ipb1 * 24 - 25],31)) {

/*  Number printing has not been suppressed, so put in the bracket. */
/*    scale = stretch factor for bracket if there are asx's */
/*    xnsk = length of the bracket in \noteskips = (\elemskips)/(eon) */

#line 3408 ""
		r__1 = space[*ib] / squez[*ib];
#line 3408 ""
		xnsk = (comeskz2_1.eskz2[commvl_1.ivx + (ipb1 + 
			comxtup_1.ntupv[commvl_1.ivx + comxtup_1.nxtinbm[
			commvl_1.ivx - 1] * 24 - 25] - 1) * 24 - 25] - 
			comeskz2_1.eskz2[commvl_1.ivx + ipb1 * 24 - 25]) / 
			squez[*ib] / feon_(&r__1);
#line 3410 ""
		if (iup == 1) {
#line 3411 ""
		    if (*lnote > 0) {
/* Writing concatenation */
#line 3412 ""
			i__3[0] = *lnote, a__3[0] = notexq;
#line 3412 ""
			i__3[1] = 1, a__3[1] = all_1.sq;
#line 3412 ""
			i__3[2] = 5, a__3[2] = "ovbkt";
#line 3412 ""
			s_cat(notexq, a__3, i__3, &c__3, (ftnlen)79);
#line 3413 ""
		    } else {
/* Writing concatenation */
#line 3414 ""
			i__2[0] = 1, a__2[0] = all_1.sq;
#line 3414 ""
			i__2[1] = 5, a__2[1] = "ovbkt";
#line 3414 ""
			s_cat(notexq, a__2, i__2, &c__2, (ftnlen)79);
#line 3415 ""
		    }
#line 3416 ""
		} else {
#line 3417 ""
		    if (*lnote > 0) {
/* Writing concatenation */
#line 3418 ""
			i__3[0] = *lnote, a__3[0] = notexq;
#line 3418 ""
			i__3[1] = 1, a__3[1] = all_1.sq;
#line 3418 ""
			i__3[2] = 5, a__3[2] = "unbkt";
#line 3418 ""
			s_cat(notexq, a__3, i__3, &c__3, (ftnlen)79);
#line 3419 ""
		    } else {

/*  Introduced 12/5/98, req'd due to possible presence of in-line TeX */

/* Writing concatenation */
#line 3423 ""
			i__2[0] = 1, a__2[0] = all_1.sq;
#line 3423 ""
			i__2[1] = 5, a__2[1] = "unbkt";
#line 3423 ""
			s_cat(notexq, a__2, i__2, &c__2, (ftnlen)79);
#line 3424 ""
		    }
#line 3425 ""
		}
#line 3426 ""
		*lnote += 6;
#line 3427 ""
		if (all_1.iline == 1) {
#line 3428 ""
		    comipb_1.smed /= 1.f - comtop_1.fracindent;
#line 3429 ""
		}
#line 3430 ""
		xslope = comipb_1.smed * 1.8f * all_1.slfac;
#line 3431 ""
		comxtup_1.islope[commvl_1.ivx - 1] = i_nint(&xslope);
#line 3432 ""
		r__1 = comipb_1.smed * comxtup_1.eloff[commvl_1.ivx - 1];
#line 3432 ""
		comxtup_1.nolev1[commvl_1.ivx - 1] = nlnum - i_nint(&r__1);
#line 3433 ""
		if (comxtup_1.islope[commvl_1.ivx - 1] == 0) {
#line 3433 ""
		    --comxtup_1.nolev1[commvl_1.ivx - 1];
#line 3433 ""
		}
#line 3434 ""
		if (iup == 1) {
#line 3434 ""
		    comxtup_1.nolev1[commvl_1.ivx - 1] += 4;
#line 3434 ""
		}
#line 3435 ""
		levbracket = comxtup_1.nolev1[commvl_1.ivx - 1];
#line 3436 ""
		if (iup == 1 && comnvst_1.cstuplet) {
#line 3436 ""
		    --levbracket;
#line 3436 ""
		}
#line 3437 ""
		i__4 = ncmid_(&all_1.iv, &ipb1);
#line 3437 ""
		notefq_(noteq, &lnoten, &levbracket, &i__4, (ftnlen)8);
#line 3438 ""
		if (lnoten == 1) {
#line 3438 ""
		    addblank_(noteq, &lnoten, (ftnlen)8);
#line 3438 ""
		}
/* Writing concatenation */
#line 3439 ""
		i__3[0] = *lnote, a__3[0] = notexq;
#line 3439 ""
		i__3[1] = lnoten, a__3[1] = noteq;
#line 3439 ""
		i__3[2] = 1, a__3[2] = "{";
#line 3439 ""
		s_cat(notexq, a__3, i__3, &c__3, (ftnlen)79);
#line 3440 ""
		*lnote = *lnote + lnoten + 1;
#line 3441 ""
		if (xnsk < .995f) {
#line 3442 ""
		    i__4 = *lnote;
#line 3442 ""
		    ici__1.icierr = 0;
#line 3442 ""
		    ici__1.icirnum = 1;
#line 3442 ""
		    ici__1.icirlen = *lnote + 4 - i__4;
#line 3442 ""
		    ici__1.iciunit = notexq + i__4;
#line 3442 ""
		    ici__1.icifmt = "(i1,f3.2)";
#line 3442 ""
		    s_wsfi(&ici__1);
#line 3442 ""
		    do_fio(&c__1, (char *)&c__0, (ftnlen)sizeof(integer));
#line 3442 ""
		    do_fio(&c__1, (char *)&xnsk, (ftnlen)sizeof(real));
#line 3442 ""
		    e_wsfi();
#line 3443 ""
		    *lnote += 4;
#line 3444 ""
		} else if (xnsk < 9.995f) {
#line 3445 ""
		    i__4 = *lnote;
#line 3445 ""
		    ici__1.icierr = 0;
#line 3445 ""
		    ici__1.icirnum = 1;
#line 3445 ""
		    ici__1.icirlen = *lnote + 4 - i__4;
#line 3445 ""
		    ici__1.iciunit = notexq + i__4;
#line 3445 ""
		    ici__1.icifmt = "(f4.2)";
#line 3445 ""
		    s_wsfi(&ici__1);
#line 3445 ""
		    do_fio(&c__1, (char *)&xnsk, (ftnlen)sizeof(real));
#line 3445 ""
		    e_wsfi();
#line 3446 ""
		    *lnote += 4;
#line 3447 ""
		} else {
#line 3448 ""
		    i__4 = *lnote;
#line 3448 ""
		    ici__1.icierr = 0;
#line 3448 ""
		    ici__1.icirnum = 1;
#line 3448 ""
		    ici__1.icirlen = *lnote + 5 - i__4;
#line 3448 ""
		    ici__1.iciunit = notexq + i__4;
#line 3448 ""
		    ici__1.icifmt = "(f5.2)";
#line 3448 ""
		    s_wsfi(&ici__1);
#line 3448 ""
		    do_fio(&c__1, (char *)&xnsk, (ftnlen)sizeof(real));
#line 3448 ""
		    e_wsfi();
#line 3449 ""
		    *lnote += 5;
#line 3450 ""
		}
/* Writing concatenation */
#line 3451 ""
		i__2[0] = *lnote, a__2[0] = notexq;
#line 3451 ""
		i__2[1] = 1, a__2[1] = "}";
#line 3451 ""
		s_cat(notexq, a__2, i__2, &c__2, (ftnlen)79);
#line 3452 ""
		++(*lnote);
#line 3453 ""
		if (bit_test(all_1.mult[commvl_1.ivx + ipb1 * 24 - 25],4)) {

/* Tweak slope of bracket */

#line 3457 ""
		    comxtup_1.islope[commvl_1.ivx - 1] = comxtup_1.islope[
			    commvl_1.ivx - 1] + igetbits_(&all_1.mult[
			    commvl_1.ivx + ipb1 * 24 - 25], &c__5, &c__5) - 
			    16;
#line 3458 ""
		}
#line 3459 ""
		if (comxtup_1.islope[commvl_1.ivx - 1] < 0 || 
			comxtup_1.islope[commvl_1.ivx - 1] >= 10) {
/* Writing concatenation */
#line 3460 ""
		    i__2[0] = *lnote, a__2[0] = notexq;
#line 3460 ""
		    i__2[1] = 1, a__2[1] = "{";
#line 3460 ""
		    s_cat(notexq, a__2, i__2, &c__2, (ftnlen)79);
#line 3461 ""
		    ++(*lnote);
#line 3462 ""
		    if (comxtup_1.islope[commvl_1.ivx - 1] < -9) {
#line 3463 ""
			i__4 = *lnote;
#line 3463 ""
			ici__1.icierr = 0;
#line 3463 ""
			ici__1.icirnum = 1;
#line 3463 ""
			ici__1.icirlen = *lnote + 3 - i__4;
#line 3463 ""
			ici__1.iciunit = notexq + i__4;
#line 3463 ""
			ici__1.icifmt = "(i3)";
#line 3463 ""
			s_wsfi(&ici__1);
#line 3463 ""
			do_fio(&c__1, (char *)&comxtup_1.islope[commvl_1.ivx 
				- 1], (ftnlen)sizeof(integer));
#line 3463 ""
			e_wsfi();
#line 3464 ""
			*lnote += 3;
#line 3465 ""
		    } else {
#line 3466 ""
			i__4 = *lnote;
#line 3466 ""
			ici__1.icierr = 0;
#line 3466 ""
			ici__1.icirnum = 1;
#line 3466 ""
			ici__1.icirlen = *lnote + 2 - i__4;
#line 3466 ""
			ici__1.iciunit = notexq + i__4;
#line 3466 ""
			ici__1.icifmt = "(i2)";
#line 3466 ""
			s_wsfi(&ici__1);
#line 3466 ""
			do_fio(&c__1, (char *)&comxtup_1.islope[commvl_1.ivx 
				- 1], (ftnlen)sizeof(integer));
#line 3466 ""
			e_wsfi();
#line 3467 ""
			*lnote += 2;
#line 3468 ""
		    }
/* Writing concatenation */
#line 3469 ""
		    i__2[0] = *lnote, a__2[0] = notexq;
#line 3469 ""
		    i__2[1] = 1, a__2[1] = "}";
#line 3469 ""
		    s_cat(notexq, a__2, i__2, &c__2, (ftnlen)79);
#line 3470 ""
		    ++(*lnote);
#line 3471 ""
		} else {
#line 3472 ""
		    i__4 = *lnote;
#line 3472 ""
		    ici__1.icierr = 0;
#line 3472 ""
		    ici__1.icirnum = 1;
#line 3472 ""
		    ici__1.icirlen = *lnote + 1 - i__4;
#line 3472 ""
		    ici__1.iciunit = notexq + i__4;
#line 3472 ""
		    ici__1.icifmt = "(i1)";
#line 3472 ""
		    s_wsfi(&ici__1);
#line 3472 ""
		    do_fio(&c__1, (char *)&comxtup_1.islope[commvl_1.ivx - 1],
			     (ftnlen)sizeof(integer));
#line 3472 ""
		    e_wsfi();
#line 3473 ""
		    ++(*lnote);
#line 3474 ""
		}

/*  Done with bracket */

#line 3478 ""
	    }
#line 3479 ""
	    if (strtmid_1.ixrest[commvl_1.ivx - 1] == 1) {

/*  Put in the rest.  Possible problem: Rest is a spacing char, but between */
/*  beamstrt and beamn1 some non-spacing chars. are inserted. */

/*  130126 Deal with vertical shifts of rest starting xtuplet */

#line 3486 ""
		lrest = 3;
#line 3487 ""
		if (bit_test(all_1.islur[commvl_1.ivx + ip * 24 - 25],29)) {
/* Writing concatenation */
#line 3488 ""
		    i__2[0] = 1, a__2[0] = all_1.sq;
#line 3488 ""
		    i__2[1] = 2, a__2[1] = "sk";
#line 3488 ""
		    s_cat(restq, a__2, i__2, &c__2, (ftnlen)40);
/*            if (multb .eq. 0) then */
#line 3490 ""
		} else if (multb == 0) {
/* Writing concatenation */
#line 3491 ""
		    i__2[0] = 1, a__2[0] = all_1.sq;
#line 3491 ""
		    i__2[1] = 2, a__2[1] = "qp";
#line 3491 ""
		    s_cat(restq, a__2, i__2, &c__2, (ftnlen)40);
#line 3492 ""
		} else if (! comdraw_1.drawbm[commvl_1.ivx - 1] && multb == 1)
			 {
/* Writing concatenation */
#line 3493 ""
		    i__2[0] = 1, a__2[0] = all_1.sq;
#line 3493 ""
		    i__2[1] = 2, a__2[1] = "ds";
#line 3493 ""
		    s_cat(restq, a__2, i__2, &c__2, (ftnlen)40);
#line 3494 ""
		} else if (! comdraw_1.drawbm[commvl_1.ivx - 1] && multb == 2)
			 {
/* Writing concatenation */
#line 3495 ""
		    i__2[0] = 1, a__2[0] = all_1.sq;
#line 3495 ""
		    i__2[1] = 2, a__2[1] = "qs";
#line 3495 ""
		    s_cat(restq, a__2, i__2, &c__2, (ftnlen)40);
#line 3496 ""
		} else if (! comdraw_1.drawbm[commvl_1.ivx - 1] && multb == 3)
			 {
/* Writing concatenation */
#line 3497 ""
		    i__2[0] = 1, a__2[0] = all_1.sq;
#line 3497 ""
		    i__2[1] = 2, a__2[1] = "hs";
#line 3497 ""
		    s_cat(restq, a__2, i__2, &c__2, (ftnlen)40);
#line 3498 ""
		} else {
/* Writing concatenation */
#line 3499 ""
		    i__2[0] = 1, a__2[0] = all_1.sq;
#line 3499 ""
		    i__2[1] = 6, a__2[1] = "hpause";
#line 3499 ""
		    s_cat(restq, a__2, i__2, &c__2, (ftnlen)40);
#line 3500 ""
		    lrest = 7;
#line 3501 ""
		}
#line 3502 ""
		if (bit_test(all_1.nacc[commvl_1.ivx + ipb1 * 24 - 25],18) && 
			bit_test(all_1.nacc[commvl_1.ivx + ipb1 * 24 - 25],19)
			) {

/*  VERY special case of rest at start of F-tuplet, needs dot */

/* Writing concatenation */
#line 3507 ""
		    i__3[0] = 1, a__3[0] = all_1.sq;
#line 3507 ""
		    i__3[1] = 3, a__3[1] = "pt4";
#line 3507 ""
		    i__3[2] = lrest, a__3[2] = restq;
#line 3507 ""
		    s_cat(restq, a__3, i__3, &c__3, (ftnlen)40);
#line 3508 ""
		    lrest += 4;
#line 3509 ""
		}
#line 3511 ""
		nole = (all_1.nolev[commvl_1.ivx + ip * 24 - 25] + 20) % 100 
			- 20;
/*            if (nole .eq. 0) then */
#line 3513 ""
		if (nole == 0 || bit_test(all_1.islur[commvl_1.ivx + ip * 24 
			- 25],29)) {

/* Rest blank or is not raised */

/* Writing concatenation */
#line 3517 ""
		    i__2[0] = *lnote, a__2[0] = notexq;
#line 3517 ""
		    i__2[1] = 40, a__2[1] = restq;
#line 3517 ""
		    s_cat(notexq, a__2, i__2, &c__2, (ftnlen)79);
#line 3518 ""
		    *lnote += lrest;
#line 3519 ""
		} else {
#line 3520 ""
		    if (abs(nole) < 10) {
#line 3521 ""
			i__4 = abs(nole) + 48;
#line 3521 ""
			chax_(ch__1, (ftnlen)1, &i__4);
#line 3521 ""
			s_copy(tempq, ch__1, (ftnlen)79, (ftnlen)1);
#line 3522 ""
			ltemp = 1;
#line 3523 ""
		    } else {
#line 3524 ""
			s_wsfi(&io___243);
#line 3524 ""
			i__4 = abs(nole);
#line 3524 ""
			do_fio(&c__1, (char *)&i__4, (ftnlen)sizeof(integer));
#line 3524 ""
			e_wsfi();
#line 3525 ""
			ltemp = 2;
#line 3526 ""
		    }
#line 3527 ""
		    if (nole > 0) {
/* Writing concatenation */
#line 3528 ""
			i__7[0] = 1, a__4[0] = all_1.sq;
#line 3528 ""
			i__7[1] = 5, a__4[1] = "raise";
#line 3528 ""
			i__7[2] = ltemp, a__4[2] = tempq;
#line 3528 ""
			i__7[3] = 1, a__4[3] = all_1.sq;
#line 3528 ""
			i__7[4] = 9, a__4[4] = "internote";
#line 3528 ""
			s_cat(tempq, a__4, i__7, &c__5, (ftnlen)79);
#line 3529 ""
		    } else {
/* Writing concatenation */
#line 3530 ""
			i__7[0] = 1, a__4[0] = all_1.sq;
#line 3530 ""
			i__7[1] = 5, a__4[1] = "lower";
#line 3530 ""
			i__7[2] = ltemp, a__4[2] = tempq;
#line 3530 ""
			i__7[3] = 1, a__4[3] = all_1.sq;
#line 3530 ""
			i__7[4] = 9, a__4[4] = "internote";
#line 3530 ""
			s_cat(tempq, a__4, i__7, &c__5, (ftnlen)79);
#line 3531 ""
		    }
#line 3532 ""
		    ltemp += 16;
/* Writing concatenation */
#line 3533 ""
		    i__3[0] = *lnote, a__3[0] = notexq;
#line 3533 ""
		    i__3[1] = ltemp, a__3[1] = tempq;
#line 3533 ""
		    i__3[2] = lrest, a__3[2] = restq;
#line 3533 ""
		    s_cat(notexq, a__3, i__3, &c__3, (ftnlen)79);
#line 3534 ""
		    *lnote = *lnote + ltemp + lrest;
#line 3535 ""
		}

/*  No need to come back through this subroutine (as would if rest starts bar */
/*  & multb>0), so do not advance ibm1. But must check in beamn1 and do nothing. */

#line 3540 ""
		strtmid_1.ixrest[commvl_1.ivx - 1] = 0;
#line 3541 ""
	    }
#line 3542 ""
	    return 0;
#line 3543 ""
	}

/*  End if block for non-beamed xtup start...note we returned */

#line 3547 ""
	if (strtmid_1.ixrest[commvl_1.ivx - 1] == 1) {

/*  Insert rest at start of beamed xtup.  See above note for possible problem. */
/*  But first check if blank rest and if in forced beam (assuming xtuplet), */
/*    and if so, count rest from beginning, add \sk's AFTER starting beam '\ib*' */

#line 3553 ""
	    if (bit_test(all_1.islur[commvl_1.ivx + ip * 24 - 25],29) && 
		    bit_test(all_1.ipl[commvl_1.ivx + ip * 24 - 25],30)) {
#line 3554 ""
		++xjbeambrests_1.nbrests;
#line 3555 ""
		writebrests = FALSE_;
#line 3556 ""
	    } else {
#line 3557 ""
		i__4 = 4 - multb;
#line 3557 ""
		all_1.nodur[commvl_1.ivx + ipb1 * 24 - 25] = pow_ii(&c__2, &
			i__4);
#line 3558 ""
		notex_(tempq, &ltemp, (ftnlen)79);
#line 3559 ""
		if (*lnote > 0) {
/* Writing concatenation */
#line 3560 ""
		    i__2[0] = *lnote, a__2[0] = notexq;
#line 3560 ""
		    i__2[1] = ltemp, a__2[1] = tempq;
#line 3560 ""
		    s_cat(notexq, a__2, i__2, &c__2, (ftnlen)79);
#line 3561 ""
		} else {
#line 3562 ""
		    s_copy(notexq, tempq, (ftnlen)79, ltemp);
#line 3563 ""
		}
#line 3564 ""
		*lnote += ltemp;
#line 3565 ""
	    }

/*  Re-zero just in case! */

#line 3569 ""
	    all_1.nodur[commvl_1.ivx + ipb1 * 24 - 25] = 0;
#line 3570 ""
	    ++all_1.ibm1[commvl_1.ivx + ibc * 24 - 25];

/*  See if next note is a non-rest */

#line 3574 ""
	    if (! bit_test(all_1.irest[commvl_1.ivx + (ipb1 + 1) * 24 - 25],0)
		    ) {
#line 3575 ""
		strtmid_1.ixrest[commvl_1.ivx - 1] = 2;
#line 3576 ""
	    } else {

/*  Suppress reprinting xtup number next time through beamstrt */

#line 3580 ""
		all_1.islur[commvl_1.ivx + (ipb1 + 1) * 24 - 25] = bit_set(
			all_1.islur[commvl_1.ivx + (ipb1 + 1) * 24 - 25],31);

/*  Set new xtup start flag */

#line 3584 ""
		all_1.irest[commvl_1.ivx + (ipb1 + 1) * 24 - 25] = bit_set(
			all_1.irest[commvl_1.ivx + (ipb1 + 1) * 24 - 25],28);
#line 3585 ""
	    }
#line 3586 ""
	    return 0;
#line 3587 ""
	}
#line 3588 ""
    }

/*  Just ended if block for xtups */

#line 3592 ""
    if (comxtup_1.vxtup[commvl_1.ivx - 1] && ipb1 == all_1.ibm2[commvl_1.ivx 
	    + ibc * 24 - 25]) {

/*  Move actual note writing to beamend */

#line 3596 ""
	strtmid_1.ixrest[commvl_1.ivx - 1] = 4;
#line 3597 ""
	return 0;
#line 3598 ""
    }
#line 3599 ""
    if (comxtup_1.issb[commvl_1.ivx - 1] == 0) {

/*  1st bmstrt in single-slope bm grp, Adjust start level(s) and slope if needed */

#line 3603 ""
	iadj = igetbits_(&all_1.ipl[commvl_1.ivx + ipb1 * 24 - 25], &c__6, &
		c__11) - 30;
#line 3604 ""
	if (iadj != -30) {
#line 3605 ""
	    comxtup_1.nolev1[commvl_1.ivx - 1] += iadj;
#line 3606 ""
	    i__4 = comxtup_1.nssb[commvl_1.ivx - 1];
#line 3606 ""
	    for (isssb = 1; isssb <= i__4; ++isssb) {
#line 3607 ""
		comxtup_1.lev1ssb[commvl_1.ivx + isssb * 24 - 25] += iadj;
#line 3608 ""
/* L2: */
#line 3608 ""
	    }
#line 3609 ""
	}
#line 3610 ""
	iadj = igetbits_(&all_1.ipl[commvl_1.ivx + ipb1 * 24 - 25], &c__6, &
		c__17) - 30;
#line 3611 ""
	if (iadj != -30) {
#line 3612 ""
	    comxtup_1.islope[commvl_1.ivx - 1] += iadj;
/*          if (abs(islope(ivx)) .gt. 9) islope(ivx) = sign(9,islope(ivx)) */
#line 3614 ""
	    if ((i__4 = comxtup_1.islope[commvl_1.ivx - 1], abs(i__4)) > 9 && 
		    ! comslope_1.bigslope) {
#line 3614 ""
		comxtup_1.islope[commvl_1.ivx - 1] = i_sign(&c__9, &
			comxtup_1.islope[commvl_1.ivx - 1]);
#line 3614 ""
	    }
#line 3616 ""
	    if (comxtup_1.nssb[commvl_1.ivx - 1] > 0) {

/*  Cycle thru non-rest notes in SSBG, looking for bmstrts. */

#line 3620 ""
		isssb = 0;
#line 3621 ""
		i__4 = comipb_1.nnb;
#line 3621 ""
		for (inb = 2; inb <= i__4; ++inb) {
#line 3622 ""
		    if (bit_test(all_1.nacc[commvl_1.ivx + comipb_1.ipb[inb - 
			    1] * 24 - 25],21)) {

/*  Beam segment start.  New start level */
#line 3625 ""
			++isssb;
#line 3626 ""
			comxtup_1.lev1ssb[commvl_1.ivx + isssb * 24 - 25] += 
				comxtup_1.islope[commvl_1.ivx - 1] * 
				comxtup_1.xelsk[inb - 1] / all_1.slfac;
#line 3628 ""
		    }
#line 3629 ""
/* L4: */
#line 3629 ""
		}
#line 3630 ""
	    }
#line 3631 ""
	}
#line 3632 ""
    }
#line 3633 ""
    iadj = igetbits_(&all_1.islur[commvl_1.ivx + ipb1 * 24 - 25], &c__2, &
	    c__27);
#line 3634 ""
    addbrack = FALSE_;
#line 3635 ""
    if (bit_test(all_1.ipl[commvl_1.ivx + ipb1 * 24 - 25],30)) {

/*  Check for altered starting polarity.  Only in forced beams. Nominal start */
/*  level is nolev1. So beam level is nolev1 +/- 6, to be compared w/ nolev(.,.). */

#line 3640 ""
	if (*(unsigned char *)&all_1.ulq[commvl_1.ivx + ibc * 24 - 25] == 'u' 
		&& comxtup_1.nolev1[commvl_1.ivx - 1] + 6 < all_1.nolev[
		commvl_1.ivx + ipb1 * 24 - 25]) {
#line 3642 ""
	    if (*lnote == 0) {
/* Writing concatenation */
#line 3643 ""
		i__2[0] = 1, a__2[0] = all_1.sq;
#line 3643 ""
		i__2[1] = 5, a__2[1] = "loff{";
#line 3643 ""
		s_cat(notexq, a__2, i__2, &c__2, (ftnlen)79);
#line 3644 ""
	    } else {
/* Writing concatenation */
#line 3645 ""
		i__3[0] = *lnote, a__3[0] = notexq;
#line 3645 ""
		i__3[1] = 1, a__3[1] = all_1.sq;
#line 3645 ""
		i__3[2] = 5, a__3[2] = "loff{";
#line 3645 ""
		s_cat(notexq, a__3, i__3, &c__3, (ftnlen)79);
#line 3646 ""
	    }
#line 3647 ""
	    *lnote += 6;
#line 3648 ""
	    addbrack = TRUE_;
#line 3649 ""
	} else if (*(unsigned char *)&all_1.ulq[commvl_1.ivx + ibc * 24 - 25] 
		== 'l' && comxtup_1.nolev1[commvl_1.ivx - 1] - 6 > 
		all_1.nolev[commvl_1.ivx + ipb1 * 24 - 25]) {
#line 3651 ""
	    if (*lnote == 0) {
/* Writing concatenation */
#line 3652 ""
		i__2[0] = 1, a__2[0] = all_1.sq;
#line 3652 ""
		i__2[1] = 5, a__2[1] = "roff{";
#line 3652 ""
		s_cat(notexq, a__2, i__2, &c__2, (ftnlen)79);
#line 3653 ""
	    } else {
/* Writing concatenation */
#line 3654 ""
		i__3[0] = *lnote, a__3[0] = notexq;
#line 3654 ""
		i__3[1] = 1, a__3[1] = all_1.sq;
#line 3654 ""
		i__3[2] = 5, a__3[2] = "roff{";
#line 3654 ""
		s_cat(notexq, a__3, i__3, &c__3, (ftnlen)79);
#line 3655 ""
	    }
#line 3656 ""
	    *lnote += 6;
#line 3657 ""
	    addbrack = TRUE_;
#line 3658 ""
	}

/*  Check end level for possible flipping in forced beam.  Have to do it */
/*  here since with multiple voices, xelsk will not be preserved. */

#line 3663 ""
	if (*(unsigned char *)&all_1.ulq[commvl_1.ivx + all_1.ibmcnt[
		commvl_1.ivx - 1] * 24 - 25] == 'u') {
#line 3664 ""
	    bmlev = comxtup_1.nolev1[commvl_1.ivx - 1] + 6 + comxtup_1.islope[
		    commvl_1.ivx - 1] * comxtup_1.xelsk[comipb_1.nnb - 1] / 
		    all_1.slfac;
#line 3665 ""
	    strtmid_1.flipend[commvl_1.ivx - 1] = bmlev < (real) all_1.nolev[
		    commvl_1.ivx + all_1.ibm2[commvl_1.ivx + ibc * 24 - 25] * 
		    24 - 25];
#line 3666 ""
	} else if (*(unsigned char *)&all_1.ulq[commvl_1.ivx + all_1.ibmcnt[
		commvl_1.ivx - 1] * 24 - 25] == 'l') {
#line 3667 ""
	    bmlev = comxtup_1.nolev1[commvl_1.ivx - 1] - 6 + comxtup_1.islope[
		    commvl_1.ivx - 1] * comxtup_1.xelsk[comipb_1.nnb - 1] / 
		    all_1.slfac;
#line 3668 ""
	    strtmid_1.flipend[commvl_1.ivx - 1] = bmlev > (real) all_1.nolev[
		    commvl_1.ivx + all_1.ibm2[commvl_1.ivx + ibc * 24 - 25] * 
		    24 - 25];
#line 3669 ""
	}
#line 3670 ""
    }
#line 3671 ""
    multbb = multb + iadj;

/* Tremolo starting? */

#line 3675 ""
    if (bit_test(all_1.irest[commvl_1.ivx + ipb1 * 24 - 25],2)) {
#line 3675 ""
	multbb = igetbits_(&all_1.irest[commvl_1.ivx + ipb1 * 24 - 25], &c__2,
		 &c__3);
#line 3675 ""
    }
#line 3677 ""
    ntrbbb_(&multbb, "i", all_1.ulq + (commvl_1.ivx + ibc * 24 - 25), &
	    commvl_1.ivx, notexq, lnote, (ftnlen)1, (ftnlen)1, (ftnlen)79);

/*   Put in name of start level and slope, after correcting nolev1 if xtup */
/*   started with a rest. */

#line 3682 ""
    if (strtmid_1.ixrest[commvl_1.ivx - 1] == 2) {
#line 3682 ""
	r__1 = comxtup_1.nolev1[commvl_1.ivx - 1] + comxtup_1.xelsk[0] * 
		comxtup_1.islope[commvl_1.ivx - 1] / all_1.slfac;
#line 3682 ""
	comxtup_1.nolev1[commvl_1.ivx - 1] = i_nint(&r__1);
#line 3682 ""
    }

/*  Add adjustment nvtrem to main beam to account for tremolo indented beams */

#line 3687 ""
    i__4 = comxtup_1.nolev1[commvl_1.ivx - 1] + nvtrem;
#line 3687 ""
    i__5 = ncmid_(&all_1.iv, &ipb1);
#line 3687 ""
    notefq_(noteq, &lnoten, &i__4, &i__5, (ftnlen)8);
#line 3688 ""
    if (comxtup_1.islope[commvl_1.ivx - 1] < -9) {
/* Writing concatenation */
#line 3689 ""
	i__3[0] = *lnote, a__3[0] = notexq;
#line 3689 ""
	i__3[1] = lnoten, a__3[1] = noteq;
#line 3689 ""
	i__3[2] = 1, a__3[2] = "{";
#line 3689 ""
	s_cat(notexq, a__3, i__3, &c__3, (ftnlen)79);
#line 3690 ""
	*lnote = *lnote + 5 + lnoten;
#line 3691 ""
	i__4 = *lnote - 4;
#line 3691 ""
	ici__1.icierr = 0;
#line 3691 ""
	ici__1.icirnum = 1;
#line 3691 ""
	ici__1.icirlen = *lnote - i__4;
#line 3691 ""
	ici__1.iciunit = notexq + i__4;
#line 3691 ""
	ici__1.icifmt = "(i3,a1)";
#line 3691 ""
	s_wsfi(&ici__1);
#line 3691 ""
	do_fio(&c__1, (char *)&comxtup_1.islope[commvl_1.ivx - 1], (ftnlen)
		sizeof(integer));
#line 3691 ""
	do_fio(&c__1, "}", (ftnlen)1);
#line 3691 ""
	e_wsfi();
#line 3692 ""
    } else if (comxtup_1.islope[commvl_1.ivx - 1] < 0) {
/* Writing concatenation */
#line 3693 ""
	i__3[0] = *lnote, a__3[0] = notexq;
#line 3693 ""
	i__3[1] = lnoten, a__3[1] = noteq;
#line 3693 ""
	i__3[2] = 1, a__3[2] = "{";
#line 3693 ""
	s_cat(notexq, a__3, i__3, &c__3, (ftnlen)79);
#line 3694 ""
	*lnote = *lnote + 4 + lnoten;
#line 3695 ""
	i__4 = *lnote - 3;
#line 3695 ""
	ici__1.icierr = 0;
#line 3695 ""
	ici__1.icirnum = 1;
#line 3695 ""
	ici__1.icirlen = *lnote - i__4;
#line 3695 ""
	ici__1.iciunit = notexq + i__4;
#line 3695 ""
	ici__1.icifmt = "(i2,a1)";
#line 3695 ""
	s_wsfi(&ici__1);
#line 3695 ""
	do_fio(&c__1, (char *)&comxtup_1.islope[commvl_1.ivx - 1], (ftnlen)
		sizeof(integer));
#line 3695 ""
	do_fio(&c__1, "}", (ftnlen)1);
#line 3695 ""
	e_wsfi();
#line 3696 ""
    } else if (comxtup_1.islope[commvl_1.ivx - 1] <= 9) {
/* Writing concatenation */
#line 3697 ""
	i__2[0] = *lnote, a__2[0] = notexq;
#line 3697 ""
	i__2[1] = lnoten, a__2[1] = noteq;
#line 3697 ""
	s_cat(notexq, a__2, i__2, &c__2, (ftnlen)79);
#line 3698 ""
	*lnote = *lnote + 1 + lnoten;
#line 3699 ""
	ici__1.icierr = 0;
#line 3699 ""
	ici__1.icirnum = 1;
#line 3699 ""
	ici__1.icirlen = 1;
#line 3699 ""
	ici__1.iciunit = notexq + (*lnote - 1);
#line 3699 ""
	ici__1.icifmt = "(i1)";
#line 3699 ""
	s_wsfi(&ici__1);
#line 3699 ""
	do_fio(&c__1, (char *)&comxtup_1.islope[commvl_1.ivx - 1], (ftnlen)
		sizeof(integer));
#line 3699 ""
	e_wsfi();
#line 3700 ""
    } else {
/* Writing concatenation */
#line 3701 ""
	i__3[0] = *lnote, a__3[0] = notexq;
#line 3701 ""
	i__3[1] = lnoten, a__3[1] = noteq;
#line 3701 ""
	i__3[2] = 1, a__3[2] = "{";
#line 3701 ""
	s_cat(notexq, a__3, i__3, &c__3, (ftnlen)79);
#line 3702 ""
	*lnote = *lnote + 4 + lnoten;
#line 3703 ""
	i__4 = *lnote - 3;
#line 3703 ""
	ici__1.icierr = 0;
#line 3703 ""
	ici__1.icirnum = 1;
#line 3703 ""
	ici__1.icirlen = *lnote - i__4;
#line 3703 ""
	ici__1.iciunit = notexq + i__4;
#line 3703 ""
	ici__1.icifmt = "(i2,a1)";
#line 3703 ""
	s_wsfi(&ici__1);
#line 3703 ""
	do_fio(&c__1, (char *)&comxtup_1.islope[commvl_1.ivx - 1], (ftnlen)
		sizeof(integer));
#line 3703 ""
	do_fio(&c__1, "}", (ftnlen)1);
#line 3703 ""
	e_wsfi();
#line 3704 ""
    }

/*  Check for beam-thk fine-tuning */

#line 3708 ""
    if (iadj > 0) {
#line 3709 ""
	i__4 = multb + 1;
#line 3709 ""
	for (imp = multb + iadj; imp >= i__4; --imp) {
#line 3710 ""
	    ntrbbb_(&imp, "t", all_1.ulq + (commvl_1.ivx + ibc * 24 - 25), &
		    commvl_1.ivx, notexq, lnote, (ftnlen)1, (ftnlen)1, (
		    ftnlen)79);
#line 3711 ""
/* L1: */
#line 3711 ""
	}
#line 3712 ""
    }

/*  If we shifted, must close with right bracket */

#line 3716 ""
    if (addbrack) {
/* Writing concatenation */
#line 3717 ""
	i__2[0] = *lnote, a__2[0] = notexq;
#line 3717 ""
	i__2[1] = 1, a__2[1] = "}";
#line 3717 ""
	s_cat(notexq, a__2, i__2, &c__2, (ftnlen)79);
#line 3718 ""
	++(*lnote);
#line 3719 ""
    }

/*  Add in \sk's for very special case of staff-crossing xtup chords */
/*  Assumes we are in lower (first) voice of up-to-both beamed xtup */
/*    that starts with blank rests (notes in upper voice here). */

#line 3725 ""
    if (xjbeambrests_1.nbrests > 0 && writebrests) {
#line 3726 ""
	i__4 = xjbeambrests_1.nbrests;
#line 3726 ""
	for (isk = 1; isk <= i__4; ++isk) {
/* Writing concatenation */
#line 3727 ""
	    i__3[0] = *lnote, a__3[0] = notexq;
#line 3727 ""
	    chax_(ch__1, (ftnlen)1, &c__92);
#line 3727 ""
	    i__3[1] = 1, a__3[1] = ch__1;
#line 3727 ""
	    i__3[2] = 2, a__3[2] = "sk";
#line 3727 ""
	    s_cat(notexq, a__3, i__3, &c__3, (ftnlen)79);
#line 3728 ""
	    *lnote += 3;
#line 3729 ""
/* L7: */
#line 3729 ""
	}
#line 3730 ""
	xjbeambrests_1.nbrests = 0;
#line 3731 ""
    }

/*  Get 'floor' zmin for figures */
/*  Note: Will not come thru here on 1st note of unbeamed xtup, so figure height */
/*    won't be adjusted. If anyone ever needs that, need to duplicate this */
/*    functionality up above, before exiting. */

#line 3738 ""
    if (all_1.figbass && (commvl_1.ivx == 1 || commvl_1.ivx == 
	    comfig_1.ivxfig2)) {
#line 3739 ""
	if (commvl_1.ivx == 1) {
#line 3740 ""
	    ivf = 1;
#line 3741 ""
	} else {
#line 3742 ""
	    ivf = comfig_1.ivxfig2;
#line 3743 ""
	}
#line 3744 ""
	zmult = (multb - 1) * 1.2f;
#line 3745 ""
	ymin = 100.f;
#line 3746 ""
	i__4 = comipb_1.nnb;
#line 3746 ""
	for (inb = 1; inb <= i__4; ++inb) {
#line 3747 ""
	    if (all_1.isfig[ivf + (comipb_1.ipb[inb - 1] << 1) - 3]) {
#line 3748 ""
		if (*(unsigned char *)&all_1.ulq[all_1.iv + ibc * 24 - 25] == 
			'u') {
#line 3749 ""
		    ybot = (real) all_1.nolev[all_1.iv + comipb_1.ipb[inb - 1]
			     * 24 - 25];
#line 3750 ""
		} else {
#line 3751 ""
		    ybot = comxtup_1.islope[commvl_1.ivx - 1] / all_1.slfac * 
			    comxtup_1.xelsk[inb - 1] + comxtup_1.nolev1[
			    commvl_1.ivx - 1] - all_1.stemlen - zmult;
#line 3753 ""
		}
#line 3754 ""
		ymin = dmin(ymin,ybot);
#line 3755 ""
	    }
#line 3756 ""
/* L3: */
#line 3756 ""
	}
#line 3757 ""
	maxdrop = ncmid_(&all_1.iv, &ipb1) - 4 - ymin + 5.01f;
/* Computing MAX */
#line 3758 ""
	i__4 = all_1.ifigdr[ivf + (all_1.iline << 1) - 3];
#line 3758 ""
	all_1.ifigdr[ivf + (all_1.iline << 1) - 3] = max(i__4,maxdrop);
#line 3759 ""
    }

/*  Compute ornament levels if needed */

#line 3763 ""
    nomornlev = ncmid_(&all_1.iv, &ipb1) + 5;
#line 3764 ""
    iorn = 0;
#line 3765 ""
    i__4 = comipb_1.nnb;
#line 3765 ""
    for (inb = 1; inb <= i__4; ++inb) {
#line 3766 ""
	ip = comipb_1.ipb[inb - 1];
#line 3767 ""
	if (! bit_test(all_1.iornq[commvl_1.ivx + ip * 24 - 1],23)) {
#line 3767 ""
	    goto L8;
#line 3767 ""
	}
#line 3768 ""
	if (bit_test(all_1.irest[commvl_1.ivx + ip * 24 - 25],26) && *(
		unsigned char *)&all_1.ulq[commvl_1.ivx + ibc * 24 - 25] == 
		'l') {

/*  letter-dynamic or hairpin ending under down-beamed */

#line 3772 ""
	    ++iorn;
#line 3773 ""
	    ybeam = comxtup_1.nolev1[commvl_1.ivx - 1] - all_1.stemlen + 
		    comxtup_1.islope[commvl_1.ivx - 1] * comxtup_1.xelsk[inb 
		    - 1] / all_1.slfac + 1 - (multb - 1) * 1.2f;
/* Computing MIN */
#line 3775 ""
	    r__1 = ybeam - 3.f;
#line 3775 ""
	    i__5 = i_nint(&r__1), i__6 = nomornlev - 10;
#line 3775 ""
	    ihornb[commvl_1.ivx + iorn * 24] = min(i__5,i__6);
#line 3776 ""
	} else if (! bit_test(all_1.ipl[commvl_1.ivx + ip * 24 - 25],10)) {

/*  Bits 0-13: (stmgx+Tupf._) , 14: Down fermata, was F */
/*  15: Trill w/o "tr", was U , 16-18 Editorial s,f,n , 19-21 TBD */

/*  Non-chord.  There IS an ornament.  Need ihornb only if upbeam, and if */
/*  ornament is 1,2,3,5,6,7,8,9,10,15-21 (up- but not domn ferm.) */

#line 3784 ""
	    if (*(unsigned char *)&all_1.ulq[commvl_1.ivx + ibc * 24 - 25] == 
		    'u' && (all_1.iornq[commvl_1.ivx + comipb_1.ipb[inb - 1] *
		     24 - 1] & 4163566) > 0) {
#line 3786 ""
		++iorn;
#line 3787 ""
		all_1.iornq[commvl_1.ivx + ip * 24 - 1] = bit_set(all_1.iornq[
			commvl_1.ivx + ip * 24 - 1],22);
#line 3788 ""
		ybeam = comxtup_1.nolev1[commvl_1.ivx - 1] + all_1.stemlen + 
			comxtup_1.islope[commvl_1.ivx - 1] * comxtup_1.xelsk[
			inb - 1] / all_1.slfac - 1 + (multb - 1) * 1.2f;
/* Computing MAX */
#line 3790 ""
		r__1 = ybeam + 3.f;
#line 3790 ""
		i__5 = i_nint(&r__1);
#line 3790 ""
		ihornb[commvl_1.ivx + iorn * 24] = max(i__5,nomornlev);
#line 3791 ""
	    }
#line 3792 ""
	} else {

/* In a chord.  Orn may be on main note or non-main or both.  Set ihornb if */
/* upbeam and highest note has orn, or down beam and lowest.  Find 1st chord note */

#line 3797 ""
	    i__5 = comtrill_1.ncrd;
#line 3797 ""
	    for (comtrill_1.icrd1 = 1; comtrill_1.icrd1 <= i__5; 
		    ++comtrill_1.icrd1) {
#line 3798 ""
		if ((255 & comtrill_1.icrdat[comtrill_1.icrd1 - 1]) == ip && (
			15 & lbit_shift(comtrill_1.icrdat[comtrill_1.icrd1 - 
			1], (ftnlen)-8)) == commvl_1.ivx) {
#line 3798 ""
		    goto L11;
#line 3798 ""
		}
#line 3800 ""
/* L10: */
#line 3800 ""
	    }
#line 3801 ""
L11:

/* Find outermost note, min or max depending on beam direction ulq.  xto is true */
/* if there's an ornament on that note.  Expand orn list to include ._, since if */
/* on extreme chord note in beam, will move. */
/* So ornaments are all except 0,4,13 (,g,) */

#line 3808 ""
	    levx = all_1.nolev[commvl_1.ivx + ip * 24 - 25];
#line 3809 ""
	    xto = (all_1.iornq[commvl_1.ivx + comipb_1.ipb[inb - 1] * 24 - 1] 
		    & 4186094) > 0;
#line 3810 ""
	    icrdx = 0;
#line 3811 ""
	    i__5 = comtrill_1.ncrd;
#line 3811 ""
	    for (icrd = comtrill_1.icrd1; icrd <= i__5; ++icrd) {
#line 3812 ""
		if ((255 & comtrill_1.icrdat[icrd - 1]) != ip || (15 & 
			lbit_shift(comtrill_1.icrdat[icrd - 1], (ftnlen)-8)) 
			!= commvl_1.ivx) {
#line 3812 ""
		    goto L13;
#line 3812 ""
		}
#line 3814 ""
		levc = 127 & lbit_shift(comtrill_1.icrdat[icrd - 1], (ftnlen)
			-12);
#line 3815 ""
		if (*(unsigned char *)&all_1.ulq[commvl_1.ivx + ibc * 24 - 25]
			 == 'u' && levc > levx || *(unsigned char *)&
			all_1.ulq[commvl_1.ivx + ibc * 24 - 25] == 'l' && 
			levc < levx) {
#line 3817 ""
		    levx = levc;
#line 3818 ""
		    icrdx = icrd;
#line 3819 ""
		    xto = (comtrill_1.icrdorn[icrd - 1] & 4186094) > 0;
#line 3820 ""
		}
#line 3821 ""
/* L12: */
#line 3821 ""
	    }
#line 3822 ""
L13:

/*  If there's orn on extreme note, do stuff */

#line 3826 ""
	    if (xto) {
#line 3827 ""
		++iorn;
#line 3828 ""
		if (*(unsigned char *)&all_1.ulq[commvl_1.ivx + ibc * 24 - 25]
			 == 'u') {
#line 3829 ""
		    ybeam = comxtup_1.nolev1[commvl_1.ivx - 1] + 
			    all_1.stemlen + comxtup_1.islope[commvl_1.ivx - 1]
			     * comxtup_1.xelsk[inb - 1] / all_1.slfac - 1 + (
			    multb - 1) * 1.2f;
/* Computing MAX */
#line 3831 ""
		    r__1 = ybeam + 3.f;
#line 3831 ""
		    i__5 = i_nint(&r__1);
#line 3831 ""
		    ihornb[commvl_1.ivx + iorn * 24] = max(i__5,nomornlev);
#line 3832 ""
		} else {
#line 3833 ""
		    ybeam = comxtup_1.nolev1[commvl_1.ivx - 1] - 
			    all_1.stemlen + comxtup_1.islope[commvl_1.ivx - 1]
			     * comxtup_1.xelsk[inb - 1] / all_1.slfac + 1 - (
			    multb - 1) * 1.2f;
/* Computing MIN */
#line 3835 ""
		    r__1 = ybeam - 3.f;
#line 3835 ""
		    i__5 = i_nint(&r__1), i__6 = nomornlev - 10;
#line 3835 ""
		    ihornb[commvl_1.ivx + iorn * 24] = min(i__5,i__6);
#line 3836 ""
		}
#line 3837 ""
		if (icrdx == 0) {

/*  Affected ornament is on main note */

#line 3841 ""
		    all_1.iornq[commvl_1.ivx + ip * 24 - 1] = bit_set(
			    all_1.iornq[commvl_1.ivx + ip * 24 - 1],22);
#line 3842 ""
		} else {
#line 3843 ""
		    comtrill_1.icrdorn[icrdx - 1] = bit_set(
			    comtrill_1.icrdorn[icrdx - 1],22);
#line 3844 ""
		}
#line 3845 ""
	    }
#line 3846 ""
	}
#line 3847 ""
L8:
#line 3847 ""
	;
#line 3847 ""
    }

/*  Henceforth nornb will be a counter. */

#line 3851 ""
    if (iorn > 0) {
#line 3851 ""
	nornb[commvl_1.ivx] = 1;
#line 3851 ""
    }
#line 3852 ""
    if (strtmid_1.ixrest[commvl_1.ivx - 1] == 2) {
#line 3852 ""
	strtmid_1.ixrest[commvl_1.ivx - 1] = 0;
#line 3852 ""
    }
#line 3853 ""
    return 0;
} /* beamstrt_ */



/*  meter space (pts) = xb4mbr = musicsize*facmtr */


/*  From other */

/*     *   2.0,1.5,1.0,0.5,1.3,1.3,0.4,0.8,1.2,0.8,1.2,1.6, */

/* Subroutine */ int catspace_(real *space, real *squez, integer *nnsk)
{
    /* System generated locals */
    integer i__1;
    real r__1;

    /* Local variables */
    static integer iptr;

#line 3935 ""
    i__1 = c1omnotes_1.nptr[c1omnotes_1.ibarcnt] - 1;
#line 3935 ""
    for (iptr = c1omnotes_1.nptr[c1omnotes_1.ibarcnt - 1]; iptr <= i__1; 
	    ++iptr) {
#line 3936 ""
	if ((r__1 = *space - c1omnotes_1.durb[iptr - 1], dabs(r__1)) < 
		comtol_1.tol) {
#line 3937 ""
	    if ((r__1 = *squez - c1omnotes_1.sqzb[iptr - 1], dabs(r__1)) < 
		    comtol_1.tol) {

/*  Increment pre-existing entry */

#line 3941 ""
		c1omnotes_1.nnpd[iptr - 1] += *nnsk;
#line 3942 ""
		return 0;
#line 3943 ""
	    }
#line 3944 ""
	}
#line 3945 ""
/* L16: */
#line 3945 ""
    }

/*  Didn't find current duration & squez, so add a new entry. */
/*  No particular reason to keep in order, so add at the end. */

#line 3950 ""
    c1omnotes_1.nnpd[c1omnotes_1.nptr[c1omnotes_1.ibarcnt] - 1] = *nnsk;
#line 3951 ""
    c1omnotes_1.durb[c1omnotes_1.nptr[c1omnotes_1.ibarcnt] - 1] = *space;
#line 3952 ""
    c1omnotes_1.sqzb[c1omnotes_1.nptr[c1omnotes_1.ibarcnt] - 1] = *squez;
#line 3953 ""
    ++c1omnotes_1.nptr[c1omnotes_1.ibarcnt];
#line 3954 ""
    return 0;
} /* catspace_ */

/* Character */ VOID chax_(char *ret_val, ftnlen ret_val_len, integer *n)
{

/* The only reason for this seemingly do-nothing function is to get around an */
/*  apparent bug in the Visual Fortran Standard Edition 5.0.A compiler! */

#line 3961 ""
    *(unsigned char *)ret_val = (char) (*n);
#line 3962 ""
    return ;
} /* chax_ */

/* Subroutine */ int checkdyn_(char *lineq, integer *iccount, integer *ibar, 
	ftnlen lineq_len)
{
    /* System generated locals */
    address a__1[3];
    integer i__1, i__2[3], i__3;
    real r__1;
    char ch__1[1], ch__2[4];
    icilist ici__1;

    /* Builtin functions */
    integer s_cmp(char *, char *, ftnlen, ftnlen), i_indx(char *, char *, 
	    ftnlen, ftnlen);
    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
    integer s_rsfi(icilist *), do_fio(integer *, char *, ftnlen), e_rsfi(void)
	    , i_nint(real *);

    /* Local variables */
    static integer ipm, iend;
    extern /* Character */ VOID chax_(char *, ftnlen, integer *);
    static integer idno;
    static real fnum;
    static char durq[1];
    extern /* Subroutine */ int stop1_(void), errmsg_(char *, integer *, 
	    integer *, char *, ftnlen, ftnlen);
    static integer istart;
    static logical txtdyn;
    extern /* Subroutine */ int readnum_(char *, integer *, char *, real *, 
	    ftnlen, ftnlen);
    static char dynsymq[4];

#line 3969 ""
    txtdyn = FALSE_;

/*  On entry, iccount is on "D" */

#line 3973 ""
    i__1 = *iccount;
#line 3973 ""
    chax_(ch__1, (ftnlen)1, &c__34);
#line 3973 ""
    if (s_cmp(lineq + i__1, ch__1, *iccount + 1 - i__1, (ftnlen)1) == 0) {

/*  Dynamic text */

#line 3978 ""
	istart = *iccount + 2;
/* 1 past 1st quote */
#line 3979 ""
L3:
#line 3980 ""
	chax_(ch__1, (ftnlen)1, &c__34);
#line 3980 ""
	iend = i_indx(lineq + (istart - 1), ch__1, 128 - (istart - 1), (
		ftnlen)1);
#line 3981 ""
	i__1 = istart + iend - 3;
#line 3981 ""
	chax_(ch__1, (ftnlen)1, &c__92);
#line 3981 ""
	if (s_cmp(lineq + i__1, ch__1, istart + iend - 2 - i__1, (ftnlen)1) ==
		 0) {
#line 3982 ""
	    istart = *iccount + iend + 2;
#line 3983 ""
	    goto L3;
#line 3984 ""
	}
#line 3985 ""
	if (iend == 0) {
#line 3986 ""
	    i__1 = *iccount + 1;
#line 3986 ""
	    errmsg_(lineq, &i__1, ibar, "Dynamic text must be terminated wit"\
		    "h double quote!", (ftnlen)128, (ftnlen)50);
#line 3988 ""
	    stop1_();
#line 3989 ""
	}

/*  Set iccount to character after 2nd ", and set ipm */

/*        iccount = iccount+iend+2 */
#line 3994 ""
	*iccount = istart + iend;
#line 3995 ""
	ipm = i_indx("- +", lineq + (*iccount - 1), (ftnlen)3, (ftnlen)1);
#line 3996 ""
	if (ipm == 0) {
#line 3997 ""
	    errmsg_(lineq, iccount, ibar, "Expected \"-\", \"+\", or blank h"\
		    "ere!", (ftnlen)128, (ftnlen)33);
#line 3999 ""
	    stop1_();
#line 4000 ""
	}
#line 4001 ""
    } else {

/*  Expect ordinary dynamic */

#line 4005 ""
	for (iend = *iccount + 2; iend <= 128; ++iend) {
#line 4006 ""
	    ipm = i_indx("- +", lineq + (iend - 1), (ftnlen)3, (ftnlen)1);
#line 4007 ""
	    if (ipm > 0) {
#line 4007 ""
		goto L2;
#line 4007 ""
	    }
#line 4008 ""
/* L1: */
#line 4008 ""
	}
#line 4009 ""
L2:
#line 4010 ""
	if (iend - *iccount > 5 || iend - *iccount < 2) {
#line 4011 ""
	    i__1 = iend - 1;
#line 4011 ""
	    errmsg_(lineq, &i__1, ibar, "Wrong length for dynamic mark!", (
		    ftnlen)128, (ftnlen)30);
#line 4013 ""
	    stop1_();
#line 4014 ""
	}
#line 4015 ""
	i__1 = *iccount;
#line 4015 ""
	ici__1.icierr = 0;
#line 4015 ""
	ici__1.iciend = 0;
#line 4015 ""
	ici__1.icirnum = 1;
#line 4015 ""
	ici__1.icirlen = iend - 1 - i__1;
#line 4015 ""
	ici__1.iciunit = lineq + i__1;
/* Writing concatenation */
#line 4015 ""
	i__2[0] = 2, a__1[0] = "(a";
#line 4015 ""
	i__3 = iend + 47 - *iccount;
#line 4015 ""
	chax_(ch__1, (ftnlen)1, &i__3);
#line 4015 ""
	i__2[1] = 1, a__1[1] = ch__1;
#line 4015 ""
	i__2[2] = 1, a__1[2] = ")";
#line 4015 ""
	ici__1.icifmt = (s_cat(ch__2, a__1, i__2, &c__3, (ftnlen)4), ch__2);
#line 4015 ""
	s_rsfi(&ici__1);
#line 4015 ""
	do_fio(&c__1, dynsymq, (ftnlen)4);
#line 4015 ""
	e_rsfi();
#line 4017 ""
	idno = (i_indx("ppppppp pp  p   mp  mf  f   fp  sfz ff  fff ffff<   "\
		">   ", dynsymq, (ftnlen)56, (ftnlen)4) + 3) / 4;
#line 4020 ""
	if (idno == 0) {
#line 4021 ""
	    i__1 = *iccount + 1;
#line 4021 ""
	    errmsg_(lineq, &i__1, ibar, "Illegal dynamic mark!", (ftnlen)128, 
		    (ftnlen)21);
#line 4022 ""
	    stop1_();
#line 4023 ""
	}
#line 4024 ""
	*iccount = iend;
#line 4025 ""
    }
#line 4026 ""
    if (ipm != 2) {

/*  There is a vertical shift, have "+" or "-" */

#line 4030 ""
	++(*iccount);
#line 4031 ""
	if (i_indx("0123456789", lineq + (*iccount - 1), (ftnlen)10, (ftnlen)
		1) == 0) {
#line 4032 ""
	    errmsg_(lineq, iccount, ibar, "Expected integer here for vertica"\
		    "l offset!", (ftnlen)128, (ftnlen)42);
#line 4034 ""
	    stop1_();
#line 4035 ""
	}
#line 4036 ""
	readnum_(lineq, iccount, durq, &fnum, (ftnlen)128, (ftnlen)1);
#line 4037 ""
	idno = i_nint(&fnum);
#line 4038 ""
	if (idno > 63) {
#line 4039 ""
	    i__1 = *iccount - 1;
#line 4039 ""
	    errmsg_(lineq, &i__1, ibar, "Vertical offset for dynamic mark mu"\
		    "st be (-63,63)!", (ftnlen)128, (ftnlen)50);
#line 4041 ""
	    stop1_();
#line 4042 ""
	}
#line 4043 ""
	ipm = i_indx("- +", durq, (ftnlen)3, (ftnlen)1);
#line 4044 ""
	if (ipm == 0) {
#line 4045 ""
	    errmsg_(lineq, iccount, ibar, "Expected \"+\", \"-\", or blank h"\
		    "ere!", (ftnlen)128, (ftnlen)33);
#line 4047 ""
	    stop1_();
#line 4048 ""
	}
#line 4049 ""
	if (ipm != 2) {

/*  There is a horizontal shift */

#line 4053 ""
	    ++(*iccount);
#line 4054 ""
	    if (i_indx(".0123456789", lineq + (*iccount - 1), (ftnlen)11, (
		    ftnlen)1) == 0) {
#line 4055 ""
		errmsg_(lineq, iccount, ibar, "Expected number here for hori"\
			"zontal offset!", (ftnlen)128, (ftnlen)43);
#line 4057 ""
		stop1_();
#line 4058 ""
	    }
#line 4059 ""
	    readnum_(lineq, iccount, durq, &fnum, (ftnlen)128, (ftnlen)1);
#line 4060 ""
	    r__1 = fnum * 10;
#line 4060 ""
	    idno = i_nint(&r__1);
#line 4061 ""
	    if (idno > 255) {
#line 4062 ""
		i__1 = *iccount - 1;
#line 4062 ""
		errmsg_(lineq, &i__1, ibar, "Horizontal offset for dynamic m"\
			"ark must be (-25.5,25.5)!", (ftnlen)128, (ftnlen)56);
#line 4064 ""
		stop1_();
#line 4065 ""
	    } else if (*(unsigned char *)durq != ' ') {
#line 4066 ""
		errmsg_(lineq, iccount, ibar, "There should be a blank here!",
			 (ftnlen)128, (ftnlen)29);
#line 4068 ""
		stop1_();
#line 4069 ""
	    }
#line 4070 ""
	}

/*  iccount should be on the blank at the end of the entire symbol */

#line 4074 ""
    }
#line 4075 ""
    return 0;
} /* checkdyn_ */

/* Subroutine */ int chkarp_(integer *ncrd, integer *icrdat, integer *ivx, 
	integer *ip, logical *iscacc, logical *isarp)
{
    /* System generated locals */
    integer i__1;

    /* Builtin functions */
    integer lbit_shift(integer, integer);

    /* Local variables */
    static integer icrd;
    static logical found1;

/*      subroutine chkarp(found1,ncrd,icrdat,icrdot,ivx,ip,isacc,isarp, */
/*     *                  icashft) */
#line 4082 ""
    /* Parameter adjustments */
#line 4082 ""
    --icrdat;
#line 4082 ""

#line 4082 ""
    /* Function Body */
#line 4082 ""
    found1 = FALSE_;

/*  icashft will be max left shift of accid's in chord notes. */
/*  Used only for spacing checks. */
/*  Will include left shift of chord note itself. */
/*  Rezero after use. */

#line 4089 ""
    i__1 = *ncrd;
#line 4089 ""
    for (icrd = 1; icrd <= i__1; ++icrd) {

/*  This if block cycles thru all chord notes on ivx,ip; then returns. */

#line 4093 ""
	if ((255 & icrdat[icrd]) == *ip && (15 & lbit_shift(icrdat[icrd], (
		ftnlen)-8)) == *ivx) {
#line 4095 ""
	    found1 = TRUE_;
#line 4096 ""
	    *iscacc = *iscacc || bit_test(icrdat[icrd],19) && ! bit_test(
		    icrdat[icrd],27);

/*  Accid on this chord note, and it's not midi-only. */

/*            irshft = igetbits(icrdot(icrd),7,20) */
/* c */
/* c  Include increment for notehead shift */
/* c */
/*            if (btest(icrdat(icrd),23)) then */
/*              if (irshft .eq. 0) then */
/*                irshft = 44 */
/*              else */
/*                irshft=irshft-20 */
/*              end if */
/*            end if */
/*            if (irshft .ne. 0) then */
/* c */
/* c  Accid on chord note is shifted.  Include only left shift, in 20ths. */
/* c */
/*              if (irshft .lt. 64) icashft = max(icashft,64-irshft) */
/*            end if */
/*          end if */
#line 4119 ""
	    *isarp = *isarp || bit_test(icrdat[icrd],25);
#line 4120 ""
	} else if (found1) {
#line 4121 ""
	    return 0;
#line 4122 ""
	}
#line 4123 ""
/* L18: */
#line 4123 ""
    }
#line 4124 ""
    return 0;
} /* chkarp_ */

/* Subroutine */ int chkimidi_(integer *icm)
{
    /* Builtin functions */
    integer s_wsle(cilist *), e_wsle(void), do_lio(integer *, integer *, char 
	    *, ftnlen), s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), 
	    e_wsfe(void);

    /* Fortran I/O blocks */
    static cilist io___275 = { 0, 6, 0, 0, 0 };
    static cilist io___276 = { 0, 6, 0, 0, 0 };
    static cilist io___277 = { 0, 6, 0, "(a6,2x,4i8)", 0 };


#line 4137 ""
    if (commidi_1.imidi[*icm] >= 24576) {
#line 4138 ""
	s_wsle(&io___275);
#line 4138 ""
	e_wsle();
#line 4139 ""
	s_wsle(&io___276);
#line 4139 ""
	do_lio(&c__9, &c__1, "Midi file is too long! It will be corrupted or"\
		" worse", (ftnlen)52);
#line 4139 ""
	e_wsle();
#line 4140 ""
	s_wsfe(&io___277);
#line 4140 ""
	do_fio(&c__1, "imidi:", (ftnlen)6);
#line 4140 ""
	do_fio(&c__1, (char *)&commidi_1.imidi[0], (ftnlen)sizeof(integer));
#line 4140 ""
	do_fio(&c__1, (char *)&commidi_1.imidi[1], (ftnlen)sizeof(integer));
#line 4140 ""
	do_fio(&c__1, (char *)&commidi_1.imidi[2], (ftnlen)sizeof(integer));
#line 4140 ""
	do_fio(&c__1, (char *)&commidi_1.imidi[3], (ftnlen)sizeof(integer));
#line 4140 ""
	e_wsfe();
#line 4142 ""
    }
#line 4143 ""
    return 0;
} /* chkimidi_ */

/* Subroutine */ int chkkbdrests_(integer *ip, integer *iv, integer *ivx, 
	integer *nn, integer *islur, integer *irest, integer *nolev, integer *
	ivmx, integer *nib, integer *nv, integer *ibar, real *tnow, real *tol,
	 integer *nodur, integer *mode, integer *levtopr, integer *levbotr, 
	integer *mult, integer *ipl)
{
    /* System generated locals */
    integer i__1;
    real r__1;

    /* Builtin functions */
    integer i_sign(integer *, integer *);

    /* Local variables */
    static integer levother, kkp;
    extern integer log2_(integer *), ncmid_(integer *, integer *);
    static integer indxr, iraise, levbot;
    static real tother;
    static integer levtop, iraise1, iraise2, ivother, levnext, iupdown;

/*     * nib,nv,ibar,tnow,tol,nodur,mode,levtopr,levbotr,mult) */

/*  On 130127 put this code, formerly in make2bar right before calling notex for */
/*  a single note/rest, into this subroutine, so the same logic could also be */
/*  with the calls to beamstrt/mid/end to adjust height of rests in xtups if the */
/*  keyboard rest option is selected */

/*  mode=1 if called as before, 2 if for an xtup. Only affects check for */
/*    quarter rests, which will fix later. */

/*  Get reference level: next following note if no intervening blank rests, */
/*    otherwise next prior note. Relative to bottom line. */

/*      if (ip.ne.nn(ivx).and..not.btest(iornq(ivx,ip),30)) then */
#line 4165 ""
    /* Parameter adjustments */
#line 4165 ""
    ipl -= 25;
#line 4165 ""
    mult -= 25;
#line 4165 ""
    --levbotr;
#line 4165 ""
    --levtopr;
#line 4165 ""
    nodur -= 25;
#line 4165 ""
    nib -= 25;
#line 4165 ""
    ivmx -= 25;
#line 4165 ""
    nolev -= 25;
#line 4165 ""
    irest -= 25;
#line 4165 ""
    islur -= 25;
#line 4165 ""
    --nn;
#line 4165 ""

#line 4165 ""
    /* Function Body */
#line 4165 ""
    if (*ip != nn[*ivx] && ! bit_test(ipl[*ivx + *ip * 24],1)) {

/*  Not the last note and not "look-left" for level */

#line 4169 ""
	i__1 = nn[*ivx];
#line 4169 ""
	for (kkp = *ip + 1; kkp <= i__1; ++kkp) {
#line 4170 ""
	    if (bit_test(islur[*ivx + kkp * 24],29)) {
#line 4170 ""
		goto L4;
#line 4170 ""
	    }
#line 4171 ""
	    if (! bit_test(irest[*ivx + kkp * 24],0)) {
#line 4172 ""
		levnext = nolev[*ivx + kkp * 24] - ncmid_(iv, &kkp) + 4;
/* Relative to botto */
#line 4173 ""
		goto L9;
#line 4174 ""
	    }
#line 4175 ""
/* L8: */
#line 4175 ""
	}
#line 4176 ""
    }
#line 4177 ""
L4:

/*  If here, there were no following notes or came to a blank rest, or */
/*    "look-left" option set. So look before */

#line 4182 ""
    if (*ip == 1) {
#line 4182 ""
	return 0;
#line 4182 ""
    }
/* Get out if this is the first note. */
#line 4183 ""
    for (kkp = *ip - 1; kkp >= 1; --kkp) {
#line 4184 ""
	if (! bit_test(irest[*ivx + kkp * 24],0)) {
#line 4185 ""
	    levnext = nolev[*ivx + kkp * 24] - ncmid_(iv, &kkp) + 4;
/* Relative to bottom */
#line 4186 ""
	    goto L9;
#line 4187 ""
	}
#line 4188 ""
/* L3: */
#line 4188 ""
    }
#line 4189 ""
    return 0;
/* Pretty odd, should never be here, but get out if so. */
#line 4190 ""
L9:

/*  Find note in other voice at same time */

#line 4194 ""
    i__1 = *ivx - *nv - 1;
#line 4194 ""
    iupdown = i_sign(&c__1, &i__1);
#line 4195 ""
    ivother = ivmx[*iv + (3 - iupdown) / 2 * 24];
#line 4196 ""
    tother = 0.f;
#line 4197 ""
    i__1 = nib[ivother + *ibar * 24];
#line 4197 ""
    for (kkp = 1; kkp <= i__1; ++kkp) {
#line 4198 ""
	if ((r__1 = tother - *tnow, dabs(r__1)) < *tol) {
#line 4198 ""
	    goto L6;
#line 4198 ""
	}
#line 4199 ""
	tother += nodur[ivother + kkp * 24];
#line 4200 ""
/* L5: */
#line 4200 ""
    }

/*  If here, then no note starts in other voice at same time, so set default */

#line 4204 ""
    levother = -iupdown * 50;
#line 4205 ""
    goto L7;
#line 4206 ""
L6:

/*  If here, have just identified a simultaneous note or rest in other voice */

#line 4210 ""
    if (! bit_test(irest[ivother + kkp * 24],0)) {
/* Not a rest, use it */
#line 4211 ""
	levother = nolev[ivother + kkp * 24] - ncmid_(iv, ip) + 4;
#line 4212 ""
    } else {
#line 4213 ""
	if (nodur[ivother + kkp * 24] == nodur[*ivx + *ip * 24]) {

/*  Rest in other voice has same duration, get out (so defualt spacing is used) */

#line 4217 ""
	    return 0;
#line 4218 ""
	}
#line 4219 ""
	levother = -iupdown * 50;
#line 4220 ""
    }
#line 4221 ""
L7:
#line 4222 ""
    if (*mode == 1) {
#line 4223 ""
	indxr = log2_(&nodur[*ivx + *ip * 24]) + 1;
#line 4224 ""
    } else {
/*        nodu = 2**(4-(iand(mult(ivx,ip),15)-8)) */
#line 4226 ""
	indxr = 4 - ((mult[*ivx + *ip * 24] & 15) - 8) + 1;
#line 4227 ""
    }
#line 4228 ""
    if (iupdown < 0) {
#line 4229 ""
	levtop = levtopr[indxr];
#line 4230 ""
	iraise1 = levother - levtop - 3;
/* Based on other note */
#line 4231 ""
	iraise2 = levnext - levtop;
/* Based on following note */
#line 4232 ""
	if (indxr == 5 && levnext < 1) {
#line 4232 ""
	    iraise2 += 2;
#line 4232 ""
	}
#line 4233 ""
	iraise = min(iraise1,iraise2);
#line 4234 ""
	if ((iraise + 50) % 2 == 1 && iraise + levtop > -1) {
#line 4234 ""
	    --iraise;
#line 4234 ""
	}
#line 4236 ""
    } else {
#line 4237 ""
	levbot = levbotr[indxr];
#line 4238 ""
	iraise1 = levother - levbot + 3;
#line 4239 ""
	iraise2 = levnext - levbot;
#line 4240 ""
	if (indxr == 5 && levnext > 8) {
#line 4240 ""
	    --iraise2;
#line 4240 ""
	}
#line 4241 ""
	iraise = max(iraise1,iraise2);
#line 4242 ""
	if ((iraise + 50) % 2 == 1 && iraise + levbot <= 9) {
#line 4242 ""
	    --iraise;
#line 4242 ""
	}
#line 4244 ""
    }
#line 4245 ""
    nolev[*ivx + *ip * 24] = iraise + 100;
#line 4246 ""
    return 0;
} /* chkkbdrests_ */

/* Subroutine */ int chklit_(char *lineq, integer *iccount, integer *literr, 
	ftnlen lineq_len)
{
    /* System generated locals */
    char ch__1[1];

    /* Local variables */
    extern /* Character */ VOID chax_(char *, ftnlen, integer *);
    static char charq[1];
    static integer itype, lenlit;
    extern /* Subroutine */ int g1etchar_(char *, integer *, char *, ftnlen, 
	    ftnlen);

#line 4251 ""
    *literr = 0;
#line 4252 ""
    itype = 1;
#line 4253 ""
L17:
#line 4253 ""
    g1etchar_(lineq, iccount, charq, (ftnlen)128, (ftnlen)1);
#line 4254 ""
    chax_(ch__1, (ftnlen)1, &c__92);
#line 4254 ""
    if (*(unsigned char *)charq == *(unsigned char *)&ch__1[0]) {
#line 4255 ""
	++itype;
#line 4256 ""
	if (itype > 3) {
#line 4257 ""
	    *literr = 1;
#line 4258 ""
	    return 0;
#line 4259 ""
	}
#line 4260 ""
	goto L17;
#line 4261 ""
    }
#line 4262 ""
    lenlit = itype;
#line 4263 ""
L18:
#line 4263 ""
    g1etchar_(lineq, iccount, charq, (ftnlen)128, (ftnlen)1);
#line 4264 ""
    chax_(ch__1, (ftnlen)1, &c__92);
#line 4264 ""
    if (*(unsigned char *)charq == *(unsigned char *)&ch__1[0]) {
#line 4265 ""
	g1etchar_(lineq, iccount, charq, (ftnlen)128, (ftnlen)1);
#line 4266 ""
	if (*(unsigned char *)charq != ' ') {

/*  Starting a new tex command withing the string */

#line 4270 ""
	    lenlit += 2;
#line 4271 ""
	    if (lenlit > 128) {
#line 4272 ""
		*literr = 2;
#line 4273 ""
		return 0;
#line 4274 ""
	    }
#line 4275 ""
	    goto L18;
#line 4276 ""
	}
#line 4277 ""
    } else {
#line 4278 ""
	++lenlit;
#line 4279 ""
	if (lenlit > 128) {
#line 4280 ""
	    *literr = 2;
#line 4281 ""
	    return 0;
#line 4282 ""
	}
#line 4283 ""
	goto L18;
#line 4284 ""
    }
#line 4285 ""
    return 0;
} /* chklit_ */

/* Subroutine */ int chkpm4ac_(char *lineq, integer *iccount, integer *nacc, 
	logical *moved, ftnlen lineq_len)
{
    /* System generated locals */
    integer i__1, i__2;
    real r__1;

    /* Builtin functions */
    integer i_indx(char *, char *, ftnlen, ftnlen), s_cmp(char *, char *, 
	    ftnlen, ftnlen), i_nint(real *);

    /* Local variables */
    static integer ipm;
    static real fnum;
    static char durq[1];
    static integer icsav;
    static logical ishorz;
    extern /* Subroutine */ int readnum_(char *, integer *, char *, real *, 
	    ftnlen, ftnlen), setbits_(integer *, integer *, integer *, 
	    integer *);


/*  Called after getting +/-/</> in a note (not rest).  iccount is on the +-<>. */
/*  Sets moved=.true. and sets move parameters in nacc if necc: horiz only (bits */
/*    10-16) if < or >,  horiz and vert (bits 4-9) if two consecutive signed */
/*    numbers.  If moved=.true., iccount on exit is on end of last number. */
/*    If moved=.false., iccount still on +/- */

#line 4298 ""
    i__1 = *iccount - 2;
#line 4298 ""
    i__2 = *iccount;
#line 4298 ""
    if (i_indx("sfnA", lineq + i__1, (ftnlen)4, *iccount - 1 - i__1) > 0 && 
	    i_indx("0123456789.", lineq + i__2, (ftnlen)11, *iccount + 1 - 
	    i__2) > 0) {

/*  Prior char was accid & next is #; this may be start of accidental shift. */
/*  Must test for "." above in case we get "<" or ">" */

#line 4304 ""
	ipm = i_indx("- +< >", lineq + (*iccount - 1), (ftnlen)6, (ftnlen)1) 
		- 2;
#line 4305 ""
	i__1 = *iccount + 1;
#line 4305 ""
	i__2 = *iccount;
#line 4305 ""
	if (s_cmp(lineq + i__2, ".", *iccount + 1 - i__2, (ftnlen)1) == 0 && 
		i_indx("0123456789", lineq + i__1, (ftnlen)10, *iccount + 2 - 
		i__1) == 0) {

/*  Rare case of [accid][+/-].[letter].  Bail out */

#line 4310 ""
	    *moved = FALSE_;
#line 4311 ""
	    return 0;
#line 4312 ""
	}
#line 4313 ""
	ishorz = ipm > 1;

/*  Save iccount in case it's not accid shift and we have to reset. */

#line 4317 ""
	icsav = *iccount;
#line 4318 ""
	++(*iccount);
#line 4319 ""
	readnum_(lineq, iccount, durq, &fnum, (ftnlen)128, (ftnlen)1);
#line 4320 ""
	if (ishorz || i_indx("+-", durq, (ftnlen)2, (ftnlen)1) > 0) {

/*  This has to be accidental shift.  Set vert. shift. */

#line 4324 ""
	    if (! ishorz) {

/*  +/- syntax, both shifts set, vertical first */

#line 4328 ""
		i__1 = (integer) (ipm * fnum + 32.5f);
#line 4328 ""
		setbits_(nacc, &c__6, &c__4, &i__1);
#line 4329 ""
		ipm = i_indx("- +", durq, (ftnlen)3, (ftnlen)1) - 2;
#line 4330 ""
		++(*iccount);
#line 4331 ""
		readnum_(lineq, iccount, durq, &fnum, (ftnlen)128, (ftnlen)1);
#line 4332 ""
	    } else {

/*  </> syntax, only horiz set */

#line 4336 ""
		ipm += -3;
#line 4337 ""
	    }

/*  Set horiz. shift */

#line 4341 ""
	    r__1 = (ipm * fnum + 5.35f) * 20;
#line 4341 ""
	    i__1 = i_nint(&r__1);
#line 4341 ""
	    setbits_(nacc, &c__7, &c__10, &i__1);
#line 4342 ""
	    --(*iccount);
#line 4343 ""
	    *moved = TRUE_;
#line 4344 ""
	} else {

/*  False alarm.  Reset everything and flow onward */

#line 4348 ""
	    *moved = FALSE_;
#line 4349 ""
	    *iccount = icsav;
#line 4350 ""
	}
#line 4351 ""
    } else {

/* Either prior char was not 'sfn' or next was not digit, so take no action */

#line 4355 ""
	*moved = FALSE_;
#line 4356 ""
    }
#line 4357 ""
    return 0;
} /* chkpm4ac_ */

/* Subroutine */ int clefsym_(integer *isl, char *notexq, integer *lnote, 
	integer *nclef, ftnlen notexq_len)
{
    /* System generated locals */
    address a__1[4];
    integer i__1[4], i__2, i__3;
    char ch__1[1], ch__2[1], ch__3[1];

    /* Builtin functions */
    integer lbit_shift(integer, integer);
    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);

    /* Local variables */
    extern /* Character */ VOID chax_(char *, ftnlen, integer *);
    static integer nlev;


/*  Returns string calling Don's TeX macro \pmxclef, for drawing small clefs. */

#line 4365 ""
    *nclef = lbit_shift(*isl, (ftnlen)-12) & 7;
#line 4366 ""
    if (*nclef == 0) {

/*  treble */

#line 4370 ""
	nlev = 2;
#line 4371 ""
    } else if (*nclef > 6) {

/*  French violin */

#line 4375 ""
	nlev = 0;
#line 4376 ""
    } else if (*nclef < 5) {

/*  C-clef */

#line 4380 ""
	nlev = (*nclef << 1) - 2;
#line 4381 ""
    } else {

/*  F-clef */

#line 4385 ""
	nlev = (*nclef << 1) - 6;
#line 4386 ""
    }
/* Writing concatenation */
#line 4387 ""
    chax_(ch__1, (ftnlen)1, &c__92);
#line 4387 ""
    i__1[0] = 1, a__1[0] = ch__1;
#line 4387 ""
    i__1[1] = 7, a__1[1] = "pmxclef";
#line 4387 ""
    i__2 = min(*nclef,7) + 48;
#line 4387 ""
    chax_(ch__2, (ftnlen)1, &i__2);
#line 4387 ""
    i__1[2] = 1, a__1[2] = ch__2;
#line 4387 ""
    i__3 = nlev + 48;
#line 4387 ""
    chax_(ch__3, (ftnlen)1, &i__3);
#line 4387 ""
    i__1[3] = 1, a__1[3] = ch__3;
#line 4387 ""
    s_cat(notexq, a__1, i__1, &c__4, notexq_len);
#line 4389 ""
    *lnote = 10;
#line 4390 ""
    return 0;
} /* clefsym_ */

/* Subroutine */ int crdacc_(integer *nacc, integer *naccid, integer *micrd, 
	integer *nolevm, real *rmsshift, logical *lasttime, integer *
	levmaxacc, integer *icrdot0, real *segrb0, integer *ksegrb0, integer *
	nsegrb0, logical *twooftwo, integer *icashft)
{
    /* Initialized data */

    static integer nsegar[5] = { 3,4,3,3,2 };
    static integer nsegal[5] = { 2,4,3,3,2 };
    static real segar[60]	/* was [5][2][6] */ = { -.05f,-.38f,-.34f,
	    -.05f,-.15f,-1.4f,-2.9f,-3.f,-1.4f,-1.2f,-.75f,-.2f,-.8f,-.75f,
	    0.f,.96f,-1.04f,1.48f,.96f,1.2f,0.f,-.38f,0.f,0.f,0.f,3.15f,1.64f,
	    3.f,3.15f,0.f,0.f,0.f,0.f,0.f,0.f,0.f,2.9f,0.f,0.f,0.f,0.f,0.f,
	    0.f,0.f,0.f,0.f,0.f,0.f,0.f,0.f,0.f,0.f,0.f,0.f,0.f,0.f,0.f,0.f,
	    0.f,0.f };
    static real segal[60]	/* was [5][2][6] */ = { -1.f,-1.02f,-.6f,
	    -1.65f,-1.2f,-1.4f,-2.9f,-3.f,-1.4f,-1.2f,0.f,-1.2f,-1.04f,0.f,
	    0.f,3.15f,-1.64f,-1.48f,3.15f,1.2f,0.f,-1.02f,0.f,0.f,0.f,0.f,
	    1.04f,3.f,0.f,0.f,0.f,0.f,0.f,0.f,0.f,0.f,2.9f,0.f,0.f,0.f,0.f,
	    0.f,0.f,0.f,0.f,0.f,0.f,0.f,0.f,0.f,0.f,0.f,0.f,0.f,0.f,0.f,0.f,
	    0.f,0.f,0.f };
    static integer iacctbl[6] = { 1,2,3,0,4,5 };

    /* System generated locals */
    integer i__1, i__2, i__3;
    real r__1;

    /* Builtin functions */
    integer i_nint(real *), s_wsle(cilist *), do_lio(integer *, integer *, 
	    char *, ftnlen), e_wsle(void);

    /* Local variables */
    static integer iacctype;
    static logical mainnote;
    extern integer igetbits_(integer *, integer *, integer *);
    static real ybotaseg, shiftmin;
    static integer isetshft[10];
    static real ytopaseg;
    static integer ibelowbot, ibelowtop, iwa, iranksetter, iseg;
    extern /* Subroutine */ int stop1_(void);
    static integer isega;
    static real segrb[100]	/* was [2][50] */;
    static integer irank;
    static real shift;
    static integer nolev, isegrb, ksegrb[50], nsegrb, ishift;
    extern /* Subroutine */ int printl_(char *, ftnlen);
    static integer netgain;
    extern /* Subroutine */ int setbits_(integer *, integer *, integer *, 
	    integer *);

    /* Fortran I/O blocks */
    static cilist io___324 = { 0, 6, 0, 0, 0 };
    static cilist io___325 = { 0, 6, 0, 0, 0 };



/*       nacc = accidental bitmap for main note */
/*       naccid = # of accid's in chord */
/*       micrd = array with icrd #'s for notes w/ acc's, 0=>main note */
/*       nolevm = level of main note */
/*       segrb(1|2,.) x|y-coord of right-bdry segment */
/*       ksegrb(.) internal use; tells what defined this segment */
/*           -2: Left-shifted notehead */
/*           -1: Original right boundary */
/*            0: Main note accidental */
/*         icrd: Chord-note accidental */
/*       isetshft(i),i=1,naccid: what set shift for this accid, same codes */
/*       icrdot0 = top-down level-rank of main note among accid-notes */
/*       icrdot(icrd)(27-29) = level rank of chord-note among accid-notes */
/*       twooftwo will be true 2nd time thru; signal to store shifts w/ notes */

#line 4417 ""
    /* Parameter adjustments */
#line 4417 ""
    --ksegrb0;
#line 4417 ""
    segrb0 -= 3;
#line 4417 ""
    --micrd;
#line 4417 ""

#line 4417 ""
    /* Function Body */

/*  Fancy sharp boundary. fl,sh,na,dfl,dsh */

/*     * -0.75,-0.20,-0.80, 0. , 0. , .96,-1.04,1.6, 0. , 0. , */
/*           meas value for y, natural is 1.6 */
/*     *  0.00, 0.00,-1.04, 0. , 0. ,3.15, 2.9,-1.6, 0. , 0. , */
/* c		(meas. value is 3.08)    ^^^^ */
/* c  Raise top of flat so it interferes with bottom of sharp */

/*  iacctbl(i) = internal accid # (1-5) when i=extern accid # (1,2,3,5,6) */


/*  Set up barrier segrb(iseg,ipoint) to define coords of corner points */
/*    on stem+notes */

#line 4448 ""
    i__1 = *nsegrb0;
#line 4448 ""
    for (iseg = 1; iseg <= i__1; ++iseg) {
#line 4449 ""
	segrb[(iseg << 1) - 2] = segrb0[(iseg << 1) + 1];
#line 4450 ""
	segrb[(iseg << 1) - 1] = segrb0[(iseg << 1) + 2];
#line 4451 ""
	ksegrb[iseg - 1] = ksegrb0[iseg];
#line 4452 ""
/* L11: */
#line 4452 ""
    }
#line 4453 ""
    nsegrb = *nsegrb0;
#line 4454 ""
    *rmsshift = 0.f;
#line 4455 ""
    shiftmin = 1e3f;
#line 4456 ""
    i__1 = *naccid;
#line 4456 ""
    for (iwa = 1; iwa <= i__1; ++iwa) {

/*  Initialize shift for this note */

#line 4460 ""
	shift = 0.f;
#line 4461 ""
	mainnote = micrd[iwa] == 0;
#line 4462 ""
	isetshft[iwa - 1] = -1;

/* Get note level and accidental type */

#line 4466 ""
	if (mainnote) {
#line 4467 ""
	    nolev = *nolevm;
#line 4468 ""
	    iacctype = iacctbl[igetbits_(nacc, &c__3, &c__0) - 1];
#line 4469 ""
	} else {
#line 4470 ""
	    nolev = igetbits_(&comtrill_1.icrdat[micrd[iwa] - 1], &c__7, &
		    c__12);
#line 4471 ""
	    iacctype = iacctbl[igetbits_(&comtrill_1.icrdat[micrd[iwa] - 1], &
		    c__3, &c__20) - 1];
#line 4472 ""
	}

/*  Cycle thru segments on right edge of this accidental */

#line 4476 ""
	i__2 = nsegar[iacctype - 1] - 1;
#line 4476 ""
	for (isega = 1; isega <= i__2; ++isega) {
#line 4477 ""
	    ybotaseg = nolev + segar[iacctype + ((isega << 1) + 2) * 5 - 16];
#line 4478 ""
	    ytopaseg = nolev + segar[iacctype + ((isega + 1 << 1) + 2) * 5 - 
		    16];

/*  Cycle thru segments of right-hand barrier */

#line 4482 ""
	    i__3 = nsegrb - 1;
#line 4482 ""
	    for (isegrb = 1; isegrb <= i__3; ++isegrb) {

/*  Must find all barrier segments that start below ytopseg & end above ybotseg */

#line 4486 ""
		if (segrb[(isegrb << 1) - 1] < ytopaseg) {

/*  Barrier seg starts below top of accid */
/*  Check if barrier seg ends above bottom of accid */

#line 4491 ""
		    if (segrb[(isegrb + 1 << 1) - 1] > ybotaseg) {
#line 4492 ""
			if (shift > segrb[(isegrb << 1) - 2] - segar[iacctype 
				+ ((isega << 1) + 1) * 5 - 16]) {
#line 4494 ""
			    shift = segrb[(isegrb << 1) - 2] - segar[iacctype 
				    + ((isega << 1) + 1) * 5 - 16];

/*  Record the cause of the shift */

#line 4498 ""
			    isetshft[iwa - 1] = ksegrb[isegrb - 1];
#line 4499 ""
			}
#line 4500 ""
		    }

/*  Does barrier segment end above top of accid seg? */

#line 4504 ""
		    if (segrb[(isegrb + 1 << 1) - 1] > ytopaseg) {
#line 4504 ""
			goto L4;
#line 4504 ""
		    }
#line 4505 ""
		}
#line 4506 ""
/* L3: */
#line 4506 ""
	    }
#line 4507 ""
L4:
#line 4508 ""
/* L2: */
#line 4508 ""
	    ;
#line 4508 ""
	}
#line 4509 ""
	if (! bit_test(*nacc,28) && dabs(shift) > 1e-4f && ! (*lasttime)) {
/*          if (nolev .eq. levmaxacc) then */
#line 4512 ""
	    if (nolev == *levmaxacc && isetshft[iwa - 1] == -1) {
#line 4513 ""
		*rmsshift = 1e3f;
#line 4514 ""
		return 0;
#line 4515 ""
	    }

/*  Does the following properly account for left-shifted noteheads? */

/*  Top-down rank of this note we just shifted */

#line 4521 ""
	    if (mainnote) {
#line 4522 ""
		irank = *icrdot0;
#line 4523 ""
	    } else {
#line 4524 ""
		irank = igetbits_(&comtrill_1.icrdot[micrd[iwa] - 1], &c__3, &
			c__27);
#line 4525 ""
	    }

/*  Compare level-rank of this note vs. that of note that caused the shift. */
/*    This has effect of checking for basic interferences from top down. */

/*       ksegrb(.) internal use; tells what defined this segment */
/*           -2: Left-shifted notehead */
/*           -1: Original right boundary */
/*            0: Main note accidental */
/*         icrd: Chord-note accidental */
/*       isetshft(i),i=1,naccid: what set shift for this accid, same codes */

#line 4537 ""
	    if (isetshft[iwa - 1] < 0) {
#line 4538 ""
		iranksetter = 0;
#line 4539 ""
	    } else if (isetshft[iwa - 1] == 0) {
#line 4540 ""
		iranksetter = *icrdot0;
#line 4541 ""
	    } else {
#line 4542 ""
		iranksetter = igetbits_(&comtrill_1.icrdot[isetshft[iwa - 1] 
			- 1], &c__3, &c__27);
#line 4543 ""
	    }
#line 4544 ""
	    if (iranksetter != 0 && irank != iranksetter + 1) {
#line 4545 ""
		*rmsshift = 1e3f;
#line 4546 ""
		return 0;
#line 4547 ""
	    }
#line 4548 ""
	}
/* Computing 2nd power */
#line 4549 ""
	r__1 = shift;
#line 4549 ""
	*rmsshift += r__1 * r__1;
#line 4550 ""
	if (*lasttime && dabs(shift) > 1e-4f) {
#line 4551 ""
	    if (mainnote) {
#line 4552 ""
		if (! bit_test(*nacc,29)) {
#line 4552 ""
		    goto L10;
#line 4552 ""
		}
#line 4553 ""
	    } else {
#line 4554 ""
		if (! bit_test(comtrill_1.icrdat[micrd[iwa] - 1],29)) {
#line 4554 ""
		    goto L10;
#line 4554 ""
		}
#line 4555 ""
	    }

/*  If here, "A" was set on a manual shift, so must cumulate the shift.  Note that if there */
/*    was a manual shift but auto-shift was zero, will not come thru here, but shift value */
/*    will be left intact. */

#line 4561 ""
	    if (mainnote) {
#line 4562 ""
		shift += (igetbits_(nacc, &c__7, &c__10) - 107) * .05f;
#line 4563 ""
	    } else {
#line 4564 ""
		shift += (igetbits_(&comtrill_1.icrdot[micrd[iwa] - 1], &c__7,
			 &c__20) - 107) * .05f;
#line 4565 ""
	    }
#line 4566 ""
L10:
#line 4567 ""
	    if (*twooftwo) {

/*  Record the shift for this accidental */

#line 4571 ""
		if (shift < -5.35f) {
#line 4572 ""
		    printl_(" ", (ftnlen)1);
#line 4573 ""
		    printl_("WARNING: auto-generated accidental shift too bi"\
			    "g for PMX, ignoring", (ftnlen)66);
#line 4575 ""
		} else {
#line 4576 ""
		    r__1 = (shift + 5.35f) * 20;
#line 4576 ""
		    ishift = i_nint(&r__1);
#line 4577 ""
		    if (mainnote) {
#line 4578 ""
			setbits_(nacc, &c__7, &c__10, &ishift);
#line 4579 ""
		    } else {
#line 4580 ""
			setbits_(&comtrill_1.icrdot[micrd[iwa] - 1], &c__7, &
				c__20, &ishift);
#line 4581 ""
		    }
#line 4582 ""
		}
#line 4583 ""
	    } else {

/*  This is the earlier call to precrd, so need minimum shift */

#line 4587 ""
		shiftmin = dmin(shiftmin,shift);
#line 4588 ""
	    }
#line 4589 ""
	}

/*  Bail out if this is the last accidental to check */

#line 4593 ""
	if (iwa == *naccid) {
#line 4593 ""
	    goto L1;
#line 4593 ""
	}

/*  Add this accidental to the right barrier! Count down from highest barrier segment, */
/*    find 1st one starting below top of accid, and first one starting below bot. */

#line 4598 ""
	for (ibelowtop = nsegrb; ibelowtop >= 1; --ibelowtop) {
#line 4599 ""
	    if (segrb[(ibelowtop << 1) - 1] < nolev + segal[iacctype + ((
		    nsegal[iacctype - 1] << 1) + 2) * 5 - 16]) {
#line 4601 ""
		for (ibelowbot = ibelowtop; ibelowbot >= 1; --ibelowbot) {
#line 4602 ""
		    if (segrb[(ibelowbot << 1) - 1] < nolev + segal[iacctype 
			    + 4]) {
#line 4602 ""
			goto L6;
#line 4602 ""
		    }
#line 4604 ""
/* L9: */
#line 4604 ""
		}
#line 4605 ""
		s_wsle(&io___324);
#line 4605 ""
		do_lio(&c__9, &c__1, "Oops2!", (ftnlen)6);
#line 4605 ""
		e_wsle();
#line 4606 ""
		stop1_();
#line 4607 ""
	    }
#line 4608 ""
/* L5: */
#line 4608 ""
	}
#line 4609 ""
	s_wsle(&io___325);
#line 4609 ""
	do_lio(&c__9, &c__1, "Ugh0! in crdaccs", (ftnlen)16);
#line 4609 ""
	e_wsle();
#line 4610 ""
	stop1_();
#line 4611 ""
L6:
#line 4612 ""
	netgain = nsegal[iacctype - 1] - ibelowtop + ibelowbot;

/*  Shift high segments up */

#line 4616 ""
	if (netgain >= 0) {
#line 4617 ""
	    i__2 = ibelowtop + 1;
#line 4617 ""
	    for (isegrb = nsegrb; isegrb >= i__2; --isegrb) {
#line 4618 ""
		segrb[(isegrb + netgain << 1) - 2] = segrb[(isegrb << 1) - 2];
#line 4619 ""
		segrb[(isegrb + netgain << 1) - 1] = segrb[(isegrb << 1) - 1];
#line 4620 ""
		ksegrb[isegrb + netgain - 1] = ksegrb[isegrb - 1];
#line 4621 ""
/* L7: */
#line 4621 ""
	    }

/*  Set up 1st segment above accid */

#line 4625 ""
	    segrb[(ibelowtop + netgain << 1) - 2] = segrb[(ibelowtop << 1) - 
		    2];
#line 4626 ""
	    segrb[(ibelowtop + netgain << 1) - 1] = nolev + segal[iacctype + (
		    (nsegal[iacctype - 1] << 1) + 2) * 5 - 16];
#line 4628 ""
	    ksegrb[ibelowtop + netgain - 1] = ksegrb[ibelowtop - 1];
#line 4629 ""
	} else {

/*  netgain<0, must remove segments. Use same coding but reverse order, */
/*    work from bottom up */

#line 4634 ""
	    segrb[(ibelowtop + netgain << 1) - 2] = segrb[(ibelowtop << 1) - 
		    2];
#line 4635 ""
	    segrb[(ibelowtop + netgain << 1) - 1] = nolev + segal[iacctype + (
		    (nsegal[iacctype - 1] << 1) + 2) * 5 - 16];
#line 4637 ""
	    ksegrb[ibelowtop + netgain - 1] = ksegrb[ibelowtop - 1];
#line 4638 ""
	    i__2 = nsegrb;
#line 4638 ""
	    for (isegrb = ibelowtop + 1; isegrb <= i__2; ++isegrb) {
#line 4639 ""
		segrb[(isegrb + netgain << 1) - 2] = segrb[(isegrb << 1) - 2];
#line 4640 ""
		segrb[(isegrb + netgain << 1) - 1] = segrb[(isegrb << 1) - 1];
#line 4641 ""
		ksegrb[isegrb + netgain - 1] = ksegrb[isegrb - 1];
#line 4642 ""
/* L12: */
#line 4642 ""
	    }
#line 4643 ""
	}

/*  Insert new segments */

#line 4647 ""
	i__2 = nsegal[iacctype - 1] - 1;
#line 4647 ""
	for (isega = 1; isega <= i__2; ++isega) {
#line 4648 ""
	    segrb[(ibelowbot + isega << 1) - 2] = shift + segal[iacctype + ((
		    isega << 1) + 1) * 5 - 16];
#line 4649 ""
	    segrb[(ibelowbot + isega << 1) - 1] = nolev + segal[iacctype + ((
		    isega << 1) + 2) * 5 - 16];
#line 4650 ""
	    if (mainnote) {
#line 4651 ""
		ksegrb[ibelowbot + isega - 1] = 0;
#line 4652 ""
	    } else {
#line 4653 ""
		ksegrb[ibelowbot + isega - 1] = micrd[iwa];
#line 4654 ""
	    }
#line 4655 ""
/* L8: */
#line 4655 ""
	}

/*  Update number of barrier segments */

#line 4659 ""
	nsegrb += netgain;
#line 4660 ""
L1:
#line 4660 ""
	;
#line 4660 ""
    }
/* next accidental */
#line 4661 ""
    if (*lasttime && ! (*twooftwo)) {

/*  This is the final call on the pre-ask pass, so compute left-shift rqmt. */

#line 4665 ""
	r__1 = shiftmin * -20;
#line 4665 ""
	*icashft = i_nint(&r__1);
#line 4666 ""
    }
#line 4667 ""
    return 0;
} /* crdacc_ */

/* Subroutine */ int crdaccs_(integer *nacc, integer *ipl, integer *irest, 
	integer *naccid, integer *kicrd, integer *nolevm, integer *levmaxacc, 
	integer *levminacc, integer *icrdot0, logical *twooftwo, integer *
	icashft)
{
    /* System generated locals */
    integer i__1, i__2, i__3;

    /* Builtin functions */
    integer s_wsle(cilist *), do_lio(integer *, integer *, char *, ftnlen), 
	    e_wsle(void);

    /* Local variables */
    extern integer igetbits_(integer *, integer *, integer *);
    static integer ipermsav[7];
    static real rmsshift;
    static integer i__, j, k, levmidacc, ip, ir, is, it, maxmanshft, icrd;
    extern /* Subroutine */ int stop1_(void);
    static integer micrd[10], iiseg, irank, iperm[7], nolev;
    static real segrb0[100]	/* was [2][50] */;
    extern /* Subroutine */ int crdacc_(integer *, integer *, integer *, 
	    integer *, real *, logical *, integer *, integer *, real *, 
	    integer *, integer *, logical *, integer *);
    static logical tagged;
    static integer isegrb;
    static logical manual, lshift;
    static integer idummy;
    static real rmsmin;
    static integer ksegrb0[50], nsegrb0, manshft;
    extern /* Subroutine */ int setbits_(integer *, integer *, integer *, 
	    integer *);

    /* Fortran I/O blocks */
    static cilist io___354 = { 0, 6, 0, 0, 0 };



/*       nacc = accidental bitmap for main note */
/*       naccid = # of accid's in chord */
/*       kicrd = array with icrd #'s for notes w/ acc's, 0=>main note */
/*       nolevm = level of main note */

/*  This is called once per multi-accidental chord.  In here, loop over all */
/*  permutations of the order of accidental as stored in kicrd.  Each time thru */
/*  loop, call crdacc once, get rms shift.  Only save permutation and rms value */
/*  if it is less than old value. */


/*  Make consistent? 120106 */
/*      integer*4 kicrd(7),iperm(7),micrd(10),ipermsav(7),ksegrb0(50) */

/*  Initialize right-barrier */

#line 4694 ""
    /* Parameter adjustments */
#line 4694 ""
    --kicrd;
#line 4694 ""

#line 4694 ""
    /* Function Body */
#line 4694 ""
    segrb0[0] = 0.f;
#line 4695 ""
    segrb0[1] = -1e3f;
#line 4696 ""
    segrb0[2] = 0.f;
#line 4697 ""
    segrb0[3] = 1e3f;
#line 4698 ""
    nsegrb0 = 2;
#line 4699 ""
    ksegrb0[0] = -1;
#line 4700 ""
    ksegrb0[1] = -1;

/*  Search for left-shifted notes, Make up the initial right-barrier, which */
/*     will be good for all permutations. */
/*     irest()(27) is set if any notes are left-shifted */
/*     Must use ALL chord notes, not just ones w/ accid's. */

#line 4707 ""
    if (bit_test(*irest,27)) {
#line 4708 ""
	i__1 = comtrill_1.icrd2;
#line 4708 ""
	for (icrd = comtrill_1.icrd1 - 1; icrd <= i__1; ++icrd) {
#line 4709 ""
	    if (icrd == comtrill_1.icrd1 - 1) {

/*  Main note */

/*            lshift = btest(ipl,8) */
#line 4714 ""
		lshift = bit_test(*ipl,8) || bit_test(*nacc,31);
#line 4715 ""
		if (lshift) {
#line 4715 ""
		    nolev = *nolevm;
#line 4715 ""
		}
#line 4716 ""
	    } else {

/*  Chord note */

#line 4720 ""
		lshift = bit_test(comtrill_1.icrdat[icrd - 1],23);
/*            if (lshift) nolev = igetbits(icrdat(icrd),7,12) */
#line 4722 ""
		if (lshift) {
#line 4723 ""
		    nolev = igetbits_(&comtrill_1.icrdat[icrd - 1], &c__7, &
			    c__12);
#line 4724 ""
		    if (bit_test(*nacc,31) && nolev == *nolevm + 1) {

/*  This note is not really shifted, It is the upper of a 2nd with the main */
/*    note on an upstem, and Main note must be shifted. */
/*    nacc(31) signals the real truth. */

#line 4730 ""
			lshift = FALSE_;
#line 4731 ""
		    }
#line 4732 ""
		}
#line 4733 ""
	    }
#line 4734 ""
	    if (lshift) {
#line 4735 ""
		i__2 = nsegrb0 - 1;
#line 4735 ""
		for (isegrb = 1; isegrb <= i__2; ++isegrb) {
#line 4736 ""
		    if (segrb0[(isegrb + 1 << 1) - 1] > (real) (nolev - 1)) {

/*  Add this notehead to the right boundary here.  Move all higher segs up 2. */

#line 4740 ""
			i__3 = isegrb + 1;
#line 4740 ""
			for (iiseg = nsegrb0; iiseg >= i__3; --iiseg) {
#line 4741 ""
			    segrb0[(iiseg + 2 << 1) - 2] = segrb0[(iiseg << 1)
				     - 2];
#line 4742 ""
			    segrb0[(iiseg + 2 << 1) - 1] = segrb0[(iiseg << 1)
				     - 1];
#line 4743 ""
			    ksegrb0[iiseg + 1] = ksegrb0[iiseg - 1];
#line 4744 ""
/* L17: */
#line 4744 ""
			}
#line 4745 ""
			goto L18;
#line 4746 ""
		    }
#line 4747 ""
/* L16: */
#line 4747 ""
		}
#line 4748 ""
L18:

/*  Insert notehead into list. Set kseg=-2 to signal notehead shift. */

#line 4752 ""
		iiseg = isegrb + 1;
#line 4753 ""
		segrb0[(iiseg << 1) - 2] = -1.2f;
#line 4754 ""
		segrb0[(iiseg << 1) - 1] = nolev - 1.f;
#line 4755 ""
		ksegrb0[iiseg - 1] = -2;
#line 4756 ""
		segrb0[(iiseg + 1 << 1) - 2] = 0.f;
#line 4757 ""
		segrb0[(iiseg + 1 << 1) - 1] = nolev + 1.f;
#line 4758 ""
		ksegrb0[iiseg] = -1;
#line 4759 ""
		nsegrb0 += 2;
#line 4760 ""
	    }
#line 4761 ""
/* L15: */
#line 4761 ""
	}
#line 4762 ""
    }

/*  Done setting right barrier for left-shifted noteheads */

#line 4766 ""
    tagged = FALSE_;
#line 4767 ""
    manual = FALSE_;

/*  Preprocess to check for manual shifts. */
/*   If are manual main [nacc(10-16)] or chord note [icrdot(20-26)]shifts, then */
/*      If any manual shift is preceded by "A" [nacc(29), icrdat(29)] then */
/*         1. Auto-shifting proceeds */
/*         2. "A"-shifts add to autoshifts */
/*         3. non-"A" shifts are ignored! */
/*      Else (>0 man shifts, none has "A") */
/*         No auto-ordering, No autoshifts, Observe all manual shifts. */
/*      End if */
/*   End if */

#line 4780 ""
    maxmanshft = 0;
#line 4781 ""
    i__1 = *naccid;
#line 4781 ""
    for (i__ = 1; i__ <= i__1; ++i__) {
#line 4782 ""
	if (kicrd[i__] == 0) {

/*  Main note */

#line 4786 ""
	    manshft = igetbits_(nacc, &c__7, &c__10);
#line 4787 ""
	    if (manshft != 0) {
#line 4788 ""
		manual = TRUE_;
#line 4789 ""
		if (bit_test(*nacc,29)) {
#line 4790 ""
		    tagged = TRUE_;
#line 4791 ""
		} else {
/*              maxmanshft = max(maxmanshft,64-manshft) */
/* Computing MAX */
#line 4793 ""
		    i__2 = maxmanshft, i__3 = 107 - manshft;
#line 4793 ""
		    maxmanshft = max(i__2,i__3);
#line 4794 ""
		}
#line 4795 ""
	    }
#line 4796 ""
	} else {

/*  Chord note */

#line 4800 ""
	    manshft = igetbits_(&comtrill_1.icrdot[kicrd[i__] - 1], &c__7, &
		    c__20);
#line 4801 ""
	    if (manshft != 0) {
#line 4802 ""
		manual = TRUE_;
#line 4803 ""
		if (bit_test(comtrill_1.icrdat[kicrd[i__] - 1],29)) {
#line 4804 ""
		    tagged = TRUE_;
#line 4805 ""
		} else {
/*              maxmanshft = max(maxmanshft,64-manshft) */
/* Computing MAX */
#line 4807 ""
		    i__2 = maxmanshft, i__3 = 107 - manshft;
#line 4807 ""
		    maxmanshft = max(i__2,i__3);
#line 4808 ""
		}
#line 4809 ""
	    }
#line 4810 ""
	}
#line 4811 ""
/* L13: */
#line 4811 ""
    }
#line 4812 ""
    if (manual) {
#line 4813 ""
	if (tagged) {

/*  zero out all untagged shifts */

#line 4817 ""
	    i__1 = *naccid;
#line 4817 ""
	    for (i__ = 1; i__ <= i__1; ++i__) {
#line 4818 ""
		if (kicrd[i__] == 0) {
#line 4819 ""
		    if (! bit_test(*nacc,29)) {
#line 4819 ""
			setbits_(nacc, &c__7, &c__10, &c__0);
#line 4819 ""
		    }
#line 4820 ""
		} else {
#line 4821 ""
		    if (! bit_test(comtrill_1.icrdat[kicrd[i__] - 1],29)) {
#line 4821 ""
			setbits_(&comtrill_1.icrdot[kicrd[i__] - 1], &c__7, &
				c__20, &c__0);
#line 4821 ""
		    }
#line 4823 ""
		}
#line 4824 ""
/* L14: */
#line 4824 ""
	    }
#line 4825 ""
	} else {

/*  There are manual shifts but none tagged. Only proceed if "Ao" was entered */

#line 4829 ""
	    if (! bit_test(*nacc,28)) {
#line 4830 ""
		*icashft = maxmanshft;
#line 4831 ""
		return 0;
#line 4832 ""
	    }
#line 4833 ""
	}
#line 4834 ""
    }
#line 4835 ""
    if (bit_test(*nacc,28)) {

/*  Take the accidentals in order as originally input, then exit. */

#line 4839 ""
	crdacc_(nacc, naccid, &kicrd[1], nolevm, &rmsshift, &c_true, &idummy, 
		&idummy, segrb0, ksegrb0, &nsegrb0, twooftwo, icashft);
#line 4841 ""
	return 0;
/*      end if */
#line 4843 ""
    } else if (*naccid == 3) {

/*  Special treatment if 3 accidentals in chord. If there aren't accids on a 2nd */
/*    then place in order top, bottom, middle. */

#line 4848 ""
	for (i__ = 1; i__ <= 3; ++i__) {
#line 4849 ""
	    if (kicrd[i__] == 0) {
#line 4850 ""
		irank = *icrdot0;
#line 4851 ""
		nolev = *nolevm;
#line 4852 ""
	    } else {
#line 4853 ""
		irank = igetbits_(&comtrill_1.icrdot[kicrd[i__] - 1], &c__3, &
			c__27);
#line 4854 ""
		nolev = igetbits_(&comtrill_1.icrdat[kicrd[i__] - 1], &c__7, &
			c__12);
#line 4855 ""
	    }
#line 4856 ""
	    if (irank == 1) {
#line 4857 ""
		micrd[0] = kicrd[i__];
#line 4858 ""
	    } else {
#line 4859 ""
		micrd[5 - irank - 1] = kicrd[i__];
#line 4860 ""
	    }
#line 4861 ""
	    if (irank == 2) {
#line 4862 ""
		levmidacc = nolev;
#line 4863 ""
	    }
#line 4864 ""
/* L20: */
#line 4864 ""
	}
#line 4865 ""
	if (*levmaxacc != levmidacc + 1 && levmidacc != *levminacc + 1) {
#line 4867 ""
	    crdacc_(nacc, naccid, micrd, nolevm, &rmsshift, &c_true, &idummy, 
		    &idummy, segrb0, ksegrb0, &nsegrb0, twooftwo, icashft);
#line 4869 ""
	    return 0;
#line 4870 ""
	}
#line 4871 ""
    }
#line 4872 ""
    rmsmin = 1e5f;

/*  Initialize permutation array */

#line 4876 ""
    i__1 = *naccid;
#line 4876 ""
    for (i__ = 1; i__ <= i__1; ++i__) {
#line 4877 ""
	iperm[i__ - 1] = i__;
#line 4878 ""
/* L7: */
#line 4878 ""
    }

/*  Start looping over permutations */

#line 4882 ""
    for (ip = 1; ip <= 5041; ++ip) {
#line 4883 ""
	if (ip != 1) {

/*  Work the magic algorithm to get the next permutation */

#line 4887 ""
	    for (k = *naccid - 1; k >= 1; --k) {
#line 4888 ""
		if (iperm[k - 1] <= iperm[k]) {
#line 4888 ""
		    goto L2;
#line 4888 ""
		}
#line 4889 ""
/* L1: */
#line 4889 ""
	    }

/*  If here, we just got the last permutation, so exit the loop over permutations */

#line 4893 ""
	    goto L10;
#line 4894 ""
L2:
#line 4895 ""
	    for (j = *naccid; j >= 1; --j) {
#line 4896 ""
		if (iperm[k - 1] <= iperm[j - 1]) {
#line 4896 ""
		    goto L4;
#line 4896 ""
		}
#line 4897 ""
/* L3: */
#line 4897 ""
	    }
#line 4898 ""
L4:
#line 4899 ""
	    it = iperm[j - 1];
#line 4900 ""
	    iperm[j - 1] = iperm[k - 1];
#line 4901 ""
	    iperm[k - 1] = it;
#line 4902 ""
	    is = k + 1;
#line 4903 ""
	    for (ir = *naccid; ir >= 1; --ir) {
#line 4904 ""
		if (ir <= is) {
#line 4904 ""
		    goto L6;
#line 4904 ""
		}
#line 4905 ""
		it = iperm[ir - 1];
#line 4906 ""
		iperm[ir - 1] = iperm[is - 1];
#line 4907 ""
		iperm[is - 1] = it;
#line 4908 ""
		++is;
#line 4909 ""
/* L5: */
#line 4909 ""
	    }
#line 4910 ""
L6:
#line 4911 ""
	    ;
#line 4911 ""
	}

/*  New we have a permutation.  Take icrd values out of kicrd and put them into */
/*  micrd in the order of the permutation */

#line 4916 ""
	i__1 = *naccid;
#line 4916 ""
	for (i__ = 1; i__ <= i__1; ++i__) {
#line 4917 ""
	    micrd[i__ - 1] = kicrd[iperm[i__ - 1]];
#line 4918 ""
/* L9: */
#line 4918 ""
	}
#line 4919 ""
	crdacc_(nacc, naccid, micrd, nolevm, &rmsshift, &c_false, levmaxacc, 
		icrdot0, segrb0, ksegrb0, &nsegrb0, twooftwo, icashft);
#line 4921 ""
	if (rmsshift < rmsmin) {

/*  Save this permutation, reset minrms */

#line 4925 ""
	    i__1 = *naccid;
#line 4925 ""
	    for (i__ = 1; i__ <= i__1; ++i__) {
#line 4926 ""
		ipermsav[i__ - 1] = iperm[i__ - 1];
#line 4927 ""
		rmsmin = rmsshift;
#line 4928 ""
/* L11: */
#line 4928 ""
	    }
#line 4929 ""
	}
#line 4930 ""
/* L8: */
#line 4930 ""
    }
#line 4931 ""
    s_wsle(&io___354);
#line 4931 ""
    do_lio(&c__9, &c__1, "Should not BEEEEEE here!", (ftnlen)24);
#line 4931 ""
    e_wsle();
#line 4932 ""
    stop1_();
#line 4933 ""
L10:

/*  Done looping, get info for the final choice */

#line 4937 ""
    i__1 = *naccid;
#line 4937 ""
    for (i__ = 1; i__ <= i__1; ++i__) {
#line 4938 ""
	micrd[i__ - 1] = kicrd[ipermsav[i__ - 1]];
#line 4939 ""
/* L12: */
#line 4939 ""
    }
#line 4940 ""
    crdacc_(nacc, naccid, micrd, nolevm, &rmsshift, &c_true, &idummy, &idummy,
	     segrb0, ksegrb0, &nsegrb0, twooftwo, icashft);
#line 4942 ""
    return 0;
} /* crdaccs_ */

/* Subroutine */ int doacc_(integer *ihshft, integer *ivshft, char *notexq, 
	integer *lnote, integer *nacc, integer *nolev, integer *ncm, logical *
	caut, ftnlen notexq_len)
{
    /* System generated locals */
    address a__1[2], a__2[3];
    integer i__1[2], i__2[3];
    char ch__1[1];
    icilist ici__1;

    /* Builtin functions */
    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
    integer s_wsfi(icilist *), do_fio(integer *, char *, ftnlen), e_wsfi(void)
	    ;
    /* Subroutine */ int s_copy(char *, char *, ftnlen, ftnlen);

    /* Local variables */
    extern /* Subroutine */ int addblank_(char *, integer *, ftnlen);
    static char sq[1];
    static integer lacc;
    extern /* Character */ VOID chax_(char *, ftnlen, integer *);
    static real hshft;
    static char noteq[8];
    extern /* Subroutine */ int accsym_(integer *, char *, integer *, ftnlen);
    static integer noleva;
    extern /* Subroutine */ int notefq_(char *, integer *, integer *, integer 
	    *, ftnlen);
    static char acsymq[3];
    static integer lnoten;

#line 4950 ""
    chax_(ch__1, (ftnlen)1, &c__92);
#line 4950 ""
    *(unsigned char *)sq = *(unsigned char *)&ch__1[0];
#line 4951 ""
    if (*ihshft == -107) {
#line 4951 ""
	*ihshft = 0;
#line 4951 ""
    }

/*  If main note shifted left, so shift accid.  Terminate below, when acc. is done. */

#line 4955 ""
    if (*ihshft != 0) {

/*  Accid must be shifted horizontally */

#line 4959 ""
	if (*ihshft < 0) {
/* Writing concatenation */
#line 4960 ""
	    i__1[0] = 1, a__1[0] = sq;
#line 4960 ""
	    i__1[1] = 8, a__1[1] = "loffset{";
#line 4960 ""
	    s_cat(notexq, a__1, i__1, &c__2, (ftnlen)79);
#line 4961 ""
	    *ihshft = -(*ihshft);
#line 4962 ""
	} else {
/* Writing concatenation */
#line 4963 ""
	    i__1[0] = 1, a__1[0] = sq;
#line 4963 ""
	    i__1[1] = 8, a__1[1] = "roffset{";
#line 4963 ""
	    s_cat(notexq, a__1, i__1, &c__2, (ftnlen)79);
#line 4964 ""
	}
#line 4965 ""
	hshft = *ihshft * .05f;
#line 4966 ""
	if (hshft < 1.f) {
#line 4967 ""
	    ici__1.icierr = 0;
#line 4967 ""
	    ici__1.icirnum = 1;
#line 4967 ""
	    ici__1.icirlen = 3;
#line 4967 ""
	    ici__1.iciunit = notexq + 9;
#line 4967 ""
	    ici__1.icifmt = "(f3.2)";
#line 4967 ""
	    s_wsfi(&ici__1);
#line 4967 ""
	    do_fio(&c__1, (char *)&hshft, (ftnlen)sizeof(real));
#line 4967 ""
	    e_wsfi();
#line 4968 ""
	    *lnote = 12;
#line 4969 ""
	} else {
#line 4970 ""
	    ici__1.icierr = 0;
#line 4970 ""
	    ici__1.icirnum = 1;
#line 4970 ""
	    ici__1.icirlen = 4;
#line 4970 ""
	    ici__1.iciunit = notexq + 9;
#line 4970 ""
	    ici__1.icifmt = "(f4.2)";
#line 4970 ""
	    s_wsfi(&ici__1);
#line 4970 ""
	    do_fio(&c__1, (char *)&hshft, (ftnlen)sizeof(real));
#line 4970 ""
	    e_wsfi();
#line 4971 ""
	    *lnote = 13;
#line 4972 ""
	}
/* Writing concatenation */
#line 4973 ""
	i__2[0] = *lnote, a__2[0] = notexq;
#line 4973 ""
	i__2[1] = 2, a__2[1] = "}{";
#line 4973 ""
	i__2[2] = 1, a__2[2] = sq;
#line 4973 ""
	s_cat(notexq, a__2, i__2, &c__3, (ftnlen)79);
#line 4974 ""
	*lnote += 3;
#line 4975 ""
    } else {
#line 4976 ""
	s_copy(notexq, sq, (ftnlen)79, (ftnlen)1);
#line 4977 ""
	*lnote = 1;
#line 4978 ""
    }
#line 4979 ""
    if (bit_test(*nacc,3)) {
/* Writing concatenation */
#line 4980 ""
	i__1[0] = *lnote, a__1[0] = notexq;
#line 4980 ""
	i__1[1] = 3, a__1[1] = "big";
#line 4980 ""
	s_cat(notexq, a__1, i__1, &c__2, (ftnlen)79);
#line 4981 ""
	*lnote += 3;
#line 4982 ""
    }
#line 4983 ""
    if (*caut) {

/*  Cautionary accidental.  Need to define bigcna,... in pmx.tex */

/* Writing concatenation */
#line 4987 ""
	i__1[0] = *lnote, a__1[0] = notexq;
#line 4987 ""
	i__1[1] = 1, a__1[1] = "c";
#line 4987 ""
	s_cat(notexq, a__1, i__1, &c__2, (ftnlen)79);
#line 4988 ""
	++(*lnote);
#line 4989 ""
    }
#line 4990 ""
    accsym_(nacc, acsymq, &lacc, (ftnlen)3);
/* Writing concatenation */
#line 4991 ""
    i__1[0] = *lnote, a__1[0] = notexq;
#line 4991 ""
    i__1[1] = lacc, a__1[1] = acsymq;
#line 4991 ""
    s_cat(notexq, a__1, i__1, &c__2, (ftnlen)79);
#line 4992 ""
    *lnote += lacc;
#line 4993 ""
    noleva = *nolev;
#line 4994 ""
    if (*ivshft != 0) {
#line 4994 ""
	noleva = noleva + *ivshft - 32;
#line 4994 ""
    }
#line 4995 ""
    notefq_(noteq, &lnoten, &noleva, ncm, (ftnlen)8);
#line 4996 ""
    if (lnoten == 1) {
#line 4996 ""
	addblank_(noteq, &lnoten, (ftnlen)8);
#line 4996 ""
    }
/* Writing concatenation */
#line 4997 ""
    i__1[0] = *lnote, a__1[0] = notexq;
#line 4997 ""
    i__1[1] = lnoten, a__1[1] = noteq;
#line 4997 ""
    s_cat(notexq, a__1, i__1, &c__2, (ftnlen)79);
#line 4998 ""
    *lnote += lnoten;
#line 4999 ""
    if (*ihshft != 0) {

/*  Terminate horizontal shift */

/* Writing concatenation */
#line 5003 ""
	i__1[0] = *lnote, a__1[0] = notexq;
#line 5003 ""
	i__1[1] = 1, a__1[1] = "}";
#line 5003 ""
	s_cat(notexq, a__1, i__1, &c__2, (ftnlen)79);
#line 5004 ""
	++(*lnote);
#line 5005 ""
    }
#line 5006 ""
    return 0;
} /* doacc_ */

/* Subroutine */ int docrd_(integer *ivx, integer *ip, integer *nodu, integer 
	*ncm, integer *iv, real *tnow, char *soutq, integer *lsout, char *ulq,
	 integer *ibmcnt, integer *islur, integer *nvmx, integer *nv, logical 
	*beamon, integer *nolevm, integer *ihornb, integer *nornb, real *
	stemlen, logical *dotxtup, integer *nacc, integer *irest, ftnlen 
	soutq_len, ftnlen ulq_len)
{
    /* System generated locals */
    address a__1[2];
    integer i__1, i__2, i__3[2], i__4, i__5, i__6;
    real r__1;
    logical L__1;
    char ch__1[1];

    /* Builtin functions */
    integer i_nint(real *), lbit_shift(integer, integer), pow_ii(integer *, 
	    integer *);
    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen),
	     s_copy(char *, char *, ftnlen, ftnlen);
    integer s_wsle(cilist *), e_wsle(void), do_lio(integer *, integer *, char 
	    *, ftnlen);

    /* Local variables */
    extern /* Subroutine */ int addblank_(char *, integer *, ftnlen);
    extern integer igetbits_(integer *, integer *, integer *);
    static integer icrdatsav, icrdotsav, kv;
    extern integer log2_(integer *);
    static integer icrd;
    extern /* Character */ VOID chax_(char *, ftnlen, integer *);
    static integer indm, lout, lsym;
    static char outq[79];
    extern /* Subroutine */ int stop1_(void), doacc_(integer *, integer *, 
	    char *, integer *, integer *, integer *, integer *, logical *, 
	    ftnlen);
    extern integer ncmid_(integer *, integer *);
    static integer lnote, nolev;
    static char noteq[8];
    extern /* Subroutine */ int addstr_(char *, integer *, char *, integer *, 
	    ftnlen, ftnlen);
    static integer nactmp;
    static logical isleft;
    extern /* Subroutine */ int notefq_(char *, integer *, integer *, integer 
	    *, ftnlen);
    static real updotc, rtdotc;
    static integer nolevo;
    extern /* Subroutine */ int dotmov_(real *, real *, char *, integer *, 
	    integer *, ftnlen);
    static integer lnoten;
    extern /* Subroutine */ int putarp_(real *, integer *, integer *, integer 
	    *, integer *, char *, integer *, ftnlen);
    static char notexq[79], nosymq[7];
    extern /* Subroutine */ int putorn_(integer *, integer *, integer *, 
	    integer *, integer *, char *, integer *, integer *, integer *, 
	    integer *, integer *, integer *, integer *, real *, char *, 
	    integer *, integer *, integer *, logical *, logical *, ftnlen, 
	    ftnlen), addmidi_(integer *, integer *, integer *, integer *, 
	    real *, logical *, logical *);
    static logical isright;
    extern /* Subroutine */ int setbits_(integer *, integer *, integer *, 
	    integer *);

    /* Fortran I/O blocks */
    static cilist io___382 = { 0, 6, 0, 0, 0 };
    static cilist io___383 = { 0, 6, 0, 0, 0 };



/*  This subr. once produced notexq for entire chord.  10/18/97 altered to write */
/*    chord notes as we go.  10/22/97 find range of icrd first. */
/*    2/25/98 moved rangefinding to precrd so done before slurs, so now */
/*    on entry, icrd1, icrd2 define range of icrd for this chord. */

/*  Set counter (for this note) for chord notes present.  Set notmain=T. */
/*    Will test for notmain=.true. in addmidi to tell whether to save pitch. */

#line 5060 ""
    /* Parameter adjustments */
#line 5060 ""
    irest -= 25;
#line 5060 ""
    --nornb;
#line 5060 ""
    ihornb -= 25;
#line 5060 ""
    ulq -= 25;
#line 5060 ""

#line 5060 ""
    /* Function Body */
#line 5060 ""
    commidi_1.nmidcrd = 0;
#line 5061 ""
    commidi_1.notmain = TRUE_;
#line 5062 ""
    commidi_1.crdacc = FALSE_;
#line 5063 ""
    i__1 = comtrill_1.icrd2;
#line 5063 ""
    for (icrd = comtrill_1.icrd1; icrd <= i__1; ++icrd) {
#line 5064 ""
	lnote = 0;
#line 5065 ""
	nolev = igetbits_(&comtrill_1.icrdat[icrd - 1], &c__7, &c__12);

/*  3/8/03 save original pitch to use in midi, in case 2nds alter things. */

#line 5069 ""
	nolevo = nolev;

/*  Check for special situations with 2nds (see precrd). */

#line 5073 ""
	if (bit_test(*nacc,30) && nolev == *nolevm - 1) {

/* Upstem, 2nd with upper as main, interchange pitches, */
/*   rt-shift upper (now chord note). Lower (orig chord, now main) */
/*   if dotted, probably had shifted dot, dot parameters must be moved */
/*   from chord to main */

#line 5080 ""
	    nolev = *nolevm;
#line 5081 ""
	    if (bit_test(comtrill_1.icrdat[icrd - 1],26)) {

/*  Orig. chord note dot shift, must transfer to main. */

#line 5085 ""
		icrdotsav = comtrill_1.icrdot[icrd - 1];
#line 5086 ""
		icrdatsav = comtrill_1.icrdat[icrd - 1];
#line 5087 ""
		if (bit_test(irest[*ivx + *ip * 24],19)) {

/* Main note (upper) had a dot shift, must move it to chord */

#line 5091 ""
		    setbits_(&comtrill_1.icrdat[icrd - 1], &c__1, &c__26, &
			    c__1);
#line 5092 ""
		    r__1 = comcc_1.updot[*ivx + (comcc_1.ndotmv[*ivx - 1] + 1)
			     * 24 - 25] * 10;
#line 5092 ""
		    i__2 = i_nint(&r__1) + 64;
#line 5092 ""
		    setbits_(&comtrill_1.icrdot[icrd - 1], &c__7, &c__0, &
			    i__2);
#line 5094 ""
		    r__1 = comcc_1.rtdot[*ivx + (comcc_1.ndotmv[*ivx - 1] + 1)
			     * 24 - 25] * 10;
#line 5094 ""
		    i__2 = i_nint(&r__1) + 64;
#line 5094 ""
		    setbits_(&comtrill_1.icrdot[icrd - 1], &c__7, &c__7, &
			    i__2);

/* May need to worry about other chord params (accid shefts etc) later */

#line 5099 ""
		} else {
#line 5100 ""
		    comtrill_1.icrdat[icrd - 1] = bit_clear(comtrill_1.icrdat[
			    icrd - 1],26);
#line 5101 ""
		}

/* We are adding a main note dot shift, so push any later ones back */

#line 5106 ""
		if (! bit_test(irest[*ivx + *ip * 24],19)) {
#line 5107 ""
		    ++comcc_1.maxdotmv[*ivx - 1];
#line 5108 ""
		    i__2 = comcc_1.ndotmv[*ivx - 1] + 2;
#line 5108 ""
		    for (indm = comcc_1.maxdotmv[*ivx - 1]; indm >= i__2; 
			    --indm) {
#line 5109 ""
			comcc_1.updot[*ivx + indm * 24 - 25] = comcc_1.updot[*
				ivx + (indm - 1) * 24 - 25];
#line 5110 ""
			comcc_1.rtdot[*ivx + indm * 24 - 25] = comcc_1.rtdot[*
				ivx + (indm - 1) * 24 - 25];
#line 5111 ""
/* L1: */
#line 5111 ""
		    }
#line 5112 ""
		}
#line 5113 ""
		irest[*ivx + *ip * 24] = bit_set(irest[*ivx + *ip * 24],19);
#line 5114 ""
		comcc_1.updot[*ivx + (comcc_1.ndotmv[*ivx - 1] + 1) * 24 - 25]
			 = ((127 & icrdotsav) - 64) * .1f;
#line 5115 ""
		comcc_1.rtdot[*ivx + (comcc_1.ndotmv[*ivx - 1] + 1) * 24 - 25]
			 = ((127 & lbit_shift(icrdotsav, (ftnlen)-7)) - 64) * 
			.1f;
#line 5117 ""
	    }
#line 5118 ""
	} else if (bit_test(*nacc,31) && nolev == *nolevm + 1) {

/* Downstem, 2nd with lower as main, interchange pitches, */
/*   left-shift lower (now chord note). Lower (orig main, now chord) */
/*   probably had shifted dot, dot parameters must be moved from */
/*   main to chord */

#line 5125 ""
	    nolev = *nolevm;
#line 5126 ""
	    if (bit_test(irest[*ivx + *ip * 24],19)) {
#line 5127 ""
		icrdotsav = comtrill_1.icrdot[icrd - 1];
#line 5128 ""
		icrdatsav = comtrill_1.icrdat[icrd - 1];
#line 5129 ""
		comtrill_1.icrdat[icrd - 1] = bit_set(comtrill_1.icrdat[icrd 
			- 1],26);
/* bits in icrdot */
/*     0-6   10*abs(vertical dot shift in \internote) + 64 */
/*     7-13  10*abs(horizontal dot shift in \internote) + 64 */
/*  Assuming >0 for now! */
#line 5134 ""
		r__1 = comcc_1.updot[*ivx + (comcc_1.ndotmv[*ivx - 1] + 1) * 
			24 - 25] * 10;
#line 5134 ""
		i__2 = i_nint(&r__1) + 64;
#line 5134 ""
		setbits_(&comtrill_1.icrdot[icrd - 1], &c__7, &c__0, &i__2);
#line 5136 ""
		r__1 = comcc_1.rtdot[*ivx + (comcc_1.ndotmv[*ivx - 1] + 1) * 
			24 - 25] * 10;
#line 5136 ""
		i__2 = i_nint(&r__1) + 64;
#line 5136 ""
		setbits_(&comtrill_1.icrdot[icrd - 1], &c__7, &c__7, &i__2);

/*  Must also set dot shift for (now) main note (orig. chord note). */

#line 5141 ""
		if (bit_test(icrdatsav,26)) {
#line 5142 ""
		    comcc_1.updot[*ivx + (comcc_1.ndotmv[*ivx - 1] + 1) * 24 
			    - 25] = ((127 & icrdotsav) - 64) * .1f;
#line 5143 ""
		    comcc_1.rtdot[*ivx + (comcc_1.ndotmv[*ivx - 1] + 1) * 24 
			    - 25] = ((127 & lbit_shift(icrdotsav, (ftnlen)-7))
			     - 64) * .1f;
#line 5145 ""
		} else {

/* No dot move on original chord (now main) note, */

#line 5149 ""
		    comcc_1.updot[*ivx + (comcc_1.ndotmv[*ivx - 1] + 1) * 24 
			    - 25] = 0.f;
#line 5150 ""
		    comcc_1.rtdot[*ivx + (comcc_1.ndotmv[*ivx - 1] + 1) * 24 
			    - 25] = 0.f;
#line 5151 ""
		}
#line 5152 ""
	    }
#line 5153 ""
	}

/*  Lower dot for lower-voice notes?.  Conditions are: */
/*   1. Dotted time value */
/*   2. Lower voice of two */
/*   3. Note is on a line */
/*   4. Not a rest (cannot be a rest in a chord!) */
/* .  5. Flag (lowdot) is set to true */

#line 5162 ""
	if (comarp_1.lowdot && *nvmx == 2 && *ivx <= *nv) {
#line 5163 ""
	    i__2 = log2_(nodu);
#line 5163 ""
	    if (pow_ii(&c__2, &i__2) != *nodu && (nolev - *ncm) % 2 == 0) {
#line 5164 ""
		if (bit_test(comtrill_1.icrdat[icrd - 1],26)) {

/*  Note already in movdot list.  Drop by 2. */

#line 5168 ""
		    i__2 = igetbits_(&comtrill_1.icrdot[icrd - 1], &c__7, &
			    c__0) - 20;
#line 5168 ""
		    setbits_(&comtrill_1.icrdot[icrd - 1], &c__7, &c__0, &
			    i__2);
#line 5170 ""
		} else {

/*  Not in list so just move it right now */

#line 5174 ""
		    i__2 = igetbits_(islur, &c__1, &c__3);
#line 5174 ""
		    dotmov_(&c_b1019, &c_b1020, soutq, lsout, &i__2, (ftnlen)
			    80);
#line 5175 ""
		}
#line 5176 ""
	    }
#line 5177 ""
	}
#line 5178 ""
	if (bit_test(comtrill_1.icrdat[icrd - 1],26)) {

/*  Move the dot. Basic call for chord notes, not main note. */

#line 5182 ""
	    updotc = ((127 & comtrill_1.icrdot[icrd - 1]) - 64) * .1f;
#line 5183 ""
	    rtdotc = ((127 & lbit_shift(comtrill_1.icrdot[icrd - 1], (ftnlen)
		    -7)) - 64) * .1f;
#line 5184 ""
	    i__2 = igetbits_(islur, &c__1, &c__3);
#line 5184 ""
	    dotmov_(&updotc, &rtdotc, soutq, lsout, &i__2, (ftnlen)80);
#line 5185 ""
	}
#line 5186 ""
	isleft = bit_test(comtrill_1.icrdat[icrd - 1],23);
#line 5187 ""
	isright = bit_test(comtrill_1.icrdat[icrd - 1],24);

/*  Check for ornament in chord. */

#line 5191 ""
	if (comtrill_1.icrdorn[icrd - 1] > 0) {
#line 5192 ""
	    putorn_(&comtrill_1.icrdorn[icrd - 1], &nolev, nolevm, nodu, &
		    nornb[1], ulq + 25, ibmcnt, ivx, ncm, islur, nvmx, nv, &
		    ihornb[25], stemlen, outq, &lout, ip, &c__0, beamon, &
		    c_true, (ftnlen)1, (ftnlen)79);
#line 5195 ""
	    addstr_(outq, &lout, soutq, lsout, (ftnlen)79, (ftnlen)80);
#line 5196 ""
	}

/*  Chord-note symbol.  First check for breve */

#line 5200 ""
	if (*nodu == 128) {
/* Writing concatenation */
#line 5201 ""
	    chax_(ch__1, (ftnlen)1, &c__92);
#line 5201 ""
	    i__3[0] = 1, a__1[0] = ch__1;
#line 5201 ""
	    i__3[1] = 6, a__1[1] = "zbreve";
#line 5201 ""
	    s_cat(nosymq, a__1, i__3, &c__2, (ftnlen)7);
#line 5202 ""
	    lsym = 7;
#line 5203 ""
	} else {

/*  Not a breve chord.  Get first letters in chord-note symbol */

#line 5207 ""
	    if (isleft) {
/* Writing concatenation */
#line 5208 ""
		chax_(ch__1, (ftnlen)1, &c__92);
#line 5208 ""
		i__3[0] = 1, a__1[0] = ch__1;
#line 5208 ""
		i__3[1] = 1, a__1[1] = "l";
#line 5208 ""
		s_cat(nosymq, a__1, i__3, &c__2, (ftnlen)7);
#line 5209 ""
	    } else if (isright) {
/* Writing concatenation */
#line 5210 ""
		chax_(ch__1, (ftnlen)1, &c__92);
#line 5210 ""
		i__3[0] = 1, a__1[0] = ch__1;
#line 5210 ""
		i__3[1] = 1, a__1[1] = "r";
#line 5210 ""
		s_cat(nosymq, a__1, i__3, &c__2, (ftnlen)7);
#line 5211 ""
	    } else {
/* Writing concatenation */
#line 5212 ""
		chax_(ch__1, (ftnlen)1, &c__92);
#line 5212 ""
		i__3[0] = 1, a__1[0] = ch__1;
#line 5212 ""
		i__3[1] = 1, a__1[1] = "z";
#line 5212 ""
		s_cat(nosymq, a__1, i__3, &c__2, (ftnlen)7);
#line 5213 ""
	    }
#line 5214 ""
	    if (*nodu >= 64) {
/* Writing concatenation */
#line 5215 ""
		i__3[0] = 2, a__1[0] = nosymq;
#line 5215 ""
		i__3[1] = 1, a__1[1] = "w";
#line 5215 ""
		s_cat(nosymq, a__1, i__3, &c__2, (ftnlen)7);
#line 5216 ""
	    } else if (*nodu >= 32) {
/* Writing concatenation */
#line 5217 ""
		i__3[0] = 2, a__1[0] = nosymq;
#line 5217 ""
		i__3[1] = 1, a__1[1] = "h";
#line 5217 ""
		s_cat(nosymq, a__1, i__3, &c__2, (ftnlen)7);
#line 5218 ""
	    } else {
/* Writing concatenation */
#line 5219 ""
		i__3[0] = 2, a__1[0] = nosymq;
#line 5219 ""
		i__3[1] = 1, a__1[1] = "q";
#line 5219 ""
		s_cat(nosymq, a__1, i__3, &c__2, (ftnlen)7);
#line 5220 ""
	    }
#line 5221 ""
	    i__2 = log2_(nodu);
#line 5221 ""
	    if (pow_ii(&c__2, &i__2) == *nodu && ! (*dotxtup)) {
#line 5222 ""
		lsym = 3;
#line 5223 ""
	    } else if (! bit_test(*islur,3) || *dotxtup) {

/*  Single dot */

/* Writing concatenation */
#line 5227 ""
		i__3[0] = 3, a__1[0] = nosymq;
#line 5227 ""
		i__3[1] = 1, a__1[1] = "p";
#line 5227 ""
		s_cat(nosymq, a__1, i__3, &c__2, (ftnlen)7);
#line 5228 ""
		lsym = 4;
#line 5229 ""
	    } else {

/*  Double dot */

/* Writing concatenation */
#line 5233 ""
		i__3[0] = 3, a__1[0] = nosymq;
#line 5233 ""
		i__3[1] = 2, a__1[1] = "pp";
#line 5233 ""
		s_cat(nosymq, a__1, i__3, &c__2, (ftnlen)7);
#line 5234 ""
		lsym = 5;
#line 5235 ""
	    }
#line 5236 ""
	}
#line 5237 ""
	if (bit_test(comtrill_1.icrdat[icrd - 1],19) && ! bit_test(
		comtrill_1.icrdat[icrd - 1],27)) {

/*  Accidental and not MIDI-only.  Build up bits 0-3 of nacc */

#line 5241 ""
	    nactmp = igetbits_(&comtrill_1.icrdat[icrd - 1], &c__3, &c__20);

/*  Kluge for bigness.  Only means 'As' has not been issued */

#line 5245 ""
	    if (spfacs_1.bacfac != 1e6f) {
#line 5245 ""
		nactmp += 8;
#line 5245 ""
	    }
#line 5246 ""
	    i__2 = igetbits_(&comtrill_1.icrdot[icrd - 1], &c__7, &c__20) - 
		    107;
#line 5246 ""
	    i__4 = igetbits_(&comtrill_1.icrdot[icrd - 1], &c__6, &c__14);
#line 5246 ""
	    i__5 = igetbits_(&comtrill_1.icrdat[icrd - 1], &c__7, &c__12);
#line 5246 ""
	    i__6 = ncmid_(iv, ip);
#line 5246 ""
	    L__1 = bit_test(comtrill_1.icrdat[icrd - 1],31);
#line 5246 ""
	    doacc_(&i__2, &i__4, notexq, &lnote, &nactmp, &i__5, &i__6, &L__1,
		     (ftnlen)79);
/*     *        notexq,lnote,nactmp,nolev,ncmid(iv,ip)) */
/*  Get original nolev, not altered to deal with 2nds */
/* Writing concatenation */
#line 5252 ""
	    i__3[0] = lnote, a__1[0] = notexq;
#line 5252 ""
	    i__3[1] = 7, a__1[1] = nosymq;
#line 5252 ""
	    s_cat(notexq, a__1, i__3, &c__2, (ftnlen)79);
#line 5253 ""
	    commidi_1.crdacc = TRUE_;
#line 5254 ""
	} else {
#line 5255 ""
	    s_copy(notexq, nosymq, (ftnlen)79, (ftnlen)7);
#line 5256 ""
	}
#line 5257 ""
	lnote += lsym;

/*  Get note name (again if accid, due to possible octave jump) */

#line 5261 ""
	notefq_(noteq, &lnoten, &nolev, ncm, (ftnlen)8);
#line 5262 ""
	if (lnoten == 1) {
#line 5262 ""
	    addblank_(noteq, &lnoten, (ftnlen)8);
#line 5262 ""
	}

/*  Put in note name */

/* Writing concatenation */
#line 5266 ""
	i__3[0] = lnote, a__1[0] = notexq;
#line 5266 ""
	i__3[1] = 8, a__1[1] = noteq;
#line 5266 ""
	s_cat(notexq, a__1, i__3, &c__2, (ftnlen)79);
#line 5267 ""
	lnote += lnoten;
#line 5268 ""
	if (bit_test(comtrill_1.icrdat[icrd - 1],25)) {

/*  Arpeggio signal */

#line 5272 ""
	    putarp_(tnow, ivx, ip, &nolev, ncm, soutq, lsout, (ftnlen)80);
#line 5273 ""
	}
#line 5274 ""
	addstr_(notexq, &lnote, soutq, lsout, (ftnlen)79, (ftnlen)80);
#line 5275 ""
	if (commidi_1.ismidi) {

/*  Here is where we collect MIDI pitch info for the chord note.  By checking */
/*    notmain, addmidi(...) knows to just compute the */
/*    pitch number and store it in mcpitch(nmidcrd).  Then on call to addmidi() */
/*    for MAIN note, will put in note codes for all chord notes + main note. */

#line 5282 ""
	    kv = 1;
#line 5283 ""
	    if (*ivx > *iv) {
#line 5283 ""
		kv = 2;
#line 5283 ""
	    }
#line 5284 ""
	    ++commidi_1.nmidcrd;
#line 5285 ""
	    if (commidi_1.nmidcrd > 20) {
#line 5286 ""
		s_wsle(&io___382);
#line 5286 ""
		e_wsle();
#line 5287 ""
		s_wsle(&io___383);
#line 5287 ""
		do_lio(&c__9, &c__1, "21 chord notes is too many for midi pr"\
			"ocessor", (ftnlen)45);
#line 5287 ""
		e_wsle();
#line 5288 ""
		stop1_();
#line 5289 ""
	    }

/*  Use original saved pitch level, unaltered by 2nds logic. */

#line 5293 ""
	    i__2 = nolevo + commvel_1.miditran[cominsttrans_1.instno[*iv - 1] 
		    - 1];
#line 5293 ""
	    i__4 = igetbits_(&comtrill_1.icrdat[icrd - 1], &c__3, &c__20);
#line 5293 ""
	    addmidi_(&commidi_1.midchan[*iv + kv * 24 - 25], &i__2, &i__4, &
		    commidisig_1.midisig, &c_b1065, &c_false, &c_false);
#line 5296 ""
	}
#line 5297 ""
/* L5: */
#line 5297 ""
    }
#line 5298 ""
    commidi_1.notmain = FALSE_;
#line 5299 ""
    return 0;
} /* docrd_ */

/* Subroutine */ int dodyn_(integer *ivx, integer *ip, integer *nolev, 
	integer *ncm, integer *ipl, integer *islur, integer *irest, integer *
	nvmx, integer *nv, logical *beamon, integer *ihornb, integer *nornb, 
	char *ulq, integer *ibmcnt, logical *nostem, char *soutq, integer *
	lsout, ftnlen ulq_len, ftnlen soutq_len)
{
    /* Initialized data */

    static char dyntablq[48] = "ppppppp pp  p   mp  mf  f   fp  sfz ff  fff "
	    "ffff";

    /* System generated locals */
    address a__1[2], a__2[4], a__3[3];
    integer i__1, i__2, i__3[2], i__4[4], i__5, i__6[3];
    char ch__1[1], ch__2[6], ch__3[81], ch__4[53];
    icilist ici__1;

    /* Builtin functions */
    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen),
	     s_copy(char *, char *, ftnlen, ftnlen);
    integer s_wsfi(icilist *), do_fio(integer *, char *, ftnlen), e_wsfi(void)
	    , s_wsfe(cilist *), e_wsfe(void);

    /* Local variables */
    extern /* Subroutine */ int backfill_(integer *, char *, integer *, char *
	    , integer *, ftnlen, ftnlen);
    static integer jtxtdyn1;
    extern integer igetbits_(integer *, integer *, integer *);
    static integer lpretweak, id, idh;
    static real hoff;
    extern /* Character */ VOID chax_(char *, ftnlen, integer *);
    static integer idno, lbot, idyn, jdyn;
    extern /* Character */ VOID udqq_(char *, ftnlen, integer *, integer *, 
	    integer *, integer *, integer *, integer *);
    static integer lbot1;
    extern integer lfmt1_(real *);
    extern /* Subroutine */ int stop1_(void);
    static integer idynd, lform, idynn[10], lnote, ltemp;
    static char tempq[48];
    static integer ivxip;
    static char numpq[5];
    static integer idynd2;
    static real hoffsd;
    extern /* Subroutine */ int addstr_(char *, integer *, char *, integer *, 
	    ftnlen, ftnlen);
    static integer iptent;
    extern integer lenstr_(char *, integer *, ftnlen);
    extern /* Subroutine */ int printl_(char *, ftnlen);
    static integer numdyn;
    static logical upstem;
    static char notexq[79];
    static integer lnumpq, icntdyn;
    extern /* Subroutine */ int setbits_(integer *, integer *, integer *, 
	    integer *);
    static integer ivxtent;
    static char dynstrq[4];
    static integer jtxtdyn, ltxtdyn;

    /* Fortran I/O blocks */
    static icilist io___405 = { 0, numpq+1, 0, "(i2)", 2, 1 };
    static icilist io___407 = { 0, numpq+1, 0, "(i2)", 2, 1 };
    static icilist io___408 = { 0, numpq+1, 0, "(i3)", 3, 1 };
    static icilist io___415 = { 0, numpq+1, 0, "(i2)", 2, 1 };
    static icilist io___416 = { 0, numpq+1, 0, "(i2)", 2, 1 };
    static icilist io___417 = { 0, numpq+1, 0, "(i3)", 3, 1 };
    static cilist io___420 = { 0, 11, 0, "(a)", 0 };



/*  Inputs are array *elements* except ihornb,nornb,ulq */

#line 5327 ""
    /* Parameter adjustments */
#line 5327 ""
    ulq -= 25;
#line 5327 ""
    --nornb;
#line 5327 ""
    ihornb -= 25;
#line 5327 ""

#line 5327 ""
    /* Function Body */
#line 5328 ""
    numdyn = 0;

/*  Find dynamics for (ivx,ip) in list.  May be as many as 4.  Store idyn values */
/*      in idynn(1...4) */

#line 5333 ""
    i__1 = comdyn_1.ndyn;
#line 5333 ""
    for (idyn = 1; idyn <= i__1; ++idyn) {
#line 5334 ""
	ivxtent = (comdyn_1.idyndat[idyn - 1] & 15) + (igetbits_(&
		comdyn_1.idynda2[idyn - 1], &c__1, &c__10) << 4);
#line 5336 ""
	if (ivxtent == *ivx) {
#line 5337 ""
	    iptent = igetbits_(&comdyn_1.idyndat[idyn - 1], &c__8, &c__4);
#line 5338 ""
	    if (iptent == *ip) {
#line 5339 ""
		++numdyn;
#line 5340 ""
		idynn[numdyn - 1] = idyn;
#line 5341 ""
	    } else if (iptent > *ip) {

/*  I don't think there are any more possible for this ivx,ip, so exit loop */

#line 5345 ""
		goto L2;
#line 5346 ""
	    }
#line 5347 ""
	}
#line 5348 ""
/* L1: */
#line 5348 ""
    }
#line 5349 ""
L2:

/*  At this point there is a list of idyn's in idynn(1...numdyn) */
/*  Compute level, and stem-dir'n-based horizontal tweaks */

#line 5354 ""
    hoffsd = 0.f;

/*  Set upstem to false as default */

#line 5358 ""
    upstem = FALSE_;
#line 5359 ""
    if (bit_test(*irest,0)) {

/*  It's a rest.  Assume it doesn't go below the staff */

#line 5363 ""
	lbot = *ncm - 4;
#line 5364 ""
    } else if (! (*beamon)) {
#line 5365 ""
	udqq_(ch__1, (ftnlen)1, nolev, ncm, islur, nvmx, ivx, nv);
#line 5365 ""
	if (*(unsigned char *)&ch__1[0] == 'u' || *nostem) {
#line 5366 ""
	    upstem = TRUE_;
#line 5367 ""
	    if (! bit_test(*ipl,10)) {
/* Computing MIN */
#line 5368 ""
		i__1 = *nolev - 1, i__2 = *ncm - 4;
#line 5368 ""
		lbot = min(i__1,i__2);
#line 5369 ""
	    } else {
/* Computing MIN */
#line 5370 ""
		i__1 = comtrill_1.minlev - 1, i__2 = *ncm - 4;
#line 5370 ""
		lbot = min(i__1,i__2);
#line 5371 ""
	    }
#line 5372 ""
	} else {
#line 5373 ""
	    hoffsd = -.5f;
#line 5374 ""
	    if (! bit_test(*ipl,10)) {
/* Computing MIN */
#line 5375 ""
		i__1 = *nolev - 7, i__2 = *ncm - 4;
#line 5375 ""
		lbot = min(i__1,i__2);
#line 5376 ""
	    } else {
/* Computing MIN */
#line 5377 ""
		i__1 = comtrill_1.minlev - 7, i__2 = *ncm - 4;
#line 5377 ""
		lbot = min(i__1,i__2);
#line 5378 ""
	    }
#line 5379 ""
	}
#line 5380 ""
    } else {
#line 5381 ""
	if (*(unsigned char *)&ulq[*ivx + *ibmcnt * 24] == 'u') {
#line 5382 ""
	    upstem = TRUE_;
#line 5383 ""
	    if (! bit_test(*ipl,10)) {
/* Computing MIN */
#line 5384 ""
		i__1 = *nolev - 1, i__2 = *ncm - 4;
#line 5384 ""
		lbot = min(i__1,i__2);
#line 5385 ""
	    } else {
/* Computing MIN */
#line 5386 ""
		i__1 = comtrill_1.minlev - 1, i__2 = *ncm - 4;
#line 5386 ""
		lbot = min(i__1,i__2);
#line 5387 ""
	    }
#line 5388 ""
	} else {
#line 5389 ""
	    hoffsd = -.5f;
#line 5390 ""
	    if (nornb[*ivx] == 0) {
#line 5391 ""
		lbot = 1;
#line 5392 ""
	    } else {
#line 5393 ""
		lbot = ihornb[*ivx + nornb[*ivx] * 24] + 1;
#line 5394 ""
	    }
#line 5395 ""
	    if (lbot == 1) {

/* Kluge for non-beamed, down xtup, for which ihorb was never set. */
/* Assumes stem is shortened. */

#line 5400 ""
		lbot = *nolev - 5;
#line 5401 ""
	    }
#line 5402 ""
	    ++nornb[*ivx];
#line 5403 ""
	}
#line 5404 ""
    }
#line 5405 ""
    lbot += -5;
#line 5406 ""
    jtxtdyn1 = 1;

/*  Now ready to loop over current dyn's */

#line 5410 ""
    i__1 = numdyn;
#line 5410 ""
    for (icntdyn = 1; icntdyn <= i__1; ++icntdyn) {
#line 5411 ""
	idynd = comdyn_1.idyndat[idynn[icntdyn - 1] - 1];
#line 5412 ""
	idynd2 = comdyn_1.idynda2[idynn[icntdyn - 1] - 1];
#line 5413 ""
	idno = igetbits_(&idynd, &c__4, &c__12);
/*        ivx = iand(15,idynd) */
#line 5415 ""
	*ivx = (15 & idynd) + (igetbits_(&idynd2, &c__1, &c__10) << 4);

/*  Build the command into notex in stages. Insert name & rq'd args in order: */

/*    Command name */
/* 	 hpstrt, hpcend, hpdend, pmxdyn */
/*    ivx */
/*        X       X       X */
/*    level */
/*                X       X       X */
/*    hoff */
/*        X       X       X       X */
/*    d-mark */
/*                                X */

#line 5430 ""
	if (idno == 0) {

/*  Text-dynamic */

/* Writing concatenation */
#line 5434 ""
	    chax_(ch__1, (ftnlen)1, &c__92);
#line 5434 ""
	    i__3[0] = 1, a__1[0] = ch__1;
#line 5434 ""
	    i__3[1] = 6, a__1[1] = "txtdyn";
#line 5434 ""
	    s_cat(notexq, a__1, i__3, &c__2, (ftnlen)79);
#line 5435 ""
	    lnote = 7;
#line 5436 ""
	} else if (idno <= 12) {

/*  Letter-group */

/* Writing concatenation */
#line 5440 ""
	    chax_(ch__1, (ftnlen)1, &c__92);
#line 5440 ""
	    i__3[0] = 1, a__1[0] = ch__1;
#line 5440 ""
	    i__3[1] = 6, a__1[1] = "pmxdyn";
#line 5440 ""
	    s_cat(notexq, a__1, i__3, &c__2, (ftnlen)79);
#line 5441 ""
	    lnote = 7;
#line 5442 ""
	} else if (comslur_1.fontslur) {
#line 5443 ""
	    lnote = 7;
#line 5444 ""
	    if (idno == 13) {

/*  Start a font-based hairpin */

/* Writing concatenation */
#line 5448 ""
		chax_(ch__1, (ftnlen)1, &c__92);
#line 5448 ""
		i__3[0] = 1, a__1[0] = ch__1;
#line 5448 ""
		i__3[1] = 6, a__1[1] = "hpstrt";
#line 5448 ""
		s_cat(notexq, a__1, i__3, &c__2, (ftnlen)79);
#line 5449 ""
	    } else if (idno == 14) {

/*  End crescendo */

/* Writing concatenation */
#line 5453 ""
		chax_(ch__1, (ftnlen)1, &c__92);
#line 5453 ""
		i__3[0] = 1, a__1[0] = ch__1;
#line 5453 ""
		i__3[1] = 6, a__1[1] = "hpcend";
#line 5453 ""
		s_cat(notexq, a__1, i__3, &c__2, (ftnlen)79);
#line 5454 ""
	    } else {

/*  End decrescendo */

/* Writing concatenation */
#line 5458 ""
		chax_(ch__1, (ftnlen)1, &c__92);
#line 5458 ""
		i__3[0] = 1, a__1[0] = ch__1;
#line 5458 ""
		i__3[1] = 6, a__1[1] = "hpdend";
#line 5458 ""
		s_cat(notexq, a__1, i__3, &c__2, (ftnlen)79);
#line 5459 ""
	    }

/*  Put in voice number as ID for font-based hairpin */

#line 5463 ""
	    if (*ivx <= 9) {
/* Writing concatenation */
#line 5464 ""
		i__3[0] = lnote, a__1[0] = notexq;
#line 5464 ""
		*(unsigned char *)&ch__1[0] = *ivx + 48;
#line 5464 ""
		i__3[1] = 1, a__1[1] = ch__1;
#line 5464 ""
		s_cat(notexq, a__1, i__3, &c__2, (ftnlen)79);
#line 5465 ""
		++lnote;
#line 5466 ""
	    } else if (*ivx <= 19) {
/* Writing concatenation */
#line 5467 ""
		i__4[0] = lnote, a__2[0] = notexq;
#line 5467 ""
		i__4[1] = 2, a__2[1] = "{1";
#line 5467 ""
		*(unsigned char *)&ch__1[0] = *ivx + 38;
#line 5467 ""
		i__4[2] = 1, a__2[2] = ch__1;
#line 5467 ""
		i__4[3] = 1, a__2[3] = "}";
#line 5467 ""
		s_cat(notexq, a__2, i__4, &c__4, (ftnlen)79);
#line 5468 ""
		lnote += 4;
#line 5469 ""
	    } else {
/* Writing concatenation */
#line 5470 ""
		i__4[0] = lnote, a__2[0] = notexq;
#line 5470 ""
		i__4[1] = 2, a__2[1] = "{2";
#line 5470 ""
		*(unsigned char *)&ch__1[0] = *ivx + 28;
#line 5470 ""
		i__4[2] = 1, a__2[2] = ch__1;
#line 5470 ""
		i__4[3] = 1, a__2[3] = "}";
#line 5470 ""
		s_cat(notexq, a__2, i__4, &c__4, (ftnlen)79);
#line 5471 ""
		lnote += 4;
#line 5472 ""
	    }
#line 5473 ""
	} else {

/*  Postscript hairpins */

#line 5477 ""
	    lnote = 7;
#line 5478 ""
	    if (idno == 13) {
/* Writing concatenation */
#line 5479 ""
		chax_(ch__1, (ftnlen)1, &c__92);
#line 5479 ""
		i__3[0] = 1, a__1[0] = ch__1;
#line 5479 ""
		i__3[1] = 6, a__1[1] = "Icresc";
#line 5479 ""
		s_cat(notexq, a__1, i__3, &c__2, (ftnlen)79);
#line 5480 ""
	    } else if (idno == 14) {
/* Writing concatenation */
#line 5481 ""
		chax_(ch__1, (ftnlen)1, &c__92);
#line 5481 ""
		i__3[0] = 1, a__1[0] = ch__1;
#line 5481 ""
		i__3[1] = 8, a__1[1] = "Idecresc";
#line 5481 ""
		s_cat(notexq, a__1, i__3, &c__2, (ftnlen)79);
#line 5482 ""
		lnote = 9;
#line 5483 ""
	    } else {
/* Writing concatenation */
#line 5484 ""
		chax_(ch__1, (ftnlen)1, &c__92);
#line 5484 ""
		i__3[0] = 1, a__1[0] = ch__1;
#line 5484 ""
		i__3[1] = 6, a__1[1] = "Tcresc";
#line 5484 ""
		s_cat(notexq, a__1, i__3, &c__2, (ftnlen)79);
#line 5485 ""
	    }
#line 5486 ""
	    if (idno <= 14) {

/*  Get and record ID no for start of ps hairpin */
/*  Find first unused ID */

#line 5491 ""
		for (idh = 1; idh <= 24; ++idh) {
#line 5492 ""
		    if (! bit_test(comhair_1.ihairuse,idh)) {
#line 5492 ""
			goto L9;
#line 5492 ""
		    }
#line 5493 ""
/* L8: */
#line 5493 ""
		}
#line 5494 ""
		printl_("Bad place in putdyn, call Dr. Don", (ftnlen)33);
#line 5495 ""
		stop1_();
#line 5496 ""
L9:
#line 5497 ""
		comhair_1.ihairuse = bit_set(comhair_1.ihairuse,idh);
#line 5498 ""
		comhair_1.idhair[*ivx - 1] = idh;
#line 5499 ""
	    } else {

/*  Unrecord ID no for end of ps hairpin */

#line 5503 ""
		setbits_(&comhair_1.ihairuse, &c__1, &comhair_1.idhair[*ivx - 
			1], &c__0);
#line 5504 ""
	    }

/*  Write ID # for start or end of ps hairpin */

#line 5508 ""
	    idh = comhair_1.idhair[*ivx - 1];
#line 5509 ""
	    if (idh <= 9) {
/* Writing concatenation */
#line 5510 ""
		i__3[0] = lnote, a__1[0] = notexq;
#line 5510 ""
		*(unsigned char *)&ch__1[0] = idh + 48;
#line 5510 ""
		i__3[1] = 1, a__1[1] = ch__1;
#line 5510 ""
		s_cat(notexq, a__1, i__3, &c__2, (ftnlen)79);
#line 5511 ""
		++lnote;
#line 5512 ""
	    } else if (idh <= 19) {
/* Writing concatenation */
#line 5513 ""
		i__4[0] = lnote, a__2[0] = notexq;
#line 5513 ""
		i__4[1] = 2, a__2[1] = "{1";
#line 5513 ""
		*(unsigned char *)&ch__1[0] = idh + 38;
#line 5513 ""
		i__4[2] = 1, a__2[2] = ch__1;
#line 5513 ""
		i__4[3] = 1, a__2[3] = "}";
#line 5513 ""
		s_cat(notexq, a__2, i__4, &c__4, (ftnlen)79);
#line 5514 ""
		lnote += 4;
#line 5515 ""
	    } else {
/* Writing concatenation */
#line 5516 ""
		i__4[0] = lnote, a__2[0] = notexq;
#line 5516 ""
		i__4[1] = 2, a__2[1] = "{2";
#line 5516 ""
		*(unsigned char *)&ch__1[0] = idh + 28;
#line 5516 ""
		i__4[2] = 1, a__2[2] = ch__1;
#line 5516 ""
		i__4[3] = 1, a__2[3] = "}";
#line 5516 ""
		s_cat(notexq, a__2, i__4, &c__4, (ftnlen)79);
#line 5517 ""
		lnote += 4;
#line 5518 ""
	    }
#line 5519 ""
	}

/*  Begin setting level */

#line 5523 ""
	lbot1 = lbot;
#line 5524 ""
	if (idno > 0 && idno <= 5) {

/*  All letters are short so raise a bit. */

#line 5528 ""
	    ++lbot1;
#line 5529 ""
	} else if (idno >= 13) {
#line 5530 ""
	    lbot1 += 2;
#line 5531 ""
	}

/*  Convert so reference is bottom line */

#line 5535 ""
	lbot1 = lbot1 - *ncm + 4;
#line 5536 ""
	if (comslur_1.fontslur && idno == 13 || ! comslur_1.fontslur && (idno 
		== 13 || idno == 14)) {

/*  Hairpin start.  Save level and user-tweak before applying user tweak. */

#line 5541 ""
	    comdyn_1.levdsav[*ivx - 1] = lbot1;
#line 5542 ""
	    comdyn_1.levhssav[*ivx - 1] = 0;
#line 5543 ""
	    if (bit_test(idynd,16)) {
#line 5543 ""
		comdyn_1.levhssav[*ivx - 1] = igetbits_(&idynd, &c__7, &c__17)
			 - 64;
#line 5543 ""
	    }
#line 5544 ""
	} else if (comslur_1.fontslur && idno >= 14 || idno == 15) {

/*  Hairpin end; Compare level with saved start level before user-tweaks */

/* Computing MIN */
#line 5548 ""
	    i__2 = lbot1, i__5 = comdyn_1.levdsav[*ivx - 1];
#line 5548 ""
	    lbot1 = min(i__2,i__5);

/*  Save pre-tweak level */

#line 5552 ""
	    lpretweak = lbot1;
#line 5553 ""
	}

/*  Check for user-defined vertical tweak */

#line 5557 ""
	if (bit_test(idynd,16)) {
#line 5557 ""
	    lbot1 = lbot1 - 64 + igetbits_(&idynd, &c__7, &c__17);
#line 5557 ""
	}

/*  Now horizontal stuff */

#line 5561 ""
	hoff = hoffsd;

/*  Some special horizontal tweaks */

#line 5565 ""
	if (upstem && idno > 0 && (idno <= 4 || idno == 8 || idno == 9)) {
#line 5565 ""
	    hoff += .4f;
#line 5565 ""
	}

/*  User-defined tweaks */

#line 5570 ""
	if (bit_test(idynd2,0)) {
#line 5570 ""
	    hoff += (igetbits_(&idynd2, &c__9, &c__1) - 256) * .1f;
#line 5570 ""
	}
#line 5572 ""
	if (numdyn > 1) {

/*  Horizontal-interaction-based tweaks. */

/*  Cases: */
/*  numdyn  type1   type2    type3    data used */
/*     2    wrd-grp hrpnstrt -        ivowg(1...12),hoh1(1...12) */
/*     2	 hrpnend wrd-grp  -		   ivowg,hoh2 */
/*     2    hrpnend hrpnstrt -		   hoh2h1(1...2) */
/*     3    hrpnend wrd-grp  hrpnstrt ivowg,hoh2,hoh1 */

#line 5583 ""
	    if (idno > 0 && idno <= 12) {

/*  Word-group, may need vertical tweak to line up. */

#line 5587 ""
		lbot1 += comdyn_1.ivowg[idno - 1];

/*  Protecting against hp start-stop on same note */

#line 5591 ""
	    } else if ((comslur_1.fontslur && idno >= 14 || idno == 15) && 
		    icntdyn < numdyn) {

/*  Hairpin ending, check next type */

#line 5596 ""
		if (comslur_1.fontslur && igetbits_(&comdyn_1.idyndat[idynn[
			icntdyn] - 1], &c__4, &c__12) == 13 || ! 
			comslur_1.fontslur && (igetbits_(&comdyn_1.idyndat[
			idynn[icntdyn] - 1], &c__4, &c__12) == 13 || 
			igetbits_(&comdyn_1.idyndat[idynn[icntdyn] - 1], &
			c__4, &c__12) == 14)) {

/*  Hairpin end then hairpin start, no words, (remember dealing with end now) */

#line 5606 ""
		    hoff += comdyn_1.hoh2h1[0];
#line 5607 ""
		} else {

/*  Hairpin end then word-group, need idno for w-g to set hp offset */

#line 5611 ""
		    hoff += comdyn_1.hoh2[igetbits_(&comdyn_1.idyndat[idynn[
			    icntdyn] - 1], &c__4, &c__12) - 1];
#line 5613 ""
		}

/*  Protecting against hp start-stop on same note */

#line 5617 ""
	    } else if (icntdyn > 1 && idno > 0 && (comslur_1.fontslur && idno 
		    < 14 || ! comslur_1.fontslur && idno < 15)) {

/*  Hairpin start, check prior type */

#line 5623 ""
		if (comslur_1.fontslur && igetbits_(&comdyn_1.idyndat[idynn[
			icntdyn - 2] - 1], &c__4, &c__12) >= 14 || ! 
			comslur_1.fontslur && igetbits_(&comdyn_1.idyndat[
			idynn[icntdyn - 2] - 1], &c__4, &c__12) == 15) {

/*  Hairpin end then hairpin start, (remember dealing with start now) */

#line 5632 ""
		    hoff += comdyn_1.hoh2h1[1];
#line 5633 ""
		} else {

/*  Hairpin start after word-group, need idno for w-g to set hp offset */

#line 5637 ""
		    hoff += comdyn_1.hoh1[igetbits_(&comdyn_1.idyndat[idynn[
			    icntdyn - 2] - 1], &c__4, &c__12) - 1];
#line 5639 ""
		}
#line 5640 ""
	    }
#line 5641 ""
	}

/*  End of if-block for 2- or 3-way interactions. */

#line 5645 ""
	if (! comslur_1.fontslur && idno >= 13) {
#line 5645 ""
	    hoff = (hoff + .5f) * 6.f / 2.5f;
#line 5645 ""
	}

/*  Slur font and hairpin. Add hoff, and change from \interneote to \qn@width */


/*  Position corrections all done now.  Put in the level. */

#line 5653 ""
	if (comslur_1.fontslur && idno == 13 || ! comslur_1.fontslur && (idno 
		== 13 || idno == 14)) {

/*  Hairpin start. */

#line 5658 ""
	    if (! comslur_1.fontslur) {

/*  Postscript hairpin start...inset placeholder for start level. */
/* Writing concatenation */
#line 5662 ""
		i__3[0] = lnote, a__1[0] = notexq;
#line 5662 ""
		i__3[1] = 5, a__1[1] = "{   }";
#line 5662 ""
		s_cat(notexq, a__1, i__3, &c__2, (ftnlen)79);
#line 5663 ""
		lnote += 5;
#line 5664 ""
	    }
#line 5665 ""
	} else {

/*  Insert actual level in all cases except hairpin start */
/*  Create string with level in it */

#line 5670 ""
	    if (lbot1 > 9) {
#line 5671 ""
		s_copy(numpq, "{", (ftnlen)5, (ftnlen)1);
#line 5672 ""
		s_wsfi(&io___405);
#line 5672 ""
		do_fio(&c__1, (char *)&lbot1, (ftnlen)sizeof(integer));
#line 5672 ""
		e_wsfi();
/* Writing concatenation */
#line 5673 ""
		i__3[0] = 3, a__1[0] = numpq;
#line 5673 ""
		i__3[1] = 1, a__1[1] = "}";
#line 5673 ""
		s_cat(numpq, a__1, i__3, &c__2, (ftnlen)5);
#line 5674 ""
		lnumpq = 4;
#line 5675 ""
	    } else if (lbot1 > -1) {
#line 5676 ""
		*(unsigned char *)&ch__1[0] = lbot1 + 48;
#line 5676 ""
		s_copy(numpq, ch__1, (ftnlen)5, (ftnlen)1);
#line 5677 ""
		lnumpq = 1;
#line 5678 ""
	    } else if (lbot1 > -10) {
#line 5679 ""
		s_copy(numpq, "{", (ftnlen)5, (ftnlen)1);
#line 5680 ""
		s_wsfi(&io___407);
#line 5680 ""
		do_fio(&c__1, (char *)&lbot1, (ftnlen)sizeof(integer));
#line 5680 ""
		e_wsfi();
/* Writing concatenation */
#line 5681 ""
		i__3[0] = 3, a__1[0] = numpq;
#line 5681 ""
		i__3[1] = 1, a__1[1] = "}";
#line 5681 ""
		s_cat(numpq, a__1, i__3, &c__2, (ftnlen)5);
#line 5682 ""
		lnumpq = 4;
#line 5683 ""
	    } else {
#line 5684 ""
		s_copy(numpq, "{", (ftnlen)5, (ftnlen)1);
#line 5685 ""
		s_wsfi(&io___408);
#line 5685 ""
		do_fio(&c__1, (char *)&lbot1, (ftnlen)sizeof(integer));
#line 5685 ""
		e_wsfi();
/* Writing concatenation */
#line 5686 ""
		i__3[0] = 4, a__1[0] = numpq;
#line 5686 ""
		i__3[1] = 1, a__1[1] = "}";
#line 5686 ""
		s_cat(numpq, a__1, i__3, &c__2, (ftnlen)5);
#line 5687 ""
		lnumpq = 5;
#line 5688 ""
	    }

/*  Level has now been computed and stored in numpq */
/*  Append the level */

/* Writing concatenation */
#line 5693 ""
	    i__3[0] = lnote, a__1[0] = notexq;
#line 5693 ""
	    i__3[1] = lnumpq, a__1[1] = numpq;
#line 5693 ""
	    s_cat(notexq, a__1, i__3, &c__2, (ftnlen)79);
#line 5694 ""
	    lnote += lnumpq;
#line 5695 ""
	}
#line 5696 ""
	if (dabs(hoff) < .001f) {

/*  No horiz offset */

/* Writing concatenation */
#line 5700 ""
	    i__3[0] = lnote, a__1[0] = notexq;
#line 5700 ""
	    i__3[1] = 1, a__1[1] = "0";
#line 5700 ""
	    s_cat(notexq, a__1, i__3, &c__2, (ftnlen)79);
#line 5701 ""
	    ++lnote;
#line 5702 ""
	} else {

/*  Horizontal tweak */

#line 5706 ""
	    lform = lfmt1_(&hoff);
/* Writing concatenation */
#line 5707 ""
	    i__3[0] = lnote, a__1[0] = notexq;
#line 5707 ""
	    i__3[1] = 1, a__1[1] = "{";
#line 5707 ""
	    s_cat(notexq, a__1, i__3, &c__2, (ftnlen)79);
#line 5708 ""
	    ++lnote;
#line 5709 ""
	    i__2 = lnote;
#line 5709 ""
	    ici__1.icierr = 0;
#line 5709 ""
	    ici__1.icirnum = 1;
#line 5709 ""
	    ici__1.icirlen = lnote + lform - i__2;
#line 5709 ""
	    ici__1.iciunit = notexq + i__2;
/* Writing concatenation */
#line 5709 ""
	    i__6[0] = 2, a__3[0] = "(f";
#line 5709 ""
	    i__5 = lform + 48;
#line 5709 ""
	    chax_(ch__1, (ftnlen)1, &i__5);
#line 5709 ""
	    i__6[1] = 1, a__3[1] = ch__1;
#line 5709 ""
	    i__6[2] = 3, a__3[2] = ".1)";
#line 5709 ""
	    ici__1.icifmt = (s_cat(ch__2, a__3, i__6, &c__3, (ftnlen)6), 
		    ch__2);
#line 5709 ""
	    s_wsfi(&ici__1);
#line 5709 ""
	    do_fio(&c__1, (char *)&hoff, (ftnlen)sizeof(real));
#line 5709 ""
	    e_wsfi();
#line 5711 ""
	    lnote += lform;
/* Writing concatenation */
#line 5712 ""
	    i__3[0] = lnote, a__1[0] = notexq;
#line 5712 ""
	    i__3[1] = 1, a__1[1] = "}";
#line 5712 ""
	    s_cat(notexq, a__1, i__3, &c__2, (ftnlen)79);
#line 5713 ""
	    ++lnote;
#line 5714 ""
	}
#line 5715 ""
	if (idno == 0) {

/*  text-dynamic.  Find the string and append it */

#line 5719 ""
	    i__2 = comdyn_1.ntxtdyn;
#line 5719 ""
	    for (jtxtdyn = jtxtdyn1; jtxtdyn <= i__2; ++jtxtdyn) {
/*            ivxip = ivx+16*ip */
#line 5721 ""
		ivxip = *ivx + (*ip << 5);
#line 5722 ""
		if (ivxip == comdyn_1.ivxiptxt[jtxtdyn - 1]) {
#line 5722 ""
		    goto L5;
#line 5722 ""
		}
#line 5723 ""
/* L4: */
#line 5723 ""
	    }
#line 5724 ""
	    printl_("Abnormal stop in putdyn", (ftnlen)23);
#line 5725 ""
	    stop1_();
#line 5726 ""
L5:
#line 5727 ""
	    ltxtdyn = lenstr_(comdyn_1.txtdynq + (jtxtdyn - 1 << 7), &c__128, 
		    (ftnlen)128);

/* Do this to insert 1st 2 args of \txtdyn, allow 3rd to be longer (on next line) */

#line 5731 ""
	    addstr_(notexq, &lnote, soutq, lsout, lnote, (ftnlen)80);
#line 5732 ""
	    if (commus_1.musize == 20) {
#line 5733 ""
		s_copy(notexq, "{\\medtype\\it ", (ftnlen)79, (ftnlen)13);
#line 5734 ""
		lnote = 13;
#line 5735 ""
	    } else if (commus_1.musize == 16) {
#line 5736 ""
		s_copy(notexq, "{\\normtype\\it ", (ftnlen)79, (ftnlen)14);
#line 5737 ""
		lnote = 14;
#line 5738 ""
	    } else if (commus_1.musize == 24) {
#line 5739 ""
		s_copy(notexq, "{\\bigtype\\it ", (ftnlen)79, (ftnlen)13);
#line 5740 ""
		lnote = 13;
#line 5741 ""
	    } else if (commus_1.musize == 29) {
#line 5742 ""
		s_copy(notexq, "{\\Bigtype\\it ", (ftnlen)79, (ftnlen)13);
#line 5743 ""
		lnote = 13;
#line 5744 ""
	    }

/* Writing concatenation */
#line 5746 ""
	    i__6[0] = lnote, a__3[0] = notexq;
#line 5746 ""
	    i__6[1] = ltxtdyn, a__3[1] = comdyn_1.txtdynq + (jtxtdyn - 1 << 7)
		    ;
#line 5746 ""
	    i__6[2] = 1, a__3[2] = "}";
#line 5746 ""
	    s_cat(notexq, a__3, i__6, &c__3, (ftnlen)79);
#line 5747 ""
	    lnote = lnote + ltxtdyn + 1;

/*  Reset jtxtdyn1 just in case >1 txtdyn on same note. */

#line 5751 ""
	    jtxtdyn1 = jtxtdyn + 1;
#line 5752 ""
	} else if (idno <= 12) {

/*  Letter-group dynamic.  Append the letter-group command */

#line 5756 ""
	    id = idno << 2;
#line 5757 ""
	    i__2 = id - 4;
#line 5757 ""
	    s_copy(dynstrq, dyntablq + i__2, (ftnlen)4, id - i__2);
#line 5758 ""
	    id = lenstr_(dynstrq, &c__4, (ftnlen)4);
/* Writing concatenation */
#line 5759 ""
	    i__6[0] = lnote, a__3[0] = notexq;
#line 5759 ""
	    chax_(ch__1, (ftnlen)1, &c__92);
#line 5759 ""
	    i__6[1] = 1, a__3[1] = ch__1;
#line 5759 ""
	    i__6[2] = id, a__3[2] = dynstrq;
#line 5759 ""
	    s_cat(notexq, a__3, i__6, &c__3, (ftnlen)79);
#line 5760 ""
	    lnote = lnote + 1 + id;
#line 5761 ""
	}
#line 5762 ""
	addstr_(notexq, &lnote, soutq, lsout, lnote, (ftnlen)80);
#line 5763 ""
	if (! comslur_1.fontslur && idno == 15) {

/*  PS slurs on, hairpin is ending.  Go back and set height at beginning. */
/*  Add user-defined tweak to default level */

#line 5768 ""
	    lbot1 = lpretweak + comdyn_1.levhssav[*ivx - 1];
#line 5769 ""
	    if (lbot1 > 9) {
#line 5770 ""
		s_copy(numpq, "{", (ftnlen)5, (ftnlen)1);
#line 5771 ""
		s_wsfi(&io___415);
#line 5771 ""
		do_fio(&c__1, (char *)&lbot1, (ftnlen)sizeof(integer));
#line 5771 ""
		e_wsfi();
/* Writing concatenation */
#line 5772 ""
		i__3[0] = 3, a__1[0] = numpq;
#line 5772 ""
		i__3[1] = 1, a__1[1] = "}";
#line 5772 ""
		s_cat(numpq, a__1, i__3, &c__2, (ftnlen)5);
#line 5773 ""
		lnumpq = 4;
#line 5774 ""
	    } else if (lbot1 > -1) {
#line 5775 ""
		*(unsigned char *)&ch__1[0] = lbot1 + 48;
#line 5775 ""
		s_copy(numpq, ch__1, (ftnlen)5, (ftnlen)1);
#line 5776 ""
		lnumpq = 1;
#line 5777 ""
	    } else if (lbot1 > -10) {
#line 5778 ""
		s_copy(numpq, "{", (ftnlen)5, (ftnlen)1);
#line 5779 ""
		s_wsfi(&io___416);
#line 5779 ""
		do_fio(&c__1, (char *)&lbot1, (ftnlen)sizeof(integer));
#line 5779 ""
		e_wsfi();
/* Writing concatenation */
#line 5780 ""
		i__3[0] = 3, a__1[0] = numpq;
#line 5780 ""
		i__3[1] = 1, a__1[1] = "}";
#line 5780 ""
		s_cat(numpq, a__1, i__3, &c__2, (ftnlen)5);
#line 5781 ""
		lnumpq = 4;
#line 5782 ""
	    } else {
#line 5783 ""
		s_copy(numpq, "{", (ftnlen)5, (ftnlen)1);
#line 5784 ""
		s_wsfi(&io___417);
#line 5784 ""
		do_fio(&c__1, (char *)&lbot1, (ftnlen)sizeof(integer));
#line 5784 ""
		e_wsfi();
/* Writing concatenation */
#line 5785 ""
		i__3[0] = 4, a__1[0] = numpq;
#line 5785 ""
		i__3[1] = 1, a__1[1] = "}";
#line 5785 ""
		s_cat(numpq, a__1, i__3, &c__2, (ftnlen)5);
#line 5786 ""
		lnumpq = 5;
#line 5787 ""
	    }

/*  Construct string to search backwards for placeholder */

#line 5791 ""
	    if (idh <= 9) {
/* Writing concatenation */
#line 5792 ""
		i__6[0] = 5, a__3[0] = "cresc";
#line 5792 ""
		*(unsigned char *)&ch__1[0] = idh + 48;
#line 5792 ""
		i__6[1] = 1, a__3[1] = ch__1;
#line 5792 ""
		i__6[2] = 5, a__3[2] = "{   }";
#line 5792 ""
		s_cat(tempq, a__3, i__6, &c__3, (ftnlen)48);
#line 5793 ""
		ltemp = 11;
#line 5794 ""
	    } else if (idh <= 19) {
/* Writing concatenation */
#line 5795 ""
		i__6[0] = 7, a__3[0] = "cresc{1";
#line 5795 ""
		*(unsigned char *)&ch__1[0] = idh + 38;
#line 5795 ""
		i__6[1] = 1, a__3[1] = ch__1;
#line 5795 ""
		i__6[2] = 6, a__3[2] = "}{   }";
#line 5795 ""
		s_cat(tempq, a__3, i__6, &c__3, (ftnlen)48);
#line 5796 ""
		ltemp = 14;
#line 5797 ""
	    } else {
/* Writing concatenation */
#line 5798 ""
		i__6[0] = 7, a__3[0] = "cresc{2";
#line 5798 ""
		*(unsigned char *)&ch__1[0] = idh + 28;
#line 5798 ""
		i__6[1] = 1, a__3[1] = ch__1;
#line 5798 ""
		i__6[2] = 6, a__3[2] = "}{   }";
#line 5798 ""
		s_cat(tempq, a__3, i__6, &c__3, (ftnlen)48);
#line 5799 ""
		ltemp = 14;
#line 5800 ""
	    }
#line 5801 ""
	    s_wsfe(&io___420);
/* Writing concatenation */
#line 5801 ""
	    i__3[0] = *lsout, a__1[0] = soutq;
#line 5801 ""
	    i__3[1] = 1, a__1[1] = "%";
#line 5801 ""
	    s_cat(ch__3, a__1, i__3, &c__2, (ftnlen)81);
#line 5801 ""
	    do_fio(&c__1, ch__3, *lsout + 1);
#line 5801 ""
	    e_wsfe();
#line 5802 ""
	    *lsout = 0;
/* Writing concatenation */
#line 5803 ""
	    i__3[0] = ltemp - 5, a__1[0] = tempq;
#line 5803 ""
	    i__3[1] = lnumpq, a__1[1] = numpq;
#line 5803 ""
	    s_cat(ch__4, a__1, i__3, &c__2, (ftnlen)53);
#line 5803 ""
	    i__2 = ltemp - 5 + lnumpq;
#line 5803 ""
	    backfill_(&c__11, tempq, &ltemp, ch__4, &i__2, (ftnlen)48, ltemp 
		    - 5 + lnumpq);
#line 5805 ""
	}
#line 5806 ""
/* L3: */
#line 5806 ""
    }

/*  Shrink arrays, decrease ndyn 111109 */

#line 5810 ""
    for (icntdyn = numdyn; icntdyn >= 1; --icntdyn) {
#line 5811 ""
	i__1 = comdyn_1.ndyn - 1;
#line 5811 ""
	for (jdyn = idynn[icntdyn - 1]; jdyn <= i__1; ++jdyn) {
#line 5812 ""
	    comdyn_1.idyndat[jdyn - 1] = comdyn_1.idyndat[jdyn];
#line 5813 ""
	    comdyn_1.idynda2[jdyn - 1] = comdyn_1.idynda2[jdyn];
#line 5814 ""
/* L7: */
#line 5814 ""
	}
#line 5815 ""
	--comdyn_1.ndyn;
#line 5816 ""
/* L6: */
#line 5816 ""
    }
#line 5817 ""
    return 0;
} /* dodyn_ */

/* Subroutine */ int dograce_(integer *ivx, integer *ip, real *ptgr, char *
	soutq, integer *lsout, integer *ncm, integer *nacc, integer *ig, 
	integer *ipl, logical *farend, logical *beamon, integer *nolev, 
	integer *ncmidx, integer *islur, integer *nvmx, integer *nv, integer *
	ibmcnt, real *tnote, char *ulq, integer *instno, ftnlen soutq_len, 
	ftnlen ulq_len)
{
    /* System generated locals */
    address a__1[2], a__2[3], a__3[4];
    integer i__1, i__2[2], i__3[3], i__4[4], i__5, i__6;
    real r__1;
    char ch__1[1], ch__2[6], ch__3[2], ch__4[5], ch__5[11], ch__6[7], ch__7[4]
	    , ch__8[87], ch__9[15], ch__10[16], ch__11[9], ch__12[12], ch__13[
	    21], ch__14[20], ch__15[19], ch__16[24], ch__17[13], ch__18[82], 
	    ch__19[3], ch__20[10];
    icilist ici__1;

    /* Builtin functions */
    integer s_wsle(cilist *), do_lio(integer *, integer *, char *, ftnlen), 
	    e_wsle(void);
    /* Subroutine */ int s_stop(char *, ftnlen);
    integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void);
    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
    integer i_nint(real *), s_wsfi(icilist *), e_wsfi(void);
    /* Subroutine */ int s_copy(char *, char *, ftnlen, ftnlen);
    integer i_sign(integer *, integer *);

    /* Local variables */
    extern /* Subroutine */ int addblank_(char *, integer *, ftnlen);
    static integer lnotenga;
    extern integer igetbits_(integer *, integer *, integer *);
    static integer i__;
    static real x, y, em;
    static integer mg;
    static char sq[1];
    static real finalshift;
    static integer ing, ngs;
    extern integer log2_(integer *);
    static integer lacc;
    static real beta;
    extern /* Character */ VOID chax_(char *, ftnlen, integer *), udqq_(char *
	    , ftnlen, integer *, integer *, integer *, integer *, integer *, 
	    integer *);
    static real sumx, sumy;
    extern /* Subroutine */ int stop1_(void);
    static real delta, ptoff;
    static integer lnote;
    static char noteq[8];
    static real sumxx, sumxy, sumyy;
    static integer nolev1;
    static logical isgaft;
    extern /* Subroutine */ int accsym_(integer *, char *, integer *, ftnlen),
	     addstr_(char *, integer *, char *, integer *, ftnlen, ftnlen);
    static logical iswaft;
    static char acsymq[3];
    extern /* Subroutine */ int notefq_(char *, integer *, integer *, integer 
	    *, ftnlen);
    static integer lnoten, itrans, niptgr, islope;
    static logical stemup, normsp;
    static char notexq[79], noteqga[8];
    static real wheadpt1;

    /* Fortran I/O blocks */
    static cilist io___426 = { 0, 6, 0, 0, 0 };
    static cilist io___430 = { 0, 6, 0, 0, 0 };
    static cilist io___431 = { 0, 6, 0, 0, 0 };
    static cilist io___432 = { 0, 15, 0, "(/,a)", 0 };
    static icilist io___435 = { 0, notexq, 0, "(i2)", 2, 1 };
    static cilist io___436 = { 0, 6, 0, 0, 0 };
    static icilist io___460 = { 0, notexq+13, 0, "(a1,f4.1)", 5, 1 };
    static icilist io___462 = { 0, notexq+13, 0, "(f4.1)", 4, 1 };
    static icilist io___464 = { 0, notexq+5, 0, "(f3.1)", 3, 1 };



/*  ip will be one LESS than current note, for way-after's before bar-end, */
/*    It is only used to find ig. */
/*  ig is returned to makeabar in case there's a slur that needs to be ended */

#line 5856 ""
    /* Parameter adjustments */
#line 5856 ""
    ulq -= 25;
#line 5856 ""
    --ptgr;
#line 5856 ""

#line 5856 ""
    /* Function Body */
#line 5856 ""
    chax_(ch__1, (ftnlen)1, &c__92);
#line 5856 ""
    *(unsigned char *)sq = *(unsigned char *)&ch__1[0];
#line 5857 ""
    isgaft = bit_test(*ipl,29);
#line 5858 ""
    iswaft = bit_test(*ipl,31);
#line 5859 ""
    normsp = ! isgaft;

/*  Find ig. */

#line 5863 ""
    i__1 = comgrace_1.ngrace;
#line 5863 ""
    for (*ig = 1; *ig <= i__1; ++(*ig)) {
#line 5864 ""
	if (comgrace_1.ipg[*ig - 1] == *ip && comgrace_1.ivg[*ig - 1] == *ivx)
		 {
#line 5864 ""
	    goto L121;
#line 5864 ""
	}
#line 5865 ""
/* L120: */
#line 5865 ""
    }
#line 5866 ""
    s_wsle(&io___426);
#line 5866 ""
    do_lio(&c__9, &c__1, "Problem finding grace index in dograce", (ftnlen)38)
	    ;
#line 5866 ""
    e_wsle();
#line 5867 ""
    s_stop("", (ftnlen)0);
#line 5868 ""
L121:
#line 5869 ""
    ngs = comgrace_1.ngstrt[*ig - 1];
#line 5870 ""
    mg = comgrace_1.multg[*ig - 1];
/* 	wheadpt1 = wheadpt*fullsize(ivx) */
#line 5872 ""
    wheadpt1 = comask_1.wheadpt * comfig_1.fullsize[*instno - 1];

/*  For way-after-graces at end of bar, must set the octave. */

#line 5876 ""
    if (*farend) {
#line 5877 ""
	comoct_1.noctup = 0;
#line 5878 ""
	if (*ncm == 23) {
#line 5878 ""
	    comoct_1.noctup = -2;
#line 5878 ""
	}
#line 5879 ""
    }
#line 5880 ""
    if (comgrace_1.slurg[*ig - 1] && ! iswaft && ! isgaft) {
#line 5881 ""
	if (comslur_1.listslur == 16777215) {
#line 5882 ""
	    s_wsle(&io___430);
#line 5882 ""
	    e_wsle();
#line 5883 ""
	    s_wsle(&io___431);
#line 5883 ""
	    do_lio(&c__9, &c__1, "You defined the twentyfifth slur, one too "\
		    "many!", (ftnlen)47);
#line 5883 ""
	    e_wsle();
#line 5884 ""
	    s_wsfe(&io___432);
#line 5884 ""
	    do_fio(&c__1, "You defined the twentyfifth slur, one too many!", (
		    ftnlen)47);
#line 5884 ""
	    e_wsfe();
#line 5886 ""
	    stop1_();
#line 5887 ""
	}

/*  Slur on fore-grace.  Get index of next slur not in use, from 23 down. */

#line 5891 ""
	i__1 = 16777215 - comslur_1.listslur;
#line 5891 ""
	comslur_1.ndxslur = log2_(&i__1);
#line 5893 ""
    }
#line 5894 ""
    if (comgrace_1.nng[*ig - 1] == 1) {

/*  Single grace. */

#line 5898 ""
	if (normsp) {

/*  Anything but GA */

/* Writing concatenation */
#line 5902 ""
	    i__2[0] = 1, a__1[0] = sq;
#line 5902 ""
	    i__2[1] = 5, a__1[1] = "shlft";
#line 5902 ""
	    s_cat(ch__2, a__1, i__2, &c__2, (ftnlen)6);
#line 5902 ""
	    addstr_(ch__2, &c__6, soutq, lsout, (ftnlen)6, (ftnlen)80);
#line 5903 ""
	    niptgr = i_nint(&ptgr[*ig]);

/*  Empirical tweak for postscript. */

/*          if (.not.fontslur) niptgr = niptgr+nint(wheadpt*.3) */
/* ++ */
#line 5909 ""
	    if (niptgr < 10) {
/* Writing concatenation */
#line 5910 ""
		i__1 = niptgr + 48;
#line 5910 ""
		chax_(ch__1, (ftnlen)1, &i__1);
#line 5910 ""
		i__2[0] = 1, a__1[0] = ch__1;
#line 5910 ""
		i__2[1] = 1, a__1[1] = "{";
#line 5910 ""
		s_cat(ch__3, a__1, i__2, &c__2, (ftnlen)2);
#line 5910 ""
		addstr_(ch__3, &c__2, soutq, lsout, (ftnlen)2, (ftnlen)80);
#line 5911 ""
	    } else if (niptgr < 100) {
#line 5912 ""
		s_wsfi(&io___435);
#line 5912 ""
		do_fio(&c__1, (char *)&niptgr, (ftnlen)sizeof(integer));
#line 5912 ""
		e_wsfi();
/* Writing concatenation */
#line 5913 ""
		i__3[0] = 1, a__2[0] = "{";
#line 5913 ""
		i__3[1] = 2, a__2[1] = notexq;
#line 5913 ""
		i__3[2] = 2, a__2[2] = "}{";
#line 5913 ""
		s_cat(ch__4, a__2, i__3, &c__3, (ftnlen)5);
#line 5913 ""
		addstr_(ch__4, &c__5, soutq, lsout, (ftnlen)5, (ftnlen)80);
#line 5914 ""
	    } else {
#line 5915 ""
		s_wsle(&io___436);
#line 5915 ""
		do_lio(&c__9, &c__1, "Call Dr. Don if you really want grace "\
			"note group > 99 pt", (ftnlen)56);
#line 5915 ""
		e_wsle();
#line 5917 ""
		s_stop("", (ftnlen)0);
#line 5918 ""
	    }
#line 5919 ""
	} else {
/* Writing concatenation */
#line 5920 ""
	    i__2[0] = 1, a__1[0] = sq;
#line 5920 ""
	    i__2[1] = 10, a__1[1] = "gaft{1.5}{";
#line 5920 ""
	    s_cat(ch__5, a__1, i__2, &c__2, (ftnlen)11);
#line 5920 ""
	    addstr_(ch__5, &c__11, soutq, lsout, (ftnlen)11, (ftnlen)80);

/*  GA.  Compute aftshft, for later use. */

#line 5924 ""
	    comgrace_1.aftshft = spfacs_1.grafac;
#line 5925 ""
	    if (comgrace_1.naccg[comgrace_1.ngstrt[*ig - 1] - 1] > 0) {
#line 5925 ""
		comgrace_1.aftshft += spfacs_1.agc1fac;
#line 5925 ""
	    }
#line 5926 ""
	    comgrace_1.aftshft *= comask_1.wheadpt;
#line 5927 ""
	}
#line 5928 ""
	if (comgrace_1.slurg[*ig - 1] && ! isgaft && ! iswaft) {

/*  Start slur on pre-grace.  No accounting needed since will be ended very soon. */

#line 5932 ""
	    notefq_(noteq, &lnoten, &comgrace_1.nolevg[ngs - 1], ncm, (ftnlen)
		    8);
#line 5933 ""
	    if (comslur_1.fontslur) {
#line 5934 ""
		if (comgrace_1.upg[*ig - 1]) {
/* Writing concatenation */
#line 5935 ""
		    i__2[0] = 1, a__1[0] = sq;
#line 5935 ""
		    i__2[1] = 6, a__1[1] = "islurd";
#line 5935 ""
		    s_cat(ch__6, a__1, i__2, &c__2, (ftnlen)7);
#line 5935 ""
		    addstr_(ch__6, &c__7, soutq, lsout, (ftnlen)7, (ftnlen)80)
			    ;
#line 5936 ""
		} else {
/* Writing concatenation */
#line 5937 ""
		    i__2[0] = 1, a__1[0] = sq;
#line 5937 ""
		    i__2[1] = 6, a__1[1] = "isluru";
#line 5937 ""
		    s_cat(ch__6, a__1, i__2, &c__2, (ftnlen)7);
#line 5937 ""
		    addstr_(ch__6, &c__7, soutq, lsout, (ftnlen)7, (ftnlen)80)
			    ;
#line 5938 ""
		}
#line 5939 ""
	    } else {

/*  Start Postscript slur. */

#line 5943 ""
		if (comgrace_1.upg[*ig - 1]) {
/* Writing concatenation */
#line 5944 ""
		    i__2[0] = 1, a__1[0] = sq;
#line 5944 ""
		    i__2[1] = 3, a__1[1] = "isd";
#line 5944 ""
		    s_cat(ch__7, a__1, i__2, &c__2, (ftnlen)4);
#line 5944 ""
		    addstr_(ch__7, &c__4, soutq, lsout, (ftnlen)4, (ftnlen)80)
			    ;
#line 5945 ""
		} else {
/* Writing concatenation */
#line 5946 ""
		    i__2[0] = 1, a__1[0] = sq;
#line 5946 ""
		    i__2[1] = 3, a__1[1] = "isu";
#line 5946 ""
		    s_cat(ch__7, a__1, i__2, &c__2, (ftnlen)4);
#line 5946 ""
		    addstr_(ch__7, &c__4, soutq, lsout, (ftnlen)4, (ftnlen)80)
			    ;
#line 5947 ""
		}
#line 5948 ""
	    }

/*  Print slur number, 23-ndxslur */

#line 5952 ""
	    lnote = 0;
#line 5953 ""
	    if (23 - comslur_1.ndxslur < 10) {
/*              notexq = notexq(1:lnote)//chax(59-ndxslur) */
#line 5955 ""
		i__1 = 71 - comslur_1.ndxslur;
#line 5955 ""
		chax_(ch__1, (ftnlen)1, &i__1);
#line 5955 ""
		s_copy(notexq, ch__1, (ftnlen)79, (ftnlen)1);
#line 5956 ""
		lnote = 1;
#line 5957 ""
	    } else if (23 - comslur_1.ndxslur < 20) {
/*              notexq = notexq(1:lnote)//'{1'//chax(49-ndxslur)//'}' */
/* Writing concatenation */
#line 5959 ""
		i__3[0] = 2, a__2[0] = "{1";
#line 5959 ""
		i__1 = 61 - comslur_1.ndxslur;
#line 5959 ""
		chax_(ch__1, (ftnlen)1, &i__1);
#line 5959 ""
		i__3[1] = 1, a__2[1] = ch__1;
#line 5959 ""
		i__3[2] = 1, a__2[2] = "}";
#line 5959 ""
		s_cat(notexq, a__2, i__3, &c__3, (ftnlen)79);
#line 5960 ""
		lnote = 4;
#line 5961 ""
	    } else {
/* Writing concatenation */
#line 5962 ""
		i__4[0] = lnote, a__3[0] = notexq;
#line 5962 ""
		i__4[1] = 2, a__3[1] = "{2";
#line 5962 ""
		i__1 = 51 - comslur_1.ndxslur;
#line 5962 ""
		chax_(ch__1, (ftnlen)1, &i__1);
#line 5962 ""
		i__4[2] = 1, a__3[2] = ch__1;
#line 5962 ""
		i__4[3] = 1, a__3[3] = "}";
#line 5962 ""
		s_cat(notexq, a__3, i__4, &c__4, (ftnlen)79);
#line 5963 ""
		lnote = 4;
#line 5964 ""
	    }
/* Writing concatenation */
#line 5965 ""
	    i__2[0] = lnote, a__1[0] = notexq;
#line 5965 ""
	    i__2[1] = lnoten, a__1[1] = noteq;
#line 5965 ""
	    s_cat(ch__8, a__1, i__2, &c__2, (ftnlen)87);
#line 5965 ""
	    i__1 = lnote + lnoten;
#line 5965 ""
	    addstr_(ch__8, &i__1, soutq, lsout, lnote + lnoten, (ftnlen)80);
#line 5967 ""
	    if (! comslur_1.fontslur) {

/*  Horizontal tweaks for postscript slur on single grace */

#line 5971 ""
		stemup = TRUE_;
#line 5972 ""
		if (comgrace_1.upg[*ig - 1]) {

/*  Check for up-grace + down stem. Get stem direction */

#line 5976 ""
		    if (! (*beamon)) {

/*  Separate note.  Get stem direction. */

#line 5980 ""
			udqq_(ch__1, (ftnlen)1, nolev, ncmidx, islur, nvmx, 
				ivx, nv);
#line 5980 ""
			stemup = *(unsigned char *)&ch__1[0] == 'u';
#line 5982 ""
		    } else {

/*  In a beam */

#line 5986 ""
			stemup = *(unsigned char *)&ulq[*ivx + *ibmcnt * 24] 
				== 'u';
#line 5987 ""
		    }

/*  Stop the shift if whole note */

#line 5991 ""
		    stemup = stemup || *tnote > 63.f;
#line 5992 ""
		}
#line 5993 ""
		if (stemup) {
#line 5994 ""
		    addstr_("{-.3}", &c__5, soutq, lsout, (ftnlen)5, (ftnlen)
			    80);
#line 5995 ""
		} else {
#line 5996 ""
		    addstr_("{-.8}", &c__5, soutq, lsout, (ftnlen)5, (ftnlen)
			    80);
#line 5997 ""
		}
#line 5998 ""
	    }
#line 5999 ""
	}
#line 6000 ""
	if (comgrace_1.naccg[ngs - 1] > 0) {
#line 6001 ""
	    notefq_(noteq, &lnoten, &comgrace_1.nolevg[ngs - 1], ncm, (ftnlen)
		    8);

/* Save for checking octave shifts in GA */

#line 6005 ""
	    if (isgaft) {
#line 6006 ""
		lnotenga = lnoten;
#line 6007 ""
		s_copy(noteqga, noteq, (ftnlen)8, (ftnlen)8);
#line 6008 ""
	    }

#line 6010 ""
	    if (lnoten == 1) {
#line 6010 ""
		addblank_(noteq, &lnoten, (ftnlen)8);
#line 6010 ""
	    }
#line 6011 ""
	    accsym_(&comgrace_1.naccg[ngs - 1], acsymq, &lacc, (ftnlen)3);
/* Writing concatenation */
#line 6012 ""
	    i__4[0] = 1, a__3[0] = sq;
#line 6012 ""
	    i__4[1] = 3, a__3[1] = "big";
#line 6012 ""
	    i__4[2] = lacc, a__3[2] = acsymq;
#line 6012 ""
	    i__4[3] = lnoten, a__3[3] = noteq;
#line 6012 ""
	    s_cat(ch__9, a__3, i__4, &c__4, (ftnlen)15);
#line 6012 ""
	    i__1 = lacc + 4 + lnoten;
#line 6012 ""
	    addstr_(ch__9, &i__1, soutq, lsout, lacc + 4 + lnoten, (ftnlen)80)
		    ;
#line 6014 ""
	}
#line 6015 ""
	if (comgrace_1.slashg[*ig - 1]) {
/* Writing concatenation */
#line 6016 ""
	    i__2[0] = 1, a__1[0] = sq;
#line 6016 ""
	    i__2[1] = 3, a__1[1] = "grc";
#line 6016 ""
	    s_cat(notexq, a__1, i__2, &c__2, (ftnlen)79);
#line 6017 ""
	    lnote = 4;
#line 6018 ""
	} else if (mg == 0) {
/* Writing concatenation */
#line 6019 ""
	    i__2[0] = 1, a__1[0] = sq;
#line 6019 ""
	    i__2[1] = 2, a__1[1] = "zq";
#line 6019 ""
	    s_cat(notexq, a__1, i__2, &c__2, (ftnlen)79);
#line 6020 ""
	    lnote = 3;
#line 6021 ""
	} else {
/* Writing concatenation */
#line 6022 ""
	    i__2[0] = 1, a__1[0] = sq;
#line 6022 ""
	    i__2[1] = 2, a__1[1] = "zc";
#line 6022 ""
	    s_cat(notexq, a__1, i__2, &c__2, (ftnlen)79);
#line 6023 ""
	    i__1 = mg;
#line 6023 ""
	    for (i__ = 2; i__ <= i__1; ++i__) {
/* Writing concatenation */
#line 6024 ""
		i__2[0] = i__ + 1, a__1[0] = notexq;
#line 6024 ""
		i__2[1] = 1, a__1[1] = "c";
#line 6024 ""
		s_cat(notexq, a__1, i__2, &c__2, (ftnlen)79);
#line 6025 ""
/* L61: */
#line 6025 ""
	    }
#line 6026 ""
	    lnote = mg + 2;
#line 6027 ""
	}
#line 6028 ""
	if (comgrace_1.upg[*ig - 1]) {
/* Writing concatenation */
#line 6029 ""
	    i__2[0] = lnote, a__1[0] = notexq;
#line 6029 ""
	    i__2[1] = 1, a__1[1] = "u";
#line 6029 ""
	    s_cat(notexq, a__1, i__2, &c__2, (ftnlen)79);
#line 6030 ""
	} else {
/* Writing concatenation */
#line 6031 ""
	    i__2[0] = lnote, a__1[0] = notexq;
#line 6031 ""
	    i__2[1] = 1, a__1[1] = "l";
#line 6031 ""
	    s_cat(notexq, a__1, i__2, &c__2, (ftnlen)79);
#line 6032 ""
	}
#line 6033 ""
	i__1 = lnote + 1;
#line 6033 ""
	addstr_(notexq, &i__1, soutq, lsout, (ftnlen)79, (ftnlen)80);
#line 6034 ""
	notefq_(noteq, &lnoten, &comgrace_1.nolevg[ngs - 1], ncm, (ftnlen)8);

#line 6036 ""
	if (isgaft && comgrace_1.naccg[ngs - 1] == 0) {
#line 6037 ""
	    lnotenga = lnoten;
#line 6038 ""
	    s_copy(noteqga, noteq, (ftnlen)8, (ftnlen)8);
#line 6039 ""
	}

#line 6041 ""
	if (lnoten == 1) {
#line 6041 ""
	    addblank_(noteq, &lnoten, (ftnlen)8);
#line 6041 ""
	}
#line 6042 ""
	addstr_(noteq, &lnoten, soutq, lsout, (ftnlen)8, (ftnlen)80);
#line 6043 ""
	if (comgrace_1.slashg[*ig - 1]) {
/* Writing concatenation */
#line 6043 ""
	    i__4[0] = 1, a__3[0] = sq;
#line 6043 ""
	    i__4[1] = 5, a__3[1] = "off{-";
#line 6043 ""
	    i__4[2] = 1, a__3[2] = sq;
#line 6043 ""
	    i__4[3] = 9, a__3[3] = "noteskip}";
#line 6043 ""
	    s_cat(ch__10, a__3, i__4, &c__4, (ftnlen)16);
#line 6043 ""
	    addstr_(ch__10, &c__16, soutq, lsout, (ftnlen)16, (ftnlen)80);
#line 6043 ""
	}

/*  Above code needed since slashg causes spacing */

#line 6048 ""
	if (comgrace_1.slurg[*ig - 1] && (iswaft || isgaft)) {

/*  Terminate slur on single after-grace */

#line 6052 ""
	    comslur_1.ndxslur = igetbits_(ipl, &c__5, &c__23);
#line 6053 ""
	    notefq_(noteq, &lnoten, &comgrace_1.nolevg[ngs - 1], ncm, (ftnlen)
		    8);
/* Writing concatenation */
#line 6054 ""
	    i__2[0] = 1, a__1[0] = sq;
#line 6054 ""
	    i__2[1] = 5, a__1[1] = "tslur";
#line 6054 ""
	    s_cat(ch__2, a__1, i__2, &c__2, (ftnlen)6);
#line 6054 ""
	    addstr_(ch__2, &c__6, soutq, lsout, (ftnlen)6, (ftnlen)80);

/*  Print 24-ndxslur */

#line 6058 ""
	    if (23 - comslur_1.ndxslur < 10) {
/* Writing concatenation */
#line 6059 ""
		i__1 = 71 - comslur_1.ndxslur;
#line 6059 ""
		chax_(ch__1, (ftnlen)1, &i__1);
#line 6059 ""
		i__2[0] = 1, a__1[0] = ch__1;
#line 6059 ""
		i__2[1] = lnoten, a__1[1] = noteq;
#line 6059 ""
		s_cat(ch__11, a__1, i__2, &c__2, (ftnlen)9);
#line 6059 ""
		i__5 = lnoten + 1;
#line 6059 ""
		addstr_(ch__11, &i__5, soutq, lsout, lnoten + 1, (ftnlen)80);
#line 6061 ""
	    } else if (23 - comslur_1.ndxslur < 20) {
/* Writing concatenation */
#line 6062 ""
		i__4[0] = 2, a__3[0] = "{2";
#line 6062 ""
		i__1 = 61 - comslur_1.ndxslur;
#line 6062 ""
		chax_(ch__1, (ftnlen)1, &i__1);
#line 6062 ""
		i__4[1] = 1, a__3[1] = ch__1;
#line 6062 ""
		i__4[2] = 1, a__3[2] = "}";
#line 6062 ""
		i__4[3] = lnoten, a__3[3] = noteq;
#line 6062 ""
		s_cat(ch__12, a__3, i__4, &c__4, (ftnlen)12);
#line 6062 ""
		i__5 = lnoten + 4;
#line 6062 ""
		addstr_(ch__12, &i__5, soutq, lsout, lnoten + 4, (ftnlen)80);
#line 6064 ""
	    } else {
/*            call addstr('{1'//chax(49-ndxslur)//'}'//noteq(1:lnoten), */
/* Writing concatenation */
#line 6066 ""
		i__4[0] = 2, a__3[0] = "{1";
#line 6066 ""
		i__1 = 51 - comslur_1.ndxslur;
#line 6066 ""
		chax_(ch__1, (ftnlen)1, &i__1);
#line 6066 ""
		i__4[1] = 1, a__3[1] = ch__1;
#line 6066 ""
		i__4[2] = 1, a__3[2] = "}";
#line 6066 ""
		i__4[3] = lnoten, a__3[3] = noteq;
#line 6066 ""
		s_cat(ch__12, a__3, i__4, &c__4, (ftnlen)12);
#line 6066 ""
		i__5 = lnoten + 4;
#line 6066 ""
		addstr_(ch__12, &i__5, soutq, lsout, lnoten + 4, (ftnlen)80);
#line 6068 ""
	    }
#line 6069 ""
	    comgrace_1.slurg[*ig - 1] = FALSE_;
#line 6070 ""
	    comslur_1.listslur = bit_clear(comslur_1.listslur,
		    comslur_1.ndxslur);
#line 6071 ""
	}
#line 6072 ""
	addstr_("}", &c__1, soutq, lsout, (ftnlen)1, (ftnlen)80);

/* +++  Try to fix loss of octave with single gaft */

#line 6076 ""
	if (isgaft) {
#line 6077 ""
	    itrans = 0;
#line 6078 ""
	    i__1 = lnotenga;
#line 6078 ""
	    for (i__ = 1; i__ <= i__1; ++i__) {
#line 6079 ""
		chax_(ch__1, (ftnlen)1, &c__39);
#line 6079 ""
		if (*(unsigned char *)&noteqga[i__ - 1] == *(unsigned char *)&
			ch__1[0]) {
#line 6080 ""
		    itrans += 7;
#line 6081 ""
		} else /* if(complicated condition) */ {
#line 6081 ""
		    chax_(ch__1, (ftnlen)1, &c__96);
#line 6081 ""
		    if (*(unsigned char *)&noteqga[i__ - 1] == *(unsigned 
			    char *)&ch__1[0]) {
#line 6082 ""
			itrans += -7;
#line 6083 ""
		    }
#line 6083 ""
		}
#line 6084 ""
/* L1: */
#line 6084 ""
	    }
#line 6085 ""
	    if (itrans == -14) {
/* Writing concatenation */
#line 6086 ""
		i__4[0] = 1, a__3[0] = sq;
#line 6086 ""
		i__4[1] = 7, a__3[1] = "advance";
#line 6086 ""
		i__4[2] = 1, a__3[2] = sq;
#line 6086 ""
		i__4[3] = 12, a__3[3] = "transpose-14";
#line 6086 ""
		s_cat(ch__13, a__3, i__4, &c__4, (ftnlen)21);
#line 6086 ""
		addstr_(ch__13, &c__21, soutq, lsout, (ftnlen)21, (ftnlen)80);
#line 6088 ""
	    } else if (itrans == -7) {
/* Writing concatenation */
#line 6089 ""
		i__4[0] = 1, a__3[0] = sq;
#line 6089 ""
		i__4[1] = 7, a__3[1] = "advance";
#line 6089 ""
		i__4[2] = 1, a__3[2] = sq;
#line 6089 ""
		i__4[3] = 11, a__3[3] = "transpose-7";
#line 6089 ""
		s_cat(ch__14, a__3, i__4, &c__4, (ftnlen)20);
#line 6089 ""
		addstr_(ch__14, &c__20, soutq, lsout, (ftnlen)20, (ftnlen)80);
#line 6091 ""
	    } else if (itrans == 7) {
/* Writing concatenation */
#line 6092 ""
		i__4[0] = 1, a__3[0] = sq;
#line 6092 ""
		i__4[1] = 7, a__3[1] = "advance";
#line 6092 ""
		i__4[2] = 1, a__3[2] = sq;
#line 6092 ""
		i__4[3] = 10, a__3[3] = "transpose7";
#line 6092 ""
		s_cat(ch__15, a__3, i__4, &c__4, (ftnlen)19);
#line 6092 ""
		addstr_(ch__15, &c__19, soutq, lsout, (ftnlen)19, (ftnlen)80);
#line 6094 ""
	    } else if (itrans == 14) {
/* Writing concatenation */
#line 6095 ""
		i__4[0] = 1, a__3[0] = sq;
#line 6095 ""
		i__4[1] = 7, a__3[1] = "advance";
#line 6095 ""
		i__4[2] = 1, a__3[2] = sq;
#line 6095 ""
		i__4[3] = 11, a__3[3] = "transpose14";
#line 6095 ""
		s_cat(ch__14, a__3, i__4, &c__4, (ftnlen)20);
#line 6095 ""
		addstr_(ch__14, &c__20, soutq, lsout, (ftnlen)20, (ftnlen)80);
#line 6097 ""
	    }
#line 6098 ""
	}
#line 6099 ""
    } else {

/*  Multiple grace.  Put in literally.  Compute beam stuff */

#line 6103 ""
	sumx = 0.f;
#line 6104 ""
	sumy = 0.f;
#line 6105 ""
	sumxy = 0.f;
#line 6106 ""
	sumxx = 0.f;
#line 6107 ""
	sumyy = 0.f;
#line 6108 ""
	x = 0.f;
#line 6109 ""
	i__1 = ngs + comgrace_1.nng[*ig - 1] - 1;
#line 6109 ""
	for (ing = ngs; ing <= i__1; ++ing) {
#line 6110 ""
	    if (ing > ngs && comgrace_1.naccg[ing - 1] > 0) {
#line 6110 ""
		x += spfacs_1.acgfac;
#line 6110 ""
	    }
#line 6111 ""
	    y = (real) comgrace_1.nolevg[ing - 1];
#line 6112 ""
	    sumx += x;
#line 6113 ""
	    sumy += y;
#line 6114 ""
	    sumxy += x * y;
#line 6115 ""
	    sumxx += x * x;
#line 6116 ""
	    sumyy += y * y;
#line 6117 ""
	    x += spfacs_1.emgfac;
#line 6118 ""
/* L118: */
#line 6118 ""
	}
#line 6119 ""
	delta = comgrace_1.nng[*ig - 1] * sumxx - sumx * sumx;
#line 6120 ""
	em = (comgrace_1.nng[*ig - 1] * sumxy - sumx * sumy) / delta;
#line 6121 ""
	r__1 = em * .5f * spfacs_1.gslfac;
#line 6121 ""
	islope = i_nint(&r__1);
#line 6122 ""
	if (abs(islope) > 9) {
#line 6122 ""
	    islope = i_sign(&c__9, &islope);
#line 6122 ""
	}
#line 6123 ""
	beta = (sumy - islope / spfacs_1.gslfac * sumx) / comgrace_1.nng[*ig 
		- 1];
#line 6124 ""
	nolev1 = i_nint(&beta);

/*  Back up */

/* Writing concatenation */
#line 6128 ""
	i__4[0] = 1, a__3[0] = sq;
#line 6128 ""
	i__4[1] = 7, a__3[1] = "settiny";
#line 6128 ""
	i__4[2] = 1, a__3[2] = sq;
#line 6128 ""
	i__4[3] = 4, a__3[3] = "off{";
#line 6128 ""
	s_cat(notexq, a__3, i__4, &c__4, (ftnlen)79);
#line 6129 ""
	if (normsp) {
#line 6130 ""
	    s_wsfi(&io___460);
#line 6130 ""
	    do_fio(&c__1, "-", (ftnlen)1);
#line 6130 ""
	    do_fio(&c__1, (char *)&ptgr[*ig], (ftnlen)sizeof(real));
#line 6130 ""
	    e_wsfi();
/* Writing concatenation */
#line 6131 ""
	    i__2[0] = 18, a__1[0] = notexq;
#line 6131 ""
	    i__2[1] = 3, a__1[1] = "pt}";
#line 6131 ""
	    s_cat(ch__13, a__1, i__2, &c__2, (ftnlen)21);
#line 6131 ""
	    addstr_(ch__13, &c__21, soutq, lsout, (ftnlen)21, (ftnlen)80);
#line 6132 ""
	    finalshift = ptgr[*ig];
#line 6133 ""
	} else {
#line 6134 ""
	    comgrace_1.aftshft = comask_1.wheadpt * 1.33f;
#line 6135 ""
	    if (comgrace_1.naccg[comgrace_1.ngstrt[*ig - 1] - 1] > 0) {
#line 6135 ""
		comgrace_1.aftshft += comask_1.wheadpt * .5f;
#line 6135 ""
	    }
#line 6136 ""
	    s_wsfi(&io___462);
#line 6136 ""
	    do_fio(&c__1, (char *)&comgrace_1.aftshft, (ftnlen)sizeof(real));
#line 6136 ""
	    e_wsfi();
/* Writing concatenation */
#line 6137 ""
	    i__4[0] = 17, a__3[0] = notexq;
#line 6137 ""
	    i__4[1] = 3, a__3[1] = "pt}";
#line 6137 ""
	    i__4[2] = 1, a__3[2] = sq;
#line 6137 ""
	    i__4[3] = 3, a__3[3] = "bsk";
#line 6137 ""
	    s_cat(ch__16, a__3, i__4, &c__4, (ftnlen)24);
#line 6137 ""
	    addstr_(ch__16, &c__24, soutq, lsout, (ftnlen)24, (ftnlen)80);
#line 6138 ""
	}

/*  Start the beam */

/* Writing concatenation */
#line 6142 ""
	i__2[0] = 1, a__1[0] = sq;
#line 6142 ""
	i__2[1] = 2, a__1[1] = "ib";
#line 6142 ""
	s_cat(notexq, a__1, i__2, &c__2, (ftnlen)79);
#line 6143 ""
	i__1 = mg;
#line 6143 ""
	for (ing = 2; ing <= i__1; ++ing) {
/* Writing concatenation */
#line 6144 ""
	    i__2[0] = ing + 1, a__1[0] = notexq;
#line 6144 ""
	    i__2[1] = 1, a__1[1] = "b";
#line 6144 ""
	    s_cat(notexq, a__1, i__2, &c__2, (ftnlen)79);
#line 6145 ""
/* L119: */
#line 6145 ""
	}
#line 6146 ""
	if (comgrace_1.upg[*ig - 1]) {
/* Writing concatenation */
#line 6147 ""
	    i__2[0] = mg + 2, a__1[0] = notexq;
#line 6147 ""
	    i__2[1] = 1, a__1[1] = "u";
#line 6147 ""
	    s_cat(notexq, a__1, i__2, &c__2, (ftnlen)79);
#line 6148 ""
	} else {
/* Writing concatenation */
#line 6149 ""
	    i__2[0] = mg + 2, a__1[0] = notexq;
#line 6149 ""
	    i__2[1] = 1, a__1[1] = "l";
#line 6149 ""
	    s_cat(notexq, a__1, i__2, &c__2, (ftnlen)79);
#line 6150 ""
	}
/* Writing concatenation */
#line 6151 ""
	i__2[0] = mg + 3, a__1[0] = notexq;
#line 6151 ""
	i__2[1] = 1, a__1[1] = "0";
#line 6151 ""
	s_cat(notexq, a__1, i__2, &c__2, (ftnlen)79);

/*  Get starting note for beam */

#line 6155 ""
	notefq_(noteq, &lnoten, &nolev1, ncm, (ftnlen)8);
/* Writing concatenation */
#line 6156 ""
	i__2[0] = mg + 4, a__1[0] = notexq;
#line 6156 ""
	i__2[1] = lnoten, a__1[1] = noteq;
#line 6156 ""
	s_cat(ch__8, a__1, i__2, &c__2, (ftnlen)87);
#line 6156 ""
	i__1 = mg + 4 + lnoten;
#line 6156 ""
	addstr_(ch__8, &i__1, soutq, lsout, mg + 4 + lnoten, (ftnlen)80);

/*  Put in the slope */

#line 6161 ""
	if (islope >= 0) {
#line 6162 ""
	    i__1 = islope + 48;
#line 6162 ""
	    chax_(ch__1, (ftnlen)1, &i__1);
#line 6162 ""
	    addstr_(ch__1, &c__1, soutq, lsout, (ftnlen)1, (ftnlen)80);
#line 6163 ""
	} else {
/* Writing concatenation */
#line 6164 ""
	    i__3[0] = 2, a__2[0] = "{-";
#line 6164 ""
	    i__1 = 48 - islope;
#line 6164 ""
	    chax_(ch__1, (ftnlen)1, &i__1);
#line 6164 ""
	    i__3[1] = 1, a__2[1] = ch__1;
#line 6164 ""
	    i__3[2] = 1, a__2[2] = "}";
#line 6164 ""
	    s_cat(ch__7, a__2, i__3, &c__3, (ftnlen)4);
#line 6164 ""
	    addstr_(ch__7, &c__4, soutq, lsout, (ftnlen)4, (ftnlen)80);
#line 6165 ""
	}

/*  Start a slur on multiple fore-grace */

#line 6169 ""
	if (comgrace_1.slurg[*ig - 1] && ! isgaft && ! iswaft) {
#line 6170 ""
	    notefq_(noteq, &lnoten, &comgrace_1.nolevg[ngs - 1], ncm, (ftnlen)
		    8);
#line 6171 ""
	    if (comslur_1.fontslur) {
#line 6172 ""
		if (comgrace_1.upg[*ig - 1]) {
/* Writing concatenation */
#line 6173 ""
		    i__2[0] = 1, a__1[0] = sq;
#line 6173 ""
		    i__2[1] = 6, a__1[1] = "islurd";
#line 6173 ""
		    s_cat(ch__6, a__1, i__2, &c__2, (ftnlen)7);
#line 6173 ""
		    addstr_(ch__6, &c__7, soutq, lsout, (ftnlen)7, (ftnlen)80)
			    ;
#line 6174 ""
		} else {
/* Writing concatenation */
#line 6175 ""
		    i__2[0] = 1, a__1[0] = sq;
#line 6175 ""
		    i__2[1] = 6, a__1[1] = "isluru";
#line 6175 ""
		    s_cat(ch__6, a__1, i__2, &c__2, (ftnlen)7);
#line 6175 ""
		    addstr_(ch__6, &c__7, soutq, lsout, (ftnlen)7, (ftnlen)80)
			    ;
#line 6176 ""
		}
#line 6177 ""
	    } else {

/*  Need a tweak for postscript slur */

#line 6181 ""
		if (comgrace_1.upg[*ig - 1]) {
/* Writing concatenation */
#line 6182 ""
		    i__2[0] = 1, a__1[0] = sq;
#line 6182 ""
		    i__2[1] = 3, a__1[1] = "isd";
#line 6182 ""
		    s_cat(ch__7, a__1, i__2, &c__2, (ftnlen)4);
#line 6182 ""
		    addstr_(ch__7, &c__4, soutq, lsout, (ftnlen)4, (ftnlen)80)
			    ;
#line 6183 ""
		} else {
/* Writing concatenation */
#line 6184 ""
		    i__2[0] = 1, a__1[0] = sq;
#line 6184 ""
		    i__2[1] = 3, a__1[1] = "isu";
#line 6184 ""
		    s_cat(ch__7, a__1, i__2, &c__2, (ftnlen)4);
#line 6184 ""
		    addstr_(ch__7, &c__4, soutq, lsout, (ftnlen)4, (ftnlen)80)
			    ;
#line 6185 ""
		}
#line 6186 ""
	    }

/*  Print 23-ndxslur */

#line 6190 ""
	    if (23 - comslur_1.ndxslur < 10) {
/* Writing concatenation */
#line 6191 ""
		i__1 = 71 - comslur_1.ndxslur;
#line 6191 ""
		chax_(ch__1, (ftnlen)1, &i__1);
#line 6191 ""
		i__2[0] = 1, a__1[0] = ch__1;
#line 6191 ""
		i__2[1] = lnoten, a__1[1] = noteq;
#line 6191 ""
		s_cat(ch__11, a__1, i__2, &c__2, (ftnlen)9);
#line 6191 ""
		i__5 = lnoten + 1;
#line 6191 ""
		addstr_(ch__11, &i__5, soutq, lsout, lnoten + 1, (ftnlen)80);
#line 6193 ""
	    } else if (23 - comslur_1.ndxslur < 2) {
/* Writing concatenation */
#line 6194 ""
		i__4[0] = 2, a__3[0] = "{1";
#line 6194 ""
		i__1 = 61 - comslur_1.ndxslur;
#line 6194 ""
		chax_(ch__1, (ftnlen)1, &i__1);
#line 6194 ""
		i__4[1] = 1, a__3[1] = ch__1;
#line 6194 ""
		i__4[2] = 1, a__3[2] = "}";
#line 6194 ""
		i__4[3] = lnoten, a__3[3] = noteq;
#line 6194 ""
		s_cat(ch__12, a__3, i__4, &c__4, (ftnlen)12);
#line 6194 ""
		i__5 = lnoten + 4;
#line 6194 ""
		addstr_(ch__12, &i__5, soutq, lsout, lnoten + 4, (ftnlen)80);
#line 6196 ""
	    } else {
/* Writing concatenation */
#line 6197 ""
		i__4[0] = 2, a__3[0] = "{1";
#line 6197 ""
		i__1 = 51 - comslur_1.ndxslur;
#line 6197 ""
		chax_(ch__1, (ftnlen)1, &i__1);
#line 6197 ""
		i__4[1] = 1, a__3[1] = ch__1;
#line 6197 ""
		i__4[2] = 1, a__3[2] = "}";
#line 6197 ""
		i__4[3] = lnoten, a__3[3] = noteq;
#line 6197 ""
		s_cat(ch__12, a__3, i__4, &c__4, (ftnlen)12);
#line 6197 ""
		i__5 = lnoten + 4;
#line 6197 ""
		addstr_(ch__12, &i__5, soutq, lsout, lnoten + 4, (ftnlen)80);
#line 6199 ""
	    }

/*  Put in tweak for postscript slur */

#line 6203 ""
	    if (! comslur_1.fontslur) {
#line 6203 ""
		addstr_("{-.3}", &c__5, soutq, lsout, (ftnlen)5, (ftnlen)80);
#line 6203 ""
	    }
#line 6204 ""
	}

/*  Put in first note.  Call notefq again in case octave changed */

#line 6208 ""
	notefq_(noteq, &lnoten, &comgrace_1.nolevg[ngs - 1], ncm, (ftnlen)8);
#line 6209 ""
	if (comgrace_1.naccg[ngs - 1] == 0) {
/* Writing concatenation */
#line 6210 ""
	    i__3[0] = 1, a__2[0] = sq;
#line 6210 ""
	    i__3[1] = 4, a__2[1] = "zqb0";
#line 6210 ""
	    i__3[2] = lnoten, a__2[2] = noteq;
#line 6210 ""
	    s_cat(notexq, a__2, i__3, &c__3, (ftnlen)79);
#line 6211 ""
	    lnote = lnoten + 5;
#line 6212 ""
	} else {
#line 6213 ""
	    if (lnoten == 1) {
#line 6213 ""
		addblank_(noteq, &lnoten, (ftnlen)8);
#line 6213 ""
	    }
#line 6214 ""
	    accsym_(&comgrace_1.naccg[ngs - 1], acsymq, &lacc, (ftnlen)3);
/* Writing concatenation */
#line 6215 ""
	    i__4[0] = 1, a__3[0] = sq;
#line 6215 ""
	    i__4[1] = 3, a__3[1] = "big";
#line 6215 ""
	    i__4[2] = lacc, a__3[2] = acsymq;
#line 6215 ""
	    i__4[3] = lnoten, a__3[3] = noteq;
#line 6215 ""
	    s_cat(notexq, a__3, i__4, &c__4, (ftnlen)79);
#line 6216 ""
	    lnote = lacc + 4 + lnoten;
#line 6217 ""
	    notefq_(noteq, &lnoten, &comgrace_1.nolevg[ngs - 1], ncm, (ftnlen)
		    8);
/* Writing concatenation */
#line 6218 ""
	    i__4[0] = lnote, a__3[0] = notexq;
#line 6218 ""
	    i__4[1] = 1, a__3[1] = sq;
#line 6218 ""
	    i__4[2] = 4, a__3[2] = "zqb0";
#line 6218 ""
	    i__4[3] = lnoten, a__3[3] = noteq;
#line 6218 ""
	    s_cat(notexq, a__3, i__4, &c__4, (ftnlen)79);
#line 6219 ""
	    lnote = lnote + 5 + lnoten;
#line 6220 ""
	}
#line 6221 ""
	addstr_(notexq, &lnote, soutq, lsout, (ftnlen)79, (ftnlen)80);
#line 6222 ""
	i__1 = ngs + comgrace_1.nng[*ig - 1] - 1;
#line 6222 ""
	for (ing = ngs + 1; ing <= i__1; ++ing) {

/*  Skip */

#line 6226 ""
	    ptoff = wheadpt1 * spfacs_1.emgfac;
#line 6227 ""
	    if (comgrace_1.naccg[ing - 1] > 0) {
#line 6227 ""
		ptoff += wheadpt1 * spfacs_1.acgfac;
#line 6227 ""
	    }
#line 6228 ""
	    if (isgaft && ! iswaft) {
#line 6228 ""
		comgrace_1.aftshft += ptoff;
#line 6228 ""
	    }
/* Writing concatenation */
#line 6229 ""
	    i__2[0] = 1, a__1[0] = sq;
#line 6229 ""
	    i__2[1] = 4, a__1[1] = "off{";
#line 6229 ""
	    s_cat(notexq, a__1, i__2, &c__2, (ftnlen)79);
#line 6230 ""
	    s_wsfi(&io___464);
#line 6230 ""
	    do_fio(&c__1, (char *)&ptoff, (ftnlen)sizeof(real));
#line 6230 ""
	    e_wsfi();
#line 6231 ""
	    if (normsp) {
#line 6231 ""
		finalshift -= ptoff;
#line 6231 ""
	    }
/* Writing concatenation */
#line 6232 ""
	    i__2[0] = 8, a__1[0] = notexq;
#line 6232 ""
	    i__2[1] = 3, a__1[1] = "pt}";
#line 6232 ""
	    s_cat(ch__5, a__1, i__2, &c__2, (ftnlen)11);
#line 6232 ""
	    addstr_(ch__5, &c__11, soutq, lsout, (ftnlen)11, (ftnlen)80);
#line 6233 ""
	    if (ing == ngs + comgrace_1.nng[*ig - 1] - 1) {

/*  Terminate beam if needed */

#line 6237 ""
		if (comgrace_1.upg[*ig - 1]) {
/* Writing concatenation */
#line 6238 ""
		    i__2[0] = 1, a__1[0] = sq;
#line 6238 ""
		    i__2[1] = 4, a__1[1] = "tbu0";
#line 6238 ""
		    s_cat(ch__4, a__1, i__2, &c__2, (ftnlen)5);
#line 6238 ""
		    addstr_(ch__4, &c__5, soutq, lsout, (ftnlen)5, (ftnlen)80)
			    ;
#line 6239 ""
		} else {
/* Writing concatenation */
#line 6240 ""
		    i__2[0] = 1, a__1[0] = sq;
#line 6240 ""
		    i__2[1] = 4, a__1[1] = "tbl0";
#line 6240 ""
		    s_cat(ch__4, a__1, i__2, &c__2, (ftnlen)5);
#line 6240 ""
		    addstr_(ch__4, &c__5, soutq, lsout, (ftnlen)5, (ftnlen)80)
			    ;
#line 6241 ""
		}

/*  Terminate after slur if needed */

#line 6245 ""
		if ((isgaft || iswaft) && comgrace_1.slurg[*ig - 1]) {
#line 6246 ""
		    if (iswaft) {
#line 6246 ""
			comslur_1.ndxslur = igetbits_(ipl, &c__5, &c__23);
#line 6246 ""
		    }
#line 6247 ""
		    notefq_(noteq, &lnoten, &comgrace_1.nolevg[ing - 1], ncm, 
			    (ftnlen)8);
/* Writing concatenation */
#line 6248 ""
		    i__2[0] = 1, a__1[0] = sq;
#line 6248 ""
		    i__2[1] = 5, a__1[1] = "tslur";
#line 6248 ""
		    s_cat(ch__2, a__1, i__2, &c__2, (ftnlen)6);
#line 6248 ""
		    addstr_(ch__2, &c__6, soutq, lsout, (ftnlen)6, (ftnlen)80)
			    ;

/*  Print 11-ndxslur */
/* c  Print 23-ndxslur */

#line 6253 ""
		    if (23 - comslur_1.ndxslur < 10) {
/* Writing concatenation */
#line 6254 ""
			i__5 = 71 - comslur_1.ndxslur;
#line 6254 ""
			chax_(ch__1, (ftnlen)1, &i__5);
#line 6254 ""
			i__2[0] = 1, a__1[0] = ch__1;
#line 6254 ""
			i__2[1] = lnoten, a__1[1] = noteq;
#line 6254 ""
			s_cat(ch__11, a__1, i__2, &c__2, (ftnlen)9);
#line 6254 ""
			i__6 = lnoten + 1;
#line 6254 ""
			addstr_(ch__11, &i__6, soutq, lsout, lnoten + 1, (
				ftnlen)80);
#line 6256 ""
		    } else if (23 - comslur_1.ndxslur < 20) {
/* Writing concatenation */
#line 6257 ""
			i__4[0] = 2, a__3[0] = "{2";
#line 6257 ""
			i__5 = 61 - comslur_1.ndxslur;
#line 6257 ""
			chax_(ch__1, (ftnlen)1, &i__5);
#line 6257 ""
			i__4[1] = 1, a__3[1] = ch__1;
#line 6257 ""
			i__4[2] = 1, a__3[2] = "}";
#line 6257 ""
			i__4[3] = lnoten, a__3[3] = noteq;
#line 6257 ""
			s_cat(ch__12, a__3, i__4, &c__4, (ftnlen)12);
#line 6257 ""
			i__6 = lnoten + 4;
#line 6257 ""
			addstr_(ch__12, &i__6, soutq, lsout, lnoten + 4, (
				ftnlen)80);
#line 6259 ""
		    } else {
/* Writing concatenation */
#line 6260 ""
			i__4[0] = 2, a__3[0] = "{1";
#line 6260 ""
			i__5 = 51 - comslur_1.ndxslur;
#line 6260 ""
			chax_(ch__1, (ftnlen)1, &i__5);
#line 6260 ""
			i__4[1] = 1, a__3[1] = ch__1;
#line 6260 ""
			i__4[2] = 1, a__3[2] = "}";
#line 6260 ""
			i__4[3] = lnoten, a__3[3] = noteq;
#line 6260 ""
			s_cat(ch__12, a__3, i__4, &c__4, (ftnlen)12);
#line 6260 ""
			i__6 = lnoten + 4;
#line 6260 ""
			addstr_(ch__12, &i__6, soutq, lsout, lnoten + 4, (
				ftnlen)80);
#line 6262 ""
		    }

/*  Stop slur terminator after exit from this subroutine */

#line 6266 ""
		    comslur_1.listslur = bit_clear(comslur_1.listslur,
			    comslur_1.ndxslur);
#line 6267 ""
		    comgrace_1.slurg[*ig - 1] = FALSE_;
#line 6268 ""
		}
#line 6269 ""
	    }

/*  Accidental if needed */

#line 6273 ""
	    if (comgrace_1.naccg[ing - 1] > 0) {
#line 6274 ""
		notefq_(noteq, &lnoten, &comgrace_1.nolevg[ing - 1], ncm, (
			ftnlen)8);
#line 6275 ""
		if (lnoten == 1) {
#line 6275 ""
		    addblank_(noteq, &lnoten, (ftnlen)8);
#line 6275 ""
		}
#line 6276 ""
		accsym_(&comgrace_1.naccg[ing - 1], acsymq, &lacc, (ftnlen)3);
/* Writing concatenation */
#line 6277 ""
		i__4[0] = 1, a__3[0] = sq;
#line 6277 ""
		i__4[1] = 3, a__3[1] = "big";
#line 6277 ""
		i__4[2] = lacc, a__3[2] = acsymq;
#line 6277 ""
		i__4[3] = lnoten, a__3[3] = noteq;
#line 6277 ""
		s_cat(ch__9, a__3, i__4, &c__4, (ftnlen)15);
#line 6277 ""
		i__5 = lacc + 4 + lnoten;
#line 6277 ""
		addstr_(ch__9, &i__5, soutq, lsout, lacc + 4 + lnoten, (
			ftnlen)80);
#line 6279 ""
	    }

/*  Put in the (beamed) grace note */

#line 6283 ""
	    notefq_(noteq, &lnoten, &comgrace_1.nolevg[ing - 1], ncm, (ftnlen)
		    8);
/* Writing concatenation */
#line 6284 ""
	    i__3[0] = 1, a__2[0] = sq;
#line 6284 ""
	    i__3[1] = 4, a__2[1] = "zqb0";
#line 6284 ""
	    i__3[2] = lnoten, a__2[2] = noteq;
#line 6284 ""
	    s_cat(ch__17, a__2, i__3, &c__3, (ftnlen)13);
#line 6284 ""
	    i__5 = lnoten + 5;
#line 6284 ""
	    addstr_(ch__17, &i__5, soutq, lsout, lnoten + 5, (ftnlen)80);
#line 6286 ""
/* L127: */
#line 6286 ""
	}

/*  Terminate the grace */

/* Writing concatenation */
#line 6290 ""
	i__2[0] = 1, a__1[0] = sq;
#line 6290 ""
	i__2[1] = 4, a__1[1] = "off{";
#line 6290 ""
	s_cat(notexq, a__1, i__2, &c__2, (ftnlen)79);
#line 6291 ""
	lnote = 5;
#line 6292 ""
	ptoff = comask_1.wheadpt * spfacs_1.emgfac;
#line 6293 ""
	if ((*nacc & 3) > 0 && ! bit_test(*nacc,17)) {
#line 6293 ""
	    ptoff += comask_1.wheadpt * spfacs_1.accfac;
#line 6293 ""
	}
#line 6295 ""
	if (isgaft && ! iswaft) {
/* Writing concatenation */
#line 6296 ""
	    i__2[0] = 5, a__1[0] = notexq;
#line 6296 ""
	    i__2[1] = 1, a__1[1] = "-";
#line 6296 ""
	    s_cat(notexq, a__1, i__2, &c__2, (ftnlen)79);
#line 6297 ""
	    lnote = 6;
#line 6298 ""
	    ptoff = comgrace_1.aftshft;
#line 6299 ""
	}
#line 6300 ""
	if (normsp) {
#line 6300 ""
	    ptoff = finalshift;
#line 6300 ""
	}
#line 6301 ""
	if (ptoff < 9.95f) {
#line 6302 ""
	    i__1 = lnote;
#line 6302 ""
	    ici__1.icierr = 0;
#line 6302 ""
	    ici__1.icirnum = 1;
#line 6302 ""
	    ici__1.icirlen = lnote + 3 - i__1;
#line 6302 ""
	    ici__1.iciunit = notexq + i__1;
#line 6302 ""
	    ici__1.icifmt = "(f3.1)";
#line 6302 ""
	    s_wsfi(&ici__1);
#line 6302 ""
	    do_fio(&c__1, (char *)&ptoff, (ftnlen)sizeof(real));
#line 6302 ""
	    e_wsfi();
#line 6303 ""
	    lnote += 3;
#line 6304 ""
	} else if (ptoff < 99.95f) {
#line 6305 ""
	    i__1 = lnote;
#line 6305 ""
	    ici__1.icierr = 0;
#line 6305 ""
	    ici__1.icirnum = 1;
#line 6305 ""
	    ici__1.icirlen = lnote + 4 - i__1;
#line 6305 ""
	    ici__1.iciunit = notexq + i__1;
#line 6305 ""
	    ici__1.icifmt = "(f4.1)";
#line 6305 ""
	    s_wsfi(&ici__1);
#line 6305 ""
	    do_fio(&c__1, (char *)&ptoff, (ftnlen)sizeof(real));
#line 6305 ""
	    e_wsfi();
#line 6306 ""
	    lnote += 4;
#line 6307 ""
	} else {
#line 6308 ""
	    i__1 = lnote;
#line 6308 ""
	    ici__1.icierr = 0;
#line 6308 ""
	    ici__1.icirnum = 1;
#line 6308 ""
	    ici__1.icirlen = lnote + 5 - i__1;
#line 6308 ""
	    ici__1.iciunit = notexq + i__1;
#line 6308 ""
	    ici__1.icifmt = "(f5.1)";
#line 6308 ""
	    s_wsfi(&ici__1);
#line 6308 ""
	    do_fio(&c__1, (char *)&ptoff, (ftnlen)sizeof(real));
#line 6308 ""
	    e_wsfi();
#line 6309 ""
	    lnote += 5;
#line 6310 ""
	}
/* Writing concatenation */
#line 6311 ""
	i__2[0] = lnote, a__1[0] = notexq;
#line 6311 ""
	i__2[1] = 3, a__1[1] = "pt}";
#line 6311 ""
	s_cat(ch__18, a__1, i__2, &c__2, (ftnlen)82);
#line 6311 ""
	i__1 = lnote + 3;
#line 6311 ""
	addstr_(ch__18, &i__1, soutq, lsout, lnote + 3, (ftnlen)80);
#line 6312 ""
	if (isgaft && ! iswaft) {
/* Writing concatenation */
#line 6312 ""
	    i__2[0] = 1, a__1[0] = sq;
#line 6312 ""
	    i__2[1] = 2, a__1[1] = "sk";
#line 6312 ""
	    s_cat(ch__19, a__1, i__2, &c__2, (ftnlen)3);
#line 6312 ""
	    addstr_(ch__19, &c__3, soutq, lsout, (ftnlen)3, (ftnlen)80);
#line 6312 ""
	}
/* Writing concatenation */
#line 6313 ""
	i__2[0] = 1, a__1[0] = sq;
#line 6313 ""
	i__2[1] = 9, a__1[1] = "resetsize";
#line 6313 ""
	s_cat(ch__20, a__1, i__2, &c__2, (ftnlen)10);
#line 6313 ""
	addstr_(ch__20, &c__10, soutq, lsout, (ftnlen)10, (ftnlen)80);
#line 6314 ""
    }
#line 6315 ""
    return 0;
} /* dograce_ */

/* Subroutine */ int dopsslur_(integer *nolev, integer *isdat1, integer *
	isdat2, integer *isdat3, integer *isdat4, integer *nsdat, integer *ip,
	 integer *iv, integer *kv, integer *nv, logical *beamon, integer *ncm,
	 char *soutq, integer *lsout, char *ulq, integer *islur, integer *ipl,
	 integer *iornq, integer *islhgt, real *tno, integer *nacc, ftnlen 
	soutq_len, ftnlen ulq_len)
{
    /* System generated locals */
    address a__1[3], a__2[4], a__3[2];
    integer i__1, i__2, i__3[3], i__4[4], i__5[2], i__6;
    char ch__1[1], ch__2[1], ch__3[6], ch__4[9];
    icilist ici__1;

    /* Builtin functions */
    integer s_wsle(cilist *), e_wsle(void), do_lio(integer *, integer *, char 
	    *, ftnlen), s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), 
	    e_wsfe(void);
    /* Subroutine */ int s_copy(char *, char *, ftnlen, ftnlen), s_cat(char *,
	     char **, integer *, integer *, ftnlen);
    integer s_wsfi(icilist *), e_wsfi(void);

    /* Local variables */
    static integer ivoffinc;
    extern integer igetbits_(integer *, integer *, integer *);
    static integer j, icm;
    extern integer log2_(integer *);
    static integer imid;
    extern /* Character */ VOID chax_(char *, ftnlen, integer *), udfq_(char *
	    , ftnlen, integer *, integer *), udqq_(char *, ftnlen, integer *, 
	    integer *, integer *, integer *, integer *, integer *);
    extern integer lfmt1_(real *);
    extern /* Subroutine */ int stop1_(void);
    static integer ihoff;
    static logical iscrd;
    static integer isdat, ivoff;
    static real shift;
    static integer iupdn, lform, lnote;
    static logical pstie;
    static char noteq[8];
    static integer idcode, isdata;
    extern /* Subroutine */ int addstr_(char *, integer *, char *, integer *, 
	    ftnlen, ftnlen);
    static logical settie;
    extern /* Subroutine */ int notefq_(char *, integer *, integer *, integer 
	    *, ftnlen);
    static integer lnoten, nolevs;
    static logical stemup;
    static char notexq[79];
    extern /* Subroutine */ int setbits_(integer *, integer *, integer *, 
	    integer *);
    static integer numdrop;
    static char slurudq[1];

    /* Fortran I/O blocks */
    static cilist io___478 = { 0, 6, 0, 0, 0 };
    static cilist io___479 = { 0, 6, 0, 0, 0 };
    static cilist io___480 = { 0, 15, 0, "(/,a)", 0 };
    static cilist io___488 = { 0, 6, 0, 0, 0 };



/*  Called once per main note. */
/*  12 May 2002  Create this subroutine to isolate postscript slurs/ties. */
/*    Always set \Nosluradjust\Notieadjust */

/* 130316 */

/*  Bits in isdat1: */
/*  13-17    iv */
/*  3-10     ip */
/*  11       start/stop switch */
/*  12       kv-1 */
/*  19-25    ichar(code$) */
/*  26       force direction? */
/*  27       forced dir'n = up if on, set in sslur; also */
/*           final direction, set in doslur when beam is started, used on term. */
/*  28-31    mod(ndxslur,16), set in doslur when slur is started, used on term. */
/*  18       int(ndxslur/16), ditto. So this allows ndxslur>15. */
/*  2        stem slur flag */
/*  1        flag for "x" slur (voice-independent) */

/*  Bits in isdat2 */
/*  0        Chord switch.  Not set on main note. */
/*  1-2      left/right notehead shift.  Set only for chord note. */
/*  3        tie positioning */
/*  4        dotted flag */
/*  6-11     voff1 1-63  =>  -31...+31 */
/*  12-18    hoff1 1-127 => -6.3...+6.3 */
/*  19-25    nolev */
/*  26       \sluradjust    (p+s) */
/*  27       \nosluradjust  (p-s) */
/*  28       \tieadjust     (p+t) */
/*  29       \notieadjust   (p-t) */

/*  Bits in isdat3: Only used for slur endings */
/*  0        set if midslur (at least one argument) */
/*  1        set if curve (2 more args) */
/*  2-7      32+first arg (height correction) (1st arg may be negative) */
/*  8-10     second arg (initial slope) */
/*  11-13    third arg (closing slope) */
/*  14-21    tie level for use in LineBreakTies */
/*  22-29    ncm for use in LineBreakTies */

/*  Bits in isdat4  Only used for linebreak slurs */
/*  0-5      Linebreak seg 1 voff 1-63  =>  -31...+31 */
/*  6-12     Linebreak seg 1 hoff 1-127 => -6.3...+6.3 */
/*  16-21    Linebreak seg 2 voff 1-63  =>  -31...+31 */
/*  22-28    Linebreak seg 2 hoff 1-127 => -6.3...+6.3 */

/*  In listslur bit ib is on if slur index ib is in use, ib=0-13. */
/*  ndxslur = slur index */
/*  Height of slur is nole+ivoff+iupdn.  iupdn is +/-1 if t&s slurs on same note, */
/*  s-slur is blank (idcode=32), t-slur is idcode=1. */
/*  ivoff is user-defined shift or shift due to . or _ , or chord adjustment. */
/*  Ivoff will be set for ./_ only if no user-defined shift is specified. */
/*  If highest note has upslur, save slur height in islhgt in case */
/*  ornament must be moved. */

#line 6412 ""
    /* Parameter adjustments */
#line 6412 ""
    --isdat4;
#line 6412 ""
    --isdat3;
#line 6412 ""
    --isdat2;
#line 6412 ""
    --isdat1;
#line 6412 ""

#line 6412 ""
    /* Function Body */
#line 6412 ""
    *islhgt = 0;
#line 6413 ""
    if (*beamon) {
#line 6414 ""
	stemup = *(unsigned char *)ulq == 'u';
#line 6415 ""
    } else if (commvl_1.nvmx[*iv - 1] == 2) {
#line 6416 ""
	if (! bit_test(*islur,30)) {

/*  Single note, 2 lines of music, stem direction not forced */

#line 6420 ""
	    stemup = commvl_1.ivx > *nv;
#line 6421 ""
	} else {
#line 6422 ""
	    stemup = bit_test(*islur,17);
#line 6423 ""
	}
#line 6424 ""
    } else {
#line 6425 ""
	udqq_(ch__1, (ftnlen)1, nolev, ncm, islur, &commvl_1.nvmx[*iv - 1], &
		commvl_1.ivx, nv);
#line 6425 ""
	stemup = *(unsigned char *)&ch__1[0] == 'u';
#line 6426 ""
    }
#line 6427 ""
    iscrd = bit_test(*ipl,10);
#line 6428 ""
    if (commidi_1.ismidi) {
#line 6429 ""
	settie = FALSE_;
#line 6430 ""
	comslm_1.dbltie = FALSE_;
#line 6431 ""
    }
#line 6432 ""
    i__1 = *nsdat;
#line 6432 ""
    for (isdat = 1; isdat <= i__1; ++isdat) {
#line 6433 ""
	isdata = isdat1[isdat];
#line 6434 ""
	if (*iv == igetbits_(&isdata, &c__5, &c__13) && *ip == igetbits_(&
		isdata, &c__8, &c__3) && (*kv == igetbits_(&isdata, &c__1, &
		c__12) + 1 || bit_test(isdata,1))) {
/*     *            kv .eq. igetbits(isdata,1,12)+1) then */

/*  Since iv and kv match, ivx will be correct */

#line 6442 ""
	    idcode = igetbits_(&isdata, &c__7, &c__19);
#line 6443 ""
	    ivoff = igetbits_(&isdat2[isdat], &c__6, &c__6) - 32;
#line 6444 ""
	    ihoff = igetbits_(&isdat2[isdat], &c__7, &c__12) - 64;
#line 6445 ""
	    iupdn = 0;
#line 6446 ""
	    *(unsigned char *)slurudq = 'd';
#line 6447 ""
	    nolevs = igetbits_(&isdat2[isdat], &c__7, &c__19);
#line 6448 ""
	    pstie = bit_test(isdat2[isdat],3) || idcode == 1;
#line 6449 ""
	    if (bit_test(isdata,11)) {

/*  Turnon */
/*  Get slur direction */

#line 6454 ""
		if (bit_test(isdata,26)) {

/*  Force slur direction */

#line 6458 ""
		    if (bit_test(isdata,27)) {
#line 6458 ""
			*(unsigned char *)slurudq = 'u';
#line 6458 ""
		    }
#line 6459 ""
		} else if (commvl_1.nvmx[*iv - 1] == 1) {

/*  Only one voice per line */

#line 6463 ""
		    if (! (*beamon)) {

/*  Separate note. */

#line 6467 ""
			udfq_(ch__1, (ftnlen)1, nolev, ncm);
#line 6467 ""
			*(unsigned char *)slurudq = *(unsigned char *)&ch__1[
				0];
#line 6468 ""
		    } else {

/*  In a beam */

#line 6472 ""
			if (*(unsigned char *)ulq != 'u') {
#line 6472 ""
			    *(unsigned char *)slurudq = 'u';
#line 6472 ""
			}
#line 6473 ""
		    }
#line 6474 ""
		    if (iscrd) {
#line 6475 ""
			if (nolevs > *ncm) {
#line 6476 ""
			    *(unsigned char *)slurudq = 'u';
#line 6477 ""
			} else {
#line 6478 ""
			    *(unsigned char *)slurudq = 'd';
#line 6479 ""
			}
#line 6480 ""
		    }
#line 6481 ""
		} else {

/*  Two voices per line.  Get default */

#line 6485 ""
		    if (commvl_1.ivx > *nv) {
#line 6485 ""
			*(unsigned char *)slurudq = 'u';
#line 6485 ""
		    }

/*  Upper voice of the two, so up slur */

#line 6489 ""
		}
#line 6490 ""
		if (bit_test(isdata,2)) {

/*  ADjust for stem slur. ASSUME this is the ONLY pos'n adjustment. */

#line 6494 ""
		    if (stemup) {
#line 6495 ""
			*(unsigned char *)slurudq = 'u';
#line 6496 ""
			ivoff += 4;
#line 6497 ""
		    } else {
#line 6498 ""
			*(unsigned char *)slurudq = 'd';
#line 6499 ""
			ivoff += -4;
#line 6500 ""
		    }
#line 6501 ""
		}

/*  Set level for slur starting on rest */

#line 6505 ""
		if (nolevs == 0 || nolevs > 60) {
#line 6506 ""
		    if (*(unsigned char *)slurudq == 'u') {
#line 6507 ""
			nolevs = *ncm + 2;
#line 6508 ""
		    } else {
#line 6509 ""
			nolevs = *ncm - 2;
#line 6510 ""
		    }
#line 6511 ""
		}

/*  Save up/down-ness for use at termination */

#line 6515 ""
		if (*(unsigned char *)slurudq == 'u') {
#line 6515 ""
		    isdata = bit_set(isdata,27);
#line 6515 ""
		}

/*  End of section for setting slur direction, still in "Turnon" if-block. */

#line 6519 ""
		if (bit_test(*iornq,11) || bit_test(*iornq,12)) {

/*  Raise or lower slur by one unit provided . or _ is on same side as slur */

#line 6523 ""
		    ivoffinc = 0;
#line 6524 ""
		    if (stemup && *(unsigned char *)slurudq == 'd' || ! 
			    stemup && *(unsigned char *)slurudq == 'u') {

/*  Must move the slur for _ or . */

#line 6529 ""
			if (stemup) {
#line 6530 ""
			    ivoffinc = -1;
#line 6531 ""
			} else {
#line 6532 ""
			    ivoffinc = 1;
#line 6533 ""
			}
#line 6534 ""
			if ((stemup && *nolev >= *ncm - 2 || ! stemup && *
				nolev <= *ncm + 2) && (i__2 = *ncm - *nolev, 
				abs(i__2)) % 2 == 0) {
#line 6534 ""
			    ivoffinc <<= 1;
#line 6534 ""
			}
#line 6537 ""
			ivoff += ivoffinc;
#line 6538 ""
		    }
#line 6539 ""
		}
#line 6540 ""
		if (comslur_1.listslur == 16777215) {
#line 6541 ""
		    s_wsle(&io___478);
#line 6541 ""
		    e_wsle();
#line 6542 ""
		    s_wsle(&io___479);
#line 6542 ""
		    do_lio(&c__9, &c__1, "You1 defined the twentyfifth slur,"\
			    " one too many!", (ftnlen)48);
#line 6542 ""
		    e_wsle();
#line 6543 ""
		    s_wsfe(&io___480);
#line 6543 ""
		    do_fio(&c__1, "You defined the twentyfifth slur, one too"\
			    " many!", (ftnlen)47);
#line 6543 ""
		    e_wsfe();
#line 6545 ""
		    stop1_();
#line 6546 ""
		}

/*  Get index of next slur not in use, starting from 12 down */

#line 6550 ""
		i__2 = 16777215 - comslur_1.listslur;
#line 6550 ""
		comslur_1.ndxslur = log2_(&i__2);

/*  Record slur index */

#line 6554 ""
		comslur_1.listslur = bit_set(comslur_1.listslur,
			comslur_1.ndxslur);

/*  Save for use on termination */
/*  080531  Allow >16 slurs */
#line 6558 ""
		i__2 = comslur_1.ndxslur % 16;
#line 6558 ""
		setbits_(&isdata, &c__4, &c__28, &i__2);
#line 6559 ""
		i__2 = comslur_1.ndxslur / 16;
#line 6559 ""
		setbits_(&isdata, &c__1, &c__18, &i__2);

/*  Shift for stem? */

#line 6563 ""
		if (stemup && *(unsigned char *)slurudq == 'u' && *tno < 63.f)
			 {
#line 6564 ""
		    if (! pstie) {
#line 6565 ""
			ihoff += 8;
#line 6566 ""
		    } else {
#line 6567 ""
			ihoff += 2;
#line 6568 ""
		    }
#line 6569 ""
		}
#line 6570 ""
		if (iscrd) {

/*  Additional horiz shifts for h-shifted noteheads? */

#line 6574 ""
		    if (bit_test(isdat2[isdat],1)) {

/*  Slur start on left-shifted chord notehead.  ASSUME downstem. */

#line 6578 ""
			if (nolevs == comtrill_1.minlev && *(unsigned char *)
				slurudq == 'd') {
#line 6579 ""
			    ihoff += -2;
#line 6580 ""
			} else {
#line 6581 ""
			    ihoff += -10;
#line 6582 ""
			}
#line 6583 ""
		    } else if (bit_test(isdat2[isdat],2)) {

/*  Right shifted chord notehead.  ASSUME upstem. */

#line 6587 ""
			if (nolevs == comtrill_1.maxlev && *(unsigned char *)
				slurudq == 'u') {
#line 6588 ""
			    ihoff += 2;
#line 6589 ""
			} else {
#line 6590 ""
			    ihoff += 10;
#line 6591 ""
			}
#line 6592 ""
		    }
#line 6593 ""
		}
#line 6594 ""
		chax_(ch__1, (ftnlen)1, &c__92);
#line 6594 ""
		s_copy(notexq, ch__1, (ftnlen)79, (ftnlen)1);
#line 6595 ""
		lnote = 1;

/*  Check for local adjustment default changes */

#line 6599 ""
		if (bit_test(isdat2[isdat],26)) {
/* Writing concatenation */
#line 6600 ""
		    chax_(ch__1, (ftnlen)1, &c__92);
#line 6600 ""
		    i__3[0] = 1, a__1[0] = ch__1;
#line 6600 ""
		    i__3[1] = 10, a__1[1] = "sluradjust";
#line 6600 ""
		    chax_(ch__2, (ftnlen)1, &c__92);
#line 6600 ""
		    i__3[2] = 1, a__1[2] = ch__2;
#line 6600 ""
		    s_cat(notexq, a__1, i__3, &c__3, (ftnlen)79);
#line 6601 ""
		    lnote = 12;
#line 6602 ""
		} else if (bit_test(isdat2[isdat],27)) {
/* Writing concatenation */
#line 6603 ""
		    chax_(ch__1, (ftnlen)1, &c__92);
#line 6603 ""
		    i__3[0] = 1, a__1[0] = ch__1;
#line 6603 ""
		    i__3[1] = 12, a__1[1] = "nosluradjust";
#line 6603 ""
		    chax_(ch__2, (ftnlen)1, &c__92);
#line 6603 ""
		    i__3[2] = 1, a__1[2] = ch__2;
#line 6603 ""
		    s_cat(notexq, a__1, i__3, &c__3, (ftnlen)79);
#line 6604 ""
		    lnote = 14;
#line 6605 ""
		} else if (bit_test(isdat2[isdat],28)) {
/* Writing concatenation */
#line 6606 ""
		    chax_(ch__1, (ftnlen)1, &c__92);
#line 6606 ""
		    i__3[0] = 1, a__1[0] = ch__1;
#line 6606 ""
		    i__3[1] = 9, a__1[1] = "tieadjust";
#line 6606 ""
		    chax_(ch__2, (ftnlen)1, &c__92);
#line 6606 ""
		    i__3[2] = 1, a__1[2] = ch__2;
#line 6606 ""
		    s_cat(notexq, a__1, i__3, &c__3, (ftnlen)79);
#line 6607 ""
		    lnote = 11;
#line 6608 ""
		} else if (bit_test(isdat2[isdat],29)) {
/* Writing concatenation */
#line 6609 ""
		    chax_(ch__1, (ftnlen)1, &c__92);
#line 6609 ""
		    i__3[0] = 1, a__1[0] = ch__1;
#line 6609 ""
		    i__3[1] = 11, a__1[1] = "notieadjust";
#line 6609 ""
		    chax_(ch__2, (ftnlen)1, &c__92);
#line 6609 ""
		    i__3[2] = 1, a__1[2] = ch__2;
#line 6609 ""
		    s_cat(notexq, a__1, i__3, &c__3, (ftnlen)79);
#line 6610 ""
		    lnote = 13;
#line 6611 ""
		}
#line 6612 ""
		if (ihoff == 0) {

/*  Write stuff for non-shifted start */

/* Writing concatenation */
#line 6616 ""
		    i__3[0] = lnote, a__1[0] = notexq;
#line 6616 ""
		    i__3[1] = 5, a__1[1] = "islur";
#line 6616 ""
		    i__3[2] = 1, a__1[2] = slurudq;
#line 6616 ""
		    s_cat(notexq, a__1, i__3, &c__3, (ftnlen)79);
#line 6617 ""
		    lnote += 6;
#line 6618 ""
		} else {
/* Writing concatenation */
#line 6619 ""
		    i__3[0] = lnote, a__1[0] = notexq;
#line 6619 ""
		    i__3[1] = 2, a__1[1] = "is";
#line 6619 ""
		    i__3[2] = 1, a__1[2] = slurudq;
#line 6619 ""
		    s_cat(notexq, a__1, i__3, &c__3, (ftnlen)79);
#line 6620 ""
		    lnote += 3;
#line 6621 ""
		}

/*  Prepend postscript tie switch */

#line 6625 ""
		if (pstie) {
/* Writing concatenation */
#line 6626 ""
		    chax_(ch__1, (ftnlen)1, &c__92);
#line 6626 ""
		    i__4[0] = 1, a__2[0] = ch__1;
#line 6626 ""
		    i__4[1] = 8, a__2[1] = "tieforis";
#line 6626 ""
		    i__4[2] = 1, a__2[2] = slurudq;
#line 6626 ""
		    i__4[3] = lnote, a__2[3] = notexq;
#line 6626 ""
		    s_cat(notexq, a__2, i__4, &c__4, (ftnlen)79);
#line 6627 ""
		    lnote += 10;
#line 6628 ""
		}
#line 6629 ""
		if (bit_test(isdat2[isdat],4)) {

/*  Dotted slur */

/* Writing concatenation */
#line 6633 ""
		    chax_(ch__1, (ftnlen)1, &c__92);
#line 6633 ""
		    i__3[0] = 1, a__1[0] = ch__1;
#line 6633 ""
		    i__3[1] = 6, a__1[1] = "dotted";
#line 6633 ""
		    i__3[2] = lnote, a__1[2] = notexq;
#line 6633 ""
		    s_cat(notexq, a__1, i__3, &c__3, (ftnlen)79);
#line 6634 ""
		    lnote += 7;
#line 6635 ""
		}

/*  Add slur index to string */
/*  Print 23-ndxslur */

#line 6640 ""
		if (23 - comslur_1.ndxslur < 10) {

/*  5/25/08 Allow 24 slurs */

/* Writing concatenation */
#line 6644 ""
		    i__5[0] = lnote, a__3[0] = notexq;
#line 6644 ""
		    i__2 = 71 - comslur_1.ndxslur;
#line 6644 ""
		    chax_(ch__1, (ftnlen)1, &i__2);
#line 6644 ""
		    i__5[1] = 1, a__3[1] = ch__1;
#line 6644 ""
		    s_cat(notexq, a__3, i__5, &c__2, (ftnlen)79);
#line 6645 ""
		    ++lnote;
#line 6646 ""
		} else if (23 - comslur_1.ndxslur < 20) {
/* Writing concatenation */
#line 6647 ""
		    i__4[0] = lnote, a__2[0] = notexq;
#line 6647 ""
		    i__4[1] = 2, a__2[1] = "{1";
#line 6647 ""
		    i__2 = 61 - comslur_1.ndxslur;
#line 6647 ""
		    chax_(ch__1, (ftnlen)1, &i__2);
#line 6647 ""
		    i__4[2] = 1, a__2[2] = ch__1;
#line 6647 ""
		    i__4[3] = 1, a__2[3] = "}";
#line 6647 ""
		    s_cat(notexq, a__2, i__4, &c__4, (ftnlen)79);
#line 6648 ""
		    lnote += 4;
#line 6649 ""
		} else {
/* Writing concatenation */
#line 6650 ""
		    i__4[0] = lnote, a__2[0] = notexq;
#line 6650 ""
		    i__4[1] = 2, a__2[1] = "{2";
#line 6650 ""
		    i__2 = 51 - comslur_1.ndxslur;
#line 6650 ""
		    chax_(ch__1, (ftnlen)1, &i__2);
#line 6650 ""
		    i__4[2] = 1, a__2[2] = ch__1;
#line 6650 ""
		    i__4[3] = 1, a__2[3] = "}";
#line 6650 ""
		    s_cat(notexq, a__2, i__4, &c__4, (ftnlen)79);
#line 6651 ""
		    lnote += 4;
#line 6652 ""
		}

/*  Add note name to string */

#line 6656 ""
		*islhgt = nolevs + iupdn + ivoff;
#line 6657 ""
		notefq_(noteq, &lnoten, islhgt, ncm, (ftnlen)8);
/* Writing concatenation */
#line 6658 ""
		i__5[0] = lnote, a__3[0] = notexq;
#line 6658 ""
		i__5[1] = lnoten, a__3[1] = noteq;
#line 6658 ""
		s_cat(notexq, a__3, i__5, &c__2, (ftnlen)79);
#line 6659 ""
		lnote += lnoten;

/*  Store height and staff mid level for use with LineBreakTies */

#line 6663 ""
		setbits_(&isdat3[isdat], &c__8, &c__14, islhgt);
#line 6664 ""
		setbits_(&isdat3[isdat], &c__8, &c__22, ncm);

/*  Save height (for ornament and barnobox interference) if topmost slur is up */

#line 6668 ""
		if (*(unsigned char *)slurudq == 'u' && (! bit_test(isdat2[
			isdat],0) || nolevs == comtrill_1.maxlev)) {
#line 6670 ""
		    *islhgt = nolevs + iupdn + ivoff;

/*  Save height & idcode if top voice and slur start */

#line 6674 ""
		    if (commvl_1.ivx == commvl_1.ivmx[*nv + commvl_1.nvmx[*nv 
			    - 1] * 24 - 25] && *islhgt > comsln_1.is1n1) {
#line 6675 ""
			comsln_1.is1n1 = *islhgt;
#line 6676 ""
			comsln_1.is2n1 = idcode;
#line 6677 ""
		    }
#line 6678 ""
		}
#line 6679 ""
		if ((real) ihoff != 0.f) {
#line 6680 ""
		    shift = ihoff * .1f;
/* Writing concatenation */
#line 6681 ""
		    i__5[0] = lnote, a__3[0] = notexq;
#line 6681 ""
		    i__5[1] = 1, a__3[1] = "{";
#line 6681 ""
		    s_cat(notexq, a__3, i__5, &c__2, (ftnlen)79);
#line 6682 ""
		    ++lnote;
#line 6683 ""
		    lform = lfmt1_(&shift);
#line 6684 ""
		    i__2 = lnote;
#line 6684 ""
		    ici__1.icierr = 0;
#line 6684 ""
		    ici__1.icirnum = 1;
#line 6684 ""
		    ici__1.icirlen = lnote + lform - i__2;
#line 6684 ""
		    ici__1.iciunit = notexq + i__2;
/* Writing concatenation */
#line 6684 ""
		    i__3[0] = 2, a__1[0] = "(f";
#line 6684 ""
		    i__6 = lform + 48;
#line 6684 ""
		    chax_(ch__1, (ftnlen)1, &i__6);
#line 6684 ""
		    i__3[1] = 1, a__1[1] = ch__1;
#line 6684 ""
		    i__3[2] = 3, a__1[2] = ".1)";
#line 6684 ""
		    ici__1.icifmt = (s_cat(ch__3, a__1, i__3, &c__3, (ftnlen)
			    6), ch__3);
#line 6684 ""
		    s_wsfi(&ici__1);
#line 6684 ""
		    do_fio(&c__1, (char *)&shift, (ftnlen)sizeof(real));
#line 6684 ""
		    e_wsfi();
#line 6686 ""
		    lnote += lform;
/* Writing concatenation */
#line 6687 ""
		    i__5[0] = lnote, a__3[0] = notexq;
#line 6687 ""
		    i__5[1] = 1, a__3[1] = "}";
#line 6687 ""
		    s_cat(notexq, a__3, i__5, &c__2, (ftnlen)79);
#line 6688 ""
		    ++lnote;
#line 6689 ""
		}
#line 6690 ""
		addstr_(notexq, &lnote, soutq, lsout, (ftnlen)79, (ftnlen)80);

/*  Zero out ip1 to avoid problems if slur goes to next input blk. */

#line 6694 ""
		setbits_(&isdata, &c__8, &c__3, &c__0);

/*  Set slur-on data for midi.  Only treat null-index slurs and ps ties for now. */

#line 6698 ""
		if (commidi_1.ismidi && (idcode == 32 || idcode == 1)) {
/*              levson(midchan(iv,kv)) = nolevs */
/* 130316 */
#line 6701 ""
		    comslm_1.levson[commidi_1.midchan[*iv + *kv * 24 - 25]] = 
			    nolevs + commvel_1.miditran[cominsttrans_1.instno[
			    *iv - 1] - 1];
#line 6702 ""
		    if (settie) {
#line 6702 ""
			comslm_1.dbltie = TRUE_;
#line 6702 ""
		    }

/*  Only way settie=T is if we just set a tie ending.  So there's also a slur */
/*   start here, so set a flag telling addmidi not to zero out levson */

#line 6707 ""
		}
#line 6708 ""
	    } else {

/*  Slur is ending.  Back thru list to find starting slur */

#line 6712 ""
		for (j = isdat - 1; j >= 1; --j) {
#line 6713 ""
		    if (*iv == igetbits_(&isdat1[j], &c__5, &c__13) && (*kv ==
			     igetbits_(&isdat1[j], &c__1, &c__12) + 1 || 
			    bit_test(isdat1[j],1))) {
/*     *            kv.eq.igetbits(isdat1(j),1,12)+1) then */
#line 6717 ""
			if (idcode == igetbits_(&isdat1[j], &c__7, &c__19)) {
#line 6718 ""
			    comslur_1.ndxslur = igetbits_(&isdat1[j], &c__4, &
				    c__28) + (igetbits_(&isdat1[j], &c__1, &
				    c__18) << 4);

/*  080531 Allow >16 slurs */

#line 6723 ""
			    if (bit_test(isdat1[j],27)) {
#line 6723 ""
				*(unsigned char *)slurudq = 'u';
#line 6723 ""
			    }
#line 6724 ""
			    goto L4;
#line 6725 ""
			}
#line 6726 ""
		    }
#line 6727 ""
/* L3: */
#line 6727 ""
		}
#line 6728 ""
		s_wsle(&io___488);
#line 6728 ""
		do_lio(&c__9, &c__1, "Bad place in doslur", (ftnlen)19);
#line 6728 ""
		e_wsle();
#line 6729 ""
		stop1_();
#line 6730 ""
L4:

/*  Bugfix 070901 for slur ending on rest in 2-voice staff */

#line 6734 ""
		if (nolevs <= 2 || nolevs > 60) {

/*  Ending is on a rest, reset nolevs to default starting height */

#line 6738 ""
		    nolevs = igetbits_(&isdat2[j], &c__7, &c__19);
#line 6739 ""
		}
#line 6740 ""
		if (bit_test(isdat3[isdat],0) || bit_test(isdat3[j],0)) {

/*  Deal with \curve or \midslur. isdat is ending, j is start. */

#line 6744 ""
		    if (bit_test(isdat3[isdat],0)) {
#line 6745 ""
			imid = igetbits_(&isdat3[isdat], &c__6, &c__2) - 32;
#line 6746 ""
		    } else {
#line 6747 ""
			imid = igetbits_(&isdat3[j], &c__6, &c__2) - 32;
#line 6748 ""
		    }

/*  Postscript slurs, and \midslur adjustment is needed.  Invoke macro */
/*   (from pmx.tex) that redefines \tslur as r'qd.  Tentative mapping: */
/*       Abs(imid)  Postscript slur type */
/*          1          f */
/*          2-3        default */
/*          4          h */
/*          5          H */
/*          6+         HH */

/* Writing concatenation */
#line 6759 ""
		    chax_(ch__1, (ftnlen)1, &c__92);
#line 6759 ""
		    i__3[0] = 1, a__1[0] = ch__1;
#line 6759 ""
		    i__3[1] = 7, a__1[1] = "psforts";
/* Computing MIN */
#line 6759 ""
		    i__6 = abs(imid);
#line 6759 ""
		    i__2 = min(i__6,6) + 48;
#line 6759 ""
		    chax_(ch__2, (ftnlen)1, &i__2);
#line 6759 ""
		    i__3[2] = 1, a__1[2] = ch__2;
#line 6759 ""
		    s_cat(ch__4, a__1, i__3, &c__3, (ftnlen)9);
#line 6759 ""
		    addstr_(ch__4, &c__9, soutq, lsout, (ftnlen)9, (ftnlen)80)
			    ;
#line 6761 ""
		}
#line 6762 ""
		if (bit_test(isdata,2)) {

/*  ADjust for stem slur. */

#line 6766 ""
		    if (stemup) {
#line 6767 ""
			*(unsigned char *)slurudq = 'u';
#line 6768 ""
			ivoff += 4;
#line 6769 ""
		    } else {
#line 6770 ""
			*(unsigned char *)slurudq = 'd';
#line 6771 ""
			ivoff += -4;
#line 6772 ""
		    }
#line 6773 ""
		}

/*  Shift slur ending for stem on any note? */

#line 6777 ""
		if (! stemup && *(unsigned char *)slurudq == 'd' && *tno < 
			63.f) {
#line 6778 ""
		    if (! pstie) {
#line 6779 ""
			ihoff += -8;
#line 6780 ""
		    } else {
#line 6781 ""
			ihoff += -3;
#line 6782 ""
		    }
#line 6783 ""
		}
#line 6784 ""
		if (iscrd) {

/*  Shift termination for shifted notehead? */

#line 6788 ""
		    if (bit_test(isdat2[isdat],1)) {

/*  Left-shifted chord notehead.  ASSUME downstem. */

#line 6792 ""
			if (nolevs == comtrill_1.minlev && *(unsigned char *)
				slurudq == 'd') {
#line 6793 ""
			    ihoff += -2;
#line 6794 ""
			} else {
#line 6795 ""
			    ihoff += -10;
#line 6796 ""
			}
#line 6797 ""
		    } else if (bit_test(isdat2[isdat],2)) {

/*  Right shifted chord notehead.  ASSUME upstem. */

#line 6801 ""
			if (nolevs == comtrill_1.maxlev && *(unsigned char *)
				slurudq == 'u') {
#line 6802 ""
			    ihoff += 2;
#line 6803 ""
			} else {
#line 6804 ""
			    ihoff += 10;
#line 6805 ""
			}
#line 6806 ""
		    }
#line 6807 ""
		}
#line 6808 ""
		if (ihoff == 0) {
/* Writing concatenation */
#line 6809 ""
		    chax_(ch__1, (ftnlen)1, &c__92);
#line 6809 ""
		    i__5[0] = 1, a__3[0] = ch__1;
#line 6809 ""
		    i__5[1] = 5, a__3[1] = "tslur";
#line 6809 ""
		    s_cat(notexq, a__3, i__5, &c__2, (ftnlen)79);
#line 6810 ""
		    lnote = 6;
#line 6811 ""
		} else {

/*  Shift needed */

/* Writing concatenation */
#line 6815 ""
		    chax_(ch__1, (ftnlen)1, &c__92);
#line 6815 ""
		    i__5[0] = 1, a__3[0] = ch__1;
#line 6815 ""
		    i__5[1] = 2, a__3[1] = "ts";
#line 6815 ""
		    s_cat(notexq, a__3, i__5, &c__2, (ftnlen)79);
#line 6816 ""
		    lnote = 3;
#line 6817 ""
		}

/*  Switch to postscript tie */

#line 6821 ""
		if (pstie) {
/* Writing concatenation */
#line 6822 ""
		    chax_(ch__1, (ftnlen)1, &c__92);
#line 6822 ""
		    i__3[0] = 1, a__1[0] = ch__1;
#line 6822 ""
		    i__3[1] = 8, a__1[1] = "tieforts";
#line 6822 ""
		    i__3[2] = lnote, a__1[2] = notexq;
#line 6822 ""
		    s_cat(notexq, a__1, i__3, &c__3, (ftnlen)79);
#line 6823 ""
		    lnote += 9;
#line 6824 ""
		}

/*  Print 13-ndxslur */
/*  5/25/08 Allow 14 slurs */

#line 6829 ""
		if (23 - comslur_1.ndxslur < 10) {
/* Writing concatenation */
#line 6830 ""
		    i__5[0] = lnote, a__3[0] = notexq;
#line 6830 ""
		    i__2 = 71 - comslur_1.ndxslur;
#line 6830 ""
		    chax_(ch__1, (ftnlen)1, &i__2);
#line 6830 ""
		    i__5[1] = 1, a__3[1] = ch__1;
#line 6830 ""
		    s_cat(notexq, a__3, i__5, &c__2, (ftnlen)79);
#line 6831 ""
		    ++lnote;
#line 6832 ""
		} else if (23 - comslur_1.ndxslur < 20) {
/* Writing concatenation */
#line 6833 ""
		    i__4[0] = lnote, a__2[0] = notexq;
#line 6833 ""
		    i__4[1] = 2, a__2[1] = "{1";
#line 6833 ""
		    i__2 = 61 - comslur_1.ndxslur;
#line 6833 ""
		    chax_(ch__1, (ftnlen)1, &i__2);
#line 6833 ""
		    i__4[2] = 1, a__2[2] = ch__1;
#line 6833 ""
		    i__4[3] = 1, a__2[3] = "}";
#line 6833 ""
		    s_cat(notexq, a__2, i__4, &c__4, (ftnlen)79);
#line 6834 ""
		    lnote += 4;
#line 6835 ""
		} else {
/* Writing concatenation */
#line 6836 ""
		    i__4[0] = lnote, a__2[0] = notexq;
#line 6836 ""
		    i__4[1] = 2, a__2[1] = "{2";
#line 6836 ""
		    i__2 = 51 - comslur_1.ndxslur;
#line 6836 ""
		    chax_(ch__1, (ftnlen)1, &i__2);
#line 6836 ""
		    i__4[2] = 1, a__2[2] = ch__1;
#line 6836 ""
		    i__4[3] = 1, a__2[3] = "}";
#line 6836 ""
		    s_cat(notexq, a__2, i__4, &c__4, (ftnlen)79);
#line 6837 ""
		    lnote += 4;
#line 6838 ""
		}
#line 6839 ""
		if (bit_test(*iornq,11) || bit_test(*iornq,12)) {

/*  Raise or lower slur by one unit provided . or _ is on same side as slur */

#line 6843 ""
		    ivoffinc = 0;
#line 6844 ""
		    if (stemup && *(unsigned char *)slurudq == 'd' || ! 
			    stemup && *(unsigned char *)slurudq == 'u') {
#line 6846 ""
			if (stemup) {
#line 6847 ""
			    ivoffinc = -1;
#line 6848 ""
			} else {
#line 6849 ""
			    ivoffinc = 1;
#line 6850 ""
			}
#line 6851 ""
			if ((stemup && *nolev >= *ncm - 2 || ! stemup && *
				nolev <= *ncm + 2) && (i__2 = *ncm - *nolev, 
				abs(i__2)) % 2 == 0) {
#line 6851 ""
			    ivoffinc <<= 1;
#line 6851 ""
			}
#line 6854 ""
		    }
#line 6855 ""
		    ivoff += ivoffinc;
#line 6856 ""
		}
#line 6857 ""
		i__2 = nolevs + iupdn + ivoff;
#line 6857 ""
		notefq_(noteq, &lnoten, &i__2, ncm, (ftnlen)8);
#line 6858 ""
		if (*(unsigned char *)slurudq == 'u' && (! bit_test(isdat2[
			isdat],0) || nolevs == comtrill_1.maxlev)) {
#line 6860 ""
		    *islhgt = nolevs + iupdn + ivoff;

/*  If topvoice, upslur, and idcode checks, no more need to keep hgt for barno. */

#line 6864 ""
		    if (commvl_1.ivx == commvl_1.ivmx[*nv + commvl_1.nvmx[*nv 
			    - 1] * 24 - 25] && comsln_1.is1n1 > 0) {
#line 6865 ""
			if (idcode == comsln_1.is2n1) {
#line 6865 ""
			    comsln_1.is1n1 = 0;
#line 6865 ""
			}
#line 6866 ""
		    }
#line 6867 ""
		}
/* Writing concatenation */
#line 6868 ""
		i__5[0] = lnote, a__3[0] = notexq;
#line 6868 ""
		i__5[1] = lnoten, a__3[1] = noteq;
#line 6868 ""
		s_cat(notexq, a__3, i__5, &c__2, (ftnlen)79);
#line 6869 ""
		lnote += lnoten;
#line 6870 ""
		if (ihoff != 0) {
#line 6871 ""
		    shift = ihoff * .1f;
/* Writing concatenation */
#line 6872 ""
		    i__5[0] = lnote, a__3[0] = notexq;
#line 6872 ""
		    i__5[1] = 1, a__3[1] = "{";
#line 6872 ""
		    s_cat(notexq, a__3, i__5, &c__2, (ftnlen)79);
#line 6873 ""
		    ++lnote;
#line 6874 ""
		    lform = lfmt1_(&shift);
#line 6875 ""
		    i__2 = lnote;
#line 6875 ""
		    ici__1.icierr = 0;
#line 6875 ""
		    ici__1.icirnum = 1;
#line 6875 ""
		    ici__1.icirlen = lnote + lform - i__2;
#line 6875 ""
		    ici__1.iciunit = notexq + i__2;
/* Writing concatenation */
#line 6875 ""
		    i__3[0] = 2, a__1[0] = "(f";
#line 6875 ""
		    i__6 = lform + 48;
#line 6875 ""
		    chax_(ch__1, (ftnlen)1, &i__6);
#line 6875 ""
		    i__3[1] = 1, a__1[1] = ch__1;
#line 6875 ""
		    i__3[2] = 3, a__1[2] = ".1)";
#line 6875 ""
		    ici__1.icifmt = (s_cat(ch__3, a__1, i__3, &c__3, (ftnlen)
			    6), ch__3);
#line 6875 ""
		    s_wsfi(&ici__1);
#line 6875 ""
		    do_fio(&c__1, (char *)&shift, (ftnlen)sizeof(real));
#line 6875 ""
		    e_wsfi();
#line 6877 ""
		    lnote += lform;
/* Writing concatenation */
#line 6878 ""
		    i__5[0] = lnote, a__3[0] = notexq;
#line 6878 ""
		    i__5[1] = 1, a__3[1] = "}";
#line 6878 ""
		    s_cat(notexq, a__3, i__5, &c__2, (ftnlen)79);
#line 6879 ""
		    ++lnote;
#line 6880 ""
		}
#line 6881 ""
		addstr_(notexq, &lnote, soutq, lsout, (ftnlen)79, (ftnlen)80);

/*  Clear the bit from list of slurs in use */

#line 6885 ""
		comslur_1.listslur = bit_clear(comslur_1.listslur,
			comslur_1.ndxslur);

/*  Zero out the entire strings for start and stop */

#line 6889 ""
		isdata = 0;
#line 6890 ""
		isdat2[isdat] = 0;
#line 6891 ""
		isdat3[isdat] = 0;
#line 6892 ""
		isdat4[isdat] = 0;
#line 6893 ""
		isdat1[j] = 0;
#line 6894 ""
		isdat2[j] = 0;
#line 6895 ""
		isdat3[j] = 0;
#line 6896 ""
		isdat4[j] = 0;

/*  Set midi info for slur ending */

#line 6900 ""
		if (commidi_1.ismidi && (idcode == 32 || idcode == 1)) {
#line 6901 ""
		    icm = commidi_1.midchan[*iv + *kv * 24 - 25];
#line 6902 ""
		    if (comslm_1.slmon[icm]) {
#line 6903 ""
			if (nolevs + commvel_1.miditran[cominsttrans_1.instno[
				*iv - 1] - 1] == comslm_1.levson[icm] && (7 & 
				*nacc) == 0) {

/*  There is a tie here.  NB!!! assumed no accidental on 2nd member of tie. */

#line 6908 ""
			    comslm_1.levsoff[icm] = nolevs + 
				    commvel_1.miditran[cominsttrans_1.instno[*
				    iv - 1] - 1];
#line 6909 ""
			    settie = TRUE_;
#line 6910 ""
			} else {
#line 6911 ""
			    comslm_1.levsoff[icm] = 0;
#line 6912 ""
			    comslm_1.levson[icm] = 0;
#line 6913 ""
			    comslm_1.slmon[icm] = FALSE_;
#line 6914 ""
			}
#line 6915 ""
		    }
#line 6916 ""
		}
#line 6917 ""
	    }
#line 6918 ""
	    isdat1[isdat] = isdata;
#line 6919 ""
	}
#line 6920 ""
/* L1: */
#line 6920 ""
    }

/*  Clear and collapse the slur data list */

#line 6924 ""
    numdrop = 0;
#line 6925 ""
    i__1 = *nsdat;
#line 6925 ""
    for (isdat = 1; isdat <= i__1; ++isdat) {
#line 6926 ""
	if (isdat1[isdat] == 0) {
#line 6927 ""
	    ++numdrop;
#line 6928 ""
	} else if (numdrop > 0) {
#line 6929 ""
	    isdat1[isdat - numdrop] = isdat1[isdat];
#line 6930 ""
	    isdat2[isdat - numdrop] = isdat2[isdat];
#line 6931 ""
	    isdat3[isdat - numdrop] = isdat3[isdat];
#line 6932 ""
	    isdat4[isdat - numdrop] = isdat4[isdat];
#line 6933 ""
	    isdat1[isdat] = 0;
#line 6934 ""
	    isdat2[isdat] = 0;
#line 6935 ""
	    isdat3[isdat] = 0;
#line 6936 ""
	    isdat4[isdat] = 0;
#line 6937 ""
	}
#line 6938 ""
/* L2: */
#line 6938 ""
    }
#line 6939 ""
    *nsdat -= numdrop;
#line 6940 ""
    return 0;
} /* dopsslur_ */

/* Subroutine */ int doslur_(integer *nolev, integer *isdat1, integer *isdat2,
	 integer *isdat3, integer *nsdat, integer *ip, integer *iv, integer *
	kv, integer *nv, logical *beamon, integer *ncm, char *soutq, integer *
	lsout, char *ulq, integer *islur, integer *ipl, integer *iornq, 
	integer *islhgt, real *tno, integer *nacc, ftnlen soutq_len, ftnlen 
	ulq_len)
{
    /* System generated locals */
    address a__1[3], a__2[2], a__3[4];
    integer i__1, i__2, i__3[3], i__4[2], i__5[4], i__6;
    char ch__1[1], ch__2[6];
    icilist ici__1;

    /* Builtin functions */
    integer s_wsle(cilist *), e_wsle(void), do_lio(integer *, integer *, char 
	    *, ftnlen), s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), 
	    e_wsfe(void);
    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen),
	     s_copy(char *, char *, ftnlen, ftnlen);
    integer s_wsfi(icilist *), e_wsfi(void);

    /* Local variables */
    static integer ivoffinc;
    extern integer igetbits_(integer *, integer *, integer *);
    static integer j, icm;
    extern integer log2_(integer *);
    static integer imid;
    extern /* Character */ VOID chax_(char *, ftnlen, integer *), udfq_(char *
	    , ftnlen, integer *, integer *), udqq_(char *, ftnlen, integer *, 
	    integer *, integer *, integer *, integer *, integer *);
    extern integer lfmt1_(real *);
    extern /* Subroutine */ int stop1_(void);
    static integer ihoff;
    static logical iscrd;
    static integer isdat, ivoff;
    static real shift;
    static integer iupdn, lform, lnote;
    static char noteq[8];
    static logical tmove;
    static integer idcode, isdata;
    extern /* Subroutine */ int addstr_(char *, integer *, char *, integer *, 
	    ftnlen, ftnlen);
    static integer isdats;
    static logical settie, sfound, tfound;
    static integer isdatt;
    extern /* Subroutine */ int notefq_(char *, integer *, integer *, integer 
	    *, ftnlen);
    static integer nolevt, nolevs;
    extern /* Subroutine */ int printl_(char *, ftnlen);
    static logical stemup;
    static char notexq[79];
    static integer lnoten;
    extern /* Subroutine */ int setbits_(integer *, integer *, integer *, 
	    integer *);
    static integer numdrop;
    static char slurudq[1];

    /* Fortran I/O blocks */
    static cilist io___509 = { 0, 6, 0, 0, 0 };
    static cilist io___511 = { 0, 6, 0, 0, 0 };
    static cilist io___512 = { 0, 6, 0, 0, 0 };
    static cilist io___513 = { 0, 15, 0, "(/,a)", 0 };
    static cilist io___521 = { 0, 6, 0, 0, 0 };



/*  Called once per main note.  (5/26/02) for non-ps slurs only */

/* 130316 */

/*  Bits in isdat1: */
/*  13-17    iv */
/*  3-10     ip */
/*  11       start/stop switch */
/*  12       kv-1 */
/*  19-25    ichar(code$) */
/*  26       force direction? */
/*  27       forced dir'n = up if on, set in sslur; also */
/*           final direction, set in doslur when beam is started, used on term. */
/*  28-31    ndxslur, set in doslur when beam is started, used on term. */

/*  Bits in isdat2 */
/*  0        Chord switch.  Not set on main note. */
/*  1-2      left/right notehead shift.  Set only for chord note. */
/*  3        tie positioning */
/*  4        dotted flag */
/*  6-11     voff1 1-63  =>  -31...+31 */
/*  12-18    hoff1 1-127 => -6.3...+6.3 */
/*  19-25    nolev */

/*  Bits in isdat3: Only used for slur endings */
/*  0        set if midslur (at least one argument) */
/*  1        set if curve (2 more args) */
/*  2-7      32+first arg (height correction) (1st arg may be negative) */
/*  8-10     second arg (initial slope) */
/*  11-13    third arg (closing slope) */

/*  In listslur bit ib is on if slur index ib is in use, ib=0-23. */
/*  ndxslur = slur index */
/*  Height of slur is nole+ivoff+iupdn.  iupdn is +/-1 if t&s slurs on same note, */
/*  s-slur is blank (idcode=32), t-slur is idcode=1. */
/*  ivoff is user-defined shift or shift due to . or _ , or chord adjustment. */
/*  Ivoff will be set for ./_ only if no user-defined shift is specified. */
/*  If highest note has upslur, save slur height in islhgt in case */
/*  ornament must be moved. */

#line 7018 ""
    /* Parameter adjustments */
#line 7018 ""
    --isdat3;
#line 7018 ""
    --isdat2;
#line 7018 ""
    --isdat1;
#line 7018 ""

#line 7018 ""
    /* Function Body */
#line 7018 ""
    *islhgt = 0;
#line 7019 ""
    if (*beamon) {
#line 7020 ""
	stemup = *(unsigned char *)ulq == 'u';
#line 7021 ""
    } else if (commvl_1.nvmx[*iv - 1] == 2) {
#line 7022 ""
	if (! bit_test(*islur,30)) {

/*  Single note, 2 lines of music, stem direction not forced */

#line 7026 ""
	    stemup = commvl_1.ivx > *nv;
#line 7027 ""
	} else {
#line 7028 ""
	    stemup = bit_test(*islur,17);
#line 7029 ""
	}
#line 7030 ""
    } else {
#line 7031 ""
	udqq_(ch__1, (ftnlen)1, nolev, ncm, islur, &commvl_1.nvmx[*iv - 1], &
		commvl_1.ivx, nv);
#line 7031 ""
	stemup = *(unsigned char *)&ch__1[0] == 'u';
#line 7032 ""
    }
#line 7033 ""
    iscrd = bit_test(*ipl,10);
#line 7034 ""
    if (bit_test(*islur,1)) {

/*  't'-slur (idcode=1) somewhere on this note.  Find it, check height against */
/*    's'-slur (idcode=32) */

#line 7039 ""
	sfound = FALSE_;
#line 7040 ""
	tfound = FALSE_;
#line 7041 ""
	tmove = FALSE_;
#line 7042 ""
	i__1 = *nsdat;
#line 7042 ""
	for (isdat = 1; isdat <= i__1; ++isdat) {
#line 7043 ""
	    if (*iv == igetbits_(&isdat1[isdat], &c__5, &c__13) && *ip == 
		    igetbits_(&isdat1[isdat], &c__8, &c__3) && *kv == 
		    igetbits_(&isdat1[isdat], &c__1, &c__12) + 1) {
#line 7046 ""
		if (! tfound) {
#line 7047 ""
		    tfound = igetbits_(&isdat1[isdat], &c__7, &c__19) == 1;
#line 7048 ""
		    if (tfound) {
#line 7049 ""
			nolevt = igetbits_(&isdat2[isdat], &c__7, &c__19);
#line 7050 ""
			isdatt = isdat;
#line 7051 ""
			if (sfound) {
#line 7051 ""
			    goto L6;
#line 7051 ""
			}
#line 7052 ""
		    }
#line 7053 ""
		}
#line 7054 ""
		if (! sfound) {
#line 7055 ""
		    sfound = igetbits_(&isdat1[isdat], &c__7, &c__19) == 32;
#line 7056 ""
		    if (sfound) {
#line 7057 ""
			nolevs = igetbits_(&isdat2[isdat], &c__7, &c__19);
#line 7058 ""
			isdats = isdat;
#line 7059 ""
			if (tfound) {
#line 7059 ""
			    goto L6;
#line 7059 ""
			}
#line 7060 ""
		    }
#line 7061 ""
		}
#line 7062 ""
	    }
#line 7063 ""
/* L5: */
#line 7063 ""
	}

/*  Will come thru here if there is a t with no s, so comment out the following */
/*        print*,'Did not find s+t-slurs in doslur' */

#line 7068 ""
L6:
#line 7069 ""
	if (sfound && tfound) {
#line 7069 ""
	    tmove = nolevs == nolevt && (bit_test(isdat1[isdats],11) && 
		    bit_test(isdat1[isdatt],11) || ! bit_test(isdat1[isdats],
		    11) && ! bit_test(isdat1[isdatt],11));
#line 7069 ""
	}

/*  Check if 2 starts or two stops */


/*  This is a flag for later changing slur level, after we know slur dir'n. */

#line 7080 ""
    }
#line 7081 ""
    if (commidi_1.ismidi) {
#line 7082 ""
	settie = FALSE_;
#line 7083 ""
	comslm_1.dbltie = FALSE_;
#line 7084 ""
    }
#line 7085 ""
    i__1 = *nsdat;
#line 7085 ""
    for (isdat = 1; isdat <= i__1; ++isdat) {
#line 7086 ""
	isdata = isdat1[isdat];
#line 7087 ""
	if (*iv == igetbits_(&isdata, &c__5, &c__13) && *ip == igetbits_(&
		isdata, &c__8, &c__3) && *kv == igetbits_(&isdata, &c__1, &
		c__12) + 1) {

/*  Since iv and kv match, ivx will be correct */

#line 7093 ""
	    idcode = igetbits_(&isdata, &c__7, &c__19);
#line 7094 ""
	    ivoff = igetbits_(&isdat2[isdat], &c__6, &c__6) - 32;
#line 7095 ""
	    ihoff = igetbits_(&isdat2[isdat], &c__7, &c__12) - 64;
#line 7096 ""
	    iupdn = 0;
#line 7097 ""
	    *(unsigned char *)slurudq = 'd';
#line 7098 ""
	    nolevs = igetbits_(&isdat2[isdat], &c__7, &c__19);
#line 7099 ""
	    if (bit_test(isdata,11)) {

/*  Turnon, */

#line 7103 ""
		if (nolevs == 0 || nolevs > 60) {

/*  Note was a rest, cannot start slur on rest. */

#line 7107 ""
		    s_wsle(&io___509);
#line 7107 ""
		    e_wsle();
#line 7108 ""
		    printl_("Cannot start slur on a rest", (ftnlen)27);
#line 7109 ""
		    stop1_();
#line 7110 ""
		}

/*  Get slur direction */

#line 7114 ""
		if (bit_test(isdata,26)) {

/*  Force slur direction */

#line 7118 ""
		    if (bit_test(isdata,27)) {
#line 7118 ""
			*(unsigned char *)slurudq = 'u';
#line 7118 ""
		    }
#line 7119 ""
		} else if (commvl_1.nvmx[*iv - 1] == 1) {

/*  Only one voice per line */

#line 7123 ""
		    if (! (*beamon)) {

/*  Separate note. */

#line 7127 ""
			udfq_(ch__1, (ftnlen)1, nolev, ncm);
#line 7127 ""
			*(unsigned char *)slurudq = *(unsigned char *)&ch__1[
				0];
#line 7128 ""
		    } else {

/*  In a beam */

#line 7132 ""
			if (*(unsigned char *)ulq != 'u') {
#line 7132 ""
			    *(unsigned char *)slurudq = 'u';
#line 7132 ""
			}
#line 7133 ""
		    }
#line 7134 ""
		    if (iscrd) {
#line 7135 ""
			if (nolevs > *ncm) {
#line 7136 ""
			    *(unsigned char *)slurudq = 'u';
#line 7137 ""
			} else {
#line 7138 ""
			    *(unsigned char *)slurudq = 'd';
#line 7139 ""
			}
#line 7140 ""
		    }
#line 7141 ""
		} else {

/*  Two voices per line.  Get default */

#line 7145 ""
		    if (commvl_1.ivx > *nv) {
#line 7145 ""
			*(unsigned char *)slurudq = 'u';
#line 7145 ""
		    }

/*  Upper voice of the two, so up slur */

#line 7149 ""
		}

/*  Save up/down-ness for use at termination */

#line 7153 ""
		if (*(unsigned char *)slurudq == 'u') {
#line 7153 ""
		    isdata = bit_set(isdata,27);
#line 7153 ""
		}

/*  End of section for setting slur direction, still in "Turnon" if-block. */

#line 7157 ""
		if (idcode == 1 && tmove) {
#line 7158 ""
		    iupdn = 1;
#line 7159 ""
		    if (*(unsigned char *)slurudq == 'd') {
#line 7159 ""
			iupdn = -1;
#line 7159 ""
		    }
#line 7160 ""
		}
#line 7161 ""
		if (bit_test(*iornq,11) || bit_test(*iornq,12)) {

/*  Raise or lower slur by one unit provided . or _ is on same side as slur */

#line 7165 ""
		    ivoffinc = 0;
#line 7166 ""
		    if (stemup && *(unsigned char *)slurudq == 'd' || ! 
			    stemup && *(unsigned char *)slurudq == 'u') {

/*  Must move the slur for _ or . */

#line 7171 ""
			if (stemup) {
#line 7172 ""
			    ivoffinc = -1;
#line 7173 ""
			} else {
#line 7174 ""
			    ivoffinc = 1;
#line 7175 ""
			}
#line 7176 ""
			if ((stemup && *nolev >= *ncm - 2 || ! stemup && *
				nolev <= *ncm + 2) && (i__2 = *ncm - *nolev, 
				abs(i__2)) % 2 == 0) {
#line 7176 ""
			    ivoffinc <<= 1;
#line 7176 ""
			}
#line 7179 ""
			ivoff += ivoffinc;
#line 7180 ""
		    }
#line 7181 ""
		}
#line 7182 ""
		if (comslur_1.listslur == 16777215) {
#line 7183 ""
		    s_wsle(&io___511);
#line 7183 ""
		    e_wsle();
#line 7184 ""
		    s_wsle(&io___512);
#line 7184 ""
		    do_lio(&c__9, &c__1, "You1 defined the twenty-fifth slur"\
			    ", one too many!", (ftnlen)49);
#line 7184 ""
		    e_wsle();
#line 7185 ""
		    s_wsfe(&io___513);
#line 7185 ""
		    do_fio(&c__1, "You2 defined the twenty-fifth slur, one t"\
			    "oo many!", (ftnlen)49);
#line 7185 ""
		    e_wsfe();
#line 7187 ""
		    stop1_();
#line 7188 ""
		}

/*  Get index of next slur not in use, starting from ? down */

#line 7192 ""
		i__2 = 16777215 - comslur_1.listslur;
#line 7192 ""
		comslur_1.ndxslur = log2_(&i__2);

/*  Record slur index */

#line 7196 ""
		comslur_1.listslur = bit_set(comslur_1.listslur,
			comslur_1.ndxslur);

/*  Save for use on termination */
/*  080531  Allow >16 slurs */
#line 7200 ""
		i__2 = comslur_1.ndxslur % 16;
#line 7200 ""
		setbits_(&isdata, &c__4, &c__28, &i__2);
#line 7201 ""
		i__2 = comslur_1.ndxslur / 16;
#line 7201 ""
		setbits_(&isdata, &c__1, &c__18, &i__2);

/*  Shift for stem? */

#line 7205 ""
		if (stemup && *(unsigned char *)slurudq == 'u' && *tno < 63.f)
			 {
#line 7205 ""
		    ihoff += 8;
#line 7205 ""
		}
#line 7207 ""
		if (bit_test(isdat2[isdat],3)) {

/*  Tie spacing, (slur start) */

#line 7211 ""
		    if (*(unsigned char *)slurudq == 'd') {
#line 7212 ""
			++ivoff;
#line 7213 ""
			ihoff += 8;
#line 7214 ""
		    } else if (*(unsigned char *)slurudq == 'u') {
#line 7215 ""
			--ivoff;
#line 7216 ""
			if (! (stemup && *tno < 63.f)) {
#line 7216 ""
			    ihoff += 8;
#line 7216 ""
			}

/*  (already shifted if (stemup.and.tno.gt.63.) and slurudq='u') */

#line 7220 ""
		    }
#line 7221 ""
		}
#line 7222 ""
		if (iscrd) {

/*  Additional horiz shifts for h-shifted noteheads? */

#line 7226 ""
		    if (bit_test(isdat2[isdat],1)) {

/*  Slur start on left-shifted chord notehead.  ASSUME downstem. */

#line 7230 ""
			if (nolevs == comtrill_1.minlev && *(unsigned char *)
				slurudq == 'd') {
#line 7231 ""
			    ihoff += -2;
#line 7232 ""
			} else {
#line 7233 ""
			    ihoff += -10;
#line 7234 ""
			}
#line 7235 ""
		    } else if (bit_test(isdat2[isdat],2)) {

/*  Right shifted chord notehead.  ASSUME upstem. */

#line 7239 ""
			if (nolevs == comtrill_1.maxlev && *(unsigned char *)
				slurudq == 'u') {
#line 7240 ""
			    ihoff += 2;
#line 7241 ""
			} else {
#line 7242 ""
			    ihoff += 10;
#line 7243 ""
			}
#line 7244 ""
		    }
#line 7245 ""
		}
#line 7246 ""
		if (ihoff == 0) {

/*  Write stuff for non-shifted start */

/* Writing concatenation */
#line 7250 ""
		    chax_(ch__1, (ftnlen)1, &c__92);
#line 7250 ""
		    i__3[0] = 1, a__1[0] = ch__1;
#line 7250 ""
		    i__3[1] = 5, a__1[1] = "islur";
#line 7250 ""
		    i__3[2] = 1, a__1[2] = slurudq;
#line 7250 ""
		    s_cat(notexq, a__1, i__3, &c__3, (ftnlen)79);
#line 7251 ""
		    lnote = 7;
#line 7252 ""
		} else {
/* Writing concatenation */
#line 7253 ""
		    chax_(ch__1, (ftnlen)1, &c__92);
#line 7253 ""
		    i__3[0] = 1, a__1[0] = ch__1;
#line 7253 ""
		    i__3[1] = 2, a__1[1] = "is";
#line 7253 ""
		    i__3[2] = 1, a__1[2] = slurudq;
#line 7253 ""
		    s_cat(notexq, a__1, i__3, &c__3, (ftnlen)79);
#line 7254 ""
		    lnote = 4;
#line 7255 ""
		}
#line 7256 ""
		if (bit_test(isdat2[isdat],4)) {

/*  Dotted slur */

#line 7260 ""
		    s_copy(noteq, notexq, (ftnlen)8, (ftnlen)79);
/* Writing concatenation */
#line 7261 ""
		    chax_(ch__1, (ftnlen)1, &c__92);
#line 7261 ""
		    i__3[0] = 1, a__1[0] = ch__1;
#line 7261 ""
		    i__3[1] = 6, a__1[1] = "dotted";
#line 7261 ""
		    i__3[2] = 8, a__1[2] = noteq;
#line 7261 ""
		    s_cat(notexq, a__1, i__3, &c__3, (ftnlen)79);
#line 7262 ""
		    lnote += 7;
#line 7263 ""
		}

/*  Add slur index to string */
/*  Print 23-ndxslur */

#line 7268 ""
		if (23 - comslur_1.ndxslur < 10) {

/*  5/25/08 Allow 24 slurs */

/* Writing concatenation */
#line 7272 ""
		    i__4[0] = lnote, a__2[0] = notexq;
#line 7272 ""
		    i__2 = 71 - comslur_1.ndxslur;
#line 7272 ""
		    chax_(ch__1, (ftnlen)1, &i__2);
#line 7272 ""
		    i__4[1] = 1, a__2[1] = ch__1;
#line 7272 ""
		    s_cat(notexq, a__2, i__4, &c__2, (ftnlen)79);
#line 7273 ""
		    ++lnote;
#line 7274 ""
		} else if (23 - comslur_1.ndxslur < 20) {
/* Writing concatenation */
#line 7275 ""
		    i__5[0] = lnote, a__3[0] = notexq;
#line 7275 ""
		    i__5[1] = 2, a__3[1] = "{1";
#line 7275 ""
		    i__2 = 61 - comslur_1.ndxslur;
#line 7275 ""
		    chax_(ch__1, (ftnlen)1, &i__2);
#line 7275 ""
		    i__5[2] = 1, a__3[2] = ch__1;
#line 7275 ""
		    i__5[3] = 1, a__3[3] = "}";
#line 7275 ""
		    s_cat(notexq, a__3, i__5, &c__4, (ftnlen)79);
#line 7276 ""
		    lnote += 4;
#line 7277 ""
		} else {
/* Writing concatenation */
#line 7278 ""
		    i__5[0] = lnote, a__3[0] = notexq;
#line 7278 ""
		    i__5[1] = 2, a__3[1] = "{2";
#line 7278 ""
		    i__2 = 51 - comslur_1.ndxslur;
#line 7278 ""
		    chax_(ch__1, (ftnlen)1, &i__2);
#line 7278 ""
		    i__5[2] = 1, a__3[2] = ch__1;
#line 7278 ""
		    i__5[3] = 1, a__3[3] = "}";
#line 7278 ""
		    s_cat(notexq, a__3, i__5, &c__4, (ftnlen)79);
#line 7279 ""
		    lnote += 4;
#line 7280 ""
		}

/*  Add note name to string */

#line 7284 ""
		i__2 = nolevs + iupdn + ivoff;
#line 7284 ""
		notefq_(noteq, &lnoten, &i__2, ncm, (ftnlen)8);
/* Writing concatenation */
#line 7285 ""
		i__4[0] = lnote, a__2[0] = notexq;
#line 7285 ""
		i__4[1] = lnoten, a__2[1] = noteq;
#line 7285 ""
		s_cat(notexq, a__2, i__4, &c__2, (ftnlen)79);
#line 7286 ""
		lnote += lnoten;

/*  Save height (for ornament and barnobox interference) if topmost slur is up */

#line 7290 ""
		if (*(unsigned char *)slurudq == 'u' && (! bit_test(isdat2[
			isdat],0) || nolevs == comtrill_1.maxlev)) {
#line 7292 ""
		    *islhgt = nolevs + iupdn + ivoff;

/*  Save height & idcode if top voice and slur start */

#line 7296 ""
		    if (commvl_1.ivx == commvl_1.ivmx[*nv + commvl_1.nvmx[*nv 
			    - 1] * 24 - 25] && *islhgt > comsln_1.is1n1) {
#line 7297 ""
			comsln_1.is1n1 = *islhgt;
#line 7298 ""
			comsln_1.is2n1 = idcode;
#line 7299 ""
		    }
#line 7300 ""
		}
#line 7301 ""
		if ((real) ihoff != 0.f) {
#line 7302 ""
		    shift = ihoff * .1f;
/* Writing concatenation */
#line 7303 ""
		    i__4[0] = lnote, a__2[0] = notexq;
#line 7303 ""
		    i__4[1] = 1, a__2[1] = "{";
#line 7303 ""
		    s_cat(notexq, a__2, i__4, &c__2, (ftnlen)79);
#line 7304 ""
		    ++lnote;
#line 7305 ""
		    lform = lfmt1_(&shift);
#line 7306 ""
		    i__2 = lnote;
#line 7306 ""
		    ici__1.icierr = 0;
#line 7306 ""
		    ici__1.icirnum = 1;
#line 7306 ""
		    ici__1.icirlen = lnote + lform - i__2;
#line 7306 ""
		    ici__1.iciunit = notexq + i__2;
/* Writing concatenation */
#line 7306 ""
		    i__3[0] = 2, a__1[0] = "(f";
#line 7306 ""
		    i__6 = lform + 48;
#line 7306 ""
		    chax_(ch__1, (ftnlen)1, &i__6);
#line 7306 ""
		    i__3[1] = 1, a__1[1] = ch__1;
#line 7306 ""
		    i__3[2] = 3, a__1[2] = ".1)";
#line 7306 ""
		    ici__1.icifmt = (s_cat(ch__2, a__1, i__3, &c__3, (ftnlen)
			    6), ch__2);
#line 7306 ""
		    s_wsfi(&ici__1);
#line 7306 ""
		    do_fio(&c__1, (char *)&shift, (ftnlen)sizeof(real));
#line 7306 ""
		    e_wsfi();
#line 7308 ""
		    lnote += lform;
/* Writing concatenation */
#line 7309 ""
		    i__4[0] = lnote, a__2[0] = notexq;
#line 7309 ""
		    i__4[1] = 1, a__2[1] = "}";
#line 7309 ""
		    s_cat(notexq, a__2, i__4, &c__2, (ftnlen)79);
#line 7310 ""
		    ++lnote;
#line 7311 ""
		}
#line 7312 ""
		addstr_(notexq, &lnote, soutq, lsout, (ftnlen)79, (ftnlen)80);

/*  Zero out ip1 to avoid problems if slur goes to next input blk. */

#line 7316 ""
		setbits_(&isdata, &c__8, &c__3, &c__0);

/*  Set slur-on data for midi.  Only treat null-index slurs and ps ties for now. */

#line 7320 ""
		if (commidi_1.ismidi && idcode == 32) {
#line 7321 ""
		    comslm_1.levson[commidi_1.midchan[*iv + *kv * 24 - 25]] = 
			    nolevs + commvel_1.miditran[cominsttrans_1.instno[
			    *iv - 1] - 1];
#line 7322 ""
		    if (settie) {
#line 7322 ""
			comslm_1.dbltie = TRUE_;
#line 7322 ""
		    }

/*  Only way settie=T is if we just set a tie ending.  So there's also a slur */
/*   start here, so set a flag telling addmidi not to zero out levson */

#line 7327 ""
		}
#line 7328 ""
	    } else {

/*  Slur is ending.  Back thru list to find starting slur */

#line 7332 ""
		for (j = isdat - 1; j >= 1; --j) {
#line 7333 ""
		    if (*iv == igetbits_(&isdat1[j], &c__5, &c__13) && *kv == 
			    igetbits_(&isdat1[j], &c__1, &c__12) + 1) {
#line 7335 ""
			if (idcode == igetbits_(&isdat1[j], &c__7, &c__19)) {
#line 7336 ""
			    comslur_1.ndxslur = igetbits_(&isdat1[j], &c__4, &
				    c__28) + (igetbits_(&isdat1[j], &c__1, &
				    c__18) << 4);

/*  080531 Allow >16 slurs */

#line 7341 ""
			    if (bit_test(isdat1[j],27)) {
#line 7341 ""
				*(unsigned char *)slurudq = 'u';
#line 7341 ""
			    }
#line 7342 ""
			    goto L4;
#line 7343 ""
			}
#line 7344 ""
		    }
#line 7345 ""
/* L3: */
#line 7345 ""
		}
#line 7346 ""
		s_wsle(&io___521);
#line 7346 ""
		do_lio(&c__9, &c__1, "Bad place in doslur", (ftnlen)19);
#line 7346 ""
		e_wsle();
#line 7347 ""
		stop1_();
#line 7348 ""
L4:
#line 7349 ""
		if (nolevs == 0 || nolevs > 60) {

/*  Ending is on a rest, reset nolevs to default starting height */

#line 7353 ""
		    nolevs = igetbits_(&isdat2[j], &c__7, &c__19);
#line 7354 ""
		}
#line 7355 ""
		if (bit_test(isdat3[isdat],0)) {

/*  Deal with \curve or \midslur */

#line 7359 ""
		    imid = igetbits_(&isdat3[isdat], &c__6, &c__2) - 32;

/*  Remember, only dealing with non-ps slurs */

/*  Who knows where the following line came from.  Removed it 6/30/02 to */
/*  restore behavior of non-ps slurs to old way */
/*              if (slurudq .eq. 'd') imid = -imid */
/*  3/8/03 added the following */

#line 7368 ""
		    if (*(unsigned char *)slurudq == 'd') {
#line 7368 ""
			imid = -abs(imid);
#line 7368 ""
		    }

#line 7370 ""
		    if (bit_test(isdat3[isdat],1)) {
/* Writing concatenation */
#line 7371 ""
			chax_(ch__1, (ftnlen)1, &c__92);
#line 7371 ""
			i__4[0] = 1, a__2[0] = ch__1;
#line 7371 ""
			i__4[1] = 5, a__2[1] = "curve";
#line 7371 ""
			s_cat(notexq, a__2, i__4, &c__2, (ftnlen)79);
#line 7372 ""
			lnote = 6;
#line 7373 ""
		    } else {
/* Writing concatenation */
#line 7374 ""
			chax_(ch__1, (ftnlen)1, &c__92);
#line 7374 ""
			i__4[0] = 1, a__2[0] = ch__1;
#line 7374 ""
			i__4[1] = 7, a__2[1] = "midslur";
#line 7374 ""
			s_cat(notexq, a__2, i__4, &c__2, (ftnlen)79);
#line 7375 ""
			lnote = 8;
#line 7376 ""
		    }
#line 7377 ""
		    if (imid < 0 || imid > 9) {

/*  Need brackets */

/* Writing concatenation */
#line 7381 ""
			i__4[0] = lnote, a__2[0] = notexq;
#line 7381 ""
			i__4[1] = 1, a__2[1] = "{";
#line 7381 ""
			s_cat(notexq, a__2, i__4, &c__2, (ftnlen)79);
#line 7382 ""
			++lnote;
#line 7383 ""
			if (imid < -9) {
#line 7384 ""
			    i__2 = lnote;
#line 7384 ""
			    ici__1.icierr = 0;
#line 7384 ""
			    ici__1.icirnum = 1;
#line 7384 ""
			    ici__1.icirlen = lnote + 3 - i__2;
#line 7384 ""
			    ici__1.iciunit = notexq + i__2;
#line 7384 ""
			    ici__1.icifmt = "(i3)";
#line 7384 ""
			    s_wsfi(&ici__1);
#line 7384 ""
			    do_fio(&c__1, (char *)&imid, (ftnlen)sizeof(
				    integer));
#line 7384 ""
			    e_wsfi();
#line 7385 ""
			    lnote += 3;
#line 7386 ""
			} else if (imid < 0 || imid > 9) {
#line 7387 ""
			    i__2 = lnote;
#line 7387 ""
			    ici__1.icierr = 0;
#line 7387 ""
			    ici__1.icirnum = 1;
#line 7387 ""
			    ici__1.icirlen = lnote + 2 - i__2;
#line 7387 ""
			    ici__1.iciunit = notexq + i__2;
#line 7387 ""
			    ici__1.icifmt = "(i2)";
#line 7387 ""
			    s_wsfi(&ici__1);
#line 7387 ""
			    do_fio(&c__1, (char *)&imid, (ftnlen)sizeof(
				    integer));
#line 7387 ""
			    e_wsfi();
#line 7388 ""
			    lnote += 2;
#line 7389 ""
			} else {
#line 7390 ""
			    i__2 = lnote;
#line 7390 ""
			    ici__1.icierr = 0;
#line 7390 ""
			    ici__1.icirnum = 1;
#line 7390 ""
			    ici__1.icirlen = lnote + 1 - i__2;
#line 7390 ""
			    ici__1.iciunit = notexq + i__2;
#line 7390 ""
			    ici__1.icifmt = "(i1)";
#line 7390 ""
			    s_wsfi(&ici__1);
#line 7390 ""
			    do_fio(&c__1, (char *)&imid, (ftnlen)sizeof(
				    integer));
#line 7390 ""
			    e_wsfi();
#line 7391 ""
			    ++lnote;
#line 7392 ""
			}
/* Writing concatenation */
#line 7393 ""
			i__4[0] = lnote, a__2[0] = notexq;
#line 7393 ""
			i__4[1] = 1, a__2[1] = "}";
#line 7393 ""
			s_cat(notexq, a__2, i__4, &c__2, (ftnlen)79);
#line 7394 ""
			++lnote;
#line 7395 ""
		    } else {

/*  1=<imid=<9, no brackets */

/* Writing concatenation */
#line 7399 ""
			i__4[0] = lnote, a__2[0] = notexq;
#line 7399 ""
			*(unsigned char *)&ch__1[0] = imid + 48;
#line 7399 ""
			i__4[1] = 1, a__2[1] = ch__1;
#line 7399 ""
			s_cat(notexq, a__2, i__4, &c__2, (ftnlen)79);
#line 7400 ""
			++lnote;
#line 7401 ""
		    }
#line 7402 ""
		    if (bit_test(isdat3[isdat],1)) {

/*  \curve; 3 args */

/* Writing concatenation */
#line 7406 ""
			i__4[0] = lnote, a__2[0] = notexq;
#line 7406 ""
			*(unsigned char *)&ch__1[0] = igetbits_(&isdat3[isdat]
				, &c__3, &c__8) + 48;
#line 7406 ""
			i__4[1] = 1, a__2[1] = ch__1;
#line 7406 ""
			s_cat(notexq, a__2, i__4, &c__2, (ftnlen)79);
/* Writing concatenation */
#line 7408 ""
			i__4[0] = lnote + 1, a__2[0] = notexq;
#line 7408 ""
			*(unsigned char *)&ch__1[0] = igetbits_(&isdat3[isdat]
				, &c__3, &c__11) + 48;
#line 7408 ""
			i__4[1] = 1, a__2[1] = ch__1;
#line 7408 ""
			s_cat(notexq, a__2, i__4, &c__2, (ftnlen)79);
#line 7410 ""
			lnote += 2;
#line 7411 ""
		    }
#line 7412 ""
		    addstr_(notexq, &lnote, soutq, lsout, (ftnlen)79, (ftnlen)
			    80);
#line 7413 ""
		}

/*  Shift slur ending for stem on any note? */

#line 7417 ""
		if (! stemup && *(unsigned char *)slurudq == 'd' && *tno < 
			63.f) {
#line 7417 ""
		    ihoff += -8;
#line 7417 ""
		}
#line 7419 ""
		if (bit_test(isdat2[isdat],3)) {

/*  Shift ending for tie spacing */

#line 7423 ""
		    if (*(unsigned char *)slurudq == 'u') {
#line 7424 ""
			ihoff += -8;
#line 7425 ""
			--ivoff;
#line 7426 ""
		    } else if (*(unsigned char *)slurudq == 'd') {
#line 7427 ""
			++ivoff;
#line 7428 ""
			if (stemup || *tno > 63.f) {
#line 7428 ""
			    ihoff += -8;
#line 7428 ""
			}
#line 7429 ""
		    }
#line 7430 ""
		}
#line 7431 ""
		if (iscrd) {

/*  Shift termination for shifted notehead? */

#line 7435 ""
		    if (bit_test(isdat2[isdat],1)) {

/*  Left-shifted chord notehead.  ASSUME downstem. */

#line 7439 ""
			if (nolevs == comtrill_1.minlev && *(unsigned char *)
				slurudq == 'd') {
#line 7440 ""
			    ihoff += -2;
#line 7441 ""
			} else {
#line 7442 ""
			    ihoff += -10;
#line 7443 ""
			}
#line 7444 ""
		    } else if (bit_test(isdat2[isdat],2)) {

/*  Right shifted chord notehead.  ASSUME upstem. */

#line 7448 ""
			if (nolevs == comtrill_1.maxlev && *(unsigned char *)
				slurudq == 'u') {
#line 7449 ""
			    ihoff += 2;
#line 7450 ""
			} else {
#line 7451 ""
			    ihoff += 10;
#line 7452 ""
			}
#line 7453 ""
		    }
#line 7454 ""
		}
#line 7455 ""
		if (ihoff == 0) {
/* Writing concatenation */
#line 7456 ""
		    chax_(ch__1, (ftnlen)1, &c__92);
#line 7456 ""
		    i__4[0] = 1, a__2[0] = ch__1;
#line 7456 ""
		    i__4[1] = 5, a__2[1] = "tslur";
#line 7456 ""
		    s_cat(notexq, a__2, i__4, &c__2, (ftnlen)79);
#line 7457 ""
		    lnote = 6;
#line 7458 ""
		} else {

/*  Shift needed */

/* Writing concatenation */
#line 7462 ""
		    chax_(ch__1, (ftnlen)1, &c__92);
#line 7462 ""
		    i__4[0] = 1, a__2[0] = ch__1;
#line 7462 ""
		    i__4[1] = 2, a__2[1] = "ts";
#line 7462 ""
		    s_cat(notexq, a__2, i__4, &c__2, (ftnlen)79);
#line 7463 ""
		    lnote = 3;
#line 7464 ""
		}

/*  Print 23-ndxslur */
/*  5/25/08 Allow 14 slurs (???????????) */

#line 7469 ""
		if (23 - comslur_1.ndxslur < 10) {
/* Writing concatenation */
#line 7470 ""
		    i__4[0] = lnote, a__2[0] = notexq;
#line 7470 ""
		    i__2 = 71 - comslur_1.ndxslur;
#line 7470 ""
		    chax_(ch__1, (ftnlen)1, &i__2);
#line 7470 ""
		    i__4[1] = 1, a__2[1] = ch__1;
#line 7470 ""
		    s_cat(notexq, a__2, i__4, &c__2, (ftnlen)79);
#line 7471 ""
		    ++lnote;
#line 7472 ""
		} else if (23 - comslur_1.ndxslur < 20) {
/* Writing concatenation */
#line 7473 ""
		    i__5[0] = lnote, a__3[0] = notexq;
#line 7473 ""
		    i__5[1] = 2, a__3[1] = "{1";
#line 7473 ""
		    i__2 = 61 - comslur_1.ndxslur;
#line 7473 ""
		    chax_(ch__1, (ftnlen)1, &i__2);
#line 7473 ""
		    i__5[2] = 1, a__3[2] = ch__1;
#line 7473 ""
		    i__5[3] = 1, a__3[3] = "}";
#line 7473 ""
		    s_cat(notexq, a__3, i__5, &c__4, (ftnlen)79);
#line 7474 ""
		    lnote += 4;
#line 7475 ""
		} else {
/* Writing concatenation */
#line 7476 ""
		    i__5[0] = lnote, a__3[0] = notexq;
#line 7476 ""
		    i__5[1] = 2, a__3[1] = "{2";
#line 7476 ""
		    i__2 = 51 - comslur_1.ndxslur;
#line 7476 ""
		    chax_(ch__1, (ftnlen)1, &i__2);
#line 7476 ""
		    i__5[2] = 1, a__3[2] = ch__1;
#line 7476 ""
		    i__5[3] = 1, a__3[3] = "}";
#line 7476 ""
		    s_cat(notexq, a__3, i__5, &c__4, (ftnlen)79);
#line 7477 ""
		    lnote += 4;
#line 7478 ""
		}
#line 7479 ""
		if (bit_test(*iornq,11) || bit_test(*iornq,12)) {

/*  Raise or lower slur by one unit provided . or _ is on same side as slur */

#line 7483 ""
		    ivoffinc = 0;
#line 7484 ""
		    if (stemup && *(unsigned char *)slurudq == 'd' || ! 
			    stemup && *(unsigned char *)slurudq == 'u') {
#line 7486 ""
			if (stemup) {
#line 7487 ""
			    ivoffinc = -1;
#line 7488 ""
			} else {
#line 7489 ""
			    ivoffinc = 1;
#line 7490 ""
			}
#line 7491 ""
			if ((stemup && *nolev >= *ncm - 2 || ! stemup && *
				nolev <= *ncm + 2) && (i__2 = *ncm - *nolev, 
				abs(i__2)) % 2 == 0) {
#line 7491 ""
			    ivoffinc <<= 1;
#line 7491 ""
			}
#line 7494 ""
		    }
#line 7495 ""
		    ivoff += ivoffinc;
#line 7496 ""
		}
#line 7497 ""
		if (idcode == 1 && tmove) {

/*  t-slur height adjustment */

#line 7501 ""
		    iupdn = 1;
#line 7502 ""
		    if (*(unsigned char *)slurudq == 'd') {
#line 7502 ""
			iupdn = -1;
#line 7502 ""
		    }
#line 7503 ""
		}
#line 7504 ""
		i__2 = nolevs + iupdn + ivoff;
#line 7504 ""
		notefq_(noteq, &lnoten, &i__2, ncm, (ftnlen)8);
#line 7505 ""
		if (*(unsigned char *)slurudq == 'u' && (! bit_test(isdat2[
			isdat],0) || nolevs == comtrill_1.maxlev)) {
#line 7507 ""
		    *islhgt = nolevs + iupdn + ivoff;

/*  If topvoice, upslur, and idcode checks, no more need to keep hgt for barno. */

#line 7511 ""
		    if (commvl_1.ivx == commvl_1.ivmx[*nv + commvl_1.nvmx[*nv 
			    - 1] * 24 - 25] && comsln_1.is1n1 > 0) {
#line 7512 ""
			if (idcode == comsln_1.is2n1) {
#line 7512 ""
			    comsln_1.is1n1 = 0;
#line 7512 ""
			}
#line 7513 ""
		    }
#line 7514 ""
		}
/* Writing concatenation */
#line 7515 ""
		i__4[0] = lnote, a__2[0] = notexq;
#line 7515 ""
		i__4[1] = lnoten, a__2[1] = noteq;
#line 7515 ""
		s_cat(notexq, a__2, i__4, &c__2, (ftnlen)79);
#line 7516 ""
		lnote += lnoten;
#line 7517 ""
		if (ihoff != 0) {
#line 7518 ""
		    shift = ihoff * .1f;
/* Writing concatenation */
#line 7519 ""
		    i__4[0] = lnote, a__2[0] = notexq;
#line 7519 ""
		    i__4[1] = 1, a__2[1] = "{";
#line 7519 ""
		    s_cat(notexq, a__2, i__4, &c__2, (ftnlen)79);
#line 7520 ""
		    ++lnote;
#line 7521 ""
		    lform = lfmt1_(&shift);
#line 7522 ""
		    i__2 = lnote;
#line 7522 ""
		    ici__1.icierr = 0;
#line 7522 ""
		    ici__1.icirnum = 1;
#line 7522 ""
		    ici__1.icirlen = lnote + lform - i__2;
#line 7522 ""
		    ici__1.iciunit = notexq + i__2;
/* Writing concatenation */
#line 7522 ""
		    i__3[0] = 2, a__1[0] = "(f";
#line 7522 ""
		    i__6 = lform + 48;
#line 7522 ""
		    chax_(ch__1, (ftnlen)1, &i__6);
#line 7522 ""
		    i__3[1] = 1, a__1[1] = ch__1;
#line 7522 ""
		    i__3[2] = 3, a__1[2] = ".1)";
#line 7522 ""
		    ici__1.icifmt = (s_cat(ch__2, a__1, i__3, &c__3, (ftnlen)
			    6), ch__2);
#line 7522 ""
		    s_wsfi(&ici__1);
#line 7522 ""
		    do_fio(&c__1, (char *)&shift, (ftnlen)sizeof(real));
#line 7522 ""
		    e_wsfi();
#line 7524 ""
		    lnote += lform;
/* Writing concatenation */
#line 7525 ""
		    i__4[0] = lnote, a__2[0] = notexq;
#line 7525 ""
		    i__4[1] = 1, a__2[1] = "}";
#line 7525 ""
		    s_cat(notexq, a__2, i__4, &c__2, (ftnlen)79);
#line 7526 ""
		    ++lnote;
#line 7527 ""
		}
#line 7528 ""
		addstr_(notexq, &lnote, soutq, lsout, (ftnlen)79, (ftnlen)80);

/*  Clear the bit from list of slurs in use */

#line 7532 ""
		comslur_1.listslur = bit_clear(comslur_1.listslur,
			comslur_1.ndxslur);

/*  Zero out the entire strings for start and stop */

#line 7536 ""
		isdata = 0;
#line 7537 ""
		isdat2[isdat] = 0;
#line 7538 ""
		isdat1[j] = 0;
#line 7539 ""
		isdat2[j] = 0;
#line 7540 ""
		isdat3[isdat] = 0;

/*  Set midi info for slur ending */

#line 7544 ""
		if (commidi_1.ismidi && idcode == 32) {
#line 7545 ""
		    icm = commidi_1.midchan[*iv + *kv * 24 - 25];
#line 7546 ""
		    if (comslm_1.slmon[icm]) {
#line 7547 ""
			if (nolevs + commvel_1.miditran[cominsttrans_1.instno[
				*iv - 1] - 1] == comslm_1.levson[icm] && (7 & 
				*nacc) == 0) {

/*  There is a tie here.  NB!!! assumed no accidental on 2nd member of tie. */

#line 7552 ""
			    comslm_1.levsoff[icm] = nolevs + 
				    commvel_1.miditran[cominsttrans_1.instno[*
				    iv - 1] - 1];
#line 7553 ""
			    settie = TRUE_;
#line 7554 ""
			} else {
#line 7555 ""
			    comslm_1.levsoff[icm] = 0;
#line 7556 ""
			    comslm_1.levson[icm] = 0;
#line 7557 ""
			    comslm_1.slmon[icm] = FALSE_;
#line 7558 ""
			}
#line 7559 ""
		    }
#line 7560 ""
		}
#line 7561 ""
	    }
#line 7562 ""
	    isdat1[isdat] = isdata;
#line 7563 ""
	}
#line 7564 ""
/* L1: */
#line 7564 ""
    }

/*  Clear and collapse the slur data list */

#line 7568 ""
    numdrop = 0;
#line 7569 ""
    i__1 = *nsdat;
#line 7569 ""
    for (isdat = 1; isdat <= i__1; ++isdat) {
#line 7570 ""
	if (isdat1[isdat] == 0) {
#line 7571 ""
	    ++numdrop;
#line 7572 ""
	} else if (numdrop > 0) {
#line 7573 ""
	    isdat1[isdat - numdrop] = isdat1[isdat];
#line 7574 ""
	    isdat2[isdat - numdrop] = isdat2[isdat];
#line 7575 ""
	    isdat3[isdat - numdrop] = isdat3[isdat];
#line 7576 ""
	    isdat1[isdat] = 0;
#line 7577 ""
	    isdat2[isdat] = 0;
#line 7578 ""
	    isdat3[isdat] = 0;
#line 7579 ""
	}
#line 7580 ""
/* L2: */
#line 7580 ""
    }
#line 7581 ""
    *nsdat -= numdrop;
#line 7582 ""
    return 0;
} /* doslur_ */

/* Subroutine */ int dotmov_(real *updot, real *rtdot, char *soutq, integer *
	lsout, integer *iddot, ftnlen soutq_len)
{
    /* System generated locals */
    address a__1[5], a__2[8], a__3[5];
    integer i__1[5], i__2, i__3, i__4[8], i__5[5], i__6;
    char ch__1[1], ch__2[22], ch__3[1], ch__4[37], ch__5[15], ch__6[1];
    icilist ici__1;

    /* Builtin functions */
    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
    integer s_wsfi(icilist *), do_fio(integer *, char *, ftnlen), e_wsfi(void)
	    ;

    /* Local variables */
    static char sq[1];
    extern /* Character */ VOID chax_(char *, ftnlen, integer *);
    extern integer lfmt1_(real *);
    static integer lnote;
    extern /* Subroutine */ int addstr_(char *, integer *, char *, integer *, 
	    ftnlen, ftnlen);
    static integer lfmtup, lfmtrt;
    static char notexq[80];


/*  iddot = 0 for single dot, 1 for double */

#line 7590 ""
    chax_(ch__1, (ftnlen)1, &c__92);
#line 7590 ""
    *(unsigned char *)sq = *(unsigned char *)&ch__1[0];
#line 7591 ""
    lfmtup = lfmt1_(updot);
#line 7592 ""
    lfmtrt = lfmt1_(rtdot);
#line 7593 ""
    ici__1.icierr = 0;
#line 7593 ""
    ici__1.icirnum = 1;
#line 7593 ""
    ici__1.icirlen = 80;
#line 7593 ""
    ici__1.iciunit = notexq;
/* Writing concatenation */
#line 7593 ""
    i__1[0] = 6, a__1[0] = "(a37,f";
#line 7593 ""
    i__2 = lfmtup + 48;
#line 7593 ""
    chax_(ch__1, (ftnlen)1, &i__2);
#line 7593 ""
    i__1[1] = 1, a__1[1] = ch__1;
#line 7593 ""
    i__1[2] = 7, a__1[2] = ".1,a2,f";
#line 7593 ""
    i__3 = lfmtrt + 48;
#line 7593 ""
    chax_(ch__3, (ftnlen)1, &i__3);
#line 7593 ""
    i__1[3] = 1, a__1[3] = ch__3;
#line 7593 ""
    i__1[4] = 7, a__1[4] = ".1,a15)";
#line 7593 ""
    ici__1.icifmt = (s_cat(ch__2, a__1, i__1, &c__5, (ftnlen)22), ch__2);
#line 7593 ""
    s_wsfi(&ici__1);
/* Writing concatenation */
#line 7593 ""
    i__4[0] = 1, a__2[0] = sq;
#line 7593 ""
    i__4[1] = 12, a__2[1] = "makeatletter";
#line 7593 ""
    i__4[2] = 1, a__2[2] = sq;
#line 7593 ""
    i__4[3] = 3, a__2[3] = "def";
#line 7593 ""
    i__4[4] = 1, a__2[4] = sq;
#line 7593 ""
    i__4[5] = 12, a__2[5] = "C@Point#1#2{";
#line 7593 ""
    i__4[6] = 1, a__2[6] = sq;
#line 7593 ""
    i__4[7] = 6, a__2[7] = "PMXpt{";
#line 7593 ""
    s_cat(ch__4, a__2, i__4, &c__8, (ftnlen)37);
#line 7593 ""
    do_fio(&c__1, ch__4, (ftnlen)37);
#line 7593 ""
    do_fio(&c__1, (char *)&(*updot), (ftnlen)sizeof(real));
#line 7593 ""
    do_fio(&c__1, "}{", (ftnlen)2);
#line 7593 ""
    do_fio(&c__1, (char *)&(*rtdot), (ftnlen)sizeof(real));
/* Writing concatenation */
#line 7593 ""
    i__5[0] = 1, a__3[0] = "}";
#line 7593 ""
    i__6 = *iddot + 48;
#line 7593 ""
    chax_(ch__6, (ftnlen)1, &i__6);
#line 7593 ""
    i__5[1] = 1, a__3[1] = ch__6;
#line 7593 ""
    i__5[2] = 1, a__3[2] = "}";
#line 7593 ""
    i__5[3] = 1, a__3[3] = sq;
#line 7593 ""
    i__5[4] = 11, a__3[4] = "makeatother";
#line 7593 ""
    s_cat(ch__5, a__3, i__5, &c__5, (ftnlen)15);
#line 7593 ""
    do_fio(&c__1, ch__5, (ftnlen)15);
#line 7593 ""
    e_wsfi();

/*   Example of string just created: */
/*   \makeatletter\def\C@Point#1#2{\PMXpt{.5}{.5}}\makeatother\ */

#line 7602 ""
    lnote = lfmtup + 54 + lfmtrt;
#line 7603 ""
    addstr_(notexq, &lnote, soutq, lsout, lnote, (ftnlen)80);
#line 7604 ""
    return 0;
} /* dotmov_ */

/* Subroutine */ int dotrill_(integer *iv, integer *ip, integer *iornq, char *
	noteq, integer *lnoten, char *notexq, integer *lnote, ftnlen 
	noteq_len, ftnlen notexq_len)
{
    /* System generated locals */
    address a__1[2], a__2[3];
    integer i__1, i__2[2], i__3[3], i__4;
    char ch__1[1], ch__2[6];
    icilist ici__1;

    /* Builtin functions */
    integer s_wsle(cilist *), do_lio(integer *, integer *, char *, ftnlen), 
	    e_wsle(void);
    /* Subroutine */ int s_stop(char *, ftnlen), s_cat(char *, char **, 
	    integer *, integer *, ftnlen);
    integer s_wsfi(icilist *), do_fio(integer *, char *, ftnlen), e_wsfi(void)
	    ;

    /* Local variables */
    static integer itr;
    extern /* Character */ VOID chax_(char *, ftnlen, integer *);
    static integer nfmt;
    static logical tronly;

    /* Fortran I/O blocks */
    static cilist io___531 = { 0, 6, 0, 0, 0 };


#line 7614 ""
    i__1 = comtrill_1.ntrill;
#line 7614 ""
    for (itr = 1; itr <= i__1; ++itr) {
#line 7615 ""
	if (*iv == comtrill_1.ivtrill[itr - 1] && *ip == comtrill_1.iptrill[
		itr - 1]) {
#line 7615 ""
	    goto L2;
#line 7615 ""
	}
#line 7616 ""
/* L1: */
#line 7616 ""
    }
#line 7617 ""
    s_wsle(&io___531);
#line 7617 ""
    do_lio(&c__9, &c__1, "Problem in dotrill.  Call Dr. Don", (ftnlen)33);
#line 7617 ""
    e_wsle();
#line 7618 ""
    s_stop("", (ftnlen)0);
#line 7619 ""
L2:
#line 7620 ""
    tronly = comtrill_1.xnsktr[itr - 1] < .01f;
#line 7621 ""
    if (tronly) {
/* Writing concatenation */
#line 7622 ""
	chax_(ch__1, (ftnlen)1, &c__92);
#line 7622 ""
	i__2[0] = 1, a__1[0] = ch__1;
#line 7622 ""
	i__2[1] = 9, a__1[1] = "zcharnote";
#line 7622 ""
	s_cat(notexq, a__1, i__2, &c__2, (ftnlen)79);
#line 7623 ""
	*lnote = 10;
#line 7624 ""
    } else if (bit_test(*iornq,7)) {
/* Writing concatenation */
#line 7625 ""
	chax_(ch__1, (ftnlen)1, &c__92);
#line 7625 ""
	i__2[0] = 1, a__1[0] = ch__1;
#line 7625 ""
	i__2[1] = 6, a__1[1] = "Trille";
#line 7625 ""
	s_cat(notexq, a__1, i__2, &c__2, (ftnlen)79);
#line 7626 ""
	*lnote = 7;
#line 7627 ""
    } else {
/* Writing concatenation */
#line 7628 ""
	chax_(ch__1, (ftnlen)1, &c__92);
#line 7628 ""
	i__2[0] = 1, a__1[0] = ch__1;
#line 7628 ""
	i__2[1] = 6, a__1[1] = "trille";
#line 7628 ""
	s_cat(notexq, a__1, i__2, &c__2, (ftnlen)79);
#line 7629 ""
	*lnote = 7;
#line 7630 ""
    }
/* Writing concatenation */
#line 7631 ""
    i__3[0] = *lnote, a__2[0] = notexq;
#line 7631 ""
    i__3[1] = *lnoten, a__2[1] = noteq;
#line 7631 ""
    i__3[2] = 1, a__2[2] = "{";
#line 7631 ""
    s_cat(notexq, a__2, i__3, &c__3, (ftnlen)79);
#line 7632 ""
    *lnote = *lnote + *lnoten + 1;

/*  Write trill duration to nearest tenth of a noteskip */

#line 7636 ""
    if (tronly) {
/* Writing concatenation */
#line 7637 ""
	i__3[0] = *lnote, a__2[0] = notexq;
#line 7637 ""
	chax_(ch__1, (ftnlen)1, &c__92);
#line 7637 ""
	i__3[1] = 1, a__2[1] = ch__1;
#line 7637 ""
	i__3[2] = 6, a__2[2] = "it tr}";
#line 7637 ""
	s_cat(notexq, a__2, i__3, &c__3, (ftnlen)79);
#line 7638 ""
	*lnote += 7;
#line 7639 ""
	return 0;
#line 7640 ""
    }
#line 7641 ""
    if (comtrill_1.xnsktr[itr - 1] < .95f) {
#line 7642 ""
	nfmt = 2;
#line 7643 ""
    } else if (comtrill_1.xnsktr[itr - 1] < 9.95f) {
#line 7644 ""
	nfmt = 3;
#line 7645 ""
    } else {
#line 7646 ""
	nfmt = 4;
#line 7647 ""
    }
#line 7648 ""
    i__1 = *lnote;
#line 7648 ""
    ici__1.icierr = 0;
#line 7648 ""
    ici__1.icirnum = 1;
#line 7648 ""
    ici__1.icirlen = *lnote + nfmt - i__1;
#line 7648 ""
    ici__1.iciunit = notexq + i__1;
/* Writing concatenation */
#line 7648 ""
    i__3[0] = 2, a__2[0] = "(f";
#line 7648 ""
    i__4 = nfmt + 48;
#line 7648 ""
    chax_(ch__1, (ftnlen)1, &i__4);
#line 7648 ""
    i__3[1] = 1, a__2[1] = ch__1;
#line 7648 ""
    i__3[2] = 3, a__2[2] = ".1)";
#line 7648 ""
    ici__1.icifmt = (s_cat(ch__2, a__2, i__3, &c__3, (ftnlen)6), ch__2);
#line 7648 ""
    s_wsfi(&ici__1);
#line 7648 ""
    do_fio(&c__1, (char *)&comtrill_1.xnsktr[itr - 1], (ftnlen)sizeof(real));
#line 7648 ""
    e_wsfi();
#line 7650 ""
    *lnote += nfmt;
/* Writing concatenation */
#line 7651 ""
    i__2[0] = *lnote, a__1[0] = notexq;
#line 7651 ""
    i__2[1] = 1, a__1[1] = "}";
#line 7651 ""
    s_cat(notexq, a__1, i__2, &c__2, (ftnlen)79);
#line 7652 ""
    ++(*lnote);
#line 7653 ""
    return 0;
} /* dotrill_ */

/* Subroutine */ int endslur_(logical *stemup, logical *upslur, integer *
	nolev, integer *iupdn, integer *ndxslur, integer *ivoff, integer *ncm,
	 char *soutq, integer *lsout, logical *fontslur, ftnlen soutq_len)
{
    /* System generated locals */
    address a__1[2], a__2[4];
    integer i__1[2], i__2, i__3[4];
    char ch__1[1];

    /* Builtin functions */
    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);

    /* Local variables */
    extern /* Character */ VOID chax_(char *, ftnlen, integer *);
    static logical shift;
    static integer lnote;
    static char noteq[8];
    extern /* Subroutine */ int addstr_(char *, integer *, char *, integer *, 
	    ftnlen, ftnlen), notefq_(char *, integer *, integer *, integer *, 
	    ftnlen);
    static integer lnoten;
    static char notexq[79];


/*  Only called to end slur started in dograce. */

#line 7665 ""
    shift = ! (*stemup) && ! (*upslur);
#line 7666 ""
    if (! shift) {

/*  No shift needed */

/* Writing concatenation */
#line 7670 ""
	chax_(ch__1, (ftnlen)1, &c__92);
#line 7670 ""
	i__1[0] = 1, a__1[0] = ch__1;
#line 7670 ""
	i__1[1] = 5, a__1[1] = "tslur";
#line 7670 ""
	s_cat(notexq, a__1, i__1, &c__2, (ftnlen)79);
#line 7671 ""
	lnote = 6;
#line 7672 ""
    } else {

/*  Shift needed */

/* Writing concatenation */
#line 7676 ""
	chax_(ch__1, (ftnlen)1, &c__92);
#line 7676 ""
	i__1[0] = 1, a__1[0] = ch__1;
#line 7676 ""
	i__1[1] = 2, a__1[1] = "ts";
#line 7676 ""
	s_cat(notexq, a__1, i__1, &c__2, (ftnlen)79);
#line 7677 ""
	lnote = 3;
#line 7678 ""
    }

/*  Print 23-ndxslur */

#line 7682 ""
    if (23 - *ndxslur < 10) {
/* Writing concatenation */
#line 7683 ""
	i__1[0] = lnote, a__1[0] = notexq;
#line 7683 ""
	i__2 = 71 - *ndxslur;
#line 7683 ""
	chax_(ch__1, (ftnlen)1, &i__2);
#line 7683 ""
	i__1[1] = 1, a__1[1] = ch__1;
#line 7683 ""
	s_cat(notexq, a__1, i__1, &c__2, (ftnlen)79);
#line 7684 ""
	++lnote;
#line 7685 ""
    } else if (23 - *ndxslur < 20) {
/* Writing concatenation */
#line 7686 ""
	i__3[0] = lnote, a__2[0] = notexq;
#line 7686 ""
	i__3[1] = 2, a__2[1] = "{1";
#line 7686 ""
	i__2 = 61 - *ndxslur;
#line 7686 ""
	chax_(ch__1, (ftnlen)1, &i__2);
#line 7686 ""
	i__3[2] = 1, a__2[2] = ch__1;
#line 7686 ""
	i__3[3] = 1, a__2[3] = "}";
#line 7686 ""
	s_cat(notexq, a__2, i__3, &c__4, (ftnlen)79);
#line 7687 ""
	lnote += 4;
#line 7688 ""
    } else {
/* Writing concatenation */
#line 7689 ""
	i__3[0] = lnote, a__2[0] = notexq;
#line 7689 ""
	i__3[1] = 2, a__2[1] = "{2";
#line 7689 ""
	i__2 = 51 - *ndxslur;
#line 7689 ""
	chax_(ch__1, (ftnlen)1, &i__2);
#line 7689 ""
	i__3[2] = 1, a__2[2] = ch__1;
#line 7689 ""
	i__3[3] = 1, a__2[3] = "}";
#line 7689 ""
	s_cat(notexq, a__2, i__3, &c__4, (ftnlen)79);
#line 7690 ""
	lnote += 4;
#line 7691 ""
    }
#line 7692 ""
    i__2 = *nolev + *iupdn + *ivoff;
#line 7692 ""
    notefq_(noteq, &lnoten, &i__2, ncm, (ftnlen)8);
/* Writing concatenation */
#line 7693 ""
    i__1[0] = lnote, a__1[0] = notexq;
#line 7693 ""
    i__1[1] = lnoten, a__1[1] = noteq;
#line 7693 ""
    s_cat(notexq, a__1, i__1, &c__2, (ftnlen)79);
#line 7694 ""
    lnote += lnoten;
#line 7695 ""
    if (shift) {
#line 7696 ""
	if (*fontslur) {
/* Writing concatenation */
#line 7697 ""
	    i__1[0] = lnote, a__1[0] = notexq;
#line 7697 ""
	    i__1[1] = 5, a__1[1] = "{-.6}";
#line 7697 ""
	    s_cat(notexq, a__1, i__1, &c__2, (ftnlen)79);
#line 7698 ""
	} else {
/* Writing concatenation */
#line 7699 ""
	    i__1[0] = lnote, a__1[0] = notexq;
#line 7699 ""
	    i__1[1] = 5, a__1[1] = "{-.8}";
#line 7699 ""
	    s_cat(notexq, a__1, i__1, &c__2, (ftnlen)79);
#line 7700 ""
	}
#line 7701 ""
	lnote += 5;
#line 7702 ""
    }
#line 7703 ""
    addstr_(notexq, &lnote, soutq, lsout, (ftnlen)79, (ftnlen)80);
#line 7704 ""
    return 0;
} /* endslur_ */

/* Subroutine */ int errmsg_(char *lineq, integer *iccount, integer *ibarno, 
	char *msgq, ftnlen lineq_len, ftnlen msgq_len)
{
    /* System generated locals */
    address a__1[2], a__2[5], a__3[4];
    integer i__1[2], i__2, i__3, i__4[5], i__5[4];
    real r__1;
    char ch__1[18], ch__2[1], ch__3[1], ch__4[7], ch__5[79];
    cilist ci__1;
    olist o__1;
    cllist cl__1;

    /* Builtin functions */
    /* Subroutine */ int s_copy(char *, char *, ftnlen, ftnlen), s_cat(char *,
	     char **, integer *, integer *, ftnlen);
    integer s_wsle(cilist *), e_wsle(void), f_open(olist *), s_wsfe(cilist *),
	     do_fio(integer *, char *, ftnlen), e_wsfe(void), f_clos(cllist *)
	    ;
    double r_lg10(real *);
    integer i_indx(char *, char *, ftnlen, ftnlen), do_lio(integer *, integer 
	    *, char *, ftnlen);

    /* Local variables */
    static integer i1, i10;
    extern /* Character */ VOID chax_(char *, ftnlen, integer *);
    static char outq[78];
    static integer iposn, ndigbn, ndignl, nlinep, lenmsg;
    extern /* Subroutine */ int printl_(char *, ftnlen);
    static integer ibarnop;

    /* Fortran I/O blocks */
    static cilist io___541 = { 0, 6, 0, 0, 0 };
    static cilist io___544 = { 0, 19, 0, "(i6)", 0 };
    static cilist io___548 = { 0, 6, 0, "(1x,a)", 0 };
    static cilist io___549 = { 0, 15, 0, "(a)", 0 };
    static cilist io___552 = { 0, 6, 0, 0, 0 };
    static cilist io___553 = { 0, 15, 0, "(a)", 0 };


#line 7716 ""
    if (*iccount <= 78) {
#line 7717 ""
	s_copy(outq, lineq, (ftnlen)78, (ftnlen)78);
#line 7718 ""
	iposn = *iccount;
#line 7719 ""
    } else {
/* Writing concatenation */
#line 7720 ""
	i__1[0] = 4, a__1[0] = "... ";
#line 7720 ""
	i__1[1] = 74, a__1[1] = lineq + 54;
#line 7720 ""
	s_cat(outq, a__1, i__1, &c__2, (ftnlen)78);
#line 7721 ""
	iposn = *iccount - 50;
#line 7722 ""
    }
#line 7723 ""
    s_wsle(&io___541);
#line 7723 ""
    e_wsle();
#line 7724 ""
    ibarnop = *ibarno;
#line 7725 ""
    if (c1omget_1.linesinpmxmod == 0 || c1omget_1.nline > 
	    c1omget_1.line1pmxmod + c1omget_1.linesinpmxmod) {

/*  Error is in main .pmx file */

/*        nlinep = nline-linesinpmxmod */
/*       Correct for comments not copied into buffer */
#line 7732 ""
	nlinep = truelinecount_1.linewcom[c1omget_1.nline - 1] - 
		c1omget_1.linesinpmxmod;
#line 7733 ""
    } else {

/*  Error is in include file */

#line 7737 ""
	ibarnop = 0;
#line 7738 ""
	nlinep = c1omget_1.nline - c1omget_1.line1pmxmod + 1;
#line 7739 ""
	printl_("ERROR in include file named above, description given below", 
		(ftnlen)58);
#line 7741 ""
    }
#line 7742 ""
    o__1.oerr = 0;
#line 7742 ""
    o__1.ounit = 19;
#line 7742 ""
    o__1.ofnmlen = 11;
#line 7742 ""
    o__1.ofnm = "pmxaerr.dat";
#line 7742 ""
    o__1.orl = 0;
#line 7742 ""
    o__1.osta = 0;
#line 7742 ""
    o__1.oacc = 0;
#line 7742 ""
    o__1.ofm = 0;
#line 7742 ""
    o__1.oblnk = 0;
#line 7742 ""
    f_open(&o__1);
#line 7743 ""
    s_wsfe(&io___544);
#line 7743 ""
    do_fio(&c__1, (char *)&nlinep, (ftnlen)sizeof(integer));
#line 7743 ""
    e_wsfe();
#line 7744 ""
    cl__1.cerr = 0;
#line 7744 ""
    cl__1.cunit = 19;
#line 7744 ""
    cl__1.csta = 0;
#line 7744 ""
    f_clos(&cl__1);
/* Computing MAX */
#line 7745 ""
    r__1 = ibarnop + .1f;
#line 7745 ""
    i__2 = 1, i__3 = (integer) (r_lg10(&r__1) + 1);
#line 7745 ""
    ndigbn = max(i__2,i__3);
#line 7746 ""
    r__1 = nlinep + .1f;
#line 7746 ""
    ndignl = (integer) (r_lg10(&r__1) + 1);
#line 7747 ""
    lenmsg = i_indx(msgq, "!", msgq_len, (ftnlen)1) - 1;

/*  Split off msgq(..) since UNIX compilers don't allow concat substring!!! */

#line 7751 ""
    ci__1.cierr = 0;
#line 7751 ""
    ci__1.ciunit = 6;
/* Writing concatenation */
#line 7751 ""
    i__4[0] = 8, a__2[0] = "(/,a15,i";
#line 7751 ""
    i__2 = ndignl + 48;
#line 7751 ""
    chax_(ch__2, (ftnlen)1, &i__2);
#line 7751 ""
    i__4[1] = 1, a__2[1] = ch__2;
#line 7751 ""
    i__4[2] = 5, a__2[2] = ",a6,i";
#line 7751 ""
    i__3 = ndigbn + 48;
#line 7751 ""
    chax_(ch__3, (ftnlen)1, &i__3);
#line 7751 ""
    i__4[3] = 1, a__2[3] = ch__3;
#line 7751 ""
    i__4[4] = 3, a__2[4] = ",$)";
#line 7751 ""
    ci__1.cifmt = (s_cat(ch__1, a__2, i__4, &c__5, (ftnlen)18), ch__1);
#line 7751 ""
    s_wsfe(&ci__1);
#line 7751 ""
    do_fio(&c__1, " ERROR in line ", (ftnlen)15);
#line 7751 ""
    do_fio(&c__1, (char *)&nlinep, (ftnlen)sizeof(integer));
#line 7751 ""
    do_fio(&c__1, ", bar ", (ftnlen)6);
#line 7751 ""
    do_fio(&c__1, (char *)&ibarnop, (ftnlen)sizeof(integer));
#line 7751 ""
    e_wsfe();
#line 7753 ""
    s_wsfe(&io___548);
#line 7753 ""
    do_fio(&c__1, msgq, lenmsg);
#line 7753 ""
    e_wsfe();
#line 7754 ""
    ci__1.cierr = 0;
#line 7754 ""
    ci__1.ciunit = 15;
/* Writing concatenation */
#line 7754 ""
    i__4[0] = 8, a__2[0] = "(/,a15,i";
#line 7754 ""
    i__2 = ndignl + 48;
#line 7754 ""
    chax_(ch__2, (ftnlen)1, &i__2);
#line 7754 ""
    i__4[1] = 1, a__2[1] = ch__2;
#line 7754 ""
    i__4[2] = 5, a__2[2] = ",a6,i";
#line 7754 ""
    i__3 = ndigbn + 48;
#line 7754 ""
    chax_(ch__3, (ftnlen)1, &i__3);
#line 7754 ""
    i__4[3] = 1, a__2[3] = ch__3;
#line 7754 ""
    i__4[4] = 3, a__2[4] = ",$)";
#line 7754 ""
    ci__1.cifmt = (s_cat(ch__1, a__2, i__4, &c__5, (ftnlen)18), ch__1);
#line 7754 ""
    s_wsfe(&ci__1);
#line 7754 ""
    do_fio(&c__1, " ERROR in line ", (ftnlen)15);
#line 7754 ""
    do_fio(&c__1, (char *)&nlinep, (ftnlen)sizeof(integer));
#line 7754 ""
    do_fio(&c__1, ", bar ", (ftnlen)6);
#line 7754 ""
    do_fio(&c__1, (char *)&ibarnop, (ftnlen)sizeof(integer));
#line 7754 ""
    e_wsfe();
#line 7756 ""
    s_wsfe(&io___549);
#line 7756 ""
    do_fio(&c__1, msgq, lenmsg);
#line 7756 ""
    e_wsfe();
#line 7757 ""
    i10 = iposn / 10;
#line 7758 ""
    i1 = iposn - i10 * 10;
#line 7759 ""
    ci__1.cierr = 0;
#line 7759 ""
    ci__1.ciunit = 6;
/* Writing concatenation */
#line 7759 ""
    i__5[0] = 1, a__3[0] = "(";
#line 7759 ""
    i__2 = i10 + 48;
#line 7759 ""
    chax_(ch__2, (ftnlen)1, &i__2);
#line 7759 ""
    i__5[1] = 1, a__3[1] = ch__2;
#line 7759 ""
    i__3 = i1 + 48;
#line 7759 ""
    chax_(ch__3, (ftnlen)1, &i__3);
#line 7759 ""
    i__5[2] = 1, a__3[2] = ch__3;
#line 7759 ""
    i__5[3] = 4, a__3[3] = "x,a)";
#line 7759 ""
    ci__1.cifmt = (s_cat(ch__4, a__3, i__5, &c__4, (ftnlen)7), ch__4);
#line 7759 ""
    s_wsfe(&ci__1);
#line 7759 ""
    do_fio(&c__1, "v", (ftnlen)1);
#line 7759 ""
    e_wsfe();
#line 7760 ""
    ci__1.cierr = 0;
#line 7760 ""
    ci__1.ciunit = 15;
/* Writing concatenation */
#line 7760 ""
    i__5[0] = 1, a__3[0] = "(";
#line 7760 ""
    i__2 = i10 + 48;
#line 7760 ""
    chax_(ch__2, (ftnlen)1, &i__2);
#line 7760 ""
    i__5[1] = 1, a__3[1] = ch__2;
#line 7760 ""
    i__3 = i1 + 48;
#line 7760 ""
    chax_(ch__3, (ftnlen)1, &i__3);
#line 7760 ""
    i__5[2] = 1, a__3[2] = ch__3;
#line 7760 ""
    i__5[3] = 4, a__3[3] = "x,a)";
#line 7760 ""
    ci__1.cifmt = (s_cat(ch__4, a__3, i__5, &c__4, (ftnlen)7), ch__4);
#line 7760 ""
    s_wsfe(&ci__1);
#line 7760 ""
    do_fio(&c__1, "v", (ftnlen)1);
#line 7760 ""
    e_wsfe();
#line 7761 ""
    s_wsle(&io___552);
#line 7761 ""
    do_lio(&c__9, &c__1, outq, (ftnlen)78);
#line 7761 ""
    e_wsle();
#line 7762 ""
    s_wsfe(&io___553);
/* Writing concatenation */
#line 7762 ""
    i__1[0] = 1, a__1[0] = " ";
#line 7762 ""
    i__1[1] = 78, a__1[1] = outq;
#line 7762 ""
    s_cat(ch__5, a__1, i__1, &c__2, (ftnlen)79);
#line 7762 ""
    do_fio(&c__1, ch__5, (ftnlen)79);
#line 7762 ""
    e_wsfe();
#line 7763 ""
    ci__1.cierr = 0;
#line 7763 ""
    ci__1.ciunit = 6;
/* Writing concatenation */
#line 7763 ""
    i__5[0] = 1, a__3[0] = "(";
#line 7763 ""
    i__2 = i10 + 48;
#line 7763 ""
    chax_(ch__2, (ftnlen)1, &i__2);
#line 7763 ""
    i__5[1] = 1, a__3[1] = ch__2;
#line 7763 ""
    i__3 = i1 + 48;
#line 7763 ""
    chax_(ch__3, (ftnlen)1, &i__3);
#line 7763 ""
    i__5[2] = 1, a__3[2] = ch__3;
#line 7763 ""
    i__5[3] = 4, a__3[3] = "x,a)";
#line 7763 ""
    ci__1.cifmt = (s_cat(ch__4, a__3, i__5, &c__4, (ftnlen)7), ch__4);
#line 7763 ""
    s_wsfe(&ci__1);
#line 7763 ""
    do_fio(&c__1, "^", (ftnlen)1);
#line 7763 ""
    e_wsfe();
#line 7764 ""
    ci__1.cierr = 0;
#line 7764 ""
    ci__1.ciunit = 15;
/* Writing concatenation */
#line 7764 ""
    i__5[0] = 1, a__3[0] = "(";
#line 7764 ""
    i__2 = i10 + 48;
#line 7764 ""
    chax_(ch__2, (ftnlen)1, &i__2);
#line 7764 ""
    i__5[1] = 1, a__3[1] = ch__2;
#line 7764 ""
    i__3 = i1 + 48;
#line 7764 ""
    chax_(ch__3, (ftnlen)1, &i__3);
#line 7764 ""
    i__5[2] = 1, a__3[2] = ch__3;
#line 7764 ""
    i__5[3] = 4, a__3[3] = "x,a)";
#line 7764 ""
    ci__1.cifmt = (s_cat(ch__4, a__3, i__5, &c__4, (ftnlen)7), ch__4);
#line 7764 ""
    s_wsfe(&ci__1);
#line 7764 ""
    do_fio(&c__1, "^", (ftnlen)1);
#line 7764 ""
    e_wsfe();
#line 7765 ""
    return 0;
} /* errmsg_ */

/* Subroutine */ int eskb4_(integer *ip, integer *ivx, integer *in, integer *
	ib, real *space, real *tstart, real *fbar, integer *itrpt, real *esk)
{
    /* System generated locals */
    real r__1;

    /* Builtin functions */
    integer i_nint(real *), s_wsle(cilist *), do_lio(integer *, integer *, 
	    char *, ftnlen), e_wsle(void);
    /* Subroutine */ int s_stop(char *, ftnlen);

    /* Local variables */
    static integer iib;
    extern doublereal feon_(real *);
    static integer itnd, nnsk, itprev;

    /* Fortran I/O blocks */
    static cilist io___558 = { 0, 6, 0, 0, 0 };



/*  Get elemskips to previous note.  Called only for graces, no xtups involved. */

#line 7785 ""
    /* Parameter adjustments */
#line 7785 ""
    --tstart;
#line 7785 ""
    --space;
#line 7785 ""

#line 7785 ""
    /* Function Body */
#line 7785 ""
    itnd = i_nint(&all_1.to[*in - 1]);
#line 7786 ""
    if (*ip == 1 || itnd == *itrpt) {

/*  Start of bar or after rpt. */

#line 7790 ""
	*esk = *fbar;
#line 7791 ""
	return 0;
#line 7792 ""
    } else {
#line 7793 ""
	*esk = 0.f;
#line 7794 ""
	itprev = itnd - all_1.nodur[*ivx + (*ip - 1) * 24 - 25];
#line 7795 ""
	for (iib = *ib; iib >= 1; --iib) {
#line 7796 ""
	    if (tstart[iib] < itprev + comtol_1.tol) {

/*  This is the block */

#line 7800 ""
		r__1 = (real) (itnd - itprev) / space[iib];
#line 7800 ""
		nnsk = i_nint(&r__1);
#line 7801 ""
		*esk += nnsk * feon_(&space[iib]);
#line 7802 ""
		return 0;
#line 7803 ""
	    } else {
#line 7804 ""
		r__1 = (itnd - tstart[iib]) / space[iib];
#line 7804 ""
		nnsk = i_nint(&r__1);
#line 7805 ""
		*esk += nnsk * feon_(&space[iib]);
#line 7806 ""
		itnd = i_nint(&tstart[iib]);
#line 7807 ""
	    }
#line 7808 ""
/* L1: */
#line 7808 ""
	}
#line 7809 ""
    }
#line 7810 ""
    s_wsle(&io___558);
#line 7810 ""
    do_lio(&c__9, &c__1, "Problem in eskb4.  Send files to Dr. Don", (ftnlen)
	    40);
#line 7810 ""
    e_wsle();
#line 7811 ""
    s_stop("", (ftnlen)0);
#line 7812 ""
    return 0;
} /* eskb4_ */

doublereal f1eon_(real *time)
{
    /* System generated locals */
    real ret_val;

    /* Builtin functions */
    double sqrt(doublereal);

#line 7814 ""
    ret_val = sqrt(*time / 2);
#line 7815 ""
    return ret_val;
} /* f1eon_ */

doublereal feon_(real *time)
{
    /* System generated locals */
    real ret_val;
    doublereal d__1, d__2;

    /* Builtin functions */
    double sqrt(doublereal), pow_dd(doublereal *, doublereal *);

#line 7819 ""
    d__1 = (doublereal) sqrt(*time / 2);
#line 7819 ""
    d__2 = (doublereal) (1.f - comeon_1.eonk);
#line 7819 ""
    ret_val = pow_dd(&d__1, &d__2) * comeon_1.ewmxk;
#line 7820 ""
    return ret_val;
} /* feon_ */

/* Subroutine */ int findbeam_(integer *ibmrep, integer *numbms, integer *
	mapfb)
{
    /* Initialized data */

    static integer nip1[248] = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };
    static integer nip2[248] = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };
    static integer nummask[3] = { 29,49,12 };
    static integer mask[147]	/* was [49][3] */ = { 65535,4095,65520,255,
	    65280,63,252,16128,64512,15,240,3840,61440,7,14,112,224,1792,3584,
	    28672,57344,3,12,48,192,768,3072,12288,49152,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,16777215,65535,16776960,4095,65520,1048320,
	    16773120,255,65280,16711680,63,252,16128,64512,4128768,16515072,
	    15,60,240,3840,15360,61440,983040,3932160,15728640,7,14,112,224,
	    1792,3584,28672,57344,458752,917504,7340032,14680064,3,12,48,192,
	    768,3072,12288,49152,196608,786432,3145728,12582912,4095,255,4080,
	    15,240,3840,3,12,48,192,768,3072,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };
    static logical eqonly[147]	/* was [49][3] */ = { TRUE_,TRUE_,TRUE_,
	    FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,
	    FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,
	    FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,
	    FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,
	    FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,
	    FALSE_,TRUE_,TRUE_,TRUE_,TRUE_,TRUE_,TRUE_,TRUE_,FALSE_,FALSE_,
	    FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,
	    FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,
	    FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,
	    FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,
	    FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,
	    FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,
	    FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,
	    FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,
	    FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,
	    FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,FALSE_,FALSE_ };

    /* System generated locals */
    integer i__1, i__2, i__3, i__4;
    real r__1, r__2;

    /* Builtin functions */
    integer lbit_shift(integer, integer), s_wsle(cilist *), do_lio(integer *, 
	    integer *, char *, ftnlen), e_wsle(void);
    double r_mod(real *, real *);

    /* Local variables */
    static integer ib, ip, ir, it, is, ib1, ib2, ir1, is1, is2, it2, iip, ipr[
	    248], itr[248], mape, mapm, irep, maps, nreal, itend, itoff, 
	    maskm, nodue[248], itseg, mtemp;
    static logical short__[248];
    static integer itnow, ithalf, numnew;
    extern /* Subroutine */ int logbeam_(integer *, integer *, integer *);
    static integer masknow;

    /* Fortran I/O blocks */
    static cilist io___592 = { 0, 6, 0, 0, 0 };



/*  Called once per voice per bar, after setting forced beams. */

/*      integer numbms(nm),ipr(48),nip1(0:47),nip2(0:47),mapfb(24), */
/*     *       itr(48),nodue(48) */
/*      logical short(48),eqonly */
#line 7850 ""
    /* Parameter adjustments */
#line 7850 ""
    --mapfb;
#line 7850 ""
    --numbms;
#line 7850 ""

#line 7850 ""
    /* Function Body */
#line 7871 ""
    ip = 0;
#line 7872 ""
    nreal = 0;
#line 7873 ""
    itnow = 0;
#line 7874 ""
L1:
#line 7875 ""
    ++ip;
#line 7876 ""
    if (ip > all_1.nn[commvl_1.ivx - 1]) {
#line 7876 ""
	goto L9;
#line 7876 ""
    }
#line 7877 ""
L11:
#line 7877 ""
    if (all_1.nodur[commvl_1.ivx + ip * 24 - 25] == 0) {

/*  Ignore all xtup notes except the last, the one with nodur > 0 . */
/*  Xtups are irrelevant here since they are already all in forced beams. */
/*  Will update itnow by nodur at the END of this loop */

#line 7883 ""
	++ip;
#line 7884 ""
	goto L11;
#line 7885 ""
    }
#line 7886 ""
    ++nreal;
#line 7887 ""
    nodue[nreal - 1] = all_1.nodur[commvl_1.ivx + ip * 24 - 25];
#line 7888 ""
    short__[nreal - 1] = nodue[nreal - 1] < 16 && ! bit_test(all_1.irest[
	    commvl_1.ivx + ip * 24 - 25],0) && ! bit_test(all_1.islur[
	    commvl_1.ivx + ip * 24 - 25],18);

/*  Rule out notes that have 'alone'-flag set */

#line 7894 ""
    ipr[nreal - 1] = ip;
#line 7895 ""
    itr[nreal - 1] = itnow;
#line 7896 ""
    if (nodue[nreal - 1] == 1) {

/*  64th gap */

#line 7900 ""
	if (itnow % 2 == 0) {

/*  Start of 32nd gap, lump with following note */

#line 7904 ""
	    ++ip;
#line 7905 ""
	    nodue[nreal - 1] = all_1.nodur[commvl_1.ivx + ip * 24 - 25] + 1;
#line 7906 ""
	    itnow += nodue[nreal - 1];
#line 7907 ""
	} else {

/*  End of 32nd gap, lump with preceeding note */

#line 7911 ""
	    --nreal;
#line 7912 ""
	    ++nodue[nreal - 1];
#line 7913 ""
	    ++itnow;
#line 7914 ""
	}
#line 7915 ""
    } else {
#line 7916 ""
	itnow += all_1.nodur[commvl_1.ivx + ip * 24 - 25];
#line 7917 ""
    }
#line 7918 ""
    goto L1;
#line 7919 ""
L9:
#line 7920 ""
    ir1 = 1;
#line 7921 ""
    itseg = all_1.lenbar / *ibmrep;
#line 7922 ""
    i__1 = *ibmrep;
#line 7922 ""
    for (irep = 1; irep <= i__1; ++irep) {

/*  Set bitmaps for all shorts neighbored by a short. Each bit represents a */
/*  span of 32nd note.  maps, mapm, mape record start, full duration, and end */
/*  of consecutive span of beamable (<1/4) notes. */

#line 7928 ""
	maps = 0;
#line 7929 ""
	mapm = 0;
#line 7930 ""
	mape = 0;
#line 7931 ""
	itend = itseg * irep;
#line 7932 ""
	itoff = itend - itseg;
#line 7933 ""
	i__2 = nreal;
#line 7933 ""
	for (ir = ir1; ir <= i__2; ++ir) {
#line 7934 ""
	    it2 = itr[ir - 1] + nodue[ir - 1] - 2;
#line 7935 ""
	    if (it2 >= itend) {
#line 7936 ""
		ir1 = ir;
#line 7937 ""
		goto L14;
#line 7938 ""
	    }
/*         if (short(ir).and.((ir.gt.1.and.short(ir-1)).or.(ir.lt.nreal */
/* Computing MAX */
#line 7940 ""
	    i__3 = ir - 1;
#line 7940 ""
	    if (short__[ir - 1] && (ir > 1 && short__[max(i__3,1) - 1] || ir <
		     nreal && short__[ir])) {
#line 7942 ""
		ib1 = (itr[ir - 1] - itoff) / 2;
#line 7943 ""
		ib2 = (it2 - itoff) / 2;
#line 7944 ""
		if (max(ib1,ib2) > 47 || ir > 48 || min(ib1,ib2) < 0) {
#line 7944 ""
		    return 0;
#line 7944 ""
		}

/*  Must have an odd number obe beats in a long bar.  Auto-beam won't work */

#line 7949 ""
		nip1[ib1] = ipr[ir - 1];
#line 7950 ""
		nip2[ib2] = ipr[ir - 1];

/*  nip1,2(ib) = 0 unless a real note starts,ends on bit ib; then = ip */

#line 7954 ""
		maps = bit_set(maps,ib1);
#line 7955 ""
		mape = bit_set(mape,ib2);
#line 7956 ""
		i__3 = ib2;
#line 7956 ""
		for (ib = ib1; ib <= i__3; ++ib) {
#line 7957 ""
		    mapm = bit_set(mapm,ib);
#line 7958 ""
/* L3: */
#line 7958 ""
		}
#line 7959 ""
	    }
#line 7960 ""
/* L2: */
#line 7960 ""
	}
#line 7961 ""
L14:
#line 7962 ""
	if (mapm == 0) {
#line 7962 ""
	    goto L13;
#line 7962 ""
	}

/*  Zero out bits from forced beams */

#line 7966 ""
	maps &= ~ mapfb[irep];
#line 7967 ""
	mapm &= ~ mapfb[irep];
#line 7968 ""
	mape &= ~ mapfb[irep];

/*  Compare map with template. */

#line 7972 ""
	i__2 = nummask[combeam_1.ibmtyp - 1];
#line 7972 ""
	for (it = 1; it <= i__2; ++it) {
#line 7973 ""
	    masknow = mask[it + combeam_1.ibmtyp * 49 - 50];
#line 7974 ""
	    if ((masknow & mapm) == masknow) {

/*  Find least significant bit in the mask to check start time */

#line 7978 ""
		mtemp = masknow;
#line 7979 ""
		maskm = masknow;
#line 7980 ""
		for (is1 = 0; is1 <= 47; ++is1) {
/*            do 5 is1 = 0 , 247 */
#line 7982 ""
		    if ((1 & mtemp) == 1) {
#line 7982 ""
			goto L6;
#line 7982 ""
		    }
#line 7983 ""
		    mtemp = lbit_shift(mtemp, (ftnlen)-1);
#line 7984 ""
/* L5: */
#line 7984 ""
		}
#line 7985 ""
L6:
#line 7986 ""
		if ((lbit_shift((ftnlen)1, is1) & maps) == 0) {
#line 7986 ""
		    goto L4;
#line 7986 ""
		}

/*  is1 is the bit where the beam starts.  Continue shifting to */
/*  find most significant bit in the mask to check ending time */

#line 7991 ""
		for (is2 = is1; is2 <= 47; ++is2) {
/*            do 7 is2 = is1 , 247 */
#line 7993 ""
		    mtemp = lbit_shift(mtemp, (ftnlen)-1);
#line 7994 ""
		    if ((1 & ~ mtemp) == 1) {
#line 7994 ""
			goto L8;
#line 7994 ""
		    }
#line 7995 ""
/* L7: */
#line 7995 ""
		}
#line 7996 ""
L8:

/*  is2 is now the bit on which the beam ends. */

#line 8000 ""
		if ((lbit_shift((ftnlen)1, is2) & mape) == 0) {
#line 8000 ""
		    goto L4;
#line 8000 ""
		}

/*  Did we pick out a single note from the middle of a longer sequence? */

#line 8004 ""
		if (nip1[is1] == nip2[is2]) {
#line 8004 ""
		    goto L4;
#line 8004 ""
		}

/*  We almost have a beam.  Check equality of notes if needed. */

#line 8008 ""
		if (eqonly[it + combeam_1.ibmtyp * 49 - 50]) {
#line 8009 ""
		    i__3 = nip2[is2];
#line 8009 ""
		    for (ip = nip1[is1]; ip <= i__3; ++ip) {
#line 8010 ""
			if (all_1.nodur[commvl_1.ivx + ip * 24 - 25] != 8) {

/*  There is a non-1/8th note in this beam. Exit if not 2 quarters */

#line 8014 ""
			    if (is2 - is1 != 15) {
#line 8014 ""
				goto L4;
#line 8014 ""
			    }

/*  Beam is 2 quarters long.  Check if can split in half. */

#line 8018 ""
			    ithalf = 0;
#line 8019 ""
			    i__4 = nip2[is2];
#line 8019 ""
			    for (iip = nip1[is1]; iip <= i__4; ++iip) {
#line 8020 ""
				ithalf += all_1.nodur[commvl_1.ivx + iip * 24 
					- 25];
#line 8021 ""
				if (ithalf > 16) {
#line 8021 ""
				    goto L4;
#line 8021 ""
				}
#line 8022 ""
				if (ithalf == 16) {
#line 8022 ""
				    goto L21;
#line 8022 ""
				}
#line 8023 ""
/* L20: */
#line 8023 ""
			    }
#line 8024 ""
			    s_wsle(&io___592);
#line 8024 ""
			    do_lio(&c__9, &c__1, "Problem in findbeam, pleas"\
				    "e call Dr. Don", (ftnlen)40);
#line 8024 ""
			    e_wsle();
#line 8025 ""
			    goto L4;
#line 8026 ""
L21:

/*  Otherwise, split in half by keeping only the first half.  Other half will */
/*  be picked up later, assuming masks are listed longest first. */

#line 8031 ""
			    is2 = is1 + 7;

/*  Reset maskm (since only used part of mask), used later to zero out */
/*  bits that contain beams */

#line 8036 ""
			    maskm = 0;
#line 8037 ""
			    i__4 = is2;
#line 8037 ""
			    for (is = is1; is <= i__4; ++is) {
#line 8038 ""
				maskm = bit_set(maskm,is);
#line 8039 ""
/* L15: */
#line 8039 ""
			    }
#line 8040 ""
			    goto L16;
#line 8041 ""
			}
#line 8042 ""
/* L10: */
#line 8042 ""
		    }
#line 8043 ""
		}
#line 8044 ""
L16:

/*  This is a beam.  If last "effective" ends on odd 64th, add 1 more */

/*            if (abs(mod(to(iand(255,ipl(ivx,nip2(is2)))) */
/*     *           +nodur(ivx,nip2(is2)),2.)) .gt. tol) then */
#line 8050 ""
		r__2 = all_1.to[comipl2_1.ipl2[commvl_1.ivx + nip2[is2] * 24 
			- 25] - 1] + all_1.nodur[commvl_1.ivx + nip2[is2] * 
			24 - 25] + comtol_1.tol * .5f;
#line 8050 ""
		if ((r__1 = r_mod(&r__2, &c_b1913), dabs(r__1)) > 
			comtol_1.tol) {
#line 8052 ""
		    ++nip2[is2];
#line 8053 ""
		}
#line 8054 ""
		++numbms[commvl_1.ivx];
#line 8055 ""
		numnew = numbms[commvl_1.ivx];
#line 8056 ""
		logbeam_(&numnew, &nip1[is1], &nip2[is2]);

/*  Zero out the appropriate bits so these notes don't get used again */

#line 8060 ""
		mapm &= ~ maskm;
#line 8061 ""
		if (mapm == 0) {
#line 8061 ""
		    goto L13;
#line 8061 ""
		}
#line 8062 ""
		maps &= ~ maskm;
#line 8063 ""
		mape &= ~ maskm;
#line 8064 ""
	    }
#line 8065 ""
L4:
#line 8065 ""
	    ;
#line 8065 ""
	}
#line 8066 ""
L13:
#line 8066 ""
	;
#line 8066 ""
    }
#line 8067 ""
    return 0;
} /* findbeam_ */

/* Subroutine */ int findeonk_(integer *nptr1, integer *nptr2, real *wovera, 
	real *xelsk, real *dtmin, real *dtmax, real *eonk0)
{
    /* System generated locals */
    integer i__1;
    real r__1;
    doublereal d__1, d__2;

    /* Builtin functions */
    double pow_dd(doublereal *, doublereal *), sqrt(doublereal), log(
	    doublereal);

    /* Local variables */
    static real f, fp;
    extern doublereal feon_(real *);
    static real targ, esum;
    static integer iptr;
    extern doublereal f1eon_(real *);
    static real desum, dsoln;
    static integer niter;
    static real detarg;
    extern /* Subroutine */ int printl_(char *, ftnlen);


/*  Compute an exponent eonk for use in the "flattened" formula for elemskips */
/*   vs time.  We must solve the eqution f = 0.  Initial quess is eonk0. */

#line 8080 ""
    comeon_1.eonk = *eonk0;
#line 8081 ""
    niter = 0;
#line 8082 ""
L1:
#line 8083 ""
    d__1 = (doublereal) f1eon_(dtmax);
#line 8083 ""
    d__2 = (doublereal) comeon_1.eonk;
#line 8083 ""
    comeon_1.ewmxk = pow_dd(&d__1, &d__2);
#line 8084 ""
    ++niter;
#line 8085 ""
    esum = 0.f;
#line 8086 ""
    desum = 0.f;
#line 8087 ""
    i__1 = *nptr2;
#line 8087 ""
    for (iptr = *nptr1; iptr <= i__1; ++iptr) {
#line 8088 ""
	targ = c1omnotes_1.durb[iptr - 1] / c1omnotes_1.sqzb[iptr - 1];
#line 8089 ""
	esum += c1omnotes_1.nnpd[iptr - 1] * c1omnotes_1.sqzb[iptr - 1] * 
		feon_(&targ);
#line 8090 ""
	d__1 = (doublereal) (*dtmax / targ);
#line 8090 ""
	d__2 = (doublereal) comeon_1.eonk;
#line 8090 ""
	detarg = sqrt(targ / 2 * pow_dd(&d__1, &d__2)) * log(*dtmax / targ);
#line 8091 ""
	desum += c1omnotes_1.nnpd[iptr - 1] * c1omnotes_1.sqzb[iptr - 1] * 
		detarg;
#line 8092 ""
/* L2: */
#line 8092 ""
    }
#line 8093 ""
    f = *wovera * feon_(dtmin) - *xelsk - esum;
#line 8094 ""
    d__1 = (doublereal) (*dtmax / *dtmin);
#line 8094 ""
    d__2 = (doublereal) comeon_1.eonk;
#line 8094 ""
    fp = *wovera * sqrt(*dtmin / 2 * pow_dd(&d__1, &d__2)) * log(*dtmax / *
	    dtmin) - desum;
#line 8096 ""
    if (dabs(fp) < comtol_1.tol || (r__1 = comeon_1.eonk - .5f, dabs(r__1)) > 
	    .5f || niter > 100) {
#line 8097 ""
	printl_("Error in findeonk.  Please send source to Dr. Don", (ftnlen)
		49);
#line 8099 ""
	comeon_1.eonk = 0.f;
#line 8100 ""
	comeon_1.ewmxk = 1.f;
#line 8101 ""
	return 0;
#line 8102 ""
    }
#line 8103 ""
    dsoln = -f / fp;
#line 8104 ""
    if (dabs(dsoln) < comtol_1.tol * .1f) {
#line 8104 ""
	return 0;
#line 8104 ""
    }

/*  Not converged yet, try again */

#line 8108 ""
    comeon_1.eonk += dsoln;
#line 8109 ""
    goto L1;
} /* findeonk_ */

doublereal fnote_(integer *nodur, integer *ivx, integer *ip, integer *nacc)
{
    /* System generated locals */
    real ret_val;

    /* Builtin functions */
    integer s_wsle(cilist *), do_lio(integer *, integer *, char *, ftnlen), 
	    e_wsle(void);

    /* Local variables */
    static integer iip, ip1m1;
    extern /* Subroutine */ int stop1_(void);
    static integer ndoub, ipback;
    extern /* Subroutine */ int printl_(char *, ftnlen);

    /* Fortran I/O blocks */
    static cilist io___608 = { 0, 6, 0, 0, 0 };
    static cilist io___609 = { 0, 6, 0, 0, 0 };



/*  This return the real duration of a note */

#line 8118 ""
    /* Parameter adjustments */
#line 8118 ""
    nacc -= 25;
#line 8118 ""
    nodur -= 25;
#line 8118 ""

#line 8118 ""
    /* Function Body */
#line 8118 ""
    ipback = *ip;
#line 8119 ""
    if (nodur[*ivx + *ip * 24] > 0) {
#line 8120 ""
	if (*ip > 1) {

/*  Check if this is last note of xtup */

#line 8124 ""
	    if (nodur[*ivx + (*ip - 1) * 24] == 0) {
#line 8125 ""
		ipback = *ip - 1;
#line 8126 ""
		goto L2;
#line 8127 ""
	    }
#line 8128 ""
	}
#line 8129 ""
	ret_val = (real) nodur[*ivx + *ip * 24];
#line 8130 ""
	return ret_val;
#line 8131 ""
    }
#line 8132 ""
L2:

/*  Count back to prior non zero note. Start at ip to avoid neg index if ip=1. */
/*  Count how many doubled xtups notes there are from ip-1 to first note. */

#line 8137 ""
    ndoub = 0;
#line 8138 ""
    for (ip1m1 = ipback; ip1m1 >= 1; --ip1m1) {
#line 8139 ""
	if (nodur[*ivx + ip1m1 * 24] > 0) {
#line 8139 ""
	    goto L4;
#line 8139 ""
	}
#line 8140 ""
	if (ip1m1 < *ip && bit_test(nacc[*ivx + ip1m1 * 24],18)) {
#line 8140 ""
	    ++ndoub;
#line 8140 ""
	}
#line 8141 ""
/* L1: */
#line 8141 ""
    }
#line 8142 ""
L4:

/*  count forward to next non-0 nodur. Start at ip in case last note of xtup. */

#line 8146 ""
    for (iip = *ip; iip <= 200; ++iip) {

/*  Count doubled xtup notes from ip to end. */

#line 8150 ""
	if (bit_test(nacc[*ivx + iip * 24],18)) {
#line 8150 ""
	    ++ndoub;
#line 8150 ""
	}
#line 8151 ""
	if (nodur[*ivx + iip * 24] > 0) {
/*          fnote = nodur(ivx,iip)/float(iip-ip1m1) */
#line 8153 ""
	    ret_val = nodur[*ivx + iip * 24] / (real) (iip - ip1m1 + ndoub);
#line 8154 ""
	    if (bit_test(nacc[*ivx + *ip * 24],18)) {
#line 8155 ""
		ret_val *= 2;
#line 8156 ""
	    } else if (bit_test(nacc[*ivx + *ip * 24],27)) {
#line 8157 ""
		ret_val *= 1.5f;
#line 8158 ""
	    } else if (*ip > 1) {
#line 8159 ""
		if (bit_test(nacc[*ivx + (*ip - 1) * 24],27)) {
#line 8159 ""
		    ret_val *= .5f;
#line 8159 ""
		}
#line 8160 ""
	    }
#line 8161 ""
	    return ret_val;
#line 8162 ""
	}
#line 8163 ""
/* L3: */
#line 8163 ""
    }
#line 8164 ""
    s_wsle(&io___608);
#line 8164 ""
    do_lio(&c__9, &c__1, " ", (ftnlen)1);
#line 8164 ""
    e_wsle();
#line 8165 ""
    printl_("Probable misplaced barline or incorrect meter, stopping", (
	    ftnlen)55);
#line 8167 ""
    s_wsle(&io___609);
#line 8167 ""
    do_lio(&c__9, &c__1, "ivx,ip:", (ftnlen)7);
#line 8167 ""
    do_lio(&c__3, &c__1, (char *)&(*ivx), (ftnlen)sizeof(integer));
#line 8167 ""
    do_lio(&c__3, &c__1, (char *)&(*ip), (ftnlen)sizeof(integer));
#line 8167 ""
    e_wsle();
#line 8168 ""
    stop1_();
#line 8169 ""
    return ret_val;
} /* fnote_ */

/* Subroutine */ int g1etchar_(char *lineq, integer *iccount, char *charq, 
	ftnlen lineq_len, ftnlen charq_len)
{
    /* Builtin functions */
    /* Subroutine */ int s_copy(char *, char *, ftnlen, ftnlen);

    /* Local variables */
    static integer ndxm;
    extern /* Subroutine */ int read10_(char *, logical *, ftnlen), m1rec1_(
	    char *, integer *, integer *, integer *, integer *, integer *, 
	    ftnlen);
    static integer nbars, ibaroff, ibarcnt;


/*  Gets the next character out of lineq*128.  If pointer iccount=128 on entry, */
/*  then reads in a new line.  Resets iccount.  Ends program if no more input. */

#line 8183 ""
    if (*iccount == 128) {
#line 8184 ""
	read10_(lineq, &c1omget_1.lastchar, (ftnlen)128);
#line 8185 ""
	if (c1omget_1.lastchar) {
#line 8185 ""
	    return 0;
#line 8185 ""
	}
#line 8186 ""
	if (! commac_1.endmac) {
#line 8187 ""
	    *iccount = 0;
#line 8188 ""
	    if (! commac_1.mplay) {
#line 8188 ""
		++c1omget_1.nline;
#line 8188 ""
	    }
#line 8189 ""
	} else {
#line 8190 ""
	    commac_1.endmac = FALSE_;
#line 8191 ""
	    *iccount = commac_1.icchold;
#line 8192 ""
	    s_copy(lineq, commac_1.lnholdq, (ftnlen)128, (ftnlen)128);
#line 8193 ""
	}
#line 8194 ""
	if (commac_1.mrecord) {
#line 8195 ""
	    m1rec1_(lineq, iccount, &ibarcnt, &ibaroff, &nbars, &ndxm, (
		    ftnlen)128);
#line 8196 ""
	}
#line 8197 ""
    }
#line 8198 ""
    ++(*iccount);
#line 8199 ""
    *(unsigned char *)charq = *(unsigned char *)&lineq[*iccount - 1];
#line 8200 ""
    return 0;
} /* g1etchar_ */

/* Subroutine */ int g1etnote_(logical *loop, integer *ifig, logical *
	optimize, logical *fulltrans)
{
    /* Initialized data */

    static char literq[51*3] = "Literal TeX string cannot start with 4 backs"
	    "lashes!" "TeX string must have <129 char, end with backslash!" 
	    "Type 2 or 3 TeX string can only start in column 1! ";
    static char lyrerq[51*5] = "pmxlyr string must end with \" followed by b"
	    "lank!   " "pmxlyr string cannot extend past position 120!     " 
	    "There must be \"a\" or \"b\" here!                     " "There"
	    " must be \"+\" or \"-\" here!                     " "There must "
	    "be an integer here!                     ";

    /* System generated locals */
    address a__1[3], a__2[2], a__3[4];
    integer i__1, i__2[3], i__3[2], i__4, i__5, i__6, i__7, i__8[4];
    real r__1;
    char ch__1[42], ch__2[1], ch__3[2], ch__4[1], ch__5[55], ch__6[54], ch__7[
	    46];
    icilist ici__1;

    /* Builtin functions */
    integer i_indx(char *, char *, ftnlen, ftnlen), s_wsle(cilist *), e_wsle(
	    void), do_lio(integer *, integer *, char *, ftnlen), s_wsfe(
	    cilist *);
    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
    integer do_fio(integer *, char *, ftnlen), e_wsfe(void), s_cmp(char *, 
	    char *, ftnlen, ftnlen), i_nint(real *);
    double log(doublereal);
    integer pow_ii(integer *, integer *), s_rsfi(icilist *), e_rsfi(void);

    /* Local variables */
    extern integer i1fnodur_(integer *, char *, ftnlen);
    extern /* Subroutine */ int checkdyn_(char *, integer *, integer *, 
	    ftnlen);
    static integer idotform, ndxquote, i__, j;
    extern /* Subroutine */ int readmeter_(char *, integer *, integer *, 
	    integer *, ftnlen), getpmxmod_(logical *, char *, ftnlen), 
	    chkpmxlyr_(char *, integer *, integer *, ftnlen);
    static integer ic, igr, ipm;
    static real dum;
    static integer ngr, iiv, nbb4, num1, num2;
    extern /* Character */ VOID chax_(char *, ftnlen, integer *);
    static logical cdot;
    static real fnum;
    static char dumq[1], dotq[1], durq[1];
    static integer itup;
    static real snum;
    static integer ntup;
    extern /* Subroutine */ int g1etx_(char *, integer *, logical *, integer *
	    , real *, real *, ftnlen), stop1_(void), read10_(char *, logical *
	    , ftnlen);
    static real dimen;
    static char charq[1];
    static integer indxb;
    static char lineq[128];
    static integer icsav, ndoub, iorig, iinow, iposn, ninow;
    extern /* Subroutine */ int getitransinfo_(logical *, integer *, char *, 
	    integer *, integer *, integer *, integer *, ftnlen);
    static integer icclhw;
    static char charlq[1];
    extern /* Subroutine */ int setmac_(char *, integer *, integer *, integer 
	    *, integer *, char *, char *, integer *, integer *, ftnlen, 
	    ftnlen, ftnlen), chklit_(char *, integer *, integer *, ftnlen);
    static logical fulbrp;
    extern /* Subroutine */ int errmsg_(char *, integer *, integer *, char *, 
	    ftnlen, ftnlen);
    static integer literr, numint, numnum;
    static logical ztrans;
    static integer lyrerr, mtrnmp, mtrdnp;
    static real fnsyst, sysflb;
    static integer lenbeat;
    extern /* Subroutine */ int getchar_(char *, integer *, char *, ftnlen, 
	    ftnlen), getmidi_(integer *, char *, integer *, integer *, 
	    integer *, integer *, integer *, integer *, integer *, logical *, 
	    ftnlen), readnum_(char *, integer *, char *, real *, ftnlen, 
	    ftnlen);
    static integer mtrdenl, lenmult, numshft;
    static logical plusmin;
    static real tintstf;
    extern /* Subroutine */ int g1etchar_(char *, integer *, char *, ftnlen, 
	    ftnlen);
    static logical twotrem;
    static integer lvoltxt;

    /* Fortran I/O blocks */
    static cilist io___621 = { 0, 6, 0, 0, 0 };
    static cilist io___622 = { 0, 6, 0, 0, 0 };
    static cilist io___623 = { 0, 6, 0, 0, 0 };
    static cilist io___624 = { 0, 6, 0, 0, 0 };
    static cilist io___625 = { 0, 15, 0, "(/a)", 0 };
    static cilist io___626 = { 0, 15, 0, "(a11,2x,i3)", 0 };
    static cilist io___627 = { 0, 15, 0, 0, 0 };
    static cilist io___628 = { 0, 6, 0, 0, 0 };
    static cilist io___636 = { 0, 6, 0, 0, 0 };
    static cilist io___637 = { 0, 6, 0, 0, 0 };
    static cilist io___638 = { 0, 6, 0, 0, 0 };
    static cilist io___643 = { 0, 6, 0, 0, 0 };
    static cilist io___644 = { 0, 6, 0, 0, 0 };
    static cilist io___645 = { 0, 6, 0, 0, 0 };
    static cilist io___659 = { 0, 6, 0, 0, 0 };
    static cilist io___662 = { 0, 6, 0, 0, 0 };
    static cilist io___663 = { 0, 6, 0, 0, 0 };
    static cilist io___664 = { 0, 6, 0, 0, 0 };
    static cilist io___667 = { 0, 6, 0, 0, 0 };
    static cilist io___673 = { 0, 6, 0, 0, 0 };
    static cilist io___674 = { 0, 6, 0, 0, 0 };
    static cilist io___675 = { 0, 15, 0, "(/,a)", 0 };
    static cilist io___676 = { 0, 6, 0, 0, 0 };
    static cilist io___677 = { 0, 6, 0, 0, 0 };
    static cilist io___678 = { 0, 15, 0, "(a)", 0 };
    static cilist io___679 = { 0, 15, 0, "(a)", 0 };
    static cilist io___684 = { 0, 6, 0, 0, 0 };
    static cilist io___685 = { 0, 15, 0, "(a)", 0 };
    static cilist io___689 = { 0, 6, 0, 0, 0 };
    static cilist io___690 = { 0, 6, 0, 0, 0 };
    static cilist io___691 = { 0, 6, 0, 0, 0 };
    static cilist io___692 = { 0, 6, 0, "(1x,a21,i3,a23)", 0 };
    static cilist io___696 = { 0, 6, 0, 0, 0 };
    static cilist io___697 = { 0, 6, 0, 0, 0 };
    static cilist io___701 = { 0, 6, 0, 0, 0 };
    static cilist io___702 = { 0, 6, 0, 0, 0 };


#line 8273 ""
    cdot = FALSE_;
#line 8274 ""
    twotrem = FALSE_;
#line 8275 ""
L1:
#line 8275 ""
    g1etchar_(lineq, &a1ll_2.iccount, charq, (ftnlen)128, (ftnlen)1);
#line 8276 ""
    if (*(unsigned char *)charq != ' ') {
#line 8276 ""
	*(unsigned char *)charlq = *(unsigned char *)charq;
#line 8276 ""
    }
#line 8277 ""
    if (c1omget_1.lastchar) {
#line 8278 ""
	if (i_indx("/%", charlq, (ftnlen)2, (ftnlen)1) == 0) {
#line 8279 ""
	    s_wsle(&io___621);
#line 8279 ""
	    e_wsle();
#line 8280 ""
	    s_wsle(&io___622);
#line 8280 ""
	    do_lio(&c__9, &c__1, "WARNING:", (ftnlen)8);
#line 8280 ""
	    e_wsle();
#line 8281 ""
	    s_wsle(&io___623);
#line 8281 ""
	    do_lio(&c__9, &c__1, "Last non-blank character is \"", (ftnlen)29)
		    ;
#line 8281 ""
	    do_lio(&c__9, &c__1, charlq, (ftnlen)1);
#line 8281 ""
	    do_lio(&c__9, &c__1, "\", not \"/,%\"", (ftnlen)12);
#line 8281 ""
	    e_wsle();
#line 8282 ""
	    s_wsle(&io___624);
#line 8282 ""
	    do_lio(&c__9, &c__1, "ASCII code:", (ftnlen)11);
#line 8282 ""
	    i__1 = *(unsigned char *)charlq;
#line 8282 ""
	    do_lio(&c__3, &c__1, (char *)&i__1, (ftnlen)sizeof(integer));
#line 8282 ""
	    e_wsle();
#line 8283 ""
	    s_wsfe(&io___625);
/* Writing concatenation */
#line 8283 ""
	    i__2[0] = 29, a__1[0] = "Last non-blank character is \"";
#line 8283 ""
	    i__2[1] = 1, a__1[1] = charlq;
#line 8283 ""
	    i__2[2] = 12, a__1[2] = "\", not \"/,%\"";
#line 8283 ""
	    s_cat(ch__1, a__1, i__2, &c__3, (ftnlen)42);
#line 8283 ""
	    do_fio(&c__1, ch__1, (ftnlen)42);
#line 8283 ""
	    e_wsfe();
#line 8285 ""
	    s_wsfe(&io___626);
#line 8285 ""
	    do_fio(&c__1, "ASCII code:", (ftnlen)11);
#line 8285 ""
	    i__1 = *(unsigned char *)charlq;
#line 8285 ""
	    do_fio(&c__1, (char *)&i__1, (ftnlen)sizeof(integer));
#line 8285 ""
	    e_wsfe();

/*  Append " /" to last line.  NB lastchar=.true. => ilbuf=nlbuf+1. */

#line 8289 ""
	    --inbuff_1.ilbuf;
#line 8290 ""
	    inbuff_1.lbuf[inbuff_1.ilbuf - 1] = (shortint) (inbuff_1.lbuf[
		    inbuff_1.ilbuf - 1] + 2);
/* Writing concatenation */
#line 8291 ""
	    i__3[0] = inbuff_1.ipbuf, a__2[0] = inbuff_1.bufq;
#line 8291 ""
	    i__3[1] = 2, a__2[1] = " /";
#line 8291 ""
	    s_cat(inbuff_1.bufq, a__2, i__3, &c__2, (ftnlen)131072);
#line 8292 ""
	    s_wsle(&io___627);
#line 8292 ""
	    do_lio(&c__9, &c__1, "appending <blank>/", (ftnlen)18);
#line 8292 ""
	    e_wsle();
#line 8293 ""
	    s_wsle(&io___628);
#line 8293 ""
	    do_lio(&c__9, &c__1, "appending <blank>/", (ftnlen)18);
#line 8293 ""
	    e_wsle();
/* Writing concatenation */
#line 8294 ""
	    i__3[0] = a1ll_2.iccount, a__2[0] = lineq;
#line 8294 ""
	    i__3[1] = 2, a__2[1] = " /";
#line 8294 ""
	    s_cat(lineq, a__2, i__3, &c__2, (ftnlen)128);
#line 8295 ""
	    c1omget_1.lastchar = FALSE_;
#line 8296 ""
	    goto L1;
#line 8297 ""
	}
#line 8298 ""
	return 0;
#line 8299 ""
    }
#line 8300 ""
    if (*(unsigned char *)charq == ' ') {
#line 8301 ""
	goto L1;
#line 8302 ""
    } else if (*(unsigned char *)charq == '%' && a1ll_2.iccount == 1) {
#line 8303 ""
	a1ll_2.iccount = 128;
#line 8304 ""
	goto L1;

/*  Replacement 1/22/12 since gfortran 4.7 with -O was choking here! */

#line 8308 ""
    } else if (i_indx("abcdefg", charq, (ftnlen)7, (ftnlen)1) > 0 || *(
	    unsigned char *)charq == 'r') {

/*  This is a note/rest. */

#line 8313 ""
	if (cdot) {
#line 8313 ""
	    goto L28;
#line 8313 ""
	}
#line 8314 ""
	idotform = 0;
#line 8315 ""
	numnum = 0;
#line 8316 ""
	plusmin = FALSE_;
#line 8317 ""
L28:
#line 8317 ""
	++a1ll_2.nnl[c1ommvl_1.ivx - 1];
#line 8318 ""
	if (a1ll_2.nnl[c1ommvl_1.ivx - 1] > 200) {
#line 8319 ""
	    i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + a1ll_2.nbars + 
		    1;
#line 8319 ""
	    errmsg_(lineq, &a1ll_2.iccount, &i__1, ">200 notes in line of mu"\
		    "sic. Use smaller blocks!", (ftnlen)128, (ftnlen)48);
#line 8321 ""
	    stop1_();
#line 8322 ""
	}
#line 8323 ""
	*(unsigned char *)dotq = 'x';

/*  Check if this is 'r ' and previous note was full-bar-pause */

#line 8327 ""
	i__1 = a1ll_2.iccount;
/* Computing MAX */
#line 8327 ""
	i__4 = 1, i__5 = a1ll_2.nnl[c1ommvl_1.ivx - 1] - 1;
/* Computing MAX */
#line 8327 ""
	i__6 = 1, i__7 = a1ll_2.nnl[c1ommvl_1.ivx - 1] - 1;
#line 8327 ""
	fulbrp = *(unsigned char *)charq == 'r' && s_cmp(lineq + i__1, " ", 
		a1ll_2.iccount + 1 - i__1, (ftnlen)1) == 0 && a1ll_2.nnl[
		c1ommvl_1.ivx - 1] > 1 && a1ll_2.rest[c1ommvl_1.ivx + max(
		i__4,i__5) * 24 - 25] && a1ll_2.nodur[c1ommvl_1.ivx + max(
		i__6,i__7) * 24 - 25] == a1ll_2.lenbar;
#line 8330 ""
L2:
#line 8330 ""
	g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)128, (ftnlen)1);
#line 8331 ""
	ic = *(unsigned char *)durq;
#line 8332 ""
	if (ic <= 57 && ic >= 48) {

/*  Digit */

#line 8336 ""
	    if (numnum == 0) {
#line 8337 ""
		c1omnotes_1.nnodur = ic - 48;
#line 8338 ""
		numnum = 1;
#line 8339 ""
		goto L2;
#line 8340 ""
	    } else if (numnum == 1) {
#line 8341 ""
		if (*(unsigned char *)charq == 'r') {
#line 8342 ""
		    i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			    a1ll_2.nbars + 1;
#line 8342 ""
		    errmsg_(lineq, &a1ll_2.iccount, &i__1, "Only one digit a"\
			    "llowed after rest symbol \"r\"!", (ftnlen)128, (
			    ftnlen)45);
#line 8344 ""
		    stop1_();
#line 8345 ""
		}
#line 8346 ""
		numnum = 2;
#line 8347 ""
		if (plusmin) {
#line 8348 ""
		    s_wsle(&io___636);
#line 8348 ""
		    e_wsle();
#line 8349 ""
		    s_wsle(&io___637);
#line 8349 ""
		    do_lio(&c__9, &c__1, "*********WARNING*********", (ftnlen)
			    25);
#line 8349 ""
		    e_wsle();
#line 8350 ""
		    i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			    a1ll_2.nbars + 1;
#line 8350 ""
		    errmsg_(lineq, &a1ll_2.iccount, &i__1, "Before version 1"\
			    ".2, +/- was ignored if octave was!", (ftnlen)128, 
			    (ftnlen)50);
#line 8352 ""
		    s_wsle(&io___638);
#line 8352 ""
		    do_lio(&c__9, &c__1, "explicitly specified.  May need to"\
			    " edit old editions", (ftnlen)52);
#line 8352 ""
		    e_wsle();
#line 8354 ""
		}
#line 8355 ""
		goto L2;
#line 8356 ""
	    } else {
#line 8357 ""
		i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			a1ll_2.nbars + 1;
#line 8357 ""
		errmsg_(lineq, &a1ll_2.iccount, &i__1, ">2 digits in note sy"\
			"mbol!", (ftnlen)128, (ftnlen)25);
#line 8359 ""
		stop1_();
#line 8360 ""
	    }
#line 8361 ""
	} else if (*(unsigned char *)durq == 'd') {
#line 8362 ""
	    *(unsigned char *)dotq = *(unsigned char *)durq;
#line 8363 ""
	    i__1 = a1ll_2.iccount;
#line 8363 ""
	    if (s_cmp(lineq + i__1, "d", a1ll_2.iccount + 1 - i__1, (ftnlen)1)
		     == 0) {
#line 8364 ""
		c1omnotes_1.iddot = 1;
#line 8365 ""
		++a1ll_2.iccount;

/*  Since we flow out, double dots won't work with other dot options */

#line 8369 ""
	    }
#line 8370 ""
	    i__1 = a1ll_2.iccount;
#line 8370 ""
	    if (i_indx("+-", lineq + i__1, (ftnlen)2, a1ll_2.iccount + 1 - 
		    i__1) > 0) {

/*  move a dot, provided a number follows. */

#line 8374 ""
		g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)128, (ftnlen)
			1);
#line 8375 ""
		g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)128, (ftnlen)
			1);
#line 8376 ""
		if (i_indx("0123456789-.", durq, (ftnlen)12, (ftnlen)1) == 0) 
			{

/*  Backup, exit the loop normally */

#line 8380 ""
		    a1ll_2.iccount += -2;
#line 8381 ""
		    goto L2;
#line 8382 ""
		}
#line 8383 ""
		readnum_(lineq, &a1ll_2.iccount, dumq, &fnum, (ftnlen)128, (
			ftnlen)1);
#line 8384 ""
		if (i_indx("+-", dumq, (ftnlen)2, (ftnlen)1) > 0) {

/*  Vertical shift also */

#line 8388 ""
		    g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)128, (
			    ftnlen)1);
#line 8389 ""
		    if (i_indx("0123456789-.", durq, (ftnlen)12, (ftnlen)1) ==
			     0) {
#line 8390 ""
			i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 8390 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__1, "Expected num"\
				"ber after 2nd +/- (shift dot)!", (ftnlen)128, 
				(ftnlen)42);
#line 8392 ""
			stop1_();
#line 8393 ""
		    }
#line 8394 ""
		    readnum_(lineq, &a1ll_2.iccount, durq, &fnum, (ftnlen)128,
			     (ftnlen)1);
#line 8395 ""
		}
#line 8396 ""
		--a1ll_2.iccount;
#line 8397 ""
	    }
#line 8398 ""
	    goto L2;
#line 8399 ""
	} else if (i_indx("<>", durq, (ftnlen)2, (ftnlen)1) > 0) {

/*  Accidental shift */

#line 8403 ""
	    i__1 = a1ll_2.iccount - 2;
#line 8403 ""
	    if (i_indx("fsnA", lineq + i__1, (ftnlen)4, a1ll_2.iccount - 1 - 
		    i__1) == 0) {
#line 8404 ""
		i__1 = a1ll_2.iccount - 1;
#line 8404 ""
		i__4 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			a1ll_2.nbars + 1;
#line 8404 ""
		errmsg_(lineq, &i__1, &i__4, "Expected \"f\", \"s\", \"n\" o"\
			"r \"A\" before \"<\" or \">\"!", (ftnlen)128, (ftnlen)
			48);
#line 8406 ""
		stop1_();
#line 8407 ""
	    }
#line 8408 ""
	    ipm = 1;
#line 8409 ""
	    if (*(unsigned char *)durq == '<') {
#line 8409 ""
		ipm = -1;
#line 8409 ""
	    }
#line 8410 ""
	    g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)128, (ftnlen)1);
#line 8411 ""
	    if (i_indx("123456789.0", durq, (ftnlen)11, (ftnlen)1) == 0) {
#line 8412 ""
		i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			a1ll_2.nbars + 1;
#line 8412 ""
		errmsg_(lineq, &a1ll_2.iccount, &i__1, "Expected number afte"\
			"r </> (accidental shift)!", (ftnlen)128, (ftnlen)45);
#line 8414 ""
		stop1_();
#line 8415 ""
	    }
#line 8416 ""
	    readnum_(lineq, &a1ll_2.iccount, durq, &fnum, (ftnlen)128, (
		    ftnlen)1);
#line 8417 ""
	    fnum = ipm * fnum;
#line 8418 ""
	    if (fnum < -5.35f || fnum > 1.f) {
#line 8419 ""
		i__1 = a1ll_2.iccount - 1;
#line 8419 ""
		i__4 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			a1ll_2.nbars + 1;
#line 8419 ""
		errmsg_(lineq, &i__1, &i__4, "Horizontal accidental shift mu"\
			"st be >-5.35 and <1.0!", (ftnlen)128, (ftnlen)52);
#line 8421 ""
		stop1_();
#line 8422 ""
	    }
#line 8423 ""
	    --a1ll_2.iccount;
#line 8424 ""
	    goto L2;
#line 8425 ""
	} else if (i_indx("+-", durq, (ftnlen)2, (ftnlen)1) > 0) {
#line 8426 ""
	    if (*(unsigned char *)charq != 'r') {
#line 8427 ""
		i__1 = a1ll_2.iccount - 2;
#line 8427 ""
		if (i_indx("fsnA", lineq + i__1, (ftnlen)4, a1ll_2.iccount - 
			1 - i__1) > 0) {
#line 8428 ""
		    ipm = 1;
#line 8429 ""
		    if (*(unsigned char *)durq == '-') {
#line 8429 ""
			ipm = -1;
#line 8429 ""
		    }
#line 8430 ""
		    i__1 = a1ll_2.iccount;
#line 8430 ""
		    if (i_indx("0123456789", lineq + i__1, (ftnlen)10, 
			    a1ll_2.iccount + 1 - i__1) > 0) {

/*  This may be start of accidental shift, but may be octave jump; then duration */

#line 8435 ""
			icsav = a1ll_2.iccount;
#line 8436 ""
			++a1ll_2.iccount;
#line 8437 ""
			readnum_(lineq, &a1ll_2.iccount, durq, &fnum, (ftnlen)
				128, (ftnlen)1);
#line 8438 ""
			if (i_indx("+-", durq, (ftnlen)2, (ftnlen)1) > 0) {

/*  This is an accid shift since there's a 2nd consecutive signed number. */
/*  Check size of 1st number. */

#line 8443 ""
			    if (fnum > 30.5f) {
#line 8444 ""
				i__1 = a1ll_2.iccount - 1;
#line 8444 ""
				i__4 = c1omnotes_1.ibarcnt - 
					c1omnotes_1.ibaroff + a1ll_2.nbars + 
					1;
#line 8444 ""
				errmsg_(lineq, &i__1, &i__4, "Vertical accid"\
					"ental shift must be less than 31!", (
					ftnlen)128, (ftnlen)47);
#line 8446 ""
				stop1_();
#line 8447 ""
			    }
#line 8448 ""
			    ipm = 1;
#line 8449 ""
			    if (*(unsigned char *)durq == '-') {
#line 8449 ""
				ipm = -1;
#line 8449 ""
			    }
#line 8450 ""
			    g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)
				    128, (ftnlen)1);
#line 8451 ""
			    if (i_indx("1234567890.", durq, (ftnlen)11, (
				    ftnlen)1) == 0) {
#line 8452 ""
				i__1 = c1omnotes_1.ibarcnt - 
					c1omnotes_1.ibaroff + a1ll_2.nbars + 
					1;
#line 8452 ""
				errmsg_(lineq, &a1ll_2.iccount, &i__1, "Expe"\
					"cted 2nd number of accidental shift)!"
					, (ftnlen)128, (ftnlen)41);
#line 8454 ""
				stop1_();
#line 8455 ""
			    }
#line 8456 ""
			    readnum_(lineq, &a1ll_2.iccount, durq, &fnum, (
				    ftnlen)128, (ftnlen)1);
#line 8457 ""
			    fnum = ipm * fnum;
#line 8458 ""
			    if (fnum < -5.35f || fnum > 1.f) {
#line 8459 ""
				i__1 = a1ll_2.iccount - 1;
#line 8459 ""
				i__4 = c1omnotes_1.ibarcnt - 
					c1omnotes_1.ibaroff + a1ll_2.nbars + 
					1;
#line 8459 ""
				errmsg_(lineq, &i__1, &i__4, "Horiz. acciden"\
					"tal shift must be >-5.35 and <1.0!", (
					ftnlen)128, (ftnlen)48);
#line 8461 ""
				stop1_();
#line 8462 ""
			    }
#line 8463 ""
			    --a1ll_2.iccount;
#line 8464 ""
			    goto L2;
#line 8465 ""
			} else {

/*  Not accid shift, reset, then flow out */

#line 8469 ""
			    a1ll_2.iccount = icsav;
#line 8470 ""
			}
#line 8471 ""
		    }
#line 8472 ""
		}
#line 8473 ""
		plusmin = TRUE_;
#line 8474 ""
		if (numnum == 2) {
#line 8475 ""
		    s_wsle(&io___643);
#line 8475 ""
		    e_wsle();
#line 8476 ""
		    s_wsle(&io___644);
#line 8476 ""
		    do_lio(&c__9, &c__1, "*********WARNING*********", (ftnlen)
			    25);
#line 8476 ""
		    e_wsle();
#line 8477 ""
		    i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			    a1ll_2.nbars + 1;
#line 8477 ""
		    errmsg_(lineq, &a1ll_2.iccount, &i__1, "Before version 1"\
			    ".2, +/- was ignored if octave was!", (ftnlen)128, 
			    (ftnlen)50);
#line 8479 ""
		    s_wsle(&io___645);
#line 8479 ""
		    do_lio(&c__9, &c__1, "explicitly specified.  May need to"\
			    " edit old editions", (ftnlen)52);
#line 8479 ""
		    e_wsle();
#line 8481 ""
		}
#line 8482 ""
		goto L2;

/*  It's a rest containing +|- .  Must refer to a vertical shift.  Read past. */

#line 8486 ""
	    } else {
#line 8487 ""
		g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)128, (ftnlen)
			1);
#line 8488 ""
		readnum_(lineq, &a1ll_2.iccount, durq, &dum, (ftnlen)128, (
			ftnlen)1);
#line 8489 ""
		i__1 = a1ll_2.iccount - 2;
#line 8489 ""
		if (s_cmp(lineq + i__1, ".", a1ll_2.iccount - 1 - i__1, (
			ftnlen)1) == 0) {
#line 8489 ""
		    --a1ll_2.iccount;
#line 8489 ""
		}
#line 8490 ""
		--a1ll_2.iccount;
#line 8491 ""
		goto L2;
#line 8492 ""
	    }
/*        else if (index('ulare',durq) .gt. 0) then */
#line 8494 ""
	} else if (i_indx("ularec", durq, (ftnlen)6, (ftnlen)1) > 0) {
#line 8495 ""
	    goto L2;
#line 8496 ""
	} else if (i_indx("LS", durq, (ftnlen)2, (ftnlen)1) > 0) {

/* Stemlength change */

#line 8500 ""
	    g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)128, (ftnlen)1);
#line 8501 ""
	    if (i_indx(".0123456789:", durq, (ftnlen)12, (ftnlen)1) == 0) {
#line 8502 ""
		i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			a1ll_2.nbars + 1;
#line 8502 ""
		errmsg_(lineq, &a1ll_2.iccount, &i__1, "There must be a numb"\
			"er or colon here!", (ftnlen)128, (ftnlen)37);
#line 8504 ""
		stop1_();
#line 8505 ""
	    }
#line 8506 ""
	    if (*(unsigned char *)durq == ':') {
#line 8507 ""
		if (! comkeys_1.stickys) {
#line 8508 ""
		    i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			    a1ll_2.nbars + 1;
#line 8508 ""
		    errmsg_(lineq, &a1ll_2.iccount, &i__1, "Turned off stick"\
			    "y stemlegth changes without turning on!", (ftnlen)
			    128, (ftnlen)55);
#line 8510 ""
		    stop1_();
#line 8511 ""
		}
#line 8512 ""
		comkeys_1.stickys = FALSE_;
#line 8513 ""
		goto L2;
#line 8514 ""
	    }
#line 8515 ""
	    readnum_(lineq, &a1ll_2.iccount, durq, &dum, (ftnlen)128, (ftnlen)
		    1);
/*          if (dum.lt..5 .or. dum.gt.4.) then */
#line 8517 ""
	    if (*(unsigned char *)durq == 'L' && dum > 20.f || *(unsigned 
		    char *)durq == 'S' && dum > 4.f) {
#line 8519 ""
		i__1 = a1ll_2.iccount - 1;
#line 8519 ""
		i__4 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			a1ll_2.nbars + 1;
#line 8519 ""
		errmsg_(lineq, &i__1, &i__4, "Stemlength change amount too b"\
			"ig!", (ftnlen)128, (ftnlen)33);
#line 8521 ""
		stop1_();
#line 8522 ""
	    }
#line 8523 ""
	    if (*(unsigned char *)durq != ':') {
#line 8524 ""
		--a1ll_2.iccount;
#line 8525 ""
	    } else {
#line 8526 ""
		if (comkeys_1.stickys) {
#line 8527 ""
		    i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			    a1ll_2.nbars + 1;
#line 8527 ""
		    errmsg_(lineq, &a1ll_2.iccount, &i__1, "Turned on sticky"\
			    " stemshrinks when already on!", (ftnlen)128, (
			    ftnlen)45);
#line 8529 ""
		    stop1_();
#line 8530 ""
		}
#line 8531 ""
		comkeys_1.stickys = TRUE_;
#line 8532 ""
	    }
#line 8533 ""
	    goto L2;
#line 8534 ""
	} else if (i_indx("fsn", durq, (ftnlen)3, (ftnlen)1) > 0) {

/* Check for midi-only accid. CANNOT coesist with accidental position tweaks, so */
/*   MUST come right after "f,s,n" */

#line 8539 ""
	    i__1 = a1ll_2.iccount;
#line 8539 ""
	    if (s_cmp(lineq + i__1, "i", a1ll_2.iccount + 1 - i__1, (ftnlen)1)
		     == 0) {
#line 8539 ""
		++a1ll_2.iccount;
#line 8539 ""
	    }
#line 8540 ""
	    goto L2;
#line 8541 ""
	} else if (*(unsigned char *)durq == 'p') {
#line 8542 ""
	    fulbrp = *(unsigned char *)charq == 'r';
#line 8543 ""
	    if (! fulbrp) {
#line 8544 ""
		i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			a1ll_2.nbars + 1;
#line 8544 ""
		errmsg_(lineq, &a1ll_2.iccount, &i__1, "The option \"p\" onl"\
			"y works with \"r\" (rest)!", (ftnlen)128, (ftnlen)42);
#line 8546 ""
		stop1_();
#line 8547 ""
	    }
#line 8548 ""
	    goto L2;
#line 8549 ""
	} else if (*(unsigned char *)durq == 'b') {
#line 8550 ""
	    if (*(unsigned char *)charq != 'r') {
#line 8551 ""
		i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			a1ll_2.nbars + 1;
#line 8551 ""
		errmsg_(lineq, &a1ll_2.iccount, &i__1, "You entered \"b\"; I"\
			" expected \"rb\"!", (ftnlen)128, (ftnlen)33);
#line 8553 ""
		stop1_();
#line 8554 ""
	    } else if (numnum == 2) {
#line 8555 ""
		i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			a1ll_2.nbars + 1;
#line 8555 ""
		errmsg_(lineq, &a1ll_2.iccount, &i__1, "You entered \"r\" &"\
			" \"b\" with two numbers!", (ftnlen)128, (ftnlen)39);
#line 8557 ""
	    }
#line 8558 ""
	    goto L2;
#line 8559 ""
	} else if (*(unsigned char *)durq == 'x') {

/*  Xtuplet. Count number of doubled notes (for unequal xtups) */

#line 8563 ""
	    if (bit_test(c1ommvl_1.nacc[c1ommvl_1.ivx + a1ll_2.nnl[
		    c1ommvl_1.ivx - 1] * 24 - 25],18)) {
#line 8564 ""
		ndoub = 1;
#line 8565 ""
	    } else {
#line 8566 ""
		ndoub = 0;
#line 8567 ""
	    }

/*  Will set all durations to 0 except last one. */

#line 8571 ""
	    g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)128, (ftnlen)1);
#line 8572 ""
	    if (i_indx("123456789T", durq, (ftnlen)10, (ftnlen)1) == 0) {
#line 8573 ""
		i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			a1ll_2.nbars + 1;
#line 8573 ""
		errmsg_(lineq, &a1ll_2.iccount, &i__1, "First char after \""\
			"x\" in xtuplet must be \"1\"-\"9\" or \"T\"!", (
			ftnlen)128, (ftnlen)55);
#line 8575 ""
		stop1_();
#line 8576 ""
	    }
#line 8577 ""
	    if (*(unsigned char *)durq == 'T') {

/*  Set a flag for checking 2nd note inputs if dot is moved */

#line 8581 ""
		twotrem = TRUE_;

/*  Check all x-tremolo inputs here; set fnum=2 */

#line 8585 ""
		fnum = 2.f;
#line 8586 ""
		getchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)128, (ftnlen)1)
			;
#line 8587 ""
		if (i_indx("0123 ", durq, (ftnlen)5, (ftnlen)1) == 0) {
#line 8588 ""
		    i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			    a1ll_2.nbars + 1;
#line 8588 ""
		    errmsg_(lineq, &a1ll_2.iccount, &i__1, "First char aft"\
			    "er \"T\" in xtuplet must be \"0\"-\"3\" or blank!"
			    , (ftnlen)128, (ftnlen)57);
#line 8590 ""
		    stop1_();
#line 8591 ""
		} else if (*(unsigned char *)durq != ' ') {
#line 8592 ""
		    getchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)128, (
			    ftnlen)1);
#line 8593 ""
		    if (i_indx("0123 ", durq, (ftnlen)5, (ftnlen)1) == 0) {
#line 8594 ""
			i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 8594 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__1, "This char mu"\
				"st be \"0\"-\"3\" or blank!", (ftnlen)128, (
				ftnlen)35);
#line 8596 ""
			stop1_();
#line 8597 ""
		    } else if (*(unsigned char *)durq != ' ') {
#line 8598 ""
			getchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)128, (
				ftnlen)1);

/*  Probably blank unles other options entered */

#line 8602 ""
		    }
#line 8603 ""
		}
#line 8604 ""
	    } else {

/* durq is digit, normal xtup */

#line 8608 ""
		readnum_(lineq, &a1ll_2.iccount, durq, &fnum, (ftnlen)128, (
			ftnlen)1);

/* Leaves durq at next char after number */

#line 8612 ""
		if (fnum > 99.f) {
#line 8613 ""
		    i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			    a1ll_2.nbars + 1;
#line 8613 ""
		    errmsg_(lineq, &a1ll_2.iccount, &i__1, "Xtuplet cannot h"\
			    "ave more than 99 notes!", (ftnlen)128, (ftnlen)39)
			    ;
#line 8615 ""
		    stop1_();
#line 8616 ""
		} else if (i_indx(" DFnd", durq, (ftnlen)5, (ftnlen)1) == 0) {
#line 8617 ""
		    i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			    a1ll_2.nbars + 1;
#line 8617 ""
		    errmsg_(lineq, &a1ll_2.iccount, &i__1, "Only legal chara"\
			    "cters here are \" \",\"D\",\"F\",\"n\"!", (ftnlen)
			    128, (ftnlen)47);
#line 8619 ""
		    stop1_();
#line 8620 ""
		}
#line 8621 ""
	    }

/*  End of mandatory xtup inputs.  Check for options. Note D,F,d must precede n. */

#line 8625 ""
	    if (i_indx("DF", durq, (ftnlen)2, (ftnlen)1) > 0) {

/*  Double xtup note to make an un= xtup. Here, number already set, but may also */
/*    have used this before number was set. */

#line 8630 ""
		c1ommvl_1.nacc[c1ommvl_1.ivx + a1ll_2.nnl[c1ommvl_1.ivx - 1] *
			 24 - 25] = bit_set(c1ommvl_1.nacc[c1ommvl_1.ivx + 
			a1ll_2.nnl[c1ommvl_1.ivx - 1] * 24 - 25],18);
#line 8631 ""
		ndoub = 1;
#line 8632 ""
		g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)128, (ftnlen)
			1);
#line 8633 ""
	    } else if (*(unsigned char *)durq == 'd') {
#line 8634 ""
		c1ommvl_1.nacc[c1ommvl_1.ivx + a1ll_2.nnl[c1ommvl_1.ivx - 1] *
			 24 - 25] = bit_set(c1ommvl_1.nacc[c1ommvl_1.ivx + 
			a1ll_2.nnl[c1ommvl_1.ivx - 1] * 24 - 25],27);
#line 8635 ""
		g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)128, (ftnlen)
			1);
#line 8636 ""
	    }
#line 8637 ""
	    if (*(unsigned char *)durq == 'n') {

/*  Number alteration stuff.  After 'n', require '+-123456789fs ', no more 'DF'. */

#line 8641 ""
		numshft = 0;
#line 8642 ""
L30:
#line 8642 ""
		g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)128, (ftnlen)
			1);
#line 8643 ""
		if (*(unsigned char *)durq == 'f') {
#line 8644 ""
		    goto L30;
#line 8645 ""
		} else if (i_indx("+-", durq, (ftnlen)2, (ftnlen)1) > 0) {
#line 8646 ""
		    ++numshft;
#line 8647 ""
		    if (numshft == 3) {
#line 8648 ""
			i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 8648 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__1, "Only 2 shift"\
				"s are allowed after \"n\" in xtup!", (ftnlen)
				128, (ftnlen)44);
#line 8650 ""
			stop1_();
#line 8651 ""
		    }
#line 8652 ""
		    g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)128, (
			    ftnlen)1);
#line 8653 ""
		    if (i_indx("0123456789.", durq, (ftnlen)11, (ftnlen)1) == 
			    0) {
#line 8654 ""
			i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 8654 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__1, "This charact"\
				"er should be a digit or \".\"!", (ftnlen)128, 
				(ftnlen)40);
#line 8656 ""
			stop1_();
#line 8657 ""
		    }
#line 8658 ""
		    readnum_(lineq, &a1ll_2.iccount, durq, &snum, (ftnlen)128,
			     (ftnlen)1);
#line 8659 ""
		    --a1ll_2.iccount;
#line 8660 ""
		    if (numshft == 1 && snum > 64.f || numshft == 2 && snum > 
			    1.51f) {
#line 8662 ""
			i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 8662 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__1, "Shift number"\
				" after \"n\" in xtup is out of range!", (
				ftnlen)128, (ftnlen)47);
#line 8664 ""
			stop1_();
#line 8665 ""
		    }
#line 8666 ""
		    goto L30;
#line 8667 ""
		} else if (*(unsigned char *)durq == 's') {

/*  Slope alteration for bracket */

#line 8671 ""
		    getchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)128, (
			    ftnlen)1);
#line 8672 ""
		    if (i_indx("+-", durq, (ftnlen)2, (ftnlen)1) == 0) {
#line 8673 ""
			i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 8673 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__1, "For slope ad"\
				"justment, this character must be \"+\" or \"-"\
				"\"!", (ftnlen)128, (ftnlen)56);
#line 8675 ""
			stop1_();
#line 8676 ""
		    }
#line 8677 ""
		    g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)128, (
			    ftnlen)1);
#line 8678 ""
		    if (i_indx("123456789", durq, (ftnlen)9, (ftnlen)1) == 0) 
			    {
#line 8679 ""
			i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 8679 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__1, "This charact"\
				"er should be a digit!", (ftnlen)128, (ftnlen)
				33);
#line 8681 ""
			stop1_();
#line 8682 ""
		    }
#line 8683 ""
		    readnum_(lineq, &a1ll_2.iccount, durq, &snum, (ftnlen)128,
			     (ftnlen)1);
#line 8684 ""
		    --a1ll_2.iccount;
#line 8685 ""
		    if (i_nint(&snum) > 15) {
#line 8686 ""
			i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 8686 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__1, "Slope adjust"\
				"ment cannot exceed 15!", (ftnlen)128, (ftnlen)
				34);
#line 8688 ""
			stop1_();
#line 8689 ""
		    }
#line 8690 ""
		    goto L30;
#line 8691 ""
		} else if (i_indx("123456789", durq, (ftnlen)9, (ftnlen)1) > 
			0) {

/* Unsigned integer => alternate printed number */

#line 8695 ""
		    readnum_(lineq, &a1ll_2.iccount, durq, &snum, (ftnlen)128,
			     (ftnlen)1);
#line 8696 ""
		    if (snum > 15.1f) {
#line 8697 ""
			i__1 = a1ll_2.iccount - 1;
#line 8697 ""
			i__4 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 8697 ""
			errmsg_(lineq, &i__1, &i__4, "Alternate xtup number "\
				"after \"n\" must be <16!", (ftnlen)128, (
				ftnlen)44);
#line 8699 ""
			stop1_();
#line 8700 ""
		    }
#line 8701 ""
		    --a1ll_2.iccount;
#line 8702 ""
		    goto L30;
#line 8703 ""
		} else if (*(unsigned char *)durq != ' ') {
#line 8704 ""
		    i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			    a1ll_2.nbars + 1;
#line 8704 ""
		    errmsg_(lineq, &a1ll_2.iccount, &i__1, "Illegal characte"\
			    "r after \"n\" in xtup!", (ftnlen)128, (ftnlen)36);
#line 8706 ""
		    stop1_();
#line 8707 ""
		}
#line 8708 ""
	    }
#line 8709 ""
	    ntup = i_nint(&fnum);
#line 8710 ""
	    i__1 = ntup;
#line 8710 ""
	    for (itup = 2; itup <= i__1; ++itup) {
#line 8711 ""
		a1ll_2.nodur[c1ommvl_1.ivx + a1ll_2.nnl[c1ommvl_1.ivx - 1] * 
			24 - 25] = 0;
#line 8712 ""
		++a1ll_2.nnl[c1ommvl_1.ivx - 1];
#line 8713 ""
L110:
#line 8713 ""
		g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)128, (ftnlen)
			1);
#line 8714 ""
		if (*(unsigned char *)durq == ' ') {
#line 8715 ""
		    goto L110;
#line 8716 ""
		} else if (*(unsigned char *)durq == 'o') {

/*  Ornament in xtup.  "o" symbol must come AFTER the affected note */

#line 8720 ""
		    g1etchar_(lineq, &a1ll_2.iccount, dumq, (ftnlen)128, (
			    ftnlen)1);
#line 8721 ""
		    if (i_indx("(stmx+Tup._)e:>^bc", dumq, (ftnlen)18, (
			    ftnlen)1) == 0) {
#line 8722 ""
			if (i_indx("fg", dumq, (ftnlen)2, (ftnlen)1) > 0) {
#line 8723 ""
			    i__4 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff 
				    + a1ll_2.nbars + 1;
#line 8723 ""
			    errmsg_(lineq, &a1ll_2.iccount, &i__4, "Fermata "\
				    "or segno not allowed in xtuplet!", (
				    ftnlen)128, (ftnlen)40);
#line 8725 ""
			} else {
#line 8726 ""
			    i__4 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff 
				    + a1ll_2.nbars + 1;
#line 8726 ""
			    errmsg_(lineq, &a1ll_2.iccount, &i__4, "Illegal "\
				    "ornament!", (ftnlen)128, (ftnlen)17);
#line 8728 ""
			}
#line 8729 ""
			stop1_();
#line 8730 ""
		    }
#line 8731 ""
		    if (*(unsigned char *)dumq == 'T') {

/*  Trill.  may be followed by 't' and/or number.  read 'til blank */

#line 8735 ""
L29:
#line 8735 ""
			g1etchar_(lineq, &a1ll_2.iccount, dumq, (ftnlen)128, (
				ftnlen)1);
#line 8736 ""
			if (*(unsigned char *)dumq != ' ') {
#line 8736 ""
			    goto L29;
#line 8736 ""
			}
#line 8737 ""
		    } else if (*(unsigned char *)dumq == 'e') {
#line 8738 ""
			g1etchar_(lineq, &a1ll_2.iccount, dumq, (ftnlen)128, (
				ftnlen)1);
#line 8739 ""
			if (i_indx("sfn?", dumq, (ftnlen)4, (ftnlen)1) == 0) {
#line 8740 ""
			    i__4 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff 
				    + a1ll_2.nbars + 1;
#line 8740 ""
			    errmsg_(lineq, &a1ll_2.iccount, &i__4, "Illegal "\
				    "character after \"e\" in edit. accid. sy"\
				    "mbol!", (ftnlen)128, (ftnlen)51);
#line 8742 ""
			    stop1_();
#line 8743 ""
			}
#line 8744 ""
			g1etchar_(lineq, &a1ll_2.iccount, dumq, (ftnlen)128, (
				ftnlen)1);
#line 8745 ""
			if (*(unsigned char *)dumq == '?') {
#line 8745 ""
			    g1etchar_(lineq, &a1ll_2.iccount, dumq, (ftnlen)
				    128, (ftnlen)1);
#line 8745 ""
			}
#line 8746 ""
		    } else if (*(unsigned char *)dumq == ':') {
#line 8747 ""
			i__4 = a1ll_2.iccount;
#line 8747 ""
			if (s_cmp(lineq + i__4, " ", a1ll_2.iccount + 1 - 
				i__4, (ftnlen)1) != 0) {
#line 8748 ""
			    i__4 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff 
				    + a1ll_2.nbars + 1;
#line 8748 ""
			    errmsg_(lineq, &a1ll_2.iccount, &i__4, "\":\" mu"\
				    "st be followed by blank in \"o: \"!", (
				    ftnlen)128, (ftnlen)39);
#line 8750 ""
			    stop1_();
#line 8751 ""
			} else if (! comkeys_1.ornrpt) {
#line 8752 ""
			    i__4 = a1ll_2.iccount - 1;
#line 8752 ""
			    i__5 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff 
				    + a1ll_2.nbars + 1;
#line 8752 ""
			    errmsg_(lineq, &i__4, &i__5, "Turned off repeate"\
				    "d ornaments before they were on!", (
				    ftnlen)128, (ftnlen)50);
#line 8754 ""
			    stop1_();
#line 8755 ""
			}
#line 8756 ""
			comkeys_1.ornrpt = FALSE_;
#line 8757 ""
		    } else {
#line 8758 ""
			g1etchar_(lineq, &a1ll_2.iccount, dumq, (ftnlen)128, (
				ftnlen)1);
#line 8759 ""
		    }
#line 8760 ""
		    if (i_indx("+- :", dumq, (ftnlen)4, (ftnlen)1) == 0) {
#line 8761 ""
			i__4 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 8761 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__4, "Illegal char"\
				"acter in ornament symbol!", (ftnlen)128, (
				ftnlen)37);
#line 8763 ""
			stop1_();
#line 8764 ""
		    }
#line 8765 ""
		    if (*(unsigned char *)dumq == ':') {
#line 8766 ""
			i__4 = a1ll_2.iccount;
#line 8766 ""
			if (s_cmp(lineq + i__4, " ", a1ll_2.iccount + 1 - 
				i__4, (ftnlen)1) != 0) {
#line 8767 ""
			    i__4 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff 
				    + a1ll_2.nbars + 1;
#line 8767 ""
			    errmsg_(lineq, &a1ll_2.iccount, &i__4, "\":\" mu"\
				    "st be followed by blank in \"o: \"!", (
				    ftnlen)128, (ftnlen)39);
#line 8769 ""
			    stop1_();
#line 8770 ""
			} else if (comkeys_1.ornrpt) {
#line 8771 ""
			    i__4 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff 
				    + a1ll_2.nbars + 1;
#line 8771 ""
			    errmsg_(lineq, &a1ll_2.iccount, &i__4, "Turned o"\
				    "n repeated ornaments but already on!", (
				    ftnlen)128, (ftnlen)44);
#line 8773 ""
			    stop1_();
#line 8774 ""
			}
#line 8775 ""
			comkeys_1.ornrpt = TRUE_;
#line 8776 ""
		    }
#line 8777 ""
		    if (i_indx("+-", dumq, (ftnlen)2, (ftnlen)1) > 0) {
#line 8778 ""
			i__4 = a1ll_2.iccount;
#line 8778 ""
			if (i_indx("0123456789", lineq + i__4, (ftnlen)10, 
				a1ll_2.iccount + 1 - i__4) == 0) {
#line 8780 ""
			    i__4 = a1ll_2.iccount + 1;
#line 8780 ""
			    i__5 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff 
				    + a1ll_2.nbars + 1;
#line 8780 ""
			    errmsg_(lineq, &i__4, &i__5, "There should be an"\
				    " integer here!", (ftnlen)128, (ftnlen)32);
#line 8782 ""
			    stop1_();
#line 8783 ""
			}
#line 8784 ""
			readnum_(lineq, &a1ll_2.iccount, durq, &fnum, (ftnlen)
				128, (ftnlen)1);
#line 8785 ""
			if (*(unsigned char *)durq == ':') {
#line 8786 ""
			    i__4 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff 
				    + a1ll_2.nbars + 1;
#line 8786 ""
			    errmsg_(lineq, &a1ll_2.iccount, &i__4, "Cannot s"\
				    "hift AND repeat an ornament!", (ftnlen)
				    128, (ftnlen)36);
#line 8788 ""
			    stop1_();
#line 8789 ""
			}

/*  12/7/03 Allow horizontal shift on any ornament, not just breath and ceas. */

#line 8793 ""
			if (i_indx("+-", durq, (ftnlen)2, (ftnlen)1) > 0) {
#line 8794 ""
			    i__4 = a1ll_2.iccount;
#line 8794 ""
			    if (i_indx(".0123456789", lineq + i__4, (ftnlen)
				    11, a1ll_2.iccount + 1 - i__4) == 0) {
#line 8796 ""
				i__4 = a1ll_2.iccount + 1;
#line 8796 ""
				i__5 = c1omnotes_1.ibarcnt - 
					c1omnotes_1.ibaroff + a1ll_2.nbars + 
					1;
#line 8796 ""
				errmsg_(lineq, &i__4, &i__5, "There should b"\
					"e a number here!", (ftnlen)128, (
					ftnlen)30);
#line 8799 ""
				stop1_();
#line 8800 ""
			    }
#line 8801 ""
			    readnum_(lineq, &a1ll_2.iccount, durq, &fnum, (
				    ftnlen)128, (ftnlen)1);
#line 8802 ""
			}
#line 8803 ""
		    }
#line 8804 ""
		    goto L110;
#line 8805 ""
		} else if (i_indx("st(){}", durq, (ftnlen)6, (ftnlen)1) > 0) {

/*  Slur in xtup */

#line 8809 ""
		    iposn = 0;
#line 8810 ""
		    numint = 0;
#line 8811 ""
L15:
#line 8811 ""
		    g1etchar_(lineq, &a1ll_2.iccount, dumq, (ftnlen)128, (
			    ftnlen)1);
#line 8812 ""
		    ++iposn;
#line 8813 ""
		    if (i_indx("udlbfnhtv", dumq, (ftnlen)9, (ftnlen)1) > 0) {
#line 8814 ""
			if (*(unsigned char *)dumq == 't' && *(unsigned char *
				)durq == 't') {
#line 8815 ""
			    i__4 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff 
				    + a1ll_2.nbars + 1;
#line 8815 ""
			    errmsg_(lineq, &a1ll_2.iccount, &i__4, "Cannot u"\
				    "se \"t\" as an option on a tie!", (ftnlen)
				    128, (ftnlen)37);
#line 8817 ""
			    stop1_();
#line 8818 ""
			}
#line 8819 ""
			goto L15;
#line 8820 ""
		    } else if (i_indx("+-", dumq, (ftnlen)2, (ftnlen)1) > 0) {
#line 8821 ""
			++numint;
#line 8822 ""
			++a1ll_2.iccount;
#line 8823 ""
			readnum_(lineq, &a1ll_2.iccount, durq, &fnum, (ftnlen)
				128, (ftnlen)1);
#line 8824 ""
			if (numint == 1) {
#line 8825 ""
			    if (i_nint(&fnum) > 30) {
#line 8826 ""
				i__4 = a1ll_2.iccount - 1;
#line 8826 ""
				i__5 = c1omnotes_1.ibarcnt - 
					c1omnotes_1.ibaroff + a1ll_2.nbars + 
					1;
#line 8826 ""
				errmsg_(lineq, &i__4, &i__5, "Magnitude of s"\
					"lur height adjustment cannot exceed "\
					"30!", (ftnlen)128, (ftnlen)53);
#line 8828 ""
				stop1_();
#line 8829 ""
			    }
#line 8830 ""
			} else if (numint == 2) {
#line 8831 ""
			    if (dabs(fnum) > 6.3f) {
#line 8832 ""
				i__4 = a1ll_2.iccount - 1;
#line 8832 ""
				i__5 = c1omnotes_1.ibarcnt - 
					c1omnotes_1.ibaroff + a1ll_2.nbars + 
					1;
#line 8832 ""
				errmsg_(lineq, &i__4, &i__5, "Slur horiz shi"\
					"ft must be in the range (-6.3,6.3)!", 
					(ftnlen)128, (ftnlen)49);
#line 8834 ""
				stop1_();
#line 8835 ""
			    }
#line 8836 ""
			} else {

/*  Third signed integer, must be a midslur or curve spec. */

#line 8840 ""
			    if (dabs(fnum) > 31.f) {
#line 8841 ""
				i__4 = a1ll_2.iccount - 1;
#line 8841 ""
				i__5 = c1omnotes_1.ibarcnt - 
					c1omnotes_1.ibaroff + a1ll_2.nbars + 
					1;
#line 8841 ""
				errmsg_(lineq, &i__4, &i__5, "Slur midheight"\
					" must be in the range (-31,31)!", (
					ftnlen)128, (ftnlen)45);
#line 8843 ""
				stop1_();
#line 8844 ""
			    }
#line 8845 ""
			    if (*(unsigned char *)durq == ':') {

/*  Expecting curve parameters.  Get two numbers */

#line 8849 ""
				for (i__ = 1; i__ <= 2; ++i__) {
#line 8850 ""
				    ++a1ll_2.iccount;
#line 8851 ""
				    fnum = (real) (*(unsigned char *)&lineq[
					    a1ll_2.iccount - 1] - 48);
#line 8852 ""
				    if ((r__1 = fnum - 3.5f, dabs(r__1)) > 
					    3.6f) {
#line 8853 ""
					i__4 = c1omnotes_1.ibarcnt - 
						c1omnotes_1.ibaroff + 
						a1ll_2.nbars + 1;
#line 8853 ""
					errmsg_(lineq, &a1ll_2.iccount, &i__4,
						 "Slur curve parameter must "\
						"be in range (0,7)!", (ftnlen)
						128, (ftnlen)44);
#line 8856 ""
					stop1_();
#line 8857 ""
				    }
#line 8858 ""
/* L40: */
#line 8858 ""
				}
#line 8859 ""
				++a1ll_2.iccount;
#line 8860 ""
			    }
#line 8861 ""
			}
#line 8862 ""
			--a1ll_2.iccount;
#line 8863 ""
			goto L15;
#line 8865 ""
		    } else if (*(unsigned char *)dumq == 's') {

/* What follows should be one or two signed numbers for adjustment of line break */
/* slur, end of 1st segment or start of second. */

#line 8870 ""
			if (comslur_1.fontslur) {
#line 8871 ""
			    i__4 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff 
				    + a1ll_2.nbars + 1;
#line 8871 ""
			    errmsg_(lineq, &a1ll_2.iccount, &i__4, "May not "\
				    "use linebreak slur options with font-bas"\
				    "ed slurs!", (ftnlen)128, (ftnlen)57);
#line 8873 ""
			    stop1_();
#line 8874 ""
			}
#line 8875 ""
			g1etchar_(lineq, &a1ll_2.iccount, dumq, (ftnlen)128, (
				ftnlen)1);
#line 8876 ""
			if (i_indx("+-", dumq, (ftnlen)2, (ftnlen)1) == 0) {
#line 8877 ""
			    i__4 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff 
				    + a1ll_2.nbars + 1;
#line 8877 ""
			    errmsg_(lineq, &a1ll_2.iccount, &i__4, "This cha"\
				    "racter must be \"+\" or \"-\"!", (ftnlen)
				    128, (ftnlen)34);
#line 8879 ""
			    stop1_();
#line 8880 ""
			}
#line 8881 ""
			++a1ll_2.iccount;
#line 8882 ""
			readnum_(lineq, &a1ll_2.iccount, dumq, &fnum, (ftnlen)
				128, (ftnlen)1);
#line 8883 ""
			if (i_nint(&fnum) > 30) {
#line 8884 ""
			    i__4 = a1ll_2.iccount - 1;
#line 8884 ""
			    i__5 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff 
				    + a1ll_2.nbars + 1;
#line 8884 ""
			    errmsg_(lineq, &i__4, &i__5, "Magnitude of slur "\
				    "height adjustment cannot exceed 30!", (
				    ftnlen)128, (ftnlen)53);
#line 8886 ""
			    stop1_();
#line 8887 ""
			}
#line 8888 ""
			if (i_indx("+-", dumq, (ftnlen)2, (ftnlen)1) > 0) {
#line 8889 ""
			    ++a1ll_2.iccount;
#line 8890 ""
			    readnum_(lineq, &a1ll_2.iccount, dumq, &fnum, (
				    ftnlen)128, (ftnlen)1);
#line 8891 ""
			    if (dabs(fnum) > 6.3f) {
#line 8892 ""
				i__4 = a1ll_2.iccount - 1;
#line 8892 ""
				i__5 = c1omnotes_1.ibarcnt - 
					c1omnotes_1.ibaroff + a1ll_2.nbars + 
					1;
#line 8892 ""
				errmsg_(lineq, &i__4, &i__5, "Slur horiz shi"\
					"ft must be in range (-6.3,6.3)!", (
					ftnlen)128, (ftnlen)45);
#line 8894 ""
				stop1_();
#line 8895 ""
			    }
#line 8896 ""
			}
#line 8897 ""
			--a1ll_2.iccount;
#line 8898 ""
			goto L15;
#line 8899 ""
		    } else if (*(unsigned char *)dumq == 'H' && iposn > 1) {
#line 8900 ""
			i__4 = a1ll_2.iccount;
#line 8900 ""
			if (s_cmp(lineq + i__4, "H", a1ll_2.iccount + 1 - 
				i__4, (ftnlen)1) == 0) {
#line 8900 ""
			    ++a1ll_2.iccount;
#line 8900 ""
			}
#line 8902 ""
			goto L15;
#line 8903 ""
		    } else if (*(unsigned char *)dumq == 'p') {

/*  local change in postscript slur/tie adjustment default */

#line 8907 ""
			if (comslur_1.fontslur) {
#line 8908 ""
			    i__4 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff 
				    + a1ll_2.nbars + 1;
#line 8908 ""
			    errmsg_(lineq, &a1ll_2.iccount, &i__4, "Must use"\
				    " postscript slurs (\"Ap\") to use this o"\
				    "ption!", (ftnlen)128, (ftnlen)52);
#line 8910 ""
			    stop1_();
#line 8911 ""
			}
#line 8912 ""
			g1etchar_(lineq, &a1ll_2.iccount, dumq, (ftnlen)128, (
				ftnlen)1);
#line 8913 ""
			if (i_indx("+-", dumq, (ftnlen)2, (ftnlen)1) == 0) {
#line 8914 ""
			    i__4 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff 
				    + a1ll_2.nbars + 1;
#line 8914 ""
			    errmsg_(lineq, &a1ll_2.iccount, &i__4, "Expect"\
				    "ed \"+\" or \"-\" here!", (ftnlen)128, (
				    ftnlen)25);
#line 8916 ""
			    stop1_();
#line 8917 ""
			}
#line 8918 ""
			g1etchar_(lineq, &a1ll_2.iccount, dumq, (ftnlen)128, (
				ftnlen)1);
#line 8919 ""
			if (i_indx("st", dumq, (ftnlen)2, (ftnlen)1) == 0) {
#line 8920 ""
			    i__4 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff 
				    + a1ll_2.nbars + 1;
#line 8920 ""
			    errmsg_(lineq, &a1ll_2.iccount, &i__4, "Expect"\
				    "ed \"s\" or \"t\" here!", (ftnlen)128, (
				    ftnlen)25);
#line 8922 ""
			    stop1_();
#line 8923 ""
			}
#line 8924 ""
			goto L15;
#line 8925 ""
		    } else if (*(unsigned char *)dumq != ' ') {
#line 8926 ""
			ic = *(unsigned char *)dumq;
#line 8927 ""
			if (ic >= 48 && ic <= 57 || ic >= 65 && ic <= 90) {
#line 8929 ""
			    if (iposn == 1) {
#line 8930 ""
				if (*(unsigned char *)durq == 't' && 
					comslur_1.fontslur) {
#line 8931 ""
				    i__4 = c1omnotes_1.ibarcnt - 
					    c1omnotes_1.ibaroff + 
					    a1ll_2.nbars + 1;
#line 8931 ""
				    errmsg_(lineq, &a1ll_2.iccount, &i__4, 
					    "Slur ID not allowed on non-post"\
					    "script tie!", (ftnlen)128, (
					    ftnlen)42);
#line 8933 ""
				    stop1_();
#line 8934 ""
				}
#line 8935 ""
				i__4 = a1ll_2.iccount;
#line 8935 ""
				if (s_cmp(lineq + i__4, "x", a1ll_2.iccount + 
					1 - i__4, (ftnlen)1) == 0) {
#line 8935 ""
				    ++a1ll_2.iccount;
#line 8935 ""
				}
#line 8937 ""
				goto L15;
#line 8938 ""
			    }
#line 8939 ""
			    i__4 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff 
				    + a1ll_2.nbars + 1;
#line 8939 ""
			    errmsg_(lineq, &a1ll_2.iccount, &i__4, "Slur ID "\
				    "must be 2nd character in slur symbol!", (
				    ftnlen)128, (ftnlen)45);
#line 8941 ""
			    stop1_();
#line 8942 ""
			}
#line 8943 ""
			i__4 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 8943 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__4, "Illegal char"\
				"acter in slur symbol!", (ftnlen)128, (ftnlen)
				33);
#line 8945 ""
			stop1_();
#line 8946 ""
		    }
#line 8947 ""
		    goto L110;
#line 8948 ""
		} else if (i_indx("0123456789#-nx_", durq, (ftnlen)15, (
			ftnlen)1) > 0) {

/*  We have a figure.  Only allow on 1st note of xtup */

#line 8952 ""
		    if (itup != 2) {
#line 8953 ""
			i__4 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 8953 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__4, "Figure in xt"\
				"up only allowed on 1st note!", (ftnlen)128, (
				ftnlen)40);
#line 8955 ""
			stop1_();
#line 8956 ""
		    } else if (*(unsigned char *)durq == 'x') {
#line 8957 ""
			i__4 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 8957 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__4, "No floating "\
				"figures in xtuplets!", (ftnlen)128, (ftnlen)
				32);
#line 8959 ""
			stop1_();
#line 8960 ""
		    }
#line 8961 ""
		    if (compage_1.usefig && c1ommvl_1.ivx == 1) {
#line 8961 ""
			*ifig = 1;
#line 8961 ""
		    }
#line 8962 ""
L26:
#line 8962 ""
		    g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)128, (
			    ftnlen)1);
#line 8963 ""
		    if (i_indx("0123456789#-n_.:v", durq, (ftnlen)17, (ftnlen)
			    1) > 0) {
#line 8964 ""
			goto L26;
#line 8965 ""
		    } else if (*(unsigned char *)durq == 's') {
#line 8966 ""
			comligfont_1.isligfont = TRUE_;
#line 8967 ""
			goto L26;
#line 8968 ""
		    } else if (*(unsigned char *)durq == '+') {

/* vertical offset, must be integer then blank */

#line 8972 ""
			g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)128, (
				ftnlen)1);
#line 8973 ""
			if (i_indx("123456789", durq, (ftnlen)9, (ftnlen)1) !=
				 0) {
#line 8974 ""
			    i__4 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff 
				    + a1ll_2.nbars + 1;
#line 8974 ""
			    errmsg_(lineq, &a1ll_2.iccount, &i__4, "Integer "\
				    "for vertical offset expected here!", (
				    ftnlen)128, (ftnlen)42);
#line 8976 ""
			    stop1_();
#line 8977 ""
			}
#line 8978 ""
			readnum_(lineq, &a1ll_2.iccount, durq, &fnum, (ftnlen)
				128, (ftnlen)1);
#line 8979 ""
			if (*(unsigned char *)durq != ' ') {
#line 8980 ""
			    i__4 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff 
				    + a1ll_2.nbars + 1;
#line 8980 ""
			    errmsg_(lineq, &a1ll_2.iccount, &i__4, "Vertical"\
				    " offset must terminate figure!", (ftnlen)
				    128, (ftnlen)38);
#line 8982 ""
			    stop1_();
#line 8983 ""
			}
#line 8984 ""
			--a1ll_2.iccount;
#line 8985 ""
			goto L26;
#line 8986 ""
		    } else if (*(unsigned char *)durq != ' ') {
#line 8987 ""
			i__4 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 8987 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__4, "Illegal char"\
				"acter in figure in xtuplet!", (ftnlen)128, (
				ftnlen)39);
#line 8989 ""
			stop1_();
#line 8990 ""
		    }
#line 8991 ""
		    goto L110;
#line 8992 ""
		} else if (*(unsigned char *)durq == 'G') {
#line 8993 ""
		    ngr = 1;
#line 8994 ""
L79:
#line 8994 ""
		    g1etchar_(lineq, &a1ll_2.iccount, charq, (ftnlen)128, (
			    ftnlen)1);
#line 8995 ""
		    if (i_indx("123456789", charq, (ftnlen)9, (ftnlen)1) > 0) 
			    {
#line 8996 ""
			readnum_(lineq, &a1ll_2.iccount, durq, &fnum, (ftnlen)
				128, (ftnlen)1);
#line 8997 ""
			ngr = i_nint(&fnum);
#line 8998 ""
			--a1ll_2.iccount;
#line 8999 ""
			goto L79;
#line 9000 ""
		    } else if (i_indx("AWulxs", charq, (ftnlen)6, (ftnlen)1) 
			    > 0) {
#line 9001 ""
			goto L79;
#line 9002 ""
		    } else if (*(unsigned char *)charq == 'm') {
#line 9003 ""
			g1etchar_(lineq, &a1ll_2.iccount, charq, (ftnlen)128, 
				(ftnlen)1);
#line 9004 ""
			if (i_indx("01234", charq, (ftnlen)5, (ftnlen)1) == 0)
				 {
#line 9005 ""
			    i__4 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff 
				    + a1ll_2.nbars + 1;
#line 9005 ""
			    errmsg_(lineq, &a1ll_2.iccount, &i__4, "A digit "\
				    "less than 5 must follow \"m\" in a grace"\
				    " note!", (ftnlen)128, (ftnlen)52);
#line 9007 ""
			    stop1_();
#line 9008 ""
			}
#line 9009 ""
			goto L79;
#line 9010 ""
		    } else if (*(unsigned char *)charq == 'X') {

/* Space before main note */

#line 9014 ""
			g1etchar_(lineq, &a1ll_2.iccount, charq, (ftnlen)128, 
				(ftnlen)1);
#line 9015 ""
			if (i_indx("0123456789.", charq, (ftnlen)11, (ftnlen)
				1) > 0) {
#line 9016 ""
			    readnum_(lineq, &a1ll_2.iccount, durq, &fnum, (
				    ftnlen)128, (ftnlen)1);
#line 9017 ""
			    --a1ll_2.iccount;
#line 9018 ""
			    goto L79;
#line 9019 ""
			} else {
#line 9020 ""
			    i__4 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff 
				    + a1ll_2.nbars + 1;
#line 9020 ""
			    errmsg_(lineq, &a1ll_2.iccount, &i__4, "A number"\
				    " must follow \"X\" in a grace note!", (
				    ftnlen)128, (ftnlen)41);
#line 9022 ""
			    stop1_();
#line 9023 ""
			}
#line 9024 ""
		    }

/*  At this point, charq is first note name in rest (grace?) */

#line 9028 ""
		    i__4 = ngr;
#line 9028 ""
		    for (igr = 1; igr <= i__4; ++igr) {
#line 9029 ""
			numnum = 0;
#line 9030 ""
			if (igr > 1) {
#line 9031 ""
L75:
#line 9031 ""
			    g1etchar_(lineq, &a1ll_2.iccount, charq, (ftnlen)
				    128, (ftnlen)1);
#line 9032 ""
			    if (*(unsigned char *)charq == ' ') {
#line 9032 ""
				goto L75;
#line 9032 ""
			    }
#line 9033 ""
			}
#line 9034 ""
			if (i_indx("abcdefg", charq, (ftnlen)7, (ftnlen)1) == 
				0) {
#line 9035 ""
			    i__5 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff 
				    + a1ll_2.nbars + 1;
#line 9035 ""
			    errmsg_(lineq, &a1ll_2.iccount, &i__5, "In grace"\
				    ", expected \"a\"-\"g\"!", (ftnlen)128, (
				    ftnlen)27);
#line 9037 ""
			    stop1_();
#line 9038 ""
			}
#line 9039 ""
L78:
#line 9039 ""
			g1etchar_(lineq, &a1ll_2.iccount, charq, (ftnlen)128, 
				(ftnlen)1);
#line 9040 ""
			if (*(unsigned char *)charq != ' ') {
#line 9041 ""
			    if (i_indx("1234567", charq, (ftnlen)7, (ftnlen)1)
				     > 0) {
#line 9042 ""
				if (numnum == 1) {
#line 9043 ""
				    i__5 = c1omnotes_1.ibarcnt - 
					    c1omnotes_1.ibaroff + 
					    a1ll_2.nbars + 1;
#line 9043 ""
				    errmsg_(lineq, &a1ll_2.iccount, &i__5, 
					    "Only one of \"+-1234567\" allow"\
					    "ed here in grace!", (ftnlen)128, (
					    ftnlen)46);
#line 9045 ""
				    stop1_();
#line 9046 ""
				}
#line 9047 ""
				numnum = 1;
#line 9048 ""
				goto L78;
#line 9049 ""
			    } else if (i_indx("+-nfs", charq, (ftnlen)5, (
				    ftnlen)1) > 0) {
#line 9050 ""
				goto L78;
#line 9051 ""
			    }

/*  Digits are possible octave numbers */

#line 9055 ""
			    i__5 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff 
				    + a1ll_2.nbars + 1;
#line 9055 ""
			    errmsg_(lineq, &a1ll_2.iccount, &i__5, "Illegal "\
				    "character after note name in grace!", (
				    ftnlen)128, (ftnlen)43);
#line 9057 ""
			    stop1_();
#line 9058 ""
			}
#line 9059 ""
/* L71: */
#line 9059 ""
		    }
#line 9060 ""
		    goto L110;
#line 9061 ""
		} else /* if(complicated condition) */ {
#line 9061 ""
		    chax_(ch__2, (ftnlen)1, &c__92);
#line 9061 ""
		    if (*(unsigned char *)durq == *(unsigned char *)&ch__2[0])
			     {
#line 9062 ""
			chklit_(lineq, &a1ll_2.iccount, &literr, (ftnlen)128);
#line 9063 ""
			if (literr > 0) {
#line 9064 ""
			    i__4 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff 
				    + a1ll_2.nbars + 1;
#line 9064 ""
			    errmsg_(lineq, &a1ll_2.iccount, &i__4, literq + (
				    literr - 1) * 51, (ftnlen)128, (ftnlen)51)
				    ;
#line 9066 ""
			    stop1_();
#line 9067 ""
			}
#line 9068 ""
			goto L110;
#line 9069 ""
		    } else /* if(complicated condition) */ {
#line 9069 ""
			chax_(ch__2, (ftnlen)1, &c__34);
#line 9069 ""
			if (*(unsigned char *)durq == *(unsigned char *)&
				ch__2[0]) {

/*  pmx lyric */

#line 9073 ""
			    chkpmxlyr_(lineq, &a1ll_2.iccount, &lyrerr, (
				    ftnlen)128);
#line 9074 ""
			    if (lyrerr > 0) {
#line 9075 ""
				i__4 = c1omnotes_1.ibarcnt - 
					c1omnotes_1.ibaroff + a1ll_2.nbars + 
					1;
#line 9075 ""
				errmsg_(lineq, &a1ll_2.iccount, &i__4, lyrerq 
					+ (lyrerr - 1) * 51, (ftnlen)128, (
					ftnlen)51);
#line 9077 ""
				stop1_();
#line 9078 ""
			    }
#line 9079 ""
			    goto L110;
#line 9080 ""
			} else if (*(unsigned char *)durq == 'M') {

/*  Temporary trap until I get around putting this in pmxb */

#line 9084 ""
			    i__4 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff 
				    + a1ll_2.nbars + 1;
#line 9084 ""
			    errmsg_(lineq, &a1ll_2.iccount, &i__4, "Macros n"\
				    "ot yet allowed in xtuplets!", (ftnlen)128,
				     (ftnlen)35);
#line 9086 ""
			    stop1_();
#line 9087 ""
			} else if (*(unsigned char *)durq == 'X') {
#line 9088 ""
			    i__4 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff 
				    + a1ll_2.nbars + 1;
#line 9088 ""
			    g1etx_(lineq, &a1ll_2.iccount, &comkeys_1.shifton,
				     &i__4, &c1omnotes_1.udsp[
				    c1omnotes_1.ibarcnt + a1ll_2.nbars], &
				    c1omnotes_1.wheadpt, (ftnlen)128);
#line 9090 ""
			    goto L110;
#line 9091 ""
			} else if (*(unsigned char *)durq == 'z') {

/*  Chord note in xtup.  Read past for now. */

#line 9095 ""
L33:
#line 9095 ""
			    g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)
				    128, (ftnlen)1);
#line 9096 ""
			    if (*(unsigned char *)durq != ' ') {
#line 9096 ""
				goto L33;
#line 9096 ""
			    }
#line 9097 ""
			    goto L110;
#line 9098 ""
			} else if (*(unsigned char *)durq == 'D') {

/*  Dynamic mark */

#line 9102 ""
			    i__4 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff 
				    + a1ll_2.nbars + 1;
#line 9102 ""
			    checkdyn_(lineq, &a1ll_2.iccount, &i__4, (ftnlen)
				    128);
#line 9103 ""
			    goto L110;
#line 9104 ""
			} else if (*(unsigned char *)durq == '%') {
#line 9105 ""
			    if (a1ll_2.iccount != 1) {
#line 9106 ""
				i__4 = c1omnotes_1.ibarcnt - 
					c1omnotes_1.ibaroff + a1ll_2.nbars + 
					1;
#line 9106 ""
				errmsg_(lineq, &a1ll_2.iccount, &i__4, "Comm"\
					"ent must have \"%\" in column 1!", (
					ftnlen)128, (ftnlen)34);
#line 9108 ""
				stop1_();
#line 9109 ""
			    }
#line 9110 ""
			    a1ll_2.iccount = 128;
#line 9111 ""
			    goto L110;
#line 9112 ""
			} else if (*(unsigned char *)durq == '?') {
#line 9113 ""
			    getchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)
				    128, (ftnlen)1);
#line 9114 ""
			    if (*(unsigned char *)durq == ' ') {
#line 9115 ""
				--a1ll_2.iccount;
#line 9116 ""
				goto L110;
#line 9117 ""
			    }
#line 9118 ""
			    if (*(unsigned char *)durq != '-') {
#line 9119 ""
				i__4 = c1omnotes_1.ibarcnt - 
					c1omnotes_1.ibaroff + a1ll_2.nbars + 
					1;
#line 9119 ""
				errmsg_(lineq, &a1ll_2.iccount, &i__4, "Expe"\
					"cting \"-\"", (ftnlen)128, (ftnlen)13)
					;
#line 9121 ""
				stop1_();
#line 9122 ""
			    }
#line 9123 ""
			    getchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)
				    128, (ftnlen)1);
#line 9124 ""
			    if (i_indx("0123456789.", durq, (ftnlen)11, (
				    ftnlen)1) == 0) {
#line 9125 ""
				i__4 = c1omnotes_1.ibarcnt - 
					c1omnotes_1.ibaroff + a1ll_2.nbars + 
					1;
#line 9125 ""
				errmsg_(lineq, &a1ll_2.iccount, &i__4, "Expe"\
					"cting number", (ftnlen)128, (ftnlen)
					16);
#line 9127 ""
				stop1_();
#line 9128 ""
			    }
#line 9129 ""
			    readnum_(lineq, &a1ll_2.iccount, durq, &fnum, (
				    ftnlen)128, (ftnlen)1);
#line 9130 ""
			    --a1ll_2.iccount;
#line 9131 ""
			    goto L110;

/*  140215 Allow clef change inside xtup */

#line 9135 ""
			} else if (*(unsigned char *)durq == 'C') {
#line 9136 ""
			    g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)
				    128, (ftnlen)1);
#line 9137 ""
			    if (! (i_indx("tsmanrbf", durq, (ftnlen)8, (
				    ftnlen)1) > 0 || *(unsigned char *)durq >=
				     48 && *(unsigned char *)durq <= 56)) {
/*     *            (ichar(durq).ge.48 .and. ichar(durq).le.55))) then */
#line 9140 ""
				i__4 = c1omnotes_1.ibarcnt - 
					c1omnotes_1.ibaroff + a1ll_2.nbars + 
					1;
#line 9140 ""
				errmsg_(lineq, &a1ll_2.iccount, &i__4, "Must"\
					" have t,s,m,a,n,r,b,f or 0-8 after C!"
					, (ftnlen)128, (ftnlen)41);
#line 9142 ""
				stop1_();
#line 9143 ""
			    }
#line 9144 ""
			    goto L110;
/* +++ */
#line 9146 ""
			} else /* if(complicated condition) */ {
#line 9146 ""
			    i__4 = a1ll_2.iccount;
#line 9146 ""
			    i__5 = a1ll_2.iccount + 1;
#line 9146 ""
			    if (*(unsigned char *)durq == ']' && s_cmp(lineq 
				    + i__4, "[", a1ll_2.iccount + 1 - i__4, (
				    ftnlen)1) == 0 && s_cmp(lineq + i__5, 
				    " ", a1ll_2.iccount + 2 - i__5, (ftnlen)1)
				     == 0) {
#line 9148 ""
				a1ll_2.iccount += 2;
#line 9149 ""
				goto L110;
/* +++ */

/* Added 200118 to allow dot to be moved on 2nd note of 2-note tremolo */

#line 9154 ""
			    }
#line 9154 ""
			}
#line 9154 ""
		    }
#line 9154 ""
		}

/*  End of xtup options. At this point symbol can only be note or rest */

#line 9158 ""
		if (i_indx("abcdefgr", durq, (ftnlen)8, (ftnlen)1) == 0) {
#line 9159 ""
		    i__4 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			    a1ll_2.nbars + 1;
#line 9159 ""
		    errmsg_(lineq, &a1ll_2.iccount, &i__4, "In xtup, this ch"\
			    "aracter is not allowed!", (ftnlen)128, (ftnlen)39)
			    ;
#line 9161 ""
		    stop1_();
#line 9162 ""
		}
#line 9163 ""
L7:
#line 9163 ""
		g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)128, (ftnlen)
			1);
#line 9164 ""
		if (i_indx("12345678ulcb", durq, (ftnlen)12, (ftnlen)1) > 0) {
#line 9165 ""
		    goto L7;
#line 9166 ""
		} else if (i_indx("sfn", durq, (ftnlen)3, (ftnlen)1) > 0) {

/*  Check for MIDI-only accidental. Cannot coexist with accid. pos'n shift. */

#line 9170 ""
		    i__4 = a1ll_2.iccount;
#line 9170 ""
		    if (s_cmp(lineq + i__4, "i", a1ll_2.iccount + 1 - i__4, (
			    ftnlen)1) == 0) {
#line 9170 ""
			++a1ll_2.iccount;
#line 9170 ""
		    }
#line 9171 ""
		    goto L7;
#line 9172 ""
		} else if (i_indx("+-<>", durq, (ftnlen)4, (ftnlen)1) > 0) {

/*  May have either octave jump or shifted accid. on main xtup note */

#line 9176 ""
		    i__4 = a1ll_2.iccount;
#line 9176 ""
		    if (i_indx("+-", durq, (ftnlen)2, (ftnlen)1) > 0 && 
			    i_indx("01234567890", lineq + i__4, (ftnlen)11, 
			    a1ll_2.iccount + 1 - i__4) == 0) {
#line 9176 ""
			goto L7;
#line 9176 ""
		    }
#line 9179 ""
		    ++a1ll_2.iccount;
#line 9180 ""
		    readnum_(lineq, &a1ll_2.iccount, durq, &fnum, (ftnlen)128,
			     (ftnlen)1);
#line 9181 ""
		    --a1ll_2.iccount;
#line 9182 ""
		    goto L7;
#line 9183 ""
		} else if (i_indx("DF", durq, (ftnlen)2, (ftnlen)1) > 0) {

/*  Double an xtup note to make an unequal xtup */

#line 9187 ""
		    c1ommvl_1.nacc[c1ommvl_1.ivx + a1ll_2.nnl[c1ommvl_1.ivx - 
			    1] * 24 - 25] = bit_set(c1ommvl_1.nacc[
			    c1ommvl_1.ivx + a1ll_2.nnl[c1ommvl_1.ivx - 1] * 
			    24 - 25],18);
#line 9188 ""
		    ++ndoub;
#line 9189 ""
		    goto L7;
#line 9190 ""
		} else if (*(unsigned char *)durq == 'd') {
#line 9191 ""
		    if (twotrem) {

/*  2-note trem, get shift */

#line 9195 ""
			g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)128, (
				ftnlen)1);
#line 9196 ""
			if (i_indx("+-", durq, (ftnlen)2, (ftnlen)1) == 0) {
#line 9197 ""
			    i__4 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff 
				    + a1ll_2.nbars + 1;
#line 9197 ""
			    errmsg_(lineq, &a1ll_2.iccount, &i__4, "Expected"\
				    " +/- for shifted dot on end of 2-note tr"\
				    "em!", (ftnlen)128, (ftnlen)51);
#line 9199 ""
			    stop1_();
#line 9200 ""
			}
#line 9201 ""
			g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)128, (
				ftnlen)1);
#line 9202 ""
			if (i_indx("0123456789.", durq, (ftnlen)11, (ftnlen)1)
				 == 0) {
#line 9203 ""
			    i__4 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff 
				    + a1ll_2.nbars + 1;
#line 9203 ""
			    errmsg_(lineq, &a1ll_2.iccount, &i__4, "Expected"\
				    " number here!", (ftnlen)128, (ftnlen)21);
#line 9205 ""
			    stop1_();
#line 9206 ""
			}
#line 9207 ""
			readnum_(lineq, &a1ll_2.iccount, dumq, &fnum, (ftnlen)
				128, (ftnlen)1);
#line 9208 ""
			if (i_indx("+-", dumq, (ftnlen)2, (ftnlen)1) > 0) {

/*  Vertical shift also */

#line 9212 ""
			    g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)
				    128, (ftnlen)1);
#line 9213 ""
			    if (i_indx("0123456789-.", durq, (ftnlen)12, (
				    ftnlen)1) == 0) {
#line 9214 ""
				i__4 = c1omnotes_1.ibarcnt - 
					c1omnotes_1.ibaroff + a1ll_2.nbars + 
					1;
#line 9214 ""
				errmsg_(lineq, &a1ll_2.iccount, &i__4, "Expe"\
					"cted number after 2nd +/- (shift dot"\
					")!", (ftnlen)128, (ftnlen)42);
#line 9216 ""
				stop1_();
#line 9217 ""
			    }
#line 9218 ""
			    readnum_(lineq, &a1ll_2.iccount, durq, &fnum, (
				    ftnlen)128, (ftnlen)1);
#line 9219 ""
			}
#line 9220 ""
			--a1ll_2.iccount;
#line 9221 ""
			goto L7;
#line 9222 ""
		    } else {
#line 9223 ""
			c1ommvl_1.nacc[c1ommvl_1.ivx + a1ll_2.nnl[
				c1ommvl_1.ivx - 1] * 24 - 25] = bit_set(
				c1ommvl_1.nacc[c1ommvl_1.ivx + a1ll_2.nnl[
				c1ommvl_1.ivx - 1] * 24 - 25],27);
#line 9224 ""
		    }
#line 9225 ""
		    goto L7;
#line 9226 ""
		} else if (*(unsigned char *)durq != ' ') {
#line 9227 ""
		    i__4 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			    a1ll_2.nbars + 1;
#line 9227 ""
		    errmsg_(lineq, &a1ll_2.iccount, &i__4, "Illegal option o"\
			    "n xtuplet note!", (ftnlen)128, (ftnlen)31);
#line 9229 ""
		    stop1_();
#line 9230 ""
		}
#line 9231 ""
		if (itup == ntup - ndoub) {
#line 9231 ""
		    goto L3;
#line 9231 ""
		}
#line 9232 ""
/* L6: */
#line 9232 ""
	    }
#line 9233 ""
L3:

/*  6==End of loop for xtuplet input */

#line 9237 ""
	    ;
#line 9237 ""
	} else if (*(unsigned char *)durq == 'm') {

/*  Multi-bar rest: next 1 or two digits are # of bars. */

#line 9241 ""
	    if (a1ll_2.itsofar[a1ll_2.iv - 1] % a1ll_2.lenbar != 0) {
#line 9242 ""
		i__1 = a1ll_2.iccount - 1;
#line 9242 ""
		i__4 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			a1ll_2.nbars + 1;
#line 9242 ""
		errmsg_(lineq, &i__1, &i__4, "Multibar rest must start at be"\
			"ginning of bar!", (ftnlen)128, (ftnlen)45);
#line 9244 ""
		stop1_();
#line 9245 ""
	    } else if (a1ll_2.iv == 1 && c1omnotes_1.ibarmbr > 0) {
#line 9246 ""
		i__1 = a1ll_2.iccount - 1;
#line 9246 ""
		i__4 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			a1ll_2.nbars + 1;
#line 9246 ""
		errmsg_(lineq, &i__1, &i__4, "Multibar rest only OK at one t"\
			"ime per block!", (ftnlen)128, (ftnlen)44);
#line 9248 ""
		stop1_();
#line 9249 ""
	    }

/*  For some purposes, pretend its one bar only */

#line 9253 ""
	    a1ll_2.nodur[a1ll_2.iv + a1ll_2.nnl[a1ll_2.iv - 1] * 24 - 25] = 
		    a1ll_2.lenbar;
#line 9254 ""
	    c1omnotes_1.ibarmbr = a1ll_2.nbars + 1;
#line 9255 ""
	    c1omnotes_1.mbrest = 0;
#line 9256 ""
	    g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)128, (ftnlen)1);
#line 9257 ""
	    if (i_indx("123456789", durq, (ftnlen)9, (ftnlen)1) == 0) {
#line 9258 ""
		i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			a1ll_2.nbars + 1;
#line 9258 ""
		errmsg_(lineq, &a1ll_2.iccount, &i__1, "Expected an integer "\
			"after \"rm\"!", (ftnlen)128, (ftnlen)31);
#line 9260 ""
		stop1_();
#line 9261 ""
	    }
#line 9262 ""
	    readnum_(lineq, &a1ll_2.iccount, durq, &fnum, (ftnlen)128, (
		    ftnlen)1);
#line 9263 ""
	    c1omnotes_1.mbrest = i_nint(&fnum);
#line 9264 ""
	    if (a1ll_2.nv > 1) {
#line 9265 ""
		if (a1ll_2.iv == 1) {
#line 9266 ""
		    comkeys_1.mbrestsav = c1omnotes_1.mbrest;
#line 9267 ""
		} else {
#line 9268 ""
		    if (c1omnotes_1.mbrest != comkeys_1.mbrestsav) {
#line 9269 ""
			i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 9269 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__1, "Must enter s"\
				"ame multi-bar rest in every voice!", (ftnlen)
				128, (ftnlen)46);
#line 9271 ""
			stop1_();
#line 9272 ""
		    }
#line 9273 ""
		}

/*  Zero out mbrestsav so can check at end of input block whether */
/*    all voices have one */

#line 9278 ""
		if (a1ll_2.iv == a1ll_2.nv) {
#line 9278 ""
		    comkeys_1.mbrestsav = 0;
#line 9278 ""
		}
#line 9279 ""
	    }
#line 9280 ""
	    if (*(unsigned char *)durq == 'n') {

/*  Get new height */

#line 9284 ""
		g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)128, (ftnlen)
			1);
#line 9285 ""
		if (i_indx("+-123456789", durq, (ftnlen)11, (ftnlen)1) == 0) {
#line 9286 ""
		    i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			    a1ll_2.nbars + 1;
#line 9286 ""
		    errmsg_(lineq, &a1ll_2.iccount, &i__1, "Expected an inte"\
			    "ger after \"rm[x]n\"!", (ftnlen)128, (ftnlen)35);
#line 9288 ""
		    stop1_();
#line 9289 ""
		}
#line 9290 ""
		if (i_indx("+-", durq, (ftnlen)2, (ftnlen)1) != 0) {
#line 9290 ""
		    ++a1ll_2.iccount;
#line 9290 ""
		}
#line 9291 ""
		readnum_(lineq, &a1ll_2.iccount, durq, &fnum, (ftnlen)128, (
			ftnlen)1);
#line 9292 ""
	    }
#line 9293 ""
	    if (*(unsigned char *)durq != ' ') {
#line 9294 ""
		i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			a1ll_2.nbars + 1;
#line 9294 ""
		errmsg_(lineq, &a1ll_2.iccount, &i__1, "Illegal character af"\
			"ter \"rm\"!", (ftnlen)128, (ftnlen)29);
#line 9296 ""
		stop1_();
#line 9297 ""
	    }
#line 9298 ""
	} else if (*(unsigned char *)durq == '.') {

/*  Dotted pattern.  Close out note.  Mult time by 3/4. */
/*  Set time for next note to 1/4.  Start the note. */

#line 9303 ""
	    idotform = 1;
#line 9304 ""
	} else if (*(unsigned char *)durq == ',') {
#line 9305 ""
	    idotform = 3;

/*  Now flow to duration setting, as if durq=' ' */

#line 9309 ""
	} else if (i_indx("oL", durq, (ftnlen)2, (ftnlen)1) > 0) {

/*  Suppress full bar rest, or look left for height */

#line 9313 ""
	    if (*(unsigned char *)charq != 'r') {
#line 9314 ""
		i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			a1ll_2.nbars + 1;
#line 9314 ""
		errmsg_(lineq, &a1ll_2.iccount, &i__1, "\"o\",\"L\" options "\
			"only legal for rest, not note!", (ftnlen)128, (ftnlen)
			46);
#line 9316 ""
		stop1_();
#line 9317 ""
	    }
#line 9318 ""
	    goto L2;
#line 9319 ""
	} else if (i_indx("DF", durq, (ftnlen)2, (ftnlen)1) > 0) {

/*  Double note for xtup.  Must check here in case "D" or "F" came before "x" or on */
/*  last note of xtup.   Need to flag it in pmxa since affects horiz. spacing. */

#line 9324 ""
	    c1ommvl_1.nacc[c1ommvl_1.ivx + a1ll_2.nnl[c1ommvl_1.ivx - 1] * 24 
		    - 25] = bit_set(c1ommvl_1.nacc[c1ommvl_1.ivx + a1ll_2.nnl[
		    c1ommvl_1.ivx - 1] * 24 - 25],18);
#line 9325 ""
	    goto L2;
#line 9326 ""
	} else if (*(unsigned char *)durq == 'A') {

/*  Main note accidental option */

#line 9330 ""
	    getchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)128, (ftnlen)1);
#line 9331 ""
	    if (i_indx("o+-<>", durq, (ftnlen)5, (ftnlen)1) == 0) {
#line 9332 ""
		i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			a1ll_2.nbars + 1;
#line 9332 ""
		errmsg_(lineq, &a1ll_2.iccount, &i__1, "\"o\",+\",\"-\",\""\
			"<\",\">\" are the only legal options here!", (ftnlen)
			128, (ftnlen)51);
#line 9334 ""
		stop1_();
#line 9335 ""
	    }

/*  Need more stuff here */

#line 9339 ""
	    if (*(unsigned char *)durq != 'o') {

/*  Back up 1, flow out, will get +|-|<|> next loop preceded by "A", and will */
/*    proceed to number input checking */

#line 9344 ""
		--a1ll_2.iccount;
#line 9345 ""
	    }
#line 9346 ""
	    goto L2;
#line 9347 ""
	} else if (*(unsigned char *)durq == 'T') {

/*  Single stem tremolo. Only option (optional) is 1,2,3, or 4. */

#line 9351 ""
	    getchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)128, (ftnlen)1);
#line 9352 ""
	    if (i_indx("1234", durq, (ftnlen)4, (ftnlen)1) == 0) {
#line 9352 ""
		--a1ll_2.iccount;
#line 9352 ""
	    }
#line 9353 ""
	    goto L2;
#line 9354 ""
	} else if (*(unsigned char *)durq != ' ') {
#line 9355 ""
	    i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + a1ll_2.nbars + 
		    1;
#line 9355 ""
	    errmsg_(lineq, &a1ll_2.iccount, &i__1, "Illegal character!", (
		    ftnlen)128, (ftnlen)18);
#line 9357 ""
	    s_wsle(&io___659);
#line 9357 ""
	    do_lio(&c__9, &c__1, "ASCII code:", (ftnlen)11);
#line 9357 ""
	    i__1 = *(unsigned char *)durq;
#line 9357 ""
	    do_lio(&c__3, &c__1, (char *)&i__1, (ftnlen)sizeof(integer));
#line 9357 ""
	    e_wsle();
#line 9358 ""
	    stop1_();
#line 9359 ""
	}

/*  End of block for note options. */

/*  Set the duration */

#line 9365 ""
	if (idotform > 0) {
#line 9366 ""
	    if (idotform == 1) {
#line 9367 ""
		a1ll_2.nodur[c1ommvl_1.ivx + a1ll_2.nnl[c1ommvl_1.ivx - 1] * 
			24 - 25] = i1fnodur_(&c1omnotes_1.nnodur, dotq, (
			ftnlen)1) * 3 / 2;
#line 9368 ""
	    } else if (idotform == 2) {
#line 9369 ""
		a1ll_2.nodur[c1ommvl_1.ivx + a1ll_2.nnl[c1ommvl_1.ivx - 1] * 
			24 - 25] = a1ll_2.nodur[c1ommvl_1.ivx + (a1ll_2.nnl[
			c1ommvl_1.ivx - 1] - 1) * 24 - 25] / 3;
#line 9370 ""
	    } else if (idotform == 3) {
#line 9371 ""
		a1ll_2.nodur[c1ommvl_1.ivx + a1ll_2.nnl[c1ommvl_1.ivx - 1] * 
			24 - 25] = i1fnodur_(&c1omnotes_1.nnodur, dotq, (
			ftnlen)1);
#line 9372 ""
	    } else if (idotform == 4) {
#line 9373 ""
		a1ll_2.nodur[c1ommvl_1.ivx + a1ll_2.nnl[c1ommvl_1.ivx - 1] * 
			24 - 25] = a1ll_2.nodur[c1ommvl_1.ivx + (a1ll_2.nnl[
			c1ommvl_1.ivx - 1] - 1) * 24 - 25] / 2;
#line 9374 ""
	    }
#line 9375 ""
	} else if (c1omnotes_1.ibarmbr != a1ll_2.nbars + 1 && ! fulbrp) {
#line 9376 ""
	    a1ll_2.nodur[c1ommvl_1.ivx + a1ll_2.nnl[c1ommvl_1.ivx - 1] * 24 - 
		    25] = i1fnodur_(&c1omnotes_1.nnodur, dotq, (ftnlen)1);

/*  Check for double dot */

#line 9380 ""
	    if (c1omnotes_1.iddot == 1) {
#line 9381 ""
		a1ll_2.nodur[c1ommvl_1.ivx + a1ll_2.nnl[c1ommvl_1.ivx - 1] * 
			24 - 25] = a1ll_2.nodur[c1ommvl_1.ivx + a1ll_2.nnl[
			c1ommvl_1.ivx - 1] * 24 - 25] * 7 / 6;
#line 9382 ""
		c1omnotes_1.iddot = 0;
#line 9383 ""
	    }
#line 9384 ""
	} else if (fulbrp) {
#line 9385 ""
	    a1ll_2.nodur[c1ommvl_1.ivx + a1ll_2.nnl[c1ommvl_1.ivx - 1] * 24 - 
		    25] = a1ll_2.lenbar;

/*  Use a one-line function to set nnodur.  It gives inverse of ifnodur. */

#line 9389 ""
	    i__1 = (integer) (log(a1ll_2.lenbar + .1f) / .69315f) + 48;
#line 9389 ""
	    chax_(ch__2, (ftnlen)1, &i__1);
#line 9389 ""
	    c1omnotes_1.nnodur = i_indx("62514x0x37", ch__2, (ftnlen)10, (
		    ftnlen)1) - 1;
#line 9391 ""
	    fulbrp = FALSE_;
#line 9392 ""
	}
#line 9393 ""
	a1ll_2.rest[c1ommvl_1.ivx + a1ll_2.nnl[c1ommvl_1.ivx - 1] * 24 - 25] =
		 *(unsigned char *)charq == 'r';

/*  If inside forced beam, check if note is beamable */

#line 9397 ""
	if (c1omget_1.fbon) {
#line 9398 ""
	    if (a1ll_2.nodur[c1ommvl_1.ivx + a1ll_2.nnl[c1ommvl_1.ivx - 1] * 
		    24 - 25] < 16) {
#line 9398 ""
		goto L120;
#line 9398 ""
	    }
#line 9399 ""
	    if (a1ll_2.nnl[c1ommvl_1.ivx - 1] > 1) {
#line 9400 ""
		if (a1ll_2.nodur[c1ommvl_1.ivx + (a1ll_2.nnl[c1ommvl_1.ivx - 
			1] - 1) * 24 - 25] == 0) {
#line 9400 ""
		    goto L120;
#line 9400 ""
		}
#line 9401 ""
	    }
#line 9402 ""
	    i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + a1ll_2.nbars + 
		    1;
#line 9402 ""
	    errmsg_(lineq, &a1ll_2.iccount, &i__1, "Unbeamable thing in forc"\
		    "ed beam!", (ftnlen)128, (ftnlen)32);
#line 9404 ""
	    stop1_();
#line 9405 ""
	}
#line 9406 ""
L120:

/* Get number of prior bars for later check on whether note spans bar line */

#line 9410 ""
	nbb4 = a1ll_2.itsofar[c1ommvl_1.ivx - 1] / a1ll_2.lenbar;
#line 9411 ""
	a1ll_2.itsofar[c1ommvl_1.ivx - 1] += a1ll_2.nodur[c1ommvl_1.ivx + 
		a1ll_2.nnl[c1ommvl_1.ivx - 1] * 24 - 25];
#line 9412 ""
	if (a1ll_2.itsofar[c1ommvl_1.ivx - 1] % a1ll_2.lenbar == 0) {
#line 9413 ""
	    ++a1ll_2.nbars;
#line 9414 ""
	    if (comkeys_1.shifton) {
#line 9414 ""
		comkeys_1.barend = TRUE_;
#line 9414 ""
	    }

/*  Will check barend when 1st note of next bar is entered. */

#line 9418 ""
	    if (a1ll_2.nbars > 15) {
#line 9419 ""
		i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			a1ll_2.nbars + 1;
#line 9419 ""
		errmsg_(lineq, &a1ll_2.iccount, &i__1, "Cannot have more tha"\
			"n 15 bars in an input block!", (ftnlen)128, (ftnlen)
			48);
#line 9421 ""
		stop1_();
#line 9422 ""
	    }
#line 9423 ""
	    a1ll_2.nib[c1ommvl_1.ivx + a1ll_2.nbars * 24 - 25] = a1ll_2.nnl[
		    c1ommvl_1.ivx - 1];
#line 9424 ""
	    if (a1ll_2.firstline && a1ll_2.lenbar != a1ll_2.lenbr1) {

/*  Just finished the pickup bar for this voice. */

#line 9428 ""
		if (a1ll_2.itsofar[c1ommvl_1.ivx - 1] != a1ll_2.lenbr0) {
#line 9429 ""
		    i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			    a1ll_2.nbars + 1;
#line 9429 ""
		    errmsg_(lineq, &a1ll_2.iccount, &i__1, "Pickup bar lengt"\
			    "h disagrees with mtrnum0!", (ftnlen)128, (ftnlen)
			    41);
#line 9431 ""
		    stop1_();
#line 9432 ""
		}
#line 9433 ""
		a1ll_2.lenbar = a1ll_2.lenbr1;
#line 9434 ""
		a1ll_2.itsofar[c1ommvl_1.ivx - 1] = 0;
#line 9435 ""
	    }
#line 9436 ""
	} else if (comkeys_1.barend) {
#line 9437 ""
	    if (comkeys_1.shifton) {
#line 9438 ""
		i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			a1ll_2.nbars + 1;
#line 9438 ""
		errmsg_(lineq, &a1ll_2.iccount, &i__1, "Bar ended with user-"\
			"defined shift still on!", (ftnlen)128, (ftnlen)43);
#line 9440 ""
		stop1_();
#line 9441 ""
	    }
#line 9442 ""
	    comkeys_1.barend = FALSE_;
#line 9443 ""
	} else if (a1ll_2.itsofar[c1ommvl_1.ivx - 1] / a1ll_2.lenbar > nbb4) {
#line 9444 ""
	    i__1 = a1ll_2.iccount - 1;
#line 9444 ""
	    i__4 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + a1ll_2.nbars + 
		    1;
#line 9444 ""
	    errmsg_(lineq, &i__1, &i__4, "This note spans a bar line!", (
		    ftnlen)128, (ftnlen)27);
#line 9446 ""
	    stop1_();
#line 9447 ""
	}
#line 9448 ""
	if (idotform == 1 || idotform == 3) {
#line 9449 ""
	    g1etchar_(lineq, &a1ll_2.iccount, charq, (ftnlen)128, (ftnlen)1);
#line 9450 ""
	    if (i_indx("abcedfgr", charq, (ftnlen)8, (ftnlen)1) == 0) {
#line 9451 ""
		i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			a1ll_2.nbars + 1;
#line 9451 ""
		errmsg_(lineq, &a1ll_2.iccount, &i__1, "Expected note name o"\
			"r \"r\" here!", (ftnlen)128, (ftnlen)31);
#line 9453 ""
		stop1_();
#line 9454 ""
	    }
#line 9455 ""
	    ++idotform;
#line 9456 ""
	    numnum = 1;
#line 9457 ""
	    goto L28;
#line 9458 ""
	}

/*  End of sub block for note-rest */

#line 9462 ""
    } else if (*(unsigned char *)charq == 'z') {
#line 9463 ""
	g1etchar_(lineq, &a1ll_2.iccount, charq, (ftnlen)128, (ftnlen)1);
#line 9464 ""
	if (i_indx("abcdefg", charq, (ftnlen)7, (ftnlen)1) == 0) {
#line 9465 ""
	    i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + a1ll_2.nbars + 
		    1;
#line 9465 ""
	    errmsg_(lineq, &a1ll_2.iccount, &i__1, "Expected chord note name"\
		    " here!", (ftnlen)128, (ftnlen)30);
#line 9467 ""
	    stop1_();
#line 9468 ""
	}
#line 9469 ""
L25:
#line 9469 ""
	g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)128, (ftnlen)1);
#line 9470 ""
	if (i_indx("dre12345678c", durq, (ftnlen)12, (ftnlen)1) > 0) {
#line 9471 ""
	    goto L25;
#line 9472 ""
	} else if (i_indx("fsn", durq, (ftnlen)3, (ftnlen)1) > 0) {

/* Check for midi-only accid. CANNOT coesist with accidental position tweaks, so */
/*   MUST come right after "f,s,n" */

#line 9477 ""
	    i__1 = a1ll_2.iccount;
#line 9477 ""
	    if (s_cmp(lineq + i__1, "i", a1ll_2.iccount + 1 - i__1, (ftnlen)1)
		     == 0) {
#line 9477 ""
		++a1ll_2.iccount;
#line 9477 ""
	    }
#line 9478 ""
	    goto L25;
#line 9479 ""
	} else if (*(unsigned char *)durq == 'A') {
#line 9480 ""
	    i__1 = a1ll_2.iccount - 2;
#line 9480 ""
	    if (i_indx("fsn", lineq + i__1, (ftnlen)3, a1ll_2.iccount - 1 - 
		    i__1) == 0) {
#line 9481 ""
		i__1 = a1ll_2.iccount - 1;
#line 9481 ""
		i__4 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			a1ll_2.nbars + 1;
#line 9481 ""
		errmsg_(lineq, &i__1, &i__4, "Must have \"f,s,n\" before \""\
			"A\" in chord note!", (ftnlen)128, (ftnlen)43);
#line 9483 ""
		stop1_();
#line 9484 ""
	    }
#line 9485 ""
	    goto L25;
#line 9486 ""
	} else if (i_indx("<>", durq, (ftnlen)2, (ftnlen)1) > 0) {
#line 9487 ""
	    i__1 = a1ll_2.iccount - 2;
#line 9487 ""
	    if (i_indx("fsnA", lineq + i__1, (ftnlen)4, a1ll_2.iccount - 1 - 
		    i__1) == 0) {
#line 9488 ""
		i__1 = a1ll_2.iccount - 1;
#line 9488 ""
		i__4 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			a1ll_2.nbars + 1;
#line 9488 ""
		errmsg_(lineq, &i__1, &i__4, "Must have \"f,s,n,A\" before"\
			" \"<\" or \">\"!", (ftnlen)128, (ftnlen)38);
#line 9490 ""
		stop1_();
#line 9491 ""
	    }
#line 9492 ""
	    g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)128, (ftnlen)1);
#line 9493 ""
	    if (i_indx("1234567890.", durq, (ftnlen)11, (ftnlen)1) == 0) {
#line 9494 ""
		i__1 = a1ll_2.iccount - 1;
#line 9494 ""
		i__4 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			a1ll_2.nbars + 1;
#line 9494 ""
		errmsg_(lineq, &i__1, &i__4, "Expected a number to start her"\
			"e for accidental shift!", (ftnlen)128, (ftnlen)53);
#line 9496 ""
		stop1_();
#line 9497 ""
	    }
#line 9498 ""
	    readnum_(lineq, &a1ll_2.iccount, durq, &fnum, (ftnlen)128, (
		    ftnlen)1);
#line 9499 ""
	    --a1ll_2.iccount;
#line 9500 ""
	    goto L25;
#line 9501 ""
	} else if (i_indx("+-", durq, (ftnlen)2, (ftnlen)1) > 0) {
#line 9502 ""
	    i__1 = a1ll_2.iccount;
#line 9502 ""
	    if (i_indx("1234567890.", lineq + i__1, (ftnlen)11, 
		    a1ll_2.iccount + 1 - i__1) == 0) {
#line 9502 ""
		goto L25;
#line 9502 ""
	    }

/*  Number or '.' (durq) follows +/- .   Get it. */

#line 9507 ""
	    g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)128, (ftnlen)1);
#line 9508 ""
	    i__1 = a1ll_2.iccount;
#line 9508 ""
	    if (*(unsigned char *)durq == '.' && i_indx("1234567890", lineq + 
		    i__1, (ftnlen)10, a1ll_2.iccount + 1 - i__1) == 0) {
#line 9510 ""
		i__1 = a1ll_2.iccount - 1;
#line 9510 ""
		i__4 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			a1ll_2.nbars + 1;
#line 9510 ""
		errmsg_(lineq, &i__1, &i__4, "\".\" here must be followed by"\
			" a digit!", (ftnlen)128, (ftnlen)37);
#line 9512 ""
		stop1_();
#line 9513 ""
	    } else /* if(complicated condition) */ {
#line 9513 ""
		i__1 = a1ll_2.iccount - 3;
#line 9513 ""
		if (i_indx("sfndA", lineq + i__1, (ftnlen)5, a1ll_2.iccount - 
			2 - i__1) == 0) {
#line 9514 ""
		    i__1 = a1ll_2.iccount - 1;
#line 9514 ""
		    i__4 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			    a1ll_2.nbars + 1;
#line 9514 ""
		    errmsg_(lineq, &i__1, &i__4, "Number after +/- must foll"\
			    "ow \"d,s,f,n,A\"!", (ftnlen)128, (ftnlen)41);
#line 9516 ""
		    stop1_();
#line 9517 ""
		}
#line 9517 ""
	    }
#line 9518 ""
	    readnum_(lineq, &a1ll_2.iccount, durq, &fnum, (ftnlen)128, (
		    ftnlen)1);
#line 9519 ""
	    if (i_indx("+-", durq, (ftnlen)2, (ftnlen)1) == 0) {
#line 9520 ""
		--a1ll_2.iccount;
#line 9521 ""
		goto L25;
#line 9522 ""
	    }

/*  2nd +/- */

#line 9526 ""
	    g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)128, (ftnlen)1);
#line 9527 ""
	    if (*(unsigned char *)durq == '.') {
#line 9527 ""
		g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)128, (ftnlen)
			1);
#line 9527 ""
	    }
#line 9528 ""
	    if (i_indx("1234567890", durq, (ftnlen)10, (ftnlen)1) == 0) {
#line 9529 ""
		i__1 = a1ll_2.iccount - 1;
#line 9529 ""
		i__4 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			a1ll_2.nbars + 1;
#line 9529 ""
		errmsg_(lineq, &i__1, &i__4, "Expected a number here!", (
			ftnlen)128, (ftnlen)23);
#line 9531 ""
		stop1_();
#line 9532 ""
	    }
#line 9533 ""
	    readnum_(lineq, &a1ll_2.iccount, durq, &fnum, (ftnlen)128, (
		    ftnlen)1);
#line 9534 ""
	    --a1ll_2.iccount;
#line 9535 ""
	    goto L25;
#line 9536 ""
	} else if (*(unsigned char *)durq != ' ') {
#line 9537 ""
	    i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + a1ll_2.nbars + 
		    1;
#line 9537 ""
	    errmsg_(lineq, &a1ll_2.iccount, &i__1, "Illegal character in cho"\
		    "rd note!", (ftnlen)128, (ftnlen)32);
#line 9539 ""
	    stop1_();
#line 9540 ""
	}
#line 9541 ""
    } else if (*(unsigned char *)charq == 'G') {
#line 9542 ""
	ngr = 1;
#line 9543 ""
L9:
#line 9543 ""
	g1etchar_(lineq, &a1ll_2.iccount, charq, (ftnlen)128, (ftnlen)1);
#line 9544 ""
	if (i_indx("123456789", charq, (ftnlen)9, (ftnlen)1) > 0) {
#line 9545 ""
	    readnum_(lineq, &a1ll_2.iccount, durq, &fnum, (ftnlen)128, (
		    ftnlen)1);
#line 9546 ""
	    ngr = i_nint(&fnum);
#line 9547 ""
	    --a1ll_2.iccount;
#line 9548 ""
	    goto L9;
#line 9549 ""
	} else if (i_indx("AWulxs", charq, (ftnlen)6, (ftnlen)1) > 0) {
#line 9550 ""
	    goto L9;
#line 9551 ""
	} else if (*(unsigned char *)charq == 'm') {
#line 9552 ""
	    g1etchar_(lineq, &a1ll_2.iccount, charq, (ftnlen)128, (ftnlen)1);
#line 9553 ""
	    if (i_indx("01234", charq, (ftnlen)5, (ftnlen)1) == 0) {
#line 9554 ""
		i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			a1ll_2.nbars + 1;
#line 9554 ""
		errmsg_(lineq, &a1ll_2.iccount, &i__1, "A digit less than 5 "\
			"must follow \"m\" in a grace note!", (ftnlen)128, (
			ftnlen)52);
#line 9556 ""
		stop1_();
#line 9557 ""
	    }
#line 9558 ""
	    goto L9;
#line 9559 ""
	} else if (*(unsigned char *)charq == 'X') {

/* Space before main note */

#line 9563 ""
	    g1etchar_(lineq, &a1ll_2.iccount, charq, (ftnlen)128, (ftnlen)1);
#line 9564 ""
	    if (i_indx("0123456789.", charq, (ftnlen)11, (ftnlen)1) > 0) {
#line 9565 ""
		readnum_(lineq, &a1ll_2.iccount, durq, &fnum, (ftnlen)128, (
			ftnlen)1);
#line 9566 ""
		--a1ll_2.iccount;
#line 9567 ""
		goto L9;
#line 9568 ""
	    } else {
#line 9569 ""
		i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			a1ll_2.nbars + 1;
#line 9569 ""
		errmsg_(lineq, &a1ll_2.iccount, &i__1, "A number must foll"\
			"ow \"X\" in a grace note!", (ftnlen)128, (ftnlen)41);
#line 9571 ""
		stop1_();
#line 9572 ""
	    }
#line 9573 ""
	}

/*  At this point, charq is first note name in rest (grace?) */

#line 9577 ""
	i__1 = ngr;
#line 9577 ""
	for (igr = 1; igr <= i__1; ++igr) {
#line 9578 ""
	    numnum = 0;
#line 9579 ""
	    if (igr > 1) {
#line 9580 ""
L55:
#line 9580 ""
		g1etchar_(lineq, &a1ll_2.iccount, charq, (ftnlen)128, (ftnlen)
			1);
#line 9581 ""
		if (*(unsigned char *)charq == ' ') {
#line 9581 ""
		    goto L55;
#line 9581 ""
		}
#line 9582 ""
	    }
#line 9583 ""
	    if (i_indx("abcdefg", charq, (ftnlen)7, (ftnlen)1) == 0) {
#line 9584 ""
		i__4 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			a1ll_2.nbars + 1;
#line 9584 ""
		errmsg_(lineq, &a1ll_2.iccount, &i__4, "In grace, expected"\
			" \"a\"-\"g\"!", (ftnlen)128, (ftnlen)27);
#line 9586 ""
		stop1_();
#line 9587 ""
	    }
#line 9588 ""
L18:
#line 9588 ""
	    g1etchar_(lineq, &a1ll_2.iccount, charq, (ftnlen)128, (ftnlen)1);
#line 9589 ""
	    if (*(unsigned char *)charq != ' ') {
#line 9590 ""
		if (i_indx("1234567", charq, (ftnlen)7, (ftnlen)1) > 0) {
#line 9591 ""
		    if (numnum == 1) {
#line 9592 ""
			i__4 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 9592 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__4, "Only one of"\
				" \"+-1234567\" allowed here in grace!", (
				ftnlen)128, (ftnlen)46);
#line 9594 ""
			stop1_();
#line 9595 ""
		    }
#line 9596 ""
		    numnum = 1;
#line 9597 ""
		    goto L18;
/*            else if (index('nfs',charq) .gt. 0) then */
#line 9599 ""
		} else if (i_indx("+-nfs", charq, (ftnlen)5, (ftnlen)1) > 0) {
#line 9600 ""
		    goto L18;
#line 9601 ""
		}

/*  Digits are possible octave numbers */

#line 9605 ""
		i__4 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			a1ll_2.nbars + 1;
#line 9605 ""
		errmsg_(lineq, &a1ll_2.iccount, &i__4, "Illegal character af"\
			"ter note name in grace!", (ftnlen)128, (ftnlen)43);
#line 9607 ""
		stop1_();
#line 9608 ""
	    }
#line 9609 ""
/* L19: */
#line 9609 ""
	}
#line 9610 ""
    } else /* if(complicated condition) */ {
#line 9610 ""
	chax_(ch__2, (ftnlen)1, &c__92);
#line 9610 ""
	if (*(unsigned char *)charq == *(unsigned char *)&ch__2[0]) {
#line 9611 ""
	    chklit_(lineq, &a1ll_2.iccount, &literr, (ftnlen)128);
#line 9612 ""
	    if (literr > 0) {
#line 9613 ""
		i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			a1ll_2.nbars + 1;
#line 9613 ""
		errmsg_(lineq, &a1ll_2.iccount, &i__1, literq + (literr - 1) *
			 51, (ftnlen)128, (ftnlen)51);
#line 9615 ""
		stop1_();
#line 9616 ""
	    }
#line 9617 ""
	} else /* if(complicated condition) */ {
#line 9617 ""
	    chax_(ch__2, (ftnlen)1, &c__34);
#line 9617 ""
	    if (*(unsigned char *)charq == *(unsigned char *)&ch__2[0]) {

/*  pmx lyric */

#line 9621 ""
		chkpmxlyr_(lineq, &a1ll_2.iccount, &lyrerr, (ftnlen)128);
#line 9622 ""
		if (lyrerr > 0) {
#line 9623 ""
		    i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			    a1ll_2.nbars + 1;
#line 9623 ""
		    errmsg_(lineq, &a1ll_2.iccount, &i__1, lyrerq + (lyrerr - 
			    1) * 51, (ftnlen)128, (ftnlen)51);
#line 9625 ""
		    stop1_();
#line 9626 ""
		}
#line 9627 ""
	    } else if (*(unsigned char *)charq == 'o') {

/*  Ornament on non-xtup note. "o" symbol must come AFTER the affected note */

#line 9631 ""
		if (a1ll_2.nnl[c1ommvl_1.ivx - 1] == 0) {
#line 9632 ""
		    i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			    a1ll_2.nbars + 1;
#line 9632 ""
		    errmsg_(lineq, &a1ll_2.iccount, &i__1, "\"o\" must be in"\
			    " same input block, after affected note!", (ftnlen)
			    128, (ftnlen)53);
#line 9634 ""
		    stop1_();
#line 9635 ""
		}
#line 9636 ""
		g1etchar_(lineq, &a1ll_2.iccount, dumq, (ftnlen)128, (ftnlen)
			1);
/*        if (index('(stmgx+Tupf._)e:>^bc',dumq) .eq. 0 ) then */
#line 9638 ""
		if (i_indx("(stmgx+Tupf._)e:>^bcCG", dumq, (ftnlen)22, (
			ftnlen)1) == 0) {
#line 9639 ""
		    i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			    a1ll_2.nbars + 1;
#line 9639 ""
		    errmsg_(lineq, &a1ll_2.iccount, &i__1, "Illegal ornament!"
			    , (ftnlen)128, (ftnlen)17);
#line 9641 ""
		    stop1_();
#line 9642 ""
		}
#line 9643 ""
		if (*(unsigned char *)dumq == ':') {
#line 9644 ""
		    g1etchar_(lineq, &a1ll_2.iccount, dumq, (ftnlen)128, (
			    ftnlen)1);
#line 9645 ""
		    if (*(unsigned char *)dumq != ' ') {
#line 9646 ""
			i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 9646 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__1, "Expected bla"\
				"nk after \"o:\"!", (ftnlen)128, (ftnlen)26);
#line 9648 ""
			stop1_();
#line 9649 ""
		    } else if (! comkeys_1.ornrpt) {
#line 9650 ""
			i__1 = a1ll_2.iccount - 1;
#line 9650 ""
			i__4 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 9650 ""
			errmsg_(lineq, &i__1, &i__4, "Turned off repeated or"\
				"naments before they were on!", (ftnlen)128, (
				ftnlen)50);
#line 9652 ""
			stop1_();
#line 9653 ""
		    }
#line 9654 ""
		    comkeys_1.ornrpt = FALSE_;
#line 9655 ""
		} else if (*(unsigned char *)dumq == 'g') {
#line 9656 ""
		    if (c1omget_1.issegno) {
#line 9657 ""
			i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 9657 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__1, "Sorry, only "\
				"one \"segno\" per input block!", (ftnlen)128, 
				(ftnlen)40);
#line 9659 ""
			stop1_();
#line 9660 ""
		    } else if (c1ommvl_1.ivx != 1) {
#line 9661 ""
			i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 9661 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__1, "segno can on"\
				"ly be in voice 1!", (ftnlen)128, (ftnlen)29);
#line 9663 ""
			stop1_();
#line 9664 ""
		    }
#line 9665 ""
		    c1omget_1.issegno = TRUE_;
#line 9666 ""
L12:
#line 9666 ""
		    g1etchar_(lineq, &a1ll_2.iccount, dumq, (ftnlen)128, (
			    ftnlen)1);
#line 9667 ""
		    if (*(unsigned char *)dumq == '-' || *(unsigned char *)
			    dumq >= 48 && *(unsigned char *)dumq <= 58) {
#line 9667 ""
			goto L12;
#line 9667 ""
		    }
#line 9669 ""
		    if (*(unsigned char *)dumq != ' ') {
#line 9670 ""
			i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 9670 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__1, "Illegal char"\
				"acter in segno ornament symbol!", (ftnlen)128,
				 (ftnlen)43);
#line 9672 ""
			stop1_();
#line 9673 ""
		    }
#line 9674 ""
		} else if (*(unsigned char *)dumq == 'T') {

/*  Trill.  may be followed by 't' and/or number.  read 'til blank */

#line 9678 ""
L22:
#line 9678 ""
		    g1etchar_(lineq, &a1ll_2.iccount, dumq, (ftnlen)128, (
			    ftnlen)1);
#line 9679 ""
		    if (*(unsigned char *)dumq == ':') {
#line 9680 ""
			i__1 = a1ll_2.iccount;
#line 9680 ""
			if (s_cmp(lineq + i__1, " ", a1ll_2.iccount + 1 - 
				i__1, (ftnlen)1) != 0) {
#line 9681 ""
			    i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff 
				    + a1ll_2.nbars + 1;
#line 9681 ""
			    errmsg_(lineq, &a1ll_2.iccount, &i__1, "Expected"\
				    " blank after \":\"!", (ftnlen)128, (
				    ftnlen)25);
#line 9683 ""
			    stop1_();
#line 9684 ""
			}
#line 9685 ""
			goto L32;
#line 9686 ""
		    } else if (*(unsigned char *)dumq != ' ') {
#line 9687 ""
			goto L22;
#line 9688 ""
		    }
#line 9689 ""
		} else if (*(unsigned char *)dumq == 'f') {
#line 9690 ""
		    g1etchar_(lineq, &a1ll_2.iccount, dumq, (ftnlen)128, (
			    ftnlen)1);
#line 9691 ""
		    if (i_indx(" d+-:", dumq, (ftnlen)5, (ftnlen)1) == 0) {
#line 9692 ""
			i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 9692 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__1, "Illegal char"\
				"acter after \"f\" in fermata ornament symbol!"
				, (ftnlen)128, (ftnlen)55);
#line 9694 ""
			stop1_();
#line 9695 ""
		    }
#line 9696 ""
		    if (*(unsigned char *)dumq == 'd') {
#line 9696 ""
			g1etchar_(lineq, &a1ll_2.iccount, dumq, (ftnlen)128, (
				ftnlen)1);
#line 9696 ""
		    }
#line 9697 ""
		    if (*(unsigned char *)dumq == ':') {
#line 9697 ""
			goto L32;
#line 9697 ""
		    }
#line 9698 ""
		} else if (*(unsigned char *)dumq == 'e') {
#line 9699 ""
		    g1etchar_(lineq, &a1ll_2.iccount, dumq, (ftnlen)128, (
			    ftnlen)1);
#line 9700 ""
		    if (i_indx("sfn?", dumq, (ftnlen)4, (ftnlen)1) == 0) {
#line 9701 ""
			i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 9701 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__1, "Illegal char"\
				"acter after \"e\" in edit. accid. symbol!", (
				ftnlen)128, (ftnlen)51);
#line 9703 ""
			stop1_();
#line 9704 ""
		    }
#line 9705 ""
		    g1etchar_(lineq, &a1ll_2.iccount, dumq, (ftnlen)128, (
			    ftnlen)1);
#line 9706 ""
		    if (*(unsigned char *)dumq == '?') {
#line 9706 ""
			g1etchar_(lineq, &a1ll_2.iccount, dumq, (ftnlen)128, (
				ftnlen)1);
#line 9706 ""
		    }
#line 9707 ""
		} else {
#line 9708 ""
		    g1etchar_(lineq, &a1ll_2.iccount, dumq, (ftnlen)128, (
			    ftnlen)1);
#line 9709 ""
		}
#line 9710 ""
		if (i_indx("+- :", dumq, (ftnlen)4, (ftnlen)1) == 0) {
#line 9711 ""
		    i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			    a1ll_2.nbars + 1;
#line 9711 ""
		    errmsg_(lineq, &a1ll_2.iccount, &i__1, "Illegal characte"\
			    "r in ornament symbol!", (ftnlen)128, (ftnlen)37);
#line 9713 ""
		    stop1_();
#line 9714 ""
		}
#line 9715 ""
		if (i_indx("+-", dumq, (ftnlen)2, (ftnlen)1) > 0) {
#line 9716 ""
		    i__1 = a1ll_2.iccount;
#line 9716 ""
		    if (i_indx("0123456789", lineq + i__1, (ftnlen)10, 
			    a1ll_2.iccount + 1 - i__1) == 0) {
#line 9717 ""
			i__1 = a1ll_2.iccount + 1;
#line 9717 ""
			i__4 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 9717 ""
			errmsg_(lineq, &i__1, &i__4, "There should be an int"\
				"eger here!", (ftnlen)128, (ftnlen)32);
#line 9719 ""
			stop1_();
#line 9720 ""
		    }
#line 9721 ""
		    readnum_(lineq, &a1ll_2.iccount, durq, &fnum, (ftnlen)128,
			     (ftnlen)1);
#line 9722 ""
		    if (*(unsigned char *)durq == ':') {
#line 9723 ""
			i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 9723 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__1, "Cannot shift"\
				" AND repeat an ornament!", (ftnlen)128, (
				ftnlen)36);
#line 9725 ""
			stop1_();
#line 9726 ""
		    }

/*  12/7/03 Allow horizontal shift on any ornament, not just breath and caes. */

#line 9730 ""
		    if (i_indx("+-", durq, (ftnlen)2, (ftnlen)1) > 0) {
#line 9731 ""
			i__1 = a1ll_2.iccount;
#line 9731 ""
			if (i_indx(".0123456789", lineq + i__1, (ftnlen)11, 
				a1ll_2.iccount + 1 - i__1) == 0) {
#line 9733 ""
			    i__1 = a1ll_2.iccount + 1;
#line 9733 ""
			    i__4 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff 
				    + a1ll_2.nbars + 1;
#line 9733 ""
			    errmsg_(lineq, &i__1, &i__4, "There should be a "\
				    "number here!", (ftnlen)128, (ftnlen)30);
#line 9735 ""
			    stop1_();
#line 9736 ""
			}
#line 9737 ""
			readnum_(lineq, &a1ll_2.iccount, durq, &fnum, (ftnlen)
				128, (ftnlen)1);
#line 9738 ""
		    }
#line 9739 ""
		}
#line 9740 ""
L32:
#line 9741 ""
		if (*(unsigned char *)dumq == ':') {
#line 9742 ""
		    i__1 = a1ll_2.iccount;
#line 9742 ""
		    if (s_cmp(lineq + i__1, " ", a1ll_2.iccount + 1 - i__1, (
			    ftnlen)1) != 0) {
#line 9743 ""
			i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 9743 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__1, "\":\" must b"\
				"e followed by blank in \"o: \"!", (ftnlen)128,
				 (ftnlen)39);
#line 9745 ""
			stop1_();
#line 9746 ""
		    } else if (comkeys_1.ornrpt) {
#line 9747 ""
			i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 9747 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__1, "Turned on re"\
				"peated ornaments but already on!", (ftnlen)
				128, (ftnlen)44);
#line 9749 ""
			stop1_();
#line 9750 ""
		    }
#line 9751 ""
		    comkeys_1.ornrpt = TRUE_;
#line 9752 ""
		}
#line 9753 ""
	    } else if (i_indx("st(){}", charq, (ftnlen)6, (ftnlen)1) > 0) {
#line 9754 ""
		numint = 0;
#line 9755 ""
		iposn = 0;
#line 9756 ""
L8:
#line 9756 ""
		g1etchar_(lineq, &a1ll_2.iccount, dumq, (ftnlen)128, (ftnlen)
			1);
#line 9757 ""
		++iposn;
#line 9758 ""
		if (*(unsigned char *)charq == 't' && *(unsigned char *)dumq 
			== 't') {
#line 9759 ""
		    i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			    a1ll_2.nbars + 1;
#line 9759 ""
		    errmsg_(lineq, &a1ll_2.iccount, &i__1, "Cannot use \"t\""\
			    " as an option on a tie!", (ftnlen)128, (ftnlen)37)
			    ;
#line 9761 ""
		    stop1_();
#line 9762 ""
		}
#line 9763 ""
		if (i_indx("udltb+-fnhHpsv ", dumq, (ftnlen)15, (ftnlen)1) == 
			0) {

/*  Check for explicit ID code. */

#line 9767 ""
		    ic = *(unsigned char *)dumq;
#line 9768 ""
		    if (ic < 48 || ic > 57 && ic < 65 || ic > 90) {

/*  Not 0-9 or A-Z, so exit */

#line 9773 ""
			i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 9773 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__1, "Illegal char"\
				"acter in slur symbol!", (ftnlen)128, (ftnlen)
				33);
#line 9775 ""
			stop1_();
#line 9776 ""
		    } else {

/*  It is a possible ID code.  Right place? */

#line 9780 ""
			if (iposn != 1) {

/*  Slur ID is not 2nd! */

#line 9784 ""
			    i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff 
				    + a1ll_2.nbars + 1;
#line 9784 ""
			    errmsg_(lineq, &a1ll_2.iccount, &i__1, "Slur ID "\
				    "must be second character in slur symbol!",
				     (ftnlen)128, (ftnlen)48);
#line 9786 ""
			    stop1_();
#line 9787 ""
			} else if (*(unsigned char *)charq == 't' && 
				comslur_1.fontslur) {
#line 9788 ""
			    i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff 
				    + a1ll_2.nbars + 1;
#line 9788 ""
			    errmsg_(lineq, &a1ll_2.iccount, &i__1, "Slur ID "\
				    "not allowed on non-postscript tie!", (
				    ftnlen)128, (ftnlen)42);
#line 9790 ""
			    stop1_();
#line 9791 ""
			} else /* if(complicated condition) */ {
#line 9791 ""
			    i__1 = a1ll_2.iccount;
#line 9791 ""
			    if (s_cmp(lineq + i__1, "x", a1ll_2.iccount + 1 - 
				    i__1, (ftnlen)1) == 0) {
#line 9792 ""
				++a1ll_2.iccount;
#line 9793 ""
			    }
#line 9793 ""
			}
#line 9794 ""
		    }

/*  Slur ID is OK. Note it cannot be "H" at this point.. */

#line 9798 ""
		    goto L8;
#line 9799 ""
		} else if (*(unsigned char *)dumq == 'H') {
#line 9800 ""
		    if (iposn == 1) {
#line 9800 ""
			goto L8;
#line 9800 ""
		    }

/*  "H" is NOT an ID code. */

#line 9804 ""
		    if (! comslur_1.fontslur && *(unsigned char *)charq == 
			    't') {
#line 9805 ""
			i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 9805 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__1, "Cannot resha"\
				"pe postscript ties this way!", (ftnlen)128, (
				ftnlen)40);
#line 9807 ""
			stop1_();
#line 9808 ""
		    }
#line 9809 ""
		    i__1 = a1ll_2.iccount;
#line 9809 ""
		    if (s_cmp(lineq + i__1, "H", a1ll_2.iccount + 1 - i__1, (
			    ftnlen)1) == 0) {
#line 9810 ""
			++a1ll_2.iccount;
#line 9811 ""
			++iposn;
#line 9812 ""
		    }
#line 9813 ""
		    goto L8;
#line 9814 ""
		} else if (i_indx("fh", dumq, (ftnlen)2, (ftnlen)1) > 0 && ! 
			comslur_1.fontslur && *(unsigned char *)charq == 't') 
			{

/*  3/9/03 Can't reshape postscript tie. */

#line 9819 ""
		    i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			    a1ll_2.nbars + 1;
#line 9819 ""
		    errmsg_(lineq, &a1ll_2.iccount, &i__1, "Cannot reshape p"\
			    "ostscript ties this way!", (ftnlen)128, (ftnlen)
			    40);
#line 9821 ""
		    stop1_();
#line 9822 ""
		} else if (*(unsigned char *)dumq == 'p') {

/*  local change in postscript slur/tie adjustment default */

#line 9826 ""
		    if (comslur_1.fontslur) {
#line 9827 ""
			i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 9827 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__1, "Must use pos"\
				"tscript slurs (\"Ap\") to use this option!", (
				ftnlen)128, (ftnlen)52);
#line 9829 ""
			stop1_();
#line 9830 ""
		    }
#line 9831 ""
		    g1etchar_(lineq, &a1ll_2.iccount, dumq, (ftnlen)128, (
			    ftnlen)1);
#line 9832 ""
		    if (i_indx("+-", dumq, (ftnlen)2, (ftnlen)1) == 0) {
#line 9833 ""
			i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 9833 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__1, "Expected \""\
				"+\" or \"-\" here!", (ftnlen)128, (ftnlen)25);
#line 9835 ""
			stop1_();
#line 9836 ""
		    }
#line 9837 ""
		    g1etchar_(lineq, &a1ll_2.iccount, dumq, (ftnlen)128, (
			    ftnlen)1);
#line 9838 ""
		    if (i_indx("st", dumq, (ftnlen)2, (ftnlen)1) == 0) {
#line 9839 ""
			i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 9839 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__1, "Expected \""\
				"s\" or \"t\" here!", (ftnlen)128, (ftnlen)25);
#line 9841 ""
			stop1_();
#line 9842 ""
		    }
#line 9843 ""
		    iposn += 2;
#line 9844 ""
		    goto L8;
#line 9845 ""
		}
#line 9846 ""
		if (i_indx("udltbfnh", dumq, (ftnlen)8, (ftnlen)1) > 0) {
#line 9847 ""
		    goto L8;
#line 9848 ""
		} else if (i_indx("+-", dumq, (ftnlen)2, (ftnlen)1) > 0) {
#line 9849 ""
		    ++numint;
#line 9850 ""
		    if (comslur_1.fontslur && *(unsigned char *)charq == 't') 
			    {
#line 9851 ""
			i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 9851 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__1, "\"+|-\" for "\
				"slur height only allowed in \"s\"-slurs!", (
				ftnlen)128, (ftnlen)48);
#line 9853 ""
			stop1_();
#line 9854 ""
		    }
#line 9855 ""
		    ++a1ll_2.iccount;
#line 9856 ""
		    readnum_(lineq, &a1ll_2.iccount, durq, &fnum, (ftnlen)128,
			     (ftnlen)1);
#line 9857 ""
		    if (numint == 1) {
#line 9858 ""
			if (i_nint(&fnum) > 30) {
#line 9859 ""
			    i__1 = a1ll_2.iccount - 1;
#line 9859 ""
			    i__4 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff 
				    + a1ll_2.nbars + 1;
#line 9859 ""
			    errmsg_(lineq, &i__1, &i__4, "Magnitude of slur "\
				    "height adjustment cannot exceed 30!", (
				    ftnlen)128, (ftnlen)53);
#line 9861 ""
			    stop1_();
#line 9862 ""
			}
#line 9863 ""
		    } else if (numint == 2) {
#line 9864 ""
			if (dabs(fnum) > 6.3f) {
#line 9865 ""
			    i__1 = a1ll_2.iccount - 1;
#line 9865 ""
			    i__4 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff 
				    + a1ll_2.nbars + 1;
#line 9865 ""
			    errmsg_(lineq, &i__1, &i__4, "Slur horiz shift m"\
				    "ust be in range (-6.3,6.3)!", (ftnlen)128,
				     (ftnlen)45);
#line 9867 ""
			    stop1_();
#line 9868 ""
			}
#line 9869 ""
		    } else {

/*  Third signed integer, must be a midslur or curve spec. */

#line 9873 ""
			if (dabs(fnum) > 31.f) {
#line 9874 ""
			    i__1 = a1ll_2.iccount - 1;
#line 9874 ""
			    i__4 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff 
				    + a1ll_2.nbars + 1;
#line 9874 ""
			    errmsg_(lineq, &i__1, &i__4, "Slur midheight mus"\
				    "t be in the range (-31,31)!", (ftnlen)128,
				     (ftnlen)45);
#line 9876 ""
			    stop1_();
#line 9877 ""
			}
#line 9878 ""
			if (*(unsigned char *)durq == ':') {

/*  Expecting curve parameters.  Get two numbers */

#line 9882 ""
			    for (i__ = 1; i__ <= 2; ++i__) {
#line 9883 ""
				++a1ll_2.iccount;
#line 9884 ""
				fnum = (real) (*(unsigned char *)&lineq[
					a1ll_2.iccount - 1] - 48);
#line 9885 ""
				if ((r__1 = fnum - 3.5f, dabs(r__1)) > 3.6f) {
#line 9886 ""
				    i__1 = c1omnotes_1.ibarcnt - 
					    c1omnotes_1.ibaroff + 
					    a1ll_2.nbars + 1;
#line 9886 ""
				    errmsg_(lineq, &a1ll_2.iccount, &i__1, 
					    "Slur curve parameter must be in"\
					    " range (0,7)!", (ftnlen)128, (
					    ftnlen)44);
#line 9888 ""
				    stop1_();
#line 9889 ""
				}
#line 9890 ""
/* L41: */
#line 9890 ""
			    }
#line 9891 ""
			    ++a1ll_2.iccount;
#line 9892 ""
			}
#line 9893 ""
		    }
#line 9894 ""
		    --a1ll_2.iccount;
#line 9895 ""
		    goto L8;
#line 9896 ""
		} else if (*(unsigned char *)dumq == 's') {

/* What follows should be one or two signed numbers for adjustment of line break */
/* slur, end of 1st segment or start of second. */

#line 9901 ""
		    if (comslur_1.fontslur) {
#line 9902 ""
			i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 9902 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__1, "May not use "\
				"linebreak slur options with font-based slurs!"
				, (ftnlen)128, (ftnlen)57);
#line 9904 ""
			stop1_();
#line 9905 ""
		    }
#line 9906 ""
		    g1etchar_(lineq, &a1ll_2.iccount, dumq, (ftnlen)128, (
			    ftnlen)1);
#line 9907 ""
		    if (i_indx("+-", dumq, (ftnlen)2, (ftnlen)1) == 0) {
#line 9908 ""
			i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 9908 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__1, "This charact"\
				"er must be \"+\" or \"-\"!", (ftnlen)128, (
				ftnlen)34);
#line 9910 ""
			stop1_();
#line 9911 ""
		    }
#line 9912 ""
		    ++a1ll_2.iccount;
#line 9913 ""
		    readnum_(lineq, &a1ll_2.iccount, dumq, &fnum, (ftnlen)128,
			     (ftnlen)1);
#line 9914 ""
		    if (i_nint(&fnum) > 30) {
#line 9915 ""
			i__1 = a1ll_2.iccount - 1;
#line 9915 ""
			i__4 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 9915 ""
			errmsg_(lineq, &i__1, &i__4, "Magnitude of slur heig"\
				"ht adjustment cannot exceed 30!", (ftnlen)128,
				 (ftnlen)53);
#line 9917 ""
			stop1_();
#line 9918 ""
		    }
#line 9919 ""
		    if (i_indx("+-", dumq, (ftnlen)2, (ftnlen)1) > 0) {
#line 9920 ""
			++a1ll_2.iccount;
#line 9921 ""
			readnum_(lineq, &a1ll_2.iccount, dumq, &fnum, (ftnlen)
				128, (ftnlen)1);
#line 9922 ""
			if (dabs(fnum) > 6.3f) {
#line 9923 ""
			    i__1 = a1ll_2.iccount - 1;
#line 9923 ""
			    i__4 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff 
				    + a1ll_2.nbars + 1;
#line 9923 ""
			    errmsg_(lineq, &i__1, &i__4, "Slur horiz shift m"\
				    "ust be in range (-6.3,6.3)!", (ftnlen)128,
				     (ftnlen)45);
#line 9925 ""
			    stop1_();
#line 9926 ""
			}
#line 9927 ""
		    }
#line 9928 ""
		    --a1ll_2.iccount;
#line 9929 ""
		    goto L8;
#line 9930 ""
		} else if (*(unsigned char *)dumq == 'H' && iposn > 1) {
#line 9931 ""
		    i__1 = a1ll_2.iccount;
#line 9931 ""
		    if (s_cmp(lineq + i__1, "H", a1ll_2.iccount + 1 - i__1, (
			    ftnlen)1) == 0) {
#line 9931 ""
			++a1ll_2.iccount;
#line 9931 ""
		    }
#line 9932 ""
		    goto L8;
#line 9933 ""
		}
#line 9934 ""
	    } else if (*(unsigned char *)charq == '?') {
#line 9935 ""
		getchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)128, (ftnlen)1)
			;
#line 9936 ""
		if (*(unsigned char *)durq == ' ') {
#line 9937 ""
		    --a1ll_2.iccount;
#line 9938 ""
		} else {
#line 9939 ""
		    if (*(unsigned char *)durq != '-') {
#line 9940 ""
			i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 9940 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__1, "Expecting"\
				" \"-\"!", (ftnlen)128, (ftnlen)14);
#line 9942 ""
			stop1_();
#line 9943 ""
		    }
#line 9944 ""
		    getchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)128, (
			    ftnlen)1);
#line 9945 ""
		    if (i_indx("0123456789.", durq, (ftnlen)11, (ftnlen)1) == 
			    0) {
#line 9946 ""
			i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 9946 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__1, "Expecting nu"\
				"mber!", (ftnlen)128, (ftnlen)17);
#line 9948 ""
			stop1_();
#line 9949 ""
		    }
#line 9950 ""
		    readnum_(lineq, &a1ll_2.iccount, durq, &fnum, (ftnlen)128,
			     (ftnlen)1);
#line 9951 ""
		    --a1ll_2.iccount;
#line 9952 ""
		}
#line 9953 ""
	    } else if (*(unsigned char *)charq >= 48 && *(unsigned char *)
		    charq <= 57 || i_indx("#-nx_", charq, (ftnlen)5, (ftnlen)
		    1) > 0) {

/*  We have a figure.  Must come AFTER the note it goes under */

#line 9958 ""
		if (a1ll_2.itsofar[c1ommvl_1.ivx - 1] == 0 && (! 
			a1ll_2.firstline || a1ll_2.lenbr0 == 0 || 
			a1ll_2.lenbar == a1ll_2.lenbr0)) {

/*  Figure before first note in block */

#line 9963 ""
		    i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			    a1ll_2.nbars + 1;
#line 9963 ""
		    errmsg_(lineq, &a1ll_2.iccount, &i__1, "Cannot put figur"\
			    "e before first note in block!", (ftnlen)128, (
			    ftnlen)45);
#line 9965 ""
		    stop1_();
#line 9966 ""
		}
#line 9967 ""
		if (*(unsigned char *)charq == 'x') {
#line 9968 ""
		    indxb = i_indx(lineq + (a1ll_2.iccount - 1), " ", 128 - (
			    a1ll_2.iccount - 1), (ftnlen)1);
#line 9969 ""
		    if (indxb < 5) {
#line 9970 ""
			i__1 = a1ll_2.iccount + indxb - 1;
#line 9970 ""
			i__4 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 9970 ""
			errmsg_(lineq, &i__1, &i__4, "Cannot have a blank he"\
				"re in floating figure!", (ftnlen)128, (ftnlen)
				44);
#line 9972 ""
			stop1_();
#line 9973 ""
		    }
#line 9974 ""
		}
#line 9975 ""
		if (compage_1.usefig) {
#line 9975 ""
		    *ifig = 1;
#line 9975 ""
		}
#line 9976 ""
L5:
#line 9976 ""
		g1etchar_(lineq, &a1ll_2.iccount, charq, (ftnlen)128, (ftnlen)
			1);
#line 9977 ""
		if (i_indx(" 0123456789#-nx_.:+sv", charq, (ftnlen)21, (
			ftnlen)1) == 0) {
#line 9978 ""
		    i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			    a1ll_2.nbars + 1;
#line 9978 ""
		    errmsg_(lineq, &a1ll_2.iccount, &i__1, "Illegal characte"\
			    "r in figure!", (ftnlen)128, (ftnlen)28);
#line 9980 ""
		    stop1_();
#line 9981 ""
		} else if (*(unsigned char *)charq == '+') {

/* vertical offset, must be integer, then blank */

#line 9985 ""
		    g1etchar_(lineq, &a1ll_2.iccount, charq, (ftnlen)128, (
			    ftnlen)1);
#line 9986 ""
		    if (i_indx("123456789", charq, (ftnlen)9, (ftnlen)1) == 0)
			     {
#line 9987 ""
			i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 9987 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__1, "Integer for "\
				"vertical offset expected here!", (ftnlen)128, 
				(ftnlen)42);
#line 9989 ""
			stop1_();
#line 9990 ""
		    }
#line 9991 ""
		    readnum_(lineq, &a1ll_2.iccount, charq, &fnum, (ftnlen)
			    128, (ftnlen)1);
#line 9992 ""
		    if (*(unsigned char *)charq != ' ') {
#line 9993 ""
			i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 9993 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__1, "Vertical off"\
				"set must terminate figure!", (ftnlen)128, (
				ftnlen)38);
#line 9995 ""
			stop1_();
#line 9996 ""
		    }
#line 9997 ""
		    --a1ll_2.iccount;
#line 9998 ""
		    goto L5;
#line 9999 ""
		} else if (*(unsigned char *)charq == 's') {
#line 10000 ""
		    comligfont_1.isligfont = TRUE_;
#line 10001 ""
		}
#line 10002 ""
		if (*(unsigned char *)charq != ' ') {
#line 10002 ""
		    goto L5;
#line 10002 ""
		}
#line 10003 ""
	    } else if (*(unsigned char *)charq == '[') {
#line 10004 ""
		if (c1omget_1.fbon) {
#line 10005 ""
		    i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			    a1ll_2.nbars + 1;
#line 10005 ""
		    errmsg_(lineq, &a1ll_2.iccount, &i__1, "Started forced b"\
			    "eam while another was open!", (ftnlen)128, (
			    ftnlen)43);
#line 10007 ""
		    stop1_();
#line 10008 ""
		}
#line 10009 ""
		c1omget_1.fbon = TRUE_;
#line 10010 ""
L17:
#line 10010 ""
		g1etchar_(lineq, &a1ll_2.iccount, charq, (ftnlen)128, (ftnlen)
			1);
#line 10011 ""
		if (i_indx("uljhf:", charq, (ftnlen)6, (ftnlen)1) > 0) {
#line 10012 ""
		    goto L17;
#line 10013 ""
		} else if (i_indx("+-", charq, (ftnlen)2, (ftnlen)1) > 0) {
#line 10014 ""
		    ++a1ll_2.iccount;
#line 10015 ""
		    readnum_(lineq, &a1ll_2.iccount, durq, &fnum, (ftnlen)128,
			     (ftnlen)1);
#line 10016 ""
		    --a1ll_2.iccount;
#line 10017 ""
		    goto L17;
#line 10018 ""
		} else if (*(unsigned char *)charq == 'm') {

/*  Forced multiplicity, next char should be 1-4 */

#line 10022 ""
		    g1etchar_(lineq, &a1ll_2.iccount, charq, (ftnlen)128, (
			    ftnlen)1);
#line 10023 ""
		    if (i_indx("1234", charq, (ftnlen)4, (ftnlen)1) == 0) {
#line 10024 ""
			i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 10024 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__1, "Forced multi"\
				"plicity for a beam must be 1, 2, 3, or 4!", (
				ftnlen)128, (ftnlen)53);
#line 10026 ""
			stop1_();
#line 10027 ""
		    }
#line 10028 ""
		    goto L17;
#line 10029 ""
		} else if (*(unsigned char *)charq != ' ') {
#line 10030 ""
		    if (i_indx("0123456789", charq, (ftnlen)10, (ftnlen)1) > 
			    0) {
#line 10031 ""
			i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 10031 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__1, "After \"[\","\
				" digits must now be preceeded by \"+\" or \"-"\
				"\"!", (ftnlen)128, (ftnlen)54);
#line 10033 ""
			s_wsle(&io___662);
#line 10033 ""
			do_lio(&c__9, &c__1, "You will have to edit older so"\
				"urces to meet this rqmt,", (ftnlen)54);
#line 10033 ""
			e_wsle();
#line 10034 ""
			s_wsle(&io___663);
#line 10034 ""
			do_lio(&c__9, &c__1, "but it was needed to allow 2-d"\
				"igit height adjustments.", (ftnlen)54);
#line 10034 ""
			e_wsle();
#line 10035 ""
			s_wsle(&io___664);
#line 10035 ""
			do_lio(&c__9, &c__1, "Sorry for the inconvenience.  "\
				"--The Management", (ftnlen)46);
#line 10035 ""
			e_wsle();
#line 10036 ""
		    } else {
#line 10037 ""
			i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 10037 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__1, "Illegal char"\
				"acter after [!", (ftnlen)128, (ftnlen)26);
#line 10039 ""
		    }
#line 10040 ""
		    stop1_();
#line 10041 ""
		}
#line 10042 ""
	    } else if (*(unsigned char *)charq == ']') {
#line 10043 ""
		if (! c1omget_1.fbon) {
#line 10044 ""
		    i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			    a1ll_2.nbars + 1;
#line 10044 ""
		    errmsg_(lineq, &a1ll_2.iccount, &i__1, "Forced beam stop"\
			    " with no corresponding start!", (ftnlen)128, (
			    ftnlen)45);
#line 10046 ""
		    stop1_();
#line 10047 ""
		}
#line 10048 ""
		g1etchar_(lineq, &a1ll_2.iccount, charq, (ftnlen)128, (ftnlen)
			1);
#line 10049 ""
		if (*(unsigned char *)charq == '-') {
#line 10050 ""
		    i__1 = a1ll_2.iccount;
#line 10050 ""
		    if (s_cmp(lineq + i__1, "[ ", a1ll_2.iccount + 2 - i__1, (
			    ftnlen)2) != 0) {
#line 10051 ""
			i__1 = a1ll_2.iccount + 1;
#line 10051 ""
			i__4 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 10051 ""
			errmsg_(lineq, &i__1, &i__4, "Only sequence allowed "\
				"here is \"[ \"!", (ftnlen)128, (ftnlen)35);
#line 10053 ""
			stop1_();
#line 10054 ""
		    } else {
#line 10055 ""
			a1ll_2.iccount += 2;
#line 10056 ""
		    }
#line 10057 ""
		} else if (*(unsigned char *)charq == '[') {
#line 10058 ""
		    i__1 = a1ll_2.iccount;
#line 10058 ""
		    if (s_cmp(lineq + i__1, " ", a1ll_2.iccount + 1 - i__1, (
			    ftnlen)1) != 0) {
#line 10059 ""
			i__1 = a1ll_2.iccount + 1;
#line 10059 ""
			i__4 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 10059 ""
			errmsg_(lineq, &i__1, &i__4, "This character must be"\
				" a blank!", (ftnlen)128, (ftnlen)31);
#line 10061 ""
			stop1_();
#line 10062 ""
		    }
#line 10063 ""
		} else {

/*  Forced beam is really ending */

#line 10067 ""
		    c1omget_1.fbon = FALSE_;
#line 10068 ""
		    if (*(unsigned char *)charq == 'j') {
#line 10069 ""
			i__1 = a1ll_2.iccount;
#line 10069 ""
			if (s_cmp(lineq + i__1, " ", a1ll_2.iccount + 1 - 
				i__1, (ftnlen)1) != 0) {
#line 10070 ""
			    i__1 = a1ll_2.iccount + 1;
#line 10070 ""
			    i__4 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff 
				    + a1ll_2.nbars + 1;
#line 10070 ""
			    errmsg_(lineq, &i__1, &i__4, "This character mus"\
				    "t be a blank!", (ftnlen)128, (ftnlen)31);
#line 10072 ""
			    stop1_();
#line 10073 ""
			}
#line 10074 ""
		    } else if (*(unsigned char *)charq != ' ') {
#line 10075 ""
			i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 10075 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__1, "\"]\" must b"\
				"e followed by blank, \"j\", \"-\", or \"[\"!",
				 (ftnlen)128, (ftnlen)48);
#line 10077 ""
			stop1_();
#line 10078 ""
		    }
#line 10079 ""
		}
#line 10080 ""
	    } else if (*(unsigned char *)charq == 'D') {

/*  Dynamic mark */

#line 10084 ""
		if (a1ll_2.nnl[c1ommvl_1.ivx - 1] == 0) {
#line 10085 ""
		    i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			    a1ll_2.nbars + 1;
#line 10085 ""
		    errmsg_(lineq, &a1ll_2.iccount, &i__1, "\"D\" must not c"\
			    "ome before any notes have been entered!", (ftnlen)
			    128, (ftnlen)53);
#line 10087 ""
		    stop1_();
#line 10088 ""
		}
#line 10089 ""
		i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			a1ll_2.nbars + 1;
#line 10089 ""
		checkdyn_(lineq, &a1ll_2.iccount, &i__1, (ftnlen)128);
#line 10090 ""
	    } else if (i_indx("lhw", charq, (ftnlen)3, (ftnlen)1) > 0) {

/*  Save position for later check */

#line 10094 ""
		icclhw = a1ll_2.iccount;
#line 10095 ""
		g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)128, (ftnlen)
			1);
#line 10096 ""
		if (i_indx("0123456789.+- ", durq, (ftnlen)14, (ftnlen)1) == 
			0) {
#line 10097 ""
		    i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			    a1ll_2.nbars + 1;
#line 10097 ""
		    errmsg_(lineq, &a1ll_2.iccount, &i__1, "Illegal characte"\
			    "r after \"l\", \"w\", or \"h\"!", (ftnlen)128, (
			    ftnlen)41);
#line 10099 ""
		    stop1_();
#line 10100 ""
		}
#line 10101 ""
		c1omget_1.isheadr = c1omget_1.isheadr || *(unsigned char *)
			charq == 'h';
#line 10102 ""
		if (i_indx(" +-", durq, (ftnlen)3, (ftnlen)1) > 0) {

/*  There is a header (or lower string?) */

#line 10106 ""
		    if (i_indx("+-", durq, (ftnlen)2, (ftnlen)1) > 0) {

/*  User-defined vert offset (\internote). */

#line 10110 ""
			if (*(unsigned char *)charq != 'h') {
#line 10111 ""
			    i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff 
				    + a1ll_2.nbars + 1;
#line 10111 ""
			    errmsg_(lineq, &a1ll_2.iccount, &i__1, "\"+\" "\
				    "or \"-\" not permitted here!", (ftnlen)
				    128, (ftnlen)30);
#line 10113 ""
			    stop1_();
#line 10114 ""
			}

/*  Have "h" followed by +/- .  Check for digit. */
/*     Can blow durq since not using fnum for now, but... */

#line 10119 ""
			g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)128, (
				ftnlen)1);
#line 10120 ""
			if (i_indx("123456789", durq, (ftnlen)9, (ftnlen)1) ==
				 0) {
#line 10121 ""
			    i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff 
				    + a1ll_2.nbars + 1;
#line 10121 ""
			    errmsg_(lineq, &a1ll_2.iccount, &i__1, "There mu"\
				    "st be a digit here!", (ftnlen)128, (
				    ftnlen)27);
#line 10123 ""
			    stop1_();
#line 10124 ""
			}

/*  Have "h" followed by +/- followed by a digit.  No need to get the number. */

/*           call readnum(lineq,iccount,durq,fnum) */
#line 10129 ""
		    }
#line 10130 ""
		    if (*(unsigned char *)charq != 'w') {

/*  Header or lower string. */

#line 10134 ""
			if (icclhw != 1) {
#line 10135 ""
			    i__1 = a1ll_2.iccount - 1;
#line 10135 ""
			    i__4 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff 
				    + a1ll_2.nbars + 1;
#line 10135 ""
			    errmsg_(lineq, &i__1, &i__4, "\"h\" or \"l\" mus"\
				    "t be first character in line!", (ftnlen)
				    128, (ftnlen)43);
#line 10137 ""
			    stop1_();
#line 10138 ""
			}

/*  Read past the next line, which has the string. */

#line 10142 ""
			read10_(charq, &c1omget_1.lastchar, (ftnlen)1);
#line 10143 ""
			++c1omget_1.nline;
#line 10144 ""
			a1ll_2.iccount = 128;
#line 10145 ""
		    } else {
#line 10146 ""
			i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 10146 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__1, "Symbol \"w\""\
				" (width) must be followed by a digit!", (
				ftnlen)128, (ftnlen)47);
#line 10148 ""
			stop1_();
#line 10149 ""
		    }
#line 10150 ""
		} else {

/*  Height or width change spec.  Check if at start of piece. */

#line 10154 ""
		    if (c1omnotes_1.ibarcnt > 0) {
#line 10155 ""
			i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 10155 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__1, "Symbol must "\
				"go at top of first input block!", (ftnlen)128,
				 (ftnlen)43);
#line 10157 ""
			stop1_();
#line 10158 ""
		    }
#line 10159 ""
		    readnum_(lineq, &a1ll_2.iccount, durq, &dimen, (ftnlen)
			    128, (ftnlen)1);

/*  Check units.  Convert to points */

#line 10163 ""
		    if (*(unsigned char *)durq == ' ' || *(unsigned char *)
			    durq == 'p') {
#line 10164 ""
			dimen += .5f;
#line 10165 ""
		    } else if (*(unsigned char *)durq == 'i') {
#line 10166 ""
			dimen = dimen * 72 + .5f;
#line 10167 ""
		    } else if (*(unsigned char *)durq == 'm') {
#line 10168 ""
			dimen = dimen / 25.4f * 72 + .5f;
#line 10169 ""
		    } else {
#line 10170 ""
			i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 10170 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__1, "Illegal unit"\
				"; must be \"p\",\"i\",or\"m\"!", (ftnlen)128, 
				(ftnlen)36);
#line 10172 ""
			stop1_();
#line 10173 ""
		    }

/* 151211 fix. May have extra character. */

#line 10177 ""
		    if (i_indx("pim", durq, (ftnlen)3, (ftnlen)1) > 0) {

/* Get another character, see if it's blank */

#line 10181 ""
			i__1 = a1ll_2.iccount;
#line 10181 ""
			if (s_cmp(lineq + i__1, " ", a1ll_2.iccount + 1 - 
				i__1, (ftnlen)1) != 0) {
#line 10182 ""
			    i__1 = a1ll_2.iccount + 1;
#line 10182 ""
			    i__4 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff 
				    + a1ll_2.nbars + 1;
#line 10182 ""
			    errmsg_(lineq, &i__1, &i__4, "This character sho"\
				    "uld be a blank!", (ftnlen)128, (ftnlen)33)
				    ;
#line 10184 ""
			    stop1_();
#line 10185 ""
			}
#line 10186 ""
		    }
#line 10187 ""
		    if (*(unsigned char *)charq == 'h') {
#line 10188 ""
			compage_1.ptheight = (real) ((integer) dimen);
#line 10189 ""
		    } else {
#line 10190 ""
			compage_1.widthpt = (real) ((integer) dimen);
#line 10191 ""
		    }
#line 10192 ""
		}
#line 10193 ""
	    } else if (*(unsigned char *)charq == 'm') {

/*  Time signature change.  Only allow at beginning of block. */
/*    mtrnuml, mtrdenl (logical) and p (printable) will be input. */
/*    mtrnuml=0 initially. (In common) */

/*  Check whether at beginning of a block */

#line 10201 ""
		if (c1ommvl_1.ivx != 1 || a1ll_2.nnl[0] != 0) {
#line 10202 ""
		    i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			    a1ll_2.nbars + 1;
#line 10202 ""
		    errmsg_(lineq, &a1ll_2.iccount, &i__1, "Meter change onl"\
			    "y OK in voice 1, at start of block!", (ftnlen)128,
			     (ftnlen)51);
#line 10204 ""
		    s_wsle(&io___667);
#line 10204 ""
		    do_lio(&c__9, &c__1, "voice number is", (ftnlen)15);
#line 10204 ""
		    do_lio(&c__3, &c__1, (char *)&c1ommvl_1.ivx, (ftnlen)
			    sizeof(integer));
#line 10204 ""
		    e_wsle();
#line 10205 ""
		    stop1_();
#line 10206 ""
		}
#line 10207 ""
		a1ll_2.newmeter = TRUE_;
#line 10208 ""
		i__1 = a1ll_2.iccount;
#line 10208 ""
		if (i_indx("o0123456789", lineq + i__1, (ftnlen)11, 
			a1ll_2.iccount + 1 - i__1) == 0) {
#line 10209 ""
		    i__1 = a1ll_2.iccount + 1;
#line 10209 ""
		    i__4 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			    a1ll_2.nbars + 1;
#line 10209 ""
		    errmsg_(lineq, &i__1, &i__4, "Illegal character in \"m\""\
			    " command for meter change!", (ftnlen)128, (ftnlen)
			    50);
#line 10211 ""
		    stop1_();
#line 10212 ""
		}
#line 10213 ""
		readmeter_(lineq, &a1ll_2.iccount, &a1ll_2.mtrnuml, &mtrdenl, 
			(ftnlen)128);
#line 10214 ""
		if (a1ll_2.mtrnuml == 0) {
#line 10215 ""
		    i__1 = a1ll_2.iccount - 1;
#line 10215 ""
		    i__4 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			    a1ll_2.nbars + 1;
#line 10215 ""
		    errmsg_(lineq, &i__1, &i__4, "Digit 0 not allowed here!", 
			    (ftnlen)128, (ftnlen)25);
#line 10217 ""
		    stop1_();
#line 10218 ""
		}
#line 10219 ""
		readmeter_(lineq, &a1ll_2.iccount, &mtrnmp, &mtrdnp, (ftnlen)
			128);

/*  Read past printed time signature; not used in pmxa. */

#line 10223 ""
		lenbeat = i1fnodur_(&mtrdenl, "x", (ftnlen)1);
#line 10224 ""
		lenmult = 1;
#line 10225 ""
		if (mtrdenl == 2) {
#line 10226 ""
		    lenbeat = 16;
#line 10227 ""
		    lenmult = 2;
#line 10228 ""
		}
#line 10229 ""
		a1ll_2.lenbar = lenmult * a1ll_2.mtrnuml * lenbeat;
#line 10230 ""
		a1ll_2.mtrnuml = 0;
#line 10231 ""
	    } else if (*(unsigned char *)charq == 'C') {
#line 10232 ""
		g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)128, (ftnlen)
			1);
#line 10233 ""
		if (! (i_indx("tsmanrbf", durq, (ftnlen)8, (ftnlen)1) > 0 || *
			(unsigned char *)durq >= 48 && *(unsigned char *)durq 
			<= 56)) {
#line 10235 ""
		    i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			    a1ll_2.nbars + 1;
#line 10235 ""
		    errmsg_(lineq, &a1ll_2.iccount, &i__1, "Must have t,s,m,"\
			    "a,n,r,b,f or 0-8 after C!", (ftnlen)128, (ftnlen)
			    41);
#line 10237 ""
		    stop1_();
#line 10238 ""
		}
#line 10239 ""
	    } else if (*(unsigned char *)charq == 'R') {
#line 10240 ""
		if (c1ommvl_1.ivx != 1) {
#line 10241 ""
		    i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			    a1ll_2.nbars + 1;
#line 10241 ""
		    errmsg_(lineq, &a1ll_2.iccount, &i__1, "Repeats can only"\
			    " go in voice 1!", (ftnlen)128, (ftnlen)31);
#line 10243 ""
		    stop1_();
#line 10244 ""
		}
#line 10245 ""
		g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)128, (ftnlen)
			1);
#line 10246 ""
		g1etchar_(lineq, &a1ll_2.iccount, dumq, (ftnlen)128, (ftnlen)
			1);
/* Writing concatenation */
#line 10247 ""
		i__3[0] = 1, a__2[0] = durq;
#line 10247 ""
		i__3[1] = 1, a__2[1] = dumq;
#line 10247 ""
		s_cat(ch__3, a__2, i__3, &c__2, (ftnlen)2);
#line 10247 ""
		if (i_indx("l Xr Xd XD Xb Xz XlrXdlX", ch__3, (ftnlen)24, (
			ftnlen)2) == 0) {
#line 10248 ""
		    i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			    a1ll_2.nbars + 1;
#line 10248 ""
		    errmsg_(lineq, &a1ll_2.iccount, &i__1, "Illegal characte"\
			    "r after \"R*\" (repeat/double bar)!", (ftnlen)128,
			     (ftnlen)49);
#line 10250 ""
		    stop1_();
#line 10251 ""
		}
#line 10252 ""
		if (*(unsigned char *)dumq != ' ') {
#line 10253 ""
		    g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)128, (
			    ftnlen)1);
#line 10254 ""
		    if (*(unsigned char *)durq != ' ') {
#line 10255 ""
			i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 10255 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__1, "Must have bl"\
				"ank after \"R**\" (repeat/double bar)!", (
				ftnlen)128, (ftnlen)48);
#line 10257 ""
			stop1_();
#line 10258 ""
		    }
#line 10259 ""
		}
#line 10260 ""
	    } else if (*(unsigned char *)charq == 'V') {

/*  Ending */

#line 10264 ""
		if (a1ll_2.iv != 1) {
#line 10265 ""
		    i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			    a1ll_2.nbars + 1;
#line 10265 ""
		    errmsg_(lineq, &a1ll_2.iccount, &i__1, "Voltas are only "\
			    "allowed in voice #1!", (ftnlen)128, (ftnlen)36);
#line 10267 ""
		    stop1_();
#line 10268 ""
		} else if (c1omget_1.isvolt) {
#line 10269 ""
		    s_wsle(&io___673);
#line 10269 ""
		    e_wsle();
#line 10270 ""
		    s_wsle(&io___674);
#line 10270 ""
		    do_lio(&c__9, &c__1, "*******WARNING********", (ftnlen)22)
			    ;
#line 10270 ""
		    e_wsle();
#line 10271 ""
		    s_wsfe(&io___675);
#line 10271 ""
		    do_fio(&c__1, "*******WARNING********", (ftnlen)22);
#line 10271 ""
		    e_wsfe();
#line 10272 ""
		    i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			    a1ll_2.nbars + 1;
#line 10272 ""
		    errmsg_(lineq, &a1ll_2.iccount, &i__1, "There is more th"\
			    "an one volta in this input block.!", (ftnlen)128, 
			    (ftnlen)50);
#line 10274 ""
		    s_wsle(&io___676);
#line 10274 ""
		    do_lio(&c__9, &c__1, "This may work in a score, but WILL"\
			    " NOT work in parts.", (ftnlen)53);
#line 10274 ""
		    e_wsle();
#line 10275 ""
		    s_wsle(&io___677);
#line 10275 ""
		    do_lio(&c__9, &c__1, "Safest to have only 1 volta per bl"\
			    "ock, at the start of the block", (ftnlen)64);
#line 10275 ""
		    e_wsle();
#line 10277 ""
		    s_wsfe(&io___678);
#line 10277 ""
		    do_fio(&c__1, "This may work in a score, but WILL NOT wo"\
			    "rk in parts.", (ftnlen)53);
#line 10277 ""
		    e_wsfe();
#line 10279 ""
		    s_wsfe(&io___679);
#line 10279 ""
		    do_fio(&c__1, "Safest to have only 1 volta per block, at"\
			    " the start of the block", (ftnlen)64);
#line 10279 ""
		    e_wsfe();
#line 10281 ""
		}
#line 10282 ""
		c1omget_1.isvolt = TRUE_;
#line 10283 ""
		lvoltxt = 0;
#line 10284 ""
L11:
#line 10284 ""
		g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)128, (ftnlen)
			1);
#line 10285 ""
		if (*(unsigned char *)durq != ' ') {
#line 10286 ""
		    goto L11;
#line 10287 ""
		}
#line 10288 ""
	    } else if (*(unsigned char *)charq == 'B') {
#line 10290 ""
	    } else if (*(unsigned char *)charq == 'P') {
#line 10291 ""
		if (c1ommvl_1.ivx != 1 || a1ll_2.nnl[0] != 0) {
#line 10292 ""
		    i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			    a1ll_2.nbars + 1;
#line 10292 ""
		    errmsg_(lineq, &a1ll_2.iccount, &i__1, "Only allowed at "\
			    "beginning of block!", (ftnlen)128, (ftnlen)35);
#line 10294 ""
		    stop1_();
#line 10295 ""
		}
#line 10296 ""
L16:
#line 10296 ""
		g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)128, (ftnlen)
			1);
#line 10297 ""
		if (*(unsigned char *)durq == 'l' || *(unsigned char *)durq ==
			 'r' || *(unsigned char *)durq >= 48 && *(unsigned 
			char *)durq <= 57) {
#line 10297 ""
		    goto L16;
#line 10297 ""
		}
#line 10299 ""
		if (*(unsigned char *)durq == 'c') {

/*  Expect a centered name, and it has to be last option */

#line 10303 ""
		    g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)128, (
			    ftnlen)1);
#line 10304 ""
		    chax_(ch__2, (ftnlen)1, &c__34);
#line 10304 ""
		    if (*(unsigned char *)durq == *(unsigned char *)&ch__2[0])
			     {

/*  Quoted name, go to next quote mark */

#line 10308 ""
			for (++a1ll_2.iccount; a1ll_2.iccount <= 127; 
				++a1ll_2.iccount) {
#line 10309 ""
			    i__1 = a1ll_2.iccount - 2;
#line 10309 ""
			    chax_(ch__2, (ftnlen)1, &c__34);
#line 10309 ""
			    chax_(ch__4, (ftnlen)1, &c__92);
#line 10309 ""
			    if (*(unsigned char *)&lineq[a1ll_2.iccount - 1] 
				    == *(unsigned char *)&ch__2[0] && s_cmp(
				    lineq + i__1, ch__4, a1ll_2.iccount - 1 - 
				    i__1, (ftnlen)1) != 0) {
#line 10309 ""
				goto L36;
#line 10309 ""
			    }
#line 10311 ""
/* L35: */
#line 10311 ""
			}
#line 10312 ""
			i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 10312 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__1, "Missing clos"\
				"e quote after page number command (P)!", (
				ftnlen)128, (ftnlen)50);
#line 10314 ""
			stop1_();
#line 10315 ""
L36:
#line 10316 ""
			;
#line 10316 ""
		    } else if (*(unsigned char *)durq != ' ') {

/*  Space-delimited name, look for next blank */

#line 10320 ""
			for (++a1ll_2.iccount; a1ll_2.iccount <= 127; 
				++a1ll_2.iccount) {
#line 10321 ""
			    if (*(unsigned char *)&lineq[a1ll_2.iccount - 1] 
				    == ' ') {
#line 10321 ""
				goto L38;
#line 10321 ""
			    }
#line 10322 ""
/* L37: */
#line 10322 ""
			}
#line 10323 ""
L38:
#line 10324 ""
			;
#line 10324 ""
		    }
#line 10325 ""
		} else if (*(unsigned char *)durq != ' ') {
#line 10326 ""
		    i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			    a1ll_2.nbars + 1;
#line 10326 ""
		    errmsg_(lineq, &a1ll_2.iccount, &i__1, "Only \"l\",\""\
			    "r\",\"c\" or digit allowed after \"P\"!", (ftnlen)
			    128, (ftnlen)44);
#line 10328 ""
		    stop1_();
#line 10329 ""
		}
#line 10330 ""
	    } else if (*(unsigned char *)charq == 'W') {
#line 10331 ""
		g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)128, (ftnlen)
			1);
#line 10332 ""
		if (i_indx(".0123456789", durq, (ftnlen)11, (ftnlen)1) == 0) {
#line 10333 ""
		    i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			    a1ll_2.nbars + 1;
#line 10333 ""
		    errmsg_(lineq, &a1ll_2.iccount, &i__1, "Expected a numbe"\
			    "r to start here!", (ftnlen)128, (ftnlen)32);
#line 10335 ""
		    stop1_();
#line 10336 ""
		}
#line 10337 ""
		readnum_(lineq, &a1ll_2.iccount, durq, &c1omnotes_1.wminnh[
			c1omnotes_1.ibarcnt + a1ll_2.nbars], (ftnlen)128, (
			ftnlen)1);
#line 10338 ""
	    } else if (*(unsigned char *)charq == 'T') {

/*  Titles */

#line 10342 ""
		g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)128, (ftnlen)
			1);
#line 10343 ""
		if (i_indx("itc", durq, (ftnlen)3, (ftnlen)1) == 0) {
#line 10344 ""
		    i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			    a1ll_2.nbars + 1;
#line 10344 ""
		    errmsg_(lineq, &a1ll_2.iccount, &i__1, "Must put \"i\","\
			    " \"t\", or \"c\" after \"T\"!", (ftnlen)128, (
			    ftnlen)36);
#line 10346 ""
		    stop1_();
#line 10347 ""
		}
#line 10348 ""
		i__1 = i_indx("itc", durq, (ftnlen)3, (ftnlen)1) - 1;
#line 10348 ""
		c1omget_1.ihead += pow_ii(&c__2, &i__1);

/*  Maybe a number after 'Tt', but ignore here.  Read past string on next line. */

#line 10352 ""
		read10_(charq, &c1omget_1.lastchar, (ftnlen)1);
#line 10353 ""
		++c1omget_1.nline;
#line 10354 ""
		a1ll_2.iccount = 128;
#line 10355 ""
	    } else if (*(unsigned char *)charq == 'A') {
#line 10356 ""
L27:
#line 10356 ""
		g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)128, (ftnlen)
			1);
#line 10357 ""
		if (i_indx("rbsdK", durq, (ftnlen)5, (ftnlen)1) > 0) {
#line 10358 ""
		    goto L27;
#line 10359 ""
		} else if (*(unsigned char *)durq == 'e') {

/* Check for is4bignv. Must do here to catch first \internote, written in topfile */
/*   before ever calling getnote. Initialize as .false. in pmxa. Make it true only */
/*   if nv>7, AI not set, Ai not set. */

#line 10365 ""
		    comis4bignv_1.is4bignv = a1ll_2.nv > 7 && ! 
			    comis4bignv_1.aiset;
#line 10366 ""
		    goto L27;
#line 10367 ""
		} else if (*(unsigned char *)durq == 'v') {
#line 10368 ""
		    if (c1omnotes_1.ibarcnt == 0) {
#line 10368 ""
			comnvst_1.novshrinktop = TRUE_;
#line 10368 ""
		    }
#line 10369 ""
		    goto L27;
#line 10370 ""
		} else if (*(unsigned char *)durq == 'a') {
#line 10371 ""
		    g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)128, (
			    ftnlen)1);
#line 10372 ""
		    if (i_indx("0123456789.", durq, (ftnlen)11, (ftnlen)1) == 
			    0) {
#line 10373 ""
			i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 10373 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__1, "After \"Aa\""\
				", need decimal number!", (ftnlen)128, (ftnlen)
				32);
#line 10375 ""
			stop1_();
#line 10376 ""
		    }
#line 10377 ""
		    readnum_(lineq, &a1ll_2.iccount, durq, &c1ommvl_1.fbar, (
			    ftnlen)128, (ftnlen)1);
#line 10378 ""
		    --a1ll_2.iccount;
#line 10379 ""
		    goto L27;
#line 10380 ""
		} else if (*(unsigned char *)durq == 'i') {
#line 10381 ""
		    comis4bignv_1.is4bignv = FALSE_;
#line 10382 ""
		    comis4bignv_1.aiset = TRUE_;
#line 10383 ""
		    g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)128, (
			    ftnlen)1);

/*  Local interstaff correction.  Set to -1. if not specifiec, or after use, */
/*  or anytime except at top, since pmxb handles all times except at top. */

#line 10388 ""
		    readnum_(lineq, &a1ll_2.iccount, durq, &tintstf, (ftnlen)
			    128, (ftnlen)1);
#line 10389 ""
		    if (c1omnotes_1.ibarcnt == 0) {
#line 10389 ""
			compage_1.fintstf = tintstf;
#line 10389 ""
		    }
#line 10390 ""
		    --a1ll_2.iccount;
#line 10391 ""
		    goto L27;
#line 10392 ""
		} else if (*(unsigned char *)durq == 'I') {

/*  Global interstaff correction.  Use in place of fintstf if fintstf<0 */

#line 10396 ""
		    comis4bignv_1.is4bignv = FALSE_;
#line 10397 ""
		    comis4bignv_1.aiset = TRUE_;
#line 10398 ""
		    g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)128, (
			    ftnlen)1);
#line 10399 ""
		    readnum_(lineq, &a1ll_2.iccount, durq, &compage_1.gintstf,
			     (ftnlen)128, (ftnlen)1);
#line 10400 ""
		    --a1ll_2.iccount;
#line 10401 ""
		    goto L27;
#line 10402 ""
		} else if (*(unsigned char *)durq == 'o') {
#line 10403 ""
		    *optimize = TRUE_;
#line 10404 ""
		    goto L27;
#line 10405 ""
		} else if (*(unsigned char *)durq == 'S') {
#line 10406 ""
		    i__1 = comkeys_1.noinst;
#line 10406 ""
		    for (iiv = 1; iiv <= i__1; ++iiv) {
#line 10407 ""
			g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)128, (
				ftnlen)1);
#line 10408 ""
			if (i_indx("-0st", durq, (ftnlen)4, (ftnlen)1) == 0) {
#line 10409 ""
			    i__4 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff 
				    + a1ll_2.nbars + 1;
#line 10409 ""
			    errmsg_(lineq, &a1ll_2.iccount, &i__4, "After \""\
				    "AS\", need nv instances of \"s,t,-,0\"!", 
				    (ftnlen)128, (ftnlen)43);
#line 10411 ""
			    stop1_();
#line 10412 ""
			}
#line 10413 ""
			if (*(unsigned char *)durq == '-' || *(unsigned char *
				)durq == 's') {
#line 10414 ""
			    comsize_1.isize[iiv - 1] = 1;
#line 10415 ""
			} else if (*(unsigned char *)durq == 't') {
#line 10416 ""
			    comsize_1.isize[iiv - 1] = 2;
#line 10417 ""
			}
#line 10418 ""
/* L50: */
#line 10418 ""
		    }
#line 10419 ""
		    goto L27;
#line 10420 ""
		} else if (*(unsigned char *)durq == 'p') {
#line 10421 ""
		    comslur_1.fontslur = FALSE_;
#line 10422 ""
L42:
#line 10423 ""
		    g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)128, (
			    ftnlen)1);
#line 10424 ""
		    if (i_indx("+-", durq, (ftnlen)2, (ftnlen)1) > 0) {

/*  Characters to change defaults for ps slurs */

#line 10428 ""
			g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)128, (
				ftnlen)1);
#line 10429 ""
			if (i_indx("shtc", durq, (ftnlen)4, (ftnlen)1) == 0) {
#line 10430 ""
			    i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff 
				    + a1ll_2.nbars + 1;
#line 10430 ""
			    errmsg_(lineq, &a1ll_2.iccount, &i__1, "Only let"\
				    "ters allowed here are \"s\",\"h\",\"t\""\
				    ",\"c\"!", (ftnlen)128, (ftnlen)46);
#line 10432 ""
			    stop1_();
#line 10433 ""
			}

/*  Now check for another default modifier */

#line 10437 ""
			goto L42;
#line 10438 ""
		    } else if (i_indx("lh", durq, (ftnlen)2, (ftnlen)1) > 0) {

/*  Flags for optional linebreak ties or header specials */

#line 10442 ""
			goto L42;
#line 10443 ""
		    } else {
#line 10444 ""
			--a1ll_2.iccount;
#line 10445 ""
		    }
#line 10446 ""
		    goto L27;
#line 10447 ""
		} else if (*(unsigned char *)durq == 'N') {

/*  Override default name for a part file. Must have part number, then */
/*    partname in quotes. Must be on line by itself, and start in column 1. */
/*    Will only be passed thru to scor2prt. */

#line 10453 ""
		    if (a1ll_2.iccount != 2) {
#line 10454 ""
			i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 10454 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__1, "\"AN\" must "\
				"start in column 1!", (ftnlen)128, (ftnlen)28);
#line 10456 ""
			stop1_();
#line 10457 ""
		    }
#line 10458 ""
		    chax_(ch__2, (ftnlen)1, &c__34);
#line 10458 ""
		    ndxquote = i_indx(lineq, ch__2, (ftnlen)128, (ftnlen)1);
#line 10459 ""
		    if (ndxquote < 4 || ndxquote > 5 || i_indx("123456789", 
			    lineq + 2, (ftnlen)9, (ftnlen)1) == 0 || ndxquote 
			    == 5 && i_indx("012", lineq + 3, (ftnlen)3, (
			    ftnlen)1) == 0) {
#line 10462 ""
			i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 10462 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__1, "\"AN\" must "\
				"be followed by inst. #, then quote!", (ftnlen)
				128, (ftnlen)45);
#line 10464 ""
			stop1_();
#line 10465 ""
		    }
#line 10466 ""
		    i__1 = ndxquote;
#line 10466 ""
		    chax_(ch__2, (ftnlen)1, &c__34);
#line 10466 ""
		    ndxquote = i_indx(lineq + i__1, ch__2, 128 - i__1, (
			    ftnlen)1);
#line 10467 ""
		    if (ndxquote == 0) {
#line 10468 ""
			i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 10468 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__1, "In \"AN\", f"\
				"ile name must be in quotes!", (ftnlen)128, (
				ftnlen)37);
#line 10470 ""
			stop1_();
#line 10471 ""
		    }
#line 10472 ""
		    a1ll_2.iccount = 128;
#line 10473 ""
		} else if (*(unsigned char *)durq == 'T') {
#line 10474 ""
		    comnvst_1.cstuplet = TRUE_;
#line 10475 ""
		} else if (*(unsigned char *)durq == 'R') {

/*  Get full name of normal include file; must occupy remainder of line */

#line 10479 ""
		    i__1 = a1ll_2.iccount;
#line 10479 ""
		    getpmxmod_(&c_false, lineq + i__1, 128 - i__1);
#line 10480 ""
		    a1ll_2.iccount = 128;
#line 10481 ""
		} else if (*(unsigned char *)durq == 'c') {
#line 10482 ""
		    g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)128, (
			    ftnlen)1);
#line 10483 ""
		    if (i_indx("l4", durq, (ftnlen)2, (ftnlen)1) == 0) {
#line 10484 ""
			i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 10484 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__1, "Only \"l\" o"\
				"r \"4\" is allowed here!", (ftnlen)128, (
				ftnlen)32);
#line 10486 ""
			stop1_();
#line 10487 ""
		    }
#line 10488 ""
		    if (*(unsigned char *)durq == 'l') {
#line 10489 ""
			compage_1.hoffpt = -25.f;
#line 10490 ""
			compage_1.voffpt = -45.f;
#line 10491 ""
		    } else if (*(unsigned char *)durq == '4') {
#line 10492 ""
			compage_1.ptheight = 745.f;
#line 10493 ""
			compage_1.widthpt = 499.f;
#line 10494 ""
			compage_1.hoffpt = -24.f;
#line 10495 ""
			compage_1.voffpt = -24.f;
#line 10496 ""
		    }
#line 10497 ""
		    goto L27;
#line 10498 ""
		} else if (*(unsigned char *)durq == 'V') {
#line 10499 ""
		    g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)128, (
			    ftnlen)1);
#line 10500 ""
		    if (i_indx("+-", durq, (ftnlen)2, (ftnlen)1) == 0) {
#line 10501 ""
			i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 10501 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__1, "Only \"+\" o"\
				"r \"-\" is allowed here!", (ftnlen)128, (
				ftnlen)32);
#line 10503 ""
			stop1_();
#line 10504 ""
		    }
#line 10505 ""
		    g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)128, (
			    ftnlen)1);
#line 10506 ""
		    if (i_indx("0123456789.", durq, (ftnlen)11, (ftnlen)1) == 
			    0) {
#line 10507 ""
			i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 10507 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__1, "A number for"\
				" vert shift before \\eject must start here!", 
				(ftnlen)128, (ftnlen)54);
#line 10509 ""
			stop1_();
#line 10510 ""
		    }
#line 10511 ""
		    readnum_(lineq, &a1ll_2.iccount, durq, &fnum, (ftnlen)128,
			     (ftnlen)1);
#line 10512 ""
		    if (i_indx("+-", durq, (ftnlen)2, (ftnlen)1) == 0) {
#line 10513 ""
			i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 10513 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__1, "Only \"+\" o"\
				"r \"-\" is allowed here!", (ftnlen)128, (
				ftnlen)32);
#line 10515 ""
			stop1_();
#line 10516 ""
		    }
#line 10517 ""
		    g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)128, (
			    ftnlen)1);
#line 10518 ""
		    if (i_indx("0123456789.", durq, (ftnlen)11, (ftnlen)1) == 
			    0) {
#line 10519 ""
			i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 10519 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__1, "A number for"\
				" vert shift after \\eject must start here!", (
				ftnlen)128, (ftnlen)53);
#line 10521 ""
			stop1_();
#line 10522 ""
		    }
#line 10523 ""
		    readnum_(lineq, &a1ll_2.iccount, durq, &fnum, (ftnlen)128,
			     (ftnlen)1);
#line 10524 ""
		    --a1ll_2.iccount;
#line 10525 ""
		    goto L27;
#line 10526 ""
		} else if (*(unsigned char *)durq == 'B') {
#line 10527 ""
		    i__1 = a1ll_2.iccount;
#line 10527 ""
		    if (s_cmp(lineq + i__1, "f", a1ll_2.iccount + 1 - i__1, (
			    ftnlen)1) == 0) {
#line 10528 ""
			++a1ll_2.iccount;
#line 10529 ""
			goto L27;
#line 10530 ""
		    }
#line 10531 ""
		    goto L27;
#line 10532 ""
		} else if (*(unsigned char *)durq != ' ') {
#line 10533 ""
		    i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			    a1ll_2.nbars + 1;
#line 10533 ""
		    errmsg_(lineq, &a1ll_2.iccount, &i__1, "After \"A\" must"\
			    " follow one of abcdeiILNprRsSTvV!", (ftnlen)128, (
			    ftnlen)47);
/*     *       'After "A" must follow one of the letters abBcdeiINprRsST!') */
#line 10536 ""
		    s_wsle(&io___684);
#line 10536 ""
		    do_lio(&c__9, &c__1, "For AS, since ver. 2.7, must only "\
			    "have noinst args.", (ftnlen)51);
#line 10536 ""
		    e_wsle();
#line 10537 ""
		    s_wsfe(&io___685);
#line 10537 ""
		    do_fio(&c__1, "For AS, since ver. 2.7, must only have no"\
			    "inst args.", (ftnlen)51);
#line 10537 ""
		    e_wsfe();
#line 10539 ""
		    stop1_();
#line 10540 ""
		}
#line 10541 ""
	    } else if (*(unsigned char *)charq == 'K') {

/*  Rules and function of K command */

/*  Only 1 K +/-n +/-m  allowed per block if n.ne.0 (transposition).  isig1 is */
/*  initial sig, and must be passed to pmxb because it is needed when topfile */
/*  is called, which is before the K+n+m command is read in pmxb.  Also, we */
/*  compute and save ibrkch and newkey for each syst, accounting for key changes, */
/*  then adjust fbar to make poenom much more accurate. */
/*  Jan 02: Now K-0+[n] is used to transpose e.g. from f to f#. */

#line 10552 ""
L77:
#line 10553 ""
		g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)128, (ftnlen)
			1);
#line 10554 ""
		if (i_indx("+-in", durq, (ftnlen)4, (ftnlen)1) == 0) {
#line 10555 ""
		    i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			    a1ll_2.nbars + 1;
#line 10555 ""
		    errmsg_(lineq, &a1ll_2.iccount, &i__1, "\"K\" (transpose"\
			    " or key change) must be followed by \"+,-,i,n\"!",
			     (ftnlen)128, (ftnlen)60);
#line 10557 ""
		    stop1_();
#line 10558 ""
		}
#line 10559 ""
		if (*(unsigned char *)durq == 'n') {
#line 10559 ""
		    goto L77;
#line 10559 ""
		}
#line 10560 ""
		if (*(unsigned char *)durq != 'i') {

/* Normal key change and/or transposition) */

#line 10564 ""
		    num1 = 44 - *(unsigned char *)durq;

/*  num1= +1 or -1 */

#line 10568 ""
		    ztrans = num1 == -1;
#line 10569 ""
		    g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)128, (
			    ftnlen)1);
#line 10570 ""
		    if (i_indx("0123456789", durq, (ftnlen)10, (ftnlen)1) == 
			    0) {
#line 10571 ""
			i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 10571 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__1, "1st +/- must"\
				" be followed by a number!", (ftnlen)128, (
				ftnlen)37);
#line 10573 ""
			stop1_();
#line 10574 ""
		    }
/*          iccount = iccount+1 */
#line 10576 ""
		    readnum_(lineq, &a1ll_2.iccount, durq, &fnum, (ftnlen)128,
			     (ftnlen)1);
#line 10577 ""
		    num1 = i_nint(&fnum) * num1;
#line 10578 ""
		    ztrans = ztrans && num1 == 0;
#line 10579 ""
		    if (i_indx("+-", durq, (ftnlen)2, (ftnlen)1) == 0) {
#line 10580 ""
			i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 10580 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__1, "1st number a"\
				"fter \"K\" must be followed by \"+,-\"!", (
				ftnlen)128, (ftnlen)47);
#line 10582 ""
			stop1_();
#line 10583 ""
		    }
#line 10584 ""
		    ++a1ll_2.iccount;
#line 10585 ""
		    num2 = 44 - *(unsigned char *)durq;
#line 10586 ""
		    readnum_(lineq, &a1ll_2.iccount, durq, &fnum, (ftnlen)128,
			     (ftnlen)1);
#line 10587 ""
		    num2 *= (integer) (fnum + .1f);
#line 10588 ""
		    if (num1 == 0 && ! ztrans) {

/*  Key change, only one per block allowed */

#line 10592 ""
			if (comkeys_1.iskchb) {
#line 10593 ""
			    i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff 
				    + a1ll_2.nbars + 1;
#line 10593 ""
			    errmsg_(lineq, &a1ll_2.iccount, &i__1, "Only one"\
				    " key change allowed per input block!", (
				    ftnlen)128, (ftnlen)44);
#line 10595 ""
			    stop1_();
#line 10596 ""
			}
#line 10597 ""
			comkeys_1.iskchb = TRUE_;
#line 10598 ""
			++comkeys_1.nkeys;
#line 10599 ""
			comkeys_1.kchmid[comkeys_1.nkeys - 1] = 
				a1ll_2.itsofar[c1ommvl_1.ivx - 1] % 
				a1ll_2.lenbar != 0;

/*  Make ibrkch = barnum-1 if at start of bar, so fsyst advances ok at linebreak. */

#line 10603 ""
			comkeys_1.ibrkch[comkeys_1.nkeys - 1] = 
				c1omnotes_1.ibarcnt + a1ll_2.nbars;
#line 10604 ""
			if (comkeys_1.kchmid[comkeys_1.nkeys - 1]) {
#line 10604 ""
			    ++comkeys_1.ibrkch[comkeys_1.nkeys - 1];
#line 10604 ""
			}
#line 10605 ""
			comkeys_1.newkey[comkeys_1.nkeys - 1] = num2 + 
				comkeys_1.idsig;
#line 10606 ""
			commidisig_1.midisig = comkeys_1.newkey[
				comkeys_1.nkeys - 1];
#line 10607 ""
		    } else {

/*  Transposition */

#line 10611 ""
			*fulltrans = TRUE_;
#line 10612 ""
			if (c1omnotes_1.ibarcnt > 0) {
#line 10613 ""
			    i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff 
				    + a1ll_2.nbars + 1;
#line 10613 ""
			    errmsg_(lineq, &a1ll_2.iccount, &i__1, "Transpos"\
				    "ition must be at top of first input bloc"\
				    "k!", (ftnlen)128, (ftnlen)50);
#line 10615 ""
			    stop1_();
#line 10616 ""
			}
#line 10617 ""
			comkeys_1.isig1 = num2;
#line 10618 ""
			comkeys_1.idsig = comkeys_1.isig1 - comkeys_1.newkey[
				0];

/*  idsig is the difference between sig after transposition, and sig in setup. */
/*  It may alter # of accid's in key changes if there is transposition. */

#line 10623 ""
		    }
#line 10624 ""
		} else {

/*  110522/110529 */
/*  Instrument-wise transposition Ki[iInstTrans][+/-][iTransAmt][+/-][iTransKey] */
/*    and repeat i[...] for multiple instruments. Store info here if ibarcnt=0 */
/*    so can pass to topfile (via comInstTrans), which is called before getnote. */
/*    Otherwise, will store info from getnote. Initialize EarlyTransOn and */
/*    LaterInstTrans to .false. in blockdata. Set EarlyTransOn from here; */
/*    LaterInstTrans from g1etnote. Zero both out after use. nInstTrans really */
/*    only needed for instrument-signatures, not transpositions. iTransAmt is */
/*    ALWAYS active per instrument. Set up instno(iv) so can fetch iTransAmt for */
/*    each staff. */

/* durq='i' */
#line 10637 ""
		    getitransinfo_(&c_true, &c1omnotes_1.ibarcnt, lineq, &
			    a1ll_2.iccount, &c1omnotes_1.ibaroff, &
			    a1ll_2.nbars, &comkeys_1.noinst, (ftnlen)128);
#line 10639 ""
		}
#line 10640 ""
	    } else if (*(unsigned char *)charq == '|') {

/*  Optional bar symbol */

#line 10644 ""
		if (a1ll_2.itsofar[c1ommvl_1.ivx - 1] % a1ll_2.lenbar != 0) {
#line 10645 ""
		    i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			    a1ll_2.nbars + 1;
#line 10645 ""
		    errmsg_(lineq, &a1ll_2.iccount, &i__1, "Bar line marker "\
			    "out of place!", (ftnlen)128, (ftnlen)29);
#line 10647 ""
		    stop1_();
#line 10648 ""
		} else if (comkeys_1.shifton) {
#line 10649 ""
		    i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			    a1ll_2.nbars + 1;
#line 10649 ""
		    errmsg_(lineq, &a1ll_2.iccount, &i__1, "Bar ended with u"\
			    "ser-defined shift still on!", (ftnlen)128, (
			    ftnlen)43);
#line 10651 ""
		    stop1_();
#line 10652 ""
		}
#line 10653 ""
	    } else /* if(complicated condition) */ {
#line 10653 ""
		chax_(ch__2, (ftnlen)1, &c__47);
#line 10653 ""
		if (*(unsigned char *)charq == *(unsigned char *)&ch__2[0]) {
#line 10654 ""
		    if (comkeys_1.ornrpt) {
#line 10655 ""
			i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 10655 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__1, "WARNING: Blo"\
				"ck ended with repeated ornament still on!", (
				ftnlen)128, (ftnlen)53);
#line 10657 ""
			comkeys_1.ornrpt = FALSE_;
#line 10658 ""
		    }
#line 10659 ""
		    if (comkeys_1.stickys) {
#line 10660 ""
			i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 10660 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__1, "WARNING: Blo"\
				"ck ended with sticky stemshrink still on!", (
				ftnlen)128, (ftnlen)53);
#line 10662 ""
			comkeys_1.stickys = FALSE_;
#line 10663 ""
		    }
#line 10664 ""
		    if (c1omget_1.fbon) {
#line 10665 ""
			i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 10665 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__1, "Block ended "\
				"with forced beam open!", (ftnlen)128, (ftnlen)
				34);
#line 10667 ""
			stop1_();
#line 10668 ""
		    } else if (comkeys_1.shifton) {
#line 10669 ""
			i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 10669 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__1, "Bar ended wi"\
				"th user-defined shift still on!", (ftnlen)128,
				 (ftnlen)43);
#line 10671 ""
			stop1_();
#line 10672 ""
		    }
#line 10673 ""
		    comkeys_1.barend = FALSE_;

/*  Perform time checks */

#line 10677 ""
		    if (a1ll_2.itsofar[c1ommvl_1.ivx - 1] % a1ll_2.lenbar != 
			    0) {
#line 10678 ""
			i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 10678 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__1, "Block durati"\
				"on not divisible by lenbar!", (ftnlen)128, (
				ftnlen)39);
#line 10680 ""
			s_wsle(&io___689);
#line 10680 ""
			do_lio(&c__9, &c__1, "lenbar, timesofar are ", (
				ftnlen)22);
#line 10680 ""
			do_lio(&c__3, &c__1, (char *)&a1ll_2.lenbar, (ftnlen)
				sizeof(integer));
#line 10680 ""
			do_lio(&c__3, &c__1, (char *)&a1ll_2.itsofar[
				c1ommvl_1.ivx - 1], (ftnlen)sizeof(integer));
#line 10680 ""
			e_wsle();
#line 10681 ""
			stop1_();
#line 10682 ""
		    } else if (c1ommvl_1.ivx > 1 && a1ll_2.itsofar[
			    c1ommvl_1.ivx - 1] != a1ll_2.itsofar[0]) {
#line 10683 ""
			s_wsle(&io___690);
#line 10683 ""
			e_wsle();
#line 10684 ""
			s_wsle(&io___691);
#line 10684 ""
			do_lio(&c__9, &c__1, "No of bars in voice 1, current"\
				" voice:", (ftnlen)37);
#line 10684 ""
			i__1 = a1ll_2.itsofar[0] / a1ll_2.lenbar;
#line 10684 ""
			do_lio(&c__3, &c__1, (char *)&i__1, (ftnlen)sizeof(
				integer));
#line 10684 ""
			i__4 = a1ll_2.itsofar[c1ommvl_1.ivx - 1] / 
				a1ll_2.lenbar;
#line 10684 ""
			do_lio(&c__3, &c__1, (char *)&i__4, (ftnlen)sizeof(
				integer));
#line 10684 ""
			e_wsle();
#line 10686 ""
			i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 10686 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__1, "Block durati"\
				"on not equal to voice 1!", (ftnlen)128, (
				ftnlen)36);
#line 10688 ""
			stop1_();
#line 10689 ""
		    }
#line 10690 ""
		    g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)128, (
			    ftnlen)1);
#line 10691 ""
		    if (*(unsigned char *)durq == ' ' && a1ll_2.iv == 
			    a1ll_2.nv) {

/*  End of input block */

#line 10695 ""
			*loop = FALSE_;
#line 10696 ""
		    } else {

/*  Start a new voice */

#line 10700 ""
			if (a1ll_2.lenbr0 != 0 && a1ll_2.firstline) {
#line 10700 ""
			    a1ll_2.lenbar = a1ll_2.lenbr0;
#line 10700 ""
			}
#line 10701 ""
			a1ll_2.nbars = 0;
#line 10702 ""
			if (*(unsigned char *)durq == ' ') {

/*  New voice is on next staff */

#line 10706 ""
			    ++a1ll_2.iv;
#line 10707 ""
			    c1ommvl_1.ivx = a1ll_2.iv;
#line 10708 ""
			} else {

/*  New voice is on same staff.  Set up for it */

#line 10712 ""
			    c1ommvl_1.ivx = a1ll_2.nv + 1;
#line 10713 ""
			    i__1 = a1ll_2.nv;
#line 10713 ""
			    for (iiv = 1; iiv <= i__1; ++iiv) {
#line 10714 ""
				if (c1ommvl_1.nvmx[iiv - 1] == 2) {
#line 10714 ""
				    ++c1ommvl_1.ivx;
#line 10714 ""
				}
#line 10715 ""
/* L23: */
#line 10715 ""
			    }
#line 10716 ""
			    if (c1ommvl_1.ivx > 24) {
#line 10717 ""
				s_wsfe(&io___692);
#line 10717 ""
				do_fio(&c__1, "Cannot have more than", (
					ftnlen)21);
#line 10717 ""
				do_fio(&c__1, (char *)&c__24, (ftnlen)sizeof(
					integer));
#line 10717 ""
				do_fio(&c__1, " lines of music at once", (
					ftnlen)23);
#line 10717 ""
				e_wsfe();
#line 10719 ""
				stop1_();
#line 10720 ""
			    }
#line 10721 ""
			    c1ommvl_1.nvmx[a1ll_2.iv - 1] = 2;
#line 10722 ""
			    c1ommvl_1.ivmx[a1ll_2.iv + 23] = c1ommvl_1.ivx;
#line 10723 ""
			    a1ll_2.itsofar[c1ommvl_1.ivx - 1] = 0;
#line 10724 ""
			    a1ll_2.nnl[c1ommvl_1.ivx - 1] = 0;
#line 10725 ""
			    for (j = 1; j <= 200; ++j) {
#line 10726 ""
				a1ll_2.rest[c1ommvl_1.ivx + j * 24 - 25] = 
					FALSE_;
#line 10727 ""
				c1ommvl_1.nacc[c1ommvl_1.ivx + j * 24 - 25] = 
					0;
#line 10728 ""
/* L24: */
#line 10728 ""
			    }

/*  For midi stuff, record that there is a 2nd line of music in this voice */

#line 10732 ""
			    if (commidi_1.ismidi) {
#line 10732 ""
				commidi_1.twoline[a1ll_2.iv - 1] = TRUE_;
#line 10732 ""
			    }
#line 10733 ""
			}
#line 10734 ""
		    }
#line 10735 ""
		    a1ll_2.iccount = 128;
#line 10736 ""
		} else if (*(unsigned char *)charq == 'S') {

/*  New nsyst: for use with partmaker scor2prt, for parts w/ diff # of systs. */

#line 10740 ""
		    if (c1omnotes_1.ibarcnt > 0) {
#line 10741 ""
			i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 10741 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__1, "\"S\" can on"\
				"ly be in first input block!", (ftnlen)128, (
				ftnlen)37);
#line 10743 ""
			stop1_();
#line 10744 ""
		    }
#line 10745 ""
		    g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)128, (
			    ftnlen)1);
#line 10746 ""
		    if (i_indx("123456789 ", durq, (ftnlen)10, (ftnlen)1) == 
			    0) {
#line 10747 ""
			i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 10747 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__1, "A digit must"\
				" follow \"S\"!", (ftnlen)128, (ftnlen)24);
#line 10749 ""
			stop1_();
#line 10750 ""
		    }
#line 10751 ""
		    readnum_(lineq, &a1ll_2.iccount, durq, &fnsyst, (ftnlen)
			    128, (ftnlen)1);
#line 10752 ""
		    compage_1.nsyst = i_nint(&fnsyst);
#line 10753 ""
L14:
#line 10754 ""
		    if (*(unsigned char *)durq == 'P') {

/*  New npages for parts. */

#line 10758 ""
			g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)128, (
				ftnlen)1);
#line 10759 ""
			if (i_indx("123456789 ", durq, (ftnlen)10, (ftnlen)1) 
				== 0) {
#line 10760 ""
			    i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff 
				    + a1ll_2.nbars + 1;
#line 10760 ""
			    errmsg_(lineq, &a1ll_2.iccount, &i__1, "Must hav"\
				    "e a number here!", (ftnlen)128, (ftnlen)
				    24);
#line 10762 ""
			    stop1_();
#line 10763 ""
			}
#line 10764 ""
			readnum_(lineq, &a1ll_2.iccount, durq, &fnsyst, (
				ftnlen)128, (ftnlen)1);
#line 10765 ""
			compage_1.npages = i_nint(&fnsyst);
#line 10766 ""
			goto L14;
#line 10767 ""
		    } else if (*(unsigned char *)durq == 'm') {

/*  Reset musize (musicsize). */

#line 10771 ""
			g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)128, (
				ftnlen)1);
#line 10772 ""
			if (i_indx("123456789 ", durq, (ftnlen)10, (ftnlen)1) 
				== 0) {
#line 10773 ""
			    i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff 
				    + a1ll_2.nbars + 1;
#line 10773 ""
			    errmsg_(lineq, &a1ll_2.iccount, &i__1, "Must hav"\
				    "e a number here!", (ftnlen)128, (ftnlen)
				    24);
#line 10775 ""
			    stop1_();
#line 10776 ""
			}
#line 10777 ""
			readnum_(lineq, &a1ll_2.iccount, durq, &fnsyst, (
				ftnlen)128, (ftnlen)1);
#line 10778 ""
			commus_1.musize = i_nint(&fnsyst);
#line 10779 ""
			c1omnotes_1.wheadpt = commus_1.whead20 * 
				commus_1.musize;
#line 10780 ""
			goto L14;
#line 10781 ""
		    } else if (*(unsigned char *)durq != ' ') {
#line 10782 ""
			i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 10782 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__1, "Illegal char"\
				"acter in \"S\" symbol!", (ftnlen)128, (ftnlen)
				32);
#line 10784 ""
			stop1_();
#line 10785 ""
		    }
#line 10786 ""
		} else if (*(unsigned char *)charq == 'L') {

/*  Force line break */

#line 10790 ""
		    g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)128, (
			    ftnlen)1);
#line 10791 ""
		    if (*(unsigned char *)durq == 'C') {

/*  Coda, no real line break, just get coda length */

#line 10795 ""
			if (comshort_1.ishort != 1) {
#line 10796 ""
			    i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff 
				    + a1ll_2.nbars + 1;
#line 10796 ""
			    errmsg_(lineq, &a1ll_2.iccount, &i__1, "Cannot u"\
				    "se \"LC\" without first using \"L[n]S\"!",
				     (ftnlen)128, (ftnlen)44);
#line 10798 ""
			    stop1_();
#line 10799 ""
			}
#line 10800 ""
			comshort_1.ishort = 0;
#line 10801 ""
			g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)128, (
				ftnlen)1);
#line 10802 ""
			if (i_indx("1234567890.", durq, (ftnlen)11, (ftnlen)1)
				 == 0) {
#line 10803 ""
			    i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff 
				    + a1ll_2.nbars + 1;
#line 10803 ""
			    errmsg_(lineq, &a1ll_2.iccount, &i__1, "Need num"\
				    "ber to define coda length!", (ftnlen)128, 
				    (ftnlen)34);
#line 10805 ""
			    stop1_();
#line 10806 ""
			}
#line 10807 ""
			readnum_(lineq, &a1ll_2.iccount, durq, &
				comshort_1.codafrac, (ftnlen)128, (ftnlen)1);
#line 10808 ""
			comshort_1.poefa[compage_1.isysflb[compage_1.nflb] - 
				1] += comshort_1.codafrac;
#line 10809 ""
			if (i_indx(" n", durq, (ftnlen)2, (ftnlen)1) == 0) {
#line 10810 ""
			    i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff 
				    + a1ll_2.nbars + 1;
#line 10810 ""
			    errmsg_(lineq, &a1ll_2.iccount, &i__1, "Need bla"\
				    "nk or \"n\" here!", (ftnlen)128, (ftnlen)
				    23);
#line 10812 ""
			    stop1_();
#line 10813 ""
			}
#line 10814 ""
			return 0;
#line 10815 ""
		    }
#line 10816 ""
		    ++compage_1.nflb;
#line 10817 ""
		    compage_1.ibarflb[compage_1.nflb] = c1omnotes_1.ibarcnt + 
			    a1ll_2.nbars + 1;
#line 10818 ""
		    if (i_indx("123456789", durq, (ftnlen)9, (ftnlen)1) == 0) 
			    {
#line 10819 ""
			i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 10819 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__1, "Need integer"\
				" to define forced line break!", (ftnlen)128, (
				ftnlen)41);
#line 10821 ""
			stop1_();
#line 10822 ""
		    }
#line 10823 ""
		    readnum_(lineq, &a1ll_2.iccount, durq, &sysflb, (ftnlen)
			    128, (ftnlen)1);
#line 10824 ""
		    compage_1.isysflb[compage_1.nflb] = i_nint(&sysflb);
#line 10825 ""
		    if (compage_1.isysflb[compage_1.nflb] == 1) {
#line 10826 ""
			i__1 = a1ll_2.iccount - 1;
#line 10826 ""
			i__4 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 10826 ""
			errmsg_(lineq, &i__1, &i__4, "For now, \"L1\" not al"\
				"lowed!", (ftnlen)128, (ftnlen)26);
#line 10828 ""
			stop1_();
#line 10829 ""
		    }
#line 10830 ""
		    if (compage_1.nflb > 1) {

/*  Check if new number is > prior one */

#line 10834 ""
			if (compage_1.isysflb[compage_1.nflb] <= 
				compage_1.isysflb[compage_1.nflb - 1]) {
#line 10835 ""
			    i__1 = a1ll_2.iccount - 1;
#line 10835 ""
			    i__4 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff 
				    + a1ll_2.nbars + 1;
#line 10835 ""
			    errmsg_(lineq, &i__1, &i__4, "You already forced"\
				    " a line break at a later line!", (ftnlen)
				    128, (ftnlen)48);
#line 10837 ""
			    stop1_();
#line 10838 ""
			}
#line 10839 ""
		    }
#line 10840 ""
		    if (compage_1.npages == 0) {
#line 10841 ""
			s_wsle(&io___696);
#line 10841 ""
			e_wsle();
#line 10842 ""
			s_wsle(&io___697);
#line 10842 ""
			do_lio(&c__9, &c__1, "WARNING! You forced a line bre"\
				"ak at line ", (ftnlen)41);
#line 10842 ""
			do_lio(&c__3, &c__1, (char *)&compage_1.isysflb[
				compage_1.nflb], (ftnlen)sizeof(integer));
#line 10842 ""
			do_lio(&c__9, &c__1, " but npage = 0.  Continue?", (
				ftnlen)26);
#line 10842 ""
			e_wsle();
#line 10844 ""
		    } else if (compage_1.isysflb[compage_1.nflb] > 
			    compage_1.nsyst) {
#line 10845 ""
			i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 10845 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__1, "Forced line "\
				"break at line num > nsyst!", (ftnlen)128, (
				ftnlen)38);
#line 10847 ""
			stop1_();
#line 10848 ""
		    } else if (i_indx(" PMS", durq, (ftnlen)4, (ftnlen)1) == 
			    0) {
#line 10849 ""
			i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 10849 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__1, "Must have"\
				" \" \", \"P\", \"M\", or \"S\" here!", (
				ftnlen)128, (ftnlen)37);
#line 10851 ""
			stop1_();
#line 10852 ""
		    }
#line 10853 ""
L49:
/* Transfer up from below to allow S after M */
#line 10854 ""
		    if (*(unsigned char *)durq == 'S') {

/*  Shortened line, get shortening fraction */

#line 10858 ""
			comshort_1.ishort = 1;
#line 10859 ""
			g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)128, (
				ftnlen)1);
#line 10860 ""
			if (i_indx("1234567890.", durq, (ftnlen)11, (ftnlen)1)
				 == 0) {
#line 10861 ""
			    i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff 
				    + a1ll_2.nbars + 1;
#line 10861 ""
			    errmsg_(lineq, &a1ll_2.iccount, &i__1, "Need num"\
				    "ber to define line shortening fraction!", 
				    (ftnlen)128, (ftnlen)47);
#line 10863 ""
			    stop1_();
#line 10864 ""
			}
#line 10865 ""
			readnum_(lineq, &a1ll_2.iccount, durq, &
				comshort_1.shortfrac, (ftnlen)128, (ftnlen)1);
#line 10866 ""
			comshort_1.poefa[compage_1.isysflb[compage_1.nflb] - 
				1] = comshort_1.shortfrac;
#line 10867 ""
			if (*(unsigned char *)durq != ' ') {
#line 10868 ""
			    i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff 
				    + a1ll_2.nbars + 1;
#line 10868 ""
			    errmsg_(lineq, &a1ll_2.iccount, &i__1, "Need bla"\
				    "nk here!", (ftnlen)128, (ftnlen)16);
#line 10870 ""
			}
#line 10871 ""
		    }
#line 10872 ""
		    if (*(unsigned char *)durq == 'P') {

/*  Forced page break here, get page number. */

#line 10876 ""
			g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)128, (
				ftnlen)1);
#line 10877 ""
			if (i_indx("123456789", durq, (ftnlen)9, (ftnlen)1) ==
				 0) {
#line 10878 ""
			    i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff 
				    + a1ll_2.nbars + 1;
#line 10878 ""
			    errmsg_(lineq, &a1ll_2.iccount, &i__1, "Need int"\
				    "eger to define forced page break!", (
				    ftnlen)128, (ftnlen)41);
#line 10880 ""
			    stop1_();
#line 10881 ""
			}
#line 10882 ""
			readnum_(lineq, &a1ll_2.iccount, durq, &fnum, (ftnlen)
				128, (ftnlen)1);
#line 10883 ""
			++compage_1.nfpb;
#line 10884 ""
			compage_1.ipagfpb[compage_1.nfpb] = i_nint(&fnum);
#line 10885 ""
			compage_1.isysfpb[compage_1.nfpb] = compage_1.isysflb[
				compage_1.nflb];
#line 10886 ""
			if (compage_1.ipagfpb[compage_1.nfpb] > 
				compage_1.npages) {
#line 10887 ""
			    i__1 = a1ll_2.iccount - 1;
#line 10887 ""
			    i__4 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff 
				    + a1ll_2.nbars + 1;
#line 10887 ""
			    errmsg_(lineq, &i__1, &i__4, "Forced page break "\
				    "at page num > npages!", (ftnlen)128, (
				    ftnlen)39);
#line 10889 ""
			    stop1_();
#line 10890 ""
			} else if (compage_1.nfpb > 1) {
#line 10891 ""
			    if (compage_1.ipagfpb[compage_1.nfpb] <= 
				    compage_1.ipagfpb[compage_1.nfpb - 1]) {
#line 10892 ""
				i__1 = a1ll_2.iccount - 1;
#line 10892 ""
				i__4 = c1omnotes_1.ibarcnt - 
					c1omnotes_1.ibaroff + a1ll_2.nbars + 
					1;
#line 10892 ""
				errmsg_(lineq, &i__1, &i__4, "Forced page br"\
					"eak numbers must increase!", (ftnlen)
					128, (ftnlen)40);
#line 10894 ""
				stop1_();
#line 10895 ""
			    }
#line 10896 ""
			}
#line 10897 ""
		    }
#line 10898 ""
		    if (i_indx(" M", durq, (ftnlen)2, (ftnlen)1) == 0) {
#line 10899 ""
			i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 10899 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__1, "Illegal char"\
				"acter in linebreak symbol!", (ftnlen)128, (
				ftnlen)38);
#line 10901 ""
			stop1_();
#line 10902 ""
		    } else if (*(unsigned char *)durq == 'M') {
#line 10903 ""
			++compage_1.nmovbrk;
#line 10904 ""
			compage_1.isysmb[compage_1.nmovbrk] = 
				compage_1.isysflb[compage_1.nflb];
#line 10905 ""
			g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)128, (
				ftnlen)1);
#line 10906 ""
L31:
#line 10906 ""
			if (*(unsigned char *)durq == '+') {

/*  Vertical spacing, read past number. */

#line 10910 ""
			    g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)
				    128, (ftnlen)1);
#line 10911 ""
			    if (i_indx("123456789", durq, (ftnlen)9, (ftnlen)
				    1) == 0) {
#line 10912 ""
				i__1 = c1omnotes_1.ibarcnt - 
					c1omnotes_1.ibaroff + a1ll_2.nbars + 
					1;
#line 10912 ""
				errmsg_(lineq, &a1ll_2.iccount, &i__1, "Inte"\
					"ger required here!", (ftnlen)128, (
					ftnlen)22);
#line 10914 ""
				stop1_();
#line 10915 ""
			    }
#line 10916 ""
			    readnum_(lineq, &a1ll_2.iccount, durq, &fnum, (
				    ftnlen)128, (ftnlen)1);
#line 10917 ""
			    goto L31;
#line 10918 ""
			} else if (*(unsigned char *)durq == 'i') {

/*  Change indentation, */

#line 10922 ""
			    g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)
				    128, (ftnlen)1);
#line 10923 ""
			    if (i_indx(".123456789", durq, (ftnlen)10, (
				    ftnlen)1) == 0) {
#line 10924 ""
				i__1 = c1omnotes_1.ibarcnt - 
					c1omnotes_1.ibaroff + a1ll_2.nbars + 
					1;
#line 10924 ""
				errmsg_(lineq, &a1ll_2.iccount, &i__1, "Deci"\
					"mal number required here!", (ftnlen)
					128, (ftnlen)29);
#line 10926 ""
				stop1_();
#line 10927 ""
			    }

/*  fracsys was initialized in block data to all 0.'s */

#line 10931 ""
			    readnum_(lineq, &a1ll_2.iccount, durq, &
				    compage_1.fracsys[compage_1.nmovbrk - 1], 
				    (ftnlen)128, (ftnlen)1);
#line 10932 ""
			    goto L31;
#line 10933 ""
			} else if (*(unsigned char *)durq == 'c') {
#line 10934 ""
			    g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)
				    128, (ftnlen)1);
#line 10935 ""
			    goto L31;
#line 10936 ""
			} else if (*(unsigned char *)durq == 'r') {
#line 10937 ""
			    g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)
				    128, (ftnlen)1);
#line 10938 ""
			    if (i_indx("+-", durq, (ftnlen)2, (ftnlen)1) == 0)
				     {
#line 10939 ""
				i__1 = c1omnotes_1.ibarcnt - 
					c1omnotes_1.ibaroff + a1ll_2.nbars + 
					1;
#line 10939 ""
				errmsg_(lineq, &a1ll_2.iccount, &i__1, "Must"\
					" have \"+\" or \"-\" after \"r\" as "\
					"movement break option!", (ftnlen)128, 
					(ftnlen)56);
#line 10941 ""
				stop1_();
#line 10942 ""
			    }
#line 10943 ""
			    g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)
				    128, (ftnlen)1);
#line 10944 ""
			    goto L31;
#line 10945 ""
			} else if (*(unsigned char *)durq == 'n') {

/*  Change # of voices.  Input ninow, iorig(1...ninow).  Will use names, */
/*  staves per inst. and clefs  corr. to iorig in original list of instruments. */

#line 10950 ""
			    a1ll_2.nv = 0;
#line 10951 ""
			    g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)
				    128, (ftnlen)1);
#line 10952 ""
			    if (*(unsigned char *)durq == ':') {

/*  Signals a 2-digit number, get next two characters */

#line 10956 ""
				g1etchar_(lineq, &a1ll_2.iccount, durq, (
					ftnlen)128, (ftnlen)1);
#line 10957 ""
				g1etchar_(lineq, &a1ll_2.iccount, dumq, (
					ftnlen)128, (ftnlen)1);
#line 10958 ""
				if (i_indx("12", durq, (ftnlen)2, (ftnlen)1) 
					== 0 || i_indx("0123456789", dumq, (
					ftnlen)10, (ftnlen)1) == 0) {
#line 10960 ""
				    i__1 = c1omnotes_1.ibarcnt - 
					    c1omnotes_1.ibaroff + 
					    a1ll_2.nbars + 1;
/* Writing concatenation */
#line 10960 ""
				    i__8[0] = 34, a__3[0] = "Illegal new num"\
					    "ber of instruments ";
#line 10960 ""
				    i__8[1] = 1, a__3[1] = durq;
#line 10960 ""
				    i__8[2] = 1, a__3[2] = dumq;
#line 10960 ""
				    i__8[3] = 19, a__3[3] = " at movement br"\
					    "eak!";
#line 10960 ""
				    s_cat(ch__5, a__3, i__8, &c__4, (ftnlen)
					    55);
#line 10960 ""
				    errmsg_(lineq, &a1ll_2.iccount, &i__1, 
					    ch__5, (ftnlen)128, (ftnlen)55);
#line 10963 ""
				    stop1_();
#line 10964 ""
				}
#line 10965 ""
				i__1 = a1ll_2.iccount - 2;
#line 10965 ""
				ici__1.icierr = 0;
#line 10965 ""
				ici__1.iciend = 0;
#line 10965 ""
				ici__1.icirnum = 1;
#line 10965 ""
				ici__1.icirlen = a1ll_2.iccount - i__1;
#line 10965 ""
				ici__1.iciunit = lineq + i__1;
#line 10965 ""
				ici__1.icifmt = "(i2)";
#line 10965 ""
				s_rsfi(&ici__1);
#line 10965 ""
				do_fio(&c__1, (char *)&ninow, (ftnlen)sizeof(
					integer));
#line 10965 ""
				e_rsfi();
#line 10966 ""
			    } else {

/*  durq is a single digit number for noinow */

#line 10970 ""
				if (i_indx("123456789", durq, (ftnlen)9, (
					ftnlen)1) == 0) {
#line 10971 ""
				    i__1 = c1omnotes_1.ibarcnt - 
					    c1omnotes_1.ibaroff + 
					    a1ll_2.nbars + 1;
/* Writing concatenation */
#line 10971 ""
				    i__2[0] = 34, a__1[0] = "Illegal new num"\
					    "ber of instruments ";
#line 10971 ""
				    i__2[1] = 1, a__1[1] = durq;
#line 10971 ""
				    i__2[2] = 19, a__1[2] = " at movement br"\
					    "eak!";
#line 10971 ""
				    s_cat(ch__6, a__1, i__2, &c__3, (ftnlen)
					    54);
#line 10971 ""
				    errmsg_(lineq, &a1ll_2.iccount, &i__1, 
					    ch__6, (ftnlen)128, (ftnlen)54);
#line 10974 ""
				    stop1_();
#line 10975 ""
				}
#line 10976 ""
				ninow = *(unsigned char *)durq - 48;
#line 10977 ""
			    }
#line 10978 ""
			    if (ninow > comkeys_1.noinst) {
#line 10979 ""
				i__1 = c1omnotes_1.ibarcnt - 
					c1omnotes_1.ibaroff + a1ll_2.nbars + 
					1;
#line 10979 ""
				errmsg_(lineq, &a1ll_2.iccount, &i__1, "New "\
					"number of instruments must be <= ori"\
					"ginal!", (ftnlen)128, (ftnlen)46);
#line 10981 ""
				stop1_();
#line 10982 ""
			    }
#line 10983 ""
			    i__1 = ninow;
#line 10983 ""
			    for (iinow = 1; iinow <= i__1; ++iinow) {
#line 10984 ""
				g1etchar_(lineq, &a1ll_2.iccount, durq, (
					ftnlen)128, (ftnlen)1);
#line 10985 ""
				if (*(unsigned char *)durq == ':') {

/*  Signals a 2-digit number */

#line 10989 ""
				    g1etchar_(lineq, &a1ll_2.iccount, durq, (
					    ftnlen)128, (ftnlen)1);
#line 10990 ""
				    g1etchar_(lineq, &a1ll_2.iccount, dumq, (
					    ftnlen)128, (ftnlen)1);
#line 10991 ""
				    if (i_indx("12", durq, (ftnlen)2, (ftnlen)
					    1) == 0 || i_indx("0123456789", 
					    dumq, (ftnlen)10, (ftnlen)1) == 0)
					     {
#line 10993 ""
					i__4 = c1omnotes_1.ibarcnt - 
						c1omnotes_1.ibaroff + 
						a1ll_2.nbars + 1;
/* Writing concatenation */
#line 10993 ""
					i__8[0] = 34, a__3[0] = "Illegal 2-d"\
						"igit instrument number ";
#line 10993 ""
					i__8[1] = 1, a__3[1] = durq;
#line 10993 ""
					i__8[2] = 1, a__3[2] = dumq;
#line 10993 ""
					i__8[3] = 19, a__3[3] = " at movemen"\
						"t break!";
#line 10993 ""
					s_cat(ch__5, a__3, i__8, &c__4, (
						ftnlen)55);
#line 10993 ""
					errmsg_(lineq, &a1ll_2.iccount, &i__4,
						 ch__5, (ftnlen)128, (ftnlen)
						55);
#line 10996 ""
					stop1_();
#line 10997 ""
				    }
#line 10998 ""
				    i__4 = a1ll_2.iccount - 2;
#line 10998 ""
				    ici__1.icierr = 0;
#line 10998 ""
				    ici__1.iciend = 0;
#line 10998 ""
				    ici__1.icirnum = 1;
#line 10998 ""
				    ici__1.icirlen = a1ll_2.iccount - i__4;
#line 10998 ""
				    ici__1.iciunit = lineq + i__4;
#line 10998 ""
				    ici__1.icifmt = "(i2)";
#line 10998 ""
				    s_rsfi(&ici__1);
#line 10998 ""
				    do_fio(&c__1, (char *)&iorig, (ftnlen)
					    sizeof(integer));
#line 10998 ""
				    e_rsfi();
#line 10999 ""
				} else {

/*  durq is a single digit number for iorig */

#line 11003 ""
				    if (i_indx("123456789", durq, (ftnlen)9, (
					    ftnlen)1) == 0) {
#line 11004 ""
					i__4 = c1omnotes_1.ibarcnt - 
						c1omnotes_1.ibaroff + 
						a1ll_2.nbars + 1;
/* Writing concatenation */
#line 11004 ""
					i__2[0] = 26, a__1[0] = "Illegal ins"\
						"trument number ";
#line 11004 ""
					i__2[1] = 1, a__1[1] = durq;
#line 11004 ""
					i__2[2] = 19, a__1[2] = " at movemen"\
						"t break!";
#line 11004 ""
					s_cat(ch__7, a__1, i__2, &c__3, (
						ftnlen)46);
#line 11004 ""
					errmsg_(lineq, &a1ll_2.iccount, &i__4,
						 ch__7, (ftnlen)128, (ftnlen)
						46);
#line 11007 ""
					stop1_();
#line 11008 ""
				    }
#line 11009 ""
				    iorig = *(unsigned char *)durq - 48;
#line 11010 ""
				}
#line 11011 ""
				if (iorig > comkeys_1.noinst) {
#line 11012 ""
				    i__4 = c1omnotes_1.ibarcnt - 
					    c1omnotes_1.ibaroff + 
					    a1ll_2.nbars + 1;
#line 11012 ""
				    errmsg_(lineq, &a1ll_2.iccount, &i__4, 
					    "New instrument number must be <"\
					    "= original noinst!", (ftnlen)128, 
					    (ftnlen)49);
#line 11014 ""
				    stop1_();
#line 11015 ""
				}
#line 11016 ""
				a1ll_2.nv += c1omget_1.nsperi[iorig - 1];
#line 11017 ""
/* L63: */
#line 11017 ""
			    }
#line 11018 ""
			    i__1 = a1ll_2.nv;
#line 11018 ""
			    for (iiv = 1; iiv <= i__1; ++iiv) {

/*  Get clef names */

#line 11022 ""
				g1etchar_(lineq, &a1ll_2.iccount, durq, (
					ftnlen)128, (ftnlen)1);
#line 11023 ""
				if (! (i_indx("tsmanrbf", durq, (ftnlen)8, (
					ftnlen)1) > 0 || *(unsigned char *)
					durq >= 48 && *(unsigned char *)durq 
					<= 56)) {
/*     *             (ichar(durq).ge.48 .and. ichar(durq).le.55))) then */
#line 11026 ""
				    i__4 = c1omnotes_1.ibarcnt - 
					    c1omnotes_1.ibaroff + 
					    a1ll_2.nbars + 1;
#line 11026 ""
				    errmsg_(lineq, &a1ll_2.iccount, &i__4, 
					    "Must have t,s,m,a,n,r,b,f or 1-"\
					    "7 as clef symbol here!", (ftnlen)
					    128, (ftnlen)53);
#line 11028 ""
				    stop1_();
#line 11029 ""
				}

/*  Initialize new voices */

#line 11033 ""
				c1ommvl_1.nvmx[iiv - 1] = 1;
#line 11034 ""
				c1ommvl_1.ivmx[iiv - 1] = iiv;
#line 11035 ""
				a1ll_2.itsofar[iiv - 1] = 0;
#line 11036 ""
				a1ll_2.nnl[iiv - 1] = 0;
#line 11037 ""
				for (j = 1; j <= 200; ++j) {
#line 11038 ""
				    a1ll_2.rest[iiv + j * 24 - 25] = FALSE_;
#line 11039 ""
/* L62: */
#line 11039 ""
				}
#line 11040 ""
/* L61: */
#line 11040 ""
			    }

/*  Loop back up, this might not be last option in M */

#line 11044 ""
			    g1etchar_(lineq, &a1ll_2.iccount, durq, (ftnlen)
				    128, (ftnlen)1);
#line 11045 ""
			    goto L31;
#line 11046 ""
			} else if (*(unsigned char *)durq == 'S') {
#line 11047 ""
			    goto L49;
#line 11048 ""
			} else if (*(unsigned char *)durq != ' ') {
#line 11049 ""
			    i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff 
				    + a1ll_2.nbars + 1;
#line 11049 ""
			    errmsg_(lineq, &a1ll_2.iccount, &i__1, "Illegal "\
				    "character after Movement break symbol!", (
				    ftnlen)128, (ftnlen)46);
#line 11051 ""
			    stop1_();
#line 11052 ""
			}
#line 11053 ""
			if (compage_1.fracsys[compage_1.nmovbrk - 1] < .001f) 
				{

/*  Since fracsys was not explicitly set, set it to prior value. */

#line 11057 ""
			    if (compage_1.nmovbrk == 1) {
#line 11058 ""
				compage_1.fracsys[compage_1.nmovbrk - 1] = 
					c1omget_1.fracindent;
#line 11059 ""
			    } else {
#line 11060 ""
				compage_1.fracsys[compage_1.nmovbrk - 1] = 
					compage_1.fracsys[compage_1.nmovbrk - 
					2];
#line 11061 ""
			    }
#line 11062 ""
			}
#line 11063 ""
		    }

/*  Just before exiting if-block for forced line breaks, set counter to use when */
/*  dealing with vertical space calcs */

#line 11068 ""
		    compage_1.nistaff[compage_1.nflb] = a1ll_2.nv - 1;
#line 11069 ""
		} else if (*(unsigned char *)charq == 'F') {
#line 11070 ""
		    compage_1.usefig = FALSE_;
#line 11071 ""
		} else if (*(unsigned char *)charq == 'X') {
#line 11072 ""
		    i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			    a1ll_2.nbars + 1;
#line 11072 ""
		    g1etx_(lineq, &a1ll_2.iccount, &comkeys_1.shifton, &i__1, 
			    &c1omnotes_1.udsp[c1omnotes_1.ibarcnt + 
			    a1ll_2.nbars], &c1omnotes_1.wheadpt, (ftnlen)128);
#line 11074 ""
		} else if (*(unsigned char *)charq == 'I') {

/*  MIDI settings. */

#line 11078 ""
		    if (c1ommvl_1.ivx != 1 || a1ll_2.nnl[0] != 0) {
#line 11079 ""
			i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 11079 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__1, "MIDI stuff o"\
				"nly allowed at start of block!", (ftnlen)128, 
				(ftnlen)42);
#line 11081 ""
			stop1_();
#line 11082 ""
		    }
#line 11083 ""
		    if (a1ll_2.nv > 15) {
#line 11084 ""
			i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
				a1ll_2.nbars + 1;
#line 11084 ""
			errmsg_(lineq, &a1ll_2.iccount, &i__1, "Sorry but MI"\
				"DI does not work with more than 15 voices!", (
				ftnlen)128, (ftnlen)54);
#line 11086 ""
			stop1_();
#line 11087 ""
		    }
#line 11088 ""
		    commidi_1.ismidi = TRUE_;
#line 11089 ""
		    getmidi_(&comkeys_1.noinst, lineq, &a1ll_2.iccount, &
			    c1omnotes_1.ibarcnt, &c1omnotes_1.ibaroff, &
			    a1ll_2.nbars, &a1ll_2.lenbar, &mtrdenl, &
			    a1ll_2.nv, &c_true, (ftnlen)128);
#line 11091 ""
		} else if (*(unsigned char *)charq == 'M') {
#line 11092 ""
		    setmac_(lineq, &a1ll_2.iccount, &c1omnotes_1.ibarcnt, &
			    c1omnotes_1.ibaroff, &a1ll_2.nbars, charq, durq, &
			    c1ommvl_1.ivx, &c1omget_1.nline, (ftnlen)128, (
			    ftnlen)1, (ftnlen)1);
#line 11094 ""
		} else if (i_indx(",.", charq, (ftnlen)2, (ftnlen)1) > 0) {

/*  Continued rhythmic shortcut */

#line 11098 ""
		    idotform = i_indx(". ,", charq, (ftnlen)3, (ftnlen)1);
#line 11099 ""
		    if (idotform == 1) {

/*  Change duration of prior note */

#line 11103 ""
			a1ll_2.itsofar[c1ommvl_1.ivx - 1] -= a1ll_2.nodur[
				c1ommvl_1.ivx + a1ll_2.nnl[c1ommvl_1.ivx - 1] 
				* 24 - 25];
#line 11104 ""
			a1ll_2.nodur[c1ommvl_1.ivx + a1ll_2.nnl[c1ommvl_1.ivx 
				- 1] * 24 - 25] = a1ll_2.nodur[c1ommvl_1.ivx 
				+ a1ll_2.nnl[c1ommvl_1.ivx - 1] * 24 - 25] * 
				3 / 2;
#line 11105 ""
			a1ll_2.itsofar[c1ommvl_1.ivx - 1] += a1ll_2.nodur[
				c1ommvl_1.ivx + a1ll_2.nnl[c1ommvl_1.ivx - 1] 
				* 24 - 25];
#line 11106 ""
		    }
#line 11107 ""
		    ++idotform;
#line 11108 ""
		    numnum = 1;
#line 11109 ""
		    cdot = TRUE_;
#line 11110 ""
		    goto L1;
#line 11111 ""
		} else {
#line 11112 ""
		    s_wsle(&io___701);
#line 11112 ""
		    do_lio(&c__9, &c__1, "ASCII code:", (ftnlen)11);
#line 11112 ""
		    i__1 = *(unsigned char *)charq;
#line 11112 ""
		    do_lio(&c__3, &c__1, (char *)&i__1, (ftnlen)sizeof(
			    integer));
#line 11112 ""
		    e_wsle();
#line 11113 ""
		    i__1 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			    a1ll_2.nbars + 1;
#line 11113 ""
		    errmsg_(lineq, &a1ll_2.iccount, &i__1, "This character i"\
			    "s not allowed here!", (ftnlen)128, (ftnlen)35);
#line 11115 ""
		    s_wsle(&io___702);
#line 11115 ""
		    do_lio(&c__9, &c__1, "ASCII code:", (ftnlen)11);
#line 11115 ""
		    i__1 = *(unsigned char *)charq;
#line 11115 ""
		    do_lio(&c__3, &c__1, (char *)&i__1, (ftnlen)sizeof(
			    integer));
#line 11115 ""
		    e_wsle();
#line 11116 ""
		    stop1_();
#line 11117 ""
		}
#line 11117 ""
	    }
#line 11117 ""
	}
#line 11117 ""
    }
#line 11118 ""
    return 0;
} /* g1etnote_ */

/* Subroutine */ int g1etset_(integer *nv, integer *noinst, integer *mtrnuml, 
	integer *mtrdenl, integer *mtrnmp, integer *mtrdnp, real *xmtrnum0, 
	integer *newkey, integer *npages, integer *nsyst, integer *musize, 
	logical *bottreb)
{
    /* System generated locals */
    address a__1[2], a__2[3];
    integer i__1, i__2[2], i__3[3];
    real r__1;
    char ch__1[3], ch__2[1], ch__3[50];

    /* Builtin functions */
    integer s_cmp(char *, char *, ftnlen, ftnlen), s_wsle(cilist *), do_lio(
	    integer *, integer *, char *, ftnlen), e_wsle(void), i_nint(real *
	    ), s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(
	    void), i_indx(char *, char *, ftnlen, ftnlen);
    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);

    /* Local variables */
    static integer i__, iv;
    extern /* Character */ VOID chax_(char *, ftnlen, integer *);
    extern /* Subroutine */ int stop1_(void);
    static char lineq[128];
    static integer lpath, iinst;
    extern doublereal readin_(char *, integer *, integer *, ftnlen);
    extern /* Subroutine */ int getbuf_(char *, ftnlen), errmsg_(char *, 
	    integer *, integer *, char *, ftnlen, ftnlen), printl_(char *, 
	    ftnlen);
    static logical newway;
    static integer iccount;

    /* Fortran I/O blocks */
    static cilist io___705 = { 0, 6, 0, 0, 0 };
    static cilist io___706 = { 0, 6, 0, "(1x,a46,i3)", 0 };
    static cilist io___707 = { 0, 6, 0, "(a)", 0 };
    static cilist io___710 = { 0, 6, 0, "(a)", 0 };
    static cilist io___711 = { 0, 6, 0, "(a)", 0 };
    static cilist io___712 = { 0, 6, 0, 0, 0 };



/*  Get the first line */

#line 11136 ""
    iccount = 0;
#line 11137 ""
    c1omget_1.nline = 1;
#line 11138 ""
L9:
#line 11138 ""
    getbuf_(lineq, (ftnlen)128);
#line 11139 ""
    if (*(unsigned char *)lineq == '%') {
#line 11140 ""
	++c1omget_1.nline;
#line 11141 ""
	goto L9;
#line 11142 ""
    }
#line 11143 ""
    if (s_cmp(lineq, "---", (ftnlen)3, (ftnlen)3) == 0) {

/*  Have TeX input until next line that starts with '---' */

#line 11147 ""
L3:
#line 11147 ""
	++c1omget_1.nline;
#line 11148 ""
	getbuf_(lineq, (ftnlen)128);
#line 11149 ""
	if (inbuff_1.ilbuf > inbuff_1.nlbuf) {
#line 11149 ""
	    goto L1;
#line 11149 ""
	}
#line 11150 ""
	goto L2;
#line 11151 ""
L1:
#line 11151 ""
	s_wsle(&io___705);
#line 11151 ""
	do_lio(&c__9, &c__1, "You did not terminate type 0 TeX input with \""\
		"---\"", (ftnlen)49);
#line 11151 ""
	e_wsle();
#line 11152 ""
	stop1_();
#line 11153 ""
L2:
#line 11154 ""
	if (s_cmp(lineq, "---", (ftnlen)3, (ftnlen)3) != 0) {
#line 11154 ""
	    goto L3;
#line 11154 ""
	}

/*  Force a new line read on first call to readin */

#line 11158 ""
	iccount = 128;
#line 11159 ""
    }

/*  Here, lineq and nline are first non-TeX lines. */

#line 11163 ""
    r__1 = readin_(lineq, &iccount, &c1omget_1.nline, (ftnlen)128);
#line 11163 ""
    *nv = i_nint(&r__1);
#line 11164 ""
    if (*nv > 24) {
#line 11165 ""
	s_wsfe(&io___706);
#line 11165 ""
	do_fio(&c__1, "In setup data, number of voices cannot exceed", (
		ftnlen)45);
#line 11165 ""
	do_fio(&c__1, (char *)&c__24, (ftnlen)sizeof(integer));
#line 11165 ""
	e_wsfe();
#line 11167 ""
	stop1_();
#line 11168 ""
    }
#line 11169 ""
    r__1 = readin_(lineq, &iccount, &c1omget_1.nline, (ftnlen)128);
#line 11169 ""
    *noinst = i_nint(&r__1);
#line 11170 ""
    if (*noinst > *nv) {
#line 11171 ""
	s_wsfe(&io___707);
#line 11171 ""
	do_fio(&c__1, "In setup data, cannot have more instruments than stav"\
		"es", (ftnlen)55);
#line 11171 ""
	e_wsfe();
#line 11173 ""
	stop1_();
#line 11174 ""
    }
#line 11175 ""
    newway = *noinst <= 0;
#line 11176 ""
    if (newway) {
#line 11176 ""
	*noinst = -(*noinst);
#line 11176 ""
    }
#line 11177 ""
    i__1 = *noinst;
#line 11177 ""
    for (iinst = 1; iinst <= i__1; ++iinst) {

/*  Seve # of staves per inst in case later drop some inst's. */

#line 11181 ""
	if (newway) {
#line 11182 ""
	    r__1 = readin_(lineq, &iccount, &c1omget_1.nline, (ftnlen)128);
#line 11182 ""
	    c1omget_1.nsperi[iinst - 1] = i_nint(&r__1);
#line 11183 ""
	} else if (iinst > 1) {
#line 11184 ""
	    c1omget_1.nsperi[iinst - 1] = 1;
#line 11185 ""
	} else {
#line 11186 ""
	    c1omget_1.nsperi[iinst - 1] = *nv - *noinst + 1;
#line 11187 ""
	}
#line 11188 ""
/* L10: */
#line 11188 ""
    }
#line 11189 ""
    r__1 = readin_(lineq, &iccount, &c1omget_1.nline, (ftnlen)128);
#line 11189 ""
    *mtrnuml = i_nint(&r__1);
#line 11190 ""
    r__1 = readin_(lineq, &iccount, &c1omget_1.nline, (ftnlen)128);
#line 11190 ""
    *mtrdenl = i_nint(&r__1);
#line 11191 ""
    r__1 = readin_(lineq, &iccount, &c1omget_1.nline, (ftnlen)128);
#line 11191 ""
    *mtrnmp = i_nint(&r__1);
#line 11192 ""
    r__1 = readin_(lineq, &iccount, &c1omget_1.nline, (ftnlen)128);
#line 11192 ""
    *mtrdnp = i_nint(&r__1);
#line 11193 ""
    if (*mtrnmp == 0 && *mtrdnp >= 8) {
#line 11194 ""
	s_wsfe(&io___710);
#line 11194 ""
	do_fio(&c__1, "In setup data, with mtrnmp=0, mtrdnp must be <8", (
		ftnlen)47);
#line 11194 ""
	e_wsfe();
#line 11195 ""
	stop1_();
#line 11196 ""
    }
#line 11197 ""
    *xmtrnum0 = readin_(lineq, &iccount, &c1omget_1.nline, (ftnlen)128);
#line 11198 ""
    r__1 = readin_(lineq, &iccount, &c1omget_1.nline, (ftnlen)128);
#line 11198 ""
    *newkey = i_nint(&r__1);
#line 11199 ""
    commidisig_1.midisig = *newkey;
#line 11200 ""
    r__1 = readin_(lineq, &iccount, &c1omget_1.nline, (ftnlen)128);
#line 11200 ""
    *npages = i_nint(&r__1);
#line 11201 ""
    r__1 = readin_(lineq, &iccount, &c1omget_1.nline, (ftnlen)128);
#line 11201 ""
    *nsyst = i_nint(&r__1);
#line 11202 ""
    r__1 = readin_(lineq, &iccount, &c1omget_1.nline, (ftnlen)128);
#line 11202 ""
    *musize = i_nint(&r__1);
#line 11203 ""
    c1omget_1.fracindent = readin_(lineq, &iccount, &c1omget_1.nline, (ftnlen)
	    128);
#line 11204 ""
    if (c1omget_1.fracindent >= 1.f) {
#line 11205 ""
	s_wsfe(&io___711);
#line 11205 ""
	do_fio(&c__1, "In setup data, fracindent must be <1", (ftnlen)36);
#line 11205 ""
	e_wsfe();
#line 11206 ""
	stop1_();
#line 11207 ""
    }
#line 11208 ""
    if (*npages > *nsyst) {
#line 11209 ""
	s_wsle(&io___712);
#line 11209 ""
	do_lio(&c__9, &c__1, "Error in input file: npages > nsyst", (ftnlen)
		35);
#line 11209 ""
	e_wsle();
#line 11210 ""
	stop1_();
#line 11211 ""
    } else if ((*musize - 16) * (*musize - 20) * (*musize - 24) * (*musize - 
	    29) != 0) {
#line 11212 ""
	printl_("Musicsize must be 16, 20, 24, or 29", (ftnlen)35);
#line 11213 ""
	stop1_();
#line 11214 ""
    }

/*  Next noinst non-comment lines are names of instruments. */

#line 11218 ""
    i__1 = abs(*noinst);
#line 11218 ""
    for (i__ = 1; i__ <= i__1; ++i__) {
#line 11219 ""
L5:
#line 11219 ""
	getbuf_(lineq, (ftnlen)128);
#line 11220 ""
	++c1omget_1.nline;
#line 11221 ""
	if (*(unsigned char *)lineq == '%') {
#line 11221 ""
	    goto L5;
#line 11221 ""
	}
#line 11222 ""
/* L4: */
#line 11222 ""
    }

/*  Mext non-comment line has nv clef names */

#line 11226 ""
L6:
#line 11226 ""
    getbuf_(lineq, (ftnlen)128);
#line 11227 ""
    ++c1omget_1.nline;
#line 11228 ""
    if (*(unsigned char *)lineq == '%') {
#line 11228 ""
	goto L6;
#line 11228 ""
    }
#line 11229 ""
    i__1 = *nv;
#line 11229 ""
    for (iv = 1; iv <= i__1; ++iv) {
/*        if (index('brnamstf01234567',lineq(iv:iv)) .eq. 0) then */
#line 11231 ""
	if (i_indx("brnamstf012345678", lineq + (iv - 1), (ftnlen)17, (ftnlen)
		1) == 0) {
#line 11232 ""
	    errmsg_(lineq, &iv, &c__0, "There should be a clef symbol here!", 
		    (ftnlen)128, (ftnlen)35);
#line 11234 ""
	    stop1_();
#line 11235 ""
	}
#line 11236 ""
/* L7: */
#line 11236 ""
    }
#line 11237 ""
    i__1 = *nv;
#line 11237 ""
    if (s_cmp(lineq + i__1, " ", *nv + 1 - i__1, (ftnlen)1) != 0) {
#line 11238 ""
	i__1 = *nv + 1;
#line 11238 ""
	errmsg_(lineq, &i__1, &c__0, "There should be a blank here!", (ftnlen)
		128, (ftnlen)29);
#line 11240 ""
	stop1_();
#line 11241 ""
    }

/* Set flag if voice 1 is treble, since it affects vertical spacing */

/*      bottreb = lineq(1:1).eq.'t' */
#line 11246 ""
    *bottreb = i_indx("t08", lineq, (ftnlen)3, (ftnlen)1) > 0;

/*  Next non-comment line has path name */

#line 11250 ""
L8:
#line 11250 ""
    getbuf_(lineq, (ftnlen)128);
#line 11251 ""
    ++c1omget_1.nline;
#line 11252 ""
    if (*(unsigned char *)lineq == '%') {
#line 11252 ""
	goto L8;
#line 11252 ""
    }
#line 11253 ""
    lpath = i_indx(lineq, " ", (ftnlen)128, (ftnlen)1) - 1;
/* Writing concatenation */
#line 11254 ""
    i__2[0] = 2, a__1[0] = "/:";
#line 11254 ""
    chax_(ch__2, (ftnlen)1, &c__92);
#line 11254 ""
    i__2[1] = 1, a__1[1] = ch__2;
#line 11254 ""
    s_cat(ch__1, a__1, i__2, &c__2, (ftnlen)3);
#line 11254 ""
    if (i_indx(ch__1, lineq + (lpath - 1), (ftnlen)3, (ftnlen)1) == 0) {
/* Writing concatenation */
#line 11255 ""
	i__3[0] = 47, a__2[0] = "Last character of pathname is not \"/\",\""\
		":\", or \"";
#line 11255 ""
	chax_(ch__2, (ftnlen)1, &c__92);
#line 11255 ""
	i__3[1] = 1, a__2[1] = ch__2;
#line 11255 ""
	i__3[2] = 2, a__2[2] = "\"!";
#line 11255 ""
	s_cat(ch__3, a__2, i__3, &c__3, (ftnlen)50);
#line 11255 ""
	errmsg_(lineq, &lpath, &c__0, ch__3, (ftnlen)128, (ftnlen)50);
#line 11258 ""
	stop1_();
#line 11259 ""
    }
#line 11260 ""
    return 0;
} /* g1etset_ */

/* Subroutine */ int g1etx_(char *lineq, integer *iccount, logical *shifton, 
	integer *ibar, real *udsp, real *wheadpt, ftnlen lineq_len)
{
    /* System generated locals */
    integer i__1;

    /* Builtin functions */
    integer i_indx(char *, char *, ftnlen, ftnlen);

    /* Local variables */
    static real fnum;
    static char dumq[1];
    extern /* Subroutine */ int stop1_(void);
    static char charq[1];
    static integer ipbsc, npbsc;
    static logical number;
    extern /* Subroutine */ int errmsg_(char *, integer *, integer *, char *, 
	    ftnlen, ftnlen), readnum_(char *, integer *, char *, real *, 
	    ftnlen, ftnlen), g1etchar_(char *, integer *, char *, ftnlen, 
	    ftnlen);


/*  Parse "X" commands.  Ignore all "B"; "P" means to ignore whole symbol. */
/*  In scor2prt, must strip out "P", copy only "B" and "P"-type "X"-symbols. */

#line 11270 ""
    number = FALSE_;
#line 11271 ""
    npbsc = 0;
#line 11272 ""
L1:
#line 11272 ""
    g1etchar_(lineq, iccount, charq, (ftnlen)128, (ftnlen)1);
#line 11273 ""
    if (i_indx("PBS:", charq, (ftnlen)4, (ftnlen)1) > 0) {

/*  Continue checking here even if "P". */

#line 11277 ""
	ipbsc = i_indx("PBS:", charq, (ftnlen)4, (ftnlen)1);
#line 11278 ""
	if (bit_test(npbsc,ipbsc)) {
#line 11279 ""
	    errmsg_(lineq, iccount, ibar, "Only one allowed per symbol!", (
		    ftnlen)128, (ftnlen)28);
#line 11280 ""
	    stop1_();
#line 11281 ""
	}
#line 11282 ""
	npbsc = bit_set(npbsc,ipbsc);
#line 11283 ""
	goto L1;
#line 11284 ""
    } else if (i_indx("+-.0123456789", charq, (ftnlen)13, (ftnlen)1) > 0) {
#line 11285 ""
	number = TRUE_;
#line 11286 ""
	if (i_indx("+-", charq, (ftnlen)2, (ftnlen)1) > 0) {
#line 11287 ""
	    g1etchar_(lineq, iccount, dumq, (ftnlen)128, (ftnlen)1);
#line 11288 ""
	    if (i_indx(".0123456789", dumq, (ftnlen)11, (ftnlen)1) == 0) {
#line 11289 ""
		errmsg_(lineq, iccount, ibar, "Expected a number here!", (
			ftnlen)128, (ftnlen)23);
#line 11290 ""
		stop1_();
#line 11291 ""
	    }
#line 11292 ""
	}
#line 11293 ""
	readnum_(lineq, iccount, dumq, &fnum, (ftnlen)128, (ftnlen)1);
#line 11294 ""
	if (*(unsigned char *)charq == '-') {
#line 11294 ""
	    fnum = -fnum;
#line 11294 ""
	}
#line 11295 ""
	if (*(unsigned char *)dumq != 'p') {
#line 11296 ""
	    --(*iccount);
#line 11297 ""
	    fnum *= *wheadpt;
#line 11298 ""
	}
#line 11299 ""
	goto L1;
#line 11300 ""
    } else if (*(unsigned char *)charq != ' ') {
#line 11301 ""
	errmsg_(lineq, iccount, ibar, "Not allowed in \"X\" symbol!", (ftnlen)
		128, (ftnlen)26);
#line 11302 ""
	stop1_();
#line 11303 ""
    }

/*  Done with parsing.  Other checks */

#line 11307 ""
    if ((6 & npbsc) == 6 || (24 & npbsc) == 24) {
#line 11308 ""
	i__1 = *iccount - 1;
#line 11308 ""
	errmsg_(lineq, &i__1, ibar, "Cannot have both \"P\" and \"B\" or \""\
		"S\" and \":\"!", (ftnlen)128, (ftnlen)44);
#line 11310 ""
	stop1_();
#line 11311 ""
    }
#line 11312 ""
    if (bit_test(npbsc,4)) {
#line 11313 ""
	if (number) {
#line 11314 ""
	    if (*shifton) {
#line 11315 ""
		i__1 = *iccount - 1;
#line 11315 ""
		errmsg_(lineq, &i__1, ibar, "Started a group shift without s"\
			"topping prior one!", (ftnlen)128, (ftnlen)49);
#line 11317 ""
		stop1_();
#line 11318 ""
	    } else {
#line 11319 ""
		*shifton = TRUE_;
#line 11320 ""
	    }
#line 11321 ""
	} else {
#line 11322 ""
	    if (! (*shifton)) {
#line 11323 ""
		i__1 = *iccount - 1;
#line 11323 ""
		errmsg_(lineq, &i__1, ibar, "Ended a group shift without sta"\
			"rting one!", (ftnlen)128, (ftnlen)41);
#line 11325 ""
		stop1_();
#line 11326 ""
	    } else {
#line 11327 ""
		*shifton = FALSE_;
#line 11328 ""
	    }
#line 11329 ""
	}
#line 11330 ""
    }

/*  P off, S off, c off => normal user-defined space.  Add to udsp (later fsyst) */

#line 11334 ""
    if ((npbsc & 26) == 0) {
#line 11334 ""
	*udsp += fnum;
#line 11334 ""
    }
#line 11335 ""
    if (! number && ! bit_test(npbsc,4)) {
#line 11336 ""
	i__1 = *iccount - 1;
#line 11336 ""
	errmsg_(lineq, &i__1, ibar, "Must have either a number or a colon "\
		"in \"X\" symbol!", (ftnlen)128, (ftnlen)51);
#line 11338 ""
	stop1_();
#line 11339 ""
    }
#line 11340 ""
    return 0;
} /* g1etx_ */

/* Subroutine */ int getbuf_(char *lineq, ftnlen lineq_len)
{
    /* System generated locals */
    integer i__1;

    /* Builtin functions */
    /* Subroutine */ int s_copy(char *, char *, ftnlen, ftnlen);

#line 11348 ""
    i__1 = inbuff_1.ipbuf;
#line 11348 ""
    s_copy(lineq, inbuff_1.bufq + i__1, lineq_len, inbuff_1.ipbuf + 
	    inbuff_1.lbuf[inbuff_1.ilbuf - 1] - i__1);
#line 11349 ""
    inbuff_1.ipbuf += inbuff_1.lbuf[inbuff_1.ilbuf - 1];
#line 11350 ""
    ++inbuff_1.ilbuf;
#line 11351 ""
    return 0;
} /* getbuf_ */

/* Subroutine */ int getchar_(char *lineq, integer *iccount, char *charq, 
	ftnlen lineq_len, ftnlen charq_len)
{
    /* Builtin functions */
    /* Subroutine */ int s_copy(char *, char *, ftnlen, ftnlen);

    /* Local variables */
    static integer ndxm;
    extern /* Subroutine */ int mrec1_(char *, integer *, integer *, ftnlen), 
	    read10_(char *, logical *, ftnlen);


/*  Gets the next character out of lineq*128.  If pointer iccount=128 on entry, */
/*  then reads in a new line.  Resets iccount.  Ends program if no more input. */

#line 11367 ""
    if (*iccount == 128) {
#line 11368 ""
	read10_(lineq, &comget_1.lastchar, (ftnlen)128);
#line 11369 ""
	if (comget_1.lastchar) {
#line 11369 ""
	    return 0;
#line 11369 ""
	}
#line 11370 ""
	if (! commac_1.endmac) {
#line 11371 ""
	    *iccount = 0;
#line 11372 ""
	} else {
#line 11373 ""
	    commac_1.endmac = FALSE_;
#line 11374 ""
	    *iccount = commac_1.icchold;
#line 11375 ""
	    s_copy(lineq, commac_1.lnholdq, (ftnlen)128, (ftnlen)128);
#line 11376 ""
	}
#line 11377 ""
	if (commac_1.mrecord) {
#line 11378 ""
	    mrec1_(lineq, iccount, &ndxm, (ftnlen)128);
#line 11379 ""
	}
#line 11380 ""
    }
#line 11381 ""
    ++(*iccount);
#line 11382 ""
    *(unsigned char *)charq = *(unsigned char *)&lineq[*iccount - 1];
#line 11383 ""
    return 0;
} /* getchar_ */

/* Subroutine */ int getdyn_(integer *ivx, integer *ip, integer *irest, 
	integer *iornq, char *lineq, integer *iccount, ftnlen lineq_len)
{
    /* System generated locals */
    address a__1[3];
    integer i__1, i__2[3], i__3;
    real r__1;
    char ch__1[1], ch__2[4];
    icilist ici__1;

    /* Builtin functions */
    integer s_cmp(char *, char *, ftnlen, ftnlen), i_indx(char *, char *, 
	    ftnlen, ftnlen);
    /* Subroutine */ int s_copy(char *, char *, ftnlen, ftnlen), s_cat(char *,
	     char **, integer *, integer *, ftnlen);
    integer s_rsfi(icilist *), do_fio(integer *, char *, ftnlen), e_rsfi(void)
	    , i_nint(real *);

    /* Local variables */
    static integer iccountt, ipm, iend;
    extern /* Character */ VOID chax_(char *, ftnlen, integer *);
    static integer idno, idyn;
    static real fnum;
    static char durq[1];
    static integer idno1;
    extern /* Subroutine */ int stop1_(void), printl_(char *, ftnlen), 
	    readnum_(char *, integer *, char *, real *, ftnlen, ftnlen), 
	    setbits_(integer *, integer *, integer *, integer *);
    static char dynsymq[4];


/*  Get info for dynamic mark.  Enter after getting "D", iccount sits on "D" */
/*  Bits in idyndat are as follows */
/*    00-03 ivx */
/*    04-11 ip */
/*    12-15 code for type of mark */
/*      0 => arbitrary text */
/*      1-12 => pppp,ppp,pp,p,mp,mf,f,fp,sfz,ff,fff,ffff */
/*      If (.not. fontslur) */
/*        13 => hairpin start, 14,15 => <,> (ending) */
/*      else */
/*         13 < start, 14 > start, 15 ending */
/*      end if */
/*    16    flag for vertical offset */
/*    17-23 vertical offset + 64 , \internote */
/*    31    Hairpin start (0), stop (1) */

/*  idynda2 */

/*    00    flag for horizontal offset */
/*    01-09 (horizontal offset)/10 + 25.6 notehead widths */
/*    10  5th bit for ivx (5/15/10) */

#line 11420 ""
    *irest = bit_set(*irest,26);
#line 11421 ""
    ++comdyn_1.ndyn;
#line 11422 ""
    idyn = *ivx;
#line 11423 ""
    comdyn_1.idynda2[comdyn_1.ndyn - 1] = 0;
#line 11424 ""
    if (*ivx >= 16) {
#line 11424 ""
	setbits_(&comdyn_1.idynda2[comdyn_1.ndyn - 1], &c__1, &c__10, &c__1);
#line 11424 ""
    }
#line 11425 ""
    setbits_(&idyn, &c__8, &c__4, ip);
#line 11426 ""
    i__1 = *iccount;
#line 11426 ""
    chax_(ch__1, (ftnlen)1, &c__34);
#line 11426 ""
    if (s_cmp(lineq + i__1, ch__1, *iccount + 1 - i__1, (ftnlen)1) == 0) {

/*  text-dynamic */

#line 11430 ""
	++comdyn_1.ntxtdyn;
#line 11431 ""
	iccountt = *iccount;
#line 11432 ""
L3:
#line 11433 ""
	i__1 = iccountt + 1;
#line 11433 ""
	chax_(ch__1, (ftnlen)1, &c__34);
#line 11433 ""
	iend = iccountt + i_indx(lineq + i__1, ch__1, 128 - i__1, (ftnlen)1) 
		+ 2;
#line 11434 ""
	i__1 = iend - 3;
#line 11434 ""
	chax_(ch__1, (ftnlen)1, &c__92);
#line 11434 ""
	if (s_cmp(lineq + i__1, ch__1, iend - 2 - i__1, (ftnlen)1) == 0) {
#line 11435 ""
	    iccountt = iend - 2;
#line 11436 ""
	    goto L3;
#line 11437 ""
	}
#line 11438 ""
	i__1 = *iccount + 1;
#line 11438 ""
	s_copy(comdyn_1.txtdynq + (comdyn_1.ntxtdyn - 1 << 7), lineq + i__1, (
		ftnlen)128, iend - 2 - i__1);

/*  Store ivx, ip in bits 0-12 */

#line 11442 ""
	comdyn_1.ivxiptxt[comdyn_1.ntxtdyn - 1] = *ivx + (*ip << 5);
#line 11443 ""
	ipm = i_indx("- +", lineq + (iend - 1), (ftnlen)3, (ftnlen)1);
#line 11444 ""
	idno = 0;
#line 11445 ""
    } else {

/*  Word-group or hairpin */

#line 11449 ""
	for (iend = *iccount + 2; iend <= 128; ++iend) {
#line 11450 ""
	    ipm = i_indx("- +", lineq + (iend - 1), (ftnlen)3, (ftnlen)1);

/*  Exit the loop at first blank, "+", or "-" */

#line 11454 ""
	    if (ipm > 0) {
#line 11454 ""
		goto L2;
#line 11454 ""
	    }
#line 11455 ""
/* L1: */
#line 11455 ""
	}
#line 11456 ""
L2:
#line 11457 ""
	i__1 = *iccount;
#line 11457 ""
	ici__1.icierr = 0;
#line 11457 ""
	ici__1.iciend = 0;
#line 11457 ""
	ici__1.icirnum = 1;
#line 11457 ""
	ici__1.icirlen = iend - 1 - i__1;
#line 11457 ""
	ici__1.iciunit = lineq + i__1;
/* Writing concatenation */
#line 11457 ""
	i__2[0] = 2, a__1[0] = "(a";
#line 11457 ""
	i__3 = iend + 47 - *iccount;
#line 11457 ""
	chax_(ch__1, (ftnlen)1, &i__3);
#line 11457 ""
	i__2[1] = 1, a__1[1] = ch__1;
#line 11457 ""
	i__2[2] = 1, a__1[2] = ")";
#line 11457 ""
	ici__1.icifmt = (s_cat(ch__2, a__1, i__2, &c__3, (ftnlen)4), ch__2);
#line 11457 ""
	s_rsfi(&ici__1);
#line 11457 ""
	do_fio(&c__1, dynsymq, (ftnlen)4);
#line 11457 ""
	e_rsfi();
#line 11459 ""
	idno = (i_indx("ppppppp pp  p   mp  mf  f   fp  sfz ff  fff ffff    "\
		"<   >   ", dynsymq, (ftnlen)60, (ftnlen)4) + 3) / 4;

/*  Save for later down */

#line 11465 ""
	idno1 = idno;
#line 11466 ""
    }

/*  Set flag to check level later if in beam */

#line 11470 ""
    *iornq = bit_set(*iornq,23);
#line 11471 ""
    if (idno >= 14) {

/*  Hairpin here.  Check if opposite type from one that's already on */

#line 11475 ""
	if (idno == 14 && bit_test(comdyn_1.listdecresc,*ivx) || idno == 15 &&
		 bit_test(comdyn_1.listcresc,*ivx)) {
#line 11477 ""
	    printl_(" ", (ftnlen)1);
#line 11478 ""
	    printl_("Started one kind of hairpin while other is on", (ftnlen)
		    45);
#line 11479 ""
	    stop1_();
#line 11480 ""
	}

/*  Start or stop? */

#line 11484 ""
	if (bit_test(comdyn_1.listcresc,*ivx) || bit_test(
		comdyn_1.listdecresc,*ivx)) {

/*  Cresc/decresc is on, this is an ending. If fontslur, leave idno as is. */

#line 11488 ""
	    if (! comslur_1.fontslur) {
#line 11488 ""
		idno = 15;
#line 11488 ""
	    }
#line 11489 ""
	} else if (comslur_1.fontslur) {

/*  Start of font slur */

#line 11493 ""
	    idno = 13;
#line 11494 ""
	} else {

/*  Start of postscript slur */

#line 11498 ""
	    --idno;
#line 11499 ""
	}
#line 11500 ""
    }

/*  Now that we used list[de]cresc, update */

#line 11504 ""
    if (idno >= 13) {
#line 11505 ""
	if (idno == 15 || comslur_1.fontslur && idno == 14) {

/*  Something's ending */

#line 11509 ""
	    if (bit_test(comdyn_1.listcresc,*ivx)) {

/*  It's a cresc! */

#line 11513 ""
		comdyn_1.listcresc = bit_clear(comdyn_1.listcresc,*ivx);
#line 11514 ""
	    } else {
#line 11515 ""
		comdyn_1.listdecresc = bit_clear(comdyn_1.listdecresc,*ivx);
#line 11516 ""
	    }
#line 11517 ""
	} else {

/*  Something's starting */

#line 11521 ""
	    if (idno1 == 14) {

/*  It's a cresc! */

#line 11525 ""
		comdyn_1.listcresc = bit_set(comdyn_1.listcresc,*ivx);
#line 11526 ""
	    } else {
#line 11527 ""
		comdyn_1.listdecresc = bit_set(comdyn_1.listdecresc,*ivx);
#line 11528 ""
	    }
#line 11529 ""
	}
#line 11530 ""
    }
#line 11531 ""
    setbits_(&idyn, &c__4, &c__12, &idno);
#line 11532 ""
    *iccount = iend;
#line 11533 ""
    if (ipm != 2) {

/*  There is a vertical shift */

#line 11537 ""
	idyn = bit_set(idyn,16);
#line 11538 ""
	++(*iccount);
#line 11539 ""
	readnum_(lineq, iccount, durq, &fnum, (ftnlen)128, (ftnlen)1);
#line 11540 ""
	idno = i_nint(&fnum);
#line 11541 ""
	i__1 = (ipm - 2) * idno + 64;
#line 11541 ""
	setbits_(&idyn, &c__7, &c__17, &i__1);
#line 11542 ""
	ipm = i_indx("- +", durq, (ftnlen)3, (ftnlen)1);
#line 11543 ""
	if (ipm != 2) {

/*  There is a horizontal shift */

/*          idynda2(ndyn) = ibset(idyn,23) */
#line 11548 ""
	    comdyn_1.idynda2[comdyn_1.ndyn - 1] = bit_set(comdyn_1.idynda2[
		    comdyn_1.ndyn - 1],0);
#line 11549 ""
	    ++(*iccount);
#line 11550 ""
	    readnum_(lineq, iccount, durq, &fnum, (ftnlen)128, (ftnlen)1);
#line 11551 ""
	    r__1 = fnum * 10;
#line 11551 ""
	    idno = i_nint(&r__1);
#line 11552 ""
	    i__1 = (ipm - 2) * idno + 256;
#line 11552 ""
	    setbits_(&comdyn_1.idynda2[comdyn_1.ndyn - 1], &c__9, &c__1, &
		    i__1);
#line 11553 ""
	}

/*  iccount should be on the blank at the end of the entire symbol */

#line 11557 ""
    }
#line 11558 ""
    comdyn_1.idyndat[comdyn_1.ndyn - 1] = idyn;
#line 11559 ""
    return 0;
} /* getdyn_ */

/* Subroutine */ int getfig_(integer *itoff, char *charq, char *lineq, 
	integer *iccount, logical *isfig, integer *itfig, integer *itsofar, 
	integer *nodur, char *figq, integer *ivupfig, integer *ivvfig, 
	integer *nfigs, ftnlen charq_len, ftnlen lineq_len, ftnlen figq_len)
{
    /* System generated locals */
    address a__1[2];
    integer i__1[2];
    icilist ici__1;

    /* Builtin functions */
    integer s_rsfi(icilist *), do_fio(integer *, char *, ftnlen), e_rsfi(void)
	    ;
    /* Subroutine */ int s_copy(char *, char *, ftnlen, ftnlen);
    integer i_indx(char *, char *, ftnlen, ftnlen);
    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
    integer i_nint(real *);

    /* Local variables */
    static integer lfig, loff, noff;
    static real fnum;
    static integer isign;
    extern /* Subroutine */ int getchar_(char *, integer *, char *, ftnlen, 
	    ftnlen), readnum_(char *, integer *, char *, real *, ftnlen, 
	    ftnlen);
    extern integer ifnodur_(integer *, char *, ftnlen);

#line 11567 ""
    ++(*nfigs);
#line 11568 ""
    *ivupfig = 0;
#line 11569 ""
    *ivvfig = 0;
#line 11570 ""
    *itoff = 0;
#line 11571 ""
    if (*(unsigned char *)charq == 'x') {

/*  Floating figure. */

#line 11575 ""
	getchar_(lineq, iccount, charq, (ftnlen)128, (ftnlen)1);
#line 11576 ""
	ici__1.icierr = 0;
#line 11576 ""
	ici__1.iciend = 0;
#line 11576 ""
	ici__1.icirnum = 1;
#line 11576 ""
	ici__1.icirlen = 1;
#line 11576 ""
	ici__1.iciunit = charq;
#line 11576 ""
	ici__1.icifmt = "(i1)";
#line 11576 ""
	s_rsfi(&ici__1);
#line 11576 ""
	do_fio(&c__1, (char *)&noff, (ftnlen)sizeof(integer));
#line 11576 ""
	e_rsfi();
#line 11577 ""
	getchar_(lineq, iccount, charq, (ftnlen)128, (ftnlen)1);
#line 11578 ""
	ici__1.icierr = 0;
#line 11578 ""
	ici__1.iciend = 0;
#line 11578 ""
	ici__1.icirnum = 1;
#line 11578 ""
	ici__1.icirlen = 1;
#line 11578 ""
	ici__1.iciunit = charq;
#line 11578 ""
	ici__1.icifmt = "(i1)";
#line 11578 ""
	s_rsfi(&ici__1);
#line 11578 ""
	do_fio(&c__1, (char *)&loff, (ftnlen)sizeof(integer));
#line 11578 ""
	e_rsfi();
#line 11579 ""
	*itoff = noff * ifnodur_(&loff, "x", (ftnlen)1);
#line 11580 ""
	getchar_(lineq, iccount, charq, (ftnlen)128, (ftnlen)1);
#line 11581 ""
    } else {

/*  Figure on a note */

#line 11585 ""
	*isfig = TRUE_;
#line 11586 ""
    }
#line 11587 ""
    *itfig = *itsofar + *itoff - *nodur;
#line 11588 ""
    lfig = 1;
#line 11589 ""
    s_copy(figq, charq, (ftnlen)10, (ftnlen)1);
#line 11590 ""
L5:
#line 11590 ""
    getchar_(lineq, iccount, charq, (ftnlen)128, (ftnlen)1);
#line 11591 ""
    if (i_indx(" +v", charq, (ftnlen)3, (ftnlen)1) == 0) {
/* Writing concatenation */
#line 11592 ""
	i__1[0] = lfig, a__1[0] = figq;
#line 11592 ""
	i__1[1] = 1, a__1[1] = charq;
#line 11592 ""
	s_cat(figq, a__1, i__1, &c__2, (ftnlen)10);
#line 11593 ""
	++lfig;
#line 11594 ""
	goto L5;
#line 11595 ""
    } else if (*(unsigned char *)charq == '+') {

/*  Get vertical offset for figure. Next character after number has to be blank. */

#line 11599 ""
	++(*iccount);
#line 11600 ""
	readnum_(lineq, iccount, charq, &fnum, (ftnlen)128, (ftnlen)1);
#line 11601 ""
	*ivupfig = i_nint(&fnum);
#line 11602 ""
    } else if (*(unsigned char *)charq == 'v') {

/*  Get vertical change in figdrop. Must be last item in figure word. */

#line 11606 ""
	isign = 1;
#line 11607 ""
	getchar_(lineq, iccount, charq, (ftnlen)128, (ftnlen)1);
#line 11608 ""
	if (*(unsigned char *)charq == '-') {
#line 11609 ""
	    isign = -1;
#line 11610 ""
	    getchar_(lineq, iccount, charq, (ftnlen)128, (ftnlen)1);
#line 11611 ""
	}
#line 11612 ""
	*ivvfig = isign * (*(unsigned char *)charq - 48);
#line 11613 ""
    }
#line 11614 ""
    return 0;
} /* getfig_ */

/* Subroutine */ int getgrace_(integer *ivx, integer *nnl, char *lineq, 
	integer *iccount, integer *islur, integer *iornq, integer *ipl, 
	integer *ndlev, integer *lastlev, integer *iv, integer *nv, ftnlen 
	lineq_len)
{
    /* System generated locals */
    integer i__1;

    /* Builtin functions */
    integer i_indx(char *, char *, ftnlen, ftnlen), i_nint(real *);

    /* Local variables */
    static integer iclastlev, kv, ing, ioct;
    static real fnum;
    static char durq[1], charq[1];
    extern /* Subroutine */ int getchar_(char *, integer *, char *, ftnlen, 
	    ftnlen), readnum_(char *, integer *, char *, real *, ftnlen, 
	    ftnlen);
    extern integer ifnolev_(char *, integer *, integer *, ftnlen);


/* Grace, comes *before* main note: */
/* UNLESS there's an 'A' or 'W' after the 'G' */
/*   ngrace = # of grace note groups so far in block */
/*   ivg(ngrace), ipg(ngrace) */
/*   nng(ngrace) = # of notes in this group: default = 1 */
/*   ngstrt(ngrace) = starting position in nolevg of levels for this grace */
/*   multg(ngrace) = multiplicity: default = 1;  input as 'm(digit)' */
/*   upg(ngrace) = logical for beam or stem dirn: default T, input'u,l' */
/*   slurg(ngrace) = logical for slur; default F, input 's' */
/*   slashg(ngrace) = T if slash; default is F, input 'x' */
/* These data MUST precede note name of first note */
/*   nolevg, naccg: lists of levels and accid's, indexed as described above. */

#line 11648 ""
    /* Parameter adjustments */
#line 11648 ""
    ndlev -= 25;
#line 11648 ""
    ipl -= 25;
#line 11648 ""
    --iornq;
#line 11648 ""
    islur -= 25;
#line 11648 ""
    --nnl;
#line 11648 ""

#line 11648 ""
    /* Function Body */
#line 11648 ""
    ++comgrace_1.ngrace;
#line 11649 ""
    comgrace_1.ivg[comgrace_1.ngrace - 1] = *ivx;
#line 11650 ""
    comgrace_1.ipg[comgrace_1.ngrace - 1] = nnl[*ivx] + 1;
#line 11651 ""
    if (comgrace_1.ngrace == 1) {
#line 11652 ""
	comgrace_1.ngstrt[comgrace_1.ngrace - 1] = 1;
#line 11653 ""
    } else {
#line 11654 ""
	comgrace_1.ngstrt[comgrace_1.ngrace - 1] = comgrace_1.ngstrt[
		comgrace_1.ngrace - 2] + comgrace_1.nng[comgrace_1.ngrace - 2]
		;
#line 11655 ""
    }
#line 11656 ""
    islur[*ivx + (nnl[*ivx] + 1) * 24] = bit_set(islur[*ivx + (nnl[*ivx] + 1) 
	    * 24],4);
#line 11657 ""
    comgrace_1.nng[comgrace_1.ngrace - 1] = 1;
#line 11658 ""
    comgrace_1.multg[comgrace_1.ngrace - 1] = 1;
#line 11659 ""
    comgrace_1.upg[comgrace_1.ngrace - 1] = TRUE_;
#line 11660 ""
    comgrace_1.slurg[comgrace_1.ngrace - 1] = FALSE_;
#line 11661 ""
    comgrace_1.slashg[comgrace_1.ngrace - 1] = FALSE_;
#line 11662 ""
L18:
#line 11662 ""
    getchar_(lineq, iccount, charq, (ftnlen)128, (ftnlen)1);
#line 11663 ""
    if (i_indx("WA", charq, (ftnlen)2, (ftnlen)1) > 0) {

/*  Grace is on note that was already done, so shift flags forward one note. */
/*  This puts flag on actual note with grace; later for W will go ahead one more. */

#line 11668 ""
	comgrace_1.ipg[comgrace_1.ngrace - 1] = nnl[*ivx];
#line 11669 ""
	islur[*ivx + (nnl[*ivx] + 1) * 24] = bit_clear(islur[*ivx + (nnl[*ivx]
		 + 1) * 24],4);
#line 11670 ""
	islur[*ivx + nnl[*ivx] * 24] = bit_set(islur[*ivx + nnl[*ivx] * 24],4)
		;
#line 11671 ""
	if (comgrace_1.slurg[comgrace_1.ngrace - 1]) {
#line 11671 ""
	    iornq[*ivx + nnl[*ivx] * 24] = bit_set(iornq[*ivx + nnl[*ivx] * 
		    24],24);
#line 11671 ""
	}
#line 11673 ""
	if (*(unsigned char *)charq == 'A') {

/*  close After, clear way-after bit, to ensure priority of most recent A/W */

#line 11677 ""
	    ipl[*ivx + nnl[*ivx] * 24] = bit_set(bit_clear(ipl[*ivx + nnl[*
		    ivx] * 24],31),29);
#line 11678 ""
	} else {

/*  Way after; later assign to following note, and position like normal grace. */

#line 11682 ""
	    ipl[*ivx + nnl[*ivx] * 24] = bit_set(bit_clear(ipl[*ivx + nnl[*
		    ivx] * 24],29),31);
#line 11683 ""
	}
#line 11684 ""
    } else if (*(unsigned char *)charq == 'm') {
#line 11685 ""
	getchar_(lineq, iccount, charq, (ftnlen)128, (ftnlen)1);
#line 11686 ""
	comgrace_1.multg[comgrace_1.ngrace - 1] = *(unsigned char *)charq - 
		48;
#line 11687 ""
    } else if (i_indx("123456789", charq, (ftnlen)9, (ftnlen)1) > 0) {
#line 11688 ""
	readnum_(lineq, iccount, durq, &fnum, (ftnlen)128, (ftnlen)1);
#line 11689 ""
	--(*iccount);
#line 11690 ""
	comgrace_1.nng[comgrace_1.ngrace - 1] = i_nint(&fnum);
#line 11691 ""
    } else if (*(unsigned char *)charq == 'l') {
#line 11692 ""
	comgrace_1.upg[comgrace_1.ngrace - 1] = FALSE_;
#line 11693 ""
    } else if (*(unsigned char *)charq == 's') {
#line 11694 ""
	comgrace_1.slurg[comgrace_1.ngrace - 1] = TRUE_;
#line 11695 ""
	if (nnl[*ivx] > 0) {

/*  If A- or W-grace, set signal to start slur on main note. */

#line 11699 ""
	    if (bit_test(ipl[*ivx + nnl[*ivx] * 24],31) || bit_test(ipl[*ivx 
		    + nnl[*ivx] * 24],29)) {
#line 11699 ""
		iornq[*ivx + nnl[*ivx] * 24] = bit_set(iornq[*ivx + nnl[*ivx] 
			* 24],24);
#line 11699 ""
	    }
#line 11702 ""
	}
#line 11703 ""
    } else if (*(unsigned char *)charq == 'x') {
#line 11704 ""
	comgrace_1.slashg[comgrace_1.ngrace - 1] = TRUE_;
#line 11705 ""
    } else if (*(unsigned char *)charq == 'u') {
#line 11706 ""
    } else if (*(unsigned char *)charq == 'X') {

/* Space before main note of grace. Number will come next. */

#line 11710 ""
	++(*iccount);
#line 11711 ""
	readnum_(lineq, iccount, durq, &comgrace_1.graspace[comgrace_1.ngrace 
		- 1], (ftnlen)128, (ftnlen)1);
#line 11712 ""
	--(*iccount);
#line 11713 ""
    }
#line 11714 ""
    if (i_indx("abcdefg", charq, (ftnlen)7, (ftnlen)1) == 0) {
#line 11714 ""
	goto L18;
#line 11714 ""
    }

/*  At this point, charq is first note name in grace */

#line 11718 ""
    i__1 = comgrace_1.ngstrt[comgrace_1.ngrace - 1] + comgrace_1.nng[
	    comgrace_1.ngrace - 1] - 1;
#line 11718 ""
    for (ing = comgrace_1.ngstrt[comgrace_1.ngrace - 1]; ing <= i__1; ++ing) {
#line 11719 ""
	comgrace_1.naccg[ing - 1] = 0;
#line 11720 ""
	ioct = 0;
#line 11721 ""
	if (ing > comgrace_1.ngstrt[comgrace_1.ngrace - 1]) {
#line 11722 ""
L55:
#line 11722 ""
	    getchar_(lineq, iccount, charq, (ftnlen)128, (ftnlen)1);
#line 11723 ""
	    if (*(unsigned char *)charq == ' ') {
#line 11723 ""
		goto L55;
#line 11723 ""
	    }
#line 11724 ""
	}
#line 11725 ""
	iclastlev = 0;
#line 11726 ""
L9:
#line 11726 ""
	getchar_(lineq, iccount, durq, (ftnlen)128, (ftnlen)1);
#line 11727 ""
	if (*(unsigned char *)durq != ' ') {
#line 11728 ""
	    if (*(unsigned char *)durq == '+') {
#line 11729 ""
		*lastlev += 7;
#line 11730 ""
		iclastlev += 7;
#line 11731 ""
	    } else if (*(unsigned char *)durq == '-') {
#line 11732 ""
		*lastlev += -7;
#line 11733 ""
		iclastlev += -7;
#line 11734 ""
	    } else if (i_indx("fsn", durq, (ftnlen)3, (ftnlen)1) > 0) {
#line 11735 ""
		if (comgrace_1.naccg[ing - 1] == 0) {
#line 11736 ""
		    comgrace_1.naccg[ing - 1] = i_indx("fsn", durq, (ftnlen)3,
			     (ftnlen)1);
#line 11737 ""
		} else {

/*  Double accidental */

#line 11741 ""
		    comgrace_1.naccg[ing - 1] = bit_set(comgrace_1.naccg[ing 
			    - 1],2);
#line 11742 ""
		}
#line 11743 ""
	    } else {
#line 11744 ""
		ioct = *(unsigned char *)durq - 48;
#line 11745 ""
	    }
#line 11746 ""
	    goto L9;
#line 11747 ""
	}
#line 11748 ""
	if (ioct > 0) {
#line 11749 ""
	    *lastlev = ifnolev_(charq, &ioct, &cominsttrans_1.itransamt[
		    cominsttrans_1.instno[*iv - 1] - 1], (ftnlen)1);
#line 11750 ""
	} else {
#line 11751 ""
	    if (nnl[*ivx] == 0 && ing == comgrace_1.ngstrt[comgrace_1.ngrace 
		    - 1]) {
#line 11752 ""
		if (*ivx <= *nv) {
#line 11753 ""
		    kv = 1;
#line 11754 ""
		} else {
#line 11755 ""
		    kv = 2;
#line 11756 ""
		}
#line 11757 ""
		*lastlev = ndlev[*iv + kv * 24] + iclastlev;
#line 11758 ""
	    }
#line 11759 ""
	    *lastlev = *lastlev - 3 + (ifnolev_(charq, &c__10, &
		    cominsttrans_1.itransamt[cominsttrans_1.instno[*iv - 1] - 
		    1], (ftnlen)1) - *lastlev + 3) % 7;
#line 11761 ""
	}
#line 11762 ""
	comgrace_1.nolevg[ing - 1] = *lastlev;
#line 11763 ""
/* L19: */
#line 11763 ""
    }

/*  Grace could come before first note of block, so reset end level. */

#line 11767 ""
    if (nnl[*ivx] == 0) {
#line 11768 ""
	if (*ivx <= *nv) {
#line 11769 ""
	    kv = 1;
#line 11770 ""
	} else {
#line 11771 ""
	    kv = 2;
#line 11772 ""
	}
#line 11773 ""
	ndlev[*iv + kv * 24] = *lastlev;
#line 11774 ""
    }
#line 11775 ""
    return 0;
} /* getgrace_ */

/* Subroutine */ int getitransinfo_(logical *from1, integer *ibarcnt, char *
	lineq, integer *iccount, integer *ibaroff, integer *nbars, integer *
	noinst, ftnlen lineq_len)
{
    /* System generated locals */
    integer i__1;

    /* Builtin functions */
    integer i_indx(char *, char *, ftnlen, ftnlen), i_nint(real *);

    /* Local variables */
    static integer ikey;
    static real fnum;
    static char durq[1];
    extern /* Subroutine */ int stop1_(void);
    static integer instn;
    static logical store;
    extern /* Subroutine */ int errmsg_(char *, integer *, integer *, char *, 
	    ftnlen, ftnlen);
    static integer itramt;
    extern /* Subroutine */ int readnum_(char *, integer *, char *, real *, 
	    ftnlen, ftnlen), g1etchar_(char *, integer *, char *, ftnlen, 
	    ftnlen);

/* ccccccccccccccccccccccc */
/* c */
/* c GetiTransInfo.for */
/* c */
/* ccccccccccccccccccccccc */

/*  Called from both g1etnote and getnote, after first 'i' in Ki[...] */
/*  On entry, iccount points to last char retrieved, which is 'i' */

/*  From1: locgical, true if called from g1etnote */
/*  ibarcnt: tells whether to set EarlyTransOn to true. */
/*  EarlyTransOn set false in blkdata, true here, back to false in topfile. */

/*  110522/110529 */
/*  Instrument-wise transposition Ki[iInstTrans][+/-][iTransAmt][+/-][iTransKey] */
/*    and repeat i[...] for multiple instruments. Store info in g1etnot if ibarcnt=0 */
/*    so can pass to topfile (via comInstTrans), which is called before getnote. */
/*    Otherwise, will store info from getnote. Initialize EarlyTransOn and */
/*    LaterInstTrans to .false. in blockdata. Set EarlyTransOn from g1etnote; */
/*    LaterInstTrans from getnote. Zero both out after use. nInstTrans really */
/*    only needed for instrument-signatures, not transpositions. iTransAmt is */
/*    ALWAYS active per instrument. Set up instno(iv) so can fetch iTransAmt for */
/*    each staff. */

/*  iTransAmt stored as fn of instrument #, not like iTransKey which is */
/*    fn. of nm, just a counter, where corr. inst num is iInstTrans(nm). This */
/*    simplifies use of iTransAmt for all calls to ifnolev. */

#line 11814 ""
    *(unsigned char *)durq = 'x';
/* Can't initialize in declaration stmt, only works onc */
#line 11815 ""
    if (! cominsttrans_1.earlytranson) {
#line 11815 ""
	cominsttrans_1.earlytranson = *from1 && *ibarcnt == 0;
#line 11815 ""
    }
#line 11816 ""
    store = cominsttrans_1.earlytranson && *ibarcnt == 0 || *ibarcnt > 0 && ! 
	    (*from1);
#line 11818 ""
    cominsttrans_1.laterinsttrans = ! (*from1) && *ibarcnt > 0;
#line 11819 ""
    if (store) {
#line 11819 ""
	cominsttrans_1.ninsttrans = 0;
#line 11819 ""
    }
#line 11820 ""
L1:
#line 11821 ""
    if (*(unsigned char *)durq == ' ') {
#line 11821 ""
	return 0;
#line 11821 ""
    }
#line 11822 ""
    g1etchar_(lineq, iccount, durq, (ftnlen)128, (ftnlen)1);
#line 11823 ""
    if (i_indx("123456789", durq, (ftnlen)9, (ftnlen)1) == 0) {
#line 11824 ""
	i__1 = *ibarcnt - *ibaroff + *nbars + 1;
#line 11824 ""
	errmsg_(lineq, iccount, &i__1, "There must be an instrument number h"\
		"ere!", (ftnlen)128, (ftnlen)40);
#line 11826 ""
	stop1_();
#line 11827 ""
    }
#line 11828 ""
    if (store) {
#line 11828 ""
	++cominsttrans_1.ninsttrans;
#line 11828 ""
    }
#line 11829 ""
    readnum_(lineq, iccount, durq, &fnum, (ftnlen)128, (ftnlen)1);
#line 11830 ""
    instn = i_nint(&fnum);
#line 11831 ""
    if (instn > *noinst) {
#line 11832 ""
	i__1 = *ibarcnt - *ibaroff + *nbars + 1;
#line 11832 ""
	errmsg_(lineq, iccount, &i__1, "Instrument number out of range!", (
		ftnlen)128, (ftnlen)31);
#line 11834 ""
	stop1_();
#line 11835 ""
    }
#line 11836 ""
    if (store) {
#line 11836 ""
	cominsttrans_1.iinsttrans[cominsttrans_1.ninsttrans - 1] = instn;
#line 11836 ""
    }

/*  durq is +/- following inst # (for iTransAmt), iccount is on it. */

#line 11840 ""
    if (i_indx("+-", durq, (ftnlen)2, (ftnlen)1) == 0) {
#line 11841 ""
	i__1 = *ibarcnt - *ibaroff + *nbars + 1;
#line 11841 ""
	errmsg_(lineq, iccount, &i__1, "1st character after instrument numbe"\
		"r must be \"+,-\"!", (ftnlen)128, (ftnlen)52);
#line 11843 ""
	stop1_();
#line 11844 ""
    }
#line 11845 ""
    itramt = 44 - *(unsigned char *)durq;
/* +1/-1 for itramt */
#line 11846 ""
    g1etchar_(lineq, iccount, durq, (ftnlen)128, (ftnlen)1);
#line 11847 ""
    if (i_indx("0123456789", durq, (ftnlen)10, (ftnlen)1) == 0) {
#line 11848 ""
	i__1 = *ibarcnt - *ibaroff + *nbars + 1;
#line 11848 ""
	errmsg_(lineq, iccount, &i__1, "There must be a transposition amount"\
		" here!", (ftnlen)128, (ftnlen)42);
#line 11850 ""
	stop1_();
#line 11851 ""
    }
#line 11852 ""
    readnum_(lineq, iccount, durq, &fnum, (ftnlen)128, (ftnlen)1);
#line 11853 ""
    if (store) {
#line 11853 ""
	cominsttrans_1.itransamt[instn - 1] = i_nint(&fnum) * itramt;
#line 11853 ""
    }

/*  durq is +/- following iTransAmt (for iTransKey), iccount is on it. */

#line 11857 ""
    if (i_indx("+-", durq, (ftnlen)2, (ftnlen)1) == 0) {
#line 11858 ""
	i__1 = *ibarcnt - *ibaroff + *nbars + 1;
#line 11858 ""
	errmsg_(lineq, iccount, &i__1, "1st character after transposition am"\
		"ount must be \"+,-\"!", (ftnlen)128, (ftnlen)55);
#line 11860 ""
	stop1_();
#line 11861 ""
    }
#line 11862 ""
    ikey = 44 - *(unsigned char *)durq;
/* +1/-1 */
#line 11863 ""
    g1etchar_(lineq, iccount, durq, (ftnlen)128, (ftnlen)1);
#line 11864 ""
    if (i_indx("0123456789", durq, (ftnlen)10, (ftnlen)1) == 0) {
#line 11865 ""
	i__1 = *ibarcnt - *ibaroff + *nbars + 1;
#line 11865 ""
	errmsg_(lineq, iccount, &i__1, "There must be a key indicator here!", 
		(ftnlen)128, (ftnlen)35);
#line 11867 ""
	stop1_();
#line 11868 ""
    }
#line 11869 ""
    readnum_(lineq, iccount, durq, &fnum, (ftnlen)128, (ftnlen)1);
#line 11870 ""
    if (store) {
#line 11870 ""
	cominsttrans_1.itranskey[cominsttrans_1.ninsttrans - 1] = i_nint(&
		fnum) * ikey;
#line 11870 ""
    }

/*  durq is now 1st character after iTransKey, should be either 'i' or ' ' */

#line 11874 ""
    if (*(unsigned char *)durq != 'i' && *(unsigned char *)durq != ' ') {
#line 11875 ""
	i__1 = *ibarcnt - *ibaroff + *nbars + 1;
#line 11875 ""
	errmsg_(lineq, iccount, &i__1, "There must be blank or \"i\" here!", (
		ftnlen)128, (ftnlen)32);
#line 11877 ""
	stop1_();
#line 11878 ""
    }
#line 11879 ""
    goto L1;
} /* getitransinfo_ */

/* Subroutine */ int getmidi_(integer *noinstarg, char *lineq, integer *
	iccount, integer *ibarcnt, integer *ibaroff, integer *nbars, integer *
	lenbar, integer *mtrdenl, integer *nv, logical *first, ftnlen 
	lineq_len)
{
    /* Initialized data */

    static shortint midinum[26] = { 1,5,7,13,20,25,33,41,42,43,44,57,58,59,61,
	    65,66,67,68,69,71,72,74,75,8,55 };

    /* System generated locals */
    address a__1[2];
    integer i__1, i__2[2], i__3, i__4;
    real r__1;

    /* Builtin functions */
    integer i_indx(char *, char *, ftnlen, ftnlen), i_nint(real *);
    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
    integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void);

    /* Local variables */
    static real pausemid;
    extern /* Subroutine */ int inst2chan_(integer *, integer *, integer *, 
	    integer *, shortint *, logical *), midievent_(char *, integer *, 
	    integer *, ftnlen);
    static integer icm, ipm;
    static real qpm;
    static integer ivx;
    static real fnum;
    static char durq[1];
    extern /* Subroutine */ int stop1_(void);
    static integer iname, numb16;
    static char instq[2];
    extern /* Subroutine */ int errmsg_(char *, integer *, integer *, char *, 
	    ftnlen, ftnlen), addmidi_(integer *, integer *, integer *, 
	    integer *, real *, logical *, logical *), getchar_(char *, 
	    integer *, char *, ftnlen, ftnlen), readnum_(char *, integer *, 
	    char *, real *, ftnlen, ftnlen);

    /* Fortran I/O blocks */
    static cilist io___761 = { 0, 6, 0, "(a)", 0 };
    static cilist io___762 = { 0, 15, 0, "(a)", 0 };



/*  Use this from both pmxa and pmxb to input and check midi data. "first" tells */
/*  whether pmxa or pmxb.  If .not.first, then tempo and pause commands cause */
/*  things to be written immediately into the midi storage buffers. */


/*  immac(i) is the index of i-th macro, i=1,nmac.  Also make a list containing */
/*   nmidsec  section starts and stops based on PLAYING macros (not recording). */


/*      Instrument codes */

/*         XXpiXrhXhaXmaXorXguXabXvlXvaXvcXcbXtrXtbXtuXfrXsoXalXteX */

/*           bsXobXbaXclXflXreXctXvo */

#line 11925 ""
L1:
#line 11925 ""
    getchar_(lineq, iccount, durq, (ftnlen)128, (ftnlen)1);
#line 11926 ""
    if (*(unsigned char *)durq == 't') {

/*  Tempo in beats ber minute */

#line 11930 ""
	getchar_(lineq, iccount, durq, (ftnlen)128, (ftnlen)1);
#line 11931 ""
	if (i_indx("0123456789", durq, (ftnlen)10, (ftnlen)1) == 0) {
#line 11932 ""
	    i__1 = *ibarcnt - *ibaroff + *nbars + 1;
#line 11932 ""
	    errmsg_(lineq, iccount, &i__1, "Expected an integer here for the"\
		    " pause!", (ftnlen)128, (ftnlen)39);
#line 11934 ""
	    stop1_();
#line 11935 ""
	}
#line 11936 ""
	readnum_(lineq, iccount, durq, &qpm, (ftnlen)128, (ftnlen)1);
#line 11937 ""
	--(*iccount);
#line 11938 ""
	if (! (*first)) {
#line 11939 ""
	    i__1 = i_nint(&qpm);
#line 11939 ""
	    midievent_("t", &i__1, &c__0, (ftnlen)1);
#line 11940 ""
	    commmac_1.gottempo = TRUE_;
#line 11941 ""
	}
#line 11942 ""
	goto L1;
#line 11943 ""
    } else if (*(unsigned char *)durq == 'p') {

/*  Insert a pause.  pausemid = pause in 1/4's */

#line 11947 ""
	getchar_(lineq, iccount, durq, (ftnlen)128, (ftnlen)1);
#line 11948 ""
	if (i_indx("0123456789.", durq, (ftnlen)11, (ftnlen)1) == 0) {
#line 11949 ""
	    i__1 = *ibarcnt - *ibaroff + *nbars + 1;
#line 11949 ""
	    errmsg_(lineq, iccount, &i__1, "Expected a number here for the p"\
		    "ause!", (ftnlen)128, (ftnlen)37);
#line 11951 ""
	    stop1_();
#line 11952 ""
	}
#line 11953 ""
	readnum_(lineq, iccount, durq, &pausemid, (ftnlen)128, (ftnlen)1);
#line 11954 ""
	--(*iccount);
#line 11955 ""
	if (! (*first)) {

/*  Compute a meter for the pause.  This is only to keep MidiNotate on track. */
/*  Round pause to nearest 16th.  Let denominator always be 16. */

#line 11960 ""
	    r__1 = pausemid * 4;
#line 11960 ""
	    numb16 = i_nint(&r__1);
#line 11961 ""
	    midievent_("m", &numb16, &c__16, (ftnlen)1);

/*  Put in pausemid beats of rest */

#line 11965 ""
	    i__1 = commidi_1.numchan - 1;
#line 11965 ""
	    for (icm = 0; icm <= i__1; ++icm) {
#line 11966 ""
		r__1 = numb16 * 4.f;
#line 11966 ""
		addmidi_(&icm, &c__0, &c__0, &c__0, &r__1, &c_true, &c_false);
#line 11967 ""
/* L3: */
#line 11967 ""
	    }
#line 11968 ""
	    r__1 = pausemid * 240;
#line 11968 ""
	    comevent_1.miditime += i_nint(&r__1);

/*  Restore meter */

#line 11972 ""
	    i__1 = *mtrdenl * *lenbar / 64;
#line 11972 ""
	    midievent_("m", &i__1, mtrdenl, (ftnlen)1);
#line 11973 ""
	}
#line 11974 ""
	goto L1;
#line 11975 ""
    } else if (*(unsigned char *)durq == 'i') {

/*  Instrument numbers or letters.  Expect noinst of them. */

#line 11979 ""
	i__1 = *noinstarg;
#line 11979 ""
	for (ivx = 1; ivx <= i__1; ++ivx) {
#line 11980 ""
	    getchar_(lineq, iccount, durq, (ftnlen)128, (ftnlen)1);
#line 11981 ""
	    if (*(unsigned char *)durq > 96) {

/*  It's a lowercase letter.  Get another, find corr. instrument #. */

#line 11985 ""
		*(unsigned char *)instq = *(unsigned char *)durq;
#line 11986 ""
		getchar_(lineq, iccount, durq, (ftnlen)128, (ftnlen)1);
/* Writing concatenation */
#line 11987 ""
		i__2[0] = 1, a__1[0] = instq;
#line 11987 ""
		i__2[1] = 1, a__1[1] = durq;
#line 11987 ""
		s_cat(instq, a__1, i__2, &c__2, (ftnlen)2);
#line 11988 ""
		iname = i_indx("XXpiXrhXhaXmaXorXguXabXvlXvaXvcXcbXtrXtbXtuX"\
			"frXsoXalXteXbsXobXbaXclXflXreXctXvo", instq, (ftnlen)
			79, (ftnlen)2) / 3;
#line 11990 ""
		if (iname == 0) {
#line 11991 ""
		    i__3 = *ibarcnt - *ibaroff + *nbars + 1;
#line 11991 ""
		    errmsg_(lineq, iccount, &i__3, "Unrecognized 2-letter mi"\
			    "di instrument name!", (ftnlen)128, (ftnlen)43);
#line 11993 ""
		    stop1_();
#line 11994 ""
		}
#line 11995 ""
		commidi_1.midinst[ivx - 1] = midinum[iname - 1] - 1;
#line 11996 ""
	    } else {

/*  Expect a number, followed by ":" if that is followed by another number. */
/*  I.e., if after call to readnum, durq is not ":", it must be either blank */
/*  or next instrument letter. */

#line 12002 ""
		if (i_indx("123456789", durq, (ftnlen)9, (ftnlen)1) == 0) {
#line 12003 ""
		    i__3 = *ibarcnt - *ibaroff + *nbars + 1;
#line 12003 ""
		    errmsg_(lineq, iccount, &i__3, "Expected a midi instrume"\
			    "nt number here!", (ftnlen)128, (ftnlen)39);
#line 12005 ""
		    stop1_();
#line 12006 ""
		}
#line 12007 ""
		readnum_(lineq, iccount, durq, &fnum, (ftnlen)128, (ftnlen)1);
#line 12008 ""
		commidi_1.midinst[ivx - 1] = i_nint(&fnum) - 1;
#line 12009 ""
		if (commidi_1.midinst[ivx - 1] < 0 || commidi_1.midinst[ivx - 
			1] > 255) {
#line 12010 ""
		    i__3 = *iccount - 1;
#line 12010 ""
		    i__4 = *ibarcnt - *ibaroff + *nbars + 1;
#line 12010 ""
		    errmsg_(lineq, &i__3, &i__4, "Midi instrument number mus"\
			    "t be in range 1-128!", (ftnlen)128, (ftnlen)46);
#line 12012 ""
		    stop1_();
#line 12013 ""
		}
#line 12014 ""
		if (*(unsigned char *)durq != ':') {
#line 12014 ""
		    --(*iccount);
#line 12014 ""
		}
#line 12015 ""
	    }
#line 12016 ""
/* L2: */
#line 12016 ""
	}
#line 12017 ""
	goto L1;
#line 12018 ""
    } else if (*(unsigned char *)durq == 'v') {

/* Get volumes for each instrument.  Expect noinst of them. */
/*    Follow same pattern as for insttrument numbers above. */

#line 12023 ""
	i__1 = *noinstarg;
#line 12023 ""
	for (ivx = 1; ivx <= i__1; ++ivx) {
#line 12024 ""
	    getchar_(lineq, iccount, durq, (ftnlen)128, (ftnlen)1);
#line 12025 ""
	    if (i_indx("123456789", durq, (ftnlen)9, (ftnlen)1) == 0) {
#line 12026 ""
		i__3 = *ibarcnt - *ibaroff + *nbars + 1;
#line 12026 ""
		errmsg_(lineq, iccount, &i__3, "Expected a midi velocity num"\
			"ber here!", (ftnlen)128, (ftnlen)37);
#line 12028 ""
		stop1_();
#line 12029 ""
	    }
#line 12030 ""
	    readnum_(lineq, iccount, durq, &fnum, (ftnlen)128, (ftnlen)1);
#line 12031 ""
	    commvel_2.midivel[ivx - 1] = i_nint(&fnum) - 1;
#line 12032 ""
	    if (commvel_2.midivel[ivx - 1] < 0 || commvel_2.midivel[ivx - 1] 
		    > 127) {
#line 12033 ""
		i__3 = *iccount - 1;
#line 12033 ""
		i__4 = *ibarcnt - *ibaroff + *nbars + 1;
#line 12033 ""
		errmsg_(lineq, &i__3, &i__4, "Midi velocity must be in range"\
			" 1-128!", (ftnlen)128, (ftnlen)37);
#line 12035 ""
		stop1_();
#line 12036 ""
	    }
#line 12037 ""
	    if (*(unsigned char *)durq != ':') {
#line 12037 ""
		--(*iccount);
#line 12037 ""
	    }
#line 12038 ""
/* L7: */
#line 12038 ""
	}
#line 12039 ""
	if (! (*first)) {
#line 12040 ""
	    inst2chan_(commvel_2.midvelc, commvel_2.midivel, 
		    commidi_1.midchan, nv, commvel_2.iinsiv, 
		    commidi_1.twoline);
#line 12041 ""
	}
#line 12042 ""
	goto L1;
#line 12043 ""
    } else if (*(unsigned char *)durq == 'b') {

/* Get balance for each instrument.  Expect noinst of them. */
/*    Follow same pattern as for instrument numbers above. */

#line 12048 ""
	i__1 = *noinstarg;
#line 12048 ""
	for (ivx = 1; ivx <= i__1; ++ivx) {
#line 12049 ""
	    getchar_(lineq, iccount, durq, (ftnlen)128, (ftnlen)1);
#line 12050 ""
	    if (i_indx("123456789", durq, (ftnlen)9, (ftnlen)1) == 0) {
#line 12051 ""
		i__3 = *ibarcnt - *ibaroff + *nbars + 1;
#line 12051 ""
		errmsg_(lineq, iccount, &i__3, "Expected a balance number he"\
			"re!", (ftnlen)128, (ftnlen)31);
#line 12053 ""
		stop1_();
#line 12054 ""
	    }
#line 12055 ""
	    readnum_(lineq, iccount, durq, &fnum, (ftnlen)128, (ftnlen)1);
#line 12056 ""
	    commvel_2.midibal[ivx - 1] = i_nint(&fnum) - 1;
#line 12057 ""
	    if (commvel_2.midibal[ivx - 1] < 0 || commvel_2.midibal[ivx - 1] 
		    > 127) {
#line 12058 ""
		i__3 = *iccount - 1;
#line 12058 ""
		i__4 = *ibarcnt - *ibaroff + *nbars + 1;
#line 12058 ""
		errmsg_(lineq, &i__3, &i__4, "Midi balance must be in range "\
			"1-128!", (ftnlen)128, (ftnlen)36);
#line 12060 ""
		stop1_();
#line 12061 ""
	    }
#line 12062 ""
	    if (*(unsigned char *)durq != ':') {
#line 12062 ""
		--(*iccount);
#line 12062 ""
	    }
#line 12063 ""
/* L8: */
#line 12063 ""
	}
#line 12064 ""
	if (! (*first)) {
#line 12065 ""
	    inst2chan_(commvel_2.midbc, commvel_2.midibal, commidi_1.midchan, 
		    nv, commvel_2.iinsiv, commidi_1.twoline);
#line 12066 ""
	}
#line 12067 ""
	goto L1;
#line 12068 ""
    } else if (*(unsigned char *)durq == 'T') {

/* Get transposition for each instrument.  Expect noinst of them. */
/*    Follow similar pattern as above, but separator is +|-. */

#line 12073 ""
	i__1 = *noinstarg;
#line 12073 ""
	for (ivx = 1; ivx <= i__1; ++ivx) {
#line 12074 ""
	    getchar_(lineq, iccount, durq, (ftnlen)128, (ftnlen)1);
#line 12075 ""
	    ipm = i_indx("-+", durq, (ftnlen)2, (ftnlen)1);
#line 12076 ""
	    if (ipm == 0) {
#line 12077 ""
		i__3 = *ibarcnt - *ibaroff + *nbars + 1;
#line 12077 ""
		errmsg_(lineq, iccount, &i__3, "Expected \"+\" or \"-\" for "\
			"midi transposition here!", (ftnlen)128, (ftnlen)48);
#line 12079 ""
		stop1_();
#line 12080 ""
	    }
#line 12081 ""
	    ipm = (ipm << 1) - 3;
#line 12082 ""
	    getchar_(lineq, iccount, durq, (ftnlen)128, (ftnlen)1);
#line 12083 ""
	    if (i_indx("0123456789", durq, (ftnlen)10, (ftnlen)1) == 0) {
#line 12084 ""
		i__3 = *ibarcnt - *ibaroff + *nbars + 1;
#line 12084 ""
		errmsg_(lineq, iccount, &i__3, "Expected a number here!", (
			ftnlen)128, (ftnlen)23);
#line 12086 ""
		stop1_();
#line 12087 ""
	    }
#line 12088 ""
	    readnum_(lineq, iccount, durq, &fnum, (ftnlen)128, (ftnlen)1);
#line 12089 ""
	    commvel_2.miditran[ivx - 1] = ipm * i_nint(&fnum);
#line 12090 ""
	    --(*iccount);
#line 12091 ""
/* L9: */
#line 12091 ""
	}
#line 12092 ""
	if (! (*first)) {
#line 12093 ""
	    inst2chan_(commvel_2.midtc, commvel_2.miditran, commidi_1.midchan,
		     nv, commvel_2.iinsiv, commidi_1.twoline);
#line 12094 ""
	}
#line 12095 ""
	goto L1;
#line 12096 ""
    } else if (*(unsigned char *)durq == 'g') {
#line 12097 ""
	getchar_(lineq, iccount, durq, (ftnlen)128, (ftnlen)1);
#line 12098 ""
	if (i_indx("0123456789", durq, (ftnlen)10, (ftnlen)1) == 0) {
#line 12099 ""
	    i__1 = *ibarcnt - *ibaroff + *nbars + 1;
#line 12099 ""
	    errmsg_(lineq, iccount, &i__1, "Expected an integer here for the"\
		    " midi gap!", (ftnlen)128, (ftnlen)42);
#line 12101 ""
	    stop1_();
#line 12102 ""
	}
#line 12103 ""
	readnum_(lineq, iccount, durq, &fnum, (ftnlen)128, (ftnlen)1);
#line 12104 ""
	commidi_1.mgap = i_nint(&fnum);
#line 12105 ""
	--(*iccount);
#line 12106 ""
	goto L1;
#line 12107 ""
    } else if (*(unsigned char *)durq == 'M') {

/*  MidiMacros */

#line 12111 ""
	getchar_(lineq, iccount, durq, (ftnlen)128, (ftnlen)1);
#line 12112 ""
	if (*(unsigned char *)durq == 'R') {

/*  Start recording */

#line 12116 ""
	    if (commmac_1.mmacrec) {
#line 12117 ""
		i__1 = *ibarcnt - *ibaroff + *nbars + 1;
#line 12117 ""
		errmsg_(lineq, iccount, &i__1, "You tried to record a MidiMa"\
			"cro while already recording!", (ftnlen)128, (ftnlen)
			56);
#line 12119 ""
		stop1_();
#line 12120 ""
	    }
#line 12121 ""
	    commmac_1.mmacrec = TRUE_;
#line 12122 ""
	    getchar_(lineq, iccount, durq, (ftnlen)128, (ftnlen)1);
#line 12123 ""
	    if (i_indx("123456789", durq, (ftnlen)9, (ftnlen)1) == 0) {
#line 12124 ""
		i__1 = *ibarcnt - *ibaroff + *nbars + 1;
#line 12124 ""
		errmsg_(lineq, iccount, &i__1, "Expected MidiMacro ID number"\
			" here!", (ftnlen)128, (ftnlen)34);
#line 12126 ""
		stop1_();
#line 12127 ""
	    }
#line 12128 ""
	    readnum_(lineq, iccount, durq, &fnum, (ftnlen)128, (ftnlen)1);
#line 12129 ""
	    --(*iccount);
#line 12130 ""
	    if (! (*first)) {
#line 12131 ""
		commmac_1.immac = i_nint(&fnum);
#line 12132 ""
		if (commmac_1.immac > 20) {
#line 12133 ""
		    i__1 = *ibarcnt - *ibaroff + *nbars + 1;
#line 12133 ""
		    errmsg_(lineq, iccount, &i__1, "MidiMacro ID cannot exce"\
			    "ed 20!", (ftnlen)128, (ftnlen)30);
#line 12135 ""
		    stop1_();
#line 12136 ""
		}

/*  Save the start time */

#line 12140 ""
		commmac_1.mmactime[commmac_1.immac - 1] = comevent_1.miditime;
#line 12141 ""
		i__1 = commidi_1.numchan;
#line 12141 ""
		for (icm = 0; icm <= i__1; ++icm) {
#line 12142 ""
		    if (icm < commidi_1.numchan) {
#line 12143 ""
			if (commidi_1.restpend[icm]) {

/*  Adjust if there's a rest at end of prior section.  Insert dummy turnoff. */
/*    (This causes two turn-offs in a row, which testmidi sees as an error). */

/*  Before:    section1  ------rest-------  section2(to be recorded) */
/*  After:     section1  rest1  now  rest2  section2(recorded) */

#line 12151 ""
			    addmidi_(&icm, &c__30, &c__0, &c__0, &
				    commidi_1.trest[icm], &c_false, &c_true);
#line 12152 ""
			    commidi_1.trest[icm] = 0.f;
#line 12153 ""
			    commidi_1.restpend[icm] = FALSE_;
#line 12154 ""
			}
#line 12155 ""
		    } else {
#line 12156 ""
			if (comevent_1.miditime > comevent_1.lasttime) {

/*  Insert a dummy turnoff in conductor track */

#line 12160 ""
			    r__1 = (comevent_1.miditime - comevent_1.lasttime)
				     / 15.f;
#line 12160 ""
			    addmidi_(&icm, &c__30, &c__0, &c__0, &r__1, &
				    c_false, &c_true);
#line 12162 ""
			    comevent_1.lasttime = comevent_1.miditime;
#line 12163 ""
			}
#line 12164 ""
		    }
#line 12165 ""
		    commmac_1.mmacstrt[icm + commmac_1.immac * 25 - 25] = 
			    commidi_1.imidi[icm] + 1;
#line 12166 ""
/* L4: */
#line 12166 ""
		}
#line 12167 ""
	    }
#line 12168 ""
	    goto L1;
#line 12169 ""
	} else if (i_indx("123456789P", durq, (ftnlen)10, (ftnlen)1) == 0) {

/*  End recording; close the open macro.  Get immac from common. */

#line 12173 ""
	    if (! commmac_1.mmacrec) {
#line 12174 ""
		i__1 = *iccount - 1;
#line 12174 ""
		i__3 = *ibarcnt - *ibaroff + *nbars + 1;
#line 12174 ""
		errmsg_(lineq, &i__1, &i__3, "You tried to end a MidiMacro b"\
			"efore starting one!", (ftnlen)128, (ftnlen)49);
#line 12176 ""
		stop1_();
#line 12177 ""
	    }
#line 12178 ""
	    commmac_1.mmacrec = FALSE_;
#line 12179 ""
	    --(*iccount);
#line 12180 ""
	    if (! (*first)) {

/*  Save the macro duration */

#line 12184 ""
		commmac_1.mmactime[commmac_1.immac - 1] = comevent_1.miditime 
			- commmac_1.mmactime[commmac_1.immac - 1];
#line 12185 ""
		i__1 = commidi_1.numchan;
#line 12185 ""
		for (icm = 0; icm <= i__1; ++icm) {
#line 12186 ""
		    if (icm < commidi_1.numchan) {
#line 12187 ""
			if (commidi_1.restpend[icm]) {
#line 12188 ""
			    addmidi_(&icm, &c__30, &c__0, &c__0, &
				    commidi_1.trest[icm], &c_false, &c_true);
#line 12189 ""
			    commidi_1.trest[icm] = 0.f;
#line 12190 ""
			    commidi_1.restpend[icm] = FALSE_;
#line 12191 ""
			}
#line 12192 ""
		    } else {
#line 12193 ""
			if (comevent_1.miditime > comevent_1.lasttime) {

/*  Insert a dummy turnoff in conductor track if needed. */

#line 12197 ""
			    r__1 = (comevent_1.miditime - comevent_1.lasttime)
				     / 15.f;
#line 12197 ""
			    addmidi_(&icm, &c__30, &c__0, &c__0, &r__1, &
				    c_false, &c_true);
#line 12199 ""
			    comevent_1.lasttime = comevent_1.miditime;
#line 12200 ""
			}
#line 12201 ""
		    }
#line 12202 ""
		    commmac_1.mmacend[icm + commmac_1.immac * 25 - 25] = 
			    commidi_1.imidi[icm];
#line 12203 ""
/* L5: */
#line 12203 ""
		}
#line 12204 ""
	    }
#line 12205 ""
	    if (*(unsigned char *)durq != ' ') {
#line 12205 ""
		goto L1;
#line 12205 ""
	    }
#line 12206 ""
	} else if (*(unsigned char *)durq == 'P') {

/*  Play Back a Macro */

#line 12210 ""
	    getchar_(lineq, iccount, durq, (ftnlen)128, (ftnlen)1);
#line 12211 ""
	    if (i_indx("123456789", durq, (ftnlen)9, (ftnlen)1) == 0) {
#line 12212 ""
		i__1 = *ibarcnt - *ibaroff + *nbars + 1;
#line 12212 ""
		errmsg_(lineq, iccount, &i__1, "Expected MidiMacro ID number"\
			" here!", (ftnlen)128, (ftnlen)34);
#line 12214 ""
		stop1_();
#line 12215 ""
	    }
#line 12216 ""
	    if (commmac_1.mmacrec) {
#line 12217 ""
		i__1 = *ibarcnt - *ibaroff + *nbars + 1;
#line 12217 ""
		errmsg_(lineq, iccount, &i__1, "You tried to play a MidiMacr"\
			"o before ending recording!", (ftnlen)128, (ftnlen)54);
#line 12219 ""
		stop1_();
#line 12220 ""
	    }
#line 12221 ""
	    readnum_(lineq, iccount, durq, &fnum, (ftnlen)128, (ftnlen)1);
#line 12222 ""
	    --(*iccount);
#line 12223 ""
	    if (! (*first)) {
#line 12224 ""
		commmac_1.immac = i_nint(&fnum);
#line 12225 ""
		if (commmac_1.mmactime[commmac_1.immac - 1] == 0) {
#line 12226 ""
		    i__1 = *ibarcnt - *ibaroff + *nbars + 1;
#line 12226 ""
		    errmsg_(lineq, iccount, &i__1, "Cannot play a MIDI macro"\
			    " before recording it!", (ftnlen)128, (ftnlen)45);
#line 12228 ""
		    stop1_();
#line 12229 ""
		}
#line 12230 ""
		i__1 = commidi_1.numchan;
#line 12230 ""
		for (icm = 0; icm <= i__1; ++icm) {
#line 12231 ""
		    if (icm < commidi_1.numchan) {
#line 12232 ""
			if (commidi_1.restpend[icm]) {
#line 12233 ""
			    addmidi_(&icm, &c__30, &c__0, &c__0, &
				    commidi_1.trest[icm], &c_false, &c_true);
#line 12234 ""
			    commidi_1.trest[icm] = 0.f;
#line 12235 ""
			    commidi_1.restpend[icm] = FALSE_;
#line 12236 ""
			}
#line 12237 ""
		    } else {
#line 12238 ""
			if (comevent_1.miditime > comevent_1.lasttime) {

/*  Insert a dummy turnoff in conductor track */

#line 12242 ""
			    r__1 = (comevent_1.miditime - comevent_1.lasttime)
				     / 15.f;
#line 12242 ""
			    addmidi_(&icm, &c__30, &c__0, &c__0, &r__1, &
				    c_false, &c_true);
#line 12244 ""
			}
#line 12245 ""
		    }
#line 12246 ""
		    commmac_1.msecend[icm + commmac_1.nmidsec * 25 - 25] = 
			    commidi_1.imidi[icm];
#line 12247 ""
		    commmac_1.msecstrt[icm + (commmac_1.nmidsec + 1) * 25 - 
			    25] = commmac_1.mmacstrt[icm + commmac_1.immac * 
			    25 - 25];
#line 12248 ""
		    commmac_1.msecend[icm + (commmac_1.nmidsec + 1) * 25 - 25]
			     = commmac_1.mmacend[icm + commmac_1.immac * 25 - 
			    25];
#line 12249 ""
		    commmac_1.msecstrt[icm + (commmac_1.nmidsec + 2) * 25 - 
			    25] = commidi_1.imidi[icm] + 1;
#line 12250 ""
/* L6: */
#line 12250 ""
		}
#line 12251 ""
		commmac_1.nmidsec += 2;

/*  Update running time */

#line 12255 ""
		comevent_1.miditime += commmac_1.mmactime[commmac_1.immac - 1]
			;
#line 12256 ""
		comevent_1.lasttime = comevent_1.miditime;
#line 12257 ""
	    }
#line 12258 ""
	    goto L1;
#line 12259 ""
	} else {
#line 12260 ""
	    i__1 = *ibarcnt - *ibaroff + *nbars + 1;
#line 12260 ""
	    errmsg_(lineq, iccount, &i__1, "Illegal character in MidiMacro s"\
		    "ub-command!", (ftnlen)128, (ftnlen)43);
#line 12262 ""
	    stop1_();
#line 12263 ""
	}
#line 12264 ""
    } else if (*(unsigned char *)durq == 'd') {
#line 12265 ""
	commidi_1.debugmidi = TRUE_;
#line 12266 ""
	goto L1;
#line 12267 ""
    } else if (*(unsigned char *)durq != ' ') {
#line 12268 ""
	i__1 = *ibarcnt - *ibaroff + *nbars + 1;
#line 12268 ""
	errmsg_(lineq, iccount, &i__1, "Illegal character in MIDI input data!"
		, (ftnlen)128, (ftnlen)37);
#line 12270 ""
	s_wsfe(&io___761);
#line 12270 ""
	do_fio(&c__1, "May be too many args to i,v,b, or T. As of Ver. 2.7, "\
		"should be noinst, not nv", (ftnlen)77);
#line 12270 ""
	e_wsfe();
#line 12273 ""
	s_wsfe(&io___762);
#line 12273 ""
	do_fio(&c__1, "May be too many args to i,v,b, or T. As of Ver. 2.7, "\
		"should be noinst, not nv", (ftnlen)77);
#line 12273 ""
	e_wsfe();
#line 12276 ""
	stop1_();
#line 12277 ""
    }
#line 12278 ""
    if (! commmac_1.gottempo && ! (*first)) {

/*  If no tempo is set on first call on the pmxb pass, then set it */

#line 12282 ""
	midievent_("t", &c__96, &c__0, (ftnlen)1);
#line 12283 ""
	commmac_1.gottempo = TRUE_;
#line 12284 ""
    }
#line 12285 ""
    return 0;
} /* getmidi_ */

/* Subroutine */ int getnote_(logical *loop)
{
    /* System generated locals */
    address a__1[5], a__2[2], a__3[3], a__4[6], a__5[8], a__6[13];
    integer i__1, i__2, i__3[5], i__4, i__5[2], i__6[3], i__7[6], i__8[8], 
	    i__9[13];
    real r__1;
    char ch__1[1], ch__2[12], ch__3[10], ch__4[13], ch__5[1], ch__6[69], 
	    ch__7[22], ch__8[21], ch__9[20], ch__10[11], ch__11[3], ch__12[9],
	     ch__13[61], ch__14[8], ch__15[82], ch__16[83], ch__17[62], 
	    ch__18[122], ch__19[15], ch__20[59], ch__21[70], ch__22[36];
    icilist ici__1;

    /* Builtin functions */
    integer i_indx(char *, char *, ftnlen, ftnlen), s_wsfe(cilist *), do_fio(
	    integer *, char *, ftnlen), e_wsfe(void);
    double r_mod(real *, real *);
    integer s_cmp(char *, char *, ftnlen, ftnlen), s_wsle(cilist *), do_lio(
	    integer *, integer *, char *, ftnlen), e_wsle(void), i_nint(real *
	    ), lbit_shift(integer, integer);
    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen),
	     s_stop(char *, ftnlen);
    double log(doublereal);
    integer s_rsfi(icilist *), e_rsfi(void);
    /* Subroutine */ int s_copy(char *, char *, ftnlen, ftnlen);
    integer s_wsfi(icilist *), e_wsfi(void);

    /* Local variables */
    static integer namstrt;
    static real tintstf;
    static integer lentemp;
    extern /* Subroutine */ int getgrace_(integer *, integer *, char *, 
	    integer *, integer *, integer *, integer *, integer *, integer *, 
	    integer *, integer *, ftnlen);
    extern integer igetbits_(integer *, integer *, integer *);
    static integer idotform;
    extern /* Subroutine */ int newvoice_(integer *, char *, logical *, 
	    ftnlen);
    static integer multtrem;
    extern /* Subroutine */ int dopmxlyr_(char *, integer *, ftnlen);
    static integer j, note1xtup;
    extern /* Subroutine */ int readmeter_(char *, integer *, integer *, 
	    integer *, ftnlen), midievent_(char *, integer *, integer *, 
	    ftnlen);
    static integer ic, jv, kv, nnb, iip, ipm, ivf, ndx, isl, iiv;
    static real hgt, dum;
    static integer iis, npg1, num1, iadj, nadj, lclf;
    extern /* Character */ VOID chax_(char *, ftnlen, integer *);
    static logical cdot;
    static integer nole, ioct;
    static real fnum;
    static char dotq[1], durq[1], dumq[1];
    extern /* Subroutine */ int getx_(char *, integer *, integer *, logical *,
	     real *, integer *, integer *, integer *, integer *, integer *, 
	    integer *, integer *, char *, integer *, ftnlen, ftnlen);
    static integer itup, nnnl, ntup, ndxm, nfig1;
    extern /* Subroutine */ int mrec1_(char *, integer *, integer *, ftnlen);
    static integer ipg1r;
    extern /* Subroutine */ int stop1_(void);
    static integer lhead;
    static char charq[1], lineq[128];
    static logical moved;
    static char tempq[24];
    static integer ndoub;
    extern /* Subroutine */ int sslur_(char *, integer *, integer *, integer *
	    , integer *, integer *, integer *, integer *, integer *, logical *
	    , integer *, char *, ftnlen, ftnlen);
    static integer ifnum, iplmi, isign, nvold, iinow, iinst;
    static real pmfac;
    extern /* Subroutine */ int getitransinfo_(logical *, integer *, char *, 
	    integer *, integer *, integer *, integer *, ftnlen);
    static logical quoted;
    static char lineqt[128], hdlndq[59];
    static logical inxtup;
    extern integer lenstr_(char *, integer *, ftnlen);
    static integer numnum, nsolid;
    extern /* Subroutine */ int getorn_(char *, integer *, integer *, integer 
	    *, logical *, integer *, integer *, integer *, logical *, logical 
	    *, integer *, ftnlen);
    static integer nnlivx;
    extern /* Subroutine */ int littex_(integer *, integer *, integer *, 
	    logical *, char *, integer *, ftnlen);
    static integer ictemp;
    extern /* Subroutine */ int getfig_(integer *, char *, char *, integer *, 
	    logical *, integer *, integer *, integer *, char *, integer *, 
	    integer *, integer *, ftnlen, ftnlen, ftnlen);
    static integer nactmp;
    extern /* Subroutine */ int getdyn_(integer *, integer *, integer *, 
	    integer *, char *, integer *, ftnlen);
    static integer nodurt;
    extern integer ncmidf_(char *, ftnlen);
    static integer nnliiv;
    extern /* Subroutine */ int getbuf_(char *, ftnlen), printl_(char *, 
	    ftnlen);
    static integer ibaroff, lenbeat;
    extern /* Subroutine */ int getchar_(char *, integer *, char *, ftnlen, 
	    ftnlen), getmidi_(integer *, char *, integer *, integer *, 
	    integer *, integer *, integer *, integer *, integer *, logical *, 
	    ftnlen), readnum_(char *, integer *, char *, real *, ftnlen, 
	    ftnlen);
    static integer nindent;
    extern /* Subroutine */ int setbits_(integer *, integer *, integer *, 
	    integer *), chkpm4ac_(char *, integer *, integer *, logical *, 
	    ftnlen);
    extern integer ifnodur_(integer *, char *, ftnlen);
    static integer numshft, iofforn;
    static real xofforn;
    extern integer ifnolev_(char *, integer *, integer *, ftnlen), numclef_(
	    char *, ftnlen);
    static integer itother;
    extern /* Subroutine */ int spsslur_(char *, integer *, integer *, 
	    integer *, integer *, integer *, integer *, integer *, integer *, 
	    integer *, logical *, integer *, char *, ftnlen, ftnlen), 
	    g1etchar_(char *, integer *, char *, ftnlen, ftnlen);
    static real fmovbrk;
    static integer lvoltxt, ltopnam;

    /* Fortran I/O blocks */
    static cilist io___767 = { 0, 11, 0, "(a)", 0 };
    static cilist io___775 = { 0, 6, 0, 0, 0 };
    static cilist io___786 = { 0, 6, 0, 0, 0 };
    static cilist io___787 = { 0, 6, 0, 0, 0 };
    static cilist io___798 = { 0, 6, 0, 0, 0 };
    static cilist io___799 = { 0, 6, 0, 0, 0 };
    static cilist io___815 = { 0, 6, 0, 0, 0 };
    static cilist io___816 = { 0, 6, 0, 0, 0 };
    static cilist io___817 = { 0, 6, 0, 0, 0 };
    static cilist io___819 = { 0, 6, 0, 0, 0 };
    static cilist io___824 = { 0, 11, 0, "(a)", 0 };
    static cilist io___825 = { 0, 11, 0, "(a)", 0 };
    static cilist io___828 = { 0, 11, 0, "(a)", 0 };
    static cilist io___829 = { 0, 11, 0, "(a)", 0 };
    static cilist io___830 = { 0, 11, 0, "(a)", 0 };
    static cilist io___831 = { 0, 11, 0, "(a)", 0 };
    static cilist io___832 = { 0, 11, 0, "(a)", 0 };
    static cilist io___833 = { 0, 11, 0, "(a11,i2,a)", 0 };
    static cilist io___834 = { 0, 11, 0, "(a9,i2,a)", 0 };
    static cilist io___836 = { 0, 11, 0, "(a8,i1,a3)", 0 };
    static cilist io___837 = { 0, 11, 0, "(a9,i2,a4)", 0 };
    static cilist io___838 = { 0, 11, 0, "(a8,i1,a)", 0 };
    static cilist io___839 = { 0, 11, 0, "(a9,i2,a)", 0 };
    static cilist io___840 = { 0, 6, 0, 0, 0 };
    static cilist io___841 = { 0, 6, 0, 0, 0 };
    static cilist io___850 = { 0, 6, 0, 0, 0 };
    static cilist io___852 = { 0, 11, 0, "(a)", 0 };
    static cilist io___853 = { 0, 11, 0, "(a)", 0 };
    static cilist io___854 = { 0, 11, 0, "(a)", 0 };
    static cilist io___855 = { 0, 11, 0, "(a)", 0 };
    static cilist io___857 = { 0, 11, 0, "(a)", 0 };
    static cilist io___860 = { 0, 11, 0, "(a)", 0 };
    static cilist io___861 = { 0, 11, 0, "(a)", 0 };
    static cilist io___862 = { 0, 11, 0, "(a)", 0 };
    static cilist io___863 = { 0, 11, 0, "(a)", 0 };
    static cilist io___864 = { 0, 11, 0, "(a)", 0 };
    static cilist io___865 = { 0, 11, 0, "(a)", 0 };
    static cilist io___866 = { 0, 11, 0, "(a)", 0 };
    static cilist io___867 = { 0, 11, 0, "(a)", 0 };
    static cilist io___869 = { 0, 11, 0, "(a)", 0 };



/*  nvmx is either 1 or 2.  ivmx(iv,1)=iv, ; ivmx(iv,2)>nv if defined */
/*  ivx is current ivmx, and is the index for all notes, acc's etc. */



#line 12415 ""
    cdot = FALSE_;
#line 12416 ""
    inxtup = FALSE_;
#line 12417 ""
L1:
#line 12417 ""
    getchar_(lineq, &all_1.iccount, charq, (ftnlen)128, (ftnlen)1);
#line 12418 ""
    if (comget_1.lastchar) {
#line 12418 ""
	return 0;
#line 12418 ""
    }
#line 12419 ""
    if (*(unsigned char *)charq == ' ') {
#line 12419 ""
	goto L1;
#line 12419 ""
    }
#line 12420 ""
    if (*(unsigned char *)charq == '%') {

/*  Check for a bar number format: */

#line 12424 ""
	if (all_1.iccount == 1 && *(unsigned char *)&lineq[1] == ' ' && 
		i_indx("bB1234567890", lineq + 2, (ftnlen)12, (ftnlen)1) > 0) 
		{
#line 12426 ""
	    if (comlast_1.islast) {
#line 12426 ""
		s_wsfe(&io___767);
#line 12426 ""
		do_fio(&c__1, lineq, lenstr_(lineq, &c__128, (ftnlen)128));
#line 12426 ""
		e_wsfe();
#line 12426 ""
	    }
#line 12427 ""
	}
#line 12428 ""
	all_1.iccount = 128;
#line 12429 ""
	goto L1;
#line 12430 ""
    }

/*  Closing repeat iff charq='/' and the prev. char was 'R' with 'd' or 'r' */

#line 12434 ""
    if (comget_1.rptprev) {
#line 12435 ""
	chax_(ch__1, (ftnlen)1, &c__47);
#line 12435 ""
	comget_1.rptnd1 = *(unsigned char *)charq == *(unsigned char *)&ch__1[
		0];
#line 12436 ""
	comget_1.rptprev = FALSE_;
#line 12437 ""
    }

/*  Repeat at end of a piece */

#line 12441 ""
    if (*(unsigned char *)charq >= 97 && *(unsigned char *)charq <= 103 || *(
	    unsigned char *)charq == 'r') {
#line 12443 ""
	if (cdot) {
#line 12443 ""
	    goto L28;
#line 12443 ""
	}

/*  This is a note/rest. */

#line 12447 ""
	idotform = 0;
#line 12448 ""
	numnum = 0;

/*  If start of line of music, set pitch from previous */

#line 12452 ""
	if (commvl_1.ivx <= all_1.nv) {
#line 12453 ""
	    kv = 1;
#line 12454 ""
	} else {
#line 12455 ""
	    kv = 2;
#line 12456 ""
	}
#line 12457 ""
	if (all_1.nnl[commvl_1.ivx - 1] == 0) {
#line 12457 ""
	    comnotes_1.lastlev = comnotes_1.ndlev[all_1.iv + kv * 24 - 25];
#line 12457 ""
	}

/*  notcrd is used to tell if orn. goes on main note or chord note */

/*        notcrd = .true.   !Move dow.  Was not observed if dotted shortcut. */

/*  Increase note count, then loop 'til blank. Label 28 is for dotted shortcuts. */

#line 12465 ""
L28:

/*  Moved this from just above, 2 Feb 02 */

#line 12469 ""
	comnotes_1.notcrd = TRUE_;
#line 12470 ""
	++all_1.nnl[commvl_1.ivx - 1];
#line 12471 ""
	if (comget_1.ornrpt) {

/*  Replicate ornament bits, also bit 23 for beam handling if chord. */

#line 12475 ""
	    all_1.iornq[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 24 - 1] 
		    |= all_1.iornq[commvl_1.ivx - 1];
#line 12476 ""
	    if ((all_1.iornq[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 24 
		    - 1] & 32896) > 0) {

/*  This is a trill (bit 7 or 15) so must dup the parameters */

#line 12480 ""
		++comtrill_1.ntrill;
#line 12481 ""
		comtrill_1.ivtrill[comtrill_1.ntrill - 1] = commvl_1.ivx;
#line 12482 ""
		comtrill_1.iptrill[comtrill_1.ntrill - 1] = all_1.nnl[
			commvl_1.ivx - 1];
#line 12483 ""
		comtrill_1.xnsktr[comtrill_1.ntrill - 1] = comtrill_1.xnsktr[
			comtrill_1.ntrill - 2];
#line 12484 ""
	    }
#line 12485 ""
	}
#line 12486 ""
	if (comget_1.stickys) {

/*  Grab stemlength shortening parameters from prior note */

#line 12490 ""
	    all_1.mult[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 24 - 25] =
		     bit_set(all_1.mult[commvl_1.ivx + all_1.nnl[commvl_1.ivx 
		    - 1] * 24 - 25],27);
#line 12491 ""
	    i__1 = igetbits_(&all_1.mult[commvl_1.ivx + (all_1.nnl[
		    commvl_1.ivx - 1] - 1) * 24 - 25], &c__6, &c__10);
#line 12491 ""
	    setbits_(&all_1.mult[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 
		    24 - 25], &c__6, &c__10, &i__1);
#line 12493 ""
	}
#line 12494 ""
	if (comfb_1.autofbon && comfb_1.tautofb > comtol_1.tol && ! 
		comget_1.fbon) {

/*  Doing auto forced beams, and period has been set, so check if this note */
/*    starts a period. */

#line 12499 ""
	    r__1 = all_1.itsofar[commvl_1.ivx - 1] - comfb_1.t1autofb;
#line 12499 ""
	    if (r_mod(&r__1, &comfb_1.tautofb) < comtol_1.tol) {

/*  Start a forced beam here */

#line 12503 ""
		++comfb_1.nfb[commvl_1.ivx - 1];
#line 12504 ""
		comget_1.fbon = TRUE_;
#line 12505 ""
		*(unsigned char *)&comfb_1.ulfbq[commvl_1.ivx + comfb_1.nfb[
			commvl_1.ivx - 1] * 24 - 25] = 'x';
#line 12506 ""
		comfb_1.t1fb[commvl_1.ivx + comfb_1.nfb[commvl_1.ivx - 1] * 
			24 - 25] = (real) all_1.itsofar[commvl_1.ivx - 1];
#line 12507 ""
	    }
#line 12508 ""
	}
#line 12509 ""
	if (comget_1.fbon) {
#line 12509 ""
	    all_1.ipl[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 24 - 25] = 
		    bit_set(all_1.ipl[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 
		    1] * 24 - 25],30);
#line 12509 ""
	}
#line 12510 ""
	*(unsigned char *)dotq = 'x';
#line 12511 ""
	if (*(unsigned char *)charq == 'r') {
#line 12511 ""
	    all_1.irest[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 24 - 25] 
		    = bit_set(all_1.irest[commvl_1.ivx + all_1.nnl[
		    commvl_1.ivx - 1] * 24 - 25],0);
#line 12511 ""
	}
#line 12513 ""
	if (bit_test(all_1.irest[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 
		24 - 25],0)) {

/*  Rest stuff.  First check if previous note was full-bar-pause */

#line 12517 ""
	    i__1 = all_1.iccount;
#line 12517 ""
	    if (s_cmp(lineq + i__1, " ", all_1.iccount + 1 - i__1, (ftnlen)1) 
		    == 0 && all_1.nnl[commvl_1.ivx - 1] > 1) {
#line 12519 ""
		if (bit_test(all_1.islur[commvl_1.ivx + (all_1.nnl[
			commvl_1.ivx - 1] - 1) * 24 - 25],19)) {
#line 12519 ""
		    all_1.islur[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 
			    24 - 25] = bit_set(all_1.islur[commvl_1.ivx + 
			    all_1.nnl[commvl_1.ivx - 1] * 24 - 25],19);
#line 12519 ""
		}
#line 12521 ""
	    }

/*  Set default rest level at 0 unless 2 voices/staff in which case it's -4 or 2 */
/*  for voice a or b.  Set a-types at 0 as encountered and adjust later */
/*  after '//'.  (Override heights will be set to 100+offset) */

#line 12527 ""
	    if (commvl_1.ivx <= all_1.nv) {
#line 12528 ""
		all_1.nolev[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 24 - 
			25] = 0;
#line 12529 ""
	    } else {
#line 12530 ""
		all_1.nolev[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 24 - 
			25] = 2;
#line 12531 ""
	    }
#line 12532 ""
	}
#line 12533 ""
L2:
#line 12533 ""
	getchar_(lineq, &all_1.iccount, durq, (ftnlen)128, (ftnlen)1);
#line 12534 ""
	ic = *(unsigned char *)durq;
#line 12535 ""
	if (ic <= 57 && ic >= 48) {

/*  Digit */

#line 12539 ""
	    if (numnum == 0) {
#line 12540 ""
		comnotes_1.nnodur = ic - 48;
#line 12541 ""
		numnum = 1;
#line 12542 ""
		goto L2;
#line 12543 ""
	    } else if (numnum == 1) {
#line 12544 ""
		ioct = ic - 48;
#line 12545 ""
		numnum = 2;
#line 12546 ""
		goto L2;
#line 12547 ""
	    } else {
#line 12548 ""
		s_wsle(&io___775);
#line 12548 ""
		do_lio(&c__9, &c__1, ">2 digits in note sym., ivx,nn:", (
			ftnlen)31);
#line 12548 ""
		do_lio(&c__3, &c__1, (char *)&commvl_1.ivx, (ftnlen)sizeof(
			integer));
#line 12548 ""
		do_lio(&c__3, &c__1, (char *)&all_1.nnl[commvl_1.ivx - 1], (
			ftnlen)sizeof(integer));
#line 12548 ""
		e_wsle();
#line 12549 ""
		stop1_();
#line 12550 ""
	    }
#line 12551 ""
	} else if (*(unsigned char *)durq == 'd') {
#line 12552 ""
	    *(unsigned char *)dotq = *(unsigned char *)durq;
#line 12553 ""
	    i__1 = all_1.iccount;
#line 12553 ""
	    if (s_cmp(lineq + i__1, "d", all_1.iccount + 1 - i__1, (ftnlen)1) 
		    == 0) {

/*  Double dot. */

#line 12557 ""
		++all_1.iccount;
#line 12558 ""
		all_1.islur[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 24 - 
			25] = bit_set(all_1.islur[commvl_1.ivx + all_1.nnl[
			commvl_1.ivx - 1] * 24 - 25],3);
#line 12559 ""
	    }
#line 12560 ""
	    i__1 = all_1.iccount;
#line 12560 ""
	    if (i_indx("+-", lineq + i__1, (ftnlen)2, all_1.iccount + 1 - 
		    i__1) > 0) {

/*  move a dot, unless next char is not part of a number */

#line 12564 ""
		i__1 = all_1.iccount + 1;
#line 12564 ""
		if (i_indx("0123456789.", lineq + i__1, (ftnlen)11, 
			all_1.iccount + 2 - i__1) == 0) {
#line 12564 ""
		    goto L2;
#line 12564 ""
		}
#line 12566 ""
		all_1.irest[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 24 - 
			25] = bit_set(all_1.irest[commvl_1.ivx + all_1.nnl[
			commvl_1.ivx - 1] * 24 - 25],19);
#line 12567 ""
		getchar_(lineq, &all_1.iccount, durq, (ftnlen)128, (ftnlen)1);
#line 12568 ""
		++comcc_1.ndotmv[commvl_1.ivx - 1];
#line 12569 ""
		++all_1.iccount;
#line 12570 ""
		readnum_(lineq, &all_1.iccount, dumq, &comcc_1.updot[
			commvl_1.ivx + comcc_1.ndotmv[commvl_1.ivx - 1] * 24 
			- 25], (ftnlen)128, (ftnlen)1);
#line 12571 ""
		if (*(unsigned char *)durq == '-') {
#line 12571 ""
		    comcc_1.updot[commvl_1.ivx + comcc_1.ndotmv[commvl_1.ivx 
			    - 1] * 24 - 25] = -comcc_1.updot[commvl_1.ivx + 
			    comcc_1.ndotmv[commvl_1.ivx - 1] * 24 - 25];
#line 12571 ""
		}
#line 12573 ""
		if (i_indx("+-", dumq, (ftnlen)2, (ftnlen)1) > 0) {

/*  Vertical shift also */

#line 12577 ""
		    ++all_1.iccount;
#line 12578 ""
		    readnum_(lineq, &all_1.iccount, durq, &comcc_1.rtdot[
			    commvl_1.ivx + comcc_1.ndotmv[commvl_1.ivx - 1] * 
			    24 - 25], (ftnlen)128, (ftnlen)1);
#line 12579 ""
		    if (*(unsigned char *)dumq == '-') {
#line 12579 ""
			comcc_1.rtdot[commvl_1.ivx + comcc_1.ndotmv[
				commvl_1.ivx - 1] * 24 - 25] = -comcc_1.rtdot[
				commvl_1.ivx + comcc_1.ndotmv[commvl_1.ivx - 
				1] * 24 - 25];
#line 12579 ""
		    }
#line 12581 ""
		} else {
#line 12582 ""
		    comcc_1.rtdot[commvl_1.ivx + comcc_1.ndotmv[commvl_1.ivx 
			    - 1] * 24 - 25] = 0.f;
#line 12583 ""
		}
#line 12584 ""
		--all_1.iccount;
#line 12585 ""
	    }
#line 12586 ""
	    goto L2;
#line 12587 ""
	} else if (*(unsigned char *)durq == 'p') {

/*  Full-bar rest as pause */

#line 12591 ""
	    all_1.islur[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 24 - 25] 
		    = bit_set(all_1.islur[commvl_1.ivx + all_1.nnl[
		    commvl_1.ivx - 1] * 24 - 25],19);
#line 12592 ""
	    goto L2;
#line 12593 ""
	} else if (*(unsigned char *)durq == 'b') {

/*  Blank rest */

#line 12597 ""
	    all_1.islur[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 24 - 25] 
		    = bit_set(all_1.islur[commvl_1.ivx + all_1.nnl[
		    commvl_1.ivx - 1] * 24 - 25],29);
#line 12598 ""
	    goto L2;
#line 12599 ""
	} else if (i_indx("fsn", durq, (ftnlen)3, (ftnlen)1) > 0) {

/*  Accidental */

/*          if (nacc(ivx,nnl(ivx)) .eq. 0) then */
#line 12604 ""
	    if (igetbits_(&all_1.nacc[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 
		    1] * 24 - 25], &c__2, &c__0) == 0) {

/*  No accidental has been set yet */

/*            nacc(ivx,nnl(ivx)) = index('fsn',durq) */
#line 12609 ""
		all_1.nacc[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 24 - 
			25] |= i_indx("fsn", durq, (ftnlen)3, (ftnlen)1);
#line 12611 ""
	    } else {

/*  Repeated accid, so must be double */

#line 12615 ""
		all_1.nacc[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 24 - 
			25] = bit_set(all_1.nacc[commvl_1.ivx + all_1.nnl[
			commvl_1.ivx - 1] * 24 - 25],2);
#line 12616 ""
	    }
#line 12617 ""
	    goto L2;
#line 12618 ""
	} else if (*(unsigned char *)durq == 'i') {

/*  Set flag for MIDI-only accidental. */

#line 12622 ""
	    all_1.nacc[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 24 - 25] =
		     bit_set(all_1.nacc[commvl_1.ivx + all_1.nnl[commvl_1.ivx 
		    - 1] * 24 - 25],17);
#line 12623 ""
	    goto L2;
#line 12624 ""
	} else if (*(unsigned char *)durq == 'c') {

/*  Set flags for cautionary accidental */

#line 12628 ""
	    all_1.irest[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 24 - 25] 
		    = bit_set(all_1.irest[commvl_1.ivx + all_1.nnl[
		    commvl_1.ivx - 1] * 24 - 25],31);
#line 12629 ""
	    all_1.iornq[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 24 - 1] =
		     bit_set(all_1.iornq[commvl_1.ivx + all_1.nnl[
		    commvl_1.ivx - 1] * 24 - 1],31);
#line 12630 ""
	    goto L2;
#line 12631 ""
	} else if (i_indx("+-<>", durq, (ftnlen)4, (ftnlen)1) > 0) {
#line 12632 ""
	    ipm = i_indx("- +", durq, (ftnlen)3, (ftnlen)1) - 2;
#line 12633 ""
	    if (! bit_test(all_1.irest[commvl_1.ivx + all_1.nnl[commvl_1.ivx 
		    - 1] * 24 - 25],0)) {

/*  A note, not a rest. */

#line 12637 ""
		chkpm4ac_(lineq, &all_1.iccount, &all_1.nacc[commvl_1.ivx + 
			all_1.nnl[commvl_1.ivx - 1] * 24 - 25], &moved, (
			ftnlen)128);
#line 12638 ""
		if (moved) {
#line 12638 ""
		    goto L2;
#line 12638 ""
		}

/*  Octave jump with a note */

#line 12642 ""
		if (numnum < 2) {
#line 12643 ""
		    comnotes_1.lastlev += ipm * 7;
#line 12644 ""
		} else {
#line 12645 ""
		    ioct += ipm;
#line 12646 ""
		}
#line 12647 ""
		goto L2;
#line 12648 ""
	    } else {

/*  Override default height of a rest */

#line 12652 ""
		++all_1.iccount;
#line 12653 ""
		readnum_(lineq, &all_1.iccount, durq, &fnum, (ftnlen)128, (
			ftnlen)1);
#line 12654 ""
		i__1 = all_1.iccount - 2;
#line 12654 ""
		if (s_cmp(lineq + i__1, ".", all_1.iccount - 1 - i__1, (
			ftnlen)1) == 0) {

/*  Kluge in case there is a shortcut ".". It will have been sucked up by */
/*  readnum.  (Same doesn't hold for ",") */

#line 12659 ""
		    --all_1.iccount;
/*               go to 2 */
#line 12661 ""
		}
#line 12662 ""
		all_1.nolev[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 24 - 
			25] = ipm * i_nint(&fnum) + 100;

/*  There may be more characters for this rest */

#line 12666 ""
		--all_1.iccount;
#line 12667 ""
		goto L2;
#line 12668 ""
	    }
#line 12669 ""
	} else if (*(unsigned char *)durq == 'x') {

/*  Xtuplet.  Count number of doubled notes (for unequal xtups) */

#line 12673 ""
	    if (bit_test(all_1.nacc[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1]
		     * 24 - 25],18)) {
#line 12674 ""
		ndoub = 1;
#line 12675 ""
	    } else {
#line 12676 ""
		ndoub = 0;
#line 12677 ""
	    }

/*  Initialize counter for # of non-rests, so can later unbeam if = 1. */

#line 12681 ""
	    inxtup = TRUE_;
#line 12682 ""
	    note1xtup = all_1.nnl[commvl_1.ivx - 1];
#line 12683 ""
	    nnb = 0;
#line 12684 ""
	    if (! bit_test(all_1.irest[commvl_1.ivx + all_1.nnl[commvl_1.ivx 
		    - 1] * 24 - 25],0)) {
#line 12684 ""
		nnb = 1;
#line 12684 ""
	    }

/*  Will set all durations to 0 except last one.  Set flag on this note. */

#line 12688 ""
	    all_1.irest[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 24 - 25] 
		    = bit_set(all_1.irest[commvl_1.ivx + all_1.nnl[
		    commvl_1.ivx - 1] * 24 - 25],28);

/*  Next input will be digit unless its a "T" */

#line 12692 ""
	    ++all_1.iccount;
#line 12693 ""
	    if (*(unsigned char *)&lineq[all_1.iccount - 1] == 'T') {

/*  Set up tremolo */

#line 12697 ""
		all_1.irest[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 24 - 
			25] = bit_set(all_1.irest[commvl_1.ivx + all_1.nnl[
			commvl_1.ivx - 1] * 24 - 25],2);
#line 12698 ""
		ntup = 2;

/*  Set default beaming, based on Wikipedia article */
/*  May be a problem here is nnodur is inherited */

#line 12703 ""
		if (comnotes_1.nnodur == 4) {
#line 12704 ""
		    nsolid = 0;
#line 12705 ""
		    nindent = 3;
#line 12706 ""
		} else if (comnotes_1.nnodur == 2) {
#line 12707 ""
		    nsolid = 3;
#line 12708 ""
		    nindent = 0;
#line 12709 ""
		} else if (comnotes_1.nnodur == 8) {
#line 12710 ""
		    nsolid = 1;
#line 12711 ""
		    nindent = 2;
#line 12712 ""
		}
#line 12713 ""
		getchar_(lineq, &all_1.iccount, durq, (ftnlen)128, (ftnlen)1);
#line 12714 ""
		if (i_indx("0123456789", durq, (ftnlen)10, (ftnlen)1) > 0) {
#line 12715 ""
		    nsolid = i_indx("0123456789", durq, (ftnlen)10, (ftnlen)1)
			     - 1;
#line 12716 ""
		    if (nsolid == 0 && comnotes_1.nnodur == 2) {
#line 12717 ""
			s_wsle(&io___786);
#line 12717 ""
			do_lio(&c__9, &c__1, "", (ftnlen)0);
#line 12717 ""
			e_wsle();
#line 12718 ""
			s_wsle(&io___787);
#line 12718 ""
			do_lio(&c__9, &c__1, "Unbeamed half-note 2-note trem"\
				"olo forbidden.", (ftnlen)44);
#line 12718 ""
			e_wsle();
#line 12719 ""
			stop1_();
#line 12720 ""
		    }
#line 12721 ""
		    getchar_(lineq, &all_1.iccount, durq, (ftnlen)128, (
			    ftnlen)1);
#line 12722 ""
		    if (i_indx("0123456789", durq, (ftnlen)10, (ftnlen)1) > 0)
			     {
#line 12723 ""
			nindent = i_indx("0123456789", durq, (ftnlen)10, (
				ftnlen)1) - 1;
#line 12724 ""
		    }
#line 12725 ""
		}
#line 12726 ""
		setbits_(&all_1.irest[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 
			1] * 24 - 25], &c__2, &c__3, &nsolid);
#line 12727 ""
		setbits_(&all_1.irest[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 
			1] * 24 - 25], &c__2, &c__5, &nindent);
#line 12728 ""
		if (nsolid == 0) {
#line 12729 ""
		    all_1.islur[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 
			    24 - 25] = bit_set(all_1.islur[commvl_1.ivx + 
			    all_1.nnl[commvl_1.ivx - 1] * 24 - 25],18);
#line 12731 ""
		}
#line 12732 ""
		all_1.islur[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 24 - 
			25] = bit_set(all_1.islur[commvl_1.ivx + all_1.nnl[
			commvl_1.ivx - 1] * 24 - 25],31);
#line 12733 ""
		all_1.islur[commvl_1.ivx + (all_1.nnl[commvl_1.ivx - 1] + 1) *
			 24 - 25] = bit_set(all_1.islur[commvl_1.ivx + (
			all_1.nnl[commvl_1.ivx - 1] + 1) * 24 - 25],21);
#line 12734 ""
		setbits_(&all_1.islur[commvl_1.ivx + (all_1.nnl[commvl_1.ivx 
			- 1] + 1) * 24 - 25], &c__3, &c__22, &nsolid);

/*  Set some force-beam parameters for the tremolo */

/*  Need to check if there's already a forced beam explicitly set here. */
/*  If there was, shouldn't do any harm resetting parameters. */

#line 12741 ""
		if (comfb_1.nfb[commvl_1.ivx - 1] == 0 || comfb_1.t1fb[
			commvl_1.ivx + comfb_1.nfb[commvl_1.ivx - 1] * 24 - 
			25] != (real) all_1.itsofar[commvl_1.ivx - 1]) {
#line 12741 ""
		    ++comfb_1.nfb[commvl_1.ivx - 1];
#line 12741 ""
		}
#line 12743 ""
		comget_1.fbon = TRUE_;
#line 12744 ""
		*(unsigned char *)&comfb_1.ulfbq[commvl_1.ivx + comfb_1.nfb[
			commvl_1.ivx - 1] * 24 - 25] = 'x';
#line 12745 ""
		comfb_1.t1fb[commvl_1.ivx + comfb_1.nfb[commvl_1.ivx - 1] * 
			24 - 25] = (real) all_1.itsofar[commvl_1.ivx - 1];
#line 12746 ""
		comfb_1.t2fb[commvl_1.ivx + comfb_1.nfb[commvl_1.ivx - 1] * 
			24 - 25] = (real) (all_1.itsofar[commvl_1.ivx - 1] + 
			ifnodur_(&comnotes_1.nnodur, dotq, (ftnlen)1));
#line 12747 ""
		nadj = 0;

/* Set open beamed notehead flag for half-note tremolo */
/*   Just gave 2 quarters with or without flag set. Need to fix */

#line 12752 ""
	    } else {
#line 12753 ""
		readnum_(lineq, &all_1.iccount, durq, &fnum, (ftnlen)128, (
			ftnlen)1);
#line 12754 ""
		ntup = i_nint(&fnum);
#line 12755 ""
	    }
#line 12756 ""
	    if (i_indx("DF", durq, (ftnlen)2, (ftnlen)1) > 0) {


/*  Double xtup note to make an un= xtup. Here xtup number already set but may also */
/*    have this command before. */

#line 12762 ""
		all_1.nacc[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 24 - 
			25] = bit_set(all_1.nacc[commvl_1.ivx + all_1.nnl[
			commvl_1.ivx - 1] * 24 - 25],18);
#line 12763 ""
		if (*(unsigned char *)durq == 'F') {
#line 12763 ""
		    all_1.nacc[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 
			    24 - 25] = bit_set(all_1.nacc[commvl_1.ivx + 
			    all_1.nnl[commvl_1.ivx - 1] * 24 - 25],19);
#line 12763 ""
		}
#line 12765 ""
		ndoub = 1;
#line 12766 ""
		getchar_(lineq, &all_1.iccount, durq, (ftnlen)128, (ftnlen)1);
#line 12767 ""
	    } else if (*(unsigned char *)durq == 'd') {
#line 12768 ""
		all_1.nacc[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 24 - 
			25] = bit_set(all_1.nacc[commvl_1.ivx + all_1.nnl[
			commvl_1.ivx - 1] * 24 - 25],27);
#line 12769 ""
		getchar_(lineq, &all_1.iccount, durq, (ftnlen)128, (ftnlen)1);
#line 12770 ""
	    }

/*  Only other possibilities here are ' ' or 'n' */

#line 12774 ""
	    if (*(unsigned char *)durq == 'n') {

/*  Alter xtup number */

#line 12778 ""
		i__1 = all_1.iccount;
#line 12778 ""
		if (s_cmp(lineq + i__1, " ", all_1.iccount + 1 - i__1, (
			ftnlen)1) == 0) {

/*  If the only modifier is 'n', cancel the number */

#line 12782 ""
		    all_1.islur[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 
			    24 - 25] = bit_set(all_1.islur[commvl_1.ivx + 
			    all_1.nnl[commvl_1.ivx - 1] * 24 - 25],31);
#line 12783 ""
		} else {
#line 12784 ""
		    numshft = 0;
#line 12785 ""
L30:
#line 12785 ""
		    getchar_(lineq, &all_1.iccount, durq, (ftnlen)128, (
			    ftnlen)1);
#line 12786 ""
		    if (*(unsigned char *)durq == 'f') {

/*  Flip up-down-ness */

#line 12790 ""
			all_1.irest[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1]
				 * 24 - 25] = bit_set(all_1.irest[
				commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 
				24 - 25],14);
#line 12791 ""
			goto L30;
#line 12792 ""
		    } else if (i_indx("+-", durq, (ftnlen)2, (ftnlen)1) > 0) {

/*  Vertical or horiz shift */

#line 12796 ""
			++numshft;
#line 12797 ""
			iofforn = 1;
#line 12798 ""
			if (*(unsigned char *)durq == '-') {
#line 12798 ""
			    iofforn = -1;
#line 12798 ""
			}
#line 12799 ""
			++all_1.iccount;
#line 12800 ""
			readnum_(lineq, &all_1.iccount, durq, &xofforn, (
				ftnlen)128, (ftnlen)1);
#line 12801 ""
			--all_1.iccount;
#line 12802 ""
			if (numshft == 1) {

/*  Vertical shift */
/*  160214 Allow (-64,64) */
#line 12806 ""
			    iofforn = iofforn * i_nint(&xofforn) + 64;

/*  Turn on bit 1 of irest; set bits 16-22 of mult to iofforn */

#line 12810 ""
			    all_1.irest[commvl_1.ivx + all_1.nnl[commvl_1.ivx 
				    - 1] * 24 - 25] = bit_set(all_1.irest[
				    commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1]
				     * 24 - 25],1);
#line 12811 ""
			    setbits_(&all_1.mult[commvl_1.ivx + all_1.nnl[
				    commvl_1.ivx - 1] * 24 - 25], &c__8, &
				    c__16, &iofforn);
#line 12812 ""
			} else {

/*  Horizontal shift */

#line 12816 ""
			    r__1 = xofforn * 10;
#line 12816 ""
			    iofforn = iofforn * i_nint(&r__1) + 16;
#line 12817 ""
			    all_1.irest[commvl_1.ivx + all_1.nnl[commvl_1.ivx 
				    - 1] * 24 - 25] = bit_set(all_1.irest[
				    commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1]
				     * 24 - 25],7);
#line 12818 ""
			    setbits_(&all_1.irest[commvl_1.ivx + all_1.nnl[
				    commvl_1.ivx - 1] * 24 - 25], &c__5, &
				    c__9, &iofforn);
#line 12819 ""
			}
#line 12820 ""
			goto L30;
#line 12821 ""
		    } else if (*(unsigned char *)durq == 's') {

/* Slope adjustment for bracket */

#line 12825 ""
			all_1.mult[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] 
				* 24 - 25] = bit_set(all_1.mult[commvl_1.ivx 
				+ all_1.nnl[commvl_1.ivx - 1] * 24 - 25],4);
#line 12826 ""
			getchar_(lineq, &all_1.iccount, durq, (ftnlen)128, (
				ftnlen)1);
#line 12827 ""
			iofforn = i_indx("- +", durq, (ftnlen)3, (ftnlen)1) - 
				2;
#line 12828 ""
			++all_1.iccount;
#line 12829 ""
			readnum_(lineq, &all_1.iccount, durq, &xofforn, (
				ftnlen)128, (ftnlen)1);
#line 12830 ""
			--all_1.iccount;
#line 12831 ""
			r__1 = iofforn * xofforn + 16;
#line 12831 ""
			iofforn = i_nint(&r__1);
#line 12832 ""
			setbits_(&all_1.mult[commvl_1.ivx + all_1.nnl[
				commvl_1.ivx - 1] * 24 - 25], &c__5, &c__5, &
				iofforn);
#line 12833 ""
		    } else if (i_indx("123456789", durq, (ftnlen)9, (ftnlen)1)
			     > 0) {

/*  Replacement printed number */

#line 12837 ""
			readnum_(lineq, &all_1.iccount, durq, &xofforn, (
				ftnlen)128, (ftnlen)1);
#line 12838 ""
			i__1 = i_nint(&xofforn);
#line 12838 ""
			setbits_(&all_1.nacc[commvl_1.ivx + all_1.nnl[
				commvl_1.ivx - 1] * 24 - 25], &c__5, &c__22, &
				i__1);
#line 12839 ""
			--all_1.iccount;
#line 12840 ""
			goto L30;
#line 12841 ""
		    }
#line 12842 ""
		}
#line 12843 ""
	    }

/*  Set note level of 1st note of xtup, provided not a rest */

#line 12847 ""
	    if (! bit_test(all_1.irest[commvl_1.ivx + all_1.nnl[commvl_1.ivx 
		    - 1] * 24 - 25],0)) {
#line 12848 ""
		if (numnum == 2) {
#line 12849 ""
		    comnotes_1.lastlev = ifnolev_(charq, &ioct, &
			    cominsttrans_1.itransamt[cominsttrans_1.instno[
			    all_1.iv - 1] - 1], (ftnlen)1);
#line 12850 ""
		    all_1.nolev[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 
			    24 - 25] = comnotes_1.lastlev;
#line 12851 ""
		} else {
#line 12852 ""
		    comnotes_1.lastlev = comnotes_1.lastlev - 3 + (ifnolev_(
			    charq, &c__10, &cominsttrans_1.itransamt[
			    cominsttrans_1.instno[all_1.iv - 1] - 1], (ftnlen)
			    1) - comnotes_1.lastlev + 3) % 7;
#line 12854 ""
		    all_1.nolev[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 
			    24 - 25] = comnotes_1.lastlev;
#line 12855 ""
		}
#line 12856 ""
	    }
#line 12857 ""
	    for (comnotes_1.npreslur = comnotes_1.npreslur; 
		    comnotes_1.npreslur >= 1; --comnotes_1.npreslur) {

/*  Set note level for preslur on starting note of xtuplet */

#line 12861 ""
		setbits_(&all_1.isdat2[all_1.nsdat - comnotes_1.npreslur], &
			c__7, &c__19, &comnotes_1.lastlev);
#line 12862 ""
/* L40: */
#line 12862 ""
	    }
#line 12863 ""
	    numnum = 0;
#line 12864 ""
	    all_1.nodur[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 24 - 25] 
		    = 0;
#line 12865 ""
	    i__1 = ntup;
#line 12865 ""
	    for (itup = 2; itup <= i__1; ++itup) {
#line 12866 ""
		if (comget_1.ornrpt) {
#line 12867 ""
		    all_1.iornq[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 
			    24 - 1] |= all_1.iornq[commvl_1.ivx + (all_1.nnl[
			    commvl_1.ivx - 1] - 1) * 24 - 1] & 10026991;
#line 12869 ""
		    if ((all_1.iornq[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 
			    1] * 24 - 1] & 32896) > 0) {

/*  This is a trill (bit 7 or 15) so must dup the parameters */

#line 12873 ""
			++comtrill_1.ntrill;
#line 12874 ""
			comtrill_1.ivtrill[comtrill_1.ntrill - 1] = 
				commvl_1.ivx;
#line 12875 ""
			comtrill_1.iptrill[comtrill_1.ntrill - 1] = all_1.nnl[
				commvl_1.ivx - 1];
#line 12876 ""
			comtrill_1.xnsktr[comtrill_1.ntrill - 1] = 
				comtrill_1.xnsktr[comtrill_1.ntrill - 2];
#line 12877 ""
		    }
#line 12878 ""
		}
#line 12879 ""
		++all_1.nnl[commvl_1.ivx - 1];
#line 12880 ""
		if (comget_1.fbon) {
#line 12880 ""
		    all_1.ipl[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 24 
			    - 25] = bit_set(all_1.ipl[commvl_1.ivx + 
			    all_1.nnl[commvl_1.ivx - 1] * 24 - 25],30);
#line 12880 ""
		}
#line 12881 ""
L7:
#line 12881 ""
		getchar_(lineq, &all_1.iccount, charq, (ftnlen)128, (ftnlen)1)
			;
#line 12882 ""
		if (*(unsigned char *)charq == ' ') {
#line 12883 ""
		    goto L7;
#line 12884 ""
		} else if (*(unsigned char *)charq == '%') {
#line 12885 ""
		    all_1.iccount = 128;
#line 12886 ""
		    goto L7;
#line 12887 ""
		} else if (*(unsigned char *)charq == 'o') {

/*  Ornament in xtuplet.  "o" symbol must come AFTER the affected note */

#line 12891 ""
		    if (comnotes_1.notcrd) {
#line 12892 ""
			nole = all_1.nolev[commvl_1.ivx + (all_1.nnl[
				commvl_1.ivx - 1] - 1) * 24 - 25];
#line 12893 ""
		    } else {
#line 12894 ""
			nole = 127 & lbit_shift(comtrill_1.icrdat[
				comtrill_1.ncrd - 1], (ftnlen)-12);
#line 12895 ""
		    }
#line 12896 ""
		    i__2 = all_1.nnl[commvl_1.ivx - 1] - 1;
#line 12896 ""
		    getorn_(lineq, &all_1.iccount, &all_1.iornq[commvl_1.ivx 
			    + (all_1.nnl[commvl_1.ivx - 1] - 1) * 24 - 1], &
			    all_1.iornq[commvl_1.ivx - 1], &comget_1.ornrpt, &
			    comgrace_1.noffseg, &i__2, &commvl_1.ivx, &
			    c_false, &comnotes_1.notcrd, &nole, (ftnlen)128);
#line 12899 ""
		    goto L7;
#line 12900 ""
		} else if (i_indx("st(){}", charq, (ftnlen)6, (ftnlen)1) > 0) 
			{
#line 12901 ""
		    nnlivx = all_1.nnl[commvl_1.ivx - 1] - 1;
#line 12902 ""
		    if (*(unsigned char *)charq == '(' || *(unsigned char *)
			    charq == '{') {

/*  Detected preslur in xtuplet loop, non-chord note */

#line 12906 ""
			++nnlivx;
#line 12907 ""
			++comnotes_1.npreslur;
#line 12908 ""
		    }
#line 12909 ""
		    all_1.islur[commvl_1.ivx + nnlivx * 24 - 25] = bit_set(
			    all_1.islur[commvl_1.ivx + nnlivx * 24 - 25],0);
#line 12910 ""
		    if (*(unsigned char *)charq == 't') {
#line 12910 ""
			all_1.islur[commvl_1.ivx + nnlivx * 24 - 25] = 
				bit_set(all_1.islur[commvl_1.ivx + nnlivx * 
				24 - 25],1);
#line 12910 ""
		    }
#line 12912 ""
		    if (commvl_1.ivx <= all_1.nv) {
#line 12913 ""
			kv = 1;
#line 12914 ""
		    } else {
#line 12915 ""
			kv = 2;
#line 12916 ""
		    }
#line 12917 ""
		    if (comslur_1.fontslur) {
#line 12918 ""
			sslur_(lineq, &all_1.iccount, &all_1.iv, &kv, &nnlivx,
				 all_1.isdat1, all_1.isdat2, all_1.isdat3, &
				all_1.nsdat, &comnotes_1.notcrd, &all_1.nolev[
				commvl_1.ivx + nnlivx * 24 - 25], charq, (
				ftnlen)128, (ftnlen)1);
#line 12920 ""
		    } else {
#line 12921 ""
			spsslur_(lineq, &all_1.iccount, &all_1.iv, &kv, &
				nnlivx, all_1.isdat1, all_1.isdat2, 
				all_1.isdat3, all_1.isdat4, &all_1.nsdat, &
				comnotes_1.notcrd, &all_1.nolev[commvl_1.ivx 
				+ nnlivx * 24 - 25], charq, (ftnlen)128, (
				ftnlen)1);
#line 12923 ""
		    }
#line 12924 ""
		    goto L7;
#line 12925 ""
		} else if (*(unsigned char *)charq == 'G') {

/* Kluge to get grace in xtup at right location */

#line 12929 ""
		    --all_1.nnl[commvl_1.ivx - 1];
#line 12930 ""
		    getgrace_(&commvl_1.ivx, all_1.nnl, lineq, &all_1.iccount,
			     all_1.islur, all_1.iornq, all_1.ipl, 
			    comnotes_1.ndlev, &comnotes_1.lastlev, &all_1.iv, 
			    &all_1.nv, (ftnlen)128);
#line 12932 ""
		    ++all_1.nnl[commvl_1.ivx - 1];
#line 12933 ""
		    goto L7;
#line 12934 ""
		} else if (*(unsigned char *)charq == *(unsigned char *)
			all_1.sq) {
#line 12935 ""
		    littex_(all_1.islur, &all_1.nnl[commvl_1.ivx - 1], &
			    commvl_1.ivx, &comas3_1.topmods, lineq, &
			    all_1.iccount, (ftnlen)128);
#line 12936 ""
		    goto L7;
#line 12937 ""
		} else /* if(complicated condition) */ {
#line 12937 ""
		    chax_(ch__1, (ftnlen)1, &c__34);
#line 12937 ""
		    if (*(unsigned char *)charq == *(unsigned char *)&ch__1[0]
			    ) {

/*  pmxlyr string in xtup. Expand "..." to \pmxlyr{...}\ */

#line 12941 ""
			if (! comlyr_1.inputmlyr) {
#line 12942 ""
			    ictemp = 0;
/* Writing concatenation */
#line 12943 ""
			    i__3[0] = 1, a__1[0] = all_1.sq;
#line 12943 ""
			    i__3[1] = 1, a__1[1] = all_1.sq;
#line 12943 ""
			    i__3[2] = 1, a__1[2] = all_1.sq;
#line 12943 ""
			    i__3[3] = 15, a__1[3] = "input musixlyr ";
#line 12943 ""
			    i__3[4] = 1, a__1[4] = all_1.sq;
#line 12943 ""
			    s_cat(lineqt, a__1, i__3, &c__5, (ftnlen)128);
#line 12944 ""
			    i__2 = all_1.nnl[commvl_1.ivx - 1] + 1;
#line 12944 ""
			    littex_(all_1.islur, &i__2, &commvl_1.ivx, &
				    comas3_1.topmods, lineqt, &ictemp, (
				    ftnlen)128);
#line 12945 ""
			    comlyr_1.inputmlyr = TRUE_;
#line 12946 ""
			}
#line 12947 ""
			dopmxlyr_(lineq, &all_1.iccount, (ftnlen)128);
#line 12948 ""
			*(unsigned char *)charq = *(unsigned char *)all_1.sq;
#line 12949 ""
			littex_(all_1.islur, &all_1.nnl[commvl_1.ivx - 1], &
				commvl_1.ivx, &comas3_1.topmods, lineq, &
				all_1.iccount, (ftnlen)128);
#line 12950 ""
			goto L7;
#line 12951 ""
		    } else if (i_indx("0123456789#-nx_", charq, (ftnlen)15, (
			    ftnlen)1) > 0) {

/*  Figure.  Must come AFTER the first note of xtup */

#line 12955 ""
			ivf = 1;
#line 12956 ""
			if (commvl_1.ivx > 1) {
#line 12957 ""
			    if (comfig_1.ivxfig2 == 0) {
#line 12958 ""
				comfig_1.ivxfig2 = commvl_1.ivx;
#line 12959 ""
			    } else if (commvl_1.ivx != comfig_1.ivxfig2) {
#line 12960 ""
				s_wsle(&io___798);
#line 12960 ""
				e_wsle();
#line 12961 ""
				s_wsle(&io___799);
#line 12961 ""
				do_lio(&c__9, &c__1, "Figures not allowed in"\
					" >1 voice above first", (ftnlen)43);
#line 12961 ""
				e_wsle();
#line 12962 ""
				s_stop("", (ftnlen)0);
#line 12963 ""
			    }
#line 12964 ""
			    ivf = 2;
#line 12965 ""
			}
#line 12966 ""
			nfig1 = comfig_1.nfigs[ivf - 1] + 1;
#line 12967 ""
			getfig_(&comgrace_1.itoff[ivf + (nfig1 << 1) - 3], 
				charq, lineq, &all_1.iccount, &all_1.isfig[
				ivf + (all_1.nnl[commvl_1.ivx - 1] - 1 << 1) 
				- 3], &comfig_1.itfig[ivf + (nfig1 << 1) - 3],
				 &all_1.itsofar[commvl_1.ivx - 1], &c__0, 
				comfig_1.figq + (ivf + (nfig1 << 1) - 3) * 10,
				 &comfig_1.ivupfig[ivf + (nfig1 << 1) - 3], &
				comfig_1.ivvfig[ivf + (nfig1 << 1) - 3], &
				comfig_1.nfigs[ivf - 1], (ftnlen)1, (ftnlen)
				128, (ftnlen)10);
#line 12971 ""
			goto L7;
#line 12972 ""
		    } else if (*(unsigned char *)charq == 'X') {
/* Computing MAX */
#line 12973 ""
			i__2 = 1, i__4 = all_1.nnl[commvl_1.ivx - 1] - 1;
#line 12973 ""
			getx_(lineq, &all_1.iccount, &all_1.irest[
				commvl_1.ivx + max(i__2,i__4) * 24 - 25], &
				comnotes_1.shifton, &comask_1.wheadpt, &
				all_1.iornq[commvl_1.ivx + all_1.nnl[
				commvl_1.ivx - 1] * 24 - 1], &commvl_1.ivx, &
				all_1.irest[commvl_1.ivx + all_1.nnl[
				commvl_1.ivx - 1] * 24 - 25], &all_1.itsofar[
				commvl_1.ivx - 1], &ntup, &itup, &
				comnotes_1.nnodur, dotq, &ndoub, (ftnlen)128, 
				(ftnlen)1);
#line 12977 ""
			goto L7;
#line 12978 ""
		    } else if (*(unsigned char *)charq == 'z') {

/*  Chord note in xtup.  Goes with *prior* note. */

#line 12982 ""
			comnotes_1.notcrd = FALSE_;
#line 12983 ""
			++comtrill_1.ncrd;
#line 12984 ""
			all_1.ipl[commvl_1.ivx + (all_1.nnl[commvl_1.ivx - 1] 
				- 1) * 24 - 25] = bit_set(all_1.ipl[
				commvl_1.ivx + (all_1.nnl[commvl_1.ivx - 1] - 
				1) * 24 - 25],10);
#line 12985 ""
			numnum = 0;
#line 12986 ""
			comtrill_1.icrdat[comtrill_1.ncrd - 1] = all_1.nnl[
				commvl_1.ivx - 1] - 1;
#line 12987 ""
			i__2 = commvl_1.ivx % 16;
#line 12987 ""
			setbits_(&comtrill_1.icrdat[comtrill_1.ncrd - 1], &
				c__4, &c__8, &i__2);
#line 12988 ""
			if (commvl_1.ivx >= 16) {
#line 12988 ""
			    comtrill_1.icrdat[comtrill_1.ncrd - 1] = bit_set(
				    comtrill_1.icrdat[comtrill_1.ncrd - 1],28)
				    ;
#line 12988 ""
			}
#line 12989 ""
			comtrill_1.icrdorn[comtrill_1.ncrd - 1] = 0;

/*  Get note name */

#line 12993 ""
			getchar_(lineq, &all_1.iccount, charq, (ftnlen)128, (
				ftnlen)1);

/*  Get optional inputs */

#line 12997 ""
L34:
#line 12997 ""
			getchar_(lineq, &all_1.iccount, durq, (ftnlen)128, (
				ftnlen)1);

/*  When chord note is done, will get ' ', making ndx=0, so go past this block */

#line 13001 ""
			ndx = i_indx("fsn+-<>12345678reicd", durq, (ftnlen)20,
				 (ftnlen)1);
#line 13002 ""
			if (ndx > 0) {
#line 13003 ""
			    if (ndx <= 3) {
#line 13004 ""
				if (! bit_test(comtrill_1.icrdat[
					comtrill_1.ncrd - 1],19)) {
#line 13005 ""
				    comtrill_1.icrdat[comtrill_1.ncrd - 1] = 
					    bit_set(comtrill_1.icrdat[
					    comtrill_1.ncrd - 1],19);
#line 13006 ""
				    comtrill_1.icrdat[comtrill_1.ncrd - 1] |= 
					    ndx << 20;
#line 13007 ""
				} else {
#line 13008 ""
				    comtrill_1.icrdat[comtrill_1.ncrd - 1] = 
					    bit_set(comtrill_1.icrdat[
					    comtrill_1.ncrd - 1],22);
#line 13009 ""
				}
#line 13010 ""
			    } else if (*(unsigned char *)durq == 'd') {

/* Get dot on chord note in xtup. Assume +n+n */

#line 13014 ""
				comtrill_1.icrdat[comtrill_1.ncrd - 1] = 
					bit_set(comtrill_1.icrdat[
					comtrill_1.ncrd - 1],26);
#line 13015 ""
				getchar_(lineq, &all_1.iccount, durq, (ftnlen)
					128, (ftnlen)1);
#line 13016 ""
				++all_1.iccount;
#line 13017 ""
				readnum_(lineq, &all_1.iccount, dumq, &fnum, (
					ftnlen)128, (ftnlen)1);
#line 13018 ""
				if (*(unsigned char *)durq == '+') {
#line 13019 ""
				    r__1 = fnum * 10;
#line 13019 ""
				    comtrill_1.icrdot[comtrill_1.ncrd - 1] |= 
					    i_nint(&r__1) + 64;
#line 13020 ""
				} else {
#line 13021 ""
				    r__1 = fnum * 10;
#line 13021 ""
				    comtrill_1.icrdot[comtrill_1.ncrd - 1] |= 
					    -i_nint(&r__1) + 64;
#line 13022 ""
				}
#line 13023 ""
				if (i_indx("+-", dumq, (ftnlen)2, (ftnlen)1) 
					> 0) {

/*  Vertical shift specified also */

#line 13027 ""
				    ++all_1.iccount;
#line 13028 ""
				    readnum_(lineq, &all_1.iccount, durq, &
					    fnum, (ftnlen)128, (ftnlen)1);
#line 13029 ""
				    if (*(unsigned char *)dumq == '+') {
#line 13030 ""
					r__1 = fnum * 10;
#line 13030 ""
					ifnum = i_nint(&r__1) + 64;
#line 13031 ""
				    } else {
#line 13032 ""
					r__1 = fnum * 10;
#line 13032 ""
					ifnum = -i_nint(&r__1) + 64;
#line 13033 ""
				    }
#line 13034 ""
				} else {
#line 13035 ""
				    ifnum = 64;
#line 13036 ""
				}
#line 13037 ""
				comtrill_1.icrdot[comtrill_1.ncrd - 1] |= 
					ifnum << 7;
#line 13038 ""
				--all_1.iccount;
/*           iccount = iccount+4 */



#line 13043 ""
			    } else if (ndx == 19) {

/*  Set flags for cautionary accidental */

#line 13047 ""
				comtrill_1.icrdat[comtrill_1.ncrd - 1] = 
					bit_set(comtrill_1.icrdat[
					comtrill_1.ncrd - 1],31);
#line 13048 ""
				all_1.iornq[commvl_1.ivx + (all_1.nnl[
					commvl_1.ivx - 1] - 1) * 24 - 1] = 
					bit_set(all_1.iornq[commvl_1.ivx + (
					all_1.nnl[commvl_1.ivx - 1] - 1) * 24 
					- 1],31);
#line 13050 ""
			    } else if (ndx <= 7) {

/* +/-/</> Check whether octave or accidental shift */

#line 13054 ""
				nactmp = 0;
#line 13055 ""
				chkpm4ac_(lineq, &all_1.iccount, &nactmp, &
					moved, (ftnlen)128);
#line 13056 ""
				if (moved) {

/*  Transfer accidental shift values */

#line 13060 ""
				    i__2 = igetbits_(&nactmp, &c__6, &c__4);
#line 13060 ""
				    setbits_(&comtrill_1.icrdot[
					    comtrill_1.ncrd - 1], &c__6, &
					    c__14, &i__2);
#line 13062 ""
				    i__2 = igetbits_(&nactmp, &c__7, &c__10);
#line 13062 ""
				    setbits_(&comtrill_1.icrdot[
					    comtrill_1.ncrd - 1], &c__7, &
					    c__20, &i__2);
#line 13064 ""
				} else {
#line 13065 ""
				    if (*(unsigned char *)durq == '+') {
#line 13066 ""
					comnotes_1.lastlev += 7;
#line 13067 ""
				    } else if (*(unsigned char *)durq == '-') 
					    {
#line 13068 ""
					comnotes_1.lastlev += -7;
#line 13069 ""
				    }
#line 13070 ""
				}
#line 13071 ""
			    } else if (*(unsigned char *)durq == 'e') {
#line 13072 ""
				comtrill_1.icrdat[comtrill_1.ncrd - 1] = 
					bit_set(comtrill_1.icrdat[
					comtrill_1.ncrd - 1],23);
#line 13073 ""
				all_1.irest[commvl_1.ivx + all_1.nnl[
					commvl_1.ivx - 1] * 24 - 25] = 
					bit_set(all_1.irest[commvl_1.ivx + 
					all_1.nnl[commvl_1.ivx - 1] * 24 - 25]
					,27);
#line 13074 ""
			    } else if (*(unsigned char *)durq == 'r') {
#line 13075 ""
				comtrill_1.icrdat[comtrill_1.ncrd - 1] = 
					bit_set(comtrill_1.icrdat[
					comtrill_1.ncrd - 1],24);
#line 13076 ""
				all_1.irest[commvl_1.ivx + (all_1.nnl[
					commvl_1.ivx - 1] - 1) * 24 - 25] = 
					bit_set(all_1.irest[commvl_1.ivx + (
					all_1.nnl[commvl_1.ivx - 1] - 1) * 24 
					- 25],20);
#line 13078 ""
			    } else if (*(unsigned char *)durq == 'i') {

/*  Midi-only accidental */

#line 13082 ""
				comtrill_1.icrdat[comtrill_1.ncrd - 1] = 
					bit_set(comtrill_1.icrdat[
					comtrill_1.ncrd - 1],27);
#line 13083 ""
			    } else {

/* must be a number, save it in ioct */

#line 13087 ""
				numnum = 1;
#line 13088 ""
				ioct = ndx - 7;
#line 13089 ""
			    }
#line 13090 ""
			    goto L34;
#line 13091 ""
			}
#line 13092 ""
			if (numnum == 1) {
#line 13093 ""
			    comnotes_1.lastlev = ifnolev_(charq, &ioct, &
				    cominsttrans_1.itransamt[
				    cominsttrans_1.instno[all_1.iv - 1] - 1], 
				    (ftnlen)1);
#line 13094 ""
			} else {
#line 13095 ""
			    comnotes_1.lastlev = comnotes_1.lastlev - 3 + (
				    ifnolev_(charq, &c__10, &
				    cominsttrans_1.itransamt[
				    cominsttrans_1.instno[all_1.iv - 1] - 1], 
				    (ftnlen)1) - comnotes_1.lastlev + 3) % 7;
#line 13097 ""
			}
#line 13098 ""
			comtrill_1.icrdat[comtrill_1.ncrd - 1] |= 
				comnotes_1.lastlev << 12;
#line 13099 ""
			for (comnotes_1.npreslur = comnotes_1.npreslur; 
				comnotes_1.npreslur >= 1; 
				--comnotes_1.npreslur) {

/*  Set note level for preslur on chord note in xtup */

#line 13103 ""
			    setbits_(&all_1.isdat2[all_1.nsdat - 
				    comnotes_1.npreslur], &c__7, &c__19, &
				    comnotes_1.lastlev);

/*  Following lines copied from loop for non-xtup, chord note, preslur */
/*  Initially I assigned the slur(s) to next note, so fix. */

#line 13108 ""
			    all_1.islur[commvl_1.ivx + all_1.nnl[commvl_1.ivx 
				    - 1] * 24 - 25] = bit_clear(all_1.islur[
				    commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1]
				     * 24 - 25],0);
#line 13109 ""
			    all_1.islur[commvl_1.ivx + (all_1.nnl[
				    commvl_1.ivx - 1] - 1) * 24 - 25] = 
				    bit_set(all_1.islur[commvl_1.ivx + (
				    all_1.nnl[commvl_1.ivx - 1] - 1) * 24 - 
				    25],0);
#line 13110 ""
			    all_1.isdat2[all_1.nsdat - comnotes_1.npreslur] = 
				    bit_set(all_1.isdat2[all_1.nsdat - 
				    comnotes_1.npreslur],0);
#line 13112 ""
			    i__2 = igetbits_(&all_1.isdat1[all_1.nsdat - 
				    comnotes_1.npreslur], &c__8, &c__3) - 1;
#line 13112 ""
			    setbits_(&all_1.isdat1[all_1.nsdat - 
				    comnotes_1.npreslur], &c__8, &c__3, &i__2)
				    ;
#line 13114 ""
/* L41: */
#line 13114 ""
			}
#line 13115 ""
			goto L7;
#line 13116 ""
		    } else if (*(unsigned char *)charq == '?') {

/*  Arpeggio */

#line 13120 ""
			if (bit_test(all_1.ipl[commvl_1.ivx + (all_1.nnl[
				commvl_1.ivx - 1] - 1) * 24 - 25],10)) {

/*  This is a chordal note.  Set a bit in icrdat.  But if *main* (spacing) note */
/*  of chord, will not set icrdat(25), but iornq(27) */

#line 13125 ""
			    comtrill_1.icrdat[comtrill_1.ncrd - 1] = bit_set(
				    comtrill_1.icrdat[comtrill_1.ncrd - 1],25)
				    ;
#line 13126 ""
			} else {
#line 13127 ""
			    all_1.iornq[commvl_1.ivx + (all_1.nnl[
				    commvl_1.ivx - 1] - 1) * 24 - 1] = 
				    bit_set(all_1.iornq[commvl_1.ivx + (
				    all_1.nnl[commvl_1.ivx - 1] - 1) * 24 - 1]
				    ,27);
#line 13128 ""
			}

/*  Check for shift */

#line 13132 ""
			getchar_(lineq, &all_1.iccount, durq, (ftnlen)128, (
				ftnlen)1);
#line 13133 ""
			if (*(unsigned char *)durq == ' ') {
#line 13134 ""
			    --all_1.iccount;
#line 13135 ""
			} else {

/*  durq must be "-" */

#line 13139 ""
			    ++all_1.iccount;
#line 13140 ""
			    readnum_(lineq, &all_1.iccount, durq, &fnum, (
				    ftnlen)128, (ftnlen)1);
#line 13141 ""
			    --all_1.iccount;

/*  record the shift */

#line 13145 ""
			    ++comarpshift_1.numarpshift;
#line 13146 ""
			    comarpshift_1.ivarpshift[
				    comarpshift_1.numarpshift - 1] = 
				    commvl_1.ivx;
#line 13147 ""
			    comarpshift_1.iparpshift[
				    comarpshift_1.numarpshift - 1] = 
				    all_1.nnl[commvl_1.ivx - 1] - 1;
#line 13148 ""
			    comarpshift_1.arpshift[comarpshift_1.numarpshift 
				    - 1] = fnum;
#line 13149 ""
			}
#line 13150 ""
			goto L7;
#line 13151 ""
		    } else if (*(unsigned char *)charq == 'D') {
#line 13152 ""
			i__2 = all_1.nnl[commvl_1.ivx - 1] - 1;
#line 13152 ""
			getdyn_(&commvl_1.ivx, &i__2, &all_1.irest[
				commvl_1.ivx + (all_1.nnl[commvl_1.ivx - 1] - 
				1) * 24 - 25], &all_1.iornq[commvl_1.ivx + (
				all_1.nnl[commvl_1.ivx - 1] - 1) * 24 - 1], 
				lineq, &all_1.iccount, (ftnlen)128);
#line 13154 ""
			goto L7;

/*  140215 Allow clef change inside xtuplet. With normal code, came out one */
/*         note too late, so try making it come earlier. */

#line 13159 ""
		    } else if (*(unsigned char *)charq == 'C') {

/*  Clef change on next note.  Set bits 11-15.  Won't allow in 2nd line of music. */

#line 13163 ""
			if (all_1.nnl[all_1.iv - 1] - 1 > 0) {
#line 13163 ""
			    ++comcc_1.ncc[all_1.iv - 1];
#line 13163 ""
			}

/*  140218 Need to get time differently inside xtup, since itsofar doesn't get */
/*  updated until after xtup is done */

#line 13168 ""
			nodurt = ifnodur_(&comnotes_1.nnodur, dotq, (ftnlen)1)
				;
#line 13169 ""
			comcc_1.tcc[all_1.iv + comcc_1.ncc[all_1.iv - 1] * 24 
				- 25] = (real) (all_1.itsofar[all_1.iv - 1] + 
				(integer) (nodurt * 1.f / ntup * (itup - 1)));
#line 13170 ""
			isl = bit_set(all_1.islur[all_1.iv + all_1.nnl[
				all_1.iv - 1] * 24 - 25],11);
#line 13171 ""
			getchar_(lineq, &all_1.iccount, durq, (ftnlen)128, (
				ftnlen)1);

/*  Store clef number, or 7 if clef number = 9 (French violin clef) */

/* Computing MIN */
#line 13175 ""
			i__2 = numclef_(durq, (ftnlen)1);
#line 13175 ""
			isl |= min(i__2,7) << 12;
#line 13176 ""
			comcc_1.ncmidcc[all_1.iv + comcc_1.ncc[all_1.iv - 1] *
				 24 - 25] = ncmidf_(durq, (ftnlen)1);
#line 13177 ""
			if (*(unsigned char *)durq == '8') {
#line 13178 ""
			    all_1.ipl[all_1.iv + all_1.nnl[all_1.iv - 1] * 24 
				    - 25] = bit_set(all_1.ipl[all_1.iv + 
				    all_1.nnl[all_1.iv - 1] * 24 - 25],2);
#line 13179 ""
			    cominsttrans_1.itransamt[cominsttrans_1.instno[
				    all_1.iv - 1] - 1] += 7;
#line 13180 ""
			}

/*  Set marker on note with lowest voice # starting at same time. */

#line 13184 ""
			if (all_1.iv == 1) {
#line 13185 ""
			    isl = bit_set(isl,15);
#line 13186 ""
			} else {
#line 13187 ""
			    i__2 = all_1.iv;
#line 13187 ""
			    for (iiv = 1; iiv <= i__2; ++iiv) {
/*                  nnliiv = nnl(iiv) */
#line 13189 ""
				nnliiv = all_1.nnl[iiv - 1] - 1;
#line 13190 ""
				if (iiv == all_1.iv) {
#line 13190 ""
				    ++nnliiv;
#line 13190 ""
				}
#line 13191 ""
				itother = 0;
#line 13192 ""
				i__4 = nnliiv;
#line 13192 ""
				for (iip = 1; iip <= i__4; ++iip) {
#line 13193 ""
				    if (itother < all_1.itsofar[all_1.iv - 1])
					     {
#line 13194 ""
					itother += all_1.nodur[iiv + iip * 24 
						- 25];
#line 13195 ""
					goto L71;
#line 13196 ""
				    } else if (itother == all_1.itsofar[
					    all_1.iv - 1]) {
#line 13197 ""
					all_1.islur[iiv + iip * 24 - 25] = 
						bit_set(all_1.islur[iiv + iip 
						* 24 - 25],15);
#line 13198 ""
					goto L72;
#line 13199 ""
				    }
#line 13200 ""
L71:
#line 13200 ""
				    ;
#line 13200 ""
				}
#line 13201 ""
/* L70: */
#line 13201 ""
			    }
#line 13202 ""
L72:
#line 13203 ""
			    ;
#line 13203 ""
			}

/*  Need 'or' since may have set bit 15 in the above loop */

#line 13207 ""
			all_1.islur[all_1.iv + all_1.nnl[all_1.iv - 1] * 24 - 
				25] = isl | all_1.islur[all_1.iv + all_1.nnl[
				all_1.iv - 1] * 24 - 25];
#line 13208 ""
			goto L7;
#line 13209 ""
		    } else if (*(unsigned char *)charq == ']') {

/*  Multiplicity up-down, must have '][ ' */

#line 13213 ""
			all_1.islur[commvl_1.ivx + (all_1.nnl[commvl_1.ivx - 
				1] - 1) * 24 - 25] = bit_set(all_1.islur[
				commvl_1.ivx + (all_1.nnl[commvl_1.ivx - 1] - 
				1) * 24 - 25],20);
#line 13214 ""
			all_1.iccount += 2;
#line 13215 ""
			goto L7;
#line 13216 ""
		    }
#line 13216 ""
		}

/*  End of loop for xtup options. If here, charq must be a (non-crd) note name. */
/*  or rest */

#line 13221 ""
		if (*(unsigned char *)charq == 'r') {

/*  Rest in xtup */

#line 13225 ""
		    all_1.irest[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 
			    24 - 25] = bit_set(all_1.irest[commvl_1.ivx + 
			    all_1.nnl[commvl_1.ivx - 1] * 24 - 25],0);
#line 13226 ""
		    i__2 = all_1.iccount;
#line 13226 ""
		    if (i_indx("+-b", lineq + i__2, (ftnlen)3, all_1.iccount 
			    + 1 - i__2) > 0) {
#line 13227 ""
			getchar_(lineq, &all_1.iccount, durq, (ftnlen)128, (
				ftnlen)1);
#line 13228 ""
			if (*(unsigned char *)durq == 'b') {

/*  Blank rest in middle of xtup */

#line 13232 ""
			    all_1.islur[commvl_1.ivx + all_1.nnl[commvl_1.ivx 
				    - 1] * 24 - 25] = bit_set(all_1.islur[
				    commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1]
				     * 24 - 25],29);
#line 13233 ""
			} else {

/*  Override height of embedded xtup rest */

#line 13237 ""
			    ipm = i_indx("- +", durq, (ftnlen)3, (ftnlen)1) - 
				    2;
#line 13238 ""
			    ++all_1.iccount;
#line 13239 ""
			    readnum_(lineq, &all_1.iccount, durq, &fnum, (
				    ftnlen)128, (ftnlen)1);
#line 13240 ""
			    all_1.nolev[commvl_1.ivx + all_1.nnl[commvl_1.ivx 
				    - 1] * 24 - 25] = ipm * i_nint(&fnum) + 
				    100;
#line 13241 ""
			    --all_1.iccount;
#line 13242 ""
			}
#line 13243 ""
		    } else if (commvl_1.ivx <= all_1.nv) {
#line 13244 ""
			all_1.nolev[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1]
				 * 24 - 25] = 0;
#line 13245 ""
		    } else {
#line 13246 ""
			all_1.nolev[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1]
				 * 24 - 25] = 2;
#line 13247 ""
		    }
#line 13248 ""
		} else {

/* Counter for non-rests */

#line 13252 ""
		    ++nnb;
#line 13253 ""
		}
#line 13254 ""
		comnotes_1.notcrd = TRUE_;
#line 13255 ""
L8:
#line 13255 ""
		getchar_(lineq, &all_1.iccount, durq, (ftnlen)128, (ftnlen)1);
#line 13256 ""
		if (*(unsigned char *)durq != ' ') {
#line 13257 ""
		    if (i_indx("+-<>", durq, (ftnlen)4, (ftnlen)1) > 0) {

/*  Accidental horizontal shift */

#line 13261 ""
			chkpm4ac_(lineq, &all_1.iccount, &all_1.nacc[
				commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 
				24 - 25], &moved, (ftnlen)128);
#line 13262 ""
			if (! moved) {
#line 13263 ""
			    if (*(unsigned char *)durq == '+') {
#line 13264 ""
				comnotes_1.lastlev += 7;
#line 13265 ""
			    } else if (*(unsigned char *)durq == '-') {
#line 13266 ""
				comnotes_1.lastlev += -7;
#line 13267 ""
			    }
#line 13268 ""
			}
#line 13269 ""
		    } else if (i_indx("fsn", durq, (ftnlen)3, (ftnlen)1) > 0) 
			    {
#line 13270 ""
			if (igetbits_(&all_1.nacc[commvl_1.ivx + all_1.nnl[
				commvl_1.ivx - 1] * 24 - 25], &c__2, &c__0) ==
				 0) {

/*  No accid set yet */

#line 13274 ""
			    all_1.nacc[commvl_1.ivx + all_1.nnl[commvl_1.ivx 
				    - 1] * 24 - 25] |= i_indx("fsn", durq, (
				    ftnlen)3, (ftnlen)1);
#line 13276 ""
			} else {

/*  Symbol must be repeated, so it's a double */

#line 13280 ""
			    all_1.nacc[commvl_1.ivx + all_1.nnl[commvl_1.ivx 
				    - 1] * 24 - 25] = bit_set(all_1.nacc[
				    commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1]
				     * 24 - 25],2);
#line 13281 ""
			}
#line 13282 ""
		    } else if (*(unsigned char *)durq == 'i') {

/*  Set flag for midi-only accidental */

#line 13286 ""
			all_1.nacc[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] 
				* 24 - 25] = bit_set(all_1.nacc[commvl_1.ivx 
				+ all_1.nnl[commvl_1.ivx - 1] * 24 - 25],17);
#line 13288 ""
		    } else if (*(unsigned char *)durq == 'c') {

/*  Set flags for cautionary accidental */

#line 13292 ""
			all_1.irest[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1]
				 * 24 - 25] = bit_set(all_1.irest[
				commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 
				24 - 25],31);
#line 13293 ""
			all_1.iornq[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1]
				 * 24 - 1] = bit_set(all_1.iornq[commvl_1.ivx 
				+ all_1.nnl[commvl_1.ivx - 1] * 24 - 1],31);
#line 13294 ""
		    } else if (i_indx("ul", durq, (ftnlen)2, (ftnlen)1) > 0) {

/*  Force stem direction for non-beamed xtup note */

#line 13298 ""
			all_1.islur[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1]
				 * 24 - 25] = bit_set(all_1.islur[
				commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 
				24 - 25],30);
#line 13299 ""
			if (*(unsigned char *)durq == 'u') {
#line 13299 ""
			    all_1.islur[commvl_1.ivx + all_1.nnl[commvl_1.ivx 
				    - 1] * 24 - 25] = bit_set(all_1.islur[
				    commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1]
				     * 24 - 25],17);
#line 13299 ""
			}
#line 13301 ""
		    } else if (*(unsigned char *)durq == 'e') {

/*  Left-shift main xtup note */

#line 13305 ""
			all_1.ipl[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] *
				 24 - 25] = bit_set(all_1.ipl[commvl_1.ivx + 
				all_1.nnl[commvl_1.ivx - 1] * 24 - 25],8);
#line 13306 ""
			all_1.irest[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1]
				 * 24 - 25] = bit_set(all_1.irest[
				commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 
				24 - 25],27);
#line 13307 ""
		    } else if (*(unsigned char *)durq == 'r') {

/*  Right-shift main xtup note */

#line 13311 ""
			all_1.ipl[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] *
				 24 - 25] = bit_set(all_1.ipl[commvl_1.ivx + 
				all_1.nnl[commvl_1.ivx - 1] * 24 - 25],9);
#line 13312 ""
			all_1.irest[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1]
				 * 24 - 25] = bit_set(all_1.irest[
				commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 
				24 - 25],20);
#line 13313 ""
		    } else if (i_indx("DF", durq, (ftnlen)2, (ftnlen)1) > 0) {

/*  Double an xtup note to make an unequal xtup */

#line 13317 ""
			all_1.nacc[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] 
				* 24 - 25] = bit_set(all_1.nacc[commvl_1.ivx 
				+ all_1.nnl[commvl_1.ivx - 1] * 24 - 25],18);
#line 13318 ""
			if (*(unsigned char *)durq == 'F') {
#line 13318 ""
			    all_1.nacc[commvl_1.ivx + all_1.nnl[commvl_1.ivx 
				    - 1] * 24 - 25] = bit_set(all_1.nacc[
				    commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1]
				     * 24 - 25],19);
#line 13318 ""
			}
#line 13320 ""
			++ndoub;
#line 13321 ""
		    } else if (*(unsigned char *)durq == 'd') {

/*  Dotted xtup note */

#line 13325 ""
			if (bit_test(all_1.irest[commvl_1.ivx + (all_1.nnl[
				commvl_1.ivx - 1] - 1) * 24 - 25],2)) {

/* Move dot on 2nd note of 2-note tremolo */

#line 13329 ""
			    ++comcc_1.ndotmv[commvl_1.ivx - 1];
#line 13330 ""
			    all_1.irest[commvl_1.ivx + all_1.nnl[commvl_1.ivx 
				    - 1] * 24 - 25] = bit_set(all_1.irest[
				    commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1]
				     * 24 - 25],19);
#line 13331 ""
			    g1etchar_(lineq, &all_1.iccount, durq, (ftnlen)
				    128, (ftnlen)1);
/* Will be + or - */
#line 13332 ""
			    ++all_1.iccount;
#line 13333 ""
			    readnum_(lineq, &all_1.iccount, dumq, &
				    comcc_1.updot[commvl_1.ivx + 
				    comcc_1.ndotmv[commvl_1.ivx - 1] * 24 - 
				    25], (ftnlen)128, (ftnlen)1);
#line 13335 ""
			    if (*(unsigned char *)durq == '-') {
#line 13335 ""
				comcc_1.updot[commvl_1.ivx + comcc_1.ndotmv[
					commvl_1.ivx - 1] * 24 - 25] = 
					-comcc_1.updot[commvl_1.ivx + 
					comcc_1.ndotmv[commvl_1.ivx - 1] * 24 
					- 25];
#line 13335 ""
			    }
#line 13337 ""
			    if (i_indx("+-", dumq, (ftnlen)2, (ftnlen)1) > 0) 
				    {

/*  Vertical shift also */

#line 13341 ""
				readnum_(lineq, &all_1.iccount, durq, &
					comcc_1.rtdot[commvl_1.ivx + 
					comcc_1.ndotmv[commvl_1.ivx - 1] * 24 
					- 25], (ftnlen)128, (ftnlen)1);
#line 13343 ""
				if (*(unsigned char *)durq == '-') {
#line 13343 ""
				    comcc_1.rtdot[commvl_1.ivx + 
					    comcc_1.ndotmv[commvl_1.ivx - 1] *
					     24 - 25] = -comcc_1.rtdot[
					    commvl_1.ivx + comcc_1.ndotmv[
					    commvl_1.ivx - 1] * 24 - 25];
#line 13343 ""
				}
#line 13345 ""
			    }
#line 13346 ""
			    --all_1.iccount;
#line 13347 ""
			} else {

/* Dot for 3:1 pair of xtup notes */

#line 13351 ""
			    all_1.nacc[commvl_1.ivx + all_1.nnl[commvl_1.ivx 
				    - 1] * 24 - 25] = bit_set(all_1.nacc[
				    commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1]
				     * 24 - 25],27);
#line 13352 ""
			}
#line 13353 ""
		    } else {

/*  Must be an octave number */

#line 13357 ""
			i__2 = *(unsigned char *)durq - 48;
#line 13357 ""
			comnotes_1.lastlev = ifnolev_(charq, &i__2, &
				cominsttrans_1.itransamt[
				cominsttrans_1.instno[all_1.iv - 1] - 1], (
				ftnlen)1);
#line 13359 ""
		    }
#line 13360 ""
		    goto L8;
#line 13361 ""
		}
#line 13362 ""
		if (itup < ntup) {

/*  Last note is handled *after* flowing out of the xtup if block, but still */
/*    within block for a note-rest.  Set note level now (rest already done). */
/*    Could have problem here if rests & doubled notes are combined in xtup, */
/*    since might exit the loop at the wrong place.  Worry about it later. */

#line 13369 ""
		    if (! bit_test(all_1.irest[commvl_1.ivx + all_1.nnl[
			    commvl_1.ivx - 1] * 24 - 25],0)) {
#line 13370 ""
			comnotes_1.lastlev = comnotes_1.lastlev - 3 + (
				ifnolev_(charq, &c__10, &
				cominsttrans_1.itransamt[
				cominsttrans_1.instno[all_1.iv - 1] - 1], (
				ftnlen)1) - comnotes_1.lastlev + 3) % 7;
#line 13372 ""
			all_1.nolev[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1]
				 * 24 - 25] = comnotes_1.lastlev;
#line 13373 ""
		    }
#line 13374 ""
		    all_1.nodur[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 
			    24 - 25] = 0;
#line 13375 ""
		    for (comnotes_1.npreslur = comnotes_1.npreslur; 
			    comnotes_1.npreslur >= 1; --comnotes_1.npreslur) {

/*  Set note level for preslur on internal xtup note */

#line 13379 ""
			setbits_(&all_1.isdat2[all_1.nsdat - 
				comnotes_1.npreslur], &c__7, &c__19, &
				comnotes_1.lastlev);
#line 13380 ""
/* L42: */
#line 13380 ""
		    }
#line 13381 ""
		}
#line 13382 ""
		if (itup == ntup - ndoub) {
#line 13382 ""
		    goto L12;
#line 13382 ""
		}
#line 13383 ""
/* L6: */
#line 13383 ""
	    }
#line 13384 ""
L12:
#line 13385 ""
	    if (comget_1.ornrpt) {
#line 13386 ""
		all_1.iornq[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 24 - 
			1] |= all_1.iornq[commvl_1.ivx + (all_1.nnl[
			commvl_1.ivx - 1] - 1) * 24 - 1] & 10026991;
#line 13388 ""
		if ((all_1.iornq[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 
			24 - 1] & 32896) > 0) {

/*  This is a trill (bit 7 or 15) so must dup the parameters */

#line 13392 ""
		    ++comtrill_1.ntrill;
#line 13393 ""
		    comtrill_1.ivtrill[comtrill_1.ntrill - 1] = commvl_1.ivx;
#line 13394 ""
		    comtrill_1.iptrill[comtrill_1.ntrill - 1] = all_1.nnl[
			    commvl_1.ivx - 1];
#line 13395 ""
		    comtrill_1.xnsktr[comtrill_1.ntrill - 1] = 
			    comtrill_1.xnsktr[comtrill_1.ntrill - 2];
#line 13396 ""
		}
#line 13397 ""
	    }

/*  End of if-block for xtuplet input */

#line 13401 ""
	} else if (*(unsigned char *)durq == 'm') {

/*  Multi-bar rest: next 1 or two digits are # of bars. */
/*  For some purposes, pretend its one bar only */

#line 13406 ""
	    all_1.nodur[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 24 - 25] 
		    = all_1.lenbar;
#line 13407 ""
	    comgrace_1.ibarmbr = all_1.nbars + 1;
#line 13408 ""
	    comgrace_1.mbrest = 0;
#line 13409 ""
	    comgrace_1.xb4mbr = 0.f;
#line 13410 ""
L20:
#line 13410 ""
	    getchar_(lineq, &all_1.iccount, durq, (ftnlen)128, (ftnlen)1);
#line 13411 ""
	    if (*(unsigned char *)durq >= 48 && *(unsigned char *)durq <= 57) 
		    {
#line 13412 ""
		comgrace_1.mbrest = comgrace_1.mbrest * 10 + *(unsigned char *
			)durq - 48;
#line 13413 ""
		goto L20;
#line 13414 ""
	    }

/*  durq will either be blank or 'n' */
#line 13417 ""
	    if (*(unsigned char *)durq == 'n') {

/*  Get new height */

#line 13421 ""
		iplmi = 1;
#line 13422 ""
		g1etchar_(lineq, &all_1.iccount, durq, (ftnlen)128, (ftnlen)1)
			;
#line 13423 ""
		if (*(unsigned char *)durq == '-') {
#line 13424 ""
		    iplmi = -1;
#line 13425 ""
		    ++all_1.iccount;
#line 13426 ""
		}
#line 13427 ""
		readnum_(lineq, &all_1.iccount, durq, &hgt, (ftnlen)128, (
			ftnlen)1);
#line 13428 ""
		r__1 = iplmi * hgt;
#line 13428 ""
		comignorenats_1.mbrhgt = i_nint(&r__1);
#line 13429 ""
		comignorenats_1.newmbrhgt = TRUE_;
#line 13430 ""
	    }
#line 13431 ""
	} else if (i_indx("ul", durq, (ftnlen)2, (ftnlen)1) > 0) {

/*  Set stem flipper */

#line 13435 ""
	    all_1.islur[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 24 - 25] 
		    = bit_set(all_1.islur[commvl_1.ivx + all_1.nnl[
		    commvl_1.ivx - 1] * 24 - 25],30);
#line 13436 ""
	    if (*(unsigned char *)durq == 'u') {
#line 13436 ""
		all_1.islur[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 24 - 
			25] = bit_set(all_1.islur[commvl_1.ivx + all_1.nnl[
			commvl_1.ivx - 1] * 24 - 25],17);
#line 13436 ""
	    }
#line 13438 ""
	    goto L2;
#line 13439 ""
	} else if (*(unsigned char *)durq == 'a') {

/*  "Alone", i.e., prohibit beam */

#line 13443 ""
	    all_1.islur[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 24 - 25] 
		    = bit_set(all_1.islur[commvl_1.ivx + all_1.nnl[
		    commvl_1.ivx - 1] * 24 - 25],18);
#line 13444 ""
	    goto L2;
#line 13445 ""
	} else if (*(unsigned char *)durq == 'r') {

/*  Right offset by one notehead */

#line 13449 ""
	    all_1.ipl[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 24 - 25] = 
		    bit_set(all_1.ipl[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 
		    1] * 24 - 25],9);
#line 13450 ""
	    all_1.irest[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 24 - 25] 
		    = bit_set(all_1.irest[commvl_1.ivx + all_1.nnl[
		    commvl_1.ivx - 1] * 24 - 25],20);
#line 13451 ""
	    goto L2;
#line 13452 ""
	} else if (*(unsigned char *)durq == 'e') {

/*  Left offset by one notehead */

#line 13456 ""
	    all_1.ipl[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 24 - 25] = 
		    bit_set(all_1.ipl[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 
		    1] * 24 - 25],8);
#line 13457 ""
	    all_1.irest[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 24 - 25] 
		    = bit_set(all_1.irest[commvl_1.ivx + all_1.nnl[
		    commvl_1.ivx - 1] * 24 - 25],27);
#line 13458 ""
	    goto L2;
#line 13459 ""
	} else if (i_indx("LS", durq, (ftnlen)2, (ftnlen)1) > 0) {

/*  Stemlength change.  Get dstemlen in \internotes.  Allowable values are -4 to 27.5 */
/*    Set mult(27).  Map value to 0 to 63, store in mult(10-15).  Later convert to */
/*    interbeams = internotes*2/3. */

#line 13465 ""
	    isign = 1;
#line 13466 ""
	    if (*(unsigned char *)durq == 'S') {
#line 13466 ""
		isign = -1;
#line 13466 ""
	    }
#line 13467 ""
	    all_1.mult[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 24 - 25] =
		     bit_set(all_1.mult[commvl_1.ivx + all_1.nnl[commvl_1.ivx 
		    - 1] * 24 - 25],27);
#line 13468 ""
	    getchar_(lineq, &all_1.iccount, durq, (ftnlen)128, (ftnlen)1);
#line 13469 ""
	    if (*(unsigned char *)durq == ':') {

/*  End stickyS.  Grab data now from prior note, since we have to shut off stickyS. */

#line 13473 ""
		i__1 = igetbits_(&all_1.mult[commvl_1.ivx + (all_1.nnl[
			commvl_1.ivx - 1] - 1) * 24 - 25], &c__6, &c__10);
#line 13473 ""
		setbits_(&all_1.mult[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 
			1] * 24 - 25], &c__6, &c__10, &i__1);
#line 13475 ""
		comget_1.stickys = FALSE_;
#line 13476 ""
		goto L2;
#line 13477 ""
	    }

/*  If durq .ne. ':' then iccount is now on the start of the number */

#line 13481 ""
	    readnum_(lineq, &all_1.iccount, durq, &dum, (ftnlen)128, (ftnlen)
		    1);
#line 13482 ""
	    dum = isign * dum;
#line 13483 ""
	    r__1 = (dum + 4.f) * 2;
#line 13483 ""
	    i__1 = i_nint(&r__1);
#line 13483 ""
	    setbits_(&all_1.mult[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 
		    24 - 25], &c__6, &c__10, &i__1);
#line 13484 ""
	    if (*(unsigned char *)durq == ':') {
#line 13485 ""
		comget_1.stickys = TRUE_;
#line 13486 ""
	    } else {
#line 13487 ""
		--all_1.iccount;
#line 13488 ""
	    }
#line 13489 ""
	    goto L2;
#line 13490 ""
	} else if (*(unsigned char *)durq == ',') {

/*  2:1 pattern */

#line 13494 ""
	    idotform = 3;

/*  Now flow to duration setting, as if durq=' ' */

#line 13498 ""
	} else if (*(unsigned char *)durq == '.') {

/*  Dotted pattern.  Close out note.  Mult time by 3/4. */
/*  Set time for next note to 1/4.  Start the note. */

#line 13503 ""
	    idotform = 1;
#line 13504 ""
	} else if (*(unsigned char *)durq == 'o') {

/*  Suppress rest centering */

#line 13508 ""
	    all_1.irest[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 24 - 25] 
		    = bit_set(all_1.irest[commvl_1.ivx + all_1.nnl[
		    commvl_1.ivx - 1] * 24 - 25],25);
#line 13509 ""
	    goto L2;
#line 13510 ""
	} else if (*(unsigned char *)durq == 'L') {

/*  With keyboard rest option, look left */

#line 13514 ""
	    all_1.ipl[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 24 - 25] = 
		    bit_set(all_1.ipl[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 
		    1] * 24 - 25],1);
#line 13515 ""
	    goto L2;
#line 13516 ""
	} else if (i_indx("DF", durq, (ftnlen)2, (ftnlen)1) > 0) {

/*  Double note for xtup.  Must check here in case "D" came before "x" or on */
/*  last note of xtup.   Need to flag it in pmxa since affects horiz. spacing. */

#line 13521 ""
	    all_1.nacc[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 24 - 25] =
		     bit_set(all_1.nacc[commvl_1.ivx + all_1.nnl[commvl_1.ivx 
		    - 1] * 24 - 25],18);
#line 13522 ""
	    if (*(unsigned char *)durq == 'F') {
#line 13522 ""
		all_1.nacc[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 24 - 
			25] = bit_set(all_1.nacc[commvl_1.ivx + all_1.nnl[
			commvl_1.ivx - 1] * 24 - 25],19);
#line 13522 ""
	    }
#line 13524 ""
	    goto L2;
#line 13525 ""
	} else if (*(unsigned char *)durq == 'A') {

/*  Accidental option */

#line 13529 ""
	    getchar_(lineq, &all_1.iccount, durq, (ftnlen)128, (ftnlen)1);

#line 13531 ""
	    if (*(unsigned char *)durq == 'o') {

/*  Ordered accidentals in a chord.  Mark the main note. */

#line 13535 ""
		all_1.nacc[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 24 - 
			25] = bit_set(all_1.nacc[commvl_1.ivx + all_1.nnl[
			commvl_1.ivx - 1] * 24 - 25],28);
#line 13536 ""
	    } else {

/*  Only other possibility is +-<> . Set tag, reduce iccount and loop to get #'s */

#line 13540 ""
		all_1.nacc[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 24 - 
			25] = bit_set(all_1.nacc[commvl_1.ivx + all_1.nnl[
			commvl_1.ivx - 1] * 24 - 25],29);
#line 13541 ""
		--all_1.iccount;
#line 13542 ""
	    }
#line 13543 ""
	    goto L2;
#line 13544 ""
	} else if (*(unsigned char *)durq == 'T') {
#line 13545 ""
	    getchar_(lineq, &all_1.iccount, durq, (ftnlen)128, (ftnlen)1);
#line 13546 ""
	    multtrem = i_indx("1234", durq, (ftnlen)4, (ftnlen)1);
#line 13547 ""
	    if (multtrem == 0) {
#line 13548 ""
		--all_1.iccount;
#line 13549 ""
		multtrem = 1;
#line 13550 ""
	    }
#line 13551 ""
	    all_1.ipl[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 24 - 25] = 
		    bit_set(all_1.ipl[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 
		    1] * 24 - 25],4);
#line 13552 ""
	    i__1 = multtrem - 1;
#line 13552 ""
	    setbits_(&all_1.ipl[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 
		    24 - 25], &c__2, &c__5, &i__1);
#line 13553 ""
	    goto L2;
#line 13554 ""
	} else if (*(unsigned char *)durq != ' ') {
#line 13555 ""
	    s_wsle(&io___815);
#line 13555 ""
	    do_lio(&c__9, &c__1, "Illegal character in note: ", (ftnlen)27);
#line 13555 ""
	    do_lio(&c__9, &c__1, durq, (ftnlen)1);
#line 13555 ""
	    do_lio(&c__9, &c__1, ", ivx,nn:", (ftnlen)9);
#line 13555 ""
	    do_lio(&c__3, &c__1, (char *)&commvl_1.ivx, (ftnlen)sizeof(
		    integer));
#line 13555 ""
	    do_lio(&c__3, &c__1, (char *)&all_1.nnl[commvl_1.ivx - 1], (
		    ftnlen)sizeof(integer));
#line 13555 ""
	    e_wsle();
#line 13557 ""
	    stop1_();
#line 13558 ""
	}

/*  Done with note/rest options.  Set level and duration. */

#line 13562 ""
	if (! bit_test(all_1.irest[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] 
		* 24 - 25],0)) {
#line 13563 ""
	    if (numnum == 2) {
#line 13564 ""
		comnotes_1.lastlev = ifnolev_(charq, &ioct, &
			cominsttrans_1.itransamt[cominsttrans_1.instno[
			all_1.iv - 1] - 1], (ftnlen)1);
#line 13565 ""
		all_1.nolev[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 24 - 
			25] = comnotes_1.lastlev;
#line 13566 ""
	    } else {
#line 13567 ""
		comnotes_1.lastlev = comnotes_1.lastlev - 3 + (ifnolev_(charq,
			 &c__10, &cominsttrans_1.itransamt[
			cominsttrans_1.instno[all_1.iv - 1] - 1], (ftnlen)1) 
			- comnotes_1.lastlev + 3) % 7;
#line 13569 ""
		all_1.nolev[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 24 - 
			25] = comnotes_1.lastlev;
#line 13570 ""
	    }
#line 13571 ""
	    for (comnotes_1.npreslur = comnotes_1.npreslur; 
		    comnotes_1.npreslur >= 1; --comnotes_1.npreslur) {

/*  Set level for preslur on normal note, non-chord */

#line 13575 ""
		setbits_(&all_1.isdat2[all_1.nsdat - comnotes_1.npreslur], &
			c__7, &c__19, &comnotes_1.lastlev);
#line 13576 ""
/* L43: */
#line 13576 ""
	    }

/*  Only matters if last note, non-rest of xtuplet */

#line 13580 ""
	    ++nnb;
#line 13581 ""
	}

/*  Set flag for unbeamed xtup if it just has 1 note */

#line 13585 ""
	if (inxtup && nnb == 1) {
#line 13586 ""
	    all_1.islur[commvl_1.ivx + note1xtup * 24 - 25] = bit_set(
		    all_1.islur[commvl_1.ivx + note1xtup * 24 - 25],18);
#line 13587 ""
	}
#line 13588 ""
	if (idotform > 0) {
#line 13589 ""
	    if (idotform == 1) {
#line 13590 ""
		all_1.nodur[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 24 - 
			25] = ifnodur_(&comnotes_1.nnodur, dotq, (ftnlen)1) * 
			3 / 2;
#line 13591 ""
	    } else if (idotform == 2) {
#line 13592 ""
		all_1.nodur[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 24 - 
			25] = all_1.nodur[commvl_1.ivx + (all_1.nnl[
			commvl_1.ivx - 1] - 1) * 24 - 25] / 3;
#line 13593 ""
	    } else if (idotform == 3) {
#line 13594 ""
		all_1.nodur[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 24 - 
			25] = ifnodur_(&comnotes_1.nnodur, dotq, (ftnlen)1);
#line 13595 ""
	    } else if (idotform == 4) {
#line 13596 ""
		all_1.nodur[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 24 - 
			25] = all_1.nodur[commvl_1.ivx + (all_1.nnl[
			commvl_1.ivx - 1] - 1) * 24 - 25] / 2;
#line 13597 ""
	    }
#line 13598 ""
	} else if (bit_test(all_1.islur[commvl_1.ivx + all_1.nnl[commvl_1.ivx 
		- 1] * 24 - 25],19)) {

/*  Set duration of full-bar rest as pause */

#line 13602 ""
	    all_1.nodur[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 24 - 25] 
		    = all_1.lenbar;

/*  Use a one-line function to set nnodur.  It gives inverse of ifnodur. */

#line 13606 ""
	    i__1 = (integer) (log(all_1.lenbar + .1f) / .69315f) + 48;
#line 13606 ""
	    chax_(ch__1, (ftnlen)1, &i__1);
#line 13606 ""
	    comnotes_1.nnodur = i_indx("62514x0x37", ch__1, (ftnlen)10, (
		    ftnlen)1) - 1;
#line 13608 ""
	} else if (comgrace_1.ibarmbr != all_1.nbars + 1) {
#line 13609 ""
	    all_1.nodur[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 24 - 25] 
		    = ifnodur_(&comnotes_1.nnodur, dotq, (ftnlen)1);
#line 13610 ""
	    if (bit_test(all_1.islur[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 
		    1] * 24 - 25],3)) {
#line 13610 ""
		all_1.nodur[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 24 - 
			25] = all_1.nodur[commvl_1.ivx + all_1.nnl[
			commvl_1.ivx - 1] * 24 - 25] * 7 / 6;
#line 13610 ""
	    }
#line 13612 ""
	}
#line 13613 ""
	if (comnotes_1.shifton && ! bit_test(all_1.irest[commvl_1.ivx + 
		all_1.nnl[commvl_1.ivx - 1] * 24 - 25],16)) {

/*  Shift is on, and this is not first shifted note.  Check for duration change */

#line 13617 ""
	    if (all_1.nodur[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 24 - 
		    25] != all_1.nodur[commvl_1.ivx + (all_1.nnl[commvl_1.ivx 
		    - 1] - 1) * 24 - 25]) {

/*  Must stop and restart the offset. */

#line 13621 ""
		all_1.irest[commvl_1.ivx + (all_1.nnl[commvl_1.ivx - 1] - 1) *
			 24 - 25] = bit_set(all_1.irest[commvl_1.ivx + (
			all_1.nnl[commvl_1.ivx - 1] - 1) * 24 - 25],17);
#line 13622 ""
		all_1.irest[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 24 - 
			25] = bit_set(all_1.irest[commvl_1.ivx + all_1.nnl[
			commvl_1.ivx - 1] * 24 - 25],16);
#line 13623 ""
		++comudsp_1.nudoff[commvl_1.ivx - 1];
#line 13624 ""
		comudsp_1.udoff[commvl_1.ivx + comudsp_1.nudoff[commvl_1.ivx 
			- 1] * 24 - 25] = comudsp_1.udoff[commvl_1.ivx + (
			comudsp_1.nudoff[commvl_1.ivx - 1] - 1) * 24 - 25];
#line 13625 ""
	    }
#line 13626 ""
	}
#line 13627 ""
	all_1.itsofar[commvl_1.ivx - 1] += all_1.nodur[commvl_1.ivx + 
		all_1.nnl[commvl_1.ivx - 1] * 24 - 25];
#line 13628 ""
	if (comfb_1.autofbon && comfb_1.tautofb > comtol_1.tol && 
		comget_1.fbon) {

/*  Check to see if need to terminate auto forced beam */

#line 13632 ""
	    r__1 = all_1.itsofar[commvl_1.ivx - 1] - comfb_1.t1autofb;
#line 13632 ""
	    if (r_mod(&r__1, &comfb_1.tautofb) < comtol_1.tol) {

/*  Terminate autofb */

#line 13636 ""
		comfb_1.t2fb[commvl_1.ivx + comfb_1.nfb[commvl_1.ivx - 1] * 
			24 - 25] = (real) all_1.itsofar[commvl_1.ivx - 1];
#line 13637 ""
		comget_1.fbon = FALSE_;
#line 13638 ""
	    }
#line 13639 ""
	}
#line 13640 ""
	if ((all_1.itsofar[commvl_1.ivx - 1] - all_1.lenb0) % all_1.lenbar == 
		0) {

/*  Finished a bar */

#line 13644 ""
	    ++all_1.nbars;
#line 13645 ""
	    all_1.nib[commvl_1.ivx + all_1.nbars * 24 - 25] = all_1.nnl[
		    commvl_1.ivx - 1];
#line 13646 ""
	    if (all_1.firstgulp && all_1.lenb0 != 0 && all_1.nbars == 1) {

/*  Just finished the pickup bar for this voice. */

#line 13650 ""
		all_1.lenbar = all_1.lenb1;
#line 13651 ""
	    }
#line 13652 ""
	}
#line 13653 ""
	if (idotform == 1) {
#line 13654 ""
	    getchar_(lineq, &all_1.iccount, charq, (ftnlen)128, (ftnlen)1);
#line 13655 ""
	    idotform = 2;
#line 13656 ""
	    numnum = 1;
#line 13657 ""
	    goto L28;
#line 13658 ""
	} else if (idotform == 3) {
#line 13659 ""
	    getchar_(lineq, &all_1.iccount, charq, (ftnlen)128, (ftnlen)1);
#line 13660 ""
	    idotform = 4;
#line 13661 ""
	    numnum = 1;
#line 13662 ""
	    goto L28;
#line 13663 ""
	}

/*  End of sub block for note-rest */

#line 13667 ""
    } else if (*(unsigned char *)charq == 'z') {

/*  Chord note.  Must have note name, may have octave#,+,-,s,f,n,d */
/*  Actually the 'd' is not used, since time value comes from */
/*    basic note. Unless dot is to be shifted! */
/*  Doesn't increase # of notes, so must handle separately */
/*  ncrd: index of crd */
/*  Set bit 10 of ipl on main note as flag */
/*  Bits in icrdat: */
/*     0-7   ip within voice */
/*     8-11  ivx */
/*     12-18 note level */
/*     19    accidental? */
/*     20-22 accidental value (1=natural, 2=flat, 3=sharp, 6=dflat, 7=dsharp) */
/*     23    shift left */
/*     24    shift right */
/*     25    arpeggio start or stop */
/*     26    flag for moved dot (here, not icrdot, since this is always reset!) */
/*     27    Midi-only accidental */
/*     29    Tag for accidental shift...means add to autoshifts. */
/*     31    Cautionary accidental */

/*  Bits in icrdot: */
/*     0-6   10*abs(vertical dot shift in \internote) + 64 */
/*     7-13  10*abs(horizontal dot shift in \internote) + 64 */
/*     14-19 vert accidental shift-32 */
/*     20-26 20*(horiz accidental shift+3.2) */
/*     27-29 top-down level rank of chord note w/accid. Set in crdaccs. */

/*  Bits in icrdorn are same as in iornq, even tho most orns won't go in crds. */

#line 13698 ""
	++comtrill_1.ncrd;
#line 13699 ""
	all_1.ipl[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 24 - 25] = 
		bit_set(all_1.ipl[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] *
		 24 - 25],10);
#line 13700 ""
	numnum = 0;
#line 13701 ""
	comtrill_1.icrdat[comtrill_1.ncrd - 1] = all_1.nnl[commvl_1.ivx - 1];
#line 13702 ""
	i__1 = commvl_1.ivx % 16;
#line 13702 ""
	setbits_(&comtrill_1.icrdat[comtrill_1.ncrd - 1], &c__4, &c__8, &i__1)
		;
#line 13703 ""
	if (commvl_1.ivx >= 16) {
#line 13703 ""
	    comtrill_1.icrdat[comtrill_1.ncrd - 1] = bit_set(
		    comtrill_1.icrdat[comtrill_1.ncrd - 1],28);
#line 13703 ""
	}
#line 13704 ""
	comtrill_1.icrdot[comtrill_1.ncrd - 1] = 0;
#line 13705 ""
	comtrill_1.icrdorn[comtrill_1.ncrd - 1] = 0;

/*  Get note name */

#line 13709 ""
	getchar_(lineq, &all_1.iccount, charq, (ftnlen)128, (ftnlen)1);

/*  Get optional inputs */

#line 13713 ""
L25:
#line 13713 ""
	getchar_(lineq, &all_1.iccount, durq, (ftnlen)128, (ftnlen)1);
#line 13714 ""
	ndx = i_indx("fsn+-<>12345678rediAc", durq, (ftnlen)21, (ftnlen)1);
#line 13715 ""
	if (ndx == 20) {

/*  Expect +|-|<|> , set tag, loop */

#line 13719 ""
	    comtrill_1.icrdat[comtrill_1.ncrd - 1] = bit_set(
		    comtrill_1.icrdat[comtrill_1.ncrd - 1],29);
#line 13720 ""
	    goto L25;
#line 13721 ""
	} else if (ndx > 0) {
#line 13722 ""
	    if (ndx <= 3) {
#line 13723 ""
		if (! bit_test(comtrill_1.icrdat[comtrill_1.ncrd - 1],19)) {
#line 13724 ""
		    comtrill_1.icrdat[comtrill_1.ncrd - 1] = bit_set(
			    comtrill_1.icrdat[comtrill_1.ncrd - 1],19);
#line 13725 ""
		    comtrill_1.icrdat[comtrill_1.ncrd - 1] |= ndx << 20;
#line 13726 ""
		} else {
#line 13727 ""
		    comtrill_1.icrdat[comtrill_1.ncrd - 1] = bit_set(
			    comtrill_1.icrdat[comtrill_1.ncrd - 1],22);
#line 13728 ""
		}
#line 13729 ""
	    } else if (ndx == 21) {

/*  Set flags for cautionary accidental */

#line 13733 ""
		comtrill_1.icrdat[comtrill_1.ncrd - 1] = bit_set(
			comtrill_1.icrdat[comtrill_1.ncrd - 1],31);
#line 13734 ""
		all_1.iornq[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 24 - 
			1] = bit_set(all_1.iornq[commvl_1.ivx + all_1.nnl[
			commvl_1.ivx - 1] * 24 - 1],31);
#line 13735 ""
	    } else if (ndx <= 7) {

/* +/-/</> Check whether octave or accidental shift */

#line 13739 ""
		nactmp = 0;
#line 13740 ""
		chkpm4ac_(lineq, &all_1.iccount, &nactmp, &moved, (ftnlen)128)
			;
#line 13741 ""
		if (moved) {

/*  Transfer accidental shift values */

#line 13745 ""
		    i__1 = igetbits_(&nactmp, &c__6, &c__4);
#line 13745 ""
		    setbits_(&comtrill_1.icrdot[comtrill_1.ncrd - 1], &c__6, &
			    c__14, &i__1);
#line 13746 ""
		    i__1 = igetbits_(&nactmp, &c__7, &c__10);
#line 13746 ""
		    setbits_(&comtrill_1.icrdot[comtrill_1.ncrd - 1], &c__7, &
			    c__20, &i__1);
#line 13747 ""
		} else {
#line 13748 ""
		    if (*(unsigned char *)durq == '+') {
#line 13749 ""
			comnotes_1.lastlev += 7;
#line 13750 ""
		    } else if (*(unsigned char *)durq == '-') {
#line 13751 ""
			comnotes_1.lastlev += -7;
#line 13752 ""
		    }
#line 13753 ""
		}
#line 13754 ""
	    } else if (*(unsigned char *)durq == 'e') {
#line 13755 ""
		comtrill_1.icrdat[comtrill_1.ncrd - 1] = bit_set(
			comtrill_1.icrdat[comtrill_1.ncrd - 1],23);
#line 13756 ""
		all_1.irest[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 24 - 
			25] = bit_set(all_1.irest[commvl_1.ivx + all_1.nnl[
			commvl_1.ivx - 1] * 24 - 25],27);
#line 13757 ""
	    } else if (*(unsigned char *)durq == 'r') {
#line 13758 ""
		comtrill_1.icrdat[comtrill_1.ncrd - 1] = bit_set(
			comtrill_1.icrdat[comtrill_1.ncrd - 1],24);
#line 13759 ""
		all_1.irest[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 24 - 
			25] = bit_set(all_1.irest[commvl_1.ivx + all_1.nnl[
			commvl_1.ivx - 1] * 24 - 25],20);
#line 13760 ""
	    } else if (*(unsigned char *)durq == 'i') {

/*  Midi-only accidental on chord note */

#line 13764 ""
		comtrill_1.icrdat[comtrill_1.ncrd - 1] = bit_set(
			comtrill_1.icrdat[comtrill_1.ncrd - 1],27);
#line 13765 ""
	    } else if (*(unsigned char *)durq == 'd') {

/*  Must keep 'd' optional (backward compatibility), unless it is moved! */

#line 13769 ""
		i__1 = all_1.iccount;
#line 13769 ""
		if (i_indx("+-", lineq + i__1, (ftnlen)2, all_1.iccount + 1 - 
			i__1) > 0) {

/*  move a dot, unless next char is not part of a number */

#line 13773 ""
		    i__1 = all_1.iccount + 1;
#line 13773 ""
		    if (i_indx("0123456789.", lineq + i__1, (ftnlen)11, 
			    all_1.iccount + 2 - i__1) == 0) {
#line 13773 ""
			goto L25;
#line 13773 ""
		    }
#line 13775 ""
		    comtrill_1.icrdat[comtrill_1.ncrd - 1] = bit_set(
			    comtrill_1.icrdat[comtrill_1.ncrd - 1],26);
#line 13776 ""
		    getchar_(lineq, &all_1.iccount, durq, (ftnlen)128, (
			    ftnlen)1);
#line 13777 ""
		    ++all_1.iccount;
#line 13778 ""
		    readnum_(lineq, &all_1.iccount, dumq, &fnum, (ftnlen)128, 
			    (ftnlen)1);
#line 13779 ""
		    if (*(unsigned char *)durq == '+') {
#line 13780 ""
			r__1 = fnum * 10;
#line 13780 ""
			comtrill_1.icrdot[comtrill_1.ncrd - 1] |= i_nint(&
				r__1) + 64;
#line 13781 ""
		    } else {
#line 13782 ""
			r__1 = fnum * 10;
#line 13782 ""
			comtrill_1.icrdot[comtrill_1.ncrd - 1] |= -i_nint(&
				r__1) + 64;
#line 13783 ""
		    }
#line 13784 ""
		    if (i_indx("+-", dumq, (ftnlen)2, (ftnlen)1) > 0) {

/*  Vertical shift specified also */

#line 13788 ""
			++all_1.iccount;
#line 13789 ""
			readnum_(lineq, &all_1.iccount, durq, &fnum, (ftnlen)
				128, (ftnlen)1);
#line 13790 ""
			if (*(unsigned char *)dumq == '+') {
#line 13791 ""
			    r__1 = fnum * 10;
#line 13791 ""
			    ifnum = i_nint(&r__1) + 64;
#line 13792 ""
			} else {
#line 13793 ""
			    r__1 = fnum * 10;
#line 13793 ""
			    ifnum = -i_nint(&r__1) + 64;
#line 13794 ""
			}
#line 13795 ""
		    } else {
#line 13796 ""
			ifnum = 64;
#line 13797 ""
		    }
#line 13798 ""
		    comtrill_1.icrdot[comtrill_1.ncrd - 1] |= ifnum << 7;
#line 13799 ""
		    --all_1.iccount;
#line 13800 ""
		}
#line 13801 ""
	    } else {

/* must be a single digit, save it in ioct */

#line 13805 ""
		numnum = 1;
#line 13806 ""
		ioct = ndx - 7;
#line 13807 ""
	    }
#line 13808 ""
	    goto L25;
#line 13809 ""
	}
#line 13810 ""
	if (numnum == 1) {
#line 13811 ""
	    comnotes_1.lastlev = ifnolev_(charq, &ioct, &
		    cominsttrans_1.itransamt[cominsttrans_1.instno[all_1.iv - 
		    1] - 1], (ftnlen)1);
#line 13812 ""
	} else {
#line 13813 ""
	    comnotes_1.lastlev = comnotes_1.lastlev - 3 + (ifnolev_(charq, &
		    c__10, &cominsttrans_1.itransamt[cominsttrans_1.instno[
		    all_1.iv - 1] - 1], (ftnlen)1) - comnotes_1.lastlev + 3) %
		     7;
#line 13815 ""
	}
#line 13816 ""
	comtrill_1.icrdat[comtrill_1.ncrd - 1] |= comnotes_1.lastlev << 12;
#line 13817 ""
	for (comnotes_1.npreslur = comnotes_1.npreslur; comnotes_1.npreslur >=
		 1; --comnotes_1.npreslur) {
#line 13818 ""
	    setbits_(&all_1.isdat2[all_1.nsdat - comnotes_1.npreslur], &c__7, 
		    &c__19, &comnotes_1.lastlev);

/*  Set level for chord note. */
/*  Initially I assigned the slur(s) to next note, so fix. */

#line 13823 ""
	    all_1.islur[commvl_1.ivx + (all_1.nnl[commvl_1.ivx - 1] + 1) * 24 
		    - 25] = bit_clear(all_1.islur[commvl_1.ivx + (all_1.nnl[
		    commvl_1.ivx - 1] + 1) * 24 - 25],0);
#line 13824 ""
	    all_1.islur[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 24 - 25] 
		    = bit_set(all_1.islur[commvl_1.ivx + all_1.nnl[
		    commvl_1.ivx - 1] * 24 - 25],0);
#line 13825 ""
	    all_1.isdat2[all_1.nsdat - comnotes_1.npreslur] = bit_set(
		    all_1.isdat2[all_1.nsdat - comnotes_1.npreslur],0);
#line 13826 ""
	    i__1 = igetbits_(&all_1.isdat1[all_1.nsdat - comnotes_1.npreslur],
		     &c__8, &c__3) - 1;
#line 13826 ""
	    setbits_(&all_1.isdat1[all_1.nsdat - comnotes_1.npreslur], &c__8, 
		    &c__3, &i__1);
#line 13828 ""
/* L44: */
#line 13828 ""
	}
#line 13829 ""
	if (comnotes_1.notcrd) {

/*  This is the first chord note in this chord. */

/* Computing MIN */
#line 13833 ""
	    i__1 = all_1.nolev[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 
		    24 - 25];
#line 13833 ""
	    comtrill_1.minlev = min(i__1,comnotes_1.lastlev);
/* Computing MAX */
#line 13834 ""
	    i__1 = all_1.nolev[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 
		    24 - 25];
#line 13834 ""
	    comtrill_1.maxlev = max(i__1,comnotes_1.lastlev);
#line 13835 ""
	} else {
#line 13836 ""
	    comtrill_1.minlev = min(comtrill_1.minlev,comnotes_1.lastlev);
#line 13837 ""
	    comtrill_1.maxlev = max(comtrill_1.maxlev,comnotes_1.lastlev);
#line 13838 ""
	}
#line 13839 ""
	comnotes_1.notcrd = FALSE_;
#line 13840 ""
    } else if (*(unsigned char *)charq == 'G') {
#line 13841 ""
	getgrace_(&commvl_1.ivx, all_1.nnl, lineq, &all_1.iccount, 
		all_1.islur, all_1.iornq, all_1.ipl, comnotes_1.ndlev, &
		comnotes_1.lastlev, &all_1.iv, &all_1.nv, (ftnlen)128);

/* Grace, comes *before* main note: */
/* UNLESS there's an 'A' or 'W' after the 'G' */
/*   ngrace = # of grace note groups so far in block */
/*   ivg(ngrace), ipg(ngrace) */
/*   nng(ngrace) = # of notes in this group: default = 1 */
/*   ngstrt(ngrace) = starting position in nolevg of levels for this grace */
/*   multg(ngrace) = multiplicity: default = 1;  input as 'm(digit)' */
/*   upg(ngrace) = logical for beam or stem dirn: default T, input'u,l' */
/*   slurg(ngrace) = logical for slur; default F, input 's' */
/*   slashg(ngrace) = T if slash; default is F, input 'x' */
/* These data MUST precede note name of first note */
/*   nolevg, naccg: lists of levels and accid's, indexed as described above. */

#line 13857 ""
    } else if (*(unsigned char *)charq == *(unsigned char *)all_1.sq) {

/*  Literal TeX string */

#line 13861 ""
	i__1 = all_1.nnl[commvl_1.ivx - 1] + 1;
#line 13861 ""
	littex_(all_1.islur, &i__1, &commvl_1.ivx, &comas3_1.topmods, lineq, &
		all_1.iccount, (ftnlen)128);
#line 13862 ""
    } else /* if(complicated condition) */ {
#line 13862 ""
	chax_(ch__1, (ftnlen)1, &c__34);
#line 13862 ""
	if (*(unsigned char *)charq == *(unsigned char *)&ch__1[0]) {

/*  pmxlyr string. Expand "..." to \pmxlyr{...}\ */

#line 13866 ""
	    if (! comlyr_1.inputmlyr) {
#line 13867 ""
		ictemp = 0;
/* Writing concatenation */
#line 13868 ""
		i__3[0] = 1, a__1[0] = all_1.sq;
#line 13868 ""
		i__3[1] = 1, a__1[1] = all_1.sq;
#line 13868 ""
		i__3[2] = 1, a__1[2] = all_1.sq;
#line 13868 ""
		i__3[3] = 15, a__1[3] = "input musixlyr ";
#line 13868 ""
		i__3[4] = 1, a__1[4] = all_1.sq;
#line 13868 ""
		s_cat(lineqt, a__1, i__3, &c__5, (ftnlen)128);
#line 13869 ""
		i__1 = all_1.nnl[commvl_1.ivx - 1] + 1;
#line 13869 ""
		littex_(all_1.islur, &i__1, &commvl_1.ivx, &comas3_1.topmods, 
			lineqt, &ictemp, (ftnlen)128);
#line 13870 ""
		comlyr_1.inputmlyr = TRUE_;
#line 13871 ""
	    }
#line 13872 ""
	    dopmxlyr_(lineq, &all_1.iccount, (ftnlen)128);
#line 13873 ""
	    *(unsigned char *)charq = *(unsigned char *)all_1.sq;
#line 13874 ""
	    i__1 = all_1.nnl[commvl_1.ivx - 1] + 1;
#line 13874 ""
	    littex_(all_1.islur, &i__1, &commvl_1.ivx, &comas3_1.topmods, 
		    lineq, &all_1.iccount, (ftnlen)128);
#line 13875 ""
	} else if (*(unsigned char *)charq == 'o') {

/*  Ornament on non-xtup note.  Symbol must come AFTER the affected note */

#line 13879 ""
	    if (comnotes_1.notcrd) {
#line 13880 ""
		nole = all_1.nolev[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] 
			* 24 - 25];
#line 13881 ""
	    } else {
#line 13882 ""
		nole = 127 & lbit_shift(comtrill_1.icrdat[comtrill_1.ncrd - 1]
			, (ftnlen)-12);
#line 13883 ""
	    }
#line 13884 ""
	    getorn_(lineq, &all_1.iccount, &all_1.iornq[commvl_1.ivx + 
		    all_1.nnl[commvl_1.ivx - 1] * 24 - 1], &all_1.iornq[
		    commvl_1.ivx - 1], &comget_1.ornrpt, &comgrace_1.noffseg, 
		    &all_1.nnl[commvl_1.ivx - 1], &commvl_1.ivx, &c_true, &
		    comnotes_1.notcrd, &nole, (ftnlen)128);
#line 13887 ""
	} else if (i_indx("st(){}", charq, (ftnlen)6, (ftnlen)1) > 0) {
#line 13888 ""
	    nnlivx = all_1.nnl[commvl_1.ivx - 1];
#line 13889 ""
	    if (*(unsigned char *)charq == '(' || *(unsigned char *)charq == 
		    '{') {

/* Detect preslur on normal non-chord note */

#line 13893 ""
		++nnlivx;
#line 13894 ""
		++comnotes_1.npreslur;
#line 13895 ""
	    }
#line 13896 ""
	    all_1.islur[commvl_1.ivx + nnlivx * 24 - 25] = bit_set(
		    all_1.islur[commvl_1.ivx + nnlivx * 24 - 25],0);
#line 13897 ""
	    if (*(unsigned char *)charq == 't') {
#line 13897 ""
		all_1.islur[commvl_1.ivx + nnlivx * 24 - 25] = bit_set(
			all_1.islur[commvl_1.ivx + nnlivx * 24 - 25],1);
#line 13897 ""
	    }
#line 13899 ""
	    if (commvl_1.ivx <= all_1.nv) {
#line 13900 ""
		kv = 1;
#line 13901 ""
	    } else {
#line 13902 ""
		kv = 2;
#line 13903 ""
	    }
#line 13904 ""
	    if (comslur_1.fontslur) {
#line 13905 ""
		sslur_(lineq, &all_1.iccount, &all_1.iv, &kv, &nnlivx, 
			all_1.isdat1, all_1.isdat2, all_1.isdat3, &
			all_1.nsdat, &comnotes_1.notcrd, &all_1.nolev[
			commvl_1.ivx + nnlivx * 24 - 25], charq, (ftnlen)128, 
			(ftnlen)1);
#line 13907 ""
	    } else {
#line 13908 ""
		spsslur_(lineq, &all_1.iccount, &all_1.iv, &kv, &nnlivx, 
			all_1.isdat1, all_1.isdat2, all_1.isdat3, 
			all_1.isdat4, &all_1.nsdat, &comnotes_1.notcrd, &
			all_1.nolev[commvl_1.ivx + nnlivx * 24 - 25], charq, (
			ftnlen)128, (ftnlen)1);
#line 13910 ""
	    }
#line 13911 ""
	} else if (*(unsigned char *)charq == '?') {

/*  Arpeggio */

#line 13915 ""
	    if (bit_test(all_1.ipl[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] 
		    * 24 - 25],10)) {

/*  This is a chordal note.  Set a bit in icrdat.  But if *main* (spacing) note */
/*  of chord, will not set icrdat(25), but iornq(27) */

#line 13920 ""
		comtrill_1.icrdat[comtrill_1.ncrd - 1] = bit_set(
			comtrill_1.icrdat[comtrill_1.ncrd - 1],25);
#line 13921 ""
	    } else {
#line 13922 ""
		all_1.iornq[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 24 - 
			1] = bit_set(all_1.iornq[commvl_1.ivx + all_1.nnl[
			commvl_1.ivx - 1] * 24 - 1],27);
#line 13923 ""
	    }

/*  Check for shift */

#line 13927 ""
	    getchar_(lineq, &all_1.iccount, durq, (ftnlen)128, (ftnlen)1);
#line 13928 ""
	    if (*(unsigned char *)durq == ' ') {
#line 13929 ""
		--all_1.iccount;
#line 13930 ""
	    } else {

/*  durq must be "-" */

#line 13934 ""
		++all_1.iccount;
#line 13935 ""
		readnum_(lineq, &all_1.iccount, durq, &fnum, (ftnlen)128, (
			ftnlen)1);
#line 13936 ""
		--all_1.iccount;

/*  record the shift */

#line 13940 ""
		++comarpshift_1.numarpshift;
#line 13941 ""
		comarpshift_1.ivarpshift[comarpshift_1.numarpshift - 1] = 
			commvl_1.ivx;
#line 13942 ""
		comarpshift_1.iparpshift[comarpshift_1.numarpshift - 1] = 
			all_1.nnl[commvl_1.ivx - 1];
#line 13943 ""
		comarpshift_1.arpshift[comarpshift_1.numarpshift - 1] = fnum;
#line 13944 ""
	    }
#line 13945 ""
	} else if (i_indx("0123456789#-nx_", charq, (ftnlen)15, (ftnlen)1) > 
		0) {

/*  We have a figure.  Must come AFTER the note it goes under */

#line 13950 ""
	    ivf = 1;
#line 13951 ""
	    if (commvl_1.ivx > 1) {
#line 13952 ""
		if (comfig_1.ivxfig2 == 0) {
#line 13953 ""
		    comfig_1.ivxfig2 = commvl_1.ivx;
#line 13954 ""
		} else if (commvl_1.ivx != comfig_1.ivxfig2) {
#line 13955 ""
		    s_wsle(&io___816);
#line 13955 ""
		    e_wsle();
#line 13956 ""
		    s_wsle(&io___817);
#line 13956 ""
		    do_lio(&c__9, &c__1, "Figures not allowed in >1 voice ab"\
			    "ove first", (ftnlen)43);
#line 13956 ""
		    e_wsle();
#line 13957 ""
		    s_stop("", (ftnlen)0);
#line 13958 ""
		}
#line 13959 ""
		ivf = 2;
#line 13960 ""
	    }
#line 13961 ""
	    nfig1 = comfig_1.nfigs[ivf - 1] + 1;
#line 13962 ""
	    getfig_(&comgrace_1.itoff[ivf + (nfig1 << 1) - 3], charq, lineq, &
		    all_1.iccount, &all_1.isfig[ivf + (all_1.nnl[commvl_1.ivx 
		    - 1] << 1) - 3], &comfig_1.itfig[ivf + (nfig1 << 1) - 3], 
		    &all_1.itsofar[commvl_1.ivx - 1], &all_1.nodur[
		    commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 24 - 25], 
		    comfig_1.figq + (ivf + (nfig1 << 1) - 3) * 10, &
		    comfig_1.ivupfig[ivf + (nfig1 << 1) - 3], &
		    comfig_1.ivvfig[ivf + (nfig1 << 1) - 3], &comfig_1.nfigs[
		    ivf - 1], (ftnlen)1, (ftnlen)128, (ftnlen)10);
#line 13966 ""
	} else if (*(unsigned char *)charq == '[') {

/*  Start forced beam.  Record barno & time since start of inp. blk.  Set signal */

#line 13970 ""
	    ++comfb_1.nfb[commvl_1.ivx - 1];
#line 13971 ""
	    comget_1.fbon = TRUE_;
#line 13972 ""
	    *(unsigned char *)&comfb_1.ulfbq[commvl_1.ivx + comfb_1.nfb[
		    commvl_1.ivx - 1] * 24 - 25] = 'x';
#line 13973 ""
	    comfb_1.t1fb[commvl_1.ivx + comfb_1.nfb[commvl_1.ivx - 1] * 24 - 
		    25] = (real) all_1.itsofar[commvl_1.ivx - 1];
#line 13974 ""
	    nadj = 0;
#line 13975 ""
	    if (comfb_1.autofbon) {
#line 13976 ""
		comfb_1.autofbon = FALSE_;
#line 13977 ""
	    }
#line 13978 ""
L17:
#line 13978 ""
	    getchar_(lineq, &all_1.iccount, charq, (ftnlen)128, (ftnlen)1);
#line 13979 ""
	    if (i_indx("ulf", charq, (ftnlen)3, (ftnlen)1) > 0) {
#line 13980 ""
		*(unsigned char *)&comfb_1.ulfbq[commvl_1.ivx + comfb_1.nfb[
			commvl_1.ivx - 1] * 24 - 25] = *(unsigned char *)
			charq;
#line 13981 ""
		goto L17;
#line 13982 ""
	    } else if (*(unsigned char *)charq == 'j') {

/*  Continuing a jumped beam here */

#line 13986 ""
		all_1.irest[commvl_1.ivx + (all_1.nnl[commvl_1.ivx - 1] + 1) *
			 24 - 25] = bit_set(all_1.irest[commvl_1.ivx + (
			all_1.nnl[commvl_1.ivx - 1] + 1) * 24 - 25],24);

/*  Set flag to watch for END of this forced beam, so can set flag rest(30) on */
/*  NEXT note as signal to start a new notes group there. */

#line 13991 ""
		combjmp_1.isbj2 = TRUE_;
#line 13992 ""
		goto L17;
#line 13993 ""
	    } else if (*(unsigned char *)charq == 'h') {
#line 13994 ""
		all_1.islur[commvl_1.ivx + (all_1.nnl[commvl_1.ivx - 1] + 1) *
			 24 - 25] = bit_set(all_1.islur[commvl_1.ivx + (
			all_1.nnl[commvl_1.ivx - 1] + 1) * 24 - 25],2);
#line 13995 ""
		goto L17;
#line 13996 ""
	    } else if (*(unsigned char *)charq == 'm') {

/*  Force multiplicity.  Next input is digit */

#line 14000 ""
		getchar_(lineq, &all_1.iccount, charq, (ftnlen)128, (ftnlen)1)
			;
#line 14001 ""
		all_1.islur[commvl_1.ivx + (all_1.nnl[commvl_1.ivx - 1] + 1) *
			 24 - 25] = bit_set(all_1.islur[commvl_1.ivx + (
			all_1.nnl[commvl_1.ivx - 1] + 1) * 24 - 25],21);
#line 14002 ""
		i__1 = *(unsigned char *)charq - 48;
#line 14002 ""
		setbits_(&all_1.islur[commvl_1.ivx + (all_1.nnl[commvl_1.ivx 
			- 1] + 1) * 24 - 25], &c__3, &c__22, &i__1);
#line 14003 ""
		goto L17;
#line 14004 ""
	    } else if (*(unsigned char *)charq == ':') {

/*  Start auto forced beam pattern */

#line 14008 ""
		comfb_1.autofbon = TRUE_;

/*  When forced later beam ends, check whether tautofv <=0; if so set it. */

#line 14012 ""
		comfb_1.tautofb = (real) (-all_1.itsofar[commvl_1.ivx - 1]);
#line 14013 ""
		comfb_1.t1autofb = (real) all_1.itsofar[commvl_1.ivx - 1];
#line 14014 ""
		goto L17;
#line 14015 ""
	    } else if (*(unsigned char *)charq != ' ') {

/*  Must be '+/-' for height or slope shift */

#line 14019 ""
		++nadj;

/*  nadj = 1,2, or 3 for normal start level, slope, or beam-thk start level. */

#line 14023 ""
		++all_1.iccount;
#line 14024 ""
		readnum_(lineq, &all_1.iccount, durq, &fnum, (ftnlen)128, (
			ftnlen)1);
#line 14025 ""
		--all_1.iccount;
#line 14026 ""
		iadj = i_nint(&fnum);
#line 14027 ""
		if (*(unsigned char *)charq == '-') {
#line 14027 ""
		    iadj = -iadj;
#line 14027 ""
		}
#line 14028 ""
		if (nadj == 1) {

/*  This is a level shift.  Note if 0 was entered, iadj = 30 */

#line 14032 ""
		    i__1 = iadj + 30;
#line 14032 ""
		    setbits_(&all_1.ipl[commvl_1.ivx + (all_1.nnl[
			    commvl_1.ivx - 1] + 1) * 24 - 25], &c__6, &c__11, 
			    &i__1);
#line 14033 ""
		} else if (nadj == 2) {

/*  Must be a slope shift */

#line 14037 ""
		    i__1 = iadj + 30;
#line 14037 ""
		    setbits_(&all_1.ipl[commvl_1.ivx + (all_1.nnl[
			    commvl_1.ivx - 1] + 1) * 24 - 25], &c__6, &c__17, 
			    &i__1);
#line 14038 ""
		} else {

/*  Beam-thk fine tune */

#line 14042 ""
		    setbits_(&all_1.islur[commvl_1.ivx + (all_1.nnl[
			    commvl_1.ivx - 1] + 1) * 24 - 25], &c__2, &c__27, 
			    &iadj);
#line 14043 ""
		}
#line 14044 ""
		goto L17;
#line 14045 ""
	    }
#line 14046 ""
	} else if (*(unsigned char *)charq == ']') {
#line 14047 ""
	    if (comfb_1.autofbon && comfb_1.tautofb < comtol_1.tol) {
#line 14048 ""
		comfb_1.tautofb = all_1.itsofar[commvl_1.ivx - 1] + 
			comfb_1.tautofb;
#line 14049 ""
	    }
#line 14050 ""
	    getchar_(lineq, &all_1.iccount, charq, (ftnlen)128, (ftnlen)1);
#line 14051 ""
	    if (i_indx("j ", charq, (ftnlen)2, (ftnlen)1) > 0) {

/*  Since ']' comes AFTER note, itsofar has been updated.  Set ending signal. */

#line 14055 ""
		comfb_1.t2fb[commvl_1.ivx + comfb_1.nfb[commvl_1.ivx - 1] * 
			24 - 25] = (real) all_1.itsofar[commvl_1.ivx - 1];
#line 14056 ""
		comget_1.fbon = FALSE_;
#line 14057 ""
		if (*(unsigned char *)charq == 'j') {
#line 14058 ""
		    all_1.irest[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 
			    24 - 25] = bit_set(all_1.irest[commvl_1.ivx + 
			    all_1.nnl[commvl_1.ivx - 1] * 24 - 25],23);
#line 14059 ""
		}
#line 14060 ""
		if (combjmp_1.isbj2) {

/*  This is the end of a fb segment of a jump beam.  Set flag on NEXT note to */
/*  force start of new notes group, provided this is not last note in bar. */

#line 14065 ""
		    if (all_1.itsofar[commvl_1.ivx - 1] % all_1.lenbar != 0) {
#line 14065 ""
			all_1.irest[commvl_1.ivx + (all_1.nnl[commvl_1.ivx - 
				1] + 1) * 24 - 25] = bit_set(all_1.irest[
				commvl_1.ivx + (all_1.nnl[commvl_1.ivx - 1] + 
				1) * 24 - 25],30);
#line 14065 ""
		    }
#line 14067 ""
		    combjmp_1.isbj2 = FALSE_;
#line 14068 ""
		}
#line 14069 ""
	    } else if (*(unsigned char *)charq == '[') {

/*  Multiplicity down-up signal */

#line 14073 ""
		all_1.islur[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 24 - 
			25] = bit_set(all_1.islur[commvl_1.ivx + all_1.nnl[
			commvl_1.ivx - 1] * 24 - 25],20);
#line 14074 ""
	    } else if (*(unsigned char *)charq == '-') {

/*  Set signals for gap in single-slope beam [...]-[...] */

#line 14078 ""
		all_1.nacc[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 24 - 
			25] = bit_set(all_1.nacc[commvl_1.ivx + all_1.nnl[
			commvl_1.ivx - 1] * 24 - 25],20);
#line 14079 ""
		all_1.nacc[commvl_1.ivx + (all_1.nnl[commvl_1.ivx - 1] + 1) * 
			24 - 25] = bit_set(all_1.nacc[commvl_1.ivx + (
			all_1.nnl[commvl_1.ivx - 1] + 1) * 24 - 25],21);

/*  Next two characters must be "[ ".  Skip over them. */

#line 14083 ""
		all_1.iccount += 2;
#line 14084 ""
	    }
#line 14085 ""
	} else if (*(unsigned char *)charq == 'D') {
#line 14086 ""
	    getdyn_(&commvl_1.ivx, &all_1.nnl[commvl_1.ivx - 1], &all_1.irest[
		    commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 24 - 25], &
		    all_1.iornq[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 
		    24 - 1], lineq, &all_1.iccount, (ftnlen)128);
#line 14088 ""
	} else if (*(unsigned char *)charq == 'h') {

/*  Heading or height.  For heading, only OK if at start of block */
/*  Check whether at beginning of a block */

#line 14093 ""
	    if (all_1.iv != 1 || all_1.nnl[0] != 0) {
#line 14094 ""
		s_wsle(&io___819);
#line 14094 ""
		do_lio(&c__9, &c__1, "You entered \"h\" not at beginning of "\
			"block", (ftnlen)41);
#line 14094 ""
		e_wsle();
#line 14095 ""
		stop1_();
#line 14096 ""
	    }
#line 14097 ""
	    getchar_(lineq, &all_1.iccount, durq, (ftnlen)128, (ftnlen)1);
#line 14098 ""
	    comhead_1.ihdvrt = 0;
#line 14099 ""
	    if (i_indx("+-", durq, (ftnlen)2, (ftnlen)1) > 0) {

/* Vertical offset */

#line 14103 ""
		++all_1.iccount;
#line 14104 ""
		readnum_(lineq, &all_1.iccount, charq, &fnum, (ftnlen)128, (
			ftnlen)1);
#line 14105 ""
		comhead_1.ihdvrt = fnum + .1f;
#line 14106 ""
		if (*(unsigned char *)durq == '-') {
#line 14106 ""
		    comhead_1.ihdvrt = -comhead_1.ihdvrt;
#line 14106 ""
		}
#line 14107 ""
		*(unsigned char *)durq = *(unsigned char *)charq;
#line 14108 ""
	    }
#line 14109 ""
	    if (*(unsigned char *)durq != ' ') {

/*  Height symbol.  Read past (until next blank) */

#line 14113 ""
L3:
#line 14113 ""
		getchar_(lineq, &all_1.iccount, durq, (ftnlen)128, (ftnlen)1);
#line 14114 ""
		if (*(unsigned char *)durq != ' ') {
#line 14114 ""
		    goto L3;
#line 14114 ""
		}
#line 14115 ""
	    } else {

/*  Set flag for header & read it in */

#line 14119 ""
		comhead_1.ihdht = 16;
#line 14120 ""
		getbuf_(comhead_1.headrq, (ftnlen)80);
#line 14121 ""
		all_1.iccount = 128;
#line 14122 ""
	    }
#line 14123 ""
	} else if (*(unsigned char *)charq == 'L') {

/*  Linebreak, already handled some in pmxa, but need to get data for */
/*    shortened line or coda lengths */

#line 14128 ""
	    ++all_1.iccount;
#line 14129 ""
	    if (*(unsigned char *)&lineq[all_1.iccount - 1] == 'C') {

/*  Coda, get length */

#line 14133 ""
		++all_1.iccount;
#line 14134 ""
		readnum_(lineq, &all_1.iccount, durq, &comshort_1.codafrac, (
			ftnlen)128, (ftnlen)1);
#line 14135 ""
		comshort_1.ishort = 3;
#line 14136 ""
		if (*(unsigned char *)durq == 'n') {
#line 14136 ""
		    comshort_1.nocodabn = TRUE_;
#line 14136 ""
		}
#line 14137 ""
		return 0;
#line 14138 ""
	    }

/*  Get line number */

#line 14142 ""
	    readnum_(lineq, &all_1.iccount, durq, &fmovbrk, (ftnlen)128, (
		    ftnlen)1);
#line 14143 ""
L48:
/* Allow transfer up from below if S follows M */
#line 14144 ""
	    if (*(unsigned char *)durq == 'S') {

/*  Shortened line, get shortening fraction */

#line 14148 ""
		++all_1.iccount;
#line 14149 ""
		readnum_(lineq, &all_1.iccount, durq, &comshort_1.shortfrac, (
			ftnlen)128, (ftnlen)1);
#line 14150 ""
		comshort_1.ishort = 1;
#line 14151 ""
		comshort_1.codafrac = 0.f;
#line 14152 ""
	    }

/*  Begin check for movement break */

#line 14156 ""
	    if (*(unsigned char *)durq == 'P') {
#line 14157 ""
		++all_1.iccount;
#line 14158 ""
		readnum_(lineq, &all_1.iccount, durq, &fnum, (ftnlen)128, (
			ftnlen)1);
#line 14159 ""
	    }
#line 14160 ""
	    if (*(unsigned char *)durq == 'M') {
#line 14161 ""
		comget_1.movbrk = i_nint(&fmovbrk);
#line 14162 ""
		comget_1.movgap = 0;
#line 14163 ""
		comget_1.parmov = -1.f;
#line 14164 ""
		getchar_(lineq, &all_1.iccount, durq, (ftnlen)128, (ftnlen)1);
#line 14165 ""
L31:
#line 14165 ""
		if (*(unsigned char *)durq == '+') {

/*  Get vertical space (\internotes) */

#line 14169 ""
		    ++all_1.iccount;
#line 14170 ""
		    readnum_(lineq, &all_1.iccount, durq, &fnum, (ftnlen)128, 
			    (ftnlen)1);
#line 14171 ""
		    comget_1.movgap = i_nint(&fnum);
#line 14172 ""
		    goto L31;
#line 14173 ""
		} else if (*(unsigned char *)durq == 'i') {
#line 14174 ""
		    ++all_1.iccount;
#line 14175 ""
		    readnum_(lineq, &all_1.iccount, durq, &comget_1.parmov, (
			    ftnlen)128, (ftnlen)1);
#line 14176 ""
		    goto L31;
#line 14177 ""
		} else if (*(unsigned char *)durq == 'c') {
#line 14178 ""
		    comnotes_1.nobar1 = TRUE_;
#line 14179 ""
		    getchar_(lineq, &all_1.iccount, durq, (ftnlen)128, (
			    ftnlen)1);
#line 14180 ""
		    goto L31;
#line 14181 ""
		} else if (*(unsigned char *)durq == 'r') {

/*  "rename" can be set on or off. */

#line 14185 ""
		    getchar_(lineq, &all_1.iccount, durq, (ftnlen)128, (
			    ftnlen)1);
#line 14186 ""
		    comnvi_1.rename = *(unsigned char *)durq == '+';
#line 14187 ""
		    getchar_(lineq, &all_1.iccount, durq, (ftnlen)128, (
			    ftnlen)1);
#line 14188 ""
		    goto L31;
#line 14189 ""
		} else if (*(unsigned char *)durq == 'n') {

/*  Change # of voices.  Input ninow, iiorig(1...ninow).  Will use names, */
/*  staves per inst. and clefs  corr. to iiorig in original list of instruments. */

#line 14194 ""
		    nvold = all_1.nv;
#line 14195 ""
		    all_1.nv = 0;
#line 14196 ""
		    comnvi_1.rename = TRUE_;
#line 14197 ""
		    getchar_(lineq, &all_1.iccount, durq, (ftnlen)128, (
			    ftnlen)1);
#line 14198 ""
		    if (*(unsigned char *)durq == ':') {
#line 14199 ""
			all_1.iccount += 2;
#line 14200 ""
			i__1 = all_1.iccount - 2;
#line 14200 ""
			ici__1.icierr = 0;
#line 14200 ""
			ici__1.iciend = 0;
#line 14200 ""
			ici__1.icirnum = 1;
#line 14200 ""
			ici__1.icirlen = all_1.iccount - i__1;
#line 14200 ""
			ici__1.iciunit = lineq + i__1;
#line 14200 ""
			ici__1.icifmt = "(i2)";
#line 14200 ""
			s_rsfi(&ici__1);
#line 14200 ""
			do_fio(&c__1, (char *)&comnotes_1.ninow, (ftnlen)
				sizeof(integer));
#line 14200 ""
			e_rsfi();
#line 14201 ""
		    } else {
#line 14202 ""
			comnotes_1.ninow = *(unsigned char *)durq - 48;
#line 14203 ""
		    }
#line 14204 ""
		    iiv = 0;
#line 14205 ""
		    i__1 = comnotes_1.ninow;
#line 14205 ""
		    for (iinow = 1; iinow <= i__1; ++iinow) {
#line 14206 ""
			getchar_(lineq, &all_1.iccount, durq, (ftnlen)128, (
				ftnlen)1);
#line 14207 ""
			if (*(unsigned char *)durq == ':') {
#line 14208 ""
			    all_1.iccount += 2;
#line 14209 ""
			    i__2 = all_1.iccount - 2;
#line 14209 ""
			    ici__1.icierr = 0;
#line 14209 ""
			    ici__1.iciend = 0;
#line 14209 ""
			    ici__1.icirnum = 1;
#line 14209 ""
			    ici__1.icirlen = all_1.iccount - i__2;
#line 14209 ""
			    ici__1.iciunit = lineq + i__2;
#line 14209 ""
			    ici__1.icifmt = "(i2)";
#line 14209 ""
			    s_rsfi(&ici__1);
#line 14209 ""
			    do_fio(&c__1, (char *)&comnvi_1.iiorig[iinow - 1],
				     (ftnlen)sizeof(integer));
#line 14209 ""
			    e_rsfi();
#line 14210 ""
			} else {
#line 14211 ""
			    comnvi_1.iiorig[iinow - 1] = *(unsigned char *)
				    durq - 48;
#line 14212 ""
			}
#line 14213 ""
			comnvi_1.nspern[iinow - 1] = comnvi_1.nsperi[
				comnvi_1.iiorig[iinow - 1] - 1];
#line 14214 ""
			all_1.nv += comnvi_1.nspern[iinow - 1];
#line 14215 ""
			*(unsigned char *)&all_1.sepsymq[iiv + 
				comnvi_1.nspern[iinow - 1] - 1] = '&';
#line 14216 ""
			if (comnvi_1.nspern[iinow - 1] > 1) {
#line 14217 ""
			    i__2 = comnvi_1.nspern[iinow - 1] - 1;
#line 14217 ""
			    for (iis = 1; iis <= i__2; ++iis) {
#line 14218 ""
				*(unsigned char *)&all_1.sepsymq[iiv + iis - 
					1] = '|';
#line 14219 ""
/* L64: */
#line 14219 ""
			    }
#line 14220 ""
			}
#line 14221 ""
			iiv += comnvi_1.nspern[iinow - 1];
#line 14222 ""
/* L63: */
#line 14222 ""
		    }
#line 14223 ""
		    if (all_1.nv == 1 && nvold > 1) {
#line 14224 ""
			if (comlast_1.islast) {
#line 14224 ""
			    s_wsfe(&io___824);
/* Writing concatenation */
#line 14224 ""
			    i__5[0] = 1, a__2[0] = all_1.sq;
#line 14224 ""
			    i__5[1] = 11, a__2[1] = "nostartrule";
#line 14224 ""
			    s_cat(ch__2, a__2, i__5, &c__2, (ftnlen)12);
#line 14224 ""
			    do_fio(&c__1, ch__2, (ftnlen)12);
#line 14224 ""
			    e_wsfe();
#line 14224 ""
			}
#line 14225 ""
		    } else if (all_1.nv > 1 && nvold == 1) {
#line 14226 ""
			if (comlast_1.islast) {
#line 14226 ""
			    s_wsfe(&io___825);
/* Writing concatenation */
#line 14226 ""
			    i__5[0] = 1, a__2[0] = all_1.sq;
#line 14226 ""
			    i__5[1] = 9, a__2[1] = "startrule";
#line 14226 ""
			    s_cat(ch__3, a__2, i__5, &c__2, (ftnlen)10);
#line 14226 ""
			    do_fio(&c__1, ch__3, (ftnlen)10);
#line 14226 ""
			    e_wsfe();
#line 14226 ""
			}
#line 14227 ""
		    }
#line 14228 ""
		    iiv = 0;
#line 14229 ""
		    i__1 = comnotes_1.ninow;
#line 14229 ""
		    for (iinow = 1; iinow <= i__1; ++iinow) {
#line 14230 ""
			i__2 = comnvi_1.nspern[iinow - 1];
#line 14230 ""
			for (iis = 1; iis <= i__2; ++iis) {
#line 14231 ""
			    ++iiv;

/*  May not really need to re-enter clefs, but it's easier to program since */
/*  clef names are not saved but are needed in newvoice to set ncmidcc. */

#line 14236 ""
			    getchar_(lineq, &all_1.iccount, comclefq_1.clefq 
				    + (iiv - 1), (ftnlen)128, (ftnlen)1);
#line 14237 ""
			    newvoice_(&iiv, comclefq_1.clefq + (iiv - 1), &
				    c_true, (ftnlen)1);
#line 14238 ""
			    if (comnvi_1.nspern[iinow - 1] == 1) {
#line 14239 ""
				i__4 = numclef_(comclefq_1.clefq + (iiv - 1), 
					(ftnlen)1) + 48;
#line 14239 ""
				chax_(ch__1, (ftnlen)1, &i__4);
#line 14239 ""
				s_copy(hdlndq, ch__1, (ftnlen)59, (ftnlen)1);
#line 14240 ""
				lclf = 1;
#line 14241 ""
			    } else if (iis == 1) {
/* Writing concatenation */
#line 14242 ""
				i__5[0] = 1, a__2[0] = "{";
#line 14242 ""
				i__4 = numclef_(comclefq_1.clefq + (iiv - 1), 
					(ftnlen)1) + 48;
#line 14242 ""
				chax_(ch__1, (ftnlen)1, &i__4);
#line 14242 ""
				i__5[1] = 1, a__2[1] = ch__1;
#line 14242 ""
				s_cat(hdlndq, a__2, i__5, &c__2, (ftnlen)59);
#line 14243 ""
				lclf = 2;
#line 14244 ""
			    } else if (iis < comnvi_1.nspern[iinow - 1]) {
/* Writing concatenation */
#line 14245 ""
				i__5[0] = lclf, a__2[0] = hdlndq;
#line 14245 ""
				i__4 = numclef_(comclefq_1.clefq + (iiv - 1), 
					(ftnlen)1) + 48;
#line 14245 ""
				chax_(ch__1, (ftnlen)1, &i__4);
#line 14245 ""
				i__5[1] = 1, a__2[1] = ch__1;
#line 14245 ""
				s_cat(hdlndq, a__2, i__5, &c__2, (ftnlen)59);
#line 14246 ""
				++lclf;
#line 14247 ""
			    } else {
/* Writing concatenation */
#line 14248 ""
				i__6[0] = lclf, a__3[0] = hdlndq;
#line 14248 ""
				i__4 = numclef_(comclefq_1.clefq + (iiv - 1), 
					(ftnlen)1) + 48;
#line 14248 ""
				chax_(ch__1, (ftnlen)1, &i__4);
#line 14248 ""
				i__6[1] = 1, a__3[1] = ch__1;
#line 14248 ""
				i__6[2] = 1, a__3[2] = "}";
#line 14248 ""
				s_cat(hdlndq, a__3, i__6, &c__3, (ftnlen)59);
#line 14250 ""
				lclf += 2;
#line 14251 ""
			    }
#line 14252 ""
/* L61: */
#line 14252 ""
			}

/*  setstaffs & setclef go by instrument, not voice */

#line 14256 ""
			if (comlast_1.islast) {
#line 14257 ""
			    if (iinow < 10) {
#line 14258 ""
				s_wsfe(&io___828);
/* Writing concatenation */
#line 14258 ""
				i__3[0] = 1, a__1[0] = all_1.sq;
#line 14258 ""
				i__3[1] = 9, a__1[1] = "setstaffs";
#line 14258 ""
				i__2 = iinow + 48;
#line 14258 ""
				chax_(ch__1, (ftnlen)1, &i__2);
#line 14258 ""
				i__3[2] = 1, a__1[2] = ch__1;
#line 14258 ""
				i__4 = comnvi_1.nspern[iinow - 1] + 48;
#line 14258 ""
				chax_(ch__5, (ftnlen)1, &i__4);
#line 14258 ""
				i__3[3] = 1, a__1[3] = ch__5;
#line 14258 ""
				i__3[4] = 1, a__1[4] = "%";
#line 14258 ""
				s_cat(ch__4, a__1, i__3, &c__5, (ftnlen)13);
#line 14258 ""
				do_fio(&c__1, ch__4, (ftnlen)13);
#line 14258 ""
				e_wsfe();
#line 14260 ""
				s_wsfe(&io___829);
/* Writing concatenation */
#line 14260 ""
				i__3[0] = 1, a__1[0] = all_1.sq;
#line 14260 ""
				i__3[1] = 7, a__1[1] = "setclef";
#line 14260 ""
				i__2 = iinow + 48;
#line 14260 ""
				chax_(ch__1, (ftnlen)1, &i__2);
#line 14260 ""
				i__3[2] = 1, a__1[2] = ch__1;
#line 14260 ""
				i__3[3] = lclf, a__1[3] = hdlndq;
#line 14260 ""
				i__3[4] = 1, a__1[4] = "%";
#line 14260 ""
				s_cat(ch__6, a__1, i__3, &c__5, (ftnlen)69);
#line 14260 ""
				do_fio(&c__1, ch__6, lclf + 10);
#line 14260 ""
				e_wsfe();
#line 14262 ""
				if (comfig_1.fullsize[comnvi_1.iiorig[iinow - 
					1] - 1] > .9f) {
#line 14263 ""
				    s_wsfe(&io___830);
/* Writing concatenation */
#line 14263 ""
				    i__3[0] = 1, a__1[0] = all_1.sq;
#line 14263 ""
				    i__3[1] = 7, a__1[1] = "setsize";
#line 14263 ""
				    i__2 = iinow + 48;
#line 14263 ""
				    chax_(ch__1, (ftnlen)1, &i__2);
#line 14263 ""
				    i__3[2] = 1, a__1[2] = ch__1;
#line 14263 ""
				    i__3[3] = 1, a__1[3] = all_1.sq;
#line 14263 ""
				    i__3[4] = 12, a__1[4] = "normalvalue%";
#line 14263 ""
				    s_cat(ch__7, a__1, i__3, &c__5, (ftnlen)
					    22);
#line 14263 ""
				    do_fio(&c__1, ch__7, (ftnlen)22);
#line 14263 ""
				    e_wsfe();

/* 140526 Account for staff size specs when noinst changes. May be confusion */
/*   here if more than one staff per instrument */

#line 14269 ""
				} else if (comfig_1.fullsize[comnvi_1.iiorig[
					iinow - 1] - 1] > .7f) {
#line 14270 ""
				    s_wsfe(&io___831);
/* Writing concatenation */
#line 14270 ""
				    i__3[0] = 1, a__1[0] = all_1.sq;
#line 14270 ""
				    i__3[1] = 7, a__1[1] = "setsize";
#line 14270 ""
				    i__2 = iinow + 48;
#line 14270 ""
				    chax_(ch__1, (ftnlen)1, &i__2);
#line 14270 ""
				    i__3[2] = 1, a__1[2] = ch__1;
#line 14270 ""
				    i__3[3] = 1, a__1[3] = all_1.sq;
#line 14270 ""
				    i__3[4] = 11, a__1[4] = "smallvalue%";
#line 14270 ""
				    s_cat(ch__8, a__1, i__3, &c__5, (ftnlen)
					    21);
#line 14270 ""
				    do_fio(&c__1, ch__8, (ftnlen)21);
#line 14270 ""
				    e_wsfe();
#line 14272 ""
				} else {
#line 14273 ""
				    s_wsfe(&io___832);
/* Writing concatenation */
#line 14273 ""
				    i__3[0] = 1, a__1[0] = all_1.sq;
#line 14273 ""
				    i__3[1] = 7, a__1[1] = "setsize";
#line 14273 ""
				    i__2 = iinow + 48;
#line 14273 ""
				    chax_(ch__1, (ftnlen)1, &i__2);
#line 14273 ""
				    i__3[2] = 1, a__1[2] = ch__1;
#line 14273 ""
				    i__3[3] = 1, a__1[3] = all_1.sq;
#line 14273 ""
				    i__3[4] = 10, a__1[4] = "tinyvalue%";
#line 14273 ""
				    s_cat(ch__9, a__1, i__3, &c__5, (ftnlen)
					    20);
#line 14273 ""
				    do_fio(&c__1, ch__9, (ftnlen)20);
#line 14273 ""
				    e_wsfe();
#line 14275 ""
				}
#line 14276 ""
			    } else {
#line 14277 ""
				s_wsfe(&io___833);
/* Writing concatenation */
#line 14277 ""
				i__5[0] = 1, a__2[0] = all_1.sq;
#line 14277 ""
				i__5[1] = 10, a__2[1] = "setstaffs{";
#line 14277 ""
				s_cat(ch__10, a__2, i__5, &c__2, (ftnlen)11);
#line 14277 ""
				do_fio(&c__1, ch__10, (ftnlen)11);
#line 14277 ""
				do_fio(&c__1, (char *)&iinow, (ftnlen)sizeof(
					integer));
/* Writing concatenation */
#line 14277 ""
				i__6[0] = 1, a__3[0] = "}";
#line 14277 ""
				i__2 = comnvi_1.nspern[iinow - 1] + 48;
#line 14277 ""
				chax_(ch__1, (ftnlen)1, &i__2);
#line 14277 ""
				i__6[1] = 1, a__3[1] = ch__1;
#line 14277 ""
				i__6[2] = 1, a__3[2] = "%";
#line 14277 ""
				s_cat(ch__11, a__3, i__6, &c__3, (ftnlen)3);
#line 14277 ""
				do_fio(&c__1, ch__11, (ftnlen)3);
#line 14277 ""
				e_wsfe();
#line 14279 ""
				s_wsfe(&io___834);
/* Writing concatenation */
#line 14279 ""
				i__5[0] = 1, a__2[0] = all_1.sq;
#line 14279 ""
				i__5[1] = 8, a__2[1] = "setclef{";
#line 14279 ""
				s_cat(ch__12, a__2, i__5, &c__2, (ftnlen)9);
#line 14279 ""
				do_fio(&c__1, ch__12, (ftnlen)9);
#line 14279 ""
				do_fio(&c__1, (char *)&iinow, (ftnlen)sizeof(
					integer));
/* Writing concatenation */
#line 14279 ""
				i__6[0] = 1, a__3[0] = "}";
#line 14279 ""
				i__6[1] = lclf, a__3[1] = hdlndq;
#line 14279 ""
				i__6[2] = 1, a__3[2] = "%";
#line 14279 ""
				s_cat(ch__13, a__3, i__6, &c__3, (ftnlen)61);
#line 14279 ""
				do_fio(&c__1, ch__13, lclf + 2);
#line 14279 ""
				e_wsfe();
#line 14281 ""
			    }
#line 14282 ""
			}
#line 14283 ""
/* L60: */
#line 14283 ""
		    }

/*  Loop back up, this may not be last option in M.  Note flow out if durq=' ' */

#line 14287 ""
		    getchar_(lineq, &all_1.iccount, durq, (ftnlen)128, (
			    ftnlen)1);
#line 14288 ""
		    goto L31;
#line 14289 ""
		} else if (*(unsigned char *)durq == 'S') {
#line 14290 ""
		    goto L48;
#line 14291 ""
		}

/*  Write instrument names */

#line 14295 ""
		if (! comnvi_1.rename) {
#line 14296 ""
		    i__1 = comnotes_1.ninow;
#line 14296 ""
		    for (iinst = 1; iinst <= i__1; ++iinst) {
#line 14297 ""
			if (comlast_1.islast) {
#line 14298 ""
			    if (iinst < 10) {
#line 14299 ""
				s_wsfe(&io___836);
/* Writing concatenation */
#line 14299 ""
				i__5[0] = 1, a__2[0] = all_1.sq;
#line 14299 ""
				i__5[1] = 7, a__2[1] = "setname";
#line 14299 ""
				s_cat(ch__14, a__2, i__5, &c__2, (ftnlen)8);
#line 14299 ""
				do_fio(&c__1, ch__14, (ftnlen)8);
#line 14299 ""
				do_fio(&c__1, (char *)&iinst, (ftnlen)sizeof(
					integer));
#line 14299 ""
				do_fio(&c__1, "{}%", (ftnlen)3);
#line 14299 ""
				e_wsfe();
#line 14300 ""
			    } else {
#line 14301 ""
				s_wsfe(&io___837);
/* Writing concatenation */
#line 14301 ""
				i__5[0] = 1, a__2[0] = all_1.sq;
#line 14301 ""
				i__5[1] = 8, a__2[1] = "setname{";
#line 14301 ""
				s_cat(ch__12, a__2, i__5, &c__2, (ftnlen)9);
#line 14301 ""
				do_fio(&c__1, ch__12, (ftnlen)9);
#line 14301 ""
				do_fio(&c__1, (char *)&iinst, (ftnlen)sizeof(
					integer));
#line 14301 ""
				do_fio(&c__1, "}{}%", (ftnlen)4);
#line 14301 ""
				e_wsfe();
#line 14302 ""
			    }
#line 14303 ""
			}
#line 14304 ""
/* L62: */
#line 14304 ""
		    }
#line 14305 ""
		} else {
#line 14306 ""
		    i__1 = comnotes_1.ninow;
#line 14306 ""
		    for (iinst = 1; iinst <= i__1; ++iinst) {
#line 14307 ""
			if (comlast_1.islast) {
#line 14308 ""
			    if (iinst < 10) {
#line 14309 ""
				s_wsfe(&io___838);
/* Writing concatenation */
#line 14309 ""
				i__5[0] = 1, a__2[0] = all_1.sq;
#line 14309 ""
				i__5[1] = 7, a__2[1] = "setname";
#line 14309 ""
				s_cat(ch__14, a__2, i__5, &c__2, (ftnlen)8);
#line 14309 ""
				do_fio(&c__1, ch__14, (ftnlen)8);
#line 14309 ""
				do_fio(&c__1, (char *)&iinst, (ftnlen)sizeof(
					integer));
/* Writing concatenation */
#line 14309 ""
				i__6[0] = 1, a__3[0] = "{";
#line 14309 ""
				i__6[1] = comtop_1.lnam[comnvi_1.iiorig[iinst 
					- 1] - 1], a__3[1] = comtop_1.inameq 
					+ (comnvi_1.iiorig[iinst - 1] - 1) * 
					79;
#line 14309 ""
				i__6[2] = 2, a__3[2] = "}%";
#line 14309 ""
				s_cat(ch__15, a__3, i__6, &c__3, (ftnlen)82);
#line 14309 ""
				do_fio(&c__1, ch__15, comtop_1.lnam[
					comnvi_1.iiorig[iinst - 1] - 1] + 3);
#line 14309 ""
				e_wsfe();
#line 14311 ""
			    } else {
#line 14312 ""
				s_wsfe(&io___839);
/* Writing concatenation */
#line 14312 ""
				i__5[0] = 1, a__2[0] = all_1.sq;
#line 14312 ""
				i__5[1] = 8, a__2[1] = "setname{";
#line 14312 ""
				s_cat(ch__12, a__2, i__5, &c__2, (ftnlen)9);
#line 14312 ""
				do_fio(&c__1, ch__12, (ftnlen)9);
#line 14312 ""
				do_fio(&c__1, (char *)&iinst, (ftnlen)sizeof(
					integer));
/* Writing concatenation */
#line 14312 ""
				i__6[0] = 2, a__3[0] = "}{";
#line 14312 ""
				i__6[1] = comtop_1.lnam[comnvi_1.iiorig[iinst 
					- 1] - 1], a__3[1] = comtop_1.inameq 
					+ (comnvi_1.iiorig[iinst - 1] - 1) * 
					79;
#line 14312 ""
				i__6[2] = 2, a__3[2] = "}%";
#line 14312 ""
				s_cat(ch__16, a__3, i__6, &c__3, (ftnlen)83);
#line 14312 ""
				do_fio(&c__1, ch__16, comtop_1.lnam[
					comnvi_1.iiorig[iinst - 1] - 1] + 4);
#line 14312 ""
				e_wsfe();
#line 14314 ""
			    }
#line 14315 ""
			}
#line 14316 ""
/* L65: */
#line 14316 ""
		    }
#line 14317 ""
		    if (comshort_1.ishort != 4 && comshort_1.ishort != 2) {
#line 14317 ""
			comnvi_1.rename = FALSE_;
#line 14317 ""
		    }

/* Reset later and rewrite setname{} in shortening case mcm, since if */
/* written here it will be inside {{...}} and will be ignored */

#line 14322 ""
		}
#line 14323 ""
	    }
#line 14324 ""
	} else if (*(unsigned char *)charq == '|') {

/*  End of bar symbol.  Check about end of bar hardspace. */

#line 14328 ""
	    if (bit_test(all_1.iornq[commvl_1.ivx + (all_1.nnl[commvl_1.ivx - 
		    1] + 1) * 24 - 1],26)) {

/*  There was a hardspace followed by a bar line.  Remove it from the hardspace */
/*  list, store with shifts instead, set special bit.  Need to repeat this code */
/*  at '/'. */

#line 14334 ""
		all_1.irest[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 24 - 
			25] = bit_set(all_1.irest[commvl_1.ivx + all_1.nnl[
			commvl_1.ivx - 1] * 24 - 25],18);
#line 14335 ""
		++comudsp_1.nudoff[commvl_1.ivx - 1];
#line 14336 ""
		comudsp_1.udoff[commvl_1.ivx + comudsp_1.nudoff[commvl_1.ivx 
			- 1] * 24 - 25] = comudsp_1.udsp[comudsp_1.nudsp - 1];
#line 14337 ""
		--comudsp_1.nudsp;
#line 14338 ""
		all_1.iornq[commvl_1.ivx + (all_1.nnl[commvl_1.ivx - 1] + 1) *
			 24 - 1] = bit_clear(all_1.iornq[commvl_1.ivx + (
			all_1.nnl[commvl_1.ivx - 1] + 1) * 24 - 1],26);
#line 14339 ""
	    }
#line 14340 ""
	} else if (i_indx("wS", charq, (ftnlen)2, (ftnlen)1) > 0) {

/*  Width symbol or new nsyst.  Read past (until blank) */

#line 14344 ""
L4:
#line 14344 ""
	    getchar_(lineq, &all_1.iccount, durq, (ftnlen)128, (ftnlen)1);
#line 14345 ""
	    if (*(unsigned char *)durq != ' ') {
#line 14345 ""
		goto L4;
#line 14345 ""
	    }
#line 14346 ""
	} else if (*(unsigned char *)charq == 'l') {

/*  Lower string.  Only OK if at start of block */
/*  Check whether at beginning of a block */

#line 14351 ""
	    if (all_1.iv != 1 || all_1.nnl[0] != 0) {
#line 14352 ""
		s_wsle(&io___840);
#line 14352 ""
		do_lio(&c__9, &c__1, "You entered \"l\" not at beginning of "\
			"block", (ftnlen)41);
#line 14352 ""
		e_wsle();
#line 14353 ""
		stop1_();
#line 14354 ""
	    }

/*  Set flag for lower string & read it in */

#line 14358 ""
	    comhead_1.lower = TRUE_;
#line 14359 ""
	    getbuf_(comhead_1.lowerq, (ftnlen)80);
#line 14360 ""
	    all_1.iccount = 128;
#line 14361 ""
	} else if (*(unsigned char *)charq == 'm') {

/*  Meter change.  Only allow at beginning of block. */
/*    mtrnuml, mtrdenl (logical) and p (printable) will be input. */
/*    mtrnuml=0 initially. (In common) */

/*  Check whether at beginning of a block */

#line 14369 ""
	    if (all_1.iv != 1 || all_1.nnl[0] != 0) {
#line 14370 ""
		s_wsle(&io___841);
#line 14370 ""
		do_lio(&c__9, &c__1, "You entered \"m\" not at beginning of "\
			"block", (ftnlen)41);
#line 14370 ""
		e_wsle();
#line 14371 ""
		stop1_();
#line 14372 ""
	    }
#line 14373 ""
	    readmeter_(lineq, &all_1.iccount, &all_1.mtrnuml, &all_1.mtrdenl, 
		    (ftnlen)128);
#line 14374 ""
	    readmeter_(lineq, &all_1.iccount, &all_1.mtrnmp, &all_1.mtrdnp, (
		    ftnlen)128);
#line 14375 ""
	    lenbeat = ifnodur_(&all_1.mtrdenl, "x", (ftnlen)1);
#line 14376 ""
	    if (all_1.mtrdenl == 2) {
#line 14376 ""
		lenbeat = 16;
#line 14376 ""
	    }
#line 14377 ""
	    all_1.lenbar = all_1.mtrnuml * lenbeat;
#line 14378 ""
	    if (all_1.mtrdenl == 2) {
#line 14378 ""
		all_1.lenbar <<= 1;
#line 14378 ""
	    }
#line 14379 ""
	    all_1.lenb1 = all_1.lenbar;
#line 14380 ""
	    all_1.lenb0 = 0;
#line 14381 ""
	    if (commidi_1.ismidi) {
#line 14381 ""
		midievent_("m", &all_1.mtrnuml, &all_1.mtrdenl, (ftnlen)1);
#line 14381 ""
	    }
#line 14382 ""
	} else if (*(unsigned char *)charq == 'C') {

/*  Clef change on next note.  Set bits 11-15.  Won't allow in 2nd line of music. */

#line 14386 ""
	    if (all_1.nnl[all_1.iv - 1] > 0) {
#line 14386 ""
		++comcc_1.ncc[all_1.iv - 1];
#line 14386 ""
	    }
#line 14387 ""
	    comcc_1.tcc[all_1.iv + comcc_1.ncc[all_1.iv - 1] * 24 - 25] = (
		    real) all_1.itsofar[all_1.iv - 1];
#line 14388 ""
	    isl = bit_set(all_1.islur[all_1.iv + (all_1.nnl[all_1.iv - 1] + 1)
		     * 24 - 25],11);
#line 14389 ""
	    getchar_(lineq, &all_1.iccount, durq, (ftnlen)128, (ftnlen)1);

/*  Store clef number, or 7 if clef number = 9 (French violin clef) */

/* Computing MIN */
#line 14393 ""
	    i__1 = numclef_(durq, (ftnlen)1);
#line 14393 ""
	    isl |= min(i__1,7) << 12;
#line 14394 ""
	    comcc_1.ncmidcc[all_1.iv + comcc_1.ncc[all_1.iv - 1] * 24 - 25] = 
		    ncmidf_(durq, (ftnlen)1);
#line 14395 ""
	    if (*(unsigned char *)durq == '8') {
#line 14396 ""
		all_1.ipl[all_1.iv + (all_1.nnl[all_1.iv - 1] + 1) * 24 - 25] 
			= bit_set(all_1.ipl[all_1.iv + (all_1.nnl[all_1.iv - 
			1] + 1) * 24 - 25],2);
#line 14397 ""
		cominsttrans_1.itransamt[cominsttrans_1.instno[all_1.iv - 1] 
			- 1] += 7;
#line 14398 ""
		comnotes_1.lastlev += 7;
#line 14399 ""
		if (all_1.nnl[all_1.iv - 1] == 0) {
#line 14400 ""
		    comnotes_1.ndlev[all_1.iv - 1] += 7;
#line 14401 ""
		    comnotes_1.ndlev[all_1.iv + 23] += 7;
#line 14402 ""
		}
#line 14403 ""
	    } else {

/*  This won't work if you really had an octave transposition with some */
/*  other clef. Need a check on whether prior clef was an octave clef. */

#line 14408 ""
		if (cominsttrans_1.itransamt[cominsttrans_1.instno[all_1.iv - 
			1] - 1] == 7) {
#line 14409 ""
		    cominsttrans_1.itransamt[cominsttrans_1.instno[all_1.iv - 
			    1] - 1] += -7;
#line 14410 ""
		    comnotes_1.lastlev += -7;
#line 14411 ""
		    if (all_1.nnl[all_1.iv - 1] == 0) {
#line 14412 ""
			comnotes_1.ndlev[all_1.iv - 1] += -7;
#line 14413 ""
			comnotes_1.ndlev[all_1.iv + 23] += -7;
#line 14414 ""
		    }
#line 14415 ""
		}
#line 14416 ""
	    }

/*  Set marker on note with lowest voice # starting at same time. */

#line 14420 ""
	    if (all_1.iv == 1) {
#line 14421 ""
		isl = bit_set(isl,15);
#line 14422 ""
	    } else {
#line 14423 ""
		i__1 = all_1.iv;
#line 14423 ""
		for (iiv = 1; iiv <= i__1; ++iiv) {
#line 14424 ""
		    nnliiv = all_1.nnl[iiv - 1];
#line 14425 ""
		    if (iiv == all_1.iv) {
#line 14425 ""
			++nnliiv;
#line 14425 ""
		    }
#line 14426 ""
		    itother = 0;
#line 14427 ""
		    i__2 = nnliiv;
#line 14427 ""
		    for (iip = 1; iip <= i__2; ++iip) {
#line 14428 ""
			if (itother < all_1.itsofar[all_1.iv - 1]) {
#line 14429 ""
			    itother += all_1.nodur[iiv + iip * 24 - 25];
#line 14430 ""
			    goto L14;
#line 14431 ""
			} else if (itother == all_1.itsofar[all_1.iv - 1]) {
#line 14432 ""
			    all_1.islur[iiv + iip * 24 - 25] = bit_set(
				    all_1.islur[iiv + iip * 24 - 25],15);
#line 14433 ""
			    goto L15;
#line 14434 ""
			}
#line 14435 ""
L14:
#line 14435 ""
			;
#line 14435 ""
		    }
#line 14436 ""
/* L13: */
#line 14436 ""
		}
#line 14437 ""
L15:
#line 14438 ""
		;
#line 14438 ""
	    }

/*  Need 'or' since may have set bit 15 in the above loop */

#line 14442 ""
	    all_1.islur[all_1.iv + (all_1.nnl[all_1.iv - 1] + 1) * 24 - 25] = 
		    isl | all_1.islur[all_1.iv + (all_1.nnl[all_1.iv - 1] + 1)
		     * 24 - 25];
#line 14443 ""
	} else if (*(unsigned char *)charq == 'R') {

/*  Repeats.  set bits 5, 6, and/or 8 of islur(1,ip+1) */

#line 14447 ""
L10:
#line 14447 ""
	    getchar_(lineq, &all_1.iccount, durq, (ftnlen)128, (ftnlen)1);

/*  Save designator in case it's a terminal Rr or Rd */

#line 14451 ""
	    if (*(unsigned char *)durq == 'l') {
#line 14452 ""
		all_1.islur[(all_1.nnl[0] + 1) * 24 - 24] = bit_set(
			all_1.islur[(all_1.nnl[0] + 1) * 24 - 24],5);
#line 14453 ""
		goto L10;
#line 14454 ""
	    } else if (i_indx("rdDbz", durq, (ftnlen)5, (ftnlen)1) > 0) {
#line 14455 ""
		if (*(unsigned char *)durq == 'r') {
#line 14456 ""
		    all_1.islur[(all_1.nnl[0] + 1) * 24 - 24] = bit_set(
			    all_1.islur[(all_1.nnl[0] + 1) * 24 - 24],6);
#line 14457 ""
		} else if (*(unsigned char *)durq == 'd') {
#line 14458 ""
		    all_1.islur[(all_1.nnl[0] + 1) * 24 - 24] = bit_set(
			    all_1.islur[(all_1.nnl[0] + 1) * 24 - 24],8);
#line 14459 ""
		} else if (*(unsigned char *)durq == 'D') {
#line 14460 ""
		    all_1.islur[(all_1.nnl[0] + 1) * 24 - 24] = bit_set(
			    all_1.islur[(all_1.nnl[0] + 1) * 24 - 24],26);
#line 14461 ""
		} else if (*(unsigned char *)durq == 'b') {
#line 14462 ""
		    all_1.islur[(all_1.nnl[0] + 1) * 24 - 24] = bit_set(
			    all_1.islur[(all_1.nnl[0] + 1) * 24 - 24],25);
#line 14463 ""
		} else if (*(unsigned char *)durq == 'z') {
/*            iornq(1,nnl(1)+1) = ibset(iornq(1,nnl(1)+1),29) */
#line 14465 ""
		    all_1.ipl[(all_1.nnl[0] + 1) * 24 - 24] = bit_set(
			    all_1.ipl[(all_1.nnl[0] + 1) * 24 - 24],0);
#line 14466 ""
		}
#line 14467 ""
		comget_1.rptprev = TRUE_;
#line 14468 ""
		*(unsigned char *)comget_1.rptfq1 = *(unsigned char *)durq;
#line 14469 ""
		goto L10;
#line 14470 ""
	    }
#line 14471 ""
	} else if (*(unsigned char *)charq == 'V') {

/*  Ending */

#line 14475 ""
	    nnnl = all_1.nnl[0] + 1;
#line 14476 ""
	    lvoltxt = 0;
#line 14477 ""
L11:
#line 14477 ""
	    getchar_(lineq, &all_1.iccount, durq, (ftnlen)128, (ftnlen)1);
#line 14478 ""
	    if (*(unsigned char *)durq == 'b' || *(unsigned char *)durq == 
		    'x') {

/*  End Volta, set bit9, and bit10 on if 'b' (end w/ box) */

#line 14482 ""
		all_1.islur[nnnl * 24 - 24] = bit_set(all_1.islur[nnnl * 24 - 
			24],9);
#line 14483 ""
		if (*(unsigned char *)durq == 'b') {
#line 14483 ""
		    all_1.islur[nnnl * 24 - 24] = bit_set(all_1.islur[nnnl * 
			    24 - 24],10);
#line 14483 ""
		}
#line 14484 ""
		goto L11;
#line 14485 ""
	    } else if (*(unsigned char *)durq != ' ') {

/*  Start volta; Get text */

#line 14489 ""
		if (lvoltxt == 0) {

/*  First character for text */

#line 14493 ""
		    lvoltxt = 1;
#line 14494 ""
		    all_1.islur[nnnl * 24 - 24] = bit_set(all_1.islur[nnnl * 
			    24 - 24],7);
#line 14495 ""
		    ++comgrace_1.nvolt;
#line 14496 ""
		    s_copy(comgrace_1.voltxtq + (comgrace_1.nvolt - 1) * 20, 
			    durq, (ftnlen)20, (ftnlen)1);
#line 14497 ""
		} else {
/* Writing concatenation */
#line 14498 ""
		    i__5[0] = lvoltxt, a__2[0] = comgrace_1.voltxtq + (
			    comgrace_1.nvolt - 1) * 20;
#line 14498 ""
		    i__5[1] = 1, a__2[1] = durq;
#line 14498 ""
		    s_cat(comgrace_1.voltxtq + (comgrace_1.nvolt - 1) * 20, 
			    a__2, i__5, &c__2, (ftnlen)20);
#line 14499 ""
		    ++lvoltxt;
#line 14500 ""
		}
#line 14501 ""
		goto L11;
#line 14502 ""
	    }
#line 14503 ""
	} else if (*(unsigned char *)charq == 'B') {
#line 14504 ""
	    combc_1.bcspec = ! combc_1.bcspec;
#line 14505 ""
	} else if (*(unsigned char *)charq == 'P') {

/*  Page numbers.  Print stuff right now. */

#line 14509 ""
	    npg1 = 0;

/*  Will use ltopnam to signal whether there's a centered heading */

#line 14513 ""
	    ltopnam = 0;
#line 14514 ""
	    ipg1r = 0;
#line 14515 ""
L16:
#line 14515 ""
	    getchar_(lineq, &all_1.iccount, durq, (ftnlen)128, (ftnlen)1);
#line 14516 ""
	    if (*(unsigned char *)durq >= 48 && *(unsigned char *)durq <= 57) 
		    {
#line 14517 ""
		npg1 = npg1 * 10 + *(unsigned char *)durq - 48;
#line 14518 ""
		goto L16;
#line 14519 ""
	    } else if (*(unsigned char *)durq == 'l') {
#line 14520 ""
		if (npg1 == 0 || npg1 % 2 == 1) {
#line 14520 ""
		    ipg1r = 1;
#line 14520 ""
		}
#line 14521 ""
		goto L16;
#line 14522 ""
	    } else if (*(unsigned char *)durq == 'r') {
#line 14523 ""
		if (npg1 > 0 && npg1 % 2 == 0) {
#line 14523 ""
		    ipg1r = 1;
#line 14523 ""
		}
#line 14524 ""
		goto L16;
#line 14525 ""
	    } else if (*(unsigned char *)durq == 'c') {

/*  Top-centered name.  Assume this is last option.  Read the name. */
/*  May surround name in double quotes (to allow blanks). */

#line 14530 ""
		getchar_(lineq, &all_1.iccount, durq, (ftnlen)128, (ftnlen)1);
#line 14531 ""
		if (*(unsigned char *)durq == ' ') {
#line 14532 ""
		    ltopnam = lenstr_(comtrans_1.cheadq, &c__60, (ftnlen)60);
#line 14533 ""
		} else {
#line 14534 ""
		    namstrt = all_1.iccount;
#line 14535 ""
		    chax_(ch__1, (ftnlen)1, &c__34);
#line 14535 ""
		    if (*(unsigned char *)durq == *(unsigned char *)&ch__1[0])
			     {

/*  Using quote delimiters. */

#line 14539 ""
			quoted = TRUE_;
#line 14540 ""
			++namstrt;
#line 14541 ""
		    } else {
#line 14542 ""
			quoted = FALSE_;
#line 14543 ""
		    }
#line 14544 ""
		    for (all_1.iccount = namstrt + 1; all_1.iccount <= 128; 
			    ++all_1.iccount) {
#line 14545 ""
			i__1 = all_1.iccount - 2;
#line 14545 ""
			chax_(ch__1, (ftnlen)1, &c__34);
#line 14545 ""
			chax_(ch__5, (ftnlen)1, &c__92);
#line 14545 ""
			if (quoted && *(unsigned char *)&lineq[all_1.iccount 
				- 1] == *(unsigned char *)&ch__1[0] && s_cmp(
				lineq + i__1, ch__5, all_1.iccount - 1 - i__1,
				 (ftnlen)1) != 0 || ! quoted && *(unsigned 
				char *)&lineq[all_1.iccount - 1] == ' ') {
#line 14545 ""
			    goto L36;
#line 14545 ""
			}

/*  On exit, iccount is OK, and name is in (namstrt:iccount-1) */

#line 14552 ""
/* L35: */
#line 14552 ""
		    }
#line 14553 ""
		    s_wsle(&io___850);
#line 14553 ""
		    do_lio(&c__9, &c__1, "Awww, cmon, should not be here.", (
			    ftnlen)31);
#line 14553 ""
		    e_wsle();
#line 14554 ""
		    stop1_();
#line 14555 ""
L36:
#line 14556 ""
		    ltopnam = all_1.iccount - namstrt;
#line 14557 ""
		    s_copy(comtrans_1.cheadq, lineq + (namstrt - 1), (ftnlen)
			    60, all_1.iccount - 1 - (namstrt - 1));
#line 14558 ""
		}
#line 14559 ""
	    }

/*  Done getting data, now assemble the command */

#line 14563 ""
	    if (npg1 == 0) {
#line 14563 ""
		npg1 = 1;
#line 14563 ""
	    }

/*  2/23/03 Don't use \atnextline if on first page and only one system */

/* Writing concatenation */
#line 14567 ""
	    i__7[0] = 1, a__4[0] = all_1.sq;
#line 14567 ""
	    i__7[1] = 3, a__4[1] = "def";
#line 14567 ""
	    i__7[2] = 1, a__4[2] = all_1.sq;
#line 14567 ""
	    i__7[3] = 11, a__4[3] = "atnextline{";
#line 14567 ""
	    i__7[4] = 1, a__4[4] = all_1.sq;
#line 14567 ""
	    i__7[5] = 10, a__4[5] = "toppageno{";
#line 14567 ""
	    s_cat(hdlndq, a__4, i__7, &c__6, (ftnlen)59);
#line 14568 ""
	    lhead = 27;
#line 14569 ""
	    if (npg1 < 10) {

/*  Note we are overwriting the last "{" */

#line 14573 ""
		ici__1.icierr = 0;
#line 14573 ""
		ici__1.icirnum = 1;
#line 14573 ""
		ici__1.icirlen = 1;
#line 14573 ""
		ici__1.iciunit = hdlndq + (lhead - 1);
#line 14573 ""
		ici__1.icifmt = "(i1)";
#line 14573 ""
		s_wsfi(&ici__1);
#line 14573 ""
		do_fio(&c__1, (char *)&npg1, (ftnlen)sizeof(integer));
#line 14573 ""
		e_wsfi();
#line 14574 ""
	    } else if (npg1 < 100) {
#line 14575 ""
		lhead += 3;
#line 14576 ""
		i__1 = lhead - 3;
#line 14576 ""
		ici__1.icierr = 0;
#line 14576 ""
		ici__1.icirnum = 1;
#line 14576 ""
		ici__1.icirlen = lhead - i__1;
#line 14576 ""
		ici__1.iciunit = hdlndq + i__1;
#line 14576 ""
		ici__1.icifmt = "(i2,a1)";
#line 14576 ""
		s_wsfi(&ici__1);
#line 14576 ""
		do_fio(&c__1, (char *)&npg1, (ftnlen)sizeof(integer));
#line 14576 ""
		do_fio(&c__1, "}", (ftnlen)1);
#line 14576 ""
		e_wsfi();
#line 14577 ""
	    } else {
#line 14578 ""
		lhead += 4;
#line 14579 ""
		i__1 = lhead - 4;
#line 14579 ""
		ici__1.icierr = 0;
#line 14579 ""
		ici__1.icirnum = 1;
#line 14579 ""
		ici__1.icirlen = lhead - i__1;
#line 14579 ""
		ici__1.iciunit = hdlndq + i__1;
#line 14579 ""
		ici__1.icifmt = "(i3,a1)";
#line 14579 ""
		s_wsfi(&ici__1);
#line 14579 ""
		do_fio(&c__1, (char *)&npg1, (ftnlen)sizeof(integer));
#line 14579 ""
		do_fio(&c__1, "}", (ftnlen)1);
#line 14579 ""
		e_wsfi();
#line 14580 ""
	    }
/* Writing concatenation */
#line 14581 ""
	    i__6[0] = lhead, a__3[0] = hdlndq;
#line 14581 ""
	    i__1 = ipg1r + 48;
#line 14581 ""
	    chax_(ch__1, (ftnlen)1, &i__1);
#line 14581 ""
	    i__6[1] = 1, a__3[1] = ch__1;
#line 14581 ""
	    i__6[2] = 1, a__3[2] = "{";
#line 14581 ""
	    s_cat(hdlndq, a__3, i__6, &c__3, (ftnlen)59);
#line 14582 ""
	    lhead += 2;
#line 14583 ""
	    if (ltopnam == 0) {
#line 14584 ""
		if (comlast_1.islast) {
#line 14584 ""
		    s_wsfe(&io___852);
/* Writing concatenation */
#line 14584 ""
		    i__5[0] = lhead, a__2[0] = hdlndq;
#line 14584 ""
		    i__5[1] = 3, a__2[1] = "}}%";
#line 14584 ""
		    s_cat(ch__17, a__2, i__5, &c__2, (ftnlen)62);
#line 14584 ""
		    do_fio(&c__1, ch__17, lhead + 3);
#line 14584 ""
		    e_wsfe();
#line 14584 ""
		}
#line 14585 ""
	    } else {
#line 14586 ""
		if (comlast_1.islast) {
#line 14586 ""
		    s_wsfe(&io___853);
/* Writing concatenation */
#line 14586 ""
		    i__6[0] = lhead, a__3[0] = hdlndq;
#line 14586 ""
		    i__6[1] = ltopnam, a__3[1] = comtrans_1.cheadq;
#line 14586 ""
		    i__6[2] = 3, a__3[2] = "}}%";
#line 14586 ""
		    s_cat(ch__18, a__3, i__6, &c__3, (ftnlen)122);
#line 14586 ""
		    do_fio(&c__1, ch__18, lhead + ltopnam + 3);
#line 14586 ""
		    e_wsfe();
#line 14586 ""
		}
#line 14588 ""
	    }
#line 14589 ""
	} else if (*(unsigned char *)charq == 'W') {

/*  Just eat the number that must follow, it was used in pmxa */

#line 14593 ""
	    ++all_1.iccount;
#line 14594 ""
	    readnum_(lineq, &all_1.iccount, durq, &fnum, (ftnlen)128, (ftnlen)
		    1);
#line 14595 ""
	} else if (*(unsigned char *)charq == 'T') {
#line 14596 ""
	    comtitl_1.headlog = TRUE_;
#line 14597 ""
	    comtitl_1.inhead = 0;
#line 14598 ""
	    getchar_(lineq, &all_1.iccount, durq, (ftnlen)128, (ftnlen)1);
#line 14599 ""
	    if (*(unsigned char *)durq == 'i') {
#line 14600 ""
		getbuf_(comtitl_1.instrq, (ftnlen)120);

/*  A kluge for parts from separate score file for later movements. */

#line 14604 ""
		if (*(unsigned char *)comtitl_1.instrq == ' ') {
#line 14604 ""
		    comtitl_1.headlog = FALSE_;
#line 14604 ""
		}
#line 14605 ""
		s_copy(comtrans_1.cheadq, comtitl_1.instrq, (ftnlen)60, (
			ftnlen)60);
#line 14606 ""
	    } else if (*(unsigned char *)durq == 't') {
#line 14607 ""
		getchar_(lineq, &all_1.iccount, durq, (ftnlen)128, (ftnlen)1);

/*  Optionally can include extra vertical \internotes above inbothd */

#line 14611 ""
		if (i_indx("-+0123456789", durq, (ftnlen)12, (ftnlen)1) > 0) {
#line 14612 ""
		    ipm = 1;
#line 14613 ""
		    if (i_indx("+-", durq, (ftnlen)2, (ftnlen)1) > 0) {

/*  Don't trust readnum to round this negative integer properly */

#line 14617 ""
			++all_1.iccount;
#line 14618 ""
			if (*(unsigned char *)durq == '-') {
#line 14618 ""
			    ipm = -1;
#line 14618 ""
			}
#line 14619 ""
		    }
#line 14620 ""
		    readnum_(lineq, &all_1.iccount, durq, &fnum, (ftnlen)128, 
			    (ftnlen)1);
#line 14621 ""
		    comtitl_1.inhead = ipm * i_nint(&fnum);
#line 14622 ""
		}
#line 14623 ""
		getbuf_(comtitl_1.titleq, (ftnlen)120);
#line 14624 ""
	    } else {
#line 14625 ""
		getbuf_(comtitl_1.compoq, (ftnlen)120);
#line 14626 ""
	    }
#line 14627 ""
	    comtitl_1.inhead += cominbot_1.inbothd;
#line 14628 ""
	    all_1.iccount = 128;
#line 14629 ""
	} else if (*(unsigned char *)charq == 'A') {

/*  Accidental handling etc. */

#line 14633 ""
L27:
#line 14633 ""
	    getchar_(lineq, &all_1.iccount, durq, (ftnlen)128, (ftnlen)1);
#line 14634 ""
	    if (*(unsigned char *)durq == 'r') {
#line 14635 ""
		if (comlast_1.islast) {
#line 14636 ""
		    commidi_1.relacc = TRUE_;
#line 14637 ""
		    s_wsfe(&io___854);
/* Writing concatenation */
#line 14637 ""
		    i__5[0] = 1, a__2[0] = all_1.sq;
#line 14637 ""
		    i__5[1] = 14, a__2[1] = "relativeaccid%";
#line 14637 ""
		    s_cat(ch__19, a__2, i__5, &c__2, (ftnlen)15);
#line 14637 ""
		    do_fio(&c__1, ch__19, (ftnlen)15);
#line 14637 ""
		    e_wsfe();
#line 14638 ""
		}
#line 14639 ""
	    } else if (*(unsigned char *)durq == 's') {
#line 14640 ""
		spfacs_1.bacfac = 1e6f;
#line 14641 ""
	    } else if (*(unsigned char *)durq == 'b') {
#line 14642 ""
		if (comlast_1.islast) {
#line 14642 ""
		    s_wsfe(&io___855);
/* Writing concatenation */
#line 14642 ""
		    i__5[0] = 1, a__2[0] = all_1.sq;
#line 14642 ""
		    i__5[1] = 9, a__2[1] = "bigaccid%";
#line 14642 ""
		    s_cat(ch__3, a__2, i__5, &c__2, (ftnlen)10);
#line 14642 ""
		    do_fio(&c__1, ch__3, (ftnlen)10);
#line 14642 ""
		    e_wsfe();
#line 14642 ""
		}
#line 14643 ""
		spfacs_1.accfac = spfacs_1.bacfac;
#line 14644 ""
	    } else if (*(unsigned char *)durq == 'a') {
#line 14645 ""
		getchar_(lineq, &all_1.iccount, durq, (ftnlen)128, (ftnlen)1);
#line 14646 ""
		readnum_(lineq, &all_1.iccount, durq, &fnum, (ftnlen)128, (
			ftnlen)1);
#line 14647 ""
		--all_1.iccount;
#line 14648 ""
	    } else if (*(unsigned char *)durq == 'i') {
#line 14649 ""
		getchar_(lineq, &all_1.iccount, durq, (ftnlen)128, (ftnlen)1);
#line 14650 ""
		readnum_(lineq, &all_1.iccount, durq, &tintstf, (ftnlen)128, (
			ftnlen)1);
#line 14651 ""
		if (! all_1.firstgulp) {
#line 14651 ""
		    comget_1.fintstf = tintstf;
#line 14651 ""
		}

/*  Local corrections for first page were handled by pmxa */

#line 14655 ""
		--all_1.iccount;
#line 14656 ""
	    } else if (*(unsigned char *)durq == 'I') {
#line 14657 ""
		getchar_(lineq, &all_1.iccount, durq, (ftnlen)128, (ftnlen)1);
#line 14658 ""
		readnum_(lineq, &all_1.iccount, durq, &comget_1.gintstf, (
			ftnlen)128, (ftnlen)1);
#line 14659 ""
		--all_1.iccount;
#line 14660 ""
	    } else if (*(unsigned char *)durq == 'd') {
#line 14661 ""
		comarp_1.lowdot = TRUE_;
#line 14662 ""
	    } else if (*(unsigned char *)durq == 'o') {
#line 14664 ""
	    } else if (*(unsigned char *)durq == 'S') {
#line 14665 ""
		i__1 = comkeys_2.noinst;
#line 14665 ""
		for (iiv = 1; iiv <= i__1; ++iiv) {
#line 14666 ""
		    getchar_(lineq, &all_1.iccount, durq, (ftnlen)128, (
			    ftnlen)1);
#line 14667 ""
		    if (i_indx("-s", durq, (ftnlen)2, (ftnlen)1) > 0) {
#line 14668 ""
			comfig_1.fullsize[iiv - 1] = .8f;
#line 14669 ""
		    } else if (*(unsigned char *)durq == 't') {
#line 14670 ""
			comfig_1.fullsize[iiv - 1] = .64f;
#line 14671 ""
		    } else {
/*              fullsize(ivx) = 1.0 */
#line 14673 ""
			comfig_1.fullsize[iiv - 1] = 1.f;
#line 14674 ""
		    }
#line 14675 ""
/* L50: */
#line 14675 ""
		}
#line 14676 ""
	    } else if (*(unsigned char *)durq == 'e') {

/*  Line-spacing equalization */

#line 14680 ""
		comget_1.equalize = TRUE_;

/*  The following redefinition of \parskip was put into pmx.tex in version 2.25 or so. */
/*    But it causes problems with some older scores and when excerpts are combined */
/*    with LaTeX.  So as of 2.352 we write it here. */

#line 14686 ""
		s_wsfe(&io___857);
/* Writing concatenation */
#line 14686 ""
		i__8[0] = 1, a__5[0] = all_1.sq;
#line 14686 ""
		i__8[1] = 6, a__5[1] = "global";
#line 14686 ""
		i__8[2] = 1, a__5[2] = all_1.sq;
#line 14686 ""
		i__8[3] = 19, a__5[3] = "parskip 0pt plus 12";
#line 14686 ""
		i__8[4] = 1, a__5[4] = all_1.sq;
#line 14686 ""
		i__8[5] = 19, a__5[5] = "Interligne minus 99";
#line 14686 ""
		i__8[6] = 1, a__5[6] = all_1.sq;
#line 14686 ""
		i__8[7] = 11, a__5[7] = "Interligne%";
#line 14686 ""
		s_cat(ch__20, a__5, i__8, &c__8, (ftnlen)59);
#line 14686 ""
		do_fio(&c__1, ch__20, (ftnlen)59);
#line 14686 ""
		e_wsfe();
#line 14688 ""
		s_copy(tempq, all_1.sepsymq, (ftnlen)24, (ftnlen)1);
#line 14689 ""
		lentemp = 1;
#line 14690 ""
		i__1 = all_1.nv - 1;
#line 14690 ""
		for (iiv = 2; iiv <= i__1; ++iiv) {
/* Writing concatenation */
#line 14691 ""
		    i__5[0] = lentemp, a__2[0] = tempq;
#line 14691 ""
		    i__5[1] = 1, a__2[1] = all_1.sepsymq + (iiv - 1);
#line 14691 ""
		    s_cat(tempq, a__2, i__5, &c__2, (ftnlen)24);
#line 14692 ""
		    ++lentemp;
#line 14693 ""
/* L51: */
#line 14693 ""
		}
#line 14694 ""
		s_wsfe(&io___860);
/* Writing concatenation */
#line 14694 ""
		i__9[0] = 1, a__6[0] = all_1.sq;
#line 14694 ""
		i__9[1] = 3, a__6[1] = "def";
#line 14694 ""
		i__9[2] = 1, a__6[2] = all_1.sq;
#line 14694 ""
		i__9[3] = 8, a__6[3] = "upstrut{";
#line 14694 ""
		i__9[4] = 1, a__6[4] = all_1.sq;
#line 14694 ""
		i__9[5] = 6, a__6[5] = "znotes";
#line 14694 ""
		i__9[6] = lentemp, a__6[6] = tempq;
#line 14694 ""
		i__9[7] = 1, a__6[7] = all_1.sq;
#line 14694 ""
		i__9[8] = 10, a__6[8] = "zcharnote{";
#line 14694 ""
		i__9[9] = 1, a__6[9] = all_1.sq;
#line 14694 ""
		i__9[10] = 9, a__6[10] = "upamt}{~}";
#line 14694 ""
		i__9[11] = 1, a__6[11] = all_1.sq;
#line 14694 ""
		i__9[12] = 4, a__6[12] = "en}%";
#line 14694 ""
		s_cat(ch__21, a__6, i__9, &c__13, (ftnlen)70);
#line 14694 ""
		do_fio(&c__1, ch__21, lentemp + 46);
#line 14694 ""
		e_wsfe();
#line 14697 ""
	    } else if (*(unsigned char *)durq == 'v') {

/*  Toggle usevshrink */

#line 14701 ""
		comlast_1.usevshrink = ! comlast_1.usevshrink;
#line 14702 ""
	    } else if (*(unsigned char *)durq == 'p') {

/*  Postscript slurs. fontslur is already false (set in g1etnote) */

#line 14706 ""
		if (! comslur_1.wrotepsslurdefaults) {

/*  Set postscrirpt slur adjustment defaults */

#line 14710 ""
		    s_wsfe(&io___861);
/* Writing concatenation */
#line 14710 ""
		    i__7[0] = 1, a__4[0] = all_1.sq;
#line 14710 ""
		    i__7[1] = 12, a__4[1] = "Nosluradjust";
#line 14710 ""
		    i__7[2] = 1, a__4[2] = all_1.sq;
#line 14710 ""
		    i__7[3] = 11, a__4[3] = "Notieadjust";
#line 14710 ""
		    i__7[4] = 1, a__4[4] = all_1.sq;
#line 14710 ""
		    i__7[5] = 10, a__4[5] = "nohalfties";
#line 14710 ""
		    s_cat(ch__22, a__4, i__7, &c__6, (ftnlen)36);
#line 14710 ""
		    do_fio(&c__1, ch__22, (ftnlen)36);
#line 14710 ""
		    e_wsfe();
#line 14712 ""
		    comslur_1.wrotepsslurdefaults = TRUE_;
#line 14713 ""
		}
#line 14714 ""
L52:
#line 14715 ""
		g1etchar_(lineq, &all_1.iccount, durq, (ftnlen)128, (ftnlen)1)
			;
/* might be "+", "-", "h" or */
#line 14716 ""
		if (i_indx("+-", durq, (ftnlen)2, (ftnlen)1) > 0) {

/*  Characters to change defaults for ps slurs */

#line 14720 ""
		    g1etchar_(lineq, &all_1.iccount, charq, (ftnlen)128, (
			    ftnlen)1);
/* charq will be "s,t,h,c */
#line 14721 ""
		    if (*(unsigned char *)durq == '+') {
#line 14722 ""
			if (*(unsigned char *)charq == 's') {
#line 14723 ""
			    s_wsfe(&io___862);
/* Writing concatenation */
#line 14723 ""
			    i__5[0] = 1, a__2[0] = all_1.sq;
#line 14723 ""
			    i__5[1] = 10, a__2[1] = "Sluradjust";
#line 14723 ""
			    s_cat(ch__10, a__2, i__5, &c__2, (ftnlen)11);
#line 14723 ""
			    do_fio(&c__1, ch__10, (ftnlen)11);
#line 14723 ""
			    e_wsfe();
#line 14724 ""
			} else if (*(unsigned char *)charq == 't') {
#line 14725 ""
			    s_wsfe(&io___863);
/* Writing concatenation */
#line 14725 ""
			    i__5[0] = 1, a__2[0] = all_1.sq;
#line 14725 ""
			    i__5[1] = 9, a__2[1] = "Tieadjust";
#line 14725 ""
			    s_cat(ch__3, a__2, i__5, &c__2, (ftnlen)10);
#line 14725 ""
			    do_fio(&c__1, ch__3, (ftnlen)10);
#line 14725 ""
			    e_wsfe();
#line 14726 ""
			} else if (*(unsigned char *)charq == 'h') {
#line 14727 ""
			    s_wsfe(&io___864);
/* Writing concatenation */
#line 14727 ""
			    i__5[0] = 1, a__2[0] = all_1.sq;
#line 14727 ""
			    i__5[1] = 8, a__2[1] = "halfties";
#line 14727 ""
			    s_cat(ch__12, a__2, i__5, &c__2, (ftnlen)9);
#line 14727 ""
			    do_fio(&c__1, ch__12, (ftnlen)9);
#line 14727 ""
			    e_wsfe();
#line 14728 ""
			} else {
#line 14729 ""
			    comslur_1.slurcurve += 1;
#line 14730 ""
			    if (comslur_1.slurcurve > 3.1f) {
#line 14731 ""
				printl_("WARNING!", (ftnlen)8);
#line 14732 ""
				printl_("Default slur curvature advanced pas"\
					"t HH, resetting", (ftnlen)50);
#line 14734 ""
				comslur_1.slurcurve = 3.f;
#line 14735 ""
			    }
#line 14736 ""
			}
#line 14737 ""
		    } else {
#line 14738 ""
			if (*(unsigned char *)charq == 's') {
#line 14739 ""
			    s_wsfe(&io___865);
/* Writing concatenation */
#line 14739 ""
			    i__5[0] = 1, a__2[0] = all_1.sq;
#line 14739 ""
			    i__5[1] = 12, a__2[1] = "Nosluradjust";
#line 14739 ""
			    s_cat(ch__4, a__2, i__5, &c__2, (ftnlen)13);
#line 14739 ""
			    do_fio(&c__1, ch__4, (ftnlen)13);
#line 14739 ""
			    e_wsfe();
#line 14740 ""
			} else if (*(unsigned char *)charq == 't') {
#line 14741 ""
			    s_wsfe(&io___866);
/* Writing concatenation */
#line 14741 ""
			    i__5[0] = 1, a__2[0] = all_1.sq;
#line 14741 ""
			    i__5[1] = 11, a__2[1] = "Notieadjust";
#line 14741 ""
			    s_cat(ch__2, a__2, i__5, &c__2, (ftnlen)12);
#line 14741 ""
			    do_fio(&c__1, ch__2, (ftnlen)12);
#line 14741 ""
			    e_wsfe();
#line 14742 ""
			} else if (*(unsigned char *)charq == 'h') {
#line 14743 ""
			    s_wsfe(&io___867);
/* Writing concatenation */
#line 14743 ""
			    i__5[0] = 1, a__2[0] = all_1.sq;
#line 14743 ""
			    i__5[1] = 10, a__2[1] = "nohalfties";
#line 14743 ""
			    s_cat(ch__10, a__2, i__5, &c__2, (ftnlen)11);
#line 14743 ""
			    do_fio(&c__1, ch__10, (ftnlen)11);
#line 14743 ""
			    e_wsfe();
#line 14744 ""
			} else {
#line 14745 ""
			    comslur_1.slurcurve += -1;
#line 14746 ""
			    if (comslur_1.slurcurve < -1.1f) {
#line 14747 ""
				printl_("WARNING!", (ftnlen)8);
#line 14748 ""
				printl_("Default slur curvature decremented "\
					"below f, resetting", (ftnlen)53);
#line 14750 ""
				comslur_1.slurcurve = -1.f;
#line 14751 ""
			    }
#line 14752 ""
			}
#line 14753 ""
		    }
#line 14754 ""
		    goto L52;
/* Check for another set of default changes */
#line 14755 ""
		} else if (*(unsigned char *)durq == 'l') {

/*  Set optional linebreak ties */

#line 14759 ""
		    comnotes_1.optlinebreakties = TRUE_;
#line 14760 ""
		    goto L52;
#line 14761 ""
		} else if (*(unsigned char *)durq == 'h') {

/*  Set flag to write header special on every page */

#line 14765 ""
		    comnotes_1.headerspecial = TRUE_;
#line 14766 ""
		    goto L52;
#line 14767 ""
		} else {
#line 14768 ""
		    --all_1.iccount;
#line 14769 ""
		}
#line 14770 ""
	    } else if (*(unsigned char *)durq == 'K') {

/* Toggle keyboard rest placement flag */

#line 14774 ""
		comkbdrests_1.kbdrests = ! comkbdrests_1.kbdrests;
#line 14775 ""
	    } else if (*(unsigned char *)durq == 'c') {
#line 14776 ""
		g1etchar_(lineq, &all_1.iccount, durq, (ftnlen)128, (ftnlen)1)
			;

/* Just eat the input; it was used in pmxa */

#line 14780 ""
		goto L27;
#line 14781 ""
	    } else if (*(unsigned char *)durq == 'V') {
#line 14782 ""
		combottop_1.bottopgap = TRUE_;
#line 14783 ""
		combottop_1.topamt = 0.f;
#line 14784 ""
		getchar_(lineq, &all_1.iccount, durq, (ftnlen)128, (ftnlen)1);
#line 14785 ""
		pmfac = (real) (i_indx("- +", durq, (ftnlen)3, (ftnlen)1) - 2)
			;
#line 14786 ""
		g1etchar_(lineq, &all_1.iccount, durq, (ftnlen)128, (ftnlen)1)
			;
#line 14787 ""
		readnum_(lineq, &all_1.iccount, durq, &combottop_1.botamt, (
			ftnlen)128, (ftnlen)1);
#line 14788 ""
		combottop_1.botamt *= pmfac;
#line 14789 ""
		pmfac = (real) (i_indx("- +", durq, (ftnlen)3, (ftnlen)1) - 2)
			;
#line 14790 ""
		g1etchar_(lineq, &all_1.iccount, durq, (ftnlen)128, (ftnlen)1)
			;
#line 14791 ""
		readnum_(lineq, &all_1.iccount, durq, &combottop_1.topamt, (
			ftnlen)128, (ftnlen)1);
#line 14792 ""
		combottop_1.topamt *= pmfac;
#line 14793 ""
		--all_1.iccount;
#line 14794 ""
		goto L27;
#line 14795 ""
	    }
#line 14796 ""
	    if (i_indx("NR", durq, (ftnlen)2, (ftnlen)1) > 0) {

/*  Override default part names for scor2prt, or normal include file. */
/*  Just bypass rest of input line */

#line 14801 ""
		all_1.iccount = 128;
#line 14802 ""
	    } else if (*(unsigned char *)durq == 'B') {
#line 14803 ""
		comslope_1.bigslope = TRUE_;
#line 14804 ""
		i__1 = all_1.iccount;
#line 14804 ""
		if (s_cmp(lineq + i__1, "f", all_1.iccount + 1 - i__1, (
			ftnlen)1) == 0) {
#line 14805 ""
		    comslope_1.novbm = TRUE_;
#line 14806 ""
		    ++all_1.iccount;
#line 14807 ""
		} else {
#line 14808 ""
		    s_wsfe(&io___869);
/* Writing concatenation */
#line 14808 ""
		    i__5[0] = 1, a__2[0] = all_1.sq;
#line 14808 ""
		    i__5[1] = 14, a__2[1] = "input musixvbm";
#line 14808 ""
		    s_cat(ch__19, a__2, i__5, &c__2, (ftnlen)15);
#line 14808 ""
		    do_fio(&c__1, ch__19, (ftnlen)15);
#line 14808 ""
		    e_wsfe();
#line 14809 ""
		}
#line 14810 ""
		goto L27;
#line 14811 ""
	    } else if (*(unsigned char *)durq != ' ') {
#line 14812 ""
		goto L27;
#line 14813 ""
	    }
#line 14814 ""
	} else if (*(unsigned char *)charq == 'K') {
#line 14815 ""
L77:
#line 14816 ""
	    getchar_(lineq, &all_1.iccount, durq, (ftnlen)128, (ftnlen)1);
#line 14817 ""
	    if (*(unsigned char *)durq == 'n') {
#line 14818 ""
		comignorenats_1.ignorenats = TRUE_;
#line 14819 ""
		goto L77;
#line 14820 ""
	    }
#line 14821 ""
	    if (*(unsigned char *)durq != 'i') {

/* Normal, full-score key change and/or transposition */

#line 14825 ""
		num1 = 44 - *(unsigned char *)durq;
#line 14826 ""
		++all_1.iccount;
#line 14827 ""
		readnum_(lineq, &all_1.iccount, durq, &fnum, (ftnlen)128, (
			ftnlen)1);
#line 14828 ""
		num1 *= i_nint(&fnum);

/*  On exit, durq='+','-'.  But only need isig if after start, else done in pmxa */

#line 14832 ""
		++all_1.iccount;
#line 14833 ""
		readnum_(lineq, &all_1.iccount, charq, &fnum, (ftnlen)128, (
			ftnlen)1);
#line 14834 ""
		if (commidi_1.ismidi) {
#line 14835 ""
		    commidisig_1.midisig = i_nint(&fnum);
#line 14836 ""
		    if (*(unsigned char *)durq == '-') {
#line 14836 ""
			commidisig_1.midisig = -commidisig_1.midisig;
#line 14836 ""
		    }
/* 130317 */
#line 14838 ""
		    commidisig_1.midisig += comtop_1.idsig;
#line 14839 ""
		    midievent_("k", &commidisig_1.midisig, &c__0, (ftnlen)1);
#line 14841 ""
		}
#line 14842 ""
		if (num1 == 0) {

/*  Key change, not transposition. */

#line 14846 ""
		    all_1.ipl[commvl_1.ivx + (all_1.nnl[commvl_1.ivx - 1] + 1)
			     * 24 - 25] = bit_set(all_1.ipl[commvl_1.ivx + (
			    all_1.nnl[commvl_1.ivx - 1] + 1) * 24 - 25],28);
#line 14847 ""
		    comtop_1.lastisig = comtop_1.isig;
#line 14848 ""
		    comtop_1.isig = i_nint(&fnum);
#line 14849 ""
		    if (*(unsigned char *)durq == '-') {
#line 14849 ""
			comtop_1.isig = -comtop_1.isig;
#line 14849 ""
		    }
#line 14850 ""
		    comtop_1.isig += comtop_1.idsig;
#line 14851 ""
		    if (commidi_1.ismidi) {
#line 14851 ""
			midievent_("k", &comtop_1.isig, &c__0, (ftnlen)1);
#line 14851 ""
		    }
#line 14852 ""
		} else {

/*  num1 .ne. 0, so transposition, so must be at beginning.  isig came with K... */
/*  but was passed to pmxb through pmxtex.dat.  isig0 comes from setup data */
/*  (signature before transposition).  idsig must be added to future key changes. */

#line 14858 ""
		    jv = 0;
#line 14859 ""
		    while(jv < 24) {
#line 14860 ""
			++jv;
#line 14861 ""
			cominsttrans_1.itransamt[jv - 1] = num1;
#line 14862 ""
		    }
#line 14863 ""
		    comtop_1.idsig = comtop_1.isig - comtop_1.isig0;
#line 14864 ""
		}
#line 14865 ""
	    } else {

/* Instrument specific transposition. */

#line 14869 ""
		getitransinfo_(&c_false, &combibarcnt_1.ibarcnt, lineq, &
			all_1.iccount, &ibaroff, &all_1.nbars, &
			comkeys_2.noinst, (ftnlen)128);

/*  The sig parameters will have been set 1st time but that's OK */

#line 14874 ""
	    }
#line 14875 ""
	} else /* if(complicated condition) */ {
#line 14875 ""
	    chax_(ch__1, (ftnlen)1, &c__47);
#line 14875 ""
	    if (*(unsigned char *)charq == *(unsigned char *)&ch__1[0]) {
#line 14876 ""
		if (bit_test(all_1.iornq[commvl_1.ivx + (all_1.nnl[
			commvl_1.ivx - 1] + 1) * 24 - 1],26)) {

/*  There was a hardspace followed by end of block.  Remove it from the hardspace */
/*  list, store with shifts instead, set special bit.  This code also at '|' */

#line 14881 ""
		    all_1.irest[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 
			    24 - 25] = bit_set(all_1.irest[commvl_1.ivx + 
			    all_1.nnl[commvl_1.ivx - 1] * 24 - 25],18);
#line 14882 ""
		    ++comudsp_1.nudoff[commvl_1.ivx - 1];
#line 14883 ""
		    comudsp_1.udoff[commvl_1.ivx + comudsp_1.nudoff[
			    commvl_1.ivx - 1] * 24 - 25] = comudsp_1.udsp[
			    comudsp_1.nudsp - 1];
#line 14884 ""
		    --comudsp_1.nudsp;
#line 14885 ""
		    all_1.iornq[commvl_1.ivx + (all_1.nnl[commvl_1.ivx - 1] + 
			    1) * 24 - 1] = bit_clear(all_1.iornq[commvl_1.ivx 
			    + (all_1.nnl[commvl_1.ivx - 1] + 1) * 24 - 1],26);
#line 14886 ""
		}
#line 14887 ""
		getchar_(lineq, &all_1.iccount, durq, (ftnlen)128, (ftnlen)1);

/*  Save ending note level: */

#line 14891 ""
		if (commvl_1.ivx <= all_1.nv) {

/*  This is the first line of music on this staff.  If previous block had only 1 */
/*  voice, save last pitch from line 1 of prev. block to line 2, in case a */
/*  2nd line is started just below */

#line 14897 ""
		    if (! comnotes_1.was2[all_1.iv - 1]) {
#line 14897 ""
			comnotes_1.ndlev[all_1.iv + 23] = comnotes_1.ndlev[
				all_1.iv - 1];
#line 14897 ""
		    }
#line 14898 ""
		    comnotes_1.was2[all_1.iv - 1] = FALSE_;
#line 14899 ""
		    comnotes_1.ndlev[all_1.iv - 1] = comnotes_1.lastlev;
#line 14900 ""
		} else {

/*  This is the 2nd line of music on this staff. */

#line 14904 ""
		    comnotes_1.was2[all_1.iv - 1] = TRUE_;
#line 14905 ""
		    comnotes_1.ndlev[all_1.iv + 23] = comnotes_1.lastlev;
#line 14906 ""
		}
#line 14907 ""
		if (*(unsigned char *)durq == ' ' && all_1.iv == all_1.nv) {

/*  End of input block */

#line 14911 ""
		    *loop = FALSE_;
#line 14912 ""
		} else {

/*  Start a new line of music */

#line 14916 ""
		    if (all_1.lenb0 != 0 && all_1.firstgulp) {
#line 14916 ""
			all_1.lenbar = all_1.lenb0;
#line 14916 ""
		    }
#line 14917 ""
		    all_1.nbars = 0;
#line 14918 ""
		    if (*(unsigned char *)durq == ' ') {

/*  New line of music is on next staff */

#line 14922 ""
			++all_1.iv;
#line 14923 ""
			commvl_1.ivx = all_1.iv;
#line 14924 ""
		    } else {

/*  durq must be 2nd '/'.  New line of music is on same staff.  Set up for it */

#line 14928 ""
			commvl_1.ivx = all_1.nv + 1;
#line 14929 ""
			i__1 = all_1.nv;
#line 14929 ""
			for (iiv = 1; iiv <= i__1; ++iiv) {
#line 14930 ""
			    if (commvl_1.nvmx[iiv - 1] == 2) {
#line 14930 ""
				++commvl_1.ivx;
#line 14930 ""
			    }
#line 14931 ""
/* L23: */
#line 14931 ""
			}
#line 14932 ""
			commvl_1.nvmx[all_1.iv - 1] = 2;
#line 14933 ""
			commvl_1.ivmx[all_1.iv + 23] = commvl_1.ivx;
#line 14934 ""
			all_1.itsofar[commvl_1.ivx - 1] = 0;
#line 14935 ""
			all_1.nnl[commvl_1.ivx - 1] = 0;
#line 14936 ""
			comfb_1.nfb[commvl_1.ivx - 1] = 0;
#line 14937 ""
			comudsp_1.nudoff[commvl_1.ivx - 1] = 0;
#line 14938 ""
			comcc_1.ndotmv[commvl_1.ivx - 1] = 0;
#line 14939 ""
			for (j = 1; j <= 200; ++j) {
#line 14940 ""
			    all_1.irest[commvl_1.ivx + j * 24 - 25] = 0;
#line 14941 ""
			    all_1.islur[commvl_1.ivx + j * 24 - 25] = 0;
#line 14942 ""
			    all_1.nacc[commvl_1.ivx + j * 24 - 25] = 0;
#line 14943 ""
			    all_1.iornq[commvl_1.ivx + j * 24 - 1] = 0;
#line 14944 ""
			    all_1.ipl[commvl_1.ivx + j * 24 - 25] = 0;
#line 14945 ""
			    all_1.mult[commvl_1.ivx + j * 24 - 25] = 0;
#line 14946 ""
/* L24: */
#line 14946 ""
			}

/*  Go back and lower the rests in voice "a" that don't have over-ridden heights */

#line 14950 ""
			i__1 = all_1.nnl[all_1.iv - 1];
#line 14950 ""
			for (j = 1; j <= i__1; ++j) {
#line 14951 ""
			    if (bit_test(all_1.irest[all_1.iv + j * 24 - 25],
				    0) && all_1.nolev[all_1.iv + j * 24 - 25] 
				    == 0) {
#line 14951 ""
				all_1.nolev[all_1.iv + j * 24 - 25] = -4;
#line 14951 ""
			    }
#line 14953 ""
/* L26: */
#line 14953 ""
			}
#line 14954 ""
		    }
#line 14955 ""
		}
#line 14956 ""
		all_1.iccount = 128;
#line 14957 ""
	    } else if (*(unsigned char *)charq == 'X') {

/*  3rd arg is only for termination of group shifts.  Use "max" to avoid zero index, */
/*    which only happens for normal X at block start, and we took special measures to */
/*    keep group shifts for crossing block boundaries. */

/* Computing MAX */
#line 14963 ""
		i__1 = 1, i__2 = all_1.nnl[commvl_1.ivx - 1];
#line 14963 ""
		getx_(lineq, &all_1.iccount, &all_1.irest[commvl_1.ivx + max(
			i__1,i__2) * 24 - 25], &comnotes_1.shifton, &
			comask_1.wheadpt, &all_1.iornq[commvl_1.ivx + (
			all_1.nnl[commvl_1.ivx - 1] + 1) * 24 - 1], &
			commvl_1.ivx, &all_1.irest[commvl_1.ivx + (all_1.nnl[
			commvl_1.ivx - 1] + 1) * 24 - 25], &all_1.itsofar[
			commvl_1.ivx - 1], &c__0, &c__0, &c__0, " ", &ndoub, (
			ftnlen)128, (ftnlen)1);
#line 14966 ""
	    } else if (*(unsigned char *)charq == 'I') {

/*  Midi controls. */

#line 14970 ""
		getmidi_(&comkeys_2.noinst, lineq, &all_1.iccount, &
			combibarcnt_1.ibarcnt, &ibaroff, &all_1.nbars, &
			all_1.lenbar, &all_1.mtrdenl, &all_1.nv, &c_false, (
			ftnlen)128);
#line 14972 ""
	    } else if (*(unsigned char *)charq == 'M') {

/*  Macro action */

#line 14976 ""
		getchar_(lineq, &all_1.iccount, charq, (ftnlen)128, (ftnlen)1)
			;
#line 14977 ""
		if (i_indx("RS", charq, (ftnlen)2, (ftnlen)1) > 0) {

/*  Record or save a macro.  Get the number of the macro. */

#line 14981 ""
		    getchar_(lineq, &all_1.iccount, durq, (ftnlen)128, (
			    ftnlen)1);
#line 14982 ""
		    readnum_(lineq, &all_1.iccount, durq, &fnum, (ftnlen)128, 
			    (ftnlen)1);
#line 14983 ""
		    commac_1.macnum = i_nint(&fnum);
#line 14984 ""
		    commac_1.macuse = bit_set(commac_1.macuse,commac_1.macnum)
			    ;
#line 14985 ""
		    if (*(unsigned char *)charq == 'R') {
#line 14986 ""
			mrec1_(lineq, &all_1.iccount, &ndxm, (ftnlen)128);
#line 14987 ""
		    } else {

/*  Save (Record but don't activate) */

#line 14991 ""
L5:
#line 14991 ""
			mrec1_(lineq, &all_1.iccount, &ndxm, (ftnlen)128);
#line 14992 ""
			if (commac_1.mrecord) {
#line 14993 ""
			    getbuf_(lineq, (ftnlen)128);
#line 14994 ""
			    all_1.iccount = 0;
#line 14995 ""
			    goto L5;
#line 14996 ""
			}
#line 14997 ""
			all_1.iccount = all_1.iccount + ndxm + 1;
#line 14998 ""
		    }
#line 14999 ""
		} else if (*(unsigned char *)charq == 'P') {

/*  Playback the macro */

#line 15003 ""
		    getchar_(lineq, &all_1.iccount, charq, (ftnlen)128, (
			    ftnlen)1);
#line 15004 ""
		    readnum_(lineq, &all_1.iccount, durq, &fnum, (ftnlen)128, 
			    (ftnlen)1);
#line 15005 ""
		    commac_1.macnum = i_nint(&fnum);
#line 15006 ""
		    commac_1.icchold = all_1.iccount;
#line 15007 ""
		    s_copy(commac_1.lnholdq, lineq, (ftnlen)128, (ftnlen)128);
#line 15008 ""
		    all_1.iccount = 128;
#line 15009 ""
		    c1ommac_1.ilmac = c1ommac_1.il1mac[commac_1.macnum - 1];
#line 15010 ""
		    commac_1.mplay = TRUE_;
#line 15011 ""
		}
#line 15012 ""
	    } else if (i_indx(",.", charq, (ftnlen)2, (ftnlen)1) > 0) {

/*  Continued rhythmic shortcut */

#line 15016 ""
		idotform = i_indx(". ,", charq, (ftnlen)3, (ftnlen)1);
#line 15017 ""
		if (idotform == 1) {

/*  Check for start of forced beam on 2nd member of dotform=1 shortcut */

#line 15021 ""
		    if (comget_1.fbon) {
#line 15022 ""
			if (comfb_1.t1fb[commvl_1.ivx + comfb_1.nfb[
				commvl_1.ivx - 1] * 24 - 25] == (real) 
				all_1.itsofar[commvl_1.ivx - 1]) {
#line 15022 ""
			    comfb_1.t1fb[commvl_1.ivx + comfb_1.nfb[
				    commvl_1.ivx - 1] * 24 - 25] += 
				    all_1.nodur[commvl_1.ivx + all_1.nnl[
				    commvl_1.ivx - 1] * 24 - 25] / 2;
#line 15022 ""
			}
#line 15025 ""
		    }

/*  Change duration of prior note */

#line 15029 ""
		    all_1.itsofar[commvl_1.ivx - 1] -= all_1.nodur[
			    commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 24 - 
			    25];
#line 15030 ""
		    all_1.nodur[commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 
			    24 - 25] = all_1.nodur[commvl_1.ivx + all_1.nnl[
			    commvl_1.ivx - 1] * 24 - 25] * 3 / 2;
#line 15031 ""
		    all_1.itsofar[commvl_1.ivx - 1] += all_1.nodur[
			    commvl_1.ivx + all_1.nnl[commvl_1.ivx - 1] * 24 - 
			    25];
#line 15032 ""
		}
#line 15033 ""
		++idotform;
#line 15034 ""
		numnum = 1;
#line 15035 ""
		cdot = TRUE_;
#line 15036 ""
		goto L1;
#line 15037 ""
	    }
#line 15037 ""
	}
#line 15037 ""
    }
#line 15038 ""
    return 0;
} /* getnote_ */

/* Subroutine */ int getorn_(char *lineq, integer *iccount, integer *iornq, 
	integer *iornq0, logical *ornrpt, integer *noffseg, integer *ip, 
	integer *ivx, logical *noxtup, logical *notcrd, integer *nole, ftnlen 
	lineq_len)
{
    /* System generated locals */
    integer i__1;
    real r__1;

    /* Builtin functions */
    integer i_indx(char *, char *, ftnlen, ftnlen), i_nint(real *), s_wsle(
	    cilist *), do_lio(integer *, integer *, char *, ftnlen), e_wsle(
	    void);

    /* Local variables */
    static real fnum;
    static integer korn;
    static char durq[1];
    extern /* Subroutine */ int stop1_(void);
    static char charq[1];
    static integer iorni;
    static logical negseg;
    extern /* Subroutine */ int getchar_(char *, integer *, char *, ftnlen, 
	    ftnlen), readnum_(char *, integer *, char *, real *, ftnlen, 
	    ftnlen);
    static integer iofforn;
    extern /* Subroutine */ int setbits_(integer *, integer *, integer *, 
	    integer *);
    static real xofforn;

    /* Fortran I/O blocks */
    static cilist io___881 = { 0, 6, 0, 0, 0 };



/*  iornq: Main note.  Do not alter if chord note, except turn on bit 23 */
/*  iornq0: Store iorni + bit 23, in case of repeated ornaments */
/*  iorni: Internal use, 1st 21 bits of iornq or icrdorn, dep. on notcrd. */
/*  noffseg: horiz. offset for segno */
/*  nole: level of note w/ orn, used to ID the note/orn if there's a level shift. */


/*  Bits 0-13: (stmgx+Tupf._), 14: Down fermata, was F, 15: Trill w/o "tr", was U */
/*  16-18 Editorial sharp, flat, natural "oes,f,n"; 19-20: >^, 21 ? for ed. accid. */

#line 15062 ""
    getchar_(lineq, iccount, charq, (ftnlen)128, (ftnlen)1);
#line 15063 ""
    if (i_indx("bc", charq, (ftnlen)2, (ftnlen)1) > 0) {

/*  caesura or breath, handle specially and exit. Set up data in ibcdata(1...nbc) */
/*      ivx(0-3,28), ip(4-12), */
/*      vshift (vshift+32 in bits 13-18), */
/*      hshift (nint(10*vshift)+128 in bits 19-26) */
/*      bit 27 = 0 if caesura, 1 if breath */
/*      bit 28: 5th bit of ivx */

#line 15072 ""
	*iornq = bit_set(*iornq,28);
#line 15073 ""
	++comcb_1.nbc;
#line 15074 ""
	comcb_1.ibcdata[comcb_1.nbc - 1] = *ivx % 16 + (*ip << 4);
#line 15075 ""
	if (*ivx >= 16) {
#line 15075 ""
	    comcb_1.ibcdata[comcb_1.nbc - 1] = bit_set(comcb_1.ibcdata[
		    comcb_1.nbc - 1],28);
#line 15075 ""
	}
#line 15076 ""
	if (*(unsigned char *)charq == 'b') {
#line 15076 ""
	    comcb_1.ibcdata[comcb_1.nbc - 1] = bit_set(comcb_1.ibcdata[
		    comcb_1.nbc - 1],27);
#line 15076 ""
	}
#line 15077 ""
	getchar_(lineq, iccount, durq, (ftnlen)128, (ftnlen)1);
#line 15078 ""
	if (i_indx("+-", durq, (ftnlen)2, (ftnlen)1) > 0) {

/*  We have a vertical shift, get it */

#line 15082 ""
	    ++(*iccount);
#line 15083 ""
	    readnum_(lineq, iccount, charq, &fnum, (ftnlen)128, (ftnlen)1);
#line 15084 ""
	    if (*(unsigned char *)durq == '-') {
#line 15084 ""
		fnum = -fnum;
#line 15084 ""
	    }
#line 15085 ""
	    r__1 = fnum + 32;
#line 15085 ""
	    i__1 = i_nint(&r__1);
#line 15085 ""
	    setbits_(&comcb_1.ibcdata[comcb_1.nbc - 1], &c__6, &c__13, &i__1);
#line 15086 ""
	    if (i_indx("+-", charq, (ftnlen)2, (ftnlen)1) > 0) {

/*  Horizontal shift, get it */

#line 15090 ""
		++(*iccount);
#line 15091 ""
		readnum_(lineq, iccount, durq, &fnum, (ftnlen)128, (ftnlen)1);
#line 15092 ""
		if (*(unsigned char *)charq == '-') {
#line 15092 ""
		    fnum = -fnum;
#line 15092 ""
		}
#line 15093 ""
		r__1 = fnum * 10;
#line 15093 ""
		i__1 = i_nint(&r__1) + 128;
#line 15093 ""
		setbits_(&comcb_1.ibcdata[comcb_1.nbc - 1], &c__8, &c__19, &
			i__1);
#line 15094 ""
	    }
#line 15095 ""
	}
#line 15096 ""
	return 0;
#line 15097 ""
    }

/*  Set signal on main note that some note at this time has ornament.  ONLY used */
/*  in beamstrt to activate further tests for whether ihornb is needed. */

#line 15102 ""
    *iornq = bit_set(*iornq,23);

/*  Isolate 21 bits defining exisiting ornaments */

#line 15106 ""
    if (*notcrd) {
/*        iorni = iand(4194303,iornq) */
/*        iorni = iand(541065215,iornq) */
#line 15109 ""
	iorni = 1614807039 & *iornq;
#line 15110 ""
    } else {
#line 15111 ""
	iorni = 4194303 & comtrill_1.icrdorn[comtrill_1.ncrd - 1];
#line 15112 ""
    }
/*      korn = index('stmgx+Tupf._)e:XXX>^',charq) */
#line 15114 ""
    korn = i_indx("stmgx+Tupf._)e:XXX>^XXXXXXXXCG", charq, (ftnlen)30, (
	    ftnlen)1);
#line 15115 ""
    if (korn != 15) {
#line 15115 ""
	iorni = bit_set(iorni,korn);
#line 15115 ""
    }

/*  Note that korn=0 => charq='(', and we set bit 0.  if "e" (14), alter later */
/*    as follows: korn=16-18 for sfn, and or 21 for bare ?. */
/*  When this if-block is done, korn will = bit# of actual ornament (unless "?"). */

#line 15121 ""
    if (korn == 15) {

/*  Turn off repeated ornament ('o:'), Replicate bits 0-3,5-15,19-21,29 prev iornq */

#line 15125 ""
	iorni |= *iornq0 & 1614348271;
#line 15126 ""
	*ornrpt = FALSE_;
#line 15127 ""
	getchar_(lineq, iccount, durq, (ftnlen)128, (ftnlen)1);

/*  durq will be ' ' */

#line 15131 ""
    } else if (korn == 14) {

/*  Editorial accidental */

#line 15135 ""
	getchar_(lineq, iccount, durq, (ftnlen)128, (ftnlen)1);
#line 15136 ""
	korn = i_indx("sfn?", durq, (ftnlen)4, (ftnlen)1) + 15;
#line 15137 ""
	if (korn == 19) {
#line 15137 ""
	    korn = 21;
#line 15137 ""
	}
#line 15138 ""
	iorni = bit_set(bit_clear(iorni,14),korn);
#line 15139 ""
	getchar_(lineq, iccount, durq, (ftnlen)128, (ftnlen)1);
#line 15140 ""
	if (*(unsigned char *)durq == '?') {

/*  This is "oe[s|f|n]?".  Set 21st bit also. */

#line 15144 ""
	    iorni = bit_set(iorni,21);
#line 15145 ""
	    korn += 6;
#line 15146 ""
	    getchar_(lineq, iccount, durq, (ftnlen)128, (ftnlen)1);
#line 15147 ""
	}
/*        iorni = ibset(ibclr(iorni,14),korn) */
#line 15149 ""
    } else if (korn == 4 && *noxtup) {

/*  segno. Check in pmxa for just 1/block & notcrd.  Get horiz. offset in points */

#line 15153 ""
	*noffseg = 0;
#line 15154 ""
	negseg = FALSE_;
#line 15155 ""
	getchar_(lineq, iccount, durq, (ftnlen)128, (ftnlen)1);
#line 15156 ""
	if (*(unsigned char *)durq != ' ') {

/*  Segno shift is specified */

#line 15160 ""
	    if (*(unsigned char *)durq == '-') {
#line 15161 ""
		negseg = TRUE_;
#line 15162 ""
		getchar_(lineq, iccount, durq, (ftnlen)128, (ftnlen)1);
#line 15163 ""
	    }
#line 15164 ""
	    readnum_(lineq, iccount, durq, &fnum, (ftnlen)128, (ftnlen)1);
#line 15165 ""
	    *noffseg = (integer) fnum;
#line 15166 ""
	    if (negseg) {
#line 15166 ""
		*noffseg = -(*noffseg);
#line 15166 ""
	    }
#line 15167 ""
	}
#line 15168 ""
    } else if (korn == 7) {

/*  Trill.  Check in pmxa for notcrd.  Default is 1 noteskip long, with "tr" */

#line 15172 ""
	++comtrill_1.ntrill;
#line 15173 ""
	comtrill_1.ivtrill[comtrill_1.ntrill - 1] = *ivx;
#line 15174 ""
	comtrill_1.iptrill[comtrill_1.ntrill - 1] = *ip;
#line 15175 ""
	comtrill_1.xnsktr[comtrill_1.ntrill - 1] = 1.f;
#line 15176 ""
	getchar_(lineq, iccount, durq, (ftnlen)128, (ftnlen)1);
#line 15177 ""
	if (*(unsigned char *)durq == 't') {

/*  Convert to new internal symbol for non-'"tr" trill */

#line 15181 ""
	    korn = 15;
#line 15182 ""
	    iorni = bit_set(bit_clear(iorni,7),15);
#line 15183 ""
	    getchar_(lineq, iccount, durq, (ftnlen)128, (ftnlen)1);
#line 15184 ""
	}
#line 15185 ""
	if (i_indx("0123456789.", durq, (ftnlen)11, (ftnlen)1) > 0) {

/*  We have a number for the length */

#line 15189 ""
	    readnum_(lineq, iccount, durq, &comtrill_1.xnsktr[
		    comtrill_1.ntrill - 1], (ftnlen)128, (ftnlen)1);
#line 15190 ""
	}
#line 15191 ""
    } else if (korn == 10 && *noxtup) {

/*  Fermata */

#line 15195 ""
	getchar_(lineq, iccount, durq, (ftnlen)128, (ftnlen)1);
#line 15196 ""
	if (*(unsigned char *)durq == 'd') {
#line 15197 ""
	    korn = 14;
#line 15198 ""
	    iorni = bit_set(bit_clear(iorni,10),14);
#line 15199 ""
	    getchar_(lineq, iccount, durq, (ftnlen)128, (ftnlen)1);
#line 15200 ""
	}
#line 15201 ""
    } else {
#line 15202 ""
	getchar_(lineq, iccount, durq, (ftnlen)128, (ftnlen)1);
#line 15203 ""
    }
#line 15204 ""
    if (i_indx("+- :", durq, (ftnlen)4, (ftnlen)1) == 0) {
#line 15205 ""
	s_wsle(&io___881);
#line 15205 ""
	do_lio(&c__9, &c__1, "Unexpected character at end of ornament: ", (
		ftnlen)41);
#line 15205 ""
	do_lio(&c__9, &c__1, durq, (ftnlen)1);
#line 15205 ""
	e_wsle();
#line 15206 ""
	stop1_();
#line 15207 ""
    }
#line 15208 ""
    if (i_indx("+-", durq, (ftnlen)2, (ftnlen)1) > 0) {

/*  Shift ornament up or down */

#line 15212 ""
	++comtrill_1.nudorn;

/*  Set bit 25 in iorni as a signal.  This may not really be necessary. */

#line 15216 ""
	iorni = bit_set(iorni,25);

/*  Assemble info to put in kudorn(nudorn) Bits 0-7:ip, 8-11:ivx, 12-18:nolev, */
/*     19-24: type of ornament to be shifted, 25-30: shift+32, 31:h-shft present */

#line 15221 ""
	xofforn = (real) (44 - *(unsigned char *)durq);
#line 15222 ""
	++(*iccount);
#line 15223 ""
	readnum_(lineq, iccount, durq, &fnum, (ftnlen)128, (ftnlen)1);
#line 15224 ""
	r__1 = xofforn * fnum;
#line 15224 ""
	iofforn = i_nint(&r__1);
#line 15225 ""
	comtrill_1.kudorn[comtrill_1.nudorn - 1] = *ip + (*ivx % 16 << 8) + (*
		nole << 12) + (korn << 19) + (iofforn + 32 << 25);
#line 15227 ""
	comivxudorn_1.ivxudorn[comtrill_1.nudorn - 1] = *ivx;
#line 15228 ""
	if (i_indx("+-", durq, (ftnlen)2, (ftnlen)1) > 0) {

/*  Horizontal shift */

#line 15232 ""
	    comtrill_1.kudorn[comtrill_1.nudorn - 1] = bit_set(
		    comtrill_1.kudorn[comtrill_1.nudorn - 1],31);
#line 15233 ""
	    xofforn = (real) (44 - *(unsigned char *)durq);
#line 15234 ""
	    ++(*iccount);
#line 15235 ""
	    readnum_(lineq, iccount, durq, &fnum, (ftnlen)128, (ftnlen)1);
#line 15236 ""
	    comtrill_1.ornhshft[comtrill_1.nudorn - 1] = xofforn * fnum;
#line 15237 ""
	}
#line 15238 ""
    } else if (*(unsigned char *)durq == ':') {

/*  Turn on repeated ornaments */

#line 15242 ""
	*ornrpt = TRUE_;

/*  Save the ornament value just set */

#line 15246 ""
	*iornq0 = iorni;
#line 15247 ""
    }
#line 15248 ""
    if (*notcrd) {
#line 15249 ""
	*iornq |= iorni;
#line 15250 ""
    } else {
#line 15251 ""
	comtrill_1.icrdorn[comtrill_1.ncrd - 1] |= iorni;
#line 15252 ""
    }
#line 15253 ""
    return 0;
} /* getorn_ */

/* Subroutine */ int getpmxmod_(logical *global, char *includeq, ftnlen 
	includeq_len)
{
    /* System generated locals */
    address a__1[3], a__2[2];
    integer i__1[3], i__2[2], i__3;
    char ch__1[114], ch__2[106], ch__3[108], ch__4[88];
    olist o__1;
    cllist cl__1;
    inlist ioin__1;

    /* Builtin functions */
    integer f_inqu(inlist *);
    /* Subroutine */ int s_copy(char *, char *, ftnlen, ftnlen);
    integer s_wsle(cilist *), e_wsle(void), s_wsfe(cilist *), e_wsfe(void);
    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
    integer f_open(olist *), s_rsfe(cilist *), do_fio(integer *, char *, 
	    ftnlen), e_rsfe(void), f_clos(cllist *);

    /* Local variables */
    static integer ilbufmod, ipbufmod, lenbufmod, lenmodline;
    static char pmxmoddirq[80];
    static integer lpmxmoddirq;
    extern /* Subroutine */ int stop1_(void);
    static integer ilbuff;
    extern /* Subroutine */ int getenv_(char *, char *, ftnlen, ftnlen);
    static logical fexist;
    extern integer lenstr_(char *, integer *, ftnlen);
    extern /* Subroutine */ int printl_(char *, ftnlen);
    static char lnholdq[128];

    /* Fortran I/O blocks */
    static cilist io___887 = { 0, 6, 0, 0, 0 };
    static cilist io___888 = { 0, 15, 0, "()", 0 };
    static cilist io___892 = { 0, 18, 1, "(a)", 0 };



/*  If global=.true., checks for environment variable with path to pmx.mod. */
/*    Then, if variable exists and points to pmx.mod, insert lines from */
/*    pmx.mod into buffer */
/*  If global=.false., checks for existence of includeq and uses it. */

/*  lenbuf0 = total length of bufq on entry */
/*  lbuf(i) = length of line (i) */
/*  nlbuf = number of lines stored in bufq */
/*  ilbuf = index of first line after setup stuff (on entry). In general, index of */
/*          next line to be sucked from buffer. */
/*  ilbufmod = counter for lines in pmx.mod as they are grabbed. */
/*             Starts at ilbuf. Points to position of next line after */
/*             pmx.mod stuff in bufq on exiting loop 1 */
/*  ilbuff = transient counter for shifting operations */
/*  ipbuf = on entry, points to last character in setup stuff. In general, points */
/*          to last character of most recent line sucked from buffer. */
/*  ipbufmod = points to last character of most recent inserted line */
/*             from pmx.mod */

#line 15287 ""
    c1omget_1.line1pmxmod = inbuff_1.ilbuf;
#line 15288 ""
    if (! (*global)) {
#line 15289 ""
	ioin__1.inerr = 0;
#line 15289 ""
	ioin__1.infilen = includeq_len;
#line 15289 ""
	ioin__1.infile = includeq;
#line 15289 ""
	ioin__1.inex = &fexist;
#line 15289 ""
	ioin__1.inopen = 0;
#line 15289 ""
	ioin__1.innum = 0;
#line 15289 ""
	ioin__1.innamed = 0;
#line 15289 ""
	ioin__1.inname = 0;
#line 15289 ""
	ioin__1.inacc = 0;
#line 15289 ""
	ioin__1.inseq = 0;
#line 15289 ""
	ioin__1.indir = 0;
#line 15289 ""
	ioin__1.infmt = 0;
#line 15289 ""
	ioin__1.inform = 0;
#line 15289 ""
	ioin__1.inunf = 0;
#line 15289 ""
	ioin__1.inrecl = 0;
#line 15289 ""
	ioin__1.innrec = 0;
#line 15289 ""
	ioin__1.inblank = 0;
#line 15289 ""
	f_inqu(&ioin__1);

/*  Transfer includeq to temporary char variable with known length */

#line 15293 ""
	s_copy(pmxmoddirq, includeq, (ftnlen)80, includeq_len);
#line 15294 ""
	lpmxmoddirq = lenstr_(pmxmoddirq, &c__80, (ftnlen)80);
#line 15295 ""
	s_wsle(&io___887);
#line 15295 ""
	e_wsle();
#line 15296 ""
	s_wsfe(&io___888);
#line 15296 ""
	e_wsfe();
#line 15297 ""
	if (! fexist) {
/* Writing concatenation */
#line 15298 ""
	    i__1[0] = 15, a__1[0] = "Could not find ";
#line 15298 ""
	    i__1[1] = lpmxmoddirq, a__1[1] = pmxmoddirq;
#line 15298 ""
	    i__1[2] = 19, a__1[2] = ", checking further.";
#line 15298 ""
	    s_cat(ch__1, a__1, i__1, &c__3, (ftnlen)114);
#line 15298 ""
	    printl_(ch__1, lpmxmoddirq + 34);

/*  File named includeq doesn't not exist. Get directory from PMXMODDIR and */
/*    see if it's there */

#line 15304 ""
	    getenv_("PMXMODDIR", pmxmoddirq, (ftnlen)9, (ftnlen)80);
#line 15305 ""
	    lpmxmoddirq = lenstr_(pmxmoddirq, &c__80, (ftnlen)80);
#line 15306 ""
	    if (lpmxmoddirq > 0) {
/* Writing concatenation */
#line 15307 ""
		i__2[0] = lpmxmoddirq, a__2[0] = pmxmoddirq;
#line 15307 ""
		i__2[1] = includeq_len, a__2[1] = includeq;
#line 15307 ""
		s_cat(pmxmoddirq, a__2, i__2, &c__2, (ftnlen)80);
#line 15308 ""
		lpmxmoddirq = lenstr_(pmxmoddirq, &c__80, (ftnlen)80);
#line 15309 ""
	    } else {
#line 15310 ""
		printl_("No other directory defined by PMXMODDIR, stopping", (
			ftnlen)49);
#line 15312 ""
		stop1_();
#line 15313 ""
	    }
#line 15314 ""
	    ioin__1.inerr = 0;
#line 15314 ""
	    ioin__1.infilen = 80;
#line 15314 ""
	    ioin__1.infile = pmxmoddirq;
#line 15314 ""
	    ioin__1.inex = &fexist;
#line 15314 ""
	    ioin__1.inopen = 0;
#line 15314 ""
	    ioin__1.innum = 0;
#line 15314 ""
	    ioin__1.innamed = 0;
#line 15314 ""
	    ioin__1.inname = 0;
#line 15314 ""
	    ioin__1.inacc = 0;
#line 15314 ""
	    ioin__1.inseq = 0;
#line 15314 ""
	    ioin__1.indir = 0;
#line 15314 ""
	    ioin__1.infmt = 0;
#line 15314 ""
	    ioin__1.inform = 0;
#line 15314 ""
	    ioin__1.inunf = 0;
#line 15314 ""
	    ioin__1.inrecl = 0;
#line 15314 ""
	    ioin__1.innrec = 0;
#line 15314 ""
	    ioin__1.inblank = 0;
#line 15314 ""
	    f_inqu(&ioin__1);
#line 15315 ""
	    if (! fexist) {
/* Writing concatenation */
#line 15316 ""
		i__1[0] = 15, a__1[0] = "Could not find ";
#line 15316 ""
		i__1[1] = lpmxmoddirq, a__1[1] = pmxmoddirq;
#line 15316 ""
		i__1[2] = 11, a__1[2] = ", stopping.";
#line 15316 ""
		s_cat(ch__2, a__1, i__1, &c__3, (ftnlen)106);
#line 15316 ""
		printl_(ch__2, lpmxmoddirq + 26);
#line 15318 ""
		stop1_();
#line 15319 ""
	    }
#line 15320 ""
	}
/* Writing concatenation */
#line 15321 ""
	i__2[0] = 28, a__2[0] = "Opening normal include file ";
#line 15321 ""
	i__2[1] = lpmxmoddirq, a__2[1] = pmxmoddirq;
#line 15321 ""
	s_cat(ch__3, a__2, i__2, &c__2, (ftnlen)108);
#line 15321 ""
	printl_(ch__3, lpmxmoddirq + 28);
#line 15323 ""
	o__1.oerr = 0;
#line 15323 ""
	o__1.ounit = 18;
#line 15323 ""
	o__1.ofnmlen = 80;
#line 15323 ""
	o__1.ofnm = pmxmoddirq;
#line 15323 ""
	o__1.orl = 0;
#line 15323 ""
	o__1.osta = 0;
#line 15323 ""
	o__1.oacc = 0;
#line 15323 ""
	o__1.ofm = 0;
#line 15323 ""
	o__1.oblnk = 0;
#line 15323 ""
	f_open(&o__1);
#line 15324 ""
    } else {

/*  Check for existence of pmx.mod */

#line 15328 ""
	getenv_("PMXMODDIR", pmxmoddirq, (ftnlen)9, (ftnlen)80);
#line 15329 ""
	lpmxmoddirq = lenstr_(pmxmoddirq, &c__80, (ftnlen)80);
#line 15330 ""
	if (lpmxmoddirq == 0) {
#line 15330 ""
	    return 0;
#line 15330 ""
	}
/* Writing concatenation */
#line 15331 ""
	i__2[0] = lpmxmoddirq, a__2[0] = pmxmoddirq;
#line 15331 ""
	i__2[1] = 7, a__2[1] = "pmx.mod";
#line 15331 ""
	s_cat(pmxmoddirq, a__2, i__2, &c__2, (ftnlen)80);
#line 15332 ""
	lpmxmoddirq += 7;
#line 15333 ""
	ioin__1.inerr = 0;
#line 15333 ""
	ioin__1.infilen = 80;
#line 15333 ""
	ioin__1.infile = pmxmoddirq;
#line 15333 ""
	ioin__1.inex = &fexist;
#line 15333 ""
	ioin__1.inopen = 0;
#line 15333 ""
	ioin__1.innum = 0;
#line 15333 ""
	ioin__1.innamed = 0;
#line 15333 ""
	ioin__1.inname = 0;
#line 15333 ""
	ioin__1.inacc = 0;
#line 15333 ""
	ioin__1.inseq = 0;
#line 15333 ""
	ioin__1.indir = 0;
#line 15333 ""
	ioin__1.infmt = 0;
#line 15333 ""
	ioin__1.inform = 0;
#line 15333 ""
	ioin__1.inunf = 0;
#line 15333 ""
	ioin__1.inrecl = 0;
#line 15333 ""
	ioin__1.innrec = 0;
#line 15333 ""
	ioin__1.inblank = 0;
#line 15333 ""
	f_inqu(&ioin__1);
#line 15334 ""
	if (! fexist) {
#line 15334 ""
	    return 0;
#line 15334 ""
	}
/* Writing concatenation */
#line 15335 ""
	i__2[0] = 28, a__2[0] = "Opening global include file ";
#line 15335 ""
	i__2[1] = lpmxmoddirq, a__2[1] = pmxmoddirq;
#line 15335 ""
	s_cat(ch__3, a__2, i__2, &c__2, (ftnlen)108);
#line 15335 ""
	printl_(ch__3, lpmxmoddirq + 28);
#line 15337 ""
	o__1.oerr = 0;
#line 15337 ""
	o__1.ounit = 18;
#line 15337 ""
	o__1.ofnmlen = lpmxmoddirq;
#line 15337 ""
	o__1.ofnm = pmxmoddirq;
#line 15337 ""
	o__1.orl = 0;
#line 15337 ""
	o__1.osta = 0;
#line 15337 ""
	o__1.oacc = 0;
#line 15337 ""
	o__1.ofm = 0;
#line 15337 ""
	o__1.oblnk = 0;
#line 15337 ""
	f_open(&o__1);
#line 15338 ""
    }
#line 15339 ""
    printl_("Adding include data", (ftnlen)19);

/*  Read lines in from pmx.mod one at a time */

#line 15343 ""
    ipbufmod = inbuff_1.ipbuf;
#line 15344 ""
    lenbufmod = c1omget_1.lenbuf0;
#line 15345 ""
    for (ilbufmod = inbuff_1.ilbuf; ilbufmod <= 9600; ++ilbufmod) {
#line 15346 ""
	i__3 = s_rsfe(&io___892);
#line 15346 ""
	if (i__3 != 0) {
#line 15346 ""
	    goto L3;
#line 15346 ""
	}
#line 15346 ""
	i__3 = do_fio(&c__1, lnholdq, (ftnlen)128);
#line 15346 ""
	if (i__3 != 0) {
#line 15346 ""
	    goto L3;
#line 15346 ""
	}
#line 15346 ""
	i__3 = e_rsfe();
#line 15346 ""
	if (i__3 != 0) {
#line 15346 ""
	    goto L3;
#line 15346 ""
	}

/*  A line was read. Slide all existing lengths from here forward ahead by 1 */

#line 15350 ""
	i__3 = ilbufmod;
#line 15350 ""
	for (ilbuff = inbuff_1.nlbuf; ilbuff >= i__3; --ilbuff) {
#line 15351 ""
	    inbuff_1.lbuf[ilbuff] = inbuff_1.lbuf[ilbuff - 1];
#line 15352 ""
/* L2: */
#line 15352 ""
	}

/*  Get length of line from include file */

#line 15356 ""
	lenmodline = lenstr_(lnholdq, &c__128, (ftnlen)128);
#line 15357 ""
	if (lenmodline == 0) {

/*  Blank line.  Make it a single blank with length 1 */

#line 15361 ""
	    lenmodline = 1;
#line 15362 ""
	    s_copy(lnholdq, " ", (ftnlen)128, (ftnlen)1);
#line 15363 ""
	}
#line 15364 ""
	inbuff_1.lbuf[ilbufmod - 1] = (shortint) lenmodline;
#line 15365 ""
	printl_(lnholdq, lenmodline);

/*  Insert new stuff into bufq */

#line 15369 ""
	i__3 = ipbufmod;
/* Writing concatenation */
#line 15369 ""
	i__1[0] = ipbufmod, a__1[0] = inbuff_1.bufq;
#line 15369 ""
	i__1[1] = lenmodline, a__1[1] = lnholdq;
#line 15369 ""
	i__1[2] = lenbufmod - i__3, a__1[2] = inbuff_1.bufq + i__3;
#line 15369 ""
	s_cat(inbuff_1.bufq, a__1, i__1, &c__3, (ftnlen)131072);

/*  Update internal parameters */

#line 15374 ""
	ipbufmod += inbuff_1.lbuf[ilbufmod - 1];
#line 15375 ""
	lenbufmod += inbuff_1.lbuf[ilbufmod - 1];
#line 15376 ""
	++inbuff_1.nlbuf;
#line 15377 ""
/* L1: */
#line 15377 ""
    }
#line 15378 ""
L3:
/* Writing concatenation */
#line 15379 ""
    i__2[0] = 8, a__2[0] = "Closing ";
#line 15379 ""
    i__2[1] = lpmxmoddirq, a__2[1] = pmxmoddirq;
#line 15379 ""
    s_cat(ch__4, a__2, i__2, &c__2, (ftnlen)88);
#line 15379 ""
    printl_(ch__4, lpmxmoddirq + 8);
#line 15380 ""
    cl__1.cerr = 0;
#line 15380 ""
    cl__1.cunit = 18;
#line 15380 ""
    cl__1.csta = 0;
#line 15380 ""
    f_clos(&cl__1);
#line 15381 ""
    c1omget_1.linesinpmxmod = c1omget_1.linesinpmxmod + ilbufmod - 
	    inbuff_1.ilbuf;
#line 15382 ""
    c1omget_1.lenbuf0 = lenbufmod;

/*  Fix Andre's error reporting problem 101211 leading to log(neg#) due */
/*  to nline being 2 bigger than it should be */

#line 15387 ""
    c1omget_1.nline += -2;

#line 15389 ""
    return 0;
} /* getpmxmod_ */

/* Subroutine */ int getset_(integer *nv, integer *noinst, integer *mtrnuml, 
	integer *mtrdenl, integer *mtrnmp, integer *mtrdnp, real *xmtrnum0, 
	integer *npages, integer *nsyst, integer *musicsize, real *fracindent,
	 logical *istype0, char *inameq, char *clefq, char *sepsymq, char *
	pathnameq, integer *lpath, integer *isig0, ftnlen inameq_len, ftnlen 
	clefq_len, ftnlen sepsymq_len, ftnlen pathnameq_len)
{
    /* System generated locals */
    integer i__1, i__2;
    real r__1;
    char ch__1[1];
    olist o__1;

    /* Builtin functions */
    integer s_cmp(char *, char *, ftnlen, ftnlen), f_open(olist *), s_wsfe(
	    cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void), 
	    i_nint(real *), i_indx(char *, char *, ftnlen, ftnlen);

    /* Local variables */
    static integer i__, iv, ivi;
    extern /* Character */ VOID chax_(char *, ftnlen, integer *);
    static integer ipos, nline;
    static char lineq[128];
    static integer iinst, jinst;
    extern doublereal readin_(char *, integer *, integer *, ftnlen);
    extern /* Subroutine */ int getbuf_(char *, ftnlen);
    static logical newway;
    static integer iccount, nvsofar;

    /* Fortran I/O blocks */
    static cilist io___898 = { 0, 17, 0, "(a)", 0 };



/*  Get the first line */

#line 15405 ""
    /* Parameter adjustments */
#line 15405 ""
    --sepsymq;
#line 15405 ""
    --clefq;
#line 15405 ""
    inameq -= 79;
#line 15405 ""

#line 15405 ""
    /* Function Body */
#line 15405 ""
    iccount = 0;
#line 15406 ""
L9:
#line 15406 ""
    getbuf_(lineq, (ftnlen)128);
#line 15407 ""
    if (*(unsigned char *)lineq == '%') {
#line 15407 ""
	goto L9;
#line 15407 ""
    }
#line 15408 ""
    *istype0 = s_cmp(lineq, "---", (ftnlen)3, (ftnlen)3) == 0;
#line 15409 ""
    if (*istype0) {

/*  Have TeX input until next line that starts with '---'.  Save in scratch. */

#line 15413 ""
	o__1.oerr = 0;
#line 15413 ""
	o__1.ounit = 17;
#line 15413 ""
	o__1.ofnm = 0;
#line 15413 ""
	o__1.orl = 0;
#line 15413 ""
	o__1.osta = "SCRATCH";
#line 15413 ""
	o__1.oacc = 0;
#line 15413 ""
	o__1.ofm = 0;
#line 15413 ""
	o__1.oblnk = 0;
#line 15413 ""
	f_open(&o__1);
#line 15414 ""
L3:
#line 15414 ""
	getbuf_(lineq, (ftnlen)128);
#line 15415 ""
	if (s_cmp(lineq, "---", (ftnlen)3, (ftnlen)3) != 0) {
#line 15416 ""
	    s_wsfe(&io___898);
#line 15416 ""
	    do_fio(&c__1, lineq, (ftnlen)128);
#line 15416 ""
	    e_wsfe();
#line 15417 ""
	    goto L3;
#line 15418 ""
	}

/*  Force a new line read on first call to readin */

#line 15422 ""
	iccount = 128;
#line 15423 ""
    }

/*  Here, lineq is first line w/ numerical setup data. */

#line 15427 ""
    r__1 = readin_(lineq, &iccount, &nline, (ftnlen)128);
#line 15427 ""
    *nv = i_nint(&r__1);
#line 15428 ""
    r__1 = readin_(lineq, &iccount, &nline, (ftnlen)128);
#line 15428 ""
    *noinst = i_nint(&r__1);
#line 15429 ""
    newway = *noinst <= 0;
#line 15430 ""
    if (newway) {
#line 15430 ""
	*noinst = -(*noinst);
#line 15430 ""
    }
#line 15431 ""
    i__1 = *noinst;
#line 15431 ""
    for (iinst = 1; iinst <= i__1; ++iinst) {

/*  Seve # of staves per inst in case later drop some inst's. */

#line 15435 ""
	if (newway) {

/*  Read in nvi for each instrument */

#line 15439 ""
	    r__1 = readin_(lineq, &iccount, &nline, (ftnlen)128);
#line 15439 ""
	    comnvi_1.nsperi[iinst - 1] = i_nint(&r__1);
#line 15440 ""
	} else if (iinst > 1) {
#line 15441 ""
	    comnvi_1.nsperi[iinst - 1] = 1;
#line 15442 ""
	} else {
#line 15443 ""
	    comnvi_1.nsperi[iinst - 1] = *nv - *noinst + 1;
#line 15444 ""
	}
#line 15445 ""
	comnvi_1.iiorig[iinst - 1] = iinst;
#line 15446 ""
	comnvi_1.nspern[iinst - 1] = comnvi_1.nsperi[iinst - 1];
#line 15447 ""
/* L2: */
#line 15447 ""
    }
#line 15448 ""
    r__1 = readin_(lineq, &iccount, &nline, (ftnlen)128);
#line 15448 ""
    *mtrnuml = i_nint(&r__1);
#line 15449 ""
    r__1 = readin_(lineq, &iccount, &nline, (ftnlen)128);
#line 15449 ""
    *mtrdenl = i_nint(&r__1);
#line 15450 ""
    r__1 = readin_(lineq, &iccount, &nline, (ftnlen)128);
#line 15450 ""
    *mtrnmp = i_nint(&r__1);
#line 15451 ""
    r__1 = readin_(lineq, &iccount, &nline, (ftnlen)128);
#line 15451 ""
    *mtrdnp = i_nint(&r__1);
#line 15452 ""
    *xmtrnum0 = readin_(lineq, &iccount, &nline, (ftnlen)128);

/*  Original key sig (before any trnasposition) in next position.  Transposed */
/*  sig for topfile was transferred thru pmxtex.dat.  Need isig0 for key */
/*  changes if transposed. */

#line 15458 ""
    r__1 = readin_(lineq, &iccount, &nline, (ftnlen)128);
#line 15458 ""
    *isig0 = i_nint(&r__1);
#line 15459 ""
    commidisig_1.midisig = *isig0;
#line 15460 ""
    r__1 = readin_(lineq, &iccount, &nline, (ftnlen)128);
#line 15460 ""
    *npages = i_nint(&r__1);
#line 15461 ""
    r__1 = readin_(lineq, &iccount, &nline, (ftnlen)128);
#line 15461 ""
    *nsyst = i_nint(&r__1);
#line 15462 ""
    r__1 = readin_(lineq, &iccount, &nline, (ftnlen)128);
#line 15462 ""
    *musicsize = i_nint(&r__1);
#line 15463 ""
    *fracindent = readin_(lineq, &iccount, &nline, (ftnlen)128);

/*  Next noinst non-comment lines are names of instruments. */

#line 15467 ""
    i__1 = *noinst;
#line 15467 ""
    for (i__ = 1; i__ <= i__1; ++i__) {
#line 15468 ""
L5:
#line 15468 ""
	getbuf_(inameq + i__ * 79, (ftnlen)79);
#line 15469 ""
	if (*(unsigned char *)&inameq[i__ * 79] == '%') {
#line 15469 ""
	    goto L5;
#line 15469 ""
	}
#line 15470 ""
/* L4: */
#line 15470 ""
    }

/*  Next non-comment line has nv clef names */

#line 15474 ""
L6:
#line 15474 ""
    getbuf_(lineq, (ftnlen)128);
#line 15475 ""
    if (*(unsigned char *)lineq == '%') {
#line 15475 ""
	goto L6;
#line 15475 ""
    }
#line 15476 ""
    iv = 0;
#line 15477 ""
    nvsofar = 0;
#line 15478 ""
    i__1 = *noinst;
#line 15478 ""
    for (jinst = 1; jinst <= i__1; ++jinst) {
#line 15479 ""
	nvsofar += comnvi_1.nsperi[jinst - 1];
#line 15480 ""
	i__2 = comnvi_1.nsperi[jinst - 1];
#line 15480 ""
	for (ivi = 1; ivi <= i__2; ++ivi) {
#line 15481 ""
	    ++iv;
#line 15482 ""
	    *(unsigned char *)&clefq[iv] = *(unsigned char *)&lineq[iv - 1];
#line 15483 ""
	    if (iv == nvsofar) {
#line 15484 ""
		*(unsigned char *)&sepsymq[iv] = '&';
#line 15485 ""
	    } else {
#line 15486 ""
		*(unsigned char *)&sepsymq[iv] = '|';
#line 15487 ""
	    }
#line 15488 ""
/* L10: */
#line 15488 ""
	}
#line 15489 ""
/* L1: */
#line 15489 ""
    }

/*  Mext non-comment line has path name */

#line 15493 ""
L8:
#line 15493 ""
    getbuf_(pathnameq, (ftnlen)40);
#line 15494 ""
    if (*(unsigned char *)pathnameq == '%') {
#line 15494 ""
	goto L8;
#line 15494 ""
    }
#line 15495 ""
    *lpath = i_indx(pathnameq, " ", (ftnlen)40, (ftnlen)1) - 1;
#line 15496 ""
L12:
#line 15496 ""
    chax_(ch__1, (ftnlen)1, &c__92);
#line 15496 ""
    ipos = i_indx(pathnameq, ch__1, (ftnlen)40, (ftnlen)1);
#line 15497 ""
    if (ipos > 0) {
#line 15498 ""
	chax_(ch__1, (ftnlen)1, &c__47);
#line 15498 ""
	*(unsigned char *)&pathnameq[ipos - 1] = *(unsigned char *)&ch__1[0];
#line 15499 ""
	goto L12;
#line 15500 ""
    }
#line 15501 ""
    return 0;
} /* getset_ */

doublereal getsquez_(integer *n, integer *ntot, real *space, real *tnote, 
	real *to)
{
    /* System generated locals */
    integer i__1;
    real ret_val, r__1, r__2;

    /* Local variables */
    static integer in;
    static real tend, tgovern;


/*  Get the squez factor by checking space against tgovern=minimum duration */
/*    of all notes sounding at time of n-th note in the list. */
/*  The starting time of base increment is to(n) and ending time is to(n)+space */
/*  Sounding notes are those that start at or before to(n) .and. end at or */
/*    after tend=to(n)+space */
/*  Since notes are ordered by increasing start times, as soon as we find one */
/*    that starts too late, we are done checking. */

#line 15515 ""
    /* Parameter adjustments */
#line 15515 ""
    --to;
#line 15515 ""
    --tnote;
#line 15515 ""

#line 15515 ""
    /* Function Body */
#line 15515 ""
    tgovern = 1e3f;
#line 15516 ""
    tend = to[*n] + *space;
#line 15517 ""
    i__1 = *ntot;
#line 15517 ""
    for (in = 1; in <= i__1; ++in) {

/*  Since to() is ordered by start times, exit loop after first note that */
/*    starts later than note of interest. */

#line 15522 ""
	if (to[in] > to[*n] + comtol_1.tol) {
#line 15522 ""
	    goto L2;
#line 15522 ""
	}
#line 15523 ""
	if (to[in] + tnote[in] > tend - comtol_1.tol) {

/*  If here, this note overlaps and must be tested. */

/* Computing MIN */
#line 15527 ""
	    r__1 = tgovern, r__2 = tnote[in];
#line 15527 ""
	    tgovern = dmin(r__1,r__2);
#line 15528 ""
	}
#line 15529 ""
/* L1: */
#line 15529 ""
    }
#line 15530 ""
L2:
#line 15531 ""
    ret_val = *space / tgovern;
#line 15532 ""
    return ret_val;
} /* getsquez_ */

/* Subroutine */ int getx_(char *lineq, integer *iccount, integer *irest, 
	logical *shifton, real *wheadpt, integer *iornq1, integer *ivx, 
	integer *irest1, integer *itsofar, integer *ntup, integer *itup, 
	integer *nnodur, char *dotq, integer *ndoub, ftnlen lineq_len, ftnlen 
	dotq_len)
{
    /* Builtin functions */
    integer i_indx(char *, char *, ftnlen, ftnlen);

    /* Local variables */
    static logical ess;
    static real fnum;
    static char durq[1], charq[1];
    static logical colon, number;
    static integer nextbl;
    extern /* Subroutine */ int getchar_(char *, integer *, char *, ftnlen, 
	    ftnlen), readnum_(char *, integer *, char *, real *, ftnlen, 
	    ftnlen);
    extern integer ifnodur_(integer *, char *, ftnlen);


/*  Parse "X" commands.  Ignore all "B"; "P" means to ignore whole symbol. */
/*  In scor2prt, must strip out "P", copy only "B" and "P"-type "X"-symbols. */
/*  Since during getnote phase time is integer itsofar, which is not updated */
/*    during xtups, we use itup and ntup to get actual time.  On entry, ntup=0 if */
/*    not in xtup. */

#line 15548 ""
    colon = FALSE_;
#line 15549 ""
    ess = FALSE_;
#line 15550 ""
    number = FALSE_;
#line 15551 ""
    nextbl = *iccount + i_indx(lineq + (*iccount - 1), " ", 128 - (*iccount - 
	    1), (ftnlen)1) - 1;
#line 15552 ""
    if (i_indx(lineq + (*iccount - 1), "P", nextbl - (*iccount - 1), (ftnlen)
	    1) > 0) {

/*  "Parts only", ignore entire symbol */

#line 15556 ""
	*iccount = nextbl;
#line 15557 ""
	return 0;
#line 15558 ""
    }
#line 15559 ""
L1:
#line 15559 ""
    getchar_(lineq, iccount, charq, (ftnlen)128, (ftnlen)1);
#line 15560 ""
    if (*(unsigned char *)charq == 'B') {

/*  "Both parts and score," ignore character */

#line 15564 ""
	goto L1;
#line 15565 ""
    } else if (*(unsigned char *)charq == ':') {
#line 15566 ""
	colon = TRUE_;
#line 15567 ""
	goto L1;
#line 15568 ""
    } else if (*(unsigned char *)charq == 'S') {
#line 15569 ""
	ess = TRUE_;
#line 15570 ""
	goto L1;
#line 15571 ""
    } else if (i_indx("+-.0123456789", charq, (ftnlen)13, (ftnlen)1) > 0) {
#line 15572 ""
	number = TRUE_;
#line 15573 ""
	if (*(unsigned char *)charq == '-') {
#line 15573 ""
	    ++(*iccount);
#line 15573 ""
	}
#line 15574 ""
	readnum_(lineq, iccount, durq, &fnum, (ftnlen)128, (ftnlen)1);
#line 15575 ""
	if (*(unsigned char *)charq == '-') {
#line 15575 ""
	    fnum = -fnum;
#line 15575 ""
	}
#line 15576 ""
	if (*(unsigned char *)durq != 'p') {
#line 15577 ""
	    fnum *= *wheadpt;
#line 15578 ""
	    --(*iccount);
#line 15579 ""
	}
#line 15580 ""
	goto L1;
#line 15581 ""
    }

/*  charq must be blank, so done parsing */

#line 15585 ""
    if (! ess && ! colon) {

/*  Ordinary hardspace.  Goes before next note. */
/*   (Later, at "|" or "/", check for presence and switch to udoff if there!) */

#line 15590 ""
	++comudsp_1.nudsp;
#line 15591 ""
	*iornq1 = bit_set(*iornq1,26);
#line 15592 ""
	comudsp_1.udsp[comudsp_1.nudsp - 1] = fnum;
#line 15593 ""
	comudsp_1.tudsp[comudsp_1.nudsp - 1] = (real) (*itsofar);
#line 15594 ""
	if (*ntup > 0) {
#line 15594 ""
	    comudsp_1.tudsp[comudsp_1.nudsp - 1] += (real) (*itup - 1 + *
		    ndoub) / *ntup * ifnodur_(nnodur, dotq, (ftnlen)1);
#line 15594 ""
	}
#line 15596 ""
    } else if (! number) {

/*  Must be "X:"  End a group offset. */

#line 15600 ""
	*irest = bit_set(*irest,17);
#line 15601 ""
	*shifton = FALSE_;
#line 15602 ""
	return 0;
#line 15603 ""
    } else {

/*  Only other possibility is start offset, "S" for single, ':' for multiple */

#line 15607 ""
	++comudsp_1.nudoff[*ivx - 1];
#line 15608 ""
	comudsp_1.udoff[*ivx + comudsp_1.nudoff[*ivx - 1] * 24 - 25] = fnum;
#line 15609 ""
	if (ess) {
#line 15610 ""
	    *irest1 = bit_set(*irest1,15);
#line 15611 ""
	} else {
#line 15612 ""
	    *irest1 = bit_set(*irest1,16);
#line 15613 ""
	    *shifton = TRUE_;
#line 15614 ""
	}
#line 15615 ""
    }
#line 15616 ""
    return 0;
} /* getx_ */

integer i1fnodur_(integer *idur, char *dotq, ftnlen dotq_len)
{
    /* System generated locals */
    integer ret_val;

    /* Builtin functions */
    integer s_wsle(cilist *), e_wsle(void), do_lio(integer *, integer *, char 
	    *, ftnlen);

    /* Local variables */
    extern /* Subroutine */ int stop1_(void);

    /* Fortran I/O blocks */
    static cilist io___918 = { 0, 6, 0, 0, 0 };
    static cilist io___919 = { 0, 6, 0, 0, 0 };


#line 15620 ""
    if (*idur == 6) {
#line 15621 ""
	ret_val = 1;
#line 15622 ""
    } else if (*idur == 3) {
#line 15623 ""
	ret_val = 2;
#line 15624 ""
    } else if (*idur == 1) {
#line 15625 ""
	ret_val = 4;
#line 15626 ""
    } else if (*idur == 8) {
#line 15627 ""
	ret_val = 8;
#line 15628 ""
    } else if (*idur == 4) {
#line 15629 ""
	ret_val = 16;
#line 15630 ""
    } else if (*idur == 2) {
#line 15631 ""
	ret_val = 32;
#line 15632 ""
    } else if (*idur == 0) {
#line 15633 ""
	ret_val = 64;
#line 15634 ""
    } else if (*idur == 16) {

/*  Only used for denominator of time signatures, not for notes */

#line 15638 ""
	ret_val = 4;
#line 15639 ""
    } else if (*idur == 9) {
#line 15640 ""
	ret_val = 128;
#line 15641 ""
    } else {
#line 15642 ""
	s_wsle(&io___918);
#line 15642 ""
	e_wsle();
#line 15643 ""
	s_wsle(&io___919);
#line 15643 ""
	do_lio(&c__9, &c__1, "You entered an invalid note-length value:", (
		ftnlen)41);
#line 15643 ""
	do_lio(&c__3, &c__1, (char *)&(*idur), (ftnlen)sizeof(integer));
#line 15643 ""
	e_wsle();
#line 15644 ""
	stop1_();
#line 15645 ""
    }
#line 15646 ""
    if (*(unsigned char *)dotq == 'd') {
#line 15646 ""
	ret_val = ret_val * 3 / 2;
#line 15646 ""
    }
#line 15647 ""
    return ret_val;
} /* i1fnodur_ */

integer iashft_(integer *nacc)
{
    /* Initialized data */

    static integer ias[6] = { -1,1,0,0,-2,2 };

    /* System generated locals */
    integer ret_val;

#line 15652 ""
    ret_val = ias[(0 + (0 + (*nacc - 1 << 2))) / 4];
#line 15653 ""
    return ret_val;
} /* iashft_ */

integer ifnodur_(integer *idur, char *dotq, ftnlen dotq_len)
{
    /* System generated locals */
    integer ret_val;

    /* Builtin functions */
    integer s_wsle(cilist *), do_lio(integer *, integer *, char *, ftnlen), 
	    e_wsle(void);
    /* Subroutine */ int s_stop(char *, ftnlen);

    /* Fortran I/O blocks */
    static cilist io___921 = { 0, 6, 0, 0, 0 };


#line 15657 ""
    if (*idur == 6) {
#line 15658 ""
	ret_val = 1;
#line 15659 ""
    } else if (*idur == 3) {
#line 15660 ""
	ret_val = 2;
#line 15661 ""
    } else if (*idur == 1) {
#line 15662 ""
	ret_val = 4;
#line 15663 ""
    } else if (*idur == 8) {
#line 15664 ""
	ret_val = 8;
#line 15665 ""
    } else if (*idur == 4) {
#line 15666 ""
	ret_val = 16;
#line 15667 ""
    } else if (*idur == 2) {
#line 15668 ""
	ret_val = 32;
#line 15669 ""
    } else if (*idur == 0) {
#line 15670 ""
	ret_val = 64;
#line 15671 ""
    } else if (*idur == 9) {
#line 15672 ""
	ret_val = 128;
#line 15673 ""
    } else if (*idur == 16) {

/*  Only used for denominator of time signatures, not for notes */

#line 15677 ""
	ret_val = 4;
#line 15678 ""
    } else {
#line 15679 ""
	s_wsle(&io___921);
#line 15679 ""
	do_lio(&c__9, &c__1, "You entered an invalid note value", (ftnlen)33);
#line 15679 ""
	e_wsle();
#line 15680 ""
	s_stop("", (ftnlen)0);
#line 15681 ""
    }
#line 15682 ""
    if (*(unsigned char *)dotq == 'd') {
#line 15682 ""
	ret_val = ret_val * 3 / 2;
#line 15682 ""
    }
#line 15683 ""
    return ret_val;
} /* ifnodur_ */

integer ifnolev_(char *noq, integer *oct, integer *ntrans, ftnlen noq_len)
{
    /* System generated locals */
    integer ret_val;

#line 15688 ""
    ret_val = *oct * 7 + (*(unsigned char *)noq - 92) % 7 + 1 + *ntrans;
#line 15689 ""
    return ret_val;
} /* ifnolev_ */

integer igetbits_(integer *isdata, integer *iwidbit, integer *ishift)
{
    /* System generated locals */
    integer ret_val;

    /* Builtin functions */
    integer pow_ii(integer *, integer *), lbit_shift(integer, integer);


/*  Extracts integer given by iwidbit bits of isdata, shifted by ishift, and */
/*  then added to ioff */

#line 15696 ""
    ret_val = pow_ii(&c__2, iwidbit) - 1 & lbit_shift(*isdata, -(*ishift));
#line 15697 ""
    return ret_val;
} /* igetbits_ */

integer igetvarlen_(shortint *mmidi, integer *icm, integer *imidi, integer *
	nbytes)
{
    /* System generated locals */
    integer ret_val;

    /* Builtin functions */
    integer s_wsle(cilist *), do_lio(integer *, integer *, char *, ftnlen), 
	    e_wsle(void);

    /* Local variables */
    extern /* Subroutine */ int stop1_(void);
    static integer mmidi4;

    /* Fortran I/O blocks */
    static cilist io___923 = { 0, 6, 0, 0, 0 };



/*  Gets variable-length integer starting in mmidi at imidi+1. Returns nbytes. */

#line 15705 ""
    /* Parameter adjustments */
#line 15705 ""
    mmidi -= 25;
#line 15705 ""

#line 15705 ""
    /* Function Body */
#line 15705 ""
    ret_val = 0;
#line 15706 ""
    for (*nbytes = 1; *nbytes <= 4; ++(*nbytes)) {
#line 15707 ""
	mmidi4 = mmidi[*icm + (*imidi + *nbytes) * 25];
#line 15708 ""
	ret_val = (ret_val << 7) + (127 & mmidi4);
#line 15710 ""
	if (! bit_test(mmidi4,7)) {
#line 15710 ""
	    return ret_val;
#line 15710 ""
	}
#line 15711 ""
/* L1: */
#line 15711 ""
    }
#line 15712 ""
    s_wsle(&io___923);
#line 15712 ""
    do_lio(&c__9, &c__1, "Messup in igetvarlen", (ftnlen)20);
#line 15712 ""
    e_wsle();
#line 15713 ""
    stop1_();
#line 15714 ""
    return ret_val;
} /* igetvarlen_ */

logical isdotted_(integer *nodur, integer *ivx, integer *ip)
{
    /* System generated locals */
    real r__1;
    logical ret_val;

    /* Builtin functions */
    double log(doublereal), r_mod(real *, real *);


/*  Function returns true if note is dotted or double-dotted. */
/*    Return false for any xtuplet. */

#line 15723 ""
    /* Parameter adjustments */
#line 15723 ""
    nodur -= 25;
#line 15723 ""

#line 15723 ""
    /* Function Body */
#line 15723 ""
    if (nodur[*ivx + *ip * 24] == 0) {
#line 15724 ""
	ret_val = FALSE_;
#line 15725 ""
	return ret_val;
#line 15726 ""
    } else if (*ip > 1) {
#line 15727 ""
	if (nodur[*ivx + (*ip - 1) * 24] == 0) {
#line 15728 ""
	    ret_val = FALSE_;
#line 15729 ""
	    return ret_val;
#line 15730 ""
	}
#line 15731 ""
    }

/*  Ruled out all xtups, so is dotted or double-dotted if not a power of 2. */

#line 15735 ""
    r__1 = log((real) nodur[*ivx + *ip * 24]) / .69314718f + comtol_1.tol * 
	    .5f;
#line 15735 ""
    ret_val = r_mod(&r__1, &c_b1065) > comtol_1.tol;
#line 15737 ""
    return ret_val;
} /* isdotted_ */

integer isetvarlen_(integer *idur, integer *nbytes)
{
    /* System generated locals */
    integer ret_val, i__1;

    /* Builtin functions */
    integer pow_ii(integer *, integer *), lbit_shift(integer, integer), 
	    s_wsle(cilist *), do_lio(integer *, integer *, char *, ftnlen), 
	    e_wsle(void);

    /* Local variables */
    extern /* Subroutine */ int stop1_(void);
    static integer itemp;

    /* Fortran I/O blocks */
    static cilist io___925 = { 0, 6, 0, 0, 0 };


#line 15740 ""
    ret_val = 0;
#line 15741 ""
    itemp = *idur;
#line 15742 ""
    for (*nbytes = 1; *nbytes <= 4; ++(*nbytes)) {
#line 15743 ""
	i__1 = *nbytes - 1;
#line 15743 ""
	ret_val += (itemp & 127) * pow_ii(&c__256, &i__1);
#line 15744 ""
	itemp = lbit_shift(itemp, (ftnlen)-7);
#line 15745 ""
	if (itemp > 0) {
#line 15746 ""
	    i__1 = (*nbytes << 3) + 7;
#line 15746 ""
	    ret_val += pow_ii(&c__2, &i__1);
#line 15747 ""
	} else {
#line 15748 ""
	    return ret_val;
#line 15749 ""
	}
#line 15750 ""
/* L1: */
#line 15750 ""
    }
#line 15751 ""
    s_wsle(&io___925);
#line 15751 ""
    do_lio(&c__9, &c__1, "Problem in fn. isetvarlen", (ftnlen)25);
#line 15751 ""
    e_wsle();
#line 15752 ""
    stop1_();
#line 15753 ""
    return ret_val;
} /* isetvarlen_ */

/* Subroutine */ int istring_(integer *i__, char *string, integer *len, 
	ftnlen string_len)
{
    /* System generated locals */
    address a__1[3], a__2[2];
    integer i__1[3], i__2[2];
    real r__1;
    char ch__1[1], ch__2[4];
    icilist ici__1;

    /* Builtin functions */
    double r_lg10(real *);
    /* Subroutine */ int s_copy(char *, char *, ftnlen, ftnlen), s_cat(char *,
	     char **, integer *, integer *, ftnlen);
    integer s_wsfi(icilist *), do_fio(integer *, char *, ftnlen), e_wsfi(void)
	    ;


/*  Returns string with integer only if length is 1, otherwise enclosed in */
/*   brackets. */

#line 15760 ""
    if (*i__ != 0) {
#line 15761 ""
	r__1 = abs(*i__) * 1.0001f;
#line 15761 ""
	*len = r_lg10(&r__1) + 1;
#line 15762 ""
	if (*i__ < 0) {
#line 15762 ""
	    ++(*len);
#line 15762 ""
	}
#line 15763 ""
    } else {
#line 15764 ""
	s_copy(string, "0", string_len, (ftnlen)1);
#line 15765 ""
	*len = 1;
#line 15766 ""
	return 0;
#line 15767 ""
    }
#line 15768 ""
    if (*len == 1) {
#line 15769 ""
	*(unsigned char *)&ch__1[0] = *i__ + 48;
#line 15769 ""
	s_copy(string, ch__1, string_len, (ftnlen)1);
#line 15770 ""
    } else {
#line 15771 ""
	s_copy(string, "{", string_len, (ftnlen)1);
#line 15772 ""
	ici__1.icierr = 0;
#line 15772 ""
	ici__1.icirnum = 1;
#line 15772 ""
	ici__1.icirlen = *len;
#line 15772 ""
	ici__1.iciunit = string + 1;
/* Writing concatenation */
#line 15772 ""
	i__1[0] = 2, a__1[0] = "(i";
#line 15772 ""
	*(unsigned char *)&ch__1[0] = *len + 48;
#line 15772 ""
	i__1[1] = 1, a__1[1] = ch__1;
#line 15772 ""
	i__1[2] = 1, a__1[2] = ")";
#line 15772 ""
	ici__1.icifmt = (s_cat(ch__2, a__1, i__1, &c__3, (ftnlen)4), ch__2);
#line 15772 ""
	s_wsfi(&ici__1);
#line 15772 ""
	do_fio(&c__1, (char *)&(*i__), (ftnlen)sizeof(integer));
#line 15772 ""
	e_wsfi();
/* Writing concatenation */
#line 15773 ""
	i__2[0] = *len + 1, a__2[0] = string;
#line 15773 ""
	i__2[1] = 1, a__2[1] = "}";
#line 15773 ""
	s_cat(string, a__2, i__2, &c__2, string_len);
#line 15774 ""
	*len += 2;
#line 15775 ""
    }
#line 15776 ""
    return 0;
} /* istring_ */

integer lenstr_(char *string, integer *n, ftnlen string_len)
{
    /* System generated locals */
    integer ret_val;

#line 15780 ""
    for (ret_val = *n; ret_val >= 1; --ret_val) {
#line 15781 ""
	if (*(unsigned char *)&string[ret_val - 1] != ' ') {
#line 15781 ""
	    return ret_val;
#line 15781 ""
	}
#line 15782 ""
/* L1: */
#line 15782 ""
    }
#line 15783 ""
    ret_val = 0;
#line 15784 ""
    return ret_val;
} /* lenstr_ */

integer levrn_(integer *nolev, integer *irest, integer *iud, integer *ncm, 
	integer *mult)
{
    /* System generated locals */
    integer ret_val;

    /* Local variables */
    static integer ioff;


/*  Used for placing numbers in xtups.  Returns note level if not a rest, */
/*  else level of top or bottom of rest symbol opposite beam.  iud=-1 for upstm. */

#line 15792 ""
    if (! bit_test(*irest,0)) {
#line 15793 ""
	ret_val = *nolev;
#line 15794 ""
    } else {

/*  Restlevel is -4, 0, 2 or 100+offset.  First get offset from 1-voice default. */

#line 15798 ""
	if (*mult > 0) {
#line 15799 ""
	    if (*mult == 2) {
#line 15800 ""
		ioff = (*iud << 1) - 1;
#line 15801 ""
	    } else if (*mult != 4) {
#line 15802 ""
		ioff = *iud * *mult;
#line 15803 ""
	    } else {
#line 15804 ""
		ioff = (*iud << 2) + 1;
#line 15805 ""
	    }
#line 15806 ""
	} else {

/*  May need to futz with this later for non-beamed xtups (quarter, half rests) */

#line 15810 ""
	    ioff = *iud << 1;
#line 15811 ""
	}
#line 15812 ""
	ret_val = (*nolev + 20) % 100 - 20 + *ncm + ioff;
#line 15813 ""
    }
#line 15814 ""
    return ret_val;
} /* levrn_ */

integer lfmt1_(real *x)
{
    /* System generated locals */
    integer ret_val;
    real r__1;

    /* Builtin functions */
    double r_sign(real *, real *), r_lg10(real *);

    /* Local variables */
    static real y;


/*  Computes total length of an "f" format with one decimal place. */
/*  First round to nearest 0.1 */

#line 15821 ""
    if (dabs(*x) < .001f) {
#line 15822 ""
	ret_val = 2;
#line 15823 ""
    } else {
#line 15824 ""
	r__1 = (integer) (dabs(*x) * 10 + .5f) * .1f;
#line 15824 ""
	y = r_sign(&r__1, x);
#line 15825 ""
	r__1 = dabs(y) * 1000 + .001f;
#line 15825 ""
	ret_val = (integer) r_lg10(&r__1);
#line 15826 ""
	if (y < 0.f) {
#line 15826 ""
	    ++ret_val;
#line 15826 ""
	}
#line 15827 ""
    }
#line 15828 ""
    return ret_val;
} /* lfmt1_ */

/* Subroutine */ int linebreakties_(integer *isdat1, integer *isdat2, integer 
	*isdat3, integer *isdat4, integer *nsdat, logical *ispstie, char *
	sepsymq, ftnlen sepsymq_len)
{
    /* System generated locals */
    address a__1[2], a__2[3], a__3[5], a__4[4];
    integer i__1, i__2[2], i__3[3], i__4[5], i__5[4];
    real r__1;
    char ch__1[1], ch__2[1];

    /* Builtin functions */
    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
    integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void);

    /* Local variables */
    extern integer igetbits_(integer *, integer *, integer *);
    extern /* Subroutine */ int writflot_(real *, char *, integer *, ftnlen);
    static integer iv, kv, ncm;
    static logical tie;
    static integer iiv;
    static char udq[1];
    static integer ndx, ilb12;
    static real hoff;
    extern /* Character */ VOID chax_(char *, ftnlen, integer *);
    static integer imid, ihoff, isdat, ivoff, lnote;
    static char noteq[8];
    static integer idcode, islhgt;
    extern /* Subroutine */ int notefq_(char *, integer *, integer *, integer 
	    *, ftnlen);
    static integer lnoten;
    static char notexq[128];

    /* Fortran I/O blocks */
    static cilist io___947 = { 0, 11, 0, "(a)", 0 };



/*  This is called twice from pmxb after having input an entire block, before */
/*    making a bar that starts a new system.  So nsdat reflects all slur starts */
/*    and stops in new block, while listslur, which is only set when bars are */
/*    made, reflects only open slurs from the old block.  So we must check */
/*    listslur to find open ties, not all nsdat. */
/*  First of two calls (ispstie=.false. on entry) terminates tie at end of line. */
/*    Second (ispstie=.true. on entry) restarts tie at start of new line. Only */
/*    need data from original tie-start for both of these. Tie/slur data from */
/*    closing of full tie are not used except for shape alterations. */

#line 15852 ""
    /* Parameter adjustments */
#line 15852 ""
    --sepsymq;
#line 15852 ""
    --isdat4;
#line 15852 ""
    --isdat3;
#line 15852 ""
    --isdat2;
#line 15852 ""
    --isdat1;
#line 15852 ""

#line 15852 ""
    /* Function Body */
#line 15852 ""
    for (ndx = 0; ndx <= 23; ++ndx) {
#line 15853 ""
	if (bit_test(comslur_1.listslur,ndx)) {

/*  Slur or tie with index ndx is open. Find the one with right ndxb, see if tie */

#line 15857 ""
	    i__1 = *nsdat;
#line 15857 ""
	    for (isdat = 1; isdat <= i__1; ++isdat) {
#line 15858 ""
		if (igetbits_(&isdat1[isdat], &c__4, &c__28) + (igetbits_(&
			isdat1[isdat], &c__1, &c__18) << 4) != ndx) {
#line 15858 ""
		    goto L2;
#line 15858 ""
		}
/* Wron */
#line 15860 ""
		if (! bit_test(isdat1[isdat],11)) {
#line 15860 ""
		    goto L2;
#line 15860 ""
		}
/* Bypass if stop */
#line 15861 ""
		if (bit_test(isdat2[isdat],3)) {
#line 15861 ""
		    goto L3;
#line 15861 ""
		}
/* "st" */
#line 15862 ""
		idcode = igetbits_(&isdat1[isdat], &c__7, &c__19);
#line 15863 ""
		if (idcode == 1) {
#line 15863 ""
		    goto L3;
#line 15863 ""
		}
/* "t" */
#line 15864 ""
		tie = FALSE_;
#line 15865 ""
		goto L5;
#line 15866 ""
L2:
#line 15866 ""
		;
#line 15866 ""
	    }
#line 15867 ""
	}
#line 15868 ""
	goto L1;
#line 15869 ""
L3:
#line 15870 ""
	tie = TRUE_;
#line 15871 ""
L5:

/*  A slur or tie is open, with index ndx */

#line 15875 ""
	iv = igetbits_(&isdat1[isdat], &c__5, &c__13);
#line 15876 ""
	kv = igetbits_(&isdat1[isdat], &c__1, &c__12) + 1;
#line 15877 ""
	*(unsigned char *)udq = 'd';
#line 15878 ""
	if (bit_test(isdat1[isdat],27)) {
#line 15878 ""
	    *(unsigned char *)udq = 'u';
#line 15878 ""
	}
/* Writing concatenation */
#line 15879 ""
	chax_(ch__1, (ftnlen)1, &c__92);
#line 15879 ""
	i__2[0] = 1, a__1[0] = ch__1;
#line 15879 ""
	i__2[1] = 6, a__1[1] = "znotes";
#line 15879 ""
	s_cat(notexq, a__1, i__2, &c__2, (ftnlen)128);
#line 15880 ""
	lnote = 7;
#line 15881 ""
	i__1 = iv - 1;
#line 15881 ""
	for (iiv = 1; iiv <= i__1; ++iiv) {
/* Writing concatenation */
#line 15882 ""
	    i__2[0] = lnote, a__1[0] = notexq;
#line 15882 ""
	    i__2[1] = 1, a__1[1] = sepsymq + iiv;
#line 15882 ""
	    s_cat(notexq, a__1, i__2, &c__2, (ftnlen)128);
#line 15883 ""
	    ++lnote;
#line 15884 ""
/* L4: */
#line 15884 ""
	}
#line 15885 ""
	if (kv == 2) {
/* Writing concatenation */
#line 15886 ""
	    i__3[0] = lnote, a__2[0] = notexq;
#line 15886 ""
	    chax_(ch__1, (ftnlen)1, &c__92);
#line 15886 ""
	    i__3[1] = 1, a__2[1] = ch__1;
#line 15886 ""
	    i__3[2] = 9, a__2[2] = "nextvoice";
#line 15886 ""
	    s_cat(notexq, a__2, i__3, &c__3, (ftnlen)128);
#line 15887 ""
	    lnote += 10;
#line 15888 ""
	}

/*  Compute horiz and vert offsets */

#line 15892 ""
	islhgt = igetbits_(&isdat3[isdat], &c__8, &c__14);
#line 15893 ""
	ilb12 = 0;
#line 15894 ""
	if (*ispstie) {
#line 15894 ""
	    ilb12 = 1;
#line 15894 ""
	}
#line 15895 ""
	i__1 = ilb12 << 4;
#line 15895 ""
	ivoff = igetbits_(&isdat4[isdat], &c__6, &i__1) - 32;
#line 15896 ""
	if (ivoff == -32) {
#line 15896 ""
	    ivoff = 0;
#line 15896 ""
	}
#line 15897 ""
	islhgt += ivoff;
#line 15898 ""
	i__1 = (ilb12 << 4) + 6;
#line 15898 ""
	ihoff = igetbits_(&isdat4[isdat], &c__7, &i__1) - 64;
/* This is 10X */
#line 15899 ""
	if (ihoff == -64) {
#line 15899 ""
	    ihoff = 0;
#line 15899 ""
	}

/*  Add starting stuff for command */

#line 15903 ""
	if (! (*ispstie)) {
/* End 1st segment */
/* Writing concatenation */
#line 15904 ""
	    i__3[0] = lnote, a__2[0] = notexq;
#line 15904 ""
	    chax_(ch__1, (ftnlen)1, &c__92);
#line 15904 ""
	    i__3[1] = 1, a__2[1] = ch__1;
#line 15904 ""
	    i__3[2] = 8, a__2[2] = "roffset{";
#line 15904 ""
	    s_cat(notexq, a__2, i__3, &c__3, (ftnlen)128);
#line 15905 ""
	    lnote += 9;
#line 15906 ""
	    hoff = ihoff * .1f - .4f;
#line 15907 ""
	    if (hoff < 0.f) {
#line 15908 ""
		hoff = -hoff;
/* Writing concatenation */
#line 15909 ""
		i__2[0] = lnote, a__1[0] = notexq;
#line 15909 ""
		i__2[1] = 1, a__1[1] = "-";
#line 15909 ""
		s_cat(notexq, a__1, i__2, &c__2, (ftnlen)128);
#line 15910 ""
		++lnote;
#line 15911 ""
	    }
#line 15912 ""
	    writflot_(&hoff, notexq, &lnote, (ftnlen)128);
/* Writing concatenation */
#line 15913 ""
	    i__2[0] = lnote, a__1[0] = notexq;
#line 15913 ""
	    i__2[1] = 2, a__1[1] = "}{";
#line 15913 ""
	    s_cat(notexq, a__1, i__2, &c__2, (ftnlen)128);
#line 15914 ""
	    lnote += 2;
#line 15915 ""
	} else {
/* Writing concatenation */
#line 15916 ""
	    i__4[0] = lnote, a__3[0] = notexq;
#line 15916 ""
	    chax_(ch__1, (ftnlen)1, &c__92);
#line 15916 ""
	    i__4[1] = 1, a__3[1] = ch__1;
#line 15916 ""
	    i__4[2] = 5, a__3[2] = "off{-";
#line 15916 ""
	    chax_(ch__2, (ftnlen)1, &c__92);
#line 15916 ""
	    i__4[3] = 1, a__3[3] = ch__2;
#line 15916 ""
	    i__4[4] = 14, a__3[4] = "afterruleskip}";
#line 15916 ""
	    s_cat(notexq, a__3, i__4, &c__5, (ftnlen)128);
#line 15918 ""
	    lnote += 21;

/* 091025 add dotting for 2nd segment if needed */

#line 15922 ""
	    if (bit_test(isdat2[isdat],4)) {
/* Writing concatenation */
#line 15923 ""
		chax_(ch__1, (ftnlen)1, &c__92);
#line 15923 ""
		i__3[0] = 1, a__2[0] = ch__1;
#line 15923 ""
		i__3[1] = 6, a__2[1] = "dotted";
#line 15923 ""
		i__3[2] = lnote, a__2[2] = notexq;
#line 15923 ""
		s_cat(notexq, a__2, i__3, &c__3, (ftnlen)128);
#line 15924 ""
		lnote += 7;
#line 15925 ""
	    }
#line 15926 ""
	}
#line 15927 ""
	if (*ispstie && tie) {
/* Writing concatenation */
#line 15928 ""
	    i__5[0] = lnote, a__4[0] = notexq;
#line 15928 ""
	    chax_(ch__1, (ftnlen)1, &c__92);
#line 15928 ""
	    i__5[1] = 1, a__4[1] = ch__1;
#line 15928 ""
	    i__5[2] = 8, a__4[2] = "tieforis";
#line 15928 ""
	    i__5[3] = 1, a__4[3] = udq;
#line 15928 ""
	    s_cat(notexq, a__4, i__5, &c__4, (ftnlen)128);
#line 15929 ""
	    lnote += 10;
#line 15930 ""
	}
#line 15931 ""
	if (bit_test(isdat3[isdat],0)) {

/*  Curvature tweak on termination of 1st seg */

#line 15935 ""
	    imid = igetbits_(&isdat3[isdat], &c__6, &c__2) - 32;

/*  Invoke macro (from pmx.tex) that redefines \tslur as r'qd.  mapping: */
/*       Abs(imid)  Postscript slur type */
/*          1          f */
/*          4          h */
/*          5          H */
/*          6         HH */

/* Writing concatenation */
#line 15944 ""
	    i__5[0] = lnote, a__4[0] = notexq;
#line 15944 ""
	    chax_(ch__1, (ftnlen)1, &c__92);
#line 15944 ""
	    i__5[1] = 1, a__4[1] = ch__1;
#line 15944 ""
	    i__5[2] = 7, a__4[2] = "psforts";
#line 15944 ""
	    i__1 = imid + 48;
#line 15944 ""
	    chax_(ch__2, (ftnlen)1, &i__1);
#line 15944 ""
	    i__5[3] = 1, a__4[3] = ch__2;
#line 15944 ""
	    s_cat(notexq, a__4, i__5, &c__4, (ftnlen)128);
#line 15945 ""
	    lnote += 9;

/*  Zero out the flag in case there's a different curv on term of 2nd, */

#line 15949 ""
	    isdat3[isdat] = bit_clear(isdat3[isdat],0);
#line 15950 ""
	}

/*  Add the command name */

#line 15954 ""
	if (*ispstie) {
/* Writing concatenation */
#line 15955 ""
	    i__5[0] = lnote, a__4[0] = notexq;
#line 15955 ""
	    chax_(ch__1, (ftnlen)1, &c__92);
#line 15955 ""
	    i__5[1] = 1, a__4[1] = ch__1;
#line 15955 ""
	    i__5[2] = 2, a__4[2] = "is";
#line 15955 ""
	    i__5[3] = 1, a__4[3] = udq;
#line 15955 ""
	    s_cat(notexq, a__4, i__5, &c__4, (ftnlen)128);
#line 15956 ""
	    lnote += 4;
#line 15957 ""
	} else if (tie) {
/* Writing concatenation */
#line 15958 ""
	    i__3[0] = lnote, a__2[0] = notexq;
#line 15958 ""
	    chax_(ch__1, (ftnlen)1, &c__92);
#line 15958 ""
	    i__3[1] = 1, a__2[1] = ch__1;
#line 15958 ""
	    i__3[2] = 4, a__2[2] = "ttie";
#line 15958 ""
	    s_cat(notexq, a__2, i__3, &c__3, (ftnlen)128);
#line 15959 ""
	    lnote += 5;
#line 15960 ""
	} else {
/* Writing concatenation */
#line 15961 ""
	    i__3[0] = lnote, a__2[0] = notexq;
#line 15961 ""
	    chax_(ch__1, (ftnlen)1, &c__92);
#line 15961 ""
	    i__3[1] = 1, a__2[1] = ch__1;
#line 15961 ""
	    i__3[2] = 5, a__2[2] = "tslur";
#line 15961 ""
	    s_cat(notexq, a__2, i__3, &c__3, (ftnlen)128);
#line 15962 ""
	    lnote += 6;
#line 15963 ""
	}

/*  Add index */

#line 15967 ""
	if (23 - ndx < 10) {
/* Writing concatenation */
#line 15968 ""
	    i__2[0] = lnote, a__1[0] = notexq;
#line 15968 ""
	    i__1 = 71 - ndx;
#line 15968 ""
	    chax_(ch__1, (ftnlen)1, &i__1);
#line 15968 ""
	    i__2[1] = 1, a__1[1] = ch__1;
#line 15968 ""
	    s_cat(notexq, a__1, i__2, &c__2, (ftnlen)128);
#line 15969 ""
	    ++lnote;
#line 15970 ""
	} else if (23 - ndx < 20) {
/* Writing concatenation */
#line 15971 ""
	    i__5[0] = lnote, a__4[0] = notexq;
#line 15971 ""
	    i__5[1] = 2, a__4[1] = "{1";
#line 15971 ""
	    i__1 = 61 - ndx;
#line 15971 ""
	    chax_(ch__1, (ftnlen)1, &i__1);
#line 15971 ""
	    i__5[2] = 1, a__4[2] = ch__1;
#line 15971 ""
	    i__5[3] = 1, a__4[3] = "}";
#line 15971 ""
	    s_cat(notexq, a__4, i__5, &c__4, (ftnlen)128);
#line 15972 ""
	    lnote += 4;
#line 15973 ""
	} else {
/* Writing concatenation */
#line 15974 ""
	    i__5[0] = lnote, a__4[0] = notexq;
#line 15974 ""
	    i__5[1] = 2, a__4[1] = "{2";
#line 15974 ""
	    i__1 = 51 - ndx;
#line 15974 ""
	    chax_(ch__1, (ftnlen)1, &i__1);
#line 15974 ""
	    i__5[2] = 1, a__4[2] = ch__1;
#line 15974 ""
	    i__5[3] = 1, a__4[3] = "}";
#line 15974 ""
	    s_cat(notexq, a__4, i__5, &c__4, (ftnlen)128);
#line 15975 ""
	    lnote += 4;
#line 15976 ""
	}
#line 15977 ""
	if (*ispstie || ! tie) {

/*  Add note name for slur height */

#line 15981 ""
	    comoct_1.noctup = 0;
#line 15982 ""
	    ncm = igetbits_(&isdat3[isdat], &c__8, &c__22);
#line 15983 ""
	    if (ncm == 23) {
#line 15983 ""
		comoct_1.noctup = -2;
#line 15983 ""
	    }
#line 15984 ""
	    notefq_(noteq, &lnoten, &islhgt, &ncm, (ftnlen)8);
/* Writing concatenation */
#line 15985 ""
	    i__5[0] = lnote, a__4[0] = notexq;
#line 15985 ""
	    i__5[1] = 1, a__4[1] = "{";
#line 15985 ""
	    i__5[2] = lnoten, a__4[2] = noteq;
#line 15985 ""
	    i__5[3] = 1, a__4[3] = "}";
#line 15985 ""
	    s_cat(notexq, a__4, i__5, &c__4, (ftnlen)128);
#line 15986 ""
	    lnote = lnote + 1 + lnoten + 1;
#line 15987 ""
	}
#line 15988 ""
	if (*ispstie) {

/*  Horizontal shift start of new thing */

/* Writing concatenation */
#line 15992 ""
	    i__2[0] = lnote, a__1[0] = notexq;
#line 15992 ""
	    i__2[1] = 1, a__1[1] = "{";
#line 15992 ""
	    s_cat(notexq, a__1, i__2, &c__2, (ftnlen)128);
#line 15993 ""
	    ++lnote;
#line 15994 ""
	    if (tie) {
#line 15995 ""
		ihoff += -12;
#line 15996 ""
	    } else {
#line 15997 ""
		ihoff += -7;
#line 15998 ""
	    }
#line 15999 ""
	    if (ihoff < 0) {
#line 16000 ""
		ihoff = -ihoff;
/* Writing concatenation */
#line 16001 ""
		i__2[0] = lnote, a__1[0] = notexq;
#line 16001 ""
		i__2[1] = 1, a__1[1] = "-";
#line 16001 ""
		s_cat(notexq, a__1, i__2, &c__2, (ftnlen)128);
#line 16002 ""
		++lnote;
#line 16003 ""
	    }
#line 16004 ""
	    r__1 = ihoff * .1f;
#line 16004 ""
	    writflot_(&r__1, notexq, &lnote, (ftnlen)128);
/* Writing concatenation */
#line 16005 ""
	    i__2[0] = lnote, a__1[0] = notexq;
#line 16005 ""
	    i__2[1] = 1, a__1[1] = "}";
#line 16005 ""
	    s_cat(notexq, a__1, i__2, &c__2, (ftnlen)128);
#line 16006 ""
	    ++lnote;
#line 16007 ""
	}

/*  Add closing stuff */

#line 16011 ""
	if (*ispstie) {
/* Writing concatenation */
#line 16012 ""
	    i__4[0] = lnote, a__3[0] = notexq;
#line 16012 ""
	    chax_(ch__1, (ftnlen)1, &c__92);
#line 16012 ""
	    i__4[1] = 1, a__3[1] = ch__1;
#line 16012 ""
	    i__4[2] = 4, a__3[2] = "off{";
#line 16012 ""
	    chax_(ch__2, (ftnlen)1, &c__92);
#line 16012 ""
	    i__4[3] = 1, a__3[3] = ch__2;
#line 16012 ""
	    i__4[4] = 14, a__3[4] = "afterruleskip}";
#line 16012 ""
	    s_cat(notexq, a__3, i__4, &c__5, (ftnlen)128);
#line 16014 ""
	    lnote += 20;
#line 16015 ""
	} else {
/* Writing concatenation */
#line 16016 ""
	    i__2[0] = lnote, a__1[0] = notexq;
#line 16016 ""
	    i__2[1] = 1, a__1[1] = "}";
#line 16016 ""
	    s_cat(notexq, a__1, i__2, &c__2, (ftnlen)128);
#line 16017 ""
	    ++lnote;
#line 16018 ""
	}
/* Writing concatenation */
#line 16019 ""
	i__3[0] = lnote, a__2[0] = notexq;
#line 16019 ""
	chax_(ch__1, (ftnlen)1, &c__92);
#line 16019 ""
	i__3[1] = 1, a__2[1] = ch__1;
#line 16019 ""
	i__3[2] = 3, a__2[2] = "en%";
#line 16019 ""
	s_cat(notexq, a__2, i__3, &c__3, (ftnlen)128);
#line 16020 ""
	lnote += 4;
#line 16021 ""
	s_wsfe(&io___947);
#line 16021 ""
	do_fio(&c__1, notexq, lnote);
#line 16021 ""
	e_wsfe();
#line 16022 ""
L1:
#line 16022 ""
	;
#line 16022 ""
    }
#line 16023 ""
    *ispstie = ! (*ispstie);
#line 16024 ""
    return 0;
} /* linebreakties_ */

/* Subroutine */ int littex_(integer *islur, integer *nnl, integer *iv, 
	logical *topmods, char *lineq, integer *iccount, ftnlen lineq_len)
{
    /* System generated locals */
    address a__1[2], a__2[3];
    integer i__1[2], i__2[3];
    char ch__1[1], ch__2[129];
    olist o__1;

    /* Builtin functions */
    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
    integer s_wsle(cilist *), e_wsle(void), do_lio(integer *, integer *, char 
	    *, ftnlen), s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), 
	    e_wsfe(void), f_open(olist *);

    /* Local variables */
    extern /* Character */ VOID chax_(char *, ftnlen, integer *);
    static char durq[1];
    extern /* Subroutine */ int stop1_(void);
    static logical merge;
    static integer itype;
    extern /* Subroutine */ int getchar_(char *, integer *, char *, ftnlen, 
	    ftnlen);

    /* Fortran I/O blocks */
    static cilist io___951 = { 0, 6, 0, 0, 0 };
    static cilist io___952 = { 0, 6, 0, 0, 0 };
    static cilist io___953 = { 0, 15, 0, "(/,a)", 0 };
    static cilist io___954 = { 0, 11, 0, "(a)", 0 };
    static cilist io___955 = { 0, 16, 0, "(a)", 0 };


#line 16042 ""
    /* Parameter adjustments */
#line 16042 ""
    islur -= 25;
#line 16042 ""

#line 16042 ""
    /* Function Body */
#line 16042 ""
    merge = FALSE_;
#line 16043 ""
    if (comgrace_1.nlit > 0) {
#line 16044 ""
	merge = *iv == comgrace_1.ivlit[comgrace_1.nlit - 1] && *nnl == 
		comgrace_1.iplit[comgrace_1.nlit - 1];
#line 16045 ""
    }
#line 16046 ""
    ++comgrace_1.nlit;
#line 16047 ""
    comgrace_1.ivlit[comgrace_1.nlit - 1] = *iv;
#line 16048 ""
    comgrace_1.iplit[comgrace_1.nlit - 1] = *nnl;
#line 16049 ""
    itype = 1;
#line 16050 ""
L17:
#line 16050 ""
    getchar_(lineq, iccount, durq, (ftnlen)128, (ftnlen)1);
#line 16051 ""
    chax_(ch__1, (ftnlen)1, &c__92);
#line 16051 ""
    if (*(unsigned char *)durq == *(unsigned char *)&ch__1[0]) {
#line 16052 ""
	++itype;
#line 16053 ""
	goto L17;
#line 16054 ""
    }
/* Writing concatenation */
#line 16055 ""
    chax_(ch__1, (ftnlen)1, &c__92);
#line 16055 ""
    i__1[0] = 1, a__1[0] = ch__1;
#line 16055 ""
    i__1[1] = 1, a__1[1] = durq;
#line 16055 ""
    s_cat(comgrace_1.litq + (comgrace_1.nlit - 1 << 7), a__1, i__1, &c__2, (
	    ftnlen)128);
#line 16056 ""
    comgrace_1.lenlit[comgrace_1.nlit - 1] = 2;
#line 16057 ""
L18:
#line 16057 ""
    getchar_(lineq, iccount, durq, (ftnlen)128, (ftnlen)1);
#line 16058 ""
    chax_(ch__1, (ftnlen)1, &c__92);
#line 16058 ""
    if (*(unsigned char *)durq == *(unsigned char *)&ch__1[0]) {
#line 16059 ""
	getchar_(lineq, iccount, durq, (ftnlen)128, (ftnlen)1);
#line 16060 ""
	if (*(unsigned char *)durq != ' ') {

/*  Starting a new tex command within the string */

/* Writing concatenation */
#line 16064 ""
	    i__2[0] = comgrace_1.lenlit[comgrace_1.nlit - 1], a__2[0] = 
		    comgrace_1.litq + (comgrace_1.nlit - 1 << 7);
#line 16064 ""
	    chax_(ch__1, (ftnlen)1, &c__92);
#line 16064 ""
	    i__2[1] = 1, a__2[1] = ch__1;
#line 16064 ""
	    i__2[2] = 1, a__2[2] = durq;
#line 16064 ""
	    s_cat(comgrace_1.litq + (comgrace_1.nlit - 1 << 7), a__2, i__2, &
		    c__3, (ftnlen)128);
#line 16065 ""
	    comgrace_1.lenlit[comgrace_1.nlit - 1] += 2;
#line 16066 ""
	    goto L18;
#line 16067 ""
	}
#line 16068 ""
    } else {
/* Writing concatenation */
#line 16069 ""
	i__1[0] = comgrace_1.lenlit[comgrace_1.nlit - 1], a__1[0] = 
		comgrace_1.litq + (comgrace_1.nlit - 1 << 7);
#line 16069 ""
	i__1[1] = 1, a__1[1] = durq;
#line 16069 ""
	s_cat(comgrace_1.litq + (comgrace_1.nlit - 1 << 7), a__1, i__1, &c__2,
		 (ftnlen)128);
#line 16070 ""
	++comgrace_1.lenlit[comgrace_1.nlit - 1];
#line 16071 ""
	goto L18;
#line 16072 ""
    }

/*  If here, just read backslash-blank so string is done */

#line 16076 ""
    if (itype == 1) {
#line 16077 ""
	islur[*iv + *nnl * 24] = bit_set(islur[*iv + *nnl * 24],16);
#line 16078 ""
	if (merge) {

/*  There are 2 separate strings on the same note, so merge them. */

#line 16082 ""
	    --comgrace_1.nlit;
/* Writing concatenation */
#line 16083 ""
	    i__1[0] = comgrace_1.lenlit[comgrace_1.nlit - 1], a__1[0] = 
		    comgrace_1.litq + (comgrace_1.nlit - 1 << 7);
#line 16083 ""
	    i__1[1] = comgrace_1.lenlit[comgrace_1.nlit], a__1[1] = 
		    comgrace_1.litq + (comgrace_1.nlit << 7);
#line 16083 ""
	    s_cat(comgrace_1.litq + (comgrace_1.nlit - 1 << 7), a__1, i__1, &
		    c__2, (ftnlen)128);
#line 16085 ""
	    comgrace_1.lenlit[comgrace_1.nlit - 1] += comgrace_1.lenlit[
		    comgrace_1.nlit];
#line 16086 ""
	    if (comgrace_1.lenlit[comgrace_1.nlit - 1] > 128) {
#line 16087 ""
		s_wsle(&io___951);
#line 16087 ""
		e_wsle();
#line 16088 ""
		s_wsle(&io___952);
#line 16088 ""
		do_lio(&c__9, &c__1, "Merged type-1 TeX strings longer than "\
			"128 characters", (ftnlen)52);
#line 16088 ""
		e_wsle();
#line 16090 ""
		s_wsfe(&io___953);
#line 16090 ""
		do_fio(&c__1, "Merged type-1 TeX strings longer than 128 cha"\
			"racters", (ftnlen)52);
#line 16090 ""
		e_wsfe();
#line 16092 ""
		stop1_();
#line 16093 ""
	    }
#line 16094 ""
	}
#line 16095 ""
    } else {

/*  Type 2 or 3. */

#line 16099 ""
	if (itype == 3) {

/*  Write the string NOW */

#line 16103 ""
	    if (comlast_1.islast) {
#line 16103 ""
		s_wsfe(&io___954);
/* Writing concatenation */
#line 16103 ""
		i__1[0] = comgrace_1.lenlit[comgrace_1.nlit - 1], a__1[0] = 
			comgrace_1.litq + (comgrace_1.nlit - 1 << 7);
#line 16103 ""
		i__1[1] = 1, a__1[1] = "%";
#line 16103 ""
		s_cat(ch__2, a__1, i__1, &c__2, (ftnlen)129);
#line 16103 ""
		do_fio(&c__1, ch__2, comgrace_1.lenlit[comgrace_1.nlit - 1] + 
			1);
#line 16103 ""
		e_wsfe();
#line 16103 ""
	    }
#line 16105 ""
	} else {

/*  Must go at top */

#line 16109 ""
	    if (! (*topmods)) {
#line 16110 ""
		*topmods = TRUE_;
#line 16111 ""
		o__1.oerr = 0;
#line 16111 ""
		o__1.ounit = 16;
#line 16111 ""
		o__1.ofnm = 0;
#line 16111 ""
		o__1.orl = 0;
#line 16111 ""
		o__1.osta = "SCRATCH";
#line 16111 ""
		o__1.oacc = 0;
#line 16111 ""
		o__1.ofm = 0;
#line 16111 ""
		o__1.oblnk = 0;
#line 16111 ""
		f_open(&o__1);
#line 16112 ""
	    }

/*  Must write '%' here rather than later, in case string ends with blank. */

#line 16116 ""
	    s_wsfe(&io___955);
/* Writing concatenation */
#line 16116 ""
	    i__1[0] = comgrace_1.lenlit[comgrace_1.nlit - 1], a__1[0] = 
		    comgrace_1.litq + (comgrace_1.nlit - 1 << 7);
#line 16116 ""
	    i__1[1] = 1, a__1[1] = "%";
#line 16116 ""
	    s_cat(ch__2, a__1, i__1, &c__2, (ftnlen)129);
#line 16116 ""
	    do_fio(&c__1, ch__2, comgrace_1.lenlit[comgrace_1.nlit - 1] + 1);
#line 16116 ""
	    e_wsfe();
#line 16117 ""
	}
#line 16118 ""
	--comgrace_1.nlit;
#line 16119 ""
    }
#line 16120 ""
    return 0;
} /* littex_ */

integer llen_(char *strq, integer *n, ftnlen strq_len)
{
    /* System generated locals */
    integer ret_val;

#line 16124 ""
    for (ret_val = *n; ret_val >= 0; --ret_val) {
#line 16125 ""
	if (*(unsigned char *)&strq[ret_val - 1] != ' ') {
#line 16125 ""
	    return ret_val;
#line 16125 ""
	}
#line 16126 ""
/* L1: */
#line 16126 ""
    }
#line 16127 ""
    return ret_val;
} /* llen_ */

integer log2_(integer *n)
{
    /* System generated locals */
    integer ret_val;

    /* Builtin functions */
    double log(doublereal);


/* 5/25/08 Modify to allow more slurs */

#line 16132 ""
    ret_val = (integer) (log(*n * 1.) / .693147181 + 2e-8);
#line 16133 ""
    return ret_val;
} /* log2_ */

/* Subroutine */ int logbeam_(integer *numnew, integer *nip1, integer *nip2)
{
    /* System generated locals */
    integer i__1, i__2, i__3;
    real r__1;
    char ch__1[1];

    /* Builtin functions */
    double log(doublereal);

    /* Local variables */
    extern integer igetbits_(integer *, integer *, integer *);
    static integer ib, iip;
    static real sum;
    static integer iip1;
    extern integer log2_(integer *);
    static integer iiip;
    extern /* Character */ VOID ulfq_(char *, ftnlen, real *, integer *);
    extern integer ncmid_(integer *, integer *);
    static integer ndoub, multx, nrests, numnow;
    static logical isxtup;
    extern /* Subroutine */ int setbits_(integer *, integer *, integer *, 
	    integer *);

#line 16152 ""
    all_1.ibm1[commvl_1.ivx + *numnew * 24 - 25] = *nip1;
#line 16153 ""
    all_1.ibm2[commvl_1.ivx + *numnew * 24 - 25] = *nip2;
#line 16154 ""
    numnow = *numnew;
#line 16155 ""
    if (*numnew > 1) {

/*  If it starts before any others, must put it in order */

#line 16159 ""
	for (ib = *numnew - 1; ib >= 1; --ib) {
#line 16160 ""
	    if (all_1.ibm1[commvl_1.ivx + ib * 24 - 25] < *nip1) {
#line 16160 ""
		goto L12;
#line 16160 ""
	    }
#line 16161 ""
	    all_1.ibm1[commvl_1.ivx + (ib + 1) * 24 - 25] = all_1.ibm1[
		    commvl_1.ivx + ib * 24 - 25];
#line 16162 ""
	    all_1.ibm2[commvl_1.ivx + (ib + 1) * 24 - 25] = all_1.ibm2[
		    commvl_1.ivx + ib * 24 - 25];
#line 16163 ""
	    *(unsigned char *)&all_1.ulq[commvl_1.ivx + (ib + 1) * 24 - 25] = 
		    *(unsigned char *)&all_1.ulq[commvl_1.ivx + ib * 24 - 25];
#line 16164 ""
	    all_1.ibm1[commvl_1.ivx + ib * 24 - 25] = *nip1;
#line 16165 ""
	    all_1.ibm2[commvl_1.ivx + ib * 24 - 25] = *nip2;
#line 16166 ""
	    numnow = ib;
#line 16167 ""
/* L11: */
#line 16167 ""
	}
#line 16168 ""
L12:
#line 16169 ""
	;
#line 16169 ""
    }
#line 16170 ""
    sum = 0.f;

/* Beam has non-xtup within */

#line 16174 ""
    nrests = 0;
#line 16175 ""
    isxtup = FALSE_;
#line 16176 ""
    i__1 = *nip2;
#line 16176 ""
    for (iip = *nip1; iip <= i__1; ++iip) {
#line 16177 ""
	if (bit_test(all_1.islur[commvl_1.ivx + *nip1 * 24 - 25],21)) {

/*  Forced multiplicity */

#line 16181 ""
	    i__2 = igetbits_(&all_1.islur[commvl_1.ivx + *nip1 * 24 - 25], &
		    c__3, &c__22) + 8;
#line 16181 ""
	    setbits_(&all_1.mult[commvl_1.ivx + iip * 24 - 25], &c__4, &c__0, 
		    &i__2);
#line 16183 ""
	} else if (! isxtup) {
#line 16184 ""
	    if (all_1.nodur[commvl_1.ivx + iip * 24 - 25] > 0) {
#line 16185 ""
		i__2 = 4 - log2_(&all_1.nodur[commvl_1.ivx + iip * 24 - 25]) 
			+ 8;
#line 16185 ""
		setbits_(&all_1.mult[commvl_1.ivx + iip * 24 - 25], &c__4, &
			c__0, &i__2);
#line 16186 ""
	    } else {

/*  Start xtup within forced beam */

#line 16190 ""
		isxtup = TRUE_;
#line 16191 ""
		iip1 = iip;
#line 16192 ""
	    }
#line 16193 ""
	} else if (isxtup && all_1.nodur[commvl_1.ivx + iip * 24 - 25] > 0) {

/*  End of xtup within forced beam.  Must count doubled notes */

#line 16197 ""
	    ndoub = 0;
#line 16198 ""
	    i__2 = iip;
#line 16198 ""
	    for (iiip = iip1; iiip <= i__2; ++iiip) {
#line 16199 ""
		if (bit_test(all_1.nacc[commvl_1.ivx + iiip * 24 - 25],18)) {
#line 16199 ""
		    ++ndoub;
#line 16199 ""
		}
#line 16200 ""
/* L1: */
#line 16200 ""
	    }
#line 16201 ""
	    multx = (integer) ((log(iip + 1.f - iip1 + ndoub) * .952f - log(
		    all_1.nodur[commvl_1.ivx + iip * 24 - 25] / 2.f)) / 
		    .69315f + 13.429f) - 10;
#line 16203 ""
	    i__2 = iip;
#line 16203 ""
	    for (iiip = iip1; iiip <= i__2; ++iiip) {
#line 16204 ""
		i__3 = multx + 8;
#line 16204 ""
		setbits_(&all_1.mult[commvl_1.ivx + iiip * 24 - 25], &c__4, &
			c__0, &i__3);

/*  Note the following still works after making mult only the 1st 4 bits. */

#line 16208 ""
		if (bit_test(all_1.nacc[commvl_1.ivx + iiip * 24 - 25],18)) {
#line 16208 ""
		    --all_1.mult[commvl_1.ivx + iiip * 24 - 25];
#line 16208 ""
		}
#line 16210 ""
		if (bit_test(all_1.nacc[commvl_1.ivx + iiip * 24 - 25],19)) {
#line 16211 ""
		    ++all_1.mult[commvl_1.ivx + iiip * 24 - 25];
#line 16212 ""
		} else if (iiip > 1) {
#line 16213 ""
		    if (bit_test(all_1.nacc[commvl_1.ivx + (iiip - 1) * 24 - 
			    25],19)) {
#line 16213 ""
			++all_1.mult[commvl_1.ivx + iiip * 24 - 25];
#line 16213 ""
		    }
#line 16215 ""
		}
#line 16216 ""
/* L74: */
#line 16216 ""
	    }
#line 16217 ""
	    isxtup = FALSE_;
#line 16218 ""
	}
#line 16219 ""
	if (bit_test(all_1.irest[commvl_1.ivx + iip * 24 - 25],0)) {
#line 16220 ""
	    ++nrests;
#line 16221 ""
	} else {
#line 16222 ""
	    sum += all_1.nolev[commvl_1.ivx + iip * 24 - 25];
#line 16223 ""
	}
#line 16224 ""
/* L9: */
#line 16224 ""
    }

/*  Set beam up-down-ness */

#line 16228 ""
    if (comfb_1.ifb > 0 && *(unsigned char *)&comfb_1.ulfbq[commvl_1.ivx + 
	    max(1,comfb_1.ifb) * 24 - 25] != 'x') {
#line 16229 ""
	if (*(unsigned char *)&comfb_1.ulfbq[commvl_1.ivx + comfb_1.ifb * 24 
		- 25] == 'f') {

/*  Get default, then trade "l" and "u" */

#line 16233 ""
	    r__1 = sum / (*nip2 - *nip1 + 1 - nrests);
#line 16233 ""
	    i__1 = ncmid_(&all_1.iv, nip1);
#line 16233 ""
	    ulfq_(ch__1, (ftnlen)1, &r__1, &i__1);
#line 16233 ""
	    *(unsigned char *)&all_1.ulq[commvl_1.ivx + numnow * 24 - 25] = (
		    char) (225 - *(unsigned char *)&ch__1[0]);
#line 16235 ""
	} else {
#line 16236 ""
	    *(unsigned char *)&all_1.ulq[commvl_1.ivx + comfb_1.ifb * 24 - 25]
		     = *(unsigned char *)&comfb_1.ulfbq[commvl_1.ivx + 
		    comfb_1.ifb * 24 - 25];
#line 16237 ""
	}

/*  This probably works only because forced beams are done first, so they */
/*  don't have to be re-sorted within each voice. ???? */

#line 16242 ""
    } else if (commvl_1.nvmx[all_1.iv - 1] == 2) {

/*  Multi-voice per staff */

#line 16246 ""
	if (commvl_1.ivx <= all_1.nv) {
#line 16247 ""
	    *(unsigned char *)&all_1.ulq[commvl_1.ivx + numnow * 24 - 25] = 
		    'l';
#line 16248 ""
	} else {
#line 16249 ""
	    *(unsigned char *)&all_1.ulq[commvl_1.ivx + numnow * 24 - 25] = 
		    'u';
#line 16250 ""
	}
#line 16251 ""
    } else {

/*  Defaults */

#line 16255 ""
	r__1 = sum / (*nip2 - *nip1 + 1 - nrests);
#line 16255 ""
	i__1 = ncmid_(&all_1.iv, nip1);
#line 16255 ""
	ulfq_(ch__1, (ftnlen)1, &r__1, &i__1);
#line 16255 ""
	*(unsigned char *)&all_1.ulq[commvl_1.ivx + numnow * 24 - 25] = *(
		unsigned char *)&ch__1[0];
#line 16257 ""
    }
#line 16258 ""
    return 0;
} /* logbeam_ */

/* Subroutine */ int m1rec1_(char *lineq, integer *iccount, integer *ibarcnt, 
	integer *ibaroff, integer *nbars, integer *ndxm, ftnlen lineq_len)
{
    /* System generated locals */
    integer i__1, i__2;

    /* Builtin functions */
    integer i_indx(char *, char *, ftnlen, ftnlen), s_cmp(char *, char *, 
	    ftnlen, ftnlen);

    /* Local variables */
    extern /* Subroutine */ int stop1_(void), errmsg_(char *, integer *, 
	    integer *, char *, ftnlen, ftnlen);
    extern integer ntindex_(char *, char *, integer *, ftnlen, ftnlen);


/*  This is called when (a) macro recording is just starting and */
/*  (b) at the start of a new line, if recording is on */

#line 16274 ""
    inbuff_1.lbuf[0] = inbuff_1.lbuf[0];
#line 16275 ""
    if (! commac_1.mrecord) {

/*  Starting the macro */

#line 16279 ""
	c1ommac_1.ip1mac[commac_1.macnum - 1] = inbuff_1.ipbuf - 
		inbuff_1.lbuf[inbuff_1.ilbuf - 2] + *iccount;
#line 16280 ""
	c1ommac_1.il1mac[commac_1.macnum - 1] = inbuff_1.ilbuf - 1;
#line 16281 ""
	c1ommac_1.ic1mac[commac_1.macnum - 1] = *iccount;
#line 16282 ""
	commac_1.mrecord = TRUE_;
#line 16283 ""
    }
#line 16284 ""
    if (*iccount < 128) {
#line 16285 ""
	i__1 = *iccount;
#line 16285 ""
	*ndxm = i_indx(lineq + i__1, "M", 128 - i__1, (ftnlen)1);
#line 16286 ""
	if (*ndxm > 0) {
#line 16286 ""
	    i__1 = *iccount;
#line 16286 ""
	    i__2 = 128 - *iccount;
#line 16286 ""
	    *ndxm = ntindex_(lineq + i__1, "M", &i__2, 128 - i__1, (ftnlen)1);
#line 16286 ""
	}
#line 16288 ""
	if (*ndxm > 0) {

/*  This line ends the macro. */

#line 16292 ""
	    i__1 = *iccount + *ndxm;
#line 16292 ""
	    if (s_cmp(lineq + i__1, " ", *iccount + *ndxm + 1 - i__1, (ftnlen)
		    1) != 0) {
#line 16293 ""
		i__1 = *iccount + *ndxm + 1;
#line 16293 ""
		i__2 = *ibarcnt - *ibaroff + *nbars + 1;
#line 16293 ""
		errmsg_(lineq, &i__1, &i__2, "Improper macro termination!", (
			ftnlen)128, (ftnlen)27);
#line 16295 ""
		stop1_();
#line 16296 ""
	    }
#line 16297 ""
	    c1ommac_1.ip2mac[commac_1.macnum - 1] = inbuff_1.ipbuf - 
		    inbuff_1.lbuf[inbuff_1.ilbuf - 2] + *iccount + *ndxm;
#line 16298 ""
	    c1ommac_1.il2mac[commac_1.macnum - 1] = inbuff_1.ilbuf - 1;
#line 16299 ""
	    commac_1.mrecord = FALSE_;
#line 16300 ""
	}
#line 16301 ""
    }
#line 16302 ""
    return 0;
} /* m1rec1_ */

/* Subroutine */ int make1bar_(integer *ibmrep, real *tglp1, real *tstart, 
	logical *cwrest, real *squez, integer *istop, integer *numbms, 
	integer *istart)
{
    /* System generated locals */
    integer i__1, i__2, i__3, i__4, i__5, i__6;
    real r__1, r__2;

    /* Builtin functions */
    integer s_wsle(cilist *), e_wsle(void), do_lio(integer *, integer *, char 
	    *, ftnlen), s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), 
	    e_wsfe(void);

    /* Local variables */
    extern /* Subroutine */ int findbeam_(integer *, integer *, integer *);
    extern integer igetbits_(integer *, integer *, integer *);
    extern doublereal getsquez_(integer *, integer *, real *, real *, real *);
    static integer ib, in, ip, kp, kv, ib1, ib2, ip1, cnn[24], inj, iin, iiv, 
	    isl;
    static real xit[24];
    extern doublereal feon_(real *);
    static integer irep;
    static real tmin;
    static integer iivx, itbb1, itbb2, itbb3, inip1;
    static real tglp2;
    extern /* Subroutine */ int addfb_(integer *, integer *, real *, real *, 
	    real *, char *, integer *, ftnlen);
    static integer mapfb[24];
    static real deskb;
    extern doublereal fnote_(integer *, integer *, integer *, integer *);
    static real eskzb;
    static integer ibrep;
    static real tminn;
    static integer nxtup, nip1fb, nip2fb, ib1now, ib2now, ifbadd;
    static real t1xtup[20];
    static integer nfbbar;
    static logical infbmx[24];
    static integer ifbnow[24];
    static logical inxtup[24];
    static integer numnew, mapnow, nxtnow[24];
    static real xsquez;
    extern /* Subroutine */ int logbeam_(integer *, integer *, integer *), 
	    setbits_(integer *, integer *, integer *, integer *);

    /* Fortran I/O blocks */
    static cilist io___1000 = { 0, 6, 0, 0, 0 };
    static cilist io___1001 = { 0, 6, 0, 0, 0 };
    static cilist io___1002 = { 0, 15, 0, "(/a)", 0 };



/*  Above are factors for grace note, clef spacing. (fraction of wheadpt) */
/*  In 1.04, moved to block data subprogram */

#line 16394 ""
    /* Parameter adjustments */
#line 16394 ""
    --istart;
#line 16394 ""
    --numbms;
#line 16394 ""
    --istop;
#line 16394 ""
    --squez;
#line 16394 ""
    --cwrest;
#line 16394 ""
    --tstart;
#line 16394 ""

#line 16394 ""
    /* Function Body */
#line 16394 ""
    if (commidi_1.ismidi) {

/*  Initialize for this bar the accidental counter for the midi file. */
/*    naccim(icm) = # of accidentals from earlier in the bar */

#line 16399 ""
	i__1 = all_1.nv;
#line 16399 ""
	for (all_1.iv = 1; all_1.iv <= i__1; ++all_1.iv) {
#line 16400 ""
	    i__2 = commvl_1.nvmx[all_1.iv - 1];
#line 16400 ""
	    for (kv = 1; kv <= i__2; ++kv) {
#line 16401 ""
		commidi_1.naccim[commidi_1.midchan[all_1.iv + kv * 24 - 25]] =
			 0;
#line 16402 ""
/* L4599: */
#line 16402 ""
	    }
#line 16403 ""
/* L45: */
#line 16403 ""
	}
#line 16404 ""
    }

/*  Time from start of gulp to end of bar, used with forced beams */

#line 16408 ""
    tglp2 = (real) (all_1.lenb0 + all_1.ibar * all_1.lenb1);
#line 16409 ""
    if (all_1.lenb0 > 0) {
#line 16409 ""
	tglp2 -= all_1.lenb1;
#line 16409 ""
    }
#line 16410 ""
    *tglp1 = tglp2 - all_1.lenbar;

/*  infbmx will only be true if in xtup that is NOT in explicit forced beam. */

#line 16414 ""
    i__1 = all_1.nv;
#line 16414 ""
    for (all_1.iv = 1; all_1.iv <= i__1; ++all_1.iv) {
#line 16415 ""
	i__2 = commvl_1.nvmx[all_1.iv - 1];
#line 16415 ""
	for (kv = 1; kv <= i__2; ++kv) {
#line 16416 ""
	    commvl_1.ivx = commvl_1.ivmx[all_1.iv + kv * 24 - 25];
#line 16417 ""
	    cwrest[commvl_1.ivx] = FALSE_;
#line 16418 ""
	    infbmx[commvl_1.ivx - 1] = FALSE_;
#line 16419 ""
	    inxtup[commvl_1.ivx - 1] = FALSE_;
#line 16420 ""
	    if (all_1.ibar > 1) {
#line 16421 ""
		all_1.nn[commvl_1.ivx - 1] = all_1.nib[commvl_1.ivx + 
			all_1.ibar * 24 - 25] - all_1.nib[commvl_1.ivx + (
			all_1.ibar - 1) * 24 - 25];
#line 16422 ""
	    } else {
#line 16423 ""
		all_1.nn[commvl_1.ivx - 1] = all_1.nib[commvl_1.ivx + 
			all_1.ibar * 24 - 25];
#line 16424 ""
	    }
#line 16425 ""
/* L1999: */
#line 16425 ""
	}
#line 16426 ""
/* L1: */
#line 16426 ""
    }

/* initialize list note counter, time(iv), curr. note(iv).  The loop to 4 */
/*   ONLY initializes each voice. */

#line 16431 ""
    in = 1;
#line 16432 ""
    nxtup = 0;
#line 16433 ""
    comarp_1.narp = 0;
#line 16434 ""
    i__1 = all_1.nv;
#line 16434 ""
    for (all_1.iv = 1; all_1.iv <= i__1; ++all_1.iv) {
#line 16435 ""
	i__2 = commvl_1.nvmx[all_1.iv - 1];
#line 16435 ""
	for (kv = 1; kv <= i__2; ++kv) {
#line 16436 ""
	    commvl_1.ivx = commvl_1.ivmx[all_1.iv + kv * 24 - 25];
#line 16437 ""
	    comcwrf_1.cwrferm[commvl_1.ivx - 1] = FALSE_;
#line 16438 ""
	    cnn[commvl_1.ivx - 1] = 1;
#line 16439 ""
	    all_1.ivxo[in - 1] = commvl_1.ivx;
#line 16440 ""
	    all_1.ipo[in - 1] = cnn[commvl_1.ivx - 1];
#line 16441 ""
	    all_1.tnote[in - 1] = fnote_(all_1.nodur, &commvl_1.ivx, &c__1, 
		    all_1.nacc);
#line 16442 ""
	    all_1.to[in - 1] = 0.f;
#line 16443 ""
	    xit[commvl_1.ivx - 1] = all_1.tnote[in - 1];

/*  Note that xit(ivx) is to END of note in voice, but it1xtup is start time. */

#line 16447 ""
	    if (all_1.nodur[commvl_1.ivx + all_1.ipo[in - 1] * 24 - 25] == 0) 
		    {

/*  First note of xtuplet at start of bar in voice ivx. */

#line 16451 ""
		++nxtup;
#line 16452 ""
		nxtnow[commvl_1.ivx - 1] = nxtup;
#line 16453 ""
		inxtup[commvl_1.ivx - 1] = TRUE_;
#line 16454 ""
		t1xtup[nxtup - 1] = 0.f;

/*  Xtup at start of bar.  If no explicit forced beam, start one, set */
/*  signal infbmx, and save number ifbnow for use at termination. */

#line 16459 ""
		if (comfb_1.nfb[commvl_1.ivx - 1] > 0) {
#line 16460 ""
		    i__3 = comfb_1.nfb[commvl_1.ivx - 1];
#line 16460 ""
		    for (comfb_1.ifb = 1; comfb_1.ifb <= i__3; ++comfb_1.ifb) 
			    {
#line 16461 ""
			if (comfb_1.t1fb[commvl_1.ivx + comfb_1.ifb * 24 - 25]
				 > *tglp1 + xit[commvl_1.ivx - 1] + 
				comtol_1.tol) {

/*  No explicit fb here; so exit loop and insert one. */

#line 16465 ""
			    goto L61;
#line 16466 ""
			} else if (comfb_1.t1fb[commvl_1.ivx + comfb_1.ifb * 
				24 - 25] < *tglp1 + xit[commvl_1.ivx - 1] + 
				comtol_1.tol && comfb_1.t2fb[commvl_1.ivx + 
				comfb_1.ifb * 24 - 25] > *tglp1 + xit[
				commvl_1.ivx - 1] + comtol_1.tol) {

/*  IS explicit fb here; must NOT insert one */

#line 16471 ""
			    goto L62;
#line 16472 ""
			}
#line 16473 ""
/* L60: */
#line 16473 ""
		    }
#line 16474 ""
		}
#line 16475 ""
L61:

/*  If here, xtup isn't in explicit fb, so must insert one */

#line 16479 ""
		infbmx[commvl_1.ivx - 1] = TRUE_;
#line 16480 ""
		r__1 = t1xtup[nxtup - 1] + *tglp1;
#line 16480 ""
		addfb_(comfb_1.nfb, &commvl_1.ivx, &r__1, comfb_1.t1fb, 
			comfb_1.t2fb, comfb_1.ulfbq, &ifbadd, (ftnlen)1);
#line 16482 ""
		ifbnow[commvl_1.ivx - 1] = ifbadd;
#line 16483 ""
	    }
#line 16484 ""
L62:
#line 16485 ""
	    if ((r__1 = xit[commvl_1.ivx - 1] - all_1.lenbar, dabs(r__1)) < 
		    comtol_1.tol) {
#line 16485 ""
		xit[commvl_1.ivx - 1] = 1e3f;
#line 16485 ""
	    }
#line 16486 ""
	    ++in;
#line 16487 ""
/* L4999: */
#line 16487 ""
	}
#line 16488 ""
/* L4: */
#line 16488 ""
    }

/*  Build the list:  This is a manual loop starting at 5 */

#line 16492 ""
L5:

/*  Determine which voice comes next from end of notes done so far. */
/*  tmin is the earliest ending time of notes done so far */

#line 16497 ""
    tmin = 1e3f;
#line 16498 ""
    i__1 = all_1.nv;
#line 16498 ""
    for (iiv = 1; iiv <= i__1; ++iiv) {
#line 16499 ""
	i__2 = commvl_1.nvmx[iiv - 1];
#line 16499 ""
	for (kv = 1; kv <= i__2; ++kv) {
#line 16500 ""
	    iivx = commvl_1.ivmx[iiv + kv * 24 - 25];
/* Computing MIN */
#line 16501 ""
	    r__1 = tmin, r__2 = xit[iivx - 1];
#line 16501 ""
	    tminn = dmin(r__1,r__2);
#line 16502 ""
	    if (tminn < tmin - comtol_1.tol) {
#line 16503 ""
		tmin = tminn;
#line 16504 ""
		commvl_1.ivx = iivx;
#line 16505 ""
	    }
#line 16506 ""
/* L6999: */
#line 16506 ""
	}
#line 16507 ""
/* L6: */
#line 16507 ""
    }
#line 16508 ""
    if ((r__1 = tmin - 1e3f, dabs(r__1)) < comtol_1.tol) {
#line 16508 ""
	goto L7;
#line 16508 ""
    }
#line 16509 ""
    all_1.ivxo[in - 1] = commvl_1.ivx;
#line 16510 ""
    ++cnn[commvl_1.ivx - 1];
#line 16511 ""
    all_1.ipo[in - 1] = cnn[commvl_1.ivx - 1];
#line 16512 ""
    all_1.to[in - 1] = tmin;

/*  Check if this voice is done */

#line 16516 ""
    all_1.tnote[in - 1] = fnote_(all_1.nodur, &commvl_1.ivx, &cnn[
	    commvl_1.ivx - 1], all_1.nacc);
#line 16517 ""
    if (cnn[commvl_1.ivx - 1] == all_1.nn[commvl_1.ivx - 1]) {
#line 16518 ""
	xit[commvl_1.ivx - 1] = 1e3f;
#line 16519 ""
    } else {
#line 16520 ""
	xit[commvl_1.ivx - 1] += all_1.tnote[in - 1];
#line 16521 ""
    }

/*  Flag xtups */

#line 16525 ""
    if (all_1.nodur[commvl_1.ivx + cnn[commvl_1.ivx - 1] * 24 - 25] == 0) {
#line 16526 ""
	if (! inxtup[commvl_1.ivx - 1]) {

/*  First note of xtup, not at start of bar. */

#line 16530 ""
	    ++nxtup;
#line 16531 ""
	    nxtnow[commvl_1.ivx - 1] = nxtup;
#line 16532 ""
	    inxtup[commvl_1.ivx - 1] = TRUE_;
#line 16533 ""
	    t1xtup[nxtup - 1] = xit[commvl_1.ivx - 1] - all_1.tnote[in - 1];

/*  (Note: can't be on last note in voice, so xit(ivx) <> 1000) */
/*  Put xtuplet in a forced beam if not already in forced beam */

#line 16538 ""
	    if (comfb_1.nfb[commvl_1.ivx - 1] > 0) {
#line 16539 ""
		i__1 = comfb_1.nfb[commvl_1.ivx - 1];
#line 16539 ""
		for (comfb_1.ifb = 1; comfb_1.ifb <= i__1; ++comfb_1.ifb) {
#line 16540 ""
		    if (comfb_1.t1fb[commvl_1.ivx + comfb_1.ifb * 24 - 25] > *
			    tglp1 + xit[commvl_1.ivx - 1] + comtol_1.tol) {

/*  NO explicit bm; put one in */

#line 16544 ""
			goto L71;
#line 16545 ""
		    } else if (comfb_1.t1fb[commvl_1.ivx + comfb_1.ifb * 24 - 
			    25] < *tglp1 + xit[commvl_1.ivx - 1] + 
			    comtol_1.tol && comfb_1.t2fb[commvl_1.ivx + 
			    comfb_1.ifb * 24 - 25] > *tglp1 + xit[
			    commvl_1.ivx - 1] + comtol_1.tol) {

/*  IS explicit bm.  Don't put one */

#line 16550 ""
			goto L72;
#line 16551 ""
		    }
#line 16552 ""
/* L70: */
#line 16552 ""
		}
#line 16553 ""
	    }
#line 16554 ""
L71:

/*  If here, no explicit bm, so put one in */

#line 16558 ""
	    infbmx[commvl_1.ivx - 1] = TRUE_;
#line 16559 ""
	    r__1 = t1xtup[nxtup - 1] + *tglp1;
#line 16559 ""
	    addfb_(comfb_1.nfb, &commvl_1.ivx, &r__1, comfb_1.t1fb, 
		    comfb_1.t2fb, comfb_1.ulfbq, &ifbadd, (ftnlen)1);
#line 16561 ""
	    ifbnow[commvl_1.ivx - 1] = ifbadd;
#line 16562 ""
	}
#line 16563 ""
L72:
#line 16564 ""
	;
#line 16564 ""
    } else if (inxtup[commvl_1.ivx - 1]) {

/*  This test is sufficient because already know nodur>0 */

#line 16568 ""
	inxtup[commvl_1.ivx - 1] = FALSE_;
#line 16569 ""
	if (infbmx[commvl_1.ivx - 1]) {

/*  Xtup is in auto-forced beam, so end it */

#line 16573 ""
	    comfb_1.t2fb[commvl_1.ivx + ifbnow[commvl_1.ivx - 1] * 24 - 25] = 
		    t1xtup[nxtnow[commvl_1.ivx - 1] - 1] + all_1.nodur[
		    commvl_1.ivx + cnn[commvl_1.ivx - 1] * 24 - 25] + *tglp1;
#line 16575 ""
	    infbmx[commvl_1.ivx - 1] = FALSE_;
#line 16576 ""
	}
#line 16577 ""
    }
#line 16578 ""
    if (bit_test(all_1.irest[all_1.ivxo[in - 1] + all_1.ipo[in - 1] * 24 - 25]
	    ,24) || bit_test(all_1.irest[all_1.ivxo[in - 1] + all_1.ipo[in - 
	    1] * 24 - 25],30)) {

/*  For staff jumped beam, flag the first note (lowest voice) at same time. */
/*  Later will start new notes group here. */

#line 16584 ""
	inj = in;
#line 16585 ""
	if (all_1.ivxo[in - 1] > 1) {
#line 16586 ""
	    for (iin = in - 1; iin >= 1; --iin) {
#line 16587 ""
		if (all_1.to[iin - 1] + comtol_1.tol < all_1.to[in - 1]) {
#line 16587 ""
		    goto L41;
#line 16587 ""
		}
#line 16588 ""
		if ((r__1 = all_1.to[iin - 1] - all_1.to[in - 1], dabs(r__1)) 
			< comtol_1.tol) {
#line 16589 ""
		    inj = iin;
#line 16590 ""
		    goto L40;
#line 16591 ""
		}
#line 16592 ""
L40:
#line 16592 ""
		;
#line 16592 ""
	    }
#line 16593 ""
	}
#line 16594 ""
L41:
#line 16595 ""
	all_1.irest[all_1.ivxo[inj - 1] + all_1.ipo[inj - 1] * 24 - 25] = 
		bit_set(all_1.irest[all_1.ivxo[inj - 1] + all_1.ipo[inj - 1] *
		 24 - 25],29);
#line 16596 ""
    }
#line 16597 ""
    ++in;
#line 16598 ""
    goto L5;
#line 16599 ""
L7:
#line 16600 ""
    comntot_1.ntot = in - 1;
#line 16601 ""
    i__1 = comntot_1.ntot - 1;
#line 16601 ""
    for (in = 1; in <= i__1; ++in) {
#line 16602 ""
	all_1.tno[in - 1] = all_1.to[in] - all_1.to[in - 1];
#line 16603 ""
/* L8: */
#line 16603 ""
    }
#line 16604 ""
    all_1.tno[comntot_1.ntot - 1] = all_1.tnote[comntot_1.ntot - 1];

/*  Done w/ list. Loop for parsing into note blocks: */

#line 16608 ""
    ib = 1;
#line 16609 ""
    istart[1] = 1;
#line 16610 ""
    comnsp_2.space[0] = 0.f;
#line 16611 ""
    in = 1;

/*  A manual loop to set space(ib) and istop(ib) */

#line 16615 ""
L9:
/* Computing MIN */
#line 16617 ""
    i__1 = in + 1;
#line 16617 ""
    commvl_1.ivx = all_1.ivxo[min(i__1,comntot_1.ntot) - 1];
/* Computing MIN */
#line 16618 ""
    i__1 = in + 1;
#line 16618 ""
    ip = all_1.ipo[min(i__1,comntot_1.ntot) - 1];
#line 16619 ""
    isl = all_1.islur[commvl_1.ivx + ip * 24 - 25];
#line 16620 ""
    if (in == comntot_1.ntot || (commvl_1.ivx == 1 && ((isl & 67109216) > 0 ||
	     bit_test(all_1.ipl[ip * 24 - 24],28) || bit_test(all_1.iornq[ip *
	     24],4)) || bit_test(isl,15)) || bit_test(all_1.irest[
	    commvl_1.ivx + ip * 24 - 25],29)) {
/*    *      .or. ornq(1,ip).eq.'g')) .or. btest(isl,15) )) then */
/*  Bits 1-13: stmgx+Tupf._) */
/*  14: Down fermata, was F */
/*  15: Trill w/o "tr", was U */

/*  Checking for start of 2nd part of jumped beam */


/*  Bar end, segno, int. rpt or sig change, clef,end of 1st part of jumped beam; */
/*    flow out of if-loop and into block-wrapup */

/*  10/18/97:  Problem with clef alignment.  Got isl{15} set on lowest-numbered */
/*  voice, but it wasn't first in the list at the same time.  So check if */
/*  prior notes in list have same time */
/*  5/25/98: This stuff causes trouble with just "c2 Ct c", maybe when clef */
/*  changes on last note in the list? */

#line 16641 ""
	if (bit_test(isl,15) && in < comntot_1.ntot) {
#line 16642 ""
	    for (iin = in; iin >= 1; --iin) {
#line 16643 ""
		if (all_1.tno[iin - 1] > comtol_1.tol) {
#line 16644 ""
		    in = iin;
#line 16645 ""
		    all_1.islur[commvl_1.ivx + ip * 24 - 25] = bit_clear(
			    all_1.islur[commvl_1.ivx + ip * 24 - 25],15);
#line 16646 ""
		    all_1.islur[all_1.ivxo[in] + all_1.ipo[in] * 24 - 25] = 
			    bit_set(all_1.islur[all_1.ivxo[in] + all_1.ipo[in]
			     * 24 - 25],15);
#line 16648 ""
		    goto L51;
#line 16649 ""
		}
#line 16650 ""
/* L50: */
#line 16650 ""
	    }
#line 16651 ""
L51:
#line 16652 ""
	    ;
#line 16652 ""
	}
#line 16653 ""
	if (comnsp_2.space[ib - 1] < comtol_1.tol) {
#line 16654 ""
	    comnsp_2.space[ib - 1] = all_1.tno[in - 1];
#line 16655 ""
	    squez[ib] = 1.f;
#line 16656 ""
	}
#line 16657 ""
	istop[ib] = in;
#line 16658 ""
    } else if (comnsp_2.space[ib - 1] < comtol_1.tol) {

/*  space hasn't been set yet, so tentatively set: */

#line 16662 ""
	comnsp_2.space[ib - 1] = all_1.tno[in - 1];
#line 16663 ""
	if (comnsp_2.space[ib - 1] < comtol_1.tol) {
#line 16664 ""
	    ++in;
#line 16665 ""
	} else {
#line 16666 ""
	    squez[ib] = getsquez_(&in, &comntot_1.ntot, &comnsp_2.space[ib - 
		    1], all_1.tnote, all_1.to);
#line 16667 ""
	    istop[ib] = in;
#line 16668 ""
	}
#line 16669 ""
	goto L9;
#line 16670 ""
    } else if (all_1.tno[in] < comtol_1.tol) {

/*  This is not the last note in the group, so */

#line 16674 ""
	++in;
#line 16675 ""
	goto L9;
#line 16676 ""
    } else if ((r__1 = all_1.tno[in] - comnsp_2.space[ib - 1], dabs(r__1)) < 
	    comtol_1.tol) {
#line 16677 ""
	i__1 = in + 1;
#line 16677 ""
	xsquez = getsquez_(&i__1, &comntot_1.ntot, &comnsp_2.space[ib - 1], 
		all_1.tnote, all_1.to);
#line 16678 ""
	if ((r__1 = xsquez - squez[ib], dabs(r__1)) < comtol_1.tol) {

/*  Keep spacing the same, update tentative stop point */

#line 16682 ""
	    ++in;
#line 16683 ""
	    istop[ib] = in;
#line 16684 ""
	    goto L9;
#line 16685 ""
	}
#line 16686 ""
    }

/* At this point istart and istop are good, so finalize block */

#line 16690 ""
    tstart[ib] = all_1.to[istart[ib] - 1];
#line 16691 ""
    if (istop[ib] == comntot_1.ntot) {
#line 16691 ""
	goto L15;
#line 16691 ""
    }
#line 16692 ""
    ++ib;
#line 16693 ""
    istart[ib] = istop[ib - 1] + 1;
#line 16694 ""
    in = istart[ib];

/* Set tentative block space and squeeze-factor for upcoming block */

#line 16698 ""
    comnsp_2.space[ib - 1] = all_1.tno[in - 1];
#line 16699 ""
    if (comnsp_2.space[ib - 1] > comtol_1.tol) {
#line 16699 ""
	squez[ib] = getsquez_(&in, &comntot_1.ntot, &comnsp_2.space[ib - 1], 
		all_1.tnote, all_1.to);
#line 16699 ""
    }
#line 16701 ""
    istop[ib] = in;
#line 16702 ""
    goto L9;
#line 16703 ""
L15:
#line 16704 ""
    comnsp_2.nb = ib;

/*  Invert the list of places into ipl(0-7), making it easier to analyze a voice */

#line 16708 ""
    i__1 = comntot_1.ntot;
#line 16708 ""
    for (in = 1; in <= i__1; ++in) {

/* ??? This may fix extra \loff's (bit 8 of ipl) in measures with >255 notes. */

#line 16712 ""
	comipl2_1.ipl2[all_1.ivxo[in - 1] + all_1.ipo[in - 1] * 24 - 25] = in;
#line 16713 ""
/* L13: */
#line 16713 ""
    }

/*  Compute elemskips from start of bar to each note in the bar, for beam slopes */

#line 16717 ""
    eskzb = 0.f;
#line 16718 ""
    ib = 1;
#line 16719 ""
    i__1 = comntot_1.ntot;
#line 16719 ""
    for (in = 1; in <= i__1; ++in) {
#line 16720 ""
	if (in == istart[ib]) {
#line 16721 ""
	    r__1 = comnsp_2.space[ib - 1] / squez[ib];
#line 16721 ""
	    deskb = squez[ib] * feon_(&r__1);
#line 16722 ""
	} else if (all_1.tno[in - 2] > comtol_1.tol) {
#line 16723 ""
	    eskzb += deskb;
#line 16724 ""
	}
#line 16725 ""
	all_1.eskz[all_1.ivxo[in - 1] + all_1.ipo[in - 1] * 24 - 25] = eskzb;
#line 16726 ""
	comeskz2_1.eskz2[all_1.ivxo[in - 1] + all_1.ipo[in - 1] * 24 - 25] = 
		eskzb;
#line 16727 ""
	if (in == istop[ib]) {
#line 16728 ""
	    eskzb += deskb;
#line 16729 ""
	    ++ib;
#line 16730 ""
	}
#line 16731 ""
/* L30: */
#line 16731 ""
    }

/*  Analyze for beams. */

#line 16735 ""
    i__1 = all_1.nv;
#line 16735 ""
    for (all_1.iv = 1; all_1.iv <= i__1; ++all_1.iv) {
#line 16736 ""
	i__2 = commvl_1.nvmx[all_1.iv - 1];
#line 16736 ""
	for (kv = 1; kv <= i__2; ++kv) {
#line 16737 ""
	    commvl_1.ivx = commvl_1.ivmx[all_1.iv + kv * 24 - 25];
#line 16738 ""
	    numbms[commvl_1.ivx] = 0;
#line 16739 ""
	    mapfb[0] = 0;
#line 16740 ""
	    mapfb[1] = 0;
#line 16741 ""
	    mapfb[2] = 0;
#line 16742 ""
	    mapfb[3] = 0;
#line 16743 ""
	    mapfb[4] = 0;
#line 16744 ""
	    mapfb[5] = 0;

/*  First forced beams. */

#line 16748 ""
	    if (comfb_1.nfb[commvl_1.ivx - 1] > 0) {

/*  tglp2 is time from start of gulp to end of current bar. */

#line 16752 ""
		nfbbar = 0;
#line 16753 ""
		i__3 = comfb_1.nfb[commvl_1.ivx - 1];
#line 16753 ""
		for (comfb_1.ifb = 1; comfb_1.ifb <= i__3; ++comfb_1.ifb) {
#line 16754 ""
		    if (comfb_1.t1fb[commvl_1.ivx + comfb_1.ifb * 24 - 25] > 
			    tglp2 - comtol_1.tol) {
#line 16754 ""
			goto L81;
#line 16754 ""
		    }
#line 16755 ""
		    ++nfbbar;
#line 16756 ""
		    ++numbms[commvl_1.ivx];
#line 16757 ""
		    numnew = numbms[commvl_1.ivx];

/*  Times from beginning of bar */

#line 16761 ""
		    itbb1 = (integer) (comfb_1.t1fb[commvl_1.ivx + 
			    comfb_1.ifb * 24 - 25] - *tglp1 + comtol_1.tol);
#line 16762 ""
		    itbb2 = (integer) (comfb_1.t2fb[commvl_1.ivx + 
			    comfb_1.ifb * 24 - 25] - *tglp1 + comtol_1.tol);
#line 16763 ""
		    i__4 = all_1.nn[commvl_1.ivx - 1];
#line 16763 ""
		    for (ip = 1; ip <= i__4; ++ip) {
#line 16764 ""
			if ((integer) (all_1.to[comipl2_1.ipl2[commvl_1.ivx + 
				ip * 24 - 25] - 1] + comtol_1.tol) == itbb1) {
#line 16765 ""
			    nip1fb = ip;
#line 16766 ""
			    i__5 = all_1.nn[commvl_1.ivx - 1];
#line 16766 ""
			    for (ip1 = ip; ip1 <= i__5; ++ip1) {
#line 16767 ""
				inip1 = comipl2_1.ipl2[commvl_1.ivx + ip1 * 
					24 - 25];
#line 16768 ""
				if ((r__1 = all_1.to[inip1 - 1] + all_1.tnote[
					inip1 - 1] - itbb2, dabs(r__1)) < 
					comtol_1.tol) {
#line 16769 ""
				    nip2fb = ip1;
#line 16770 ""
				    itbb3 = itbb2 - 2;
#line 16771 ""
				    goto L85;
#line 16772 ""
				}
#line 16773 ""
/* L84: */
#line 16773 ""
			    }
#line 16774 ""
			}
#line 16775 ""
/* L83: */
#line 16775 ""
		    }
#line 16776 ""
		    s_wsle(&io___1000);
#line 16776 ""
		    e_wsle();
#line 16777 ""
		    s_wsle(&io___1001);
#line 16777 ""
		    do_lio(&c__9, &c__1, "Timing problem w/ forced beams", (
			    ftnlen)30);
#line 16777 ""
		    e_wsle();
#line 16778 ""
		    s_wsfe(&io___1002);
#line 16778 ""
		    do_fio(&c__1, "Timing problem w/ forced beams", (ftnlen)
			    30);
#line 16778 ""
		    e_wsfe();
#line 16779 ""
L85:
#line 16780 ""
		    logbeam_(&numnew, &nip1fb, &nip2fb);

/*  Set up mapfb for forced beam just logged: */

#line 16784 ""
		    ib1 = itbb1 / 2;
#line 16785 ""
		    ib2 = itbb3 / 2;
#line 16786 ""
		    ibrep = all_1.lenbar / *ibmrep / 2;
#line 16787 ""
		    i__4 = *ibmrep;
#line 16787 ""
		    for (irep = 1; irep <= i__4; ++irep) {
/* Computing MAX */
#line 16788 ""
			i__5 = 0, i__6 = ib1 - (irep - 1) * ibrep;
#line 16788 ""
			ib1now = max(i__5,i__6);
/* Computing MIN */
#line 16789 ""
			i__5 = irep * ibrep - 1, i__6 = ib2 - (irep - 1) * 
				ibrep;
#line 16789 ""
			ib2now = min(i__5,i__6);
#line 16790 ""
			mapnow = 0;
#line 16791 ""
			i__5 = ib2now;
#line 16791 ""
			for (ib = ib1now; ib <= i__5; ++ib) {
#line 16792 ""
			    mapnow = bit_set(mapnow,ib);
#line 16793 ""
/* L87: */
#line 16793 ""
			}
#line 16794 ""
			mapfb[irep - 1] |= mapnow;
#line 16795 ""
/* L86: */
#line 16795 ""
		    }

/*  Since we are cycling thru forced beams, for those that start with a rest and */
/*    have height & slope adjustments, move adjustments to next note. */
/*  060924: Copy to ALL later notes in fb, in case there's more than 1 rest at */
/*    start of beam */

#line 16802 ""
		    if (bit_test(all_1.irest[commvl_1.ivx + nip1fb * 24 - 25],
			    0)) {
#line 16803 ""
			i__4 = nip2fb;
#line 16803 ""
			for (kp = nip1fb + 1; kp <= i__4; ++kp) {
#line 16804 ""
			    i__5 = igetbits_(&all_1.ipl[commvl_1.ivx + nip1fb 
				    * 24 - 25], &c__6, &c__11);
#line 16804 ""
			    setbits_(&all_1.ipl[commvl_1.ivx + kp * 24 - 25], 
				    &c__6, &c__11, &i__5);
#line 16806 ""
			    i__5 = igetbits_(&all_1.ipl[commvl_1.ivx + nip1fb 
				    * 24 - 25], &c__6, &c__17);
#line 16806 ""
			    setbits_(&all_1.ipl[commvl_1.ivx + kp * 24 - 25], 
				    &c__6, &c__17, &i__5);
#line 16808 ""
			    i__5 = igetbits_(&all_1.islur[commvl_1.ivx + 
				    nip1fb * 24 - 25], &c__2, &c__27);
#line 16808 ""
			    setbits_(&all_1.islur[commvl_1.ivx + kp * 24 - 25]
				    , &c__2, &c__27, &i__5);
#line 16810 ""
/* L88: */
#line 16810 ""
			}
#line 16811 ""
		    }
#line 16812 ""
/* L80: */
#line 16812 ""
		}
#line 16813 ""
L81:

/*  Slide down, reduce nfb(ivx).  This lets us count up from 1 for each new bar. */
/*  Remember, makeabar is called 1/bar, and it calls findbeam once per voice. */

#line 16818 ""
		if (nfbbar > 0) {
#line 16819 ""
		    comfb_1.nfb[commvl_1.ivx - 1] -= nfbbar;
#line 16820 ""
		    i__3 = comfb_1.nfb[commvl_1.ivx - 1];
#line 16820 ""
		    for (comfb_1.ifb = 1; comfb_1.ifb <= i__3; ++comfb_1.ifb) 
			    {
#line 16821 ""
			comfb_1.t1fb[commvl_1.ivx + comfb_1.ifb * 24 - 25] = 
				comfb_1.t1fb[commvl_1.ivx + (comfb_1.ifb + 
				nfbbar) * 24 - 25];
#line 16822 ""
			comfb_1.t2fb[commvl_1.ivx + comfb_1.ifb * 24 - 25] = 
				comfb_1.t2fb[commvl_1.ivx + (comfb_1.ifb + 
				nfbbar) * 24 - 25];
#line 16823 ""
			*(unsigned char *)&comfb_1.ulfbq[commvl_1.ivx + 
				comfb_1.ifb * 24 - 25] = *(unsigned char *)&
				comfb_1.ulfbq[commvl_1.ivx + (comfb_1.ifb + 
				nfbbar) * 24 - 25];
#line 16824 ""
/* L82: */
#line 16824 ""
		    }
#line 16825 ""
		}
#line 16826 ""
	    }
#line 16827 ""
	    comfb_1.ifb = 0;

/*  Done with forced beam masks for this bar and voice.  Now get normal beams. */

#line 16831 ""
	    findbeam_(ibmrep, &numbms[1], mapfb);
#line 16832 ""
/* L2099: */
#line 16832 ""
	}
#line 16833 ""
/* L20: */
#line 16833 ""
    }
#line 16834 ""
    return 0;
} /* make1bar_ */

/* Subroutine */ int make2bar_(integer *ninow, real *tglp1, real *tstart, 
	logical *cwrest, real *squez, integer *istop, integer *numbms, 
	integer *istart, char *clefq, ftnlen clefq_len)
{
    /* System generated locals */
    address a__1[6], a__2[2], a__3[5], a__4[3], a__5[2], a__6[4], a__7[8], 
	    a__8[7], a__9[9];
    integer i__1, i__2, i__3[6], i__4[2], i__5[5], i__6[3], i__7, i__8[2], 
	    i__9[4], i__10, i__11[8], i__12, i__13, i__14[7], i__15[9];
    real r__1, r__2;
    logical L__1;
    char ch__1[80], ch__2[82], ch__3[20], ch__4[14], ch__5[12], ch__6[1], 
	    ch__7[17], ch__8[16], ch__9[11], ch__10[10], ch__11[44], ch__12[
	    81], ch__13[113], ch__14[3], ch__15[9], ch__16[129], ch__17[6], 
	    ch__18[13], ch__19[5], ch__20[4], ch__21[22];
    cilist ci__1;

    /* Builtin functions */
    integer s_wsfi(icilist *), do_fio(integer *, char *, ftnlen), e_wsfi(void)
	    ;
    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
    integer s_wsfe(cilist *), e_wsfe(void), lbit_shift(integer, integer), 
	    s_wsle(cilist *), e_wsle(void), do_lio(integer *, integer *, char 
	    *, ftnlen), i_nint(real *);
    /* Subroutine */ int s_stop(char *, ftnlen);
    integer pow_ii(integer *, integer *);
    /* Subroutine */ int s_copy(char *, char *, ftnlen, ftnlen);
    double r_lg10(real *);
    integer s_cmp(char *, char *, ftnlen, ftnlen);

    /* Local variables */
    static integer lineno, itleft, itright, itendb;
    extern integer iashft_(integer *);
    static integer nolevc, ivlast;
    extern /* Subroutine */ int istring_(integer *, char *, integer *, ftnlen)
	    ;
    static integer mtrspc;
    extern integer igetbits_(integer *, integer *, integer *);
    static real dstemlen;
    extern logical isdotted_(integer *, integer *, integer *);
    extern /* Subroutine */ int beamstrt_(char *, integer *, integer *, 
	    integer *, real *, real *, integer *, ftnlen);
    static real ptsavail;
    static integer multtrem;
    extern /* Subroutine */ int dopsslur_(integer *, integer *, integer *, 
	    integer *, integer *, integer *, integer *, integer *, integer *, 
	    integer *, logical *, integer *, char *, integer *, char *, 
	    integer *, integer *, integer *, integer *, real *, integer *, 
	    ftnlen, ftnlen), midievent_(char *, integer *, integer *, ftnlen);
    static real stemshort;
    static integer ib, ig, il, in, ip, kv, iv1;
    extern /* Subroutine */ int adjusteskz_(integer *, integer *, real *);
    static integer iib, icm, ing, len;
    static real esk;
    static char udq[1];
    static real xnd;
    static integer ivf;
    static real wgr;
    static integer iiv;
    static real pts;
    static logical secondgrace;
    extern integer log2_(integer *);
    extern /* Subroutine */ int chkkbdrests_(integer *, integer *, integer *, 
	    integer *, integer *, integer *, integer *, integer *, integer *, 
	    integer *, integer *, real *, real *, integer *, integer *, 
	    integer *, integer *, integer *, integer *);
    static integer iacc, kacc, macc, ifig[2], icrd, ndig;
    extern /* Character */ VOID chax_(char *, ftnlen, integer *);
    extern doublereal feon_(real *);
    static integer lcwr[24];
    extern /* Character */ VOID udqq_(char *, ftnlen, integer *, integer *, 
	    integer *, integer *, integer *, integer *);
    static char cwrq[79*24];
    static real ptgr[37], spgr, ptsl, zero;
    static char ivxq[4];
    static real tnow;
    static integer nodu, livx;
    extern /* Subroutine */ int eskb4_(integer *, integer *, integer *, 
	    integer *, real *, real *, real *, integer *, real *), stop1_(
	    void), doacc_(integer *, integer *, char *, integer *, integer *, 
	    integer *, integer *, logical *, ftnlen);
    static logical isacc;
    static integer nclef, iaskb[24];
    static logical iscln, issig;
    static integer nornb[24];
    static logical isarp, isdot;
    static char noteq[8];
    static logical iscwr;
    static char soutq[80];
    static integer lnote, iinst, lsout, itrpt, itsig;
    extern integer ncmid_(integer *, integer *);
    static integer iirpt, lclow;
    extern /* Subroutine */ int dodyn_(integer *, integer *, integer *, 
	    integer *, integer *, integer *, integer *, integer *, integer *, 
	    logical *, integer *, integer *, char *, integer *, logical *, 
	    char *, integer *, ftnlen, ftnlen), docrd_(integer *, integer *, 
	    integer *, integer *, integer *, real *, char *, integer *, char *
	    , integer *, integer *, integer *, integer *, logical *, integer *
	    , integer *, integer *, real *, logical *, integer *, integer *, 
	    ftnlen, ftnlen), putcb_(integer *, integer *, char *, integer *, 
	    ftnlen);
    static logical iscacc;
    extern /* Subroutine */ int addask_(real *, real *, real *, real *, real *
	    , real *, real *, logical *);
    static logical isclef, isflag, isaccs, bspend, isgaft;
    static real ptclef[24];
    static integer ihornb[576]	/* was [24][24] */;
    static real eskndg[24], ptsndg[24];
    static logical rpndot;
    static char notexq[79];
    static logical stemup, beamon1[24];
    static integer ibmcnt1[24], lnoten;
    extern /* Subroutine */ int wsclef_(integer *, integer *, integer *);
    static real eonsqz;
    extern /* Subroutine */ int precrd_(integer *, integer *, integer *, 
	    integer *, integer *, integer *, char *, logical *, integer *, 
	    ftnlen), chkarp_(integer *, integer *, integer *, integer *, 
	    logical *, logical *);
    static integer ibmchk;
    static real taccfac, esksav, ptsadd;
    static integer ihshft;
    extern /* Subroutine */ int addstr_(char *, integer *, char *, integer *, 
	    ftnlen, ftnlen);
    static integer lchead;
    extern integer lenstr_(char *, integer *, ftnlen);
    static integer islhgt;
    static real offnsk;
    extern /* Subroutine */ int putfig_(integer *, integer *, real *, logical 
	    *, char *, integer *, ftnlen), putarp_(real *, integer *, integer 
	    *, integer *, integer *, char *, integer *, ftnlen);
    static logical isgrace;
    static integer icashft;
    static real ptbneed;
    extern /* Subroutine */ int doslur_(integer *, integer *, integer *, 
	    integer *, integer *, integer *, integer *, integer *, integer *, 
	    logical *, integer *, char *, integer *, char *, integer *, 
	    integer *, integer *, integer *, real *, integer *, ftnlen, 
	    ftnlen);
    static integer iphold;
    extern /* Subroutine */ int dograce_(integer *, integer *, real *, char *,
	     integer *, integer *, integer *, integer *, integer *, logical *,
	     logical *, integer *, integer *, integer *, integer *, integer *,
	     integer *, real *, char *, integer *, ftnlen, ftnlen);
    static real ptsneed;
    extern /* Subroutine */ int clefsym_(integer *, char *, integer *, 
	    integer *, ftnlen);
    static logical isrshft, isfirst, nofirst;
    static char slurudq[1];
    extern /* Subroutine */ int putshft_(integer *, logical *, char *, 
	    integer *, ftnlen), endslur_(logical *, logical *, integer *, 
	    integer *, integer *, integer *, integer *, char *, integer *, 
	    logical *, ftnlen), notefq_(char *, integer *, integer *, integer 
	    *, ftnlen), setbits_(integer *, integer *, integer *, integer *), 
	    addmidi_(integer *, integer *, integer *, integer *, real *, 
	    logical *, logical *), putorn_(integer *, integer *, integer *, 
	    integer *, integer *, char *, integer *, integer *, integer *, 
	    integer *, integer *, integer *, integer *, real *, char *, 
	    integer *, integer *, integer *, logical *, logical *, ftnlen, 
	    ftnlen), dotmov_(real *, real *, char *, integer *, integer *, 
	    ftnlen), beamn1_(char *, integer *, ftnlen);
    static real wheadpt1;
    extern /* Subroutine */ int beamend_(char *, integer *, ftnlen), beamid_(
	    char *, integer *, ftnlen), notex_(char *, integer *, ftnlen);

    /* Fortran I/O blocks */
    static icilist io___1022 = { 0, noteq, 0, "(1H{,i3,1H})", 5, 1 };
    static icilist io___1024 = { 0, noteq, 0, "(1H{,i2,1H})", 4, 1 };
    static icilist io___1025 = { 0, noteq, 0, "(i1)", 1, 1 };
    static cilist io___1028 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1029 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1034 = { 0, 6, 0, 0, 0 };
    static cilist io___1035 = { 0, 6, 0, 0, 0 };
    static cilist io___1036 = { 0, 11, 0, "(a20,i1,a)", 0 };
    static cilist io___1037 = { 0, 11, 0, "(a20,i2,a)", 0 };
    static cilist io___1038 = { 0, 11, 0, "(a)", 0 };
    static icilist io___1041 = { 0, soutq+8, 0, "(f4.1)", 4, 1 };
    static icilist io___1042 = { 0, soutq+8, 0, "(f4.2)", 4, 1 };
    static icilist io___1043 = { 0, soutq+10, 0, "(i2)", 2, 1 };
    static icilist io___1044 = { 0, soutq+11, 0, "(i1)", 1, 1 };
    static cilist io___1049 = { 0, 6, 0, 0, 0 };
    static cilist io___1050 = { 0, 6, 0, 0, 0 };
    static cilist io___1070 = { 0, 6, 0, 0, 0 };
    static cilist io___1086 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1087 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1088 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1089 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1090 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1091 = { 0, 6, 0, 0, 0 };
    static cilist io___1092 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1093 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1094 = { 0, 11, 0, "(a)", 0 };
    static icilist io___1098 = { 0, notexq+11, 0, "(i2)", 2, 1 };
    static icilist io___1104 = { 0, notexq+6, 0, "(f3.1)", 3, 1 };
    static icilist io___1105 = { 0, notexq+6, 0, "(f4.1)", 4, 1 };
    static icilist io___1107 = { 0, notexq+5, 0, "(f3.1)", 3, 1 };
    static icilist io___1108 = { 0, notexq+5, 0, "(f4.1)", 4, 1 };
    static cilist io___1110 = { 0, 6, 0, 0, 0 };
    static cilist io___1111 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1112 = { 0, 11, 0, "(a)", 0 };
    static icilist io___1120 = { 0, notexq, 0, "(f4.1)", 79, 1 };
    static icilist io___1128 = { 0, noteq, 0, "(a1,i2,a1)", 8, 1 };
    static cilist io___1129 = { 0, 6, 0, 0, 0 };
    static cilist io___1142 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1145 = { 0, 11, 0, "(a)", 0 };
    static icilist io___1146 = { 0, soutq+12, 0, "(i3)", 3, 1 };
    static icilist io___1147 = { 0, soutq+12, 0, "(i2)", 2, 1 };
    static cilist io___1148 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1151 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1153 = { 0, 11, 0, "(a)", 0 };



/*  Factors for grace note, clef spacing. (fraction of wheadpt) */
/*  In 1.04, moved to block data subprogram */

/* 130316 */
#line 16963 ""
    /* Parameter adjustments */
#line 16963 ""
    --clefq;
#line 16963 ""
    --istart;
#line 16963 ""
    --numbms;
#line 16963 ""
    --istop;
#line 16963 ""
    --squez;
#line 16963 ""
    --cwrest;
#line 16963 ""
    --tstart;
#line 16963 ""

#line 16963 ""
    /* Function Body */
#line 16963 ""
    xjbeambrests_1.nbrests = 0;

/*  Set up main ib loop within which a block (notes group) is written */

#line 16967 ""
    i__1 = all_1.nv;
#line 16967 ""
    for (all_1.iv = 1; all_1.iv <= i__1; ++all_1.iv) {
#line 16968 ""
	i__2 = commvl_1.nvmx[all_1.iv - 1];
#line 16968 ""
	for (kv = 1; kv <= i__2; ++kv) {
#line 16969 ""
	    commvl_1.ivx = commvl_1.ivmx[all_1.iv + kv * 24 - 25];
#line 16970 ""
	    all_1.ibmcnt[commvl_1.ivx - 1] = 1;
#line 16971 ""
	    ibmcnt1[commvl_1.ivx - 1] = 1;
#line 16972 ""
	    all_1.beamon[commvl_1.ivx - 1] = FALSE_;
#line 16973 ""
	    beamon1[commvl_1.ivx - 1] = FALSE_;
#line 16974 ""
	    nornb[commvl_1.ivx - 1] = 0;
#line 16975 ""
	    iaskb[commvl_1.ivx - 1] = 1;
#line 16976 ""
	    comxtup_1.vxtup[commvl_1.ivx - 1] = FALSE_;
#line 16977 ""
	    comdraw_1.drawbm[commvl_1.ivx - 1] = TRUE_;
#line 16978 ""
/* L2599: */
#line 16978 ""
	}
#line 16979 ""
/* L25: */
#line 16979 ""
    }
#line 16980 ""
    comas1_1.naskb = 0;
#line 16981 ""
    ifig[0] = 1;
#line 16982 ""
    ifig[1] = 1;
#line 16983 ""
    comxtup_1.ixtup = 0;
#line 16984 ""
    bspend = FALSE_;
#line 16985 ""
    iscwr = FALSE_;
#line 16986 ""
    rpndot = FALSE_;
#line 16987 ""
    i__1 = comnsp_2.nb;
#line 16987 ""
    for (ib = 1; ib <= i__1; ++ib) {

/*  Check for segno */

#line 16991 ""
	if (bit_test(all_1.iornq[all_1.ipo[istart[ib] - 1] * 24],4) && 
		all_1.ivxo[istart[ib] - 1] == 1) {
#line 16993 ""
	    if (comgrace_1.noffseg <= -10) {
#line 16994 ""
		s_wsfi(&io___1022);
#line 16994 ""
		do_fio(&c__1, (char *)&comgrace_1.noffseg, (ftnlen)sizeof(
			integer));
#line 16994 ""
		e_wsfi();
#line 16995 ""
		lnoten = 5;
#line 16996 ""
	    } else if (comgrace_1.noffseg < 0 || comgrace_1.noffseg >= 10) {
#line 16997 ""
		s_wsfi(&io___1024);
#line 16997 ""
		do_fio(&c__1, (char *)&comgrace_1.noffseg, (ftnlen)sizeof(
			integer));
#line 16997 ""
		e_wsfi();
#line 16998 ""
		lnoten = 4;
#line 16999 ""
	    } else {
#line 17000 ""
		s_wsfi(&io___1025);
#line 17000 ""
		do_fio(&c__1, (char *)&comgrace_1.noffseg, (ftnlen)sizeof(
			integer));
#line 17000 ""
		e_wsfi();
#line 17001 ""
		lnoten = 1;
#line 17002 ""
	    }
/* Writing concatenation */
#line 17003 ""
	    i__3[0] = 1, a__1[0] = all_1.sq;
#line 17003 ""
	    i__3[1] = 6, a__1[1] = "znotes";
#line 17003 ""
	    i__3[2] = 1, a__1[2] = all_1.sq;
#line 17003 ""
	    i__3[3] = 6, a__1[3] = "segnoo";
#line 17003 ""
	    i__3[4] = lnoten, a__1[4] = noteq;
#line 17003 ""
	    i__3[5] = 1, a__1[5] = "9";
#line 17003 ""
	    s_cat(notexq, a__1, i__3, &c__6, (ftnlen)79);
#line 17004 ""
	    lnote = lnoten + 15;
#line 17005 ""
	    i__2 = all_1.nv;
#line 17005 ""
	    for (all_1.iv = 2; all_1.iv <= i__2; ++all_1.iv) {
#line 17006 ""
		if (lnote > 60) {
#line 17007 ""
		    if (comlast_1.islast) {
#line 17007 ""
			s_wsfe(&io___1028);
/* Writing concatenation */
#line 17007 ""
			i__4[0] = lnote, a__2[0] = notexq;
#line 17007 ""
			i__4[1] = 1, a__2[1] = "%";
#line 17007 ""
			s_cat(ch__1, a__2, i__4, &c__2, (ftnlen)80);
#line 17007 ""
			do_fio(&c__1, ch__1, lnote + 1);
#line 17007 ""
			e_wsfe();
#line 17007 ""
		    }
/* Writing concatenation */
#line 17008 ""
		    i__5[0] = 1, a__3[0] = all_1.sepsymq + (all_1.iv - 2);
#line 17008 ""
		    i__5[1] = 1, a__3[1] = all_1.sq;
#line 17008 ""
		    i__5[2] = 6, a__3[2] = "segnoo";
#line 17008 ""
		    i__5[3] = lnoten, a__3[3] = noteq;
#line 17008 ""
		    i__5[4] = 1, a__3[4] = "9";
#line 17008 ""
		    s_cat(notexq, a__3, i__5, &c__5, (ftnlen)79);
#line 17010 ""
		    lnote = lnoten + 9;
#line 17011 ""
		} else {
/* Writing concatenation */
#line 17012 ""
		    i__3[0] = lnote, a__1[0] = notexq;
#line 17012 ""
		    i__3[1] = 1, a__1[1] = all_1.sepsymq + (all_1.iv - 2);
#line 17012 ""
		    i__3[2] = 1, a__1[2] = all_1.sq;
#line 17012 ""
		    i__3[3] = 6, a__1[3] = "segnoo";
#line 17012 ""
		    i__3[4] = lnoten, a__1[4] = noteq;
#line 17012 ""
		    i__3[5] = 1, a__1[5] = "9";
#line 17012 ""
		    s_cat(notexq, a__1, i__3, &c__6, (ftnlen)79);
#line 17014 ""
		    lnote = lnote + lnoten + 9;
#line 17015 ""
		}
#line 17016 ""
/* L130: */
#line 17016 ""
	    }
#line 17017 ""
	    if (comlast_1.islast) {
#line 17017 ""
		s_wsfe(&io___1029);
/* Writing concatenation */
#line 17017 ""
		i__6[0] = lnote, a__4[0] = notexq;
#line 17017 ""
		i__6[1] = 1, a__4[1] = all_1.sq;
#line 17017 ""
		i__6[2] = 2, a__4[2] = "en";
#line 17017 ""
		s_cat(ch__2, a__4, i__6, &c__3, (ftnlen)82);
#line 17017 ""
		do_fio(&c__1, ch__2, lnote + 3);
#line 17017 ""
		e_wsfe();
#line 17017 ""
	    }
#line 17018 ""
	    lnote = 0;
#line 17019 ""
	}

/*  Check for new clefs */

#line 17023 ""
	isclef = FALSE_;
#line 17024 ""
	if (bit_test(all_1.islur[all_1.ivxo[istart[ib] - 1] + all_1.ipo[
		istart[ib] - 1] * 24 - 25],15)) {

/*  In preceding line, fl32 gave wrong result for ... .gt.0 !!! */

#line 17029 ""
	    i__2 = istop[ib];
#line 17029 ""
	    for (in = istart[ib]; in <= i__2; ++in) {
#line 17030 ""
		if (bit_test(all_1.islur[all_1.ivxo[in - 1] + all_1.ipo[in - 
			1] * 24 - 25],11)) {
#line 17031 ""
		    i__7 = lbit_shift(all_1.islur[all_1.ivxo[in - 1] + 
			    all_1.ipo[in - 1] * 24 - 25], (ftnlen)-12) & 7;
#line 17031 ""
		    wsclef_(&all_1.ivxo[in - 1], ninow, &i__7);

/* If clefq = '8', must add eg \settrebleclefsymbol3\treblelowoct% */

#line 17036 ""
		    if (bit_test(all_1.ipl[all_1.ivxo[in - 1] + all_1.ipo[in 
			    - 1] * 24 - 25],2)) {

/* Find instrument number for voice ivso(in) */

#line 17040 ""
			iv1 = 1;
#line 17041 ""
			i__7 = *ninow;
#line 17041 ""
			for (iinst = 1; iinst <= i__7; ++iinst) {
#line 17042 ""
			    if (all_1.ivxo[in - 1] < iv1 + comnvi_1.nspern[
				    iinst - 1]) {
#line 17042 ""
				goto L2222;
#line 17042 ""
			    }
#line 17043 ""
			    iv1 += comnvi_1.nspern[iinst - 1];
#line 17044 ""
/* L1111: */
#line 17044 ""
			}
#line 17045 ""
			s_wsle(&io___1034);
#line 17045 ""
			e_wsle();
#line 17046 ""
			s_wsle(&io___1035);
#line 17046 ""
			do_lio(&c__9, &c__1, "Should not be here in make2bar!"
				, (ftnlen)31);
#line 17046 ""
			e_wsle();
#line 17047 ""
			stop1_();
#line 17048 ""
L2222:
#line 17049 ""
			if (iinst <= 9) {
#line 17050 ""
			    s_wsfe(&io___1036);
/* Writing concatenation */
#line 17050 ""
			    i__4[0] = 1, a__2[0] = all_1.sq;
#line 17050 ""
			    i__4[1] = 19, a__2[1] = "settrebleclefsymbol";
#line 17050 ""
			    s_cat(ch__3, a__2, i__4, &c__2, (ftnlen)20);
#line 17050 ""
			    do_fio(&c__1, ch__3, (ftnlen)20);
#line 17050 ""
			    do_fio(&c__1, (char *)&iinst, (ftnlen)sizeof(
				    integer));
/* Writing concatenation */
#line 17050 ""
			    i__8[0] = 1, a__5[0] = all_1.sq;
#line 17050 ""
			    i__8[1] = 13, a__5[1] = "treblelowoct%";
#line 17050 ""
			    s_cat(ch__4, a__5, i__8, &c__2, (ftnlen)14);
#line 17050 ""
			    do_fio(&c__1, ch__4, (ftnlen)14);
#line 17050 ""
			    e_wsfe();
#line 17052 ""
			} else {
#line 17053 ""
			    s_wsfe(&io___1037);
/* Writing concatenation */
#line 17053 ""
			    i__4[0] = 1, a__2[0] = all_1.sq;
#line 17053 ""
			    i__4[1] = 19, a__2[1] = "settrebleclefsymbol";
#line 17053 ""
			    s_cat(ch__3, a__2, i__4, &c__2, (ftnlen)20);
#line 17053 ""
			    do_fio(&c__1, ch__3, (ftnlen)20);
#line 17053 ""
			    do_fio(&c__1, (char *)&iinst, (ftnlen)sizeof(
				    integer));
/* Writing concatenation */
#line 17053 ""
			    i__8[0] = 1, a__5[0] = all_1.sq;
#line 17053 ""
			    i__8[1] = 13, a__5[1] = "treblelowoct%";
#line 17053 ""
			    s_cat(ch__4, a__5, i__8, &c__2, (ftnlen)14);
#line 17053 ""
			    do_fio(&c__1, ch__4, (ftnlen)14);
#line 17053 ""
			    e_wsfe();
#line 17055 ""
			}
#line 17056 ""
			comc8flag_1.c8flag[all_1.ivxo[in - 1] - 1] = TRUE_;
#line 17057 ""
		    }
#line 17058 ""
		}
#line 17059 ""
/* L140: */
#line 17059 ""
	    }
#line 17060 ""
	    if (comlast_1.islast) {
#line 17060 ""
		s_wsfe(&io___1038);
/* Writing concatenation */
#line 17060 ""
		i__4[0] = 1, a__2[0] = all_1.sq;
#line 17060 ""
		i__4[1] = 11, a__2[1] = "pmxnewclefs";
#line 17060 ""
		s_cat(ch__5, a__2, i__4, &c__2, (ftnlen)12);
#line 17060 ""
		do_fio(&c__1, ch__5, (ftnlen)12);
#line 17060 ""
		e_wsfe();
#line 17060 ""
	    }
#line 17061 ""
	    isclef = TRUE_;
#line 17062 ""
	}

/*  Start a notes group.  We're just gonna define every one using pnotes{n}, */
/*    where \def\pnotes#1{\vnotes#1\elemskip} */

/* Writing concatenation */
#line 17067 ""
	i__4[0] = 1, a__2[0] = all_1.sq;
#line 17067 ""
	i__4[1] = 7, a__2[1] = "pnotes{";
#line 17067 ""
	s_cat(soutq, a__2, i__4, &c__2, (ftnlen)80);
#line 17068 ""
	r__1 = comnsp_2.space[ib - 1] / squez[ib];
#line 17068 ""
	eonsqz = squez[ib] * feon_(&r__1);
#line 17069 ""
	if (eonsqz > 9.995f) {
#line 17070 ""
	    s_wsfi(&io___1041);
#line 17070 ""
	    do_fio(&c__1, (char *)&eonsqz, (ftnlen)sizeof(real));
#line 17070 ""
	    e_wsfi();
#line 17071 ""
	} else if (eonsqz > .995f) {
#line 17072 ""
	    s_wsfi(&io___1042);
#line 17072 ""
	    do_fio(&c__1, (char *)&eonsqz, (ftnlen)sizeof(real));
#line 17072 ""
	    e_wsfi();
#line 17073 ""
	} else if (eonsqz > .095f) {
/* Writing concatenation */
#line 17074 ""
	    i__4[0] = 8, a__2[0] = soutq;
#line 17074 ""
	    i__4[1] = 2, a__2[1] = "0.";
#line 17074 ""
	    s_cat(soutq, a__2, i__4, &c__2, (ftnlen)80);
#line 17075 ""
	    s_wsfi(&io___1043);
#line 17075 ""
	    r__1 = eonsqz * 100;
#line 17075 ""
	    i__2 = i_nint(&r__1);
#line 17075 ""
	    do_fio(&c__1, (char *)&i__2, (ftnlen)sizeof(integer));
#line 17075 ""
	    e_wsfi();
#line 17076 ""
	} else {
/* Writing concatenation */
#line 17077 ""
	    i__4[0] = 8, a__2[0] = soutq;
#line 17077 ""
	    i__4[1] = 3, a__2[1] = "0.0";
#line 17077 ""
	    s_cat(soutq, a__2, i__4, &c__2, (ftnlen)80);
#line 17078 ""
	    s_wsfi(&io___1044);
#line 17078 ""
	    r__1 = eonsqz * 100;
#line 17078 ""
	    i__2 = i_nint(&r__1);
#line 17078 ""
	    do_fio(&c__1, (char *)&i__2, (ftnlen)sizeof(integer));
#line 17078 ""
	    e_wsfi();
#line 17079 ""
	}
/* Writing concatenation */
#line 17080 ""
	i__4[0] = 12, a__2[0] = soutq;
#line 17080 ""
	i__4[1] = 1, a__2[1] = "}";
#line 17080 ""
	s_cat(soutq, a__2, i__4, &c__2, (ftnlen)80);
#line 17081 ""
	lsout = 13;

/*  Check whole block, flag accidentals etc that are too close, one per *time*. */
/*  Note about bar starts and after rpt's/boublebars: There is an afterruleskip */
/*    (fbar*wheadpt) following, but rpts seem to occupy some of that gap, so */
/*    (dotsfac*wheadpt) is presumed to be filled up. */

#line 17088 ""
	in = istart[ib] - 1;
#line 17089 ""
	itrpt = -1;
#line 17090 ""
	itsig = -1;

/*  Begin big manual loop over notes in this block; ends at 112 */

#line 17094 ""
L111:
#line 17094 ""
	++in;
#line 17095 ""
	if (in > istop[ib]) {
#line 17095 ""
	    goto L112;
#line 17095 ""
	}
#line 17096 ""
	ip = all_1.ipo[in - 1];
#line 17097 ""
	commvl_1.ivx = all_1.ivxo[in - 1];
#line 17098 ""
	if (commvl_1.ivx <= all_1.nv) {
#line 17099 ""
	    all_1.iv = commvl_1.ivx;
#line 17100 ""
	} else {
#line 17101 ""
	    i__2 = all_1.nv;
#line 17101 ""
	    for (all_1.iv = 1; all_1.iv <= i__2; ++all_1.iv) {
#line 17102 ""
		if (commvl_1.nvmx[all_1.iv - 1] == 2 && commvl_1.ivmx[
			all_1.iv + 23] == commvl_1.ivx) {
#line 17102 ""
		    goto L129;
#line 17102 ""
		}
#line 17103 ""
/* L128: */
#line 17103 ""
	    }
#line 17104 ""
	    s_wsle(&io___1049);
#line 17104 ""
	    do_lio(&c__9, &c__1, "Trouble finding iv!, ivx,nvmx,ivmx:", (
		    ftnlen)35);
#line 17104 ""
	    do_lio(&c__3, &c__1, (char *)&commvl_1.ivx, (ftnlen)sizeof(
		    integer));
#line 17104 ""
	    do_lio(&c__3, &c__1, (char *)&commvl_1.nvmx[0], (ftnlen)sizeof(
		    integer));
#line 17104 ""
	    do_lio(&c__3, &c__1, (char *)&commvl_1.nvmx[1], (ftnlen)sizeof(
		    integer));
#line 17104 ""
	    e_wsle();
#line 17105 ""
	    s_wsle(&io___1050);
#line 17105 ""
	    do_lio(&c__3, &c__1, (char *)&commvl_1.ivmx[0], (ftnlen)sizeof(
		    integer));
#line 17105 ""
	    do_lio(&c__3, &c__1, (char *)&commvl_1.ivmx[24], (ftnlen)sizeof(
		    integer));
#line 17105 ""
	    do_lio(&c__3, &c__1, (char *)&commvl_1.ivmx[1], (ftnlen)sizeof(
		    integer));
#line 17105 ""
	    do_lio(&c__3, &c__1, (char *)&commvl_1.ivmx[25], (ftnlen)sizeof(
		    integer));
#line 17105 ""
	    e_wsle();
#line 17106 ""
	    s_stop("", (ftnlen)0);
#line 17107 ""
	}
#line 17108 ""
L129:

/*  Call precrd here so we know how much space to add for accid's in chords */
/*    After calling precrd, icashft>0 means there is a shifted chordal accid (incl. */
/*    main note. */

/*  To call precrd, need up-downness, so must track if in beam. */

/*  Deal w/ staff-jumping beams later */

#line 17118 ""
	if (numbms[commvl_1.ivx] > 0 && ibmcnt1[commvl_1.ivx - 1] <= numbms[
		commvl_1.ivx] && all_1.ibm1[commvl_1.ivx + ibmcnt1[
		commvl_1.ivx - 1] * 24 - 25] == ip) {
#line 17120 ""
	    beamon1[commvl_1.ivx - 1] = TRUE_;
#line 17121 ""
	}
#line 17122 ""
	icashft = 0;
#line 17123 ""
	if (bit_test(all_1.ipl[commvl_1.ivx + ip * 24 - 25],10)) {

/*  There is a chord on this note. Need up-down-ness in precrd to auto shift for 2nds. */

#line 17127 ""
	    if (beamon1[commvl_1.ivx - 1]) {
#line 17128 ""
		precrd_(&commvl_1.ivx, &ip, &all_1.nolev[commvl_1.ivx + ip * 
			24 - 25], &all_1.nacc[commvl_1.ivx + ip * 24 - 25], &
			all_1.ipl[commvl_1.ivx + ip * 24 - 25], &all_1.irest[
			commvl_1.ivx + ip * 24 - 25], all_1.ulq + (
			commvl_1.ivx + ibmcnt1[commvl_1.ivx - 1] * 24 - 25), &
			c_false, &icashft, (ftnlen)1);
#line 17131 ""
	    } else {
#line 17132 ""
		i__2 = ncmid_(&all_1.iv, &ip);
#line 17132 ""
		udqq_(ch__6, (ftnlen)1, &all_1.nolev[commvl_1.ivx + ip * 24 - 
			25], &i__2, &all_1.islur[commvl_1.ivx + ip * 24 - 25],
			 &commvl_1.nvmx[all_1.iv - 1], &commvl_1.ivx, &
			all_1.nv);
#line 17132 ""
		precrd_(&commvl_1.ivx, &ip, &all_1.nolev[commvl_1.ivx + ip * 
			24 - 25], &all_1.nacc[commvl_1.ivx + ip * 24 - 25], &
			all_1.ipl[commvl_1.ivx + ip * 24 - 25], &all_1.irest[
			commvl_1.ivx + ip * 24 - 25], ch__6, &c_false, &
			icashft, (ftnlen)1);
#line 17136 ""
	    }
#line 17137 ""
	}

/*  Turn beam off? */

#line 17141 ""
	if (beamon1[commvl_1.ivx - 1] && all_1.ibm2[commvl_1.ivx + ibmcnt1[
		commvl_1.ivx - 1] * 24 - 25] == ip) {
#line 17142 ""
	    beamon1[commvl_1.ivx - 1] = FALSE_;
#line 17143 ""
	    ++ibmcnt1[commvl_1.ivx - 1];
#line 17144 ""
	}

/*  Remember, rpts & internal sigs can only come at start of (internal) block */

#line 17148 ""
	isacc = (all_1.nacc[commvl_1.ivx + ip * 24 - 25] & 3) > 0 && ! 
		bit_test(all_1.nacc[commvl_1.ivx + ip * 24 - 25],17) && ! 
		bit_test(all_1.ipl[commvl_1.ivx + ip * 24 - 25],10);

/*  i.e., do not set for chord. Now check for "(" as ornament on main note, */

/* !!!  Need to do this for chord notes too.  Maybe in chkarp? */

#line 17156 ""
	isaccs = isacc || bit_test(all_1.iornq[commvl_1.ivx + ip * 24 - 1],0);

#line 17158 ""
	isarp = bit_test(all_1.iornq[commvl_1.ivx + ip * 24 - 1],27);
#line 17159 ""
	iscacc = FALSE_;
#line 17160 ""
	if (bit_test(all_1.ipl[commvl_1.ivx + ip * 24 - 25],10)) {

/*  There is a chord here; check for arpeggios and accidentals. Note accid shifts are */
/*    not of concern here, only whether there's an accid, whick causes iscacc=.true. */

#line 17165 ""
	    iscacc = igetbits_(&all_1.nacc[commvl_1.ivx + ip * 24 - 25], &
		    c__3, &c__0) > 0 && ! bit_test(all_1.nacc[commvl_1.ivx + 
		    ip * 24 - 25],17);
#line 17167 ""
	    chkarp_(&comtrill_1.ncrd, comtrill_1.icrdat, &commvl_1.ivx, &ip, &
		    iscacc, &isarp);
#line 17168 ""
	}

/*  When we get motivated, will do spacing for arpeggios here. */

#line 17172 ""
	if (commvl_1.ivx == 1 && (all_1.islur[commvl_1.ivx + ip * 24 - 25] & 
		96) > 0) {
#line 17172 ""
	    itrpt = i_nint(&all_1.to[in - 1]);
#line 17172 ""
	}
#line 17174 ""
	issig = bit_test(all_1.ipl[commvl_1.ivx + ip * 24 - 25],28);
#line 17175 ""
	if (commvl_1.ivx == 1 && issig) {
#line 17175 ""
	    itsig = i_nint(&all_1.to[in - 1]);
#line 17175 ""
	}
#line 17176 ""
	isgrace = bit_test(all_1.islur[commvl_1.ivx + ip * 24 - 25],4) && ! 
		bit_test(all_1.ipl[commvl_1.ivx + ip * 24 - 25],29) && ! 
		bit_test(all_1.ipl[commvl_1.ivx + ip * 24 - 25],31);
#line 17178 ""
	isgaft = FALSE_;
#line 17179 ""
	if (ip > 1) {
#line 17180 ""
	    xnd = all_1.tnote[comipl2_1.ipl2[commvl_1.ivx + (ip - 1) * 24 - 
		    25] - 1];
#line 17181 ""
	    isgaft = bit_test(all_1.ipl[commvl_1.ivx + (ip - 1) * 24 - 25],29)
		     || bit_test(all_1.ipl[commvl_1.ivx + (ip - 1) * 24 - 25],
		    31);
#line 17182 ""
	    isgrace = isgrace || isgaft;
#line 17183 ""
	}
#line 17184 ""
	iscln = isclef && bit_test(all_1.islur[commvl_1.ivx + ip * 24 - 25],
		11);

/*  Is prev. note non-beamed, up-stemmed, & flagged? Recall if ip>1, have nd */

#line 17188 ""
	isflag = ip > 1 && xnd > comtol_1.tol && xnd < 16.f - comtol_1.tol;
#line 17189 ""
	if (isflag) {
#line 17189 ""
	    i__7 = ip - 1;
#line 17189 ""
	    i__2 = ncmid_(&all_1.iv, &i__7);
#line 17189 ""
	    udqq_(ch__6, (ftnlen)1, &all_1.nolev[commvl_1.ivx + (ip - 1) * 24 
		    - 25], &i__2, &all_1.islur[commvl_1.ivx + (ip - 1) * 24 - 
		    25], &commvl_1.nvmx[all_1.iv - 1], &commvl_1.ivx, &
		    all_1.nv);
#line 17189 ""
	    isflag = ! bit_test(all_1.irest[commvl_1.ivx + (ip - 1) * 24 - 25]
		    ,0) && *(unsigned char *)&ch__6[0] == 'u';
#line 17189 ""
	}
#line 17193 ""
	if (isflag) {
#line 17194 ""
	    i__2 = numbms[commvl_1.ivx];
#line 17194 ""
	    for (ibmchk = 1; ibmchk <= i__2; ++ibmchk) {
#line 17195 ""
		if (ip - 1 < all_1.ibm1[commvl_1.ivx + ibmchk * 24 - 25]) {
#line 17196 ""
		    goto L117;

/*  Add check for non-beamed xtuplets. May be problem with stem direction. */

#line 17200 ""
		} else if (ip - 1 <= all_1.ibm2[commvl_1.ivx + ibmchk * 24 - 
			25] && ! bit_test(all_1.islur[commvl_1.ivx + 
			all_1.ibm1[commvl_1.ivx + ibmchk * 24 - 25] * 24 - 25]
			,18)) {
#line 17202 ""
		    isflag = FALSE_;
#line 17203 ""
		    goto L117;
#line 17204 ""
		}
#line 17205 ""
/* L116: */
#line 17205 ""
	    }
#line 17206 ""
	}
#line 17207 ""
L117:

/*  If isflag, then won't need to check for dot on prev. note. */

/*  5/16/02 ???  Try using this for ) ornament. */

#line 17213 ""
	isflag = isflag || bit_test(all_1.iornq[commvl_1.ivx + (ip - 1) * 24 
		- 1],13);
#line 17214 ""
	isdot = ip > 1;
#line 17215 ""
	if (isdot) {
#line 17215 ""
	    i__2 = ip - 1;
#line 17215 ""
	    isdot = isdotted_(all_1.nodur, &commvl_1.ivx, &i__2);
#line 17215 ""
	}
#line 17216 ""
	isrshft = ip > 1;
#line 17217 ""
	if (isrshft) {
#line 17217 ""
	    isrshft = bit_test(all_1.irest[commvl_1.ivx + (ip - 1) * 24 - 25],
		    20);
#line 17217 ""
	}
#line 17218 ""
	if (! (isaccs || isgrace || iscln || isflag || isrshft || isdot || 
		bit_test(all_1.iornq[commvl_1.ivx + ip * 24 - 1],26) || 
		bit_test(all_1.irest[commvl_1.ivx + ip * 24 - 25],21) || 
		isarp || bit_test(all_1.irest[commvl_1.ivx + ip * 24 - 25],27)
		 || iscacc)) {
#line 17218 ""
	    goto L111;
#line 17218 ""
	}

/*  Here is an accid,grace,clef,flag,rtshft,dot,udsp,arpeg,left-shift. */
/*  Compute pts, the total occupied space including prior notehead. */

/* 130324 */
#line 17227 ""
	wheadpt1 = comask_1.wheadpt * comfig_1.fullsize[cominsttrans_1.instno[
		all_1.iv - 1] - 1];
#line 17228 ""
	pts = wheadpt1;

/*  Set up for possible cautionary accidental here */

#line 17232 ""
	if (isaccs || iscacc) {
#line 17233 ""
	    if (! bit_test(all_1.iornq[commvl_1.ivx + ip * 24 - 1],31)) {
#line 17234 ""
		taccfac = spfacs_1.accfac;
#line 17235 ""
	    } else {
#line 17236 ""
		taccfac = spfacs_1.accfac * 1.4f;
/* cautionary accidental */
#line 17237 ""
	    }
#line 17238 ""
	}
#line 17239 ""
	if (isgrace) {
#line 17240 ""
	    secondgrace = FALSE_;
#line 17241 ""
	    i__2 = comgrace_1.ngrace;
#line 17241 ""
	    for (ig = 1; ig <= i__2; ++ig) {
#line 17242 ""
		if (! isgaft) {
#line 17243 ""
		    if (comgrace_1.ipg[ig - 1] == ip && comgrace_1.ivg[ig - 1]
			     == commvl_1.ivx) {
#line 17243 ""
			goto L123;
#line 17243 ""
		    }
#line 17244 ""
		} else if (ip > 1) {
#line 17245 ""
		    if (comgrace_1.ipg[ig - 1] == ip - 1 && comgrace_1.ivg[ig 
			    - 1] == commvl_1.ivx) {
#line 17245 ""
			goto L123;
#line 17245 ""
		    }
#line 17246 ""
		}
#line 17247 ""
/* L122: */
#line 17247 ""
	    }
#line 17248 ""
	    s_wsle(&io___1070);
#line 17248 ""
	    do_lio(&c__9, &c__1, "Problem finding grace index in makeabar", (
		    ftnlen)39);
#line 17248 ""
	    e_wsle();
#line 17249 ""
	    s_stop("", (ftnlen)0);
#line 17250 ""
L123:

/*  wgr = distance to backspace (in headwidths), less main acc. */
/*  ptgr = same in pts,+ main acc.  Not used for after-grace. Distance to backspace. */
/*  spgr = total space needed (w/o main acc). */
/*   Also, spgr is same for b4 or after, but xb4fac-space will be in diff. place. */

#line 17257 ""
	    if (comgrace_1.nng[ig - 1] == 1) {
#line 17258 ""
		wgr = spfacs_1.grafac;
#line 17259 ""
		if (comgrace_1.multg[ig - 1] == 0) {
#line 17259 ""
		    wgr += -.4f;
#line 17259 ""
		}
#line 17260 ""
	    } else {
#line 17261 ""
		wgr = comgrace_1.nng[ig - 1] * spfacs_1.emgfac;
#line 17262 ""
		i__2 = comgrace_1.nng[ig - 1];
#line 17262 ""
		for (ing = 2; ing <= i__2; ++ing) {
#line 17263 ""
		    if (comgrace_1.naccg[comgrace_1.ngstrt[ig - 1] - 1 + ing 
			    - 1] > 0) {
#line 17263 ""
			wgr += spfacs_1.acgfac;
#line 17263 ""
		    }
#line 17264 ""
/* L126: */
#line 17264 ""
		}
#line 17265 ""
	    }
#line 17266 ""
	    if (comgrace_1.graspace[ig - 1] > 0.f) {

/*  User-defined space before grace */

#line 17270 ""
		wgr += comgrace_1.graspace[ig - 1];
#line 17271 ""
	    }
#line 17272 ""
	    ptgr[ig - 1] = wgr * wheadpt1;
#line 17273 ""
	    spgr = ptgr[ig - 1] + spfacs_1.xb4fac * wheadpt1;

/* !!! May need to mod for chord accid's */

#line 17277 ""
	    if (isaccs || iscacc) {
#line 17277 ""
		ptgr[ig - 1] += taccfac * wheadpt1;
#line 17277 ""
	    }
#line 17278 ""
	    if (comgrace_1.naccg[comgrace_1.ngstrt[ig - 1] - 1] > 0) {
#line 17278 ""
		spgr += wheadpt1 * spfacs_1.agc1fac;
#line 17278 ""
	    }
#line 17279 ""
	    pts += spgr;

/*  Special check for after-grace on ip-1 and normal on ip. Must go back thru */
/*   loop again for the normal grace. */

#line 17284 ""
	    if (isgaft && ig < comgrace_1.ngrace && ! secondgrace) {
#line 17285 ""
		if (comgrace_1.ipg[ig] == ip) {
#line 17286 ""
		    secondgrace = TRUE_;
#line 17287 ""
		    ++ig;
#line 17288 ""
		    goto L123;
#line 17289 ""
		}
#line 17290 ""
	    }
#line 17291 ""
	}
#line 17292 ""
	if (iscln) {
#line 17293 ""
	    pts += spfacs_1.clefac * wheadpt1;

/*  How far to backspace when printing the clef */

#line 17297 ""
	    ptclef[commvl_1.ivx - 1] = 0.f;

/* !!! May need to mod for chord accid's */

#line 17301 ""
	    if (isaccs || iscacc) {
#line 17301 ""
		ptclef[commvl_1.ivx - 1] += taccfac * wheadpt1;
#line 17301 ""
	    }
#line 17303 ""
	    if (isgrace) {
#line 17303 ""
		ptclef[commvl_1.ivx - 1] += spgr;
#line 17303 ""
	    }
#line 17304 ""
	}
#line 17305 ""
	if (isrshft) {
#line 17306 ""
	    pts += spfacs_1.rtshfac * wheadpt1;
#line 17307 ""
	} else if (isflag) {
#line 17308 ""
	    pts += spfacs_1.flagfac * wheadpt1;
#line 17309 ""
	} else if (isdot) {
#line 17310 ""
	    pts += spfacs_1.dotfac * wheadpt1;
#line 17311 ""
	}
#line 17312 ""
	if ((r__1 = all_1.to[in - 1] - itrpt, dabs(r__1)) < comtol_1.tol) {

/*  Repeat, need a little extra space */

#line 17316 ""
	    pts += spfacs_1.dotsfac * wheadpt1;
#line 17317 ""
	}
#line 17318 ""
	if (isarp) {
#line 17319 ""
	    pts += spfacs_1.arpfac * wheadpt1;
#line 17320 ""
	}

/*  Add in padding space */

#line 17324 ""
	pts += spfacs_1.xspfac * wheadpt1;

/*  Now done with all items needing space except accidentals, */
/*    accidental shifts, and left-notehead-shifts, and will later */
/*    subtract a notehead if at start of bar. */

/*  Get available space in elemskips (esk) */

#line 17332 ""
	isfirst = ip == 1 || (r__1 = all_1.to[in - 1] - itrpt, dabs(r__1)) < 
		comtol_1.tol || (r__2 = all_1.to[in - 1] - itsig, dabs(r__2)) 
		< comtol_1.tol;
#line 17334 ""
	if (isfirst) {

/*  At start of bar or after repeat sign or new signature */

#line 17338 ""
	    if ((r__1 = all_1.to[in - 1] - itsig, dabs(r__1)) < comtol_1.tol) 
		    {
#line 17339 ""
		esk = 0.f;
#line 17340 ""
	    } else {
#line 17341 ""
		esk = comask_1.fbar;
#line 17342 ""
	    }
#line 17343 ""
	} else {

/*  Not 1st note of bar */

#line 17347 ""
	    esk = all_1.eskz[commvl_1.ivx + ip * 24 - 25] - all_1.eskz[
		    commvl_1.ivx + (ip - 1) * 24 - 25];
#line 17348 ""
	}
#line 17349 ""
	if (isgrace) {

/*  Since graces can be very long, cannot assume no interference if prior */
/*  note uses >1 noteskip.  So must get elsk's back to prior note, whether or */
/*  not it used only one noteskip. */
/*  <<But if it was xtup. don't need to call eskb4.>>???? */

/*  10/8/05 Kluge to not zero out esk if in xtup */

#line 17358 ""
	    esksav = esk;
/* Computing MAX */
#line 17359 ""
	    i__2 = 1, i__7 = ip - 2;
#line 17359 ""
	    if ((ip <= 2 || all_1.nodur[commvl_1.ivx + max(i__2,i__7) * 24 - 
		    25] > 0) && (r__1 = all_1.to[in - 1] - itsig, dabs(r__1)) 
		    > comtol_1.tol) {
#line 17359 ""
		eskb4_(&ip, &commvl_1.ivx, &in, &ib, comnsp_2.space, &tstart[
			1], &comask_1.fbar, &itrpt, &esk);
#line 17359 ""
	    }
#line 17362 ""
	    if (dabs(esk) < comtol_1.tol) {
#line 17362 ""
		esk = esksav;
#line 17362 ""
	    }
#line 17363 ""
	}

/*  Done getting available elemskips.  Remove headwidth if first.  Must do here */
/*  rather than earlier since check uses isfirst */

#line 17368 ""
	if (isfirst) {
#line 17368 ""
	    pts -= wheadpt1;
#line 17368 ""
	}

/*  Deal with accidental shifts and left-notehead shifts */

#line 17372 ""
	if (bit_test(all_1.ipl[commvl_1.ivx + ip * 24 - 25],10)) {

/*  In a chord */

#line 17376 ""
	    ptsl = 0.f;
#line 17377 ""
	    if (bit_test(all_1.irest[commvl_1.ivx + ip * 24 - 25],27)) {
#line 17377 ""
		ptsl = wheadpt1;
#line 17377 ""
	    }
/* Computing MAX */
#line 17378 ""
	    r__1 = ptsl, r__2 = icashft * .05f * wheadpt1;
#line 17378 ""
	    ptsadd = dmax(r__1,r__2);

/*  Note: may have icashft=-20000 (if shftmin=-1000 in crdacc) but that's OK */

#line 17382 ""
	} else {

/*  Not in a chord */

#line 17386 ""
	    ihshft = 0;
#line 17387 ""
	    if (isaccs) {
#line 17388 ""
		ihshft = igetbits_(&all_1.nacc[commvl_1.ivx + ip * 24 - 25], &
			c__7, &c__10);
#line 17389 ""
		if (ihshft != 0) {
/* Computing MAX */
#line 17389 ""
		    i__2 = 0, i__7 = 107 - ihshft;
#line 17389 ""
		    ihshft = max(i__2,i__7);
#line 17389 ""
		}
#line 17390 ""
	    }

/* Check for left-shifted main note */

#line 17394 ""
	    if (bit_test(all_1.ipl[commvl_1.ivx + ip * 24 - 25],8)) {
#line 17394 ""
		ihshft = max(20,ihshft);
#line 17394 ""
	    }
#line 17395 ""
	    ptsadd = ihshft * .05f * wheadpt1;
#line 17396 ""
	}
#line 17397 ""
	pts += ptsadd;
#line 17398 ""
	if (isgrace) {
#line 17398 ""
	    ptgr[ig - 1] += ptsadd;
#line 17398 ""
	}
#line 17399 ""
	if (iscln) {
#line 17399 ""
	    ptclef[commvl_1.ivx - 1] += ptsadd;
#line 17399 ""
	}

/*  Left-shifted, non-chord note before? */

#line 17403 ""
	if (ip > 1) {
#line 17404 ""
	    if (! bit_test(all_1.ipl[commvl_1.ivx + (ip - 1) * 24 - 25],10) &&
		     bit_test(all_1.irest[commvl_1.ivx + (ip - 1) * 24 - 25],
		    27)) {
#line 17404 ""
		pts -= wheadpt1;
#line 17404 ""
	    }
#line 17406 ""
	}

/*  Try big accidentals first */

#line 17410 ""
	ptbneed = pts;
#line 17411 ""
	if (isaccs || iscacc) {
#line 17412 ""
	    ptbneed += wheadpt1 * spfacs_1.bacfac;
#line 17413 ""
	}
#line 17414 ""
	if (comshort_1.poefa[all_1.iline - 1] * comask_1.poenom * esk > 
		ptbneed) {

/*  Set flag for big accidental */

#line 17418 ""
	    if (isacc) {
#line 17418 ""
		all_1.nacc[commvl_1.ivx + ip * 24 - 25] = bit_set(all_1.nacc[
			commvl_1.ivx + ip * 24 - 25],3);
#line 17418 ""
	    }
#line 17419 ""
	    goto L99;
#line 17420 ""
	}

/*  Cannot use big, so try small */

#line 17424 ""
	ptsneed = pts;
#line 17425 ""
	if (isaccs || iscacc) {
#line 17426 ""
	    ptsneed += taccfac * wheadpt1;
#line 17427 ""
	}
#line 17428 ""
	if (comshort_1.poefa[all_1.iline - 1] * comask_1.poenom * esk < 
		ptsneed) {
#line 17429 ""
	    r__1 = comshort_1.poefa[all_1.iline - 1] * esk;
#line 17429 ""
	    addask_(&all_1.to[in - 1], &ptsneed, &r__1, &comask_1.fixednew, &
		    comask_1.scaldold, &c_b1020, &comshort_1.poefa[
		    all_1.iline - 1], &c_false);
#line 17431 ""
	}
#line 17432 ""
L99:
#line 17433 ""
	if (bit_test(all_1.iornq[commvl_1.ivx + ip * 24 - 1],26)) {

/*  User-defined space.  Warning, "zero" may change value in addask! */

#line 17437 ""
	    zero = 0.f;
#line 17438 ""
	    addask_(&all_1.to[in - 1], &ptsneed, &zero, &comask_1.fixednew, &
		    comask_1.scaldold, tglp1, &c_b1065, &c_true);
#line 17440 ""
	}

/*  End of big manual loop over "in" for accidental checking */

#line 17444 ""
	goto L111;
#line 17445 ""
L112:

/* End of ask analysis for this block. */

/* Adjust eskz if there are added spaces. Corrects length of xtup brackets. */

#line 17451 ""
	if (comas1_1.naskb > 0) {
#line 17451 ""
	    adjusteskz_(&ib, &istart[1], &comask_1.poenom);
#line 17451 ""
	}

/* Check for internal repeat or sig change. */

#line 17455 ""
	if (ib > 1 && all_1.ivxo[istart[ib] - 1] == 1) {
#line 17456 ""
	    iirpt = all_1.islur[all_1.ipo[istart[ib] - 1] * 24 - 24] & 
		    67109216;
#line 17457 ""
	    if (iirpt > 0) {

/* Internal repeat */

#line 17461 ""
		if (comlast_1.islast) {
#line 17461 ""
		    s_wsfe(&io___1086);
/* Writing concatenation */
#line 17461 ""
		    i__9[0] = 1, a__6[0] = all_1.sq;
#line 17461 ""
		    i__9[1] = 7, a__6[1] = "advance";
#line 17461 ""
		    i__9[2] = 1, a__6[2] = all_1.sq;
#line 17461 ""
		    i__9[3] = 8, a__6[3] = "barno-1%";
#line 17461 ""
		    s_cat(ch__7, a__6, i__9, &c__4, (ftnlen)17);
#line 17461 ""
		    do_fio(&c__1, ch__7, (ftnlen)17);
#line 17461 ""
		    e_wsfe();
#line 17461 ""
		}
#line 17462 ""
		if (iirpt == 96) {
#line 17463 ""
		    if (comlast_1.islast) {
#line 17463 ""
			s_wsfe(&io___1087);
/* Writing concatenation */
#line 17463 ""
			i__4[0] = 1, a__2[0] = all_1.sq;
#line 17463 ""
			i__4[1] = 15, a__2[1] = "leftrightrepeat";
#line 17463 ""
			s_cat(ch__8, a__2, i__4, &c__2, (ftnlen)16);
#line 17463 ""
			do_fio(&c__1, ch__8, (ftnlen)16);
#line 17463 ""
			e_wsfe();
#line 17463 ""
		    }
#line 17464 ""
		    comask_1.fixednew += spfacs_1.lrrptfac * comask_1.wheadpt;
#line 17465 ""
		} else if (bit_test(iirpt,5)) {
#line 17466 ""
		    if (comlast_1.islast) {
#line 17466 ""
			s_wsfe(&io___1088);
/* Writing concatenation */
#line 17466 ""
			i__4[0] = 1, a__2[0] = all_1.sq;
#line 17466 ""
			i__4[1] = 10, a__2[1] = "leftrepeat";
#line 17466 ""
			s_cat(ch__9, a__2, i__4, &c__2, (ftnlen)11);
#line 17466 ""
			do_fio(&c__1, ch__9, (ftnlen)11);
#line 17466 ""
			e_wsfe();
#line 17466 ""
		    }
#line 17467 ""
		    comask_1.fixednew += spfacs_1.rptfac * comask_1.wheadpt;
#line 17468 ""
		} else if (bit_test(iirpt,6)) {
#line 17469 ""
		    if (comlast_1.islast) {
#line 17469 ""
			s_wsfe(&io___1089);
/* Writing concatenation */
#line 17469 ""
			i__4[0] = 1, a__2[0] = all_1.sq;
#line 17469 ""
			i__4[1] = 11, a__2[1] = "rightrepeat";
#line 17469 ""
			s_cat(ch__5, a__2, i__4, &c__2, (ftnlen)12);
#line 17469 ""
			do_fio(&c__1, ch__5, (ftnlen)12);
#line 17469 ""
			e_wsfe();
#line 17469 ""
		    }
#line 17470 ""
		    comask_1.fixednew += spfacs_1.rptfac * comask_1.wheadpt;
#line 17471 ""
		} else if (bit_test(iirpt,8)) {
#line 17472 ""
		    if (comlast_1.islast) {
#line 17472 ""
			s_wsfe(&io___1090);
/* Writing concatenation */
#line 17472 ""
			i__4[0] = 1, a__2[0] = all_1.sq;
#line 17472 ""
			i__4[1] = 9, a__2[1] = "doublebar";
#line 17472 ""
			s_cat(ch__10, a__2, i__4, &c__2, (ftnlen)10);
#line 17472 ""
			do_fio(&c__1, ch__10, (ftnlen)10);
#line 17472 ""
			e_wsfe();
#line 17472 ""
		    }
#line 17473 ""
		} else {
#line 17474 ""
		    s_wsle(&io___1091);
#line 17474 ""
		    do_lio(&c__9, &c__1, "Unexpected mid-bar repeat command "\
			    "R*", (ftnlen)36);
#line 17474 ""
		    e_wsle();
#line 17475 ""
		    stop1_();
#line 17476 ""
		}
#line 17477 ""
		comask_1.scaldold -= comask_1.fbar;
#line 17478 ""
	    }
#line 17479 ""
	    if (bit_test(all_1.ipl[all_1.ipo[istart[ib] - 1] * 24 - 24],28)) {

/*  Internal signature change. */

/* Writing concatenation */
#line 17483 ""
		i__4[0] = 1, a__2[0] = all_1.sq;
#line 17483 ""
		i__4[1] = 17, a__2[1] = "generalsignature{";
#line 17483 ""
		s_cat(notexq, a__2, i__4, &c__2, (ftnlen)79);
#line 17484 ""
		lnote = 18;
#line 17485 ""
		if (comtop_1.isig < 0) {
/* Writing concatenation */
#line 17486 ""
		    i__4[0] = lnote, a__2[0] = notexq;
#line 17486 ""
		    i__4[1] = 1, a__2[1] = "-";
#line 17486 ""
		    s_cat(notexq, a__2, i__4, &c__2, (ftnlen)79);
#line 17487 ""
		    ++lnote;
#line 17488 ""
		}
#line 17489 ""
		if (comlast_1.islast) {
#line 17489 ""
		    s_wsfe(&io___1092);
/* Writing concatenation */
#line 17489 ""
		    i__6[0] = lnote, a__4[0] = notexq;
#line 17489 ""
		    i__2 = abs(comtop_1.isig) + 48;
#line 17489 ""
		    chax_(ch__6, (ftnlen)1, &i__2);
#line 17489 ""
		    i__6[1] = 1, a__4[1] = ch__6;
#line 17489 ""
		    i__6[2] = 2, a__4[2] = "}%";
#line 17489 ""
		    s_cat(ch__2, a__4, i__6, &c__3, (ftnlen)82);
#line 17489 ""
		    do_fio(&c__1, ch__2, lnote + 3);
#line 17489 ""
		    e_wsfe();
#line 17489 ""
		}
#line 17491 ""
		if (comlast_1.islast && comignorenats_1.ignorenats) {
#line 17491 ""
		    s_wsfe(&io___1093);
/* Writing concatenation */
#line 17491 ""
		    i__4[0] = 1, a__2[0] = all_1.sq;
#line 17491 ""
		    i__4[1] = 11, a__2[1] = "ignorenats%";
#line 17491 ""
		    s_cat(ch__5, a__2, i__4, &c__2, (ftnlen)12);
#line 17491 ""
		    do_fio(&c__1, ch__5, (ftnlen)12);
#line 17491 ""
		    e_wsfe();
#line 17491 ""
		}
#line 17493 ""
		if (comlast_1.islast) {
#line 17493 ""
		    s_wsfe(&io___1094);
/* Writing concatenation */
#line 17493 ""
		    i__3[0] = 1, a__1[0] = all_1.sq;
#line 17493 ""
		    i__3[1] = 14, a__1[1] = "zchangecontext";
#line 17493 ""
		    i__3[2] = 1, a__1[2] = all_1.sq;
#line 17493 ""
		    i__3[3] = 12, a__1[3] = "addspace{-.5";
#line 17493 ""
		    i__3[4] = 1, a__1[4] = all_1.sq;
#line 17493 ""
		    i__3[5] = 15, a__1[5] = "afterruleskip}%";
#line 17493 ""
		    s_cat(ch__11, a__1, i__3, &c__6, (ftnlen)44);
#line 17493 ""
		    do_fio(&c__1, ch__11, (ftnlen)44);
#line 17493 ""
		    e_wsfe();
#line 17493 ""
		}
#line 17495 ""
		lnote = 0;
#line 17496 ""
	    }
#line 17497 ""
	}
#line 17498 ""
	comnsp_2.flgndb = FALSE_;

/*  Done with start-of-block stuff.  Begin main loop over voices. */

#line 17502 ""
	i__2 = all_1.nv;
#line 17502 ""
	for (all_1.iv = 1; all_1.iv <= i__2; ++all_1.iv) {
#line 17503 ""
	    i__7 = commvl_1.nvmx[all_1.iv - 1];
#line 17503 ""
	    for (kv = 1; kv <= i__7; ++kv) {
#line 17504 ""
		commvl_1.ivx = commvl_1.ivmx[all_1.iv + kv * 24 - 25];
#line 17505 ""
		icm = commidi_1.midchan[all_1.iv + kv * 24 - 25];

/*  A rather klugey way to set flag for figure in this voice */
/*  Must always check figbass before figchk. */

#line 17510 ""
		if (all_1.figbass) {
#line 17511 ""
		    ivf = 0;
#line 17512 ""
		    if (commvl_1.ivx == 1) {
#line 17513 ""
			ivf = 1;
#line 17514 ""
		    } else if (commvl_1.ivx == comfig_1.ivxfig2) {
#line 17515 ""
			ivf = 2;
#line 17516 ""
		    }
#line 17517 ""
		    if (ivf > 0) {
#line 17517 ""
			all_1.figchk[ivf - 1] = comfig_1.nfigs[ivf - 1] > 0;
#line 17517 ""
		    }
#line 17518 ""
		}
#line 17519 ""
		if (commvl_1.ivx > 1) {
#line 17520 ""
		    if (commvl_1.ivx <= all_1.nv) {
#line 17521 ""
			addstr_(all_1.sepsymq + (all_1.iv - 2), &c__1, soutq, 
				&lsout, (ftnlen)1, (ftnlen)80);
#line 17522 ""
		    } else {
/* Writing concatenation */
#line 17523 ""
			i__4[0] = 1, a__2[0] = all_1.sq;
#line 17523 ""
			i__4[1] = 9, a__2[1] = "nextvoice";
#line 17523 ""
			s_cat(ch__10, a__2, i__4, &c__2, (ftnlen)10);
#line 17523 ""
			addstr_(ch__10, &c__10, soutq, &lsout, (ftnlen)10, (
				ftnlen)80);
#line 17524 ""
		    }
#line 17525 ""
		}
#line 17526 ""
		if (comhead_1.ihdht > 0 && commvl_1.ivx == all_1.nv) {

/*  Write header.  First adjust height if needed to miss barno. */

#line 17530 ""
		    if (comask_1.bar1syst && all_1.iline != 1) {
#line 17531 ""
			comhead_1.ihdht = comsln_1.irzbnd + 15 + 
				comsln_1.isnx;
#line 17532 ""
		    }

/*  Add user-defined vertical shift */

#line 17536 ""
		    comhead_1.ihdht += comhead_1.ihdvrt;
#line 17537 ""
		    lchead = lenstr_(comhead_1.headrq, &c__80, (ftnlen)80);
/* Writing concatenation */
#line 17538 ""
		    i__4[0] = 1, a__2[0] = all_1.sq;
#line 17538 ""
		    i__4[1] = 10, a__2[1] = "zcharnote{";
#line 17538 ""
		    s_cat(notexq, a__2, i__4, &c__2, (ftnlen)79);
#line 17539 ""
		    s_wsfi(&io___1098);
#line 17539 ""
		    do_fio(&c__1, (char *)&comhead_1.ihdht, (ftnlen)sizeof(
			    integer));
#line 17539 ""
		    e_wsfi();
/* Writing concatenation */
#line 17540 ""
		    i__3[0] = 13, a__1[0] = notexq;
#line 17540 ""
		    i__3[1] = 2, a__1[1] = "}{";
#line 17540 ""
		    i__3[2] = 1, a__1[2] = all_1.sq;
#line 17540 ""
		    i__3[3] = 7, a__1[3] = "bigfont";
#line 17540 ""
		    i__3[4] = 1, a__1[4] = all_1.sq;
#line 17540 ""
		    i__3[5] = 10, a__1[5] = "kern-30pt ";
#line 17540 ""
		    s_cat(notexq, a__1, i__3, &c__6, (ftnlen)79);
#line 17541 ""
		    addstr_(notexq, &c__34, soutq, &lsout, (ftnlen)79, (
			    ftnlen)80);
/* Writing concatenation */
#line 17542 ""
		    i__4[0] = lchead, a__2[0] = comhead_1.headrq;
#line 17542 ""
		    i__4[1] = 1, a__2[1] = "}";
#line 17542 ""
		    s_cat(ch__12, a__2, i__4, &c__2, (ftnlen)81);
#line 17542 ""
		    i__10 = lchead + 1;
#line 17542 ""
		    addstr_(ch__12, &i__10, soutq, &lsout, lchead + 1, (
			    ftnlen)80);
#line 17543 ""
		    comhead_1.ihdht = 0;
#line 17544 ""
		}
#line 17545 ""
		if (comhead_1.lower && commvl_1.ivx == all_1.nv) {
#line 17546 ""
		    lclow = lenstr_(comhead_1.lowerq, &c__80, (ftnlen)80);
/* Writing concatenation */
#line 17547 ""
		    i__11[0] = 1, a__7[0] = all_1.sq;
#line 17547 ""
		    i__11[1] = 14, a__7[1] = "zcharnote{-6}{";
#line 17547 ""
		    i__11[2] = 1, a__7[2] = all_1.sq;
#line 17547 ""
		    i__11[3] = 5, a__7[3] = "tempo";
#line 17547 ""
		    i__11[4] = 1, a__7[4] = all_1.sq;
#line 17547 ""
		    i__11[5] = 10, a__7[5] = "kern-10pt ";
#line 17547 ""
		    i__11[6] = lclow, a__7[6] = comhead_1.lowerq;
#line 17547 ""
		    i__11[7] = 1, a__7[7] = "}";
#line 17547 ""
		    s_cat(ch__13, a__7, i__11, &c__8, (ftnlen)113);
#line 17547 ""
		    i__10 = lclow + 33;
#line 17547 ""
		    addstr_(ch__13, &i__10, soutq, &lsout, lclow + 33, (
			    ftnlen)80);
#line 17550 ""
		    comhead_1.lower = FALSE_;
#line 17551 ""
		}
#line 17552 ""
		tnow = tstart[ib];
#line 17553 ""
		nofirst = TRUE_;

/*  Done setting up voice ivx for start of block ib.  Loop over notes in voice. */

#line 17557 ""
		i__10 = istop[ib];
#line 17557 ""
		for (all_1.jn = istart[ib]; all_1.jn <= i__10; ++all_1.jn) {
#line 17558 ""
		    if (all_1.ivxo[all_1.jn - 1] != commvl_1.ivx) {
#line 17558 ""
			goto L10;
#line 17558 ""
		    }
#line 17559 ""
		    ip = all_1.ipo[all_1.jn - 1];

/*  May have problem with not initializing islhgt, so do it here */

#line 17563 ""
		    islhgt = 0;

#line 17565 ""
		    if (nofirst) {
#line 17566 ""
			comoct_1.noctup = 0;
#line 17567 ""
			if (ncmid_(&all_1.iv, &ip) == 23) {
#line 17567 ""
			    comoct_1.noctup = -2;
#line 17567 ""
			}
#line 17568 ""
			nofirst = FALSE_;
#line 17569 ""
		    }

/*  Check for internal floating figure (before last note of group). */

#line 17573 ""
L12:
#line 17573 ""
		    if (all_1.figbass) {
#line 17574 ""
			if (commvl_1.ivx == 1 || commvl_1.ivx == 
				comfig_1.ivxfig2) {
#line 17575 ""
			    ivf = 1;
#line 17576 ""
			    if (commvl_1.ivx > 1) {
#line 17576 ""
				ivf = 2;
#line 17576 ""
			    }
#line 17577 ""
			    if (all_1.figchk[ivf - 1] && (real) 
				    comfig_1.itfig[ivf + (ifig[ivf - 1] << 1) 
				    - 3] < tnow - comtol_1.tol) {

/*  Bypassed figure location. Backup, place fig, return. */

#line 17582 ""
				offnsk = (tnow - comfig_1.itfig[ivf + (ifig[
					ivf - 1] << 1) - 3]) / comnsp_2.space[
					ib - 1];
#line 17583 ""
				putfig_(&ivf, &ifig[ivf - 1], &offnsk, &
					all_1.figchk[ivf - 1], soutq, &lsout, 
					(ftnlen)80);
#line 17585 ""
				goto L12;
#line 17586 ""
			    }
#line 17587 ""
			}
#line 17588 ""
		    }

/*  Put in \sk if needed */

#line 17592 ""
		    if (all_1.to[all_1.jn - 1] > tnow + comtol_1.tol) {
/* Writing concatenation */
#line 17593 ""
			i__4[0] = 1, a__2[0] = all_1.sq;
#line 17593 ""
			i__4[1] = 2, a__2[1] = "sk";
#line 17593 ""
			s_cat(ch__14, a__2, i__4, &c__2, (ftnlen)3);
#line 17593 ""
			addstr_(ch__14, &c__3, soutq, &lsout, (ftnlen)3, (
				ftnlen)80);
#line 17594 ""
			tnow += comnsp_2.space[ib - 1];
#line 17595 ""
			goto L12;
#line 17596 ""
		    }

/*  Check for user-defined shifts */

#line 17600 ""
		    if (bit_test(all_1.irest[commvl_1.ivx + ip * 24 - 25],15) 
			    || bit_test(all_1.irest[commvl_1.ivx + ip * 24 - 
			    25],16)) {
#line 17600 ""
			putshft_(&commvl_1.ivx, &c_true, soutq, &lsout, (
				ftnlen)80);
#line 17600 ""
		    }
#line 17602 ""
L21:
#line 17602 ""
		    if (iaskb[commvl_1.ivx - 1] <= comas1_1.naskb && tnow > 
			    comas1_1.task[iaskb[commvl_1.ivx - 1] - 1] - 
			    comtol_1.tol) {
#line 17604 ""
			if (comas1_1.task[iaskb[commvl_1.ivx - 1] - 1] > 
				tstart[ib] - comtol_1.tol) {

/*  Insert placeholder for accidental skip */

/* Writing concatenation */
#line 17608 ""
			    i__4[0] = 1, a__2[0] = all_1.sq;
#line 17608 ""
			    i__4[1] = 8, a__2[1] = "ask     ";
#line 17608 ""
			    s_cat(ch__15, a__2, i__4, &c__2, (ftnlen)9);
#line 17608 ""
			    addstr_(ch__15, &c__9, soutq, &lsout, (ftnlen)9, (
				    ftnlen)80);
#line 17609 ""
			    ++comas2_1.nasksys;
#line 17610 ""
			    comas2_1.wasksys[comas2_1.nasksys - 1] = 
				    comas1_1.wask[iaskb[commvl_1.ivx - 1] - 1]
				    ;
#line 17611 ""
			    if (comas1_1.wask[iaskb[commvl_1.ivx - 1] - 1] > 
				    0.f) {
#line 17612 ""
				comas2_1.elasksys[comas2_1.nasksys - 1] = 
					comas1_1.elask[iaskb[commvl_1.ivx - 1]
					 - 1];
#line 17613 ""
			    } else {

/*  This is a signal to permit negative ask's.  Should really have elask>=0. */

#line 17617 ""
				comas2_1.elasksys[comas2_1.nasksys - 1] = 
					-comas1_1.elask[iaskb[commvl_1.ivx - 
					1] - 1];
#line 17618 ""
			    }
#line 17619 ""
			}

/*  May have skipped some task's in earlier blocks (due to void voice) */

#line 17623 ""
			++iaskb[commvl_1.ivx - 1];
#line 17624 ""
			goto L21;
#line 17625 ""
		    }
#line 17626 ""
		    if (all_1.figbass) {
#line 17627 ""
			if (commvl_1.ivx == 1 || commvl_1.ivx == 
				comfig_1.ivxfig2) {
#line 17628 ""
			    ivf = 1;
#line 17629 ""
			    if (commvl_1.ivx > 1) {
#line 17629 ""
				ivf = 2;
#line 17629 ""
			    }
#line 17630 ""
			    if (all_1.figchk[ivf - 1] && (r__1 = 
				    comfig_1.itfig[ivf + (ifig[ivf - 1] << 1) 
				    - 3] - tnow, dabs(r__1)) < comtol_1.tol) {

/*  Figure on a note.  NB: later special check for late figs. */

#line 17635 ""
				putfig_(&ivf, &ifig[ivf - 1], &c_b1020, &
					all_1.figchk[ivf - 1], soutq, &lsout, 
					(ftnlen)80);
#line 17636 ""
			    }
#line 17637 ""
			}
#line 17638 ""
		    }

/*  Check for new clef here. */

#line 17642 ""
		    if (isclef && bit_test(all_1.islur[commvl_1.ivx + ip * 24 
			    - 25],11)) {
#line 17643 ""
			if (ptclef[all_1.iv - 1] > 0.f) {
/* Writing concatenation */
#line 17644 ""
			    i__4[0] = 1, a__2[0] = all_1.sq;
#line 17644 ""
			    i__4[1] = 5, a__2[1] = "off{-";
#line 17644 ""
			    s_cat(notexq, a__2, i__4, &c__2, (ftnlen)79);
#line 17645 ""
			    if (ptclef[all_1.iv - 1] < 9.95f) {
#line 17646 ""
				s_wsfi(&io___1104);
#line 17646 ""
				do_fio(&c__1, (char *)&ptclef[all_1.iv - 1], (
					ftnlen)sizeof(real));
#line 17646 ""
				e_wsfi();
#line 17647 ""
				lnote = 9;
#line 17648 ""
			    } else {
#line 17649 ""
				s_wsfi(&io___1105);
#line 17649 ""
				do_fio(&c__1, (char *)&ptclef[all_1.iv - 1], (
					ftnlen)sizeof(real));
#line 17649 ""
				e_wsfi();
#line 17650 ""
				lnote = 10;
#line 17651 ""
			    }
/* Writing concatenation */
#line 17652 ""
			    i__4[0] = lnote, a__2[0] = notexq;
#line 17652 ""
			    i__4[1] = 3, a__2[1] = "pt}";
#line 17652 ""
			    s_cat(notexq, a__2, i__4, &c__2, (ftnlen)79);
#line 17653 ""
			    lnote += 3;
#line 17654 ""
			    addstr_(notexq, &lnote, soutq, &lsout, (ftnlen)79,
				     (ftnlen)80);
#line 17655 ""
			}
#line 17656 ""
			clefsym_(&all_1.islur[all_1.iv + ip * 24 - 25], 
				notexq, &lnote, &nclef, (ftnlen)79);

/* 151220 If clef is treblelowoct, change '0' in pos'n 9 to '8' */

#line 17660 ""
			if (bit_test(all_1.ipl[commvl_1.ivx + ip * 24 - 25],2)
				) {
/* Writing concatenation */
#line 17660 ""
			    i__6[0] = 8, a__4[0] = notexq;
#line 17660 ""
			    i__6[1] = 1, a__4[1] = "8";
#line 17660 ""
			    i__6[2] = 1, a__4[2] = notexq + 9;
#line 17660 ""
			    s_cat(notexq, a__4, i__6, &c__3, (ftnlen)79);
#line 17660 ""
			}
#line 17662 ""
			addstr_(notexq, &lnote, soutq, &lsout, (ftnlen)79, (
				ftnlen)80);
#line 17663 ""
			if (ptclef[all_1.iv - 1] > 0.f) {
/* Writing concatenation */
#line 17664 ""
			    i__4[0] = 1, a__2[0] = all_1.sq;
#line 17664 ""
			    i__4[1] = 4, a__2[1] = "off{";
#line 17664 ""
			    s_cat(notexq, a__2, i__4, &c__2, (ftnlen)79);
#line 17665 ""
			    if (ptclef[all_1.iv - 1] < 9.95f) {
#line 17666 ""
				s_wsfi(&io___1107);
#line 17666 ""
				do_fio(&c__1, (char *)&ptclef[all_1.iv - 1], (
					ftnlen)sizeof(real));
#line 17666 ""
				e_wsfi();
#line 17667 ""
				lnote = 8;
#line 17668 ""
			    } else {
#line 17669 ""
				s_wsfi(&io___1108);
#line 17669 ""
				do_fio(&c__1, (char *)&ptclef[all_1.iv - 1], (
					ftnlen)sizeof(real));
#line 17669 ""
				e_wsfi();
#line 17670 ""
				lnote = 9;
#line 17671 ""
			    }
/* Writing concatenation */
#line 17672 ""
			    i__4[0] = lnote, a__2[0] = notexq;
#line 17672 ""
			    i__4[1] = 3, a__2[1] = "pt}";
#line 17672 ""
			    s_cat(notexq, a__2, i__4, &c__2, (ftnlen)79);
#line 17673 ""
			    lnote += 3;
#line 17674 ""
			    addstr_(notexq, &lnote, soutq, &lsout, (ftnlen)79,
				     (ftnlen)80);
#line 17675 ""
			}
#line 17676 ""
		    }

/*  Checking for literal TeX string BEFORE starting beams!! */

#line 17680 ""
		    if (bit_test(all_1.islur[commvl_1.ivx + ip * 24 - 25],16))
			     {
#line 17681 ""
			i__12 = comgrace_1.nlit;
#line 17681 ""
			for (il = 1; il <= i__12; ++il) {
#line 17682 ""
			    if (comgrace_1.iplit[il - 1] == ip && 
				    comgrace_1.ivlit[il - 1] == commvl_1.ivx) 
				    {
#line 17682 ""
				goto L125;
#line 17682 ""
			    }
#line 17683 ""
/* L124: */
#line 17683 ""
			}
#line 17684 ""
			s_wsle(&io___1110);
#line 17684 ""
			do_lio(&c__9, &c__1, "Problem finding index for lite"\
				"ral string", (ftnlen)40);
#line 17684 ""
			e_wsle();
#line 17685 ""
			stop1_();
#line 17686 ""
L125:

/*  Write a type 1 tex string. */

#line 17690 ""
			if (comgrace_1.lenlit[il - 1] < 71) {

/*  Add normally */

#line 17694 ""
			    addstr_(comgrace_1.litq + (il - 1 << 7), &
				    comgrace_1.lenlit[il - 1], soutq, &lsout, 
				    (ftnlen)128, (ftnlen)80);
#line 17695 ""
			} else {

/*  Longer than 71.  Write souq, Write string, start new soutq. */

#line 17699 ""
			    if (comlast_1.islast) {
#line 17699 ""
				s_wsfe(&io___1111);
/* Writing concatenation */
#line 17699 ""
				i__4[0] = lsout, a__2[0] = soutq;
#line 17699 ""
				i__4[1] = 1, a__2[1] = "%";
#line 17699 ""
				s_cat(ch__12, a__2, i__4, &c__2, (ftnlen)81);
#line 17699 ""
				do_fio(&c__1, ch__12, lsout + 1);
#line 17699 ""
				e_wsfe();
#line 17699 ""
			    }
#line 17700 ""
			    if (comlast_1.islast) {
#line 17700 ""
				s_wsfe(&io___1112);
/* Writing concatenation */
#line 17700 ""
				i__4[0] = comgrace_1.lenlit[il - 1], a__2[0] =
					 comgrace_1.litq + (il - 1 << 7);
#line 17700 ""
				i__4[1] = 1, a__2[1] = "%";
#line 17700 ""
				s_cat(ch__16, a__2, i__4, &c__2, (ftnlen)129);
#line 17700 ""
				do_fio(&c__1, ch__16, comgrace_1.lenlit[il - 
					1] + 1);
#line 17700 ""
				e_wsfe();
#line 17700 ""
			    }
#line 17701 ""
			    lsout = 0;
#line 17702 ""
			}
#line 17703 ""
		    }

/*  Arpeggio on a main (non-chordal) note? */

#line 17707 ""
		    if (bit_test(all_1.iornq[commvl_1.ivx + ip * 24 - 1],27)) 
			    {
#line 17708 ""
			i__12 = ncmid_(&all_1.iv, &ip);
#line 17708 ""
			putarp_(&tnow, &commvl_1.ivx, &ip, &all_1.nolev[
				commvl_1.ivx + ip * 24 - 25], &i__12, soutq, &
				lsout, (ftnlen)80);
#line 17710 ""
		    }

/*  See if a beam starts here */

#line 17714 ""
		    if (numbms[commvl_1.ivx] > 0 && all_1.ibmcnt[commvl_1.ivx 
			    - 1] <= numbms[commvl_1.ivx] && all_1.ibm1[
			    commvl_1.ivx + all_1.ibmcnt[commvl_1.ivx - 1] * 
			    24 - 25] == ip || bit_test(all_1.nacc[
			    commvl_1.ivx + ip * 24 - 25],21)) {
#line 17717 ""
			if (! bit_test(all_1.irest[commvl_1.ivx + ip * 24 - 
				25],24)) {

/*  Not a jump start */

#line 17721 ""
			    if (comkbdrests_1.kbdrests && bit_test(
				    all_1.irest[commvl_1.ivx + ip * 24 - 25],
				    0) && ! bit_test(all_1.islur[commvl_1.ivx 
				    + ip * 24 - 25],29) && commvl_1.nvmx[
				    all_1.iv - 1] == 2 && all_1.nolev[
				    commvl_1.ivx + ip * 24 - 25] <= 50) {
#line 17721 ""
				chkkbdrests_(&ip, &all_1.iv, &commvl_1.ivx, 
					all_1.nn, all_1.islur, all_1.irest, 
					all_1.nolev, commvl_1.ivmx, all_1.nib,
					 &all_1.nv, &all_1.ibar, &tnow, &
					comtol_1.tol, all_1.nodur, &c__2, 
					comkbdrests_1.levtopr, 
					comkbdrests_1.levbotr, all_1.mult, 
					all_1.ipl);
#line 17721 ""
			    }
#line 17727 ""
			    beamstrt_(notexq, &lnote, nornb, ihornb, 
				    comnsp_2.space, &squez[1], &ib, (ftnlen)
				    79);

/*  Shift beam start if notehead was shifted */

#line 17731 ""
			    if (bit_test(all_1.ipl[commvl_1.ivx + ip * 24 - 
				    25],8)) {
/* Writing concatenation */
#line 17732 ""
				i__4[0] = 1, a__2[0] = all_1.sq;
#line 17732 ""
				i__4[1] = 5, a__2[1] = "loff{";
#line 17732 ""
				s_cat(ch__17, a__2, i__4, &c__2, (ftnlen)6);
#line 17732 ""
				addstr_(ch__17, &c__6, soutq, &lsout, (ftnlen)
					6, (ftnlen)80);
#line 17733 ""
			    } else if (bit_test(all_1.ipl[commvl_1.ivx + ip * 
				    24 - 25],9)) {
/* Writing concatenation */
#line 17734 ""
				i__4[0] = 1, a__2[0] = all_1.sq;
#line 17734 ""
				i__4[1] = 5, a__2[1] = "roff{";
#line 17734 ""
				s_cat(ch__17, a__2, i__4, &c__2, (ftnlen)6);
#line 17734 ""
				addstr_(ch__17, &c__6, soutq, &lsout, (ftnlen)
					6, (ftnlen)80);
#line 17735 ""
			    }
#line 17736 ""
			    if (lnote > 0) {
#line 17736 ""
				addstr_(notexq, &lnote, soutq, &lsout, (
					ftnlen)79, (ftnlen)80);
#line 17736 ""
			    }
#line 17737 ""
			    if (bit_test(all_1.ipl[commvl_1.ivx + ip * 24 - 
				    25],8) || bit_test(all_1.ipl[commvl_1.ivx 
				    + ip * 24 - 25],9)) {
#line 17737 ""
				addstr_("}", &c__1, soutq, &lsout, (ftnlen)1, 
					(ftnlen)80);
#line 17737 ""
			    }
#line 17739 ""
			} else {

/*  Jump start.  Set marker for second part of a jump beam. Note ivbj2 was set */
/*  to 0 at end of first part of jump beam */

#line 17744 ""
			    combjmp_1.ivbj2 = commvl_1.ivx;

/*  Check for xtup since we bypassed beamstrt wherein vxtup is normally set */

#line 17748 ""
			    if (bit_test(all_1.irest[commvl_1.ivx + ip * 24 - 
				    25],28) && strtmid_1.ixrest[commvl_1.ivx 
				    - 1] != 2) {
#line 17748 ""
				comxtup_1.vxtup[commvl_1.ivx - 1] = TRUE_;
#line 17748 ""
			    }

/*  Since beamstrt is not called, and drawbm is normally set there, need to set */
/*    it here.  This could cause problems if someone tries a staff-jumping, */
/*    unbarred beam, which I'll deal with when it comes up. */

#line 17755 ""
			    comdraw_1.drawbm[commvl_1.ivx - 1] = TRUE_;
#line 17756 ""
			}
#line 17757 ""
			if (strtmid_1.ixrest[commvl_1.ivx - 1] == 0) {
#line 17758 ""
			    all_1.beamon[commvl_1.ivx - 1] = TRUE_;
#line 17759 ""
			    bspend = TRUE_;
#line 17760 ""
			    if (! bit_test(all_1.irest[commvl_1.ivx + ip * 24 
				    - 25],24)) {
#line 17760 ""
				bspend = TRUE_;
#line 17760 ""
			    }
#line 17761 ""
			}
#line 17762 ""
		    }

/*  Setup for chords and possible slurs in chords */

#line 17766 ""
		    if (bit_test(all_1.ipl[commvl_1.ivx + ip * 24 - 25],10)) {

/*  There is a chord on this note. Just rerun precrd. Klunky, but saves */
/*    me from tracking down errors instroduced when I moved 1st call */
/*    forward for accidental spacing analysis. */

#line 17772 ""
			if (all_1.beamon[commvl_1.ivx - 1]) {
#line 17773 ""
			    precrd_(&commvl_1.ivx, &ip, &all_1.nolev[
				    commvl_1.ivx + ip * 24 - 25], &all_1.nacc[
				    commvl_1.ivx + ip * 24 - 25], &all_1.ipl[
				    commvl_1.ivx + ip * 24 - 25], &
				    all_1.irest[commvl_1.ivx + ip * 24 - 25], 
				    all_1.ulq + (commvl_1.ivx + all_1.ibmcnt[
				    commvl_1.ivx - 1] * 24 - 25), &c_true, &
				    icashft, (ftnlen)1);
#line 17776 ""
			} else {
#line 17777 ""
			    i__12 = ncmid_(&all_1.iv, &ip);
#line 17777 ""
			    udqq_(ch__6, (ftnlen)1, &all_1.nolev[commvl_1.ivx 
				    + ip * 24 - 25], &i__12, &all_1.islur[
				    commvl_1.ivx + ip * 24 - 25], &
				    commvl_1.nvmx[all_1.iv - 1], &
				    commvl_1.ivx, &all_1.nv);
#line 17777 ""
			    precrd_(&commvl_1.ivx, &ip, &all_1.nolev[
				    commvl_1.ivx + ip * 24 - 25], &all_1.nacc[
				    commvl_1.ivx + ip * 24 - 25], &all_1.ipl[
				    commvl_1.ivx + ip * 24 - 25], &
				    all_1.irest[commvl_1.ivx + ip * 24 - 25], 
				    ch__6, &c_true, &icashft, (ftnlen)1);
#line 17781 ""
			}
#line 17782 ""
		    }

/*  Is there slur or grace activity? */

#line 17786 ""
		    isgrace = bit_test(all_1.islur[commvl_1.ivx + ip * 24 - 
			    25],4);
#line 17787 ""
		    if (ip > 1) {
#line 17787 ""
			isgrace = isgrace || bit_test(all_1.ipl[commvl_1.ivx 
				+ (ip - 1) * 24 - 25],31);
#line 17787 ""
		    }

/*  isgrace if not 1st note in bar and previous note has Way-after grace. */

#line 17791 ""
		    if (bit_test(all_1.islur[commvl_1.ivx + ip * 24 - 25],0) 
			    || isgrace) {
#line 17792 ""
			if (bit_test(all_1.islur[commvl_1.ivx + ip * 24 - 25],
				0)) {
#line 17793 ""
			    if (comslur_1.fontslur) {

/*  Call routine for non-postscript slurs */

#line 17797 ""
				i__12 = ncmid_(&all_1.iv, &ip);
#line 17797 ""
				doslur_(&all_1.nolev[commvl_1.ivx + ip * 24 - 
					25], all_1.isdat1, all_1.isdat2, 
					all_1.isdat3, &all_1.nsdat, &ip, &
					all_1.iv, &kv, &all_1.nv, &
					all_1.beamon[commvl_1.ivx - 1], &
					i__12, soutq, &lsout, all_1.ulq + (
					commvl_1.ivx + all_1.ibmcnt[
					commvl_1.ivx - 1] * 24 - 25), &
					all_1.islur[commvl_1.ivx + ip * 24 - 
					25], &all_1.ipl[commvl_1.ivx + ip * 
					24 - 25], &all_1.iornq[commvl_1.ivx + 
					ip * 24 - 1], &islhgt, &all_1.tnote[
					comipl2_1.ipl2[commvl_1.ivx + ip * 24 
					- 25] - 1], &all_1.nacc[commvl_1.ivx 
					+ ip * 24 - 25], (ftnlen)80, (ftnlen)
					1);
#line 17802 ""
			    } else {

/*  Postscript slurs */

#line 17806 ""
				i__12 = ncmid_(&all_1.iv, &ip);
#line 17806 ""
				dopsslur_(&all_1.nolev[commvl_1.ivx + ip * 24 
					- 25], all_1.isdat1, all_1.isdat2, 
					all_1.isdat3, all_1.isdat4, &
					all_1.nsdat, &ip, &all_1.iv, &kv, &
					all_1.nv, &all_1.beamon[commvl_1.ivx 
					- 1], &i__12, soutq, &lsout, 
					all_1.ulq + (commvl_1.ivx + 
					all_1.ibmcnt[commvl_1.ivx - 1] * 24 - 
					25), &all_1.islur[commvl_1.ivx + ip * 
					24 - 25], &all_1.ipl[commvl_1.ivx + 
					ip * 24 - 25], &all_1.iornq[
					commvl_1.ivx + ip * 24 - 1], &islhgt, 
					&all_1.tnote[comipl2_1.ipl2[
					commvl_1.ivx + ip * 24 - 25] - 1], &
					all_1.nacc[commvl_1.ivx + ip * 24 - 
					25], (ftnlen)80, (ftnlen)1);
#line 17812 ""
			    }
#line 17813 ""
			}
#line 17814 ""
			if (isgrace) {

/* Grace note. */

#line 17818 ""
			    iphold = ip;
#line 17819 ""
			    isgrace = FALSE_;
#line 17820 ""
			    if (ip > 1) {
#line 17820 ""
				isgrace = bit_test(all_1.ipl[commvl_1.ivx + (
					ip - 1) * 24 - 25],31);
#line 17820 ""
			    }
#line 17821 ""
			    if (isgrace) {
#line 17821 ""
				--iphold;
#line 17821 ""
			    }
#line 17822 ""
			    isgrace = isgrace || ! bit_test(all_1.ipl[
				    commvl_1.ivx + ip * 24 - 25],31) && ! 
				    bit_test(all_1.ipl[commvl_1.ivx + ip * 24 
				    - 25],29);

/* Place grace now if (a) Way-after from prev note and ip>1 or (b) Pre-grace */
/*   on current note.  Do A-grace on current note, and W-grace at barend, later. */

#line 17828 ""
			    if (isgrace) {
#line 17829 ""
				i__12 = ncmid_(&all_1.iv, &ip);
#line 17829 ""
				i__13 = ncmid_(&all_1.iv, &ip);
#line 17829 ""
				dograce_(&commvl_1.ivx, &iphold, ptgr, soutq, 
					&lsout, &i__12, &all_1.nacc[
					commvl_1.ivx + ip * 24 - 25], &ig, &
					all_1.ipl[commvl_1.ivx + iphold * 24 
					- 25], &c_false, &all_1.beamon[
					commvl_1.ivx - 1], &all_1.nolev[
					commvl_1.ivx + ip * 24 - 25], &i__13, 
					&all_1.islur[commvl_1.ivx + ip * 24 - 
					25], &commvl_1.nvmx[all_1.iv - 1], &
					all_1.nv, &all_1.ibmcnt[commvl_1.ivx 
					- 1], &all_1.tnote[comipl2_1.ipl2[
					commvl_1.ivx + ip * 24 - 25] - 1], 
					all_1.ulq, &cominsttrans_1.instno[
					all_1.iv - 1], (ftnlen)80, (ftnlen)1);
/* 130324 */
#line 17835 ""
				if (comgrace_1.slurg[ig - 1]) {

/* Terminate slur started in dograce.  Get direction of main note stem */

#line 17839 ""
				    if (! all_1.beamon[commvl_1.ivx - 1]) {

/*  Separate note.  Get stem direction. */

#line 17843 ""
					i__12 = ncmid_(&all_1.iv, &ip);
#line 17843 ""
					udqq_(ch__6, (ftnlen)1, &all_1.nolev[
						commvl_1.ivx + ip * 24 - 25], 
						&i__12, &all_1.islur[
						commvl_1.ivx + ip * 24 - 25], 
						&commvl_1.nvmx[all_1.iv - 1], 
						&commvl_1.ivx, &all_1.nv);
#line 17843 ""
					stemup = *(unsigned char *)&ch__6[0] 
						== 'u';
#line 17845 ""
				    } else {

/*  In a beam */

#line 17849 ""
					stemup = *(unsigned char *)&all_1.ulq[
						commvl_1.ivx + all_1.ibmcnt[
						commvl_1.ivx - 1] * 24 - 25] 
						== 'u';
#line 17850 ""
				    }

/*  Stop the shift if whole note */

#line 17854 ""
				    stemup = stemup || all_1.tnote[
					    comipl2_1.ipl2[commvl_1.ivx + ip *
					     24 - 25] - 1] > 63.f;
#line 17856 ""
				    L__1 = ! comgrace_1.upg[ig - 1];
#line 17856 ""
				    i__12 = ncmid_(&all_1.iv, &ip);
#line 17856 ""
				    endslur_(&stemup, &L__1, &all_1.nolev[
					    commvl_1.ivx + ip * 24 - 25], &
					    c__0, &comslur_1.ndxslur, &c__0, &
					    i__12, soutq, &lsout, &
					    comslur_1.fontslur, (ftnlen)80);
#line 17858 ""
				}
#line 17859 ""
			    }
#line 17860 ""
			}
#line 17861 ""
			if (bit_test(all_1.iornq[commvl_1.ivx + ip * 24 - 1],
				24)) {

/*  Start slur on main note for After- or Way-after-grace. */

#line 17865 ""
			    i__12 = 16777215 - comslur_1.listslur;
#line 17865 ""
			    comslur_1.ndxslur = log2_(&i__12);

/*  Get note name */

#line 17869 ""
			    i__12 = ncmid_(&all_1.iv, &ip);
#line 17869 ""
			    notefq_(noteq, &lnoten, &all_1.nolev[commvl_1.ivx 
				    + ip * 24 - 25], &i__12, (ftnlen)8);

/*  Get slur direction */

#line 17873 ""
			    *(unsigned char *)slurudq = 'u';
#line 17874 ""
			    if (! all_1.beamon[commvl_1.ivx - 1]) {
#line 17875 ""
				i__12 = ncmid_(&all_1.iv, &ip);
#line 17875 ""
				udqq_(ch__6, (ftnlen)1, &all_1.nolev[
					commvl_1.ivx + ip * 24 - 25], &i__12, 
					&all_1.islur[commvl_1.ivx + ip * 24 - 
					25], &commvl_1.nvmx[all_1.iv - 1], &
					commvl_1.ivx, &all_1.nv);
#line 17875 ""
				if (*(unsigned char *)&ch__6[0] == 'u') {
#line 17875 ""
				    *(unsigned char *)slurudq = 'd';
#line 17875 ""
				}
#line 17877 ""
			    } else {
#line 17878 ""
				if (*(unsigned char *)&all_1.ulq[commvl_1.ivx 
					+ all_1.ibmcnt[commvl_1.ivx - 1] * 24 
					- 25] == 'u') {
#line 17878 ""
				    *(unsigned char *)slurudq = 'd';
#line 17878 ""
				}
#line 17879 ""
			    }

/*  Replace ndxslur by 23-ndxslur when printing only. */

#line 17883 ""
			    if (23 - comslur_1.ndxslur < 10) {
/* Writing concatenation */
#line 17884 ""
				i__5[0] = 1, a__3[0] = all_1.sq;
#line 17884 ""
				i__5[1] = 5, a__3[1] = "islur";
#line 17884 ""
				i__5[2] = 1, a__3[2] = slurudq;
#line 17884 ""
				i__12 = 71 - comslur_1.ndxslur;
#line 17884 ""
				chax_(ch__6, (ftnlen)1, &i__12);
#line 17884 ""
				i__5[3] = 1, a__3[3] = ch__6;
#line 17884 ""
				i__5[4] = lnoten, a__3[4] = noteq;
#line 17884 ""
				s_cat(notexq, a__3, i__5, &c__5, (ftnlen)79);
#line 17886 ""
				i__12 = lnoten + 8;
#line 17886 ""
				addstr_(notexq, &i__12, soutq, &lsout, (
					ftnlen)79, (ftnlen)80);
#line 17887 ""
			    } else if (23 - comslur_1.ndxslur < 20) {
/* Writing concatenation */
#line 17888 ""
				i__14[0] = 1, a__8[0] = all_1.sq;
#line 17888 ""
				i__14[1] = 5, a__8[1] = "islur";
#line 17888 ""
				i__14[2] = 1, a__8[2] = slurudq;
#line 17888 ""
				i__14[3] = 2, a__8[3] = "{1";
#line 17888 ""
				i__12 = 61 - comslur_1.ndxslur;
#line 17888 ""
				chax_(ch__6, (ftnlen)1, &i__12);
#line 17888 ""
				i__14[4] = 1, a__8[4] = ch__6;
#line 17888 ""
				i__14[5] = 1, a__8[5] = "}";
#line 17888 ""
				i__14[6] = lnoten, a__8[6] = noteq;
#line 17888 ""
				s_cat(notexq, a__8, i__14, &c__7, (ftnlen)79);
#line 17890 ""
				i__12 = lnoten + 11;
#line 17890 ""
				addstr_(notexq, &i__12, soutq, &lsout, (
					ftnlen)79, (ftnlen)80);
#line 17891 ""
			    } else {
/* Writing concatenation */
#line 17892 ""
				i__14[0] = 1, a__8[0] = all_1.sq;
#line 17892 ""
				i__14[1] = 5, a__8[1] = "islur";
#line 17892 ""
				i__14[2] = 1, a__8[2] = slurudq;
#line 17892 ""
				i__14[3] = 2, a__8[3] = "{2";
#line 17892 ""
				i__12 = 51 - comslur_1.ndxslur;
#line 17892 ""
				chax_(ch__6, (ftnlen)1, &i__12);
#line 17892 ""
				i__14[4] = 1, a__8[4] = ch__6;
#line 17892 ""
				i__14[5] = 1, a__8[5] = "}";
#line 17892 ""
				i__14[6] = lnoten, a__8[6] = noteq;
#line 17892 ""
				s_cat(notexq, a__8, i__14, &c__7, (ftnlen)79);
#line 17894 ""
				i__12 = lnoten + 11;
#line 17894 ""
				addstr_(notexq, &i__12, soutq, &lsout, (
					ftnlen)79, (ftnlen)80);
#line 17895 ""
			    }
#line 17896 ""
			    setbits_(&all_1.ipl[commvl_1.ivx + ip * 24 - 25], 
				    &c__5, &c__23, &comslur_1.ndxslur);
#line 17897 ""
			    if (bit_test(all_1.ipl[commvl_1.ivx + ip * 24 - 
				    25],31)) {
#line 17897 ""
				comslur_1.listslur = bit_set(
					comslur_1.listslur,comslur_1.ndxslur);
#line 17897 ""
			    }

/*  Starting slur on W-grace on THIS note.  Record ndxslur. */

#line 17902 ""
			}
#line 17903 ""
		    }

/*  Process dynamic marks */

#line 17907 ""
		    if (bit_test(all_1.irest[commvl_1.ivx + ip * 24 - 25],26))
			     {
#line 17908 ""
			i__12 = ncmid_(&all_1.iv, &ip);
#line 17908 ""
			L__1 = all_1.nodur[commvl_1.ivx + ip * 24 - 25] >= 64;
#line 17908 ""
			dodyn_(&commvl_1.ivx, &ip, &all_1.nolev[commvl_1.ivx 
				+ ip * 24 - 25], &i__12, &all_1.ipl[
				commvl_1.ivx + ip * 24 - 25], &all_1.islur[
				commvl_1.ivx + ip * 24 - 25], &all_1.irest[
				commvl_1.ivx + ip * 24 - 25], &commvl_1.nvmx[
				all_1.iv - 1], &all_1.nv, &all_1.beamon[
				commvl_1.ivx - 1], ihornb, nornb, all_1.ulq, &
				all_1.ibmcnt[commvl_1.ivx - 1], &L__1, soutq, 
				&lsout, (ftnlen)1, (ftnlen)80);
#line 17912 ""
		    }

/*  Check for chord notes.  Moved up from below, 10/27/96 so chord orns done 1st. */

#line 17916 ""
		    if (bit_test(all_1.ipl[commvl_1.ivx + ip * 24 - 25],10)) {

/*  Need a duration to set type of note head */

/*  Clumsy test, but vxtup is not set until main note is processed. */

#line 17922 ""
			if (! (comxtup_1.vxtup[commvl_1.ivx - 1] || bit_test(
				all_1.irest[commvl_1.ivx + ip * 24 - 25],28)))
				 {
#line 17923 ""
			    nodu = all_1.nodur[commvl_1.ivx + ip * 24 - 25];
#line 17924 ""
			} else if (bit_test(all_1.irest[commvl_1.ivx + ip * 
				24 - 25],2) || ip > 1 && bit_test(all_1.irest[
				commvl_1.ivx + (ip - 1) * 24 - 25],2)) {

/* In a 2-note tremolo */

#line 17929 ""
			    if (bit_test(all_1.irest[commvl_1.ivx + ip * 24 - 
				    25],2)) {

/* First note of tremolo, duration is on next note */

#line 17933 ""
				nodu = all_1.nodur[commvl_1.ivx + (ip + 1) * 
					24 - 25];
#line 17934 ""
			    } else {
#line 17935 ""
				nodu = all_1.nodur[commvl_1.ivx + ip * 24 - 
					25];
#line 17936 ""
			    }
#line 17937 ""
			} else if ((all_1.mult[commvl_1.ivx + ip * 24 - 25] & 
				15) - 8 < 0) {
#line 17938 ""
			    nodu = 32;
#line 17939 ""
			} else {
#line 17940 ""
			    nodu = 16;
#line 17941 ""
			}
#line 17942 ""
			i__12 = ncmid_(&all_1.iv, &ip);
#line 17942 ""
			L__1 = bit_test(all_1.nacc[commvl_1.ivx + ip * 24 - 
				25],27);
#line 17942 ""
			docrd_(&commvl_1.ivx, &ip, &nodu, &i__12, &all_1.iv, &
				tnow, soutq, &lsout, all_1.ulq, &all_1.ibmcnt[
				commvl_1.ivx - 1], &all_1.islur[commvl_1.ivx 
				+ ip * 24 - 25], &commvl_1.nvmx[all_1.iv - 1],
				 &all_1.nv, &all_1.beamon[commvl_1.ivx - 1], &
				all_1.nolev[commvl_1.ivx + ip * 24 - 25], 
				ihornb, nornb, &all_1.stemlen, &L__1, &
				all_1.nacc[commvl_1.ivx + ip * 24 - 25], 
				all_1.irest, (ftnlen)80, (ftnlen)1);
#line 17947 ""
		    }

/*  Now that chords are done, add stuff to midi file */

#line 17951 ""
		    if (commidi_1.ismidi) {
#line 17951 ""
			i__12 = all_1.nolev[commvl_1.ivx + ip * 24 - 25] + 
				commvel_1.miditran[cominsttrans_1.instno[
				all_1.iv - 1] - 1];
#line 17951 ""
			i__13 = all_1.nacc[commvl_1.ivx + ip * 24 - 25] & 7;
#line 17951 ""
			L__1 = bit_test(all_1.irest[commvl_1.ivx + ip * 24 - 
				25],0);
#line 17951 ""
			addmidi_(&icm, &i__12, &i__13, &commidisig_1.midisig, 
				&all_1.tnote[comipl2_1.ipl2[commvl_1.ivx + ip 
				* 24 - 25] - 1], &L__1, &c_false);
#line 17951 ""
		    }
/* 130316 */

/*  Check for breath or caesura */

#line 17960 ""
		    if (bit_test(all_1.iornq[commvl_1.ivx + ip * 24 - 1],28)) 
			    {
#line 17961 ""
			putcb_(&commvl_1.ivx, &ip, notexq, &lnote, (ftnlen)79)
				;
#line 17962 ""
			addstr_(notexq, &lnote, soutq, &lsout, (ftnlen)79, (
				ftnlen)80);
#line 17963 ""
		    }

/*  Check for main-note ornaments. ')' on dotted notes go in with note, not here. */
/*  Bits 0-13: (stmgx+Tupf._) ; 14: Down fermata, was F */
/*  15: Trill w/o "tr", was U , 16-18 edit. accid., 19-21 TBD */

#line 17969 ""
		    isacc = (all_1.iornq[commvl_1.ivx + ip * 24 - 1] & 
			    1614807023) > 0;

/*  isacc=.true. if any ornament except segno */

#line 17973 ""
		    if (bit_test(all_1.iornq[commvl_1.ivx + ip * 24 - 1],13) 
			    && all_1.nodur[commvl_1.ivx + ip * 24 - 25] > 0) {

/*  If ).  is only ornament, bypass.  If with others, temporarirly zero the bit. */

#line 17977 ""
			i__12 = log2_(&all_1.nodur[commvl_1.ivx + ip * 24 - 
				25]);
#line 17977 ""
			if (pow_ii(&c__2, &i__12) != all_1.nodur[commvl_1.ivx 
				+ ip * 24 - 25]) {
#line 17978 ""
			    if ((all_1.iornq[commvl_1.ivx + ip * 24 - 1] & 
				    516079) == 0) {

/*  ). is the only non-segno ornament */

#line 17982 ""
				isacc = FALSE_;
#line 17983 ""
			    } else {

/*  There are other ornaments in addition */

#line 17987 ""
				rpndot = TRUE_;
#line 17988 ""
				all_1.iornq[commvl_1.ivx + ip * 24 - 1] = 
					bit_clear(all_1.iornq[commvl_1.ivx + 
					ip * 24 - 1],13);
#line 17989 ""
			    }
#line 17990 ""
			}
#line 17991 ""
		    }
#line 17992 ""
		    if (isacc && ! comcwrf_1.cwrferm[commvl_1.ivx - 1]) {

/*  Check for centered whole-bar rest with fermata (bits 10 or 14). */

#line 17996 ""
			if ((all_1.iornq[commvl_1.ivx + ip * 24 - 1] & 17408) 
				> 0 && bit_test(all_1.irest[commvl_1.ivx + ip 
				* 24 - 25],0) && all_1.nodur[commvl_1.ivx + 
				ip * 24 - 25] == all_1.lenbar && ! (
				all_1.firstgulp && all_1.ibar == 1 && 
				all_1.lenb0 > 0)) {
#line 18000 ""
			    comcwrf_1.cwrferm[commvl_1.ivx - 1] = TRUE_;
#line 18001 ""
			    goto L30;
#line 18002 ""
			}
#line 18003 ""
			i__12 = ncmid_(&all_1.iv, &ip);
#line 18003 ""
			L__1 = bit_test(all_1.ipl[commvl_1.ivx + ip * 24 - 25]
				,10);
#line 18003 ""
			putorn_(&all_1.iornq[commvl_1.ivx + ip * 24 - 1], &
				all_1.nolev[commvl_1.ivx + ip * 24 - 25], &
				all_1.nolev[commvl_1.ivx + ip * 24 - 25], &
				all_1.nodur[commvl_1.ivx + ip * 24 - 25], 
				nornb, all_1.ulq, &all_1.ibmcnt[commvl_1.ivx 
				- 1], &commvl_1.ivx, &i__12, &all_1.islur[
				commvl_1.ivx + ip * 24 - 25], &commvl_1.nvmx[
				all_1.iv - 1], &all_1.nv, ihornb, &
				all_1.stemlen, notexq, &lnote, &ip, &islhgt, &
				all_1.beamon[commvl_1.ivx - 1], &L__1, (
				ftnlen)1, (ftnlen)79);
#line 18008 ""
			addstr_(notexq, &lnote, soutq, &lsout, (ftnlen)79, (
				ftnlen)80);
#line 18009 ""
		    }
#line 18010 ""
		    if (rpndot) {
#line 18011 ""
			all_1.iornq[commvl_1.ivx + ip * 24 - 1] = bit_set(
				all_1.iornq[commvl_1.ivx + ip * 24 - 1],13);
#line 18012 ""
			rpndot = FALSE_;
#line 18013 ""
		    }
#line 18014 ""
L30:

/*  Check for main note accidental */

#line 18018 ""
		    if ((all_1.nacc[commvl_1.ivx + ip * 24 - 25] & 3) > 0 && !
			     bit_test(all_1.nacc[commvl_1.ivx + ip * 24 - 25],
			    17)) {
#line 18020 ""
			ihshft = igetbits_(&all_1.nacc[commvl_1.ivx + ip * 24 
				- 25], &c__7, &c__10);
#line 18021 ""
			if (ihshft != 0) {
#line 18021 ""
			    ihshft += -107;
#line 18021 ""
			}
#line 18022 ""
			if (! bit_test(all_1.ipl[commvl_1.ivx + ip * 24 - 25],
				10) && bit_test(all_1.ipl[commvl_1.ivx + ip * 
				24 - 25],8)) {
#line 18022 ""
			    ihshft += -20;
#line 18022 ""
			}

/* Not a chord, and left-shifted main note, so left-shift accid */

#line 18027 ""
			i__12 = igetbits_(&all_1.nacc[commvl_1.ivx + ip * 24 
				- 25], &c__6, &c__4);
#line 18027 ""
			i__13 = ncmid_(&all_1.iv, &ip);
#line 18027 ""
			L__1 = bit_test(all_1.irest[commvl_1.ivx + ip * 24 - 
				25],31);
#line 18027 ""
			doacc_(&ihshft, &i__12, notexq, &lnote, &all_1.nacc[
				commvl_1.ivx + ip * 24 - 25], &all_1.nolev[
				commvl_1.ivx + ip * 24 - 25], &i__13, &L__1, (
				ftnlen)79);
#line 18030 ""
			addstr_(notexq, &lnote, soutq, &lsout, (ftnlen)79, (
				ftnlen)80);
#line 18031 ""
		    }

/*  Lower dot for lower-voice notes.  Conditions are: */
/*   1. Dotted time value */
/*   2. Lower voice of two */
/*   3. Note is on a line */
/*   4. Not a rest */
/* .  5. Flag (lowdot) is set to true */
/*   6. Not in an xtuplet */

#line 18041 ""
		    if (comarp_1.lowdot && commvl_1.nvmx[all_1.iv - 1] == 2 &&
			     commvl_1.ivx <= all_1.nv && all_1.nodur[
			    commvl_1.ivx + ip * 24 - 25] != 0) {
#line 18043 ""
			i__12 = log2_(&all_1.nodur[commvl_1.ivx + ip * 24 - 
				25]);
#line 18043 ""
			if (! bit_test(all_1.irest[commvl_1.ivx + ip * 24 - 
				25],0) && pow_ii(&c__2, &i__12) != 
				all_1.nodur[commvl_1.ivx + ip * 24 - 25] && (
				all_1.nolev[commvl_1.ivx + ip * 24 - 25] - 
				ncmid_(&commvl_1.ivx, &ip)) % 2 == 0) {
#line 18046 ""
			    if (bit_test(all_1.irest[commvl_1.ivx + ip * 24 - 
				    25],19)) {

/*  Note already in movdot list.  Drop by 2. */

#line 18050 ""
				comcc_1.updot[commvl_1.ivx + (comcc_1.ndotmv[
					commvl_1.ivx - 1] + 1) * 24 - 25] += 
					-2.f;
#line 18052 ""
			    } else {

/*  Not in list so just move it right now */

#line 18056 ""
				i__12 = igetbits_(&all_1.islur[commvl_1.ivx + 
					ip * 24 - 25], &c__1, &c__3);
#line 18056 ""
				dotmov_(&c_b1019, &c_b1020, soutq, &lsout, &
					i__12, (ftnlen)80);
#line 18058 ""
			    }
#line 18059 ""
			}
#line 18060 ""
		    }

/*  Check for dotted main notes with moved dots. Chord notes done elsewhere. */
/*  Added check rules out special chordal 2nds, but later must check */
/*  substituted chord note for dot shift that now applies to main note. */

#line 18066 ""
		    if (bit_test(all_1.irest[commvl_1.ivx + ip * 24 - 25],19))
			     {
#line 18067 ""
			++comcc_1.ndotmv[commvl_1.ivx - 1];
#line 18068 ""
			i__12 = igetbits_(&all_1.islur[commvl_1.ivx + ip * 24 
				- 25], &c__1, &c__3);
#line 18068 ""
			dotmov_(&comcc_1.updot[commvl_1.ivx + comcc_1.ndotmv[
				commvl_1.ivx - 1] * 24 - 25], &comcc_1.rtdot[
				commvl_1.ivx + comcc_1.ndotmv[commvl_1.ivx - 
				1] * 24 - 25], soutq, &lsout, &i__12, (ftnlen)
				80);
#line 18070 ""
		    }

/*  Stemlength changes */

#line 18074 ""
		    if (bit_test(all_1.mult[commvl_1.ivx + ip * 24 - 25],27)) 
			    {
#line 18075 ""
			dstemlen = igetbits_(&all_1.mult[commvl_1.ivx + ip * 
				24 - 25], &c__6, &c__10) * .5f - 4.f;
/* Writing concatenation */
#line 18076 ""
			i__4[0] = 1, a__2[0] = all_1.sq;
#line 18076 ""
			i__4[1] = 12, a__2[1] = "stdstemfalse";
#line 18076 ""
			s_cat(ch__18, a__2, i__4, &c__2, (ftnlen)13);
#line 18076 ""
			addstr_(ch__18, &c__13, soutq, &lsout, (ftnlen)13, (
				ftnlen)80);
#line 18077 ""
			stemshort = dstemlen * .667f + 4.66f;
/* Writing concatenation */
#line 18078 ""
			i__4[0] = 1, a__2[0] = all_1.sq;
#line 18078 ""
			i__4[1] = 11, a__2[1] = "stemlength{";
#line 18078 ""
			s_cat(ch__5, a__2, i__4, &c__2, (ftnlen)12);
#line 18078 ""
			addstr_(ch__5, &c__12, soutq, &lsout, (ftnlen)12, (
				ftnlen)80);
#line 18079 ""
			s_wsfi(&io___1120);
#line 18079 ""
			do_fio(&c__1, (char *)&stemshort, (ftnlen)sizeof(real)
				);
#line 18079 ""
			e_wsfi();
/* Writing concatenation */
#line 18080 ""
			i__4[0] = 4, a__2[0] = notexq;
#line 18080 ""
			i__4[1] = 1, a__2[1] = "}";
#line 18080 ""
			s_cat(ch__19, a__2, i__4, &c__2, (ftnlen)5);
#line 18080 ""
			addstr_(ch__19, &c__5, soutq, &lsout, (ftnlen)5, (
				ftnlen)80);
#line 18081 ""
		    } else if (ip > 1) {
#line 18082 ""
			if (bit_test(all_1.mult[commvl_1.ivx + (ip - 1) * 24 
				- 25],27)) {
/* Writing concatenation */
#line 18082 ""
			    i__4[0] = 1, a__2[0] = all_1.sq;
#line 18082 ""
			    i__4[1] = 16, a__2[1] = "stemlength{4.66}";
#line 18082 ""
			    s_cat(ch__7, a__2, i__4, &c__2, (ftnlen)17);
#line 18082 ""
			    addstr_(ch__7, &c__17, soutq, &lsout, (ftnlen)17, 
				    (ftnlen)80);
#line 18082 ""
			}

/*  Cancel shortening.  Looks like it gets automatically restored if new inst. or */
/*    new line, so no need to worry about affecting other lines */

#line 18088 ""
		    }

/*  Zero out slur-height marker for raising ornaments */

#line 18092 ""
		    islhgt = 0;

/*  Now start with spacing notes.  Is a beam start pending? */

#line 18096 ""
		    if (bspend && all_1.ibm2[commvl_1.ivx + all_1.ibmcnt[
			    commvl_1.ivx - 1] * 24 - 25] > all_1.ibm1[
			    commvl_1.ivx + all_1.ibmcnt[commvl_1.ivx - 1] * 
			    24 - 25]) {
#line 18098 ""
			if (strtmid_1.ixrest[commvl_1.ivx - 1] == 4) {

/*  Special path for single note at end of otherwise beamed xtup */

#line 18102 ""
			    strtmid_1.ixrest[commvl_1.ivx - 1] = 0;
#line 18103 ""
			} else {
#line 18104 ""
			    if (comkbdrests_1.kbdrests && bit_test(
				    all_1.irest[commvl_1.ivx + ip * 24 - 25],
				    0) && ! bit_test(all_1.islur[commvl_1.ivx 
				    + ip * 24 - 25],29) && commvl_1.nvmx[
				    all_1.iv - 1] == 2 && all_1.nolev[
				    commvl_1.ivx + ip * 24 - 25] <= 50) {
#line 18104 ""
				chkkbdrests_(&ip, &all_1.iv, &commvl_1.ivx, 
					all_1.nn, all_1.islur, all_1.irest, 
					all_1.nolev, commvl_1.ivmx, all_1.nib,
					 &all_1.nv, &all_1.ibar, &tnow, &
					comtol_1.tol, all_1.nodur, &c__2, 
					comkbdrests_1.levtopr, 
					comkbdrests_1.levbotr, all_1.mult, 
					all_1.ipl);
#line 18104 ""
			    }
#line 18110 ""
			    if (bit_test(all_1.islur[commvl_1.ivx + ip * 24 - 
				    25],29) && bit_test(all_1.irest[
				    commvl_1.ivx + ip * 24 - 25],24)) {
/* Writing concatenation */
#line 18112 ""
				chax_(ch__6, (ftnlen)1, &c__92);
#line 18112 ""
				i__4[0] = 1, a__2[0] = ch__6;
#line 18112 ""
				i__4[1] = 2, a__2[1] = "sk";
#line 18112 ""
				s_cat(notexq, a__2, i__4, &c__2, (ftnlen)79);
#line 18113 ""
				lnote = 3;
#line 18114 ""
			    } else {
#line 18115 ""
				beamn1_(notexq, &lnote, (ftnlen)79);
/*                  if (isbjmp .and. */
#line 18117 ""
				if (combjmp_1.isbjmp && combjmp_1.ivbj2 != 0 
					&& (all_1.mult[commvl_1.ivx + ip * 24 
					- 25] & 15) - 8 > combjmp_1.multbj1) {

/*  Need to increase multiplicity at the beam jump */

/*  ibmcnt was increased by 1 at the end of first seg of jump beam!? */
/*  Try adding e.g. \nbbu1 if needed to increase multiplicity. Add */
/*  character in reverse order to start of notexq. */

#line 18126 ""
				    if (combjmp_1.ivbj1 < 9) {
/* Writing concatenation */
#line 18127 ""
					*(unsigned char *)&ch__6[0] = 
						combjmp_1.ivbj1 + 48;
#line 18127 ""
					i__4[0] = 1, a__2[0] = ch__6;
#line 18127 ""
					i__4[1] = lnote, a__2[1] = notexq;
#line 18127 ""
					s_cat(notexq, a__2, i__4, &c__2, (
						ftnlen)79);
#line 18128 ""
					++lnote;
#line 18129 ""
				    } else {
/* Writing concatenation */
#line 18130 ""
					i__9[0] = 2, a__6[0] = "{1";
#line 18130 ""
					*(unsigned char *)&ch__6[0] = 
						combjmp_1.ivbj1 + 38;
#line 18130 ""
					i__9[1] = 1, a__6[1] = ch__6;
#line 18130 ""
					i__9[2] = 1, a__6[2] = "}";
#line 18130 ""
					i__9[3] = lnote, a__6[3] = notexq;
#line 18130 ""
					s_cat(notexq, a__6, i__9, &c__4, (
						ftnlen)79);
#line 18132 ""
					lnote += 4;
#line 18133 ""
				    }
/* Writing concatenation */
#line 18134 ""
				    i__6[0] = 2, a__4[0] = "bb";
#line 18134 ""
				    i__6[1] = 1, a__4[1] = all_1.ulq + (
					    combjmp_1.ivbj1 + (all_1.ibmcnt[
					    combjmp_1.ivbj1 - 1] - 1) * 24 - 
					    25);
#line 18134 ""
				    i__6[2] = lnote, a__4[2] = notexq;
#line 18134 ""
				    s_cat(notexq, a__4, i__6, &c__3, (ftnlen)
					    79);
#line 18136 ""
				    lnote += 3;
#line 18137 ""
				    if ((15 & all_1.mult[commvl_1.ivx + ip * 
					    24 - 25]) - 8 == 3) {
/* Writing concatenation */
#line 18138 ""
					i__4[0] = 1, a__2[0] = "b";
#line 18138 ""
					i__4[1] = lnote, a__2[1] = notexq;
#line 18138 ""
					s_cat(notexq, a__2, i__4, &c__2, (
						ftnlen)79);
#line 18139 ""
					++lnote;
#line 18140 ""
				    }
/* Writing concatenation */
#line 18141 ""
				    i__6[0] = 1, a__4[0] = all_1.sq;
#line 18141 ""
				    i__6[1] = 1, a__4[1] = "n";
#line 18141 ""
				    i__6[2] = lnote, a__4[2] = notexq;
#line 18141 ""
				    s_cat(notexq, a__4, i__6, &c__3, (ftnlen)
					    79);
#line 18142 ""
				    lnote += 2;
#line 18143 ""
				}
#line 18144 ""
			    }
#line 18145 ""
			}
#line 18146 ""
			bspend = FALSE_;

/*  Is a beam ending? */

#line 18150 ""
		    } else if (numbms[commvl_1.ivx] > 0 && all_1.ibmcnt[
			    commvl_1.ivx - 1] <= numbms[commvl_1.ivx] && (
			    all_1.ibm2[commvl_1.ivx + all_1.ibmcnt[
			    commvl_1.ivx - 1] * 24 - 25] == ip || bit_test(
			    all_1.nacc[commvl_1.ivx + ip * 24 - 25],20))) {
#line 18153 ""
			if (bspend) {

/*  Must be a single-note ending of a jump-beam */

#line 18157 ""
			    bspend = FALSE_;
#line 18158 ""
			}
#line 18159 ""
			beamend_(notexq, &lnote, (ftnlen)79);
#line 18160 ""
			if (combjmp_1.isbjmp && commvl_1.ivx == 
				combjmp_1.ivbj1) {

/*  Jump beam segment is ending, check if multiplicity DECREASES */

#line 18164 ""
			    if (comnsp_2.space[ib] > comnsp_2.space[ib - 1]) {

/*  Decrease multiplicity 3-1, 3-2, or 2-1. Spaces are 2,4, or 8. */

#line 18168 ""
				if (commvl_1.ivx < 10) {
#line 18169 ""
				    *(unsigned char *)&ch__6[0] = 
					    commvl_1.ivx + 48;
#line 18169 ""
				    s_copy(ivxq, ch__6, (ftnlen)4, (ftnlen)1);
#line 18170 ""
				    livx = 1;
#line 18171 ""
				} else {
/* Writing concatenation */
#line 18172 ""
				    i__6[0] = 2, a__4[0] = "{1";
#line 18172 ""
				    *(unsigned char *)&ch__6[0] = 
					    commvl_1.ivx - 10;
#line 18172 ""
				    i__6[1] = 1, a__4[1] = ch__6;
#line 18172 ""
				    i__6[2] = 1, a__4[2] = "}";
#line 18172 ""
				    s_cat(ivxq, a__4, i__6, &c__3, (ftnlen)4);
#line 18173 ""
				    livx = 4;
#line 18174 ""
				}
#line 18175 ""
				if (comnsp_2.space[ib] == 8.f && 
					comnsp_2.space[ib - 1] == 2.f) {
/* Writing concatenation */
#line 18176 ""
				    i__15[0] = 1, a__9[0] = all_1.sq;
#line 18176 ""
				    i__15[1] = 4, a__9[1] = "tbbb";
#line 18176 ""
				    i__15[2] = 1, a__9[2] = all_1.ulq + (
					    commvl_1.ivx + all_1.ibmcnt[
					    commvl_1.ivx - 1] * 24 - 25);
#line 18176 ""
				    i__15[3] = livx, a__9[3] = ivxq;
#line 18176 ""
				    i__15[4] = 1, a__9[4] = all_1.sq;
#line 18176 ""
				    i__15[5] = 3, a__9[5] = "tbb";
#line 18176 ""
				    i__15[6] = 1, a__9[6] = all_1.ulq + (
					    commvl_1.ivx + all_1.ibmcnt[
					    commvl_1.ivx - 1] * 24 - 25);
#line 18176 ""
				    i__15[7] = livx, a__9[7] = ivxq;
#line 18176 ""
				    i__15[8] = lnote, a__9[8] = notexq;
#line 18176 ""
				    s_cat(notexq, a__9, i__15, &c__9, (ftnlen)
					    79);
#line 18179 ""
				    lnote = lnote + 11 + (livx << 1);
#line 18180 ""
				} else if (comnsp_2.space[ib] == 8.f && 
					comnsp_2.space[ib - 1] == 4.f) {
/* Writing concatenation */
#line 18181 ""
				    i__5[0] = 1, a__3[0] = all_1.sq;
#line 18181 ""
				    i__5[1] = 3, a__3[1] = "tbb";
#line 18181 ""
				    i__5[2] = 1, a__3[2] = all_1.ulq + (
					    commvl_1.ivx + all_1.ibmcnt[
					    commvl_1.ivx - 1] * 24 - 25);
#line 18181 ""
				    i__5[3] = livx, a__3[3] = ivxq;
#line 18181 ""
				    i__5[4] = lnote, a__3[4] = notexq;
#line 18181 ""
				    s_cat(notexq, a__3, i__5, &c__5, (ftnlen)
					    79);
#line 18183 ""
				    lnote = lnote + 5 + livx;
#line 18184 ""
				} else if (comnsp_2.space[ib] == 4.f && 
					comnsp_2.space[ib - 1] == 2.f) {
/* Writing concatenation */
#line 18185 ""
				    i__5[0] = 1, a__3[0] = all_1.sq;
#line 18185 ""
				    i__5[1] = 4, a__3[1] = "tbbb";
#line 18185 ""
				    i__5[2] = 1, a__3[2] = all_1.ulq + (
					    commvl_1.ivx + all_1.ibmcnt[
					    commvl_1.ivx - 1] * 24 - 25);
#line 18185 ""
				    i__5[3] = livx, a__3[3] = ivxq;
#line 18185 ""
				    i__5[4] = lnote, a__3[4] = notexq;
#line 18185 ""
				    s_cat(notexq, a__3, i__5, &c__5, (ftnlen)
					    79);
#line 18187 ""
				    lnote = lnote + 6 + livx;
#line 18188 ""
				}
#line 18189 ""
			    }
#line 18190 ""
			}
#line 18191 ""
			if (! bit_test(all_1.nacc[commvl_1.ivx + ip * 24 - 25]
				,20)) {
#line 18192 ""
			    comxtup_1.vxtup[commvl_1.ivx - 1] = FALSE_;
#line 18193 ""
			    nornb[commvl_1.ivx - 1] = 0;
#line 18194 ""
			    ++all_1.ibmcnt[commvl_1.ivx - 1];
#line 18195 ""
			    all_1.beamon[commvl_1.ivx - 1] = FALSE_;
#line 18196 ""
			}

/*  Or if we're in the middle of a beam */

#line 18200 ""
		    } else if (numbms[commvl_1.ivx] > 0 && all_1.beamon[
			    commvl_1.ivx - 1]) {

/*  Added 130127 */

#line 18204 ""
			if (comkbdrests_1.kbdrests && bit_test(all_1.irest[
				commvl_1.ivx + ip * 24 - 25],0) && ! bit_test(
				all_1.islur[commvl_1.ivx + ip * 24 - 25],29) 
				&& commvl_1.nvmx[all_1.iv - 1] == 2 && 
				all_1.nolev[commvl_1.ivx + ip * 24 - 25] <= 
				50) {
#line 18204 ""
			    chkkbdrests_(&ip, &all_1.iv, &commvl_1.ivx, 
				    all_1.nn, all_1.islur, all_1.irest, 
				    all_1.nolev, commvl_1.ivmx, all_1.nib, &
				    all_1.nv, &all_1.ibar, &tnow, &
				    comtol_1.tol, all_1.nodur, &c__2, 
				    comkbdrests_1.levtopr, 
				    comkbdrests_1.levbotr, all_1.mult, 
				    all_1.ipl);
#line 18204 ""
			}
#line 18210 ""
			beamid_(notexq, &lnote, (ftnlen)79);

/*      Or whole-bar rest */

#line 18214 ""
		    } else if (bit_test(all_1.irest[commvl_1.ivx + ip * 24 - 
			    25],0) && all_1.nodur[commvl_1.ivx + ip * 24 - 25]
			     == all_1.lenbar && ! (all_1.firstgulp && 
			    all_1.ibar == 1 && all_1.lenb0 > 0) && ! bit_test(
			    all_1.irest[commvl_1.ivx + ip * 24 - 25],25) && ! 
			    bit_test(all_1.islur[commvl_1.ivx + ip * 24 - 25],
			    29)) {

/*  Rule out pickup bar, blank rests, non-centered.  Remember islur b19=> rp */

#line 18222 ""
			cwrest[commvl_1.ivx] = TRUE_;
#line 18223 ""
			iscwr = TRUE_;
#line 18224 ""
			notex_(cwrq + (commvl_1.ivx - 1) * 79, &lcwr[
				commvl_1.ivx - 1], (ftnlen)79);
#line 18225 ""
			tnow += all_1.lenbar;
#line 18226 ""
			goto L10;
#line 18227 ""
		    } else if (strtmid_1.ixrest[commvl_1.ivx - 1] == 0) {

/*  Before writing note or rest, check for keyboard rest height adjustment. */
/*  Conditions are 0. This is a non-blank rest */
/*                 1. kbdrests = .true. */
/*                 2. There are two voices on the staff */
/*                 3. No user-def height adjustments have been applied (nolev<50) */

#line 18235 ""
			if (comkbdrests_1.kbdrests && bit_test(all_1.irest[
				commvl_1.ivx + ip * 24 - 25],0) && ! bit_test(
				all_1.islur[commvl_1.ivx + ip * 24 - 25],29) 
				&& commvl_1.nvmx[all_1.iv - 1] == 2 && 
				all_1.nolev[commvl_1.ivx + ip * 24 - 25] <= 
				50) {
#line 18238 ""
			    chkkbdrests_(&ip, &all_1.iv, &commvl_1.ivx, 
				    all_1.nn, all_1.islur, all_1.irest, 
				    all_1.nolev, commvl_1.ivmx, all_1.nib, &
				    all_1.nv, &all_1.ibar, &tnow, &
				    comtol_1.tol, all_1.nodur, &c__1, 
				    comkbdrests_1.levtopr, 
				    comkbdrests_1.levbotr, all_1.mult, 
				    all_1.ipl);
#line 18241 ""
			}
#line 18242 ""
			if (bit_test(all_1.ipl[commvl_1.ivx + ip * 24 - 25],4)
				) {

/*  Deal with single stem tremolo */
/*  Get up-downness, borrowed from notex */

#line 18247 ""
			    i__12 = ncmid_(&all_1.iv, &ip);
#line 18247 ""
			    udqq_(ch__6, (ftnlen)1, &all_1.nolev[commvl_1.ivx 
				    + ip * 24 - 25], &i__12, &all_1.islur[
				    commvl_1.ivx + ip * 24 - 25], &
				    commvl_1.nvmx[all_1.iv - 1], &
				    commvl_1.ivx, &all_1.nv);
#line 18247 ""
			    if (*(unsigned char *)&ch__6[0] == 'u') {
#line 18249 ""
				*(unsigned char *)udq = 'u';
#line 18250 ""
			    } else {
#line 18251 ""
				*(unsigned char *)udq = 'l';
#line 18252 ""
			    }
#line 18253 ""
			    multtrem = igetbits_(&all_1.ipl[commvl_1.ivx + ip 
				    * 24 - 25], &c__2, &c__5) + 1;
#line 18254 ""
			    if (all_1.nodur[commvl_1.ivx + ip * 24 - 25] < 64)
				     {
/* Writing concatenation */
#line 18255 ""
				i__4[0] = 1, a__2[0] = all_1.sq;
#line 18255 ""
				i__4[1] = 2, a__2[1] = "tr";
#line 18255 ""
				s_cat(notexq, a__2, i__4, &c__2, (ftnlen)79);
#line 18256 ""
			    } else {
/* Writing concatenation */
#line 18257 ""
				i__4[0] = 1, a__2[0] = all_1.sq;
#line 18257 ""
				i__4[1] = 2, a__2[1] = "Tr";
#line 18257 ""
				s_cat(notexq, a__2, i__4, &c__2, (ftnlen)79);
#line 18258 ""
			    }
#line 18259 ""
			    lnote = 3;
#line 18260 ""
			    if (multtrem == 2) {
/* Writing concatenation */
#line 18261 ""
				i__4[0] = 3, a__2[0] = notexq;
#line 18261 ""
				i__4[1] = 1, a__2[1] = "r";
#line 18261 ""
				s_cat(notexq, a__2, i__4, &c__2, (ftnlen)79);
#line 18262 ""
				lnote = 4;
#line 18263 ""
			    } else if (multtrem == 3) {
/* Writing concatenation */
#line 18264 ""
				i__4[0] = 3, a__2[0] = notexq;
#line 18264 ""
				i__4[1] = 2, a__2[1] = "rr";
#line 18264 ""
				s_cat(notexq, a__2, i__4, &c__2, (ftnlen)79);
#line 18265 ""
				lnote = 5;
#line 18266 ""
			    }

/* Get a numerical pitch argument */

#line 18270 ""
			    lineno = all_1.nolev[commvl_1.ivx + ip * 24 - 25] 
				    - ncmid_(&all_1.iv, &ip) + 4;
#line 18271 ""
			    if (lineno < 0 || lineno > 9) {
#line 18272 ""
				s_wsfi(&io___1128);
#line 18272 ""
				do_fio(&c__1, "{", (ftnlen)1);
#line 18272 ""
				do_fio(&c__1, (char *)&lineno, (ftnlen)sizeof(
					integer));
#line 18272 ""
				do_fio(&c__1, "}", (ftnlen)1);
#line 18272 ""
				e_wsfi();
#line 18273 ""
				lnoten = 4;
#line 18274 ""
			    } else {
#line 18275 ""
				*(unsigned char *)&ch__6[0] = lineno + 48;
#line 18275 ""
				s_copy(noteq, ch__6, (ftnlen)8, (ftnlen)1);
#line 18276 ""
				lnoten = 1;
#line 18277 ""
			    }
/* Writing concatenation */
#line 18278 ""
			    i__9[0] = lnote, a__6[0] = notexq;
#line 18278 ""
			    i__9[1] = 1, a__6[1] = "m";
#line 18278 ""
			    i__9[2] = 1, a__6[2] = udq;
#line 18278 ""
			    i__9[3] = lnoten, a__6[3] = noteq;
#line 18278 ""
			    s_cat(notexq, a__6, i__9, &c__4, (ftnlen)79);
#line 18279 ""
			    lnote = lnote + 2 + lnoten;
#line 18280 ""
			    addstr_(notexq, &lnote, soutq, &lsout, (ftnlen)79,
				     (ftnlen)80);
#line 18281 ""
			}

/*  Get code for a separate note or rest */
/*  If nacc(ivx,ip)(30-31)=1 (dotted chordal 2nd including main note), */
/*    pitch will be shifted +/-1 inside notex. */

#line 18287 ""
			notex_(notexq, &lnote, (ftnlen)79);
#line 18288 ""
		    }

/*  Right offset?  This may cause trouble */

#line 18292 ""
		    if (bit_test(all_1.ipl[commvl_1.ivx + ip * 24 - 25],8)) {
/* Writing concatenation */
#line 18293 ""
			i__4[0] = 1, a__2[0] = all_1.sq;
#line 18293 ""
			i__4[1] = 5, a__2[1] = "loff{";
#line 18293 ""
			s_cat(ch__17, a__2, i__4, &c__2, (ftnlen)6);
#line 18293 ""
			addstr_(ch__17, &c__6, soutq, &lsout, (ftnlen)6, (
				ftnlen)80);
#line 18294 ""
		    } else if (bit_test(all_1.ipl[commvl_1.ivx + ip * 24 - 25]
			    ,9)) {
/* Writing concatenation */
#line 18295 ""
			i__4[0] = 1, a__2[0] = all_1.sq;
#line 18295 ""
			i__4[1] = 5, a__2[1] = "roff{";
#line 18295 ""
			s_cat(ch__17, a__2, i__4, &c__2, (ftnlen)6);
#line 18295 ""
			addstr_(ch__17, &c__6, soutq, &lsout, (ftnlen)6, (
				ftnlen)80);
#line 18296 ""
		    }
#line 18297 ""
		    if (strtmid_1.ixrest[commvl_1.ivx - 1] == 0 && lnote > 0) 
			    {
#line 18298 ""
			addstr_(notexq, &lnote, soutq, &lsout, (ftnlen)79, (
				ftnlen)80);
#line 18299 ""
		    }
#line 18300 ""
		    if (bit_test(all_1.ipl[commvl_1.ivx + ip * 24 - 25],8) || 
			    bit_test(all_1.ipl[commvl_1.ivx + ip * 24 - 25],9)
			    ) {
#line 18300 ""
			addstr_("}", &c__1, soutq, &lsout, (ftnlen)1, (ftnlen)
				80);
#line 18300 ""
		    }

/*  Terminate user-defined offsets.  Fix format */

#line 18305 ""
		    if (bit_test(all_1.irest[commvl_1.ivx + ip * 24 - 25],15) 
			    || bit_test(all_1.irest[commvl_1.ivx + ip * 24 - 
			    25],17)) {
#line 18305 ""
			putshft_(&commvl_1.ivx, &c_false, soutq, &lsout, (
				ftnlen)80);
#line 18305 ""
		    }

/*  Deal with After- and Way-after-graces.  First, if end of bar, compute space */
/*    needed since it wasn't done during general ask-checks. If extra space is */
/*    rq'd, convert GW to GA.  Therefore GW at end of bar never needs extra sp. */
/*    But will still need to add extra space as hardspace. */

#line 18313 ""
		    if (ip == all_1.nn[commvl_1.ivx - 1] && (bit_test(
			    all_1.ipl[commvl_1.ivx + ip * 24 - 25],31) || 
			    bit_test(all_1.ipl[commvl_1.ivx + ip * 24 - 25],
			    29))) {
#line 18315 ""
			i__12 = comgrace_1.ngrace;
#line 18315 ""
			for (ig = 1; ig <= i__12; ++ig) {
#line 18316 ""
			    if (comgrace_1.ipg[ig - 1] == ip && 
				    comgrace_1.ivg[ig - 1] == commvl_1.ivx) {
#line 18316 ""
				goto L78;
#line 18316 ""
			    }
#line 18317 ""
/* L77: */
#line 18317 ""
			}
#line 18318 ""
			s_wsle(&io___1129);
#line 18318 ""
			do_lio(&c__9, &c__1, "Problem finding grace index "\
				"at \"do 77\"", (ftnlen)38);
#line 18318 ""
			e_wsle();
#line 18319 ""
			stop1_();
#line 18320 ""
L78:

/*  Get elemskip to end of bar.  WON'T WORK IF XTUPS !! */

#line 18324 ""
			esk = 0.f;
#line 18325 ""
			i__12 = comnsp_2.nb;
#line 18325 ""
			for (iib = ib; iib <= i__12; ++iib) {
#line 18326 ""
			    if (iib == ib) {
#line 18327 ""
				itleft = i_nint(&all_1.to[comipl2_1.ipl2[
					commvl_1.ivx + ip * 24 - 25] - 1]);
#line 18328 ""
			    } else {
#line 18329 ""
				itleft = i_nint(&tstart[ib]);
#line 18330 ""
			    }
#line 18331 ""
			    if (iib < comnsp_2.nb) {
#line 18332 ""
				itright = i_nint(&tstart[iib + 1]);
#line 18333 ""
			    } else {
#line 18334 ""
				itright = all_1.lenbar;
#line 18335 ""
			    }
#line 18336 ""
			    esk += feon_(&comnsp_2.space[ib - 1]) * (itright 
				    - itleft) / comnsp_2.space[ib - 1];
#line 18338 ""
/* L40: */
#line 18338 ""
			}
#line 18339 ""
			ptsavail = comask_1.poenom * esk - comask_1.wheadpt;
#line 18340 ""
			if (comgrace_1.nng[ig - 1] == 1) {
#line 18341 ""
			    wgr = spfacs_1.grafac;
#line 18342 ""
			} else {
#line 18343 ""
			    wgr = comgrace_1.nng[ig - 1] * spfacs_1.emgfac;
#line 18344 ""
			    i__12 = comgrace_1.nng[ig - 1];
#line 18344 ""
			    for (ing = 1; ing <= i__12; ++ing) {
#line 18345 ""
				if (comgrace_1.naccg[comgrace_1.ngstrt[ig - 1]
					 - 1 + ing - 1] > 0) {
#line 18345 ""
				    wgr += spfacs_1.acgfac;
#line 18345 ""
				}
#line 18346 ""
/* L41: */
#line 18346 ""
			    }
#line 18347 ""
			}
#line 18348 ""
			ptgr[ig - 1] = wgr * comask_1.wheadpt;
#line 18349 ""
			ptsneed = (wgr + .5f) * comask_1.wheadpt;
#line 18350 ""
			ptsndg[commvl_1.ivx - 1] = 0.f;
#line 18351 ""
			if (ptsavail < ptsneed) {
#line 18352 ""
			    ptsndg[commvl_1.ivx - 1] = ptsneed;
#line 18353 ""
			    eskndg[commvl_1.ivx - 1] = esk;
#line 18354 ""
			    if (bit_test(all_1.ipl[commvl_1.ivx + ip * 24 - 
				    25],31)) {

/*  Convert GW to GA */

#line 18358 ""
				all_1.ipl[commvl_1.ivx + ip * 24 - 25] = 
					bit_set(bit_clear(all_1.ipl[
					commvl_1.ivx + ip * 24 - 25],31),29);
#line 18359 ""
			    }
#line 18360 ""
			}
#line 18361 ""
		    }

/*  Check for GA */

#line 18365 ""
		    if (bit_test(all_1.ipl[commvl_1.ivx + ip * 24 - 25],29)) {
#line 18365 ""
			i__12 = ncmid_(&all_1.iv, &ip);
#line 18365 ""
			dograce_(&commvl_1.ivx, &ip, ptgr, soutq, &lsout, &
				i__12, &all_1.nacc[commvl_1.ivx + ip * 24 - 
				25], &ig, &all_1.ipl[commvl_1.ivx + ip * 24 - 
				25], &c_false, &c_false, &c__0, &c__0, &c__0, 
				&c__0, &c__0, &c__0, &c_b1020, all_1.ulq, &
				cominsttrans_1.instno[all_1.iv - 1], (ftnlen)
				80, (ftnlen)1);
#line 18365 ""
		    }

/*  Update running time */

#line 18372 ""
		    tnow += comnsp_2.space[ib - 1];
#line 18373 ""
L10:
#line 18373 ""
		    ;
#line 18373 ""
		}

/*  Have finished last note in this voice and block */

#line 18377 ""
		r__1 = all_1.to[istop[ib] - 1] + comnsp_2.space[ib - 1];
#line 18377 ""
		itendb = i_nint(&r__1);
#line 18378 ""
		if (all_1.figbass && commvl_1.ivx == 1 || commvl_1.ivx == 
			comfig_1.ivxfig2) {
#line 18379 ""
		    ivf = 1;
#line 18380 ""
		    if (commvl_1.ivx > 1) {
#line 18380 ""
			ivf = 2;
#line 18380 ""
		    }
#line 18381 ""
L17:
#line 18381 ""
		    if (all_1.figchk[ivf - 1] && comfig_1.itfig[ivf + (ifig[
			    ivf - 1] << 1) - 3] < itendb) {

/*  There's at least one figure left. offnsk could be <0 */

#line 18385 ""
			offnsk = (tnow - comfig_1.itfig[ivf + (ifig[ivf - 1] 
				<< 1) - 3]) / comnsp_2.space[ib - 1];
#line 18386 ""
			putfig_(&ivf, &ifig[ivf - 1], &offnsk, &all_1.figchk[
				ivf - 1], soutq, &lsout, (ftnlen)80);
#line 18387 ""
			goto L17;
#line 18388 ""
		    }
#line 18389 ""
		}

/*  Check for flag, dot, or upstem on last note of bar. */

#line 18393 ""
		if (ib == comnsp_2.nb) {
#line 18394 ""
		    ip = all_1.ipo[comipl2_1.ipl2[commvl_1.ivx + all_1.nn[
			    commvl_1.ivx - 1] * 24 - 25] - 1];
#line 18395 ""
		    comnsp_2.flgndv[commvl_1.ivx - 1] = 0.f;
#line 18396 ""
		    if ((r__1 = all_1.tnote[comipl2_1.ipl2[commvl_1.ivx + ip *
			     24 - 25] - 1] - comnsp_2.space[ib - 1], dabs(
			    r__1)) < comtol_1.tol) {
#line 18397 ""
			if (comnsp_2.space[ib - 1] < 16.f - comtol_1.tol) {

/*  Note in last space, smaller than a quarter note. */

#line 18401 ""
			    i__10 = ncmid_(&all_1.iv, &ip);
#line 18401 ""
			    udqq_(ch__6, (ftnlen)1, &all_1.nolev[commvl_1.ivx 
				    + ip * 24 - 25], &i__10, &all_1.islur[
				    commvl_1.ivx + ip * 24 - 25], &
				    commvl_1.nvmx[all_1.iv - 1], &
				    commvl_1.ivx, &all_1.nv);
#line 18401 ""
			    if (! bit_test(all_1.irest[commvl_1.ivx + ip * 24 
				    - 25],0) && *(unsigned char *)&ch__6[0] ==
				     'u' || isdotted_(all_1.nodur, &
				    commvl_1.ivx, &ip)) {

/*  Upstem non-rest, or dotted */

/* Computing MAX */
#line 18408 ""
				i__10 = 1, i__12 = numbms[commvl_1.ivx];
#line 18408 ""
				if (numbms[commvl_1.ivx] > 0 && ip == 
					all_1.ibm2[commvl_1.ivx + max(i__10,
					i__12) * 24 - 25] && ! isdotted_(
					all_1.nodur, &commvl_1.ivx, &ip)) {

/*  In beam and not dotted, so use smaller space */

#line 18415 ""
				    comnsp_2.flgndv[commvl_1.ivx - 1] = 
					    spfacs_1.upstmfac;
#line 18416 ""
				} else {
#line 18417 ""
				    comnsp_2.flgndv[commvl_1.ivx - 1] = 
					    spfacs_1.flagfac;
#line 18418 ""
				}
#line 18419 ""
			    }
#line 18420 ""
			} else {

/*  Last space, nonflagged (no beam) only worry dot or up */

#line 18424 ""
			    if (isdotted_(all_1.nodur, &commvl_1.ivx, &ip)) {
#line 18425 ""
				comnsp_2.flgndv[commvl_1.ivx - 1] = 
					spfacs_1.flagfac;
#line 18426 ""
			    } else /* if(complicated condition) */ {
#line 18426 ""
				i__10 = ncmid_(&all_1.iv, &ip);
#line 18426 ""
				udqq_(ch__6, (ftnlen)1, &all_1.nolev[
					commvl_1.ivx + ip * 24 - 25], &i__10, 
					&all_1.islur[commvl_1.ivx + ip * 24 - 
					25], &commvl_1.nvmx[all_1.iv - 1], &
					commvl_1.ivx, &all_1.nv);
#line 18426 ""
				if (all_1.tnote[comipl2_1.ipl2[commvl_1.ivx + 
					ip * 24 - 25] - 1] < 64.f && *(
					unsigned char *)&ch__6[0] == 'u') {

/*  Upstem on last note , non-flagged */

#line 18432 ""
				    comnsp_2.flgndv[commvl_1.ivx - 1] = 
					    spfacs_1.upstmfac;
#line 18433 ""
				}
#line 18433 ""
			    }
#line 18434 ""
			}
#line 18435 ""
		    }

/*  Check for right-shifted chordal note */

#line 18439 ""
		    if (bit_test(all_1.irest[commvl_1.ivx + ip * 24 - 25],20))
			     {
#line 18439 ""
			comnsp_2.flgndv[commvl_1.ivx - 1] = spfacs_1.rtshfac;
#line 18439 ""
		    }
#line 18440 ""
		    comnsp_2.flgndb = comnsp_2.flgndb || comnsp_2.flgndv[
			    commvl_1.ivx - 1] > 0.f;
#line 18441 ""
		    if (commidi_1.ismidi) {

/*  For midi, set flags for accidentals on last note of bar.  Assume they affect */
/*    first note of next bar whether or not tied. */
/*  Note has already been done, so next entry into addmidi is 1st in new bar. */
/*  First do main note, then chord notes */

/*  Gyrations needed to account for multi-bar tied full-bar notes? */
/* c  Old old    lbacc(icm) = iand(nacc(ivx,ip),7) */
/*   New old    if (lbacc(icm).eq.0) lbacc(icm) = iand(nacc(ivx,ip),7) */

#line 18452 ""
			if ((all_1.nacc[commvl_1.ivx + ip * 24 - 25] & 7) > 0)
				 {

/*  Explicit accidental on last main note in bar */

#line 18456 ""
			    i__10 = comslm_1.naccbl[icm];
#line 18456 ""
			    for (kacc = 1; kacc <= i__10; ++kacc) {
#line 18457 ""
				if (comslm_1.laccbl[icm + kacc * 25 - 25] == 
					all_1.nolev[commvl_1.ivx + ip * 24 - 
					25]) {
#line 18457 ""
				    goto L56;
#line 18457 ""
				}
#line 18458 ""
/* L55: */
#line 18458 ""
			    }
#line 18459 ""
			    ++comslm_1.naccbl[icm];
#line 18460 ""
			    comslm_1.laccbl[icm + comslm_1.naccbl[icm] * 25 - 
				    25] = all_1.nolev[commvl_1.ivx + ip * 24 
				    - 25];
#line 18461 ""
			    i__10 = all_1.nacc[commvl_1.ivx + ip * 24 - 25] & 
				    7;
#line 18461 ""
			    comslm_1.jaccbl[icm + comslm_1.naccbl[icm] * 25 - 
				    25] = iashft_(&i__10);
#line 18462 ""
			}
#line 18463 ""
L56:
#line 18464 ""
			if (bit_test(all_1.ipl[commvl_1.ivx + ip * 24 - 25],
				10) && commidi_1.crdacc) {
#line 18465 ""
			    i__10 = comtrill_1.icrd2;
#line 18465 ""
			    for (icrd = comtrill_1.icrd1; icrd <= i__10; 
				    ++icrd) {
#line 18466 ""
				iacc = igetbits_(&comtrill_1.icrdat[icrd - 1],
					 &c__3, &c__20);
#line 18467 ""
				if (iacc > 0) {

/*  Explicit accidental on chord note at end of bar */

#line 18471 ""
				    nolevc = igetbits_(&comtrill_1.icrdat[
					    icrd - 1], &c__7, &c__12);
#line 18472 ""
				    i__12 = comslm_1.naccbl[icm];
#line 18472 ""
				    for (kacc = 1; kacc <= i__12; ++kacc) {
#line 18473 ""
					if (comslm_1.laccbl[icm + kacc * 25 - 
						25] == nolevc) {
#line 18473 ""
					    goto L59;
#line 18473 ""
					}
#line 18474 ""
/* L58: */
#line 18474 ""
				    }
#line 18475 ""
				    ++comslm_1.naccbl[icm];
#line 18476 ""
				    comslm_1.laccbl[icm + comslm_1.naccbl[icm]
					     * 25 - 25] = nolevc;
#line 18477 ""
				    comslm_1.jaccbl[icm + comslm_1.naccbl[icm]
					     * 25 - 25] = iashft_(&iacc);
#line 18478 ""
				}
#line 18479 ""
L59:
#line 18480 ""
/* L57: */
#line 18480 ""
				;
#line 18480 ""
			    }
#line 18481 ""
			}
/*              if (lbacc(icm).eq.0 .and. accb4(icm)) then */
#line 18483 ""
			i__10 = commidi_1.naccim[icm];
#line 18483 ""
			for (kacc = 1; kacc <= i__10; ++kacc) {

/*  If naccim(icm)>0, */
/*  possible implicit accidental from earlier in the bar.  Check for prior accid */
/*  in this bar at relevant note levels, main and chord notes.  Only act if no */
/*  explicit action from just above.  Assuming any accid on last note in bar, */
/*  either explicit or implicit, has same effect on 1st note of next bar. */

#line 18491 ""
			    if (all_1.nolev[commvl_1.ivx + ip * 24 - 25] == 
				    commidi_1.laccim[icm + kacc * 25 - 25]) {
#line 18491 ""
				goto L66;
#line 18491 ""
			    }
#line 18492 ""
			    if (bit_test(all_1.ipl[commvl_1.ivx + ip * 24 - 
				    25],10)) {
#line 18493 ""
				i__12 = comtrill_1.icrd2;
#line 18493 ""
				for (icrd = comtrill_1.icrd1; icrd <= i__12; 
					++icrd) {
#line 18494 ""
				    if ((lbit_shift(comtrill_1.icrdat[icrd - 
					    1], (ftnlen)-12) & 127) == 
					    commidi_1.laccim[icm + kacc * 25 
					    - 25]) {
#line 18494 ""
					goto L66;
#line 18494 ""
				    }
#line 18496 ""
/* L67: */
#line 18496 ""
				}
#line 18497 ""
			    }
#line 18498 ""
			    goto L65;
#line 18499 ""
L66:

/*  So far we know there is a main or chord note at level laccim(icm,kacc). So */
/*   it will get a bl-accid if it didn't just already get one. */

#line 18504 ""
			    i__12 = comslm_1.naccbl[icm];
#line 18504 ""
			    for (macc = 1; macc <= i__12; ++macc) {
#line 18505 ""
				if (comslm_1.laccbl[icm + macc * 25 - 25] == 
					commidi_1.laccim[icm + kacc * 25 - 25]
					) {
#line 18505 ""
				    goto L65;
#line 18505 ""
				}
#line 18506 ""
/* L68: */
#line 18506 ""
			    }
#line 18507 ""
			    ++comslm_1.naccbl[icm];
#line 18508 ""
			    comslm_1.laccbl[icm + comslm_1.naccbl[icm] * 25 - 
				    25] = commidi_1.laccim[icm + kacc * 25 - 
				    25];
#line 18509 ""
			    comslm_1.jaccbl[icm + comslm_1.naccbl[icm] * 25 - 
				    25] = commidi_1.jaccim[icm + kacc * 25 - 
				    25];
#line 18510 ""
L65:
#line 18510 ""
			    ;
#line 18510 ""
			}
#line 18511 ""
		    }
#line 18512 ""
		}
#line 18513 ""
/* L1199: */
#line 18513 ""
	    }
#line 18514 ""
/* L11: */
#line 18514 ""
	}

/*  Close out the notes group */

/* Writing concatenation */
#line 18518 ""
	i__4[0] = 1, a__2[0] = all_1.sq;
#line 18518 ""
	i__4[1] = 2, a__2[1] = "en";
#line 18518 ""
	s_cat(ch__14, a__2, i__4, &c__2, (ftnlen)3);
#line 18518 ""
	addstr_(ch__14, &c__3, soutq, &lsout, (ftnlen)3, (ftnlen)80);
#line 18519 ""
	if (comlast_1.islast && lsout > 0) {
#line 18519 ""
	    s_wsfe(&io___1142);
/* Writing concatenation */
#line 18519 ""
	    i__4[0] = lsout, a__2[0] = soutq;
#line 18519 ""
	    i__4[1] = 1, a__2[1] = "%";
#line 18519 ""
	    s_cat(ch__12, a__2, i__4, &c__2, (ftnlen)81);
#line 18519 ""
	    do_fio(&c__1, ch__12, lsout + 1);
#line 18519 ""
	    e_wsfe();
#line 18519 ""
	}
#line 18520 ""
/* L16: */
#line 18520 ""
    }

/*  Check for way-after graces at end of bar.  We could not link these to notes */
/*  as in midbar since there is no note following grace!  Also, set flag if */
/*  hardspace is needed. Also, save nvmx, ivmx for use in space checks on reloop. */

#line 18526 ""
    isgrace = FALSE_;
#line 18527 ""
    i__1 = all_1.nv;
#line 18527 ""
    for (all_1.iv = 1; all_1.iv <= i__1; ++all_1.iv) {
#line 18528 ""
	comnsp_2.nvmxsav[all_1.iv - 1] = commvl_1.nvmx[all_1.iv - 1];
#line 18529 ""
	i__2 = commvl_1.nvmx[all_1.iv - 1];
#line 18529 ""
	for (kv = 1; kv <= i__2; ++kv) {
#line 18530 ""
	    comnsp_2.ivmxsav[all_1.iv + kv * 24 - 25] = commvl_1.ivmx[
		    all_1.iv + kv * 24 - 25];
#line 18531 ""
	    commvl_1.ivx = commvl_1.ivmx[all_1.iv + kv * 24 - 25];
#line 18532 ""
	    comnsp_2.ptsgnd = 0.f;
#line 18533 ""
	    if ((bit_test(all_1.ipl[commvl_1.ivx + all_1.nn[commvl_1.ivx - 1] 
		    * 24 - 25],29) || bit_test(all_1.ipl[commvl_1.ivx + 
		    all_1.nn[commvl_1.ivx - 1] * 24 - 25],31)) && ptsndg[
		    commvl_1.ivx - 1] > 0.f) {
#line 18535 ""
		comnsp_2.flgndb = TRUE_;
#line 18536 ""
		if (ptsndg[commvl_1.ivx - 1] > comnsp_2.ptsgnd) {
#line 18537 ""
		    comnsp_2.ptsgnd = ptsndg[commvl_1.ivx - 1];
#line 18538 ""
		    comnsp_2.eskgnd = eskndg[commvl_1.ivx - 1];
#line 18539 ""
		}
#line 18540 ""
	    }
#line 18541 ""
	    if (bit_test(all_1.ipl[commvl_1.ivx + all_1.nn[commvl_1.ivx - 1] *
		     24 - 25],31)) {

/*  This voice has a way-after grace here at end of bar */

#line 18545 ""
		if (! isgrace) {

/*  This is the first one, so set up the string */

#line 18549 ""
		    isgrace = TRUE_;
#line 18550 ""
		    ivlast = 1;
/* Writing concatenation */
#line 18551 ""
		    i__4[0] = 1, a__2[0] = all_1.sq;
#line 18551 ""
		    i__4[1] = 6, a__2[1] = "znotes";
#line 18551 ""
		    s_cat(soutq, a__2, i__4, &c__2, (ftnlen)80);
#line 18552 ""
		    lsout = 7;
#line 18553 ""
		}
#line 18554 ""
		i__7 = all_1.iv - 1;
#line 18554 ""
		for (iiv = ivlast; iiv <= i__7; ++iiv) {
#line 18555 ""
		    addstr_(all_1.sepsymq + (iiv - 1), &c__1, soutq, &lsout, (
			    ftnlen)1, (ftnlen)80);
#line 18556 ""
/* L76: */
#line 18556 ""
		}
#line 18557 ""
		ivlast = all_1.iv;

/*  No need to put in 'nextvoice', even if 2 lines/staff */

#line 18561 ""
		i__7 = ncmid_(&all_1.iv, &all_1.nn[commvl_1.ivx - 1]);
#line 18561 ""
		dograce_(&commvl_1.ivx, &all_1.nn[commvl_1.ivx - 1], ptgr, 
			soutq, &lsout, &i__7, &all_1.nacc[commvl_1.ivx + 
			all_1.nn[commvl_1.ivx - 1] * 24 - 25], &ig, &
			all_1.ipl[commvl_1.ivx + all_1.nn[commvl_1.ivx - 1] * 
			24 - 25], &c_true, &c_false, &c__0, &c__0, &c__0, &
			c__0, &c__0, &c__0, &c_b1020, all_1.ulq, &
			cominsttrans_1.instno[all_1.iv - 1], (ftnlen)80, (
			ftnlen)1);
#line 18564 ""
	    }
#line 18565 ""
/* L7599: */
#line 18565 ""
	}
#line 18566 ""
/* L75: */
#line 18566 ""
    }
#line 18567 ""
    if (isgrace) {
/* Writing concatenation */
#line 18568 ""
	i__4[0] = 1, a__2[0] = all_1.sq;
#line 18568 ""
	i__4[1] = 3, a__2[1] = "en%";
#line 18568 ""
	s_cat(ch__20, a__2, i__4, &c__2, (ftnlen)4);
#line 18568 ""
	addstr_(ch__20, &c__4, soutq, &lsout, (ftnlen)4, (ftnlen)80);
#line 18569 ""
	if (comlast_1.islast && lsout > 0) {
#line 18569 ""
	    s_wsfe(&io___1145);
#line 18569 ""
	    do_fio(&c__1, soutq, lsout);
#line 18569 ""
	    e_wsfe();
#line 18569 ""
	}
#line 18570 ""
    }
#line 18571 ""
    lsout = 0;

/*  Write multibar rest.  Assuming nv = 1  and do not worry about cwbrest */
/*  This has to be the only use of atnextbar */

#line 18576 ""
    if (all_1.ibar == comgrace_1.ibarmbr && comlast_1.islast) {
#line 18577 ""
	if (comignorenats_1.newmbrhgt) {
/* Writing concatenation */
#line 18578 ""
	    i__9[0] = 1, a__6[0] = all_1.sq;
#line 18578 ""
	    i__9[1] = 3, a__6[1] = "def";
#line 18578 ""
	    i__9[2] = 1, a__6[2] = all_1.sq;
#line 18578 ""
	    i__9[3] = 7, a__6[3] = "mbrhgt{";
#line 18578 ""
	    s_cat(soutq, a__6, i__9, &c__4, (ftnlen)80);
#line 18579 ""
	    if (comignorenats_1.mbrhgt <= -10) {
#line 18580 ""
		s_wsfi(&io___1146);
#line 18580 ""
		do_fio(&c__1, (char *)&comignorenats_1.mbrhgt, (ftnlen)sizeof(
			integer));
#line 18580 ""
		e_wsfi();
#line 18581 ""
		lsout = 15;
#line 18582 ""
	    } else if (comignorenats_1.mbrhgt >= 10 || comignorenats_1.mbrhgt 
		    <= -1) {
#line 18583 ""
		s_wsfi(&io___1147);
#line 18583 ""
		do_fio(&c__1, (char *)&comignorenats_1.mbrhgt, (ftnlen)sizeof(
			integer));
#line 18583 ""
		e_wsfi();
#line 18584 ""
		lsout = 14;
#line 18585 ""
	    } else {
/* Writing concatenation */
#line 18586 ""
		i__4[0] = 12, a__2[0] = soutq;
#line 18586 ""
		*(unsigned char *)&ch__6[0] = comignorenats_1.mbrhgt + 48;
#line 18586 ""
		i__4[1] = 1, a__2[1] = ch__6;
#line 18586 ""
		s_cat(soutq, a__2, i__4, &c__2, (ftnlen)80);
#line 18587 ""
		lsout = 13;
#line 18588 ""
	    }
/* Writing concatenation */
#line 18589 ""
	    i__4[0] = lsout, a__2[0] = soutq;
#line 18589 ""
	    i__4[1] = 2, a__2[1] = "}%";
#line 18589 ""
	    s_cat(soutq, a__2, i__4, &c__2, (ftnlen)80);
#line 18590 ""
	    s_wsfe(&io___1148);
#line 18590 ""
	    do_fio(&c__1, soutq, lsout + 2);
#line 18590 ""
	    e_wsfe();
#line 18591 ""
	    comignorenats_1.newmbrhgt = FALSE_;
#line 18592 ""
	}
/* Writing concatenation */
#line 18593 ""
	i__3[0] = 1, a__1[0] = all_1.sq;
#line 18593 ""
	i__3[1] = 3, a__1[1] = "def";
#line 18593 ""
	i__3[2] = 1, a__1[2] = all_1.sq;
#line 18593 ""
	i__3[3] = 10, a__1[3] = "atnextbar{";
#line 18593 ""
	i__3[4] = 1, a__1[4] = all_1.sq;
#line 18593 ""
	i__3[5] = 6, a__1[5] = "znotes";
#line 18593 ""
	s_cat(soutq, a__1, i__3, &c__6, (ftnlen)80);
#line 18594 ""
	lsout = 22;
/* Writing concatenation */
#line 18595 ""
	i__4[0] = 1, a__2[0] = all_1.sq;
#line 18595 ""
	i__4[1] = 6, a__2[1] = "mbrest";
#line 18595 ""
	s_cat(notexq, a__2, i__4, &c__2, (ftnlen)79);
#line 18596 ""
	lnote = 7;
#line 18597 ""
	istring_(&comgrace_1.mbrest, noteq, &len, (ftnlen)8);
/* Writing concatenation */
#line 18598 ""
	i__4[0] = lnote, a__2[0] = notexq;
#line 18598 ""
	i__4[1] = len, a__2[1] = noteq;
#line 18598 ""
	s_cat(notexq, a__2, i__4, &c__2, (ftnlen)79);
#line 18599 ""
	lnote += len;
#line 18600 ""
	mtrspc = i_nint(&comgrace_1.xb4mbr);
#line 18601 ""
	comgrace_1.xb4mbr = 0.f;
#line 18602 ""
	istring_(&mtrspc, noteq, &len, (ftnlen)8);
/* Writing concatenation */
#line 18603 ""
	i__6[0] = lnote, a__4[0] = notexq;
#line 18603 ""
	i__6[1] = len, a__4[1] = noteq;
#line 18603 ""
	i__6[2] = 1, a__4[2] = "0";
#line 18603 ""
	s_cat(notexq, a__4, i__6, &c__3, (ftnlen)79);
#line 18604 ""
	lnote = lnote + len + 1;
#line 18605 ""
	i__1 = all_1.nv;
#line 18605 ""
	for (all_1.iv = 1; all_1.iv <= i__1; ++all_1.iv) {
#line 18606 ""
	    addstr_(notexq, &lnote, soutq, &lsout, (ftnlen)79, (ftnlen)80);
#line 18607 ""
	    if (all_1.iv < all_1.nv) {
#line 18607 ""
		addstr_(all_1.sepsymq + (all_1.iv - 1), &c__1, soutq, &lsout, 
			(ftnlen)1, (ftnlen)80);
#line 18607 ""
	    }
#line 18608 ""
/* L62: */
#line 18608 ""
	}
/* Writing concatenation */
#line 18609 ""
	i__4[0] = 1, a__2[0] = all_1.sq;
#line 18609 ""
	i__4[1] = 4, a__2[1] = "en}%";
#line 18609 ""
	s_cat(ch__19, a__2, i__4, &c__2, (ftnlen)5);
#line 18609 ""
	addstr_(ch__19, &c__5, soutq, &lsout, (ftnlen)5, (ftnlen)80);
#line 18610 ""
	s_wsfe(&io___1151);
#line 18610 ""
	do_fio(&c__1, soutq, lsout);
#line 18610 ""
	e_wsfe();
#line 18611 ""
	lsout = 0;
#line 18612 ""
	if (comshort_1.ishort > 0) {
#line 18613 ""
	    comshort_1.mbrsum += comgrace_1.mbrest;
#line 18614 ""
	    ++comshort_1.nmbr;
#line 18615 ""
	}
#line 18616 ""
	if (comgrace_1.mbrest > 1) {
#line 18617 ""
	    r__1 = comgrace_1.mbrest - 1 + .01f;
#line 18617 ""
	    ndig = (integer) r_lg10(&r__1) + 1;
#line 18618 ""
	    ci__1.cierr = 0;
#line 18618 ""
	    ci__1.ciunit = 11;
/* Writing concatenation */
#line 18618 ""
	    i__6[0] = 6, a__4[0] = "(a14,i";
#line 18618 ""
	    i__1 = ndig + 48;
#line 18618 ""
	    chax_(ch__6, (ftnlen)1, &i__1);
#line 18618 ""
	    i__6[1] = 1, a__4[1] = ch__6;
#line 18618 ""
	    i__6[2] = 4, a__4[2] = ",a1)";
#line 18618 ""
	    ci__1.cifmt = (s_cat(ch__9, a__4, i__6, &c__3, (ftnlen)11), ch__9)
		    ;
#line 18618 ""
	    s_wsfe(&ci__1);
/* Writing concatenation */
#line 18618 ""
	    i__9[0] = 1, a__6[0] = all_1.sq;
#line 18618 ""
	    i__9[1] = 7, a__6[1] = "advance";
#line 18618 ""
	    i__9[2] = 1, a__6[2] = all_1.sq;
#line 18618 ""
	    i__9[3] = 5, a__6[3] = "barno";
#line 18618 ""
	    s_cat(ch__4, a__6, i__9, &c__4, (ftnlen)14);
#line 18618 ""
	    do_fio(&c__1, ch__4, (ftnlen)14);
#line 18618 ""
	    i__2 = comgrace_1.mbrest - 1;
#line 18618 ""
	    do_fio(&c__1, (char *)&i__2, (ftnlen)sizeof(integer));
#line 18618 ""
	    do_fio(&c__1, "%", (ftnlen)1);
#line 18618 ""
	    e_wsfe();
#line 18620 ""
	}
#line 18621 ""
    } else if (iscwr) {

/*  Centered whole-bar rests. Set flag to pass to pmxb at start of NEXT bar */
/*    to check for new clef and add space by redefining \CenterBar */

#line 18626 ""
	comclefrests_1.centrests = TRUE_;
/* Writing concatenation */
#line 18627 ""
	i__9[0] = 1, a__6[0] = all_1.sq;
#line 18627 ""
	i__9[1] = 3, a__6[1] = "def";
#line 18627 ""
	i__9[2] = 1, a__6[2] = all_1.sq;
#line 18627 ""
	i__9[3] = 8, a__6[3] = "value{0}";
#line 18627 ""
	s_cat(ch__18, a__6, i__9, &c__4, (ftnlen)13);
#line 18627 ""
	addstr_(ch__18, &c__13, soutq, &lsout, (ftnlen)13, (ftnlen)80);
/* Writing concatenation */
#line 18628 ""
	i__3[0] = 1, a__1[0] = all_1.sq;
#line 18628 ""
	i__3[1] = 3, a__1[1] = "def";
#line 18628 ""
	i__3[2] = 1, a__1[2] = all_1.sq;
#line 18628 ""
	i__3[3] = 10, a__1[3] = "atnextbar{";
#line 18628 ""
	i__3[4] = 1, a__1[4] = all_1.sq;
#line 18628 ""
	i__3[5] = 6, a__1[5] = "znotes";
#line 18628 ""
	s_cat(ch__21, a__1, i__3, &c__6, (ftnlen)22);
#line 18628 ""
	addstr_(ch__21, &c__22, soutq, &lsout, (ftnlen)22, (ftnlen)80);
#line 18630 ""
	i__1 = all_1.nv;
#line 18630 ""
	for (all_1.iv = 1; all_1.iv <= i__1; ++all_1.iv) {
/* added */
#line 18632 ""
	    lnote = 0;

#line 18634 ""
	    i__2 = commvl_1.nvmx[all_1.iv - 1];
#line 18634 ""
	    for (kv = 1; kv <= i__2; ++kv) {
#line 18635 ""
		commvl_1.ivx = commvl_1.ivmx[all_1.iv + kv * 24 - 25];
#line 18636 ""
		if (cwrest[commvl_1.ivx]) {
/* Writing concatenation */
#line 18637 ""
		    i__4[0] = 1, a__2[0] = all_1.sq;
#line 18637 ""
		    i__4[1] = 10, a__2[1] = "CenterBar{";
#line 18637 ""
		    s_cat(ch__9, a__2, i__4, &c__2, (ftnlen)11);
#line 18637 ""
		    addstr_(ch__9, &c__11, soutq, &lsout, (ftnlen)11, (ftnlen)
			    80);
#line 18638 ""
		    if (! comcwrf_1.cwrferm[commvl_1.ivx - 1]) {
#line 18639 ""
			if (lcwr[commvl_1.ivx - 1] >= 11 && *(unsigned char *)
				&cwrq[(commvl_1.ivx - 1) * 79 + 10] != 'p') {

/*  Kluge to use new definitions for centered, stacked rests */

#line 18643 ""
			    if (s_cmp(cwrq + ((commvl_1.ivx - 1) * 79 + 1), 
				    "liftpause", (ftnlen)9, (ftnlen)9) == 0 ||
				     s_cmp(cwrq + ((commvl_1.ivx - 1) * 79 + 
				    1), "liftPAuse", (ftnlen)9, (ftnlen)9) == 
				    0) {
#line 18643 ""
				*(unsigned char *)&cwrq[(commvl_1.ivx - 1) * 
					79 + 9] = 'c';
#line 18643 ""
			    }
#line 18646 ""
			}
#line 18647 ""
			addstr_(cwrq + (commvl_1.ivx - 1) * 79, &lcwr[
				commvl_1.ivx - 1], soutq, &lsout, lcwr[
				commvl_1.ivx - 1], (ftnlen)80);
/* Writing concatenation */
#line 18649 ""
			i__6[0] = 6, a__4[0] = "}{-2}{";
#line 18649 ""
			i__6[1] = 1, a__4[1] = all_1.sq;
#line 18649 ""
			i__6[2] = 6, a__4[2] = "value}";
#line 18649 ""
			s_cat(ch__18, a__4, i__6, &c__3, (ftnlen)13);
#line 18649 ""
			addstr_(ch__18, &c__13, soutq, &lsout, (ftnlen)13, (
				ftnlen)80);
#line 18650 ""
		    } else {

/*  Fermata on centered rest.  Will need to fix up level. */
/*  12/6/07 shift it left so it's centered over rest */

/* Writing concatenation */
#line 18655 ""
			i__15[0] = lnote, a__9[0] = notexq;
#line 18655 ""
			i__15[1] = 1, a__9[1] = all_1.sq;
#line 18655 ""
			i__15[2] = 13, a__9[2] = "loffset{.33}{";
#line 18655 ""
			i__15[3] = 1, a__9[3] = all_1.sq;
#line 18655 ""
			i__15[4] = 11, a__9[4] = "fermataup7}";
#line 18655 ""
			i__15[5] = lcwr[commvl_1.ivx - 1], a__9[5] = cwrq + (
				commvl_1.ivx - 1) * 79;
#line 18655 ""
			i__15[6] = 6, a__9[6] = "}{-2}{";
#line 18655 ""
			i__15[7] = 1, a__9[7] = all_1.sq;
#line 18655 ""
			i__15[8] = 6, a__9[8] = "value}";
#line 18655 ""
			s_cat(notexq, a__9, i__15, &c__9, (ftnlen)79);
#line 18658 ""
			lnote = lnote + 26 + lcwr[commvl_1.ivx - 1] + 13;
#line 18659 ""
			addstr_(notexq, &lnote, soutq, &lsout, (ftnlen)79, (
				ftnlen)80);
#line 18660 ""
			comcwrf_1.cwrferm[commvl_1.ivx - 1] = FALSE_;
#line 18661 ""
		    }
#line 18662 ""
		}
#line 18663 ""
/* L61: */
#line 18663 ""
	    }
#line 18664 ""
	    if (all_1.iv != all_1.nv) {
#line 18664 ""
		addstr_(all_1.sepsymq + (all_1.iv - 1), &c__1, soutq, &lsout, 
			(ftnlen)1, (ftnlen)80);
#line 18664 ""
	    }
#line 18665 ""
/* L60: */
#line 18665 ""
	}
#line 18666 ""
	if (comlast_1.islast) {
/* Writing concatenation */
#line 18667 ""
	    i__4[0] = 1, a__2[0] = all_1.sq;
#line 18667 ""
	    i__4[1] = 4, a__2[1] = "en}%";
#line 18667 ""
	    s_cat(ch__19, a__2, i__4, &c__2, (ftnlen)5);
#line 18667 ""
	    addstr_(ch__19, &c__5, soutq, &lsout, (ftnlen)5, (ftnlen)80);
#line 18668 ""
	    if (lsout > 0) {
#line 18668 ""
		s_wsfe(&io___1153);
#line 18668 ""
		do_fio(&c__1, soutq, lsout);
#line 18668 ""
		e_wsfe();
#line 18668 ""
	    }
#line 18669 ""
	}
#line 18670 ""
    }

/*  End of block for centered whole-bar rests and multi-bar rests */

/*  If at end of block, save durations of last notes in bar, for possible use */
/*  if clef changes at start of next bar */

#line 18677 ""
    if (all_1.ibar == all_1.nbars) {
#line 18678 ""
	i__1 = all_1.nv;
#line 18678 ""
	for (all_1.iv = 1; all_1.iv <= i__1; ++all_1.iv) {
#line 18679 ""
	    i__2 = commvl_1.nvmx[all_1.iv - 1];
#line 18679 ""
	    for (kv = 1; kv <= i__2; ++kv) {
#line 18680 ""
		commvl_1.ivx = commvl_1.ivmx[all_1.iv + kv * 24 - 25];
#line 18681 ""
		comnsp_2.prevtn[commvl_1.ivx - 1] = all_1.tnote[
			comipl2_1.ipl2[commvl_1.ivx + all_1.nn[commvl_1.ivx - 
			1] * 24 - 25] - 1];
#line 18682 ""
/* L6399: */
#line 18682 ""
	    }
#line 18683 ""
/* L63: */
#line 18683 ""
	}
#line 18684 ""
    }

/*  Update time for midi.  This is only used for the event track */

#line 18688 ""
    if (commidi_1.ismidi) {
#line 18689 ""
	comevent_1.miditime += all_1.lenbar * 15;

/*  If pickup, write the real time signature to the event track.  Cannot use */
/*    mtrnuml since it was reset to 0, have to recompute it */

#line 18694 ""
	if (all_1.lenb0 == all_1.lenbar) {
#line 18694 ""
	    i__1 = all_1.mtrdenl * all_1.lenb1 / 64;
#line 18694 ""
	    midievent_("m", &i__1, &all_1.mtrdenl, (ftnlen)1);
#line 18694 ""
	}
#line 18696 ""
    }
#line 18697 ""
    return 0;
} /* make2bar_ */

/* Subroutine */ int makeabar_(void)
{
    /* System generated locals */
    integer i__1, i__2;
    real r__1, r__2, r__3;

    /* Builtin functions */
    integer i_nint(real *);

    /* Local variables */
    extern /* Subroutine */ int catspace_(real *, real *, integer *);
    static real elsperns;
    extern doublereal getsquez_(integer *, integer *, real *, real *, real *);
    static integer ib, in, kv, cnn[24];
    static real xit[24];
    static integer ilnc;
    static real tmin;
    static integer nnsk, ntot;
    extern doublereal f1eon_(real *);
    extern /* Subroutine */ int stop1_(void);
    static real space[80];
    extern doublereal fnote_(integer *, integer *, integer *, integer *);
    static real tminn, tnote[600];
    static integer istop[80];
    static real squez[80];
    static integer istart[80];
    extern /* Subroutine */ int printl_(char *, ftnlen);
    static integer ivnext;
    static real tstart[80], xsquez;


/*  On input, have pseudo-durations in nodur(ivx,ip).  Not real durations for */
/*    xtups, since only last note of xtup gets non-zero nodur, which */
/*    corresponds to single note of full length of xtup. */
/*  In this subroutine we make an ordered list of all notes in all voices. */
/*    ilnc      = list note counter */
/*    ivxo(ilnc), ipo(ilnc) = voice# and position in voice of ilnc-th note. */
/*    to(ilnc)  = real start time of note in PMX-units (64=whole note) */
/*    tno(ilnc) = time to next event in the bar. */
/*    tnote(ilnc) = actual duration of note */
/*  Then run thru list, grouping consecutive notes into \notes groups ib. */
/*    space(ib) = real time unit for the \notes group */
/*    squez(ib) = factor on space to get effective space.  This will be 1 if */
/*                there is a note exactly spanning each interval of space, and */
/*                <1 if not. */
/*  Details:  let eon = elemskips per noteskip (like length).  Basic formula is */
/*    eon = sqrt(space/2.) */
/*  If tgovern >= space, then */
/*    eon = sqrt(tgovern/2)*(space/tgovern) = space/sqrt(2*tgovern). */
/*  Time needed to give this eon using basic formula is */
/*    teq = space**2/tgovern */
/*  Factor on space to get teq is */
/*    squez(ib) = space/tgovern */
/*  The eon for each ib can then be computed based on time of space*squez. */
/*  Iff squez = 1, there is a note spanning every increment in the \notes group. */

/*    tnminb = minimum time span in the bar for increments spanned by notes, */
/*             i.e., with squez=1.  Use after parsing into line to decide if */
/*             spacing needs to be "flattened" among notes groups. */

#line 18744 ""
    linecom_1.elskb = 0.f;
#line 18745 ""
    linecom_1.tnminb[c1omnotes_1.ibarcnt - 1] = 1e3f;
#line 18746 ""
    i__1 = a1ll_2.nv;
#line 18746 ""
    for (a1ll_2.iv = 1; a1ll_2.iv <= i__1; ++a1ll_2.iv) {
#line 18747 ""
	i__2 = c1ommvl_1.nvmx[a1ll_2.iv - 1];
#line 18747 ""
	for (kv = 1; kv <= i__2; ++kv) {
#line 18748 ""
	    c1ommvl_1.ivx = c1ommvl_1.ivmx[a1ll_2.iv + kv * 24 - 25];
#line 18749 ""
	    if (a1ll_2.ibar > 1) {
#line 18750 ""
		a1ll_2.nn[c1ommvl_1.ivx - 1] = a1ll_2.nib[c1ommvl_1.ivx + 
			a1ll_2.ibar * 24 - 25] - a1ll_2.nib[c1ommvl_1.ivx + (
			a1ll_2.ibar - 1) * 24 - 25];
#line 18751 ""
	    } else {
#line 18752 ""
		a1ll_2.nn[c1ommvl_1.ivx - 1] = a1ll_2.nib[c1ommvl_1.ivx + 
			a1ll_2.ibar * 24 - 25];
#line 18753 ""
	    }
#line 18754 ""
/* L1999: */
#line 18754 ""
	}
#line 18755 ""
/* L1: */
#line 18755 ""
    }

/* initialize list note counter, time(iv), curr. note(iv) */

#line 18759 ""
    ilnc = 1;
#line 18760 ""
    i__1 = a1ll_2.nv;
#line 18760 ""
    for (a1ll_2.iv = 1; a1ll_2.iv <= i__1; ++a1ll_2.iv) {
#line 18761 ""
	i__2 = c1ommvl_1.nvmx[a1ll_2.iv - 1];
#line 18761 ""
	for (kv = 1; kv <= i__2; ++kv) {
#line 18762 ""
	    c1ommvl_1.ivx = c1ommvl_1.ivmx[a1ll_2.iv + kv * 24 - 25];
#line 18763 ""
	    cnn[c1ommvl_1.ivx - 1] = 1;
#line 18764 ""
	    a1ll_2.ivxo[ilnc - 1] = c1ommvl_1.ivx;
#line 18765 ""
	    a1ll_2.ipo[ilnc - 1] = 1;
#line 18766 ""
	    a1ll_2.to[ilnc - 1] = 0.f;
#line 18767 ""
	    tnote[ilnc - 1] = fnote_(a1ll_2.nodur, &c1ommvl_1.ivx, &c__1, 
		    c1ommvl_1.nacc);
#line 18768 ""
	    xit[c1ommvl_1.ivx - 1] = tnote[ilnc - 1];
#line 18769 ""
	    if ((r__1 = xit[c1ommvl_1.ivx - 1] - a1ll_2.lenbar, dabs(r__1)) < 
		    comtol_1.tol) {
#line 18769 ""
		xit[c1ommvl_1.ivx - 1] = 1e3f;
#line 18769 ""
	    }
#line 18770 ""
	    ++ilnc;
#line 18771 ""
/* L4999: */
#line 18771 ""
	}
#line 18772 ""
/* L4: */
#line 18772 ""
    }

/*  Build the list */

#line 18776 ""
L5:

/*  Determine which voice comes next from end of notes done so far. */
/*  tmin is the earliest ending time of notes done so far */

#line 18781 ""
    tmin = 1e3f;
#line 18782 ""
    i__1 = a1ll_2.nv;
#line 18782 ""
    for (a1ll_2.iv = 1; a1ll_2.iv <= i__1; ++a1ll_2.iv) {
#line 18783 ""
	i__2 = c1ommvl_1.nvmx[a1ll_2.iv - 1];
#line 18783 ""
	for (kv = 1; kv <= i__2; ++kv) {
#line 18784 ""
	    c1ommvl_1.ivx = c1ommvl_1.ivmx[a1ll_2.iv + kv * 24 - 25];
/* Computing MIN */
#line 18785 ""
	    r__1 = tmin, r__2 = xit[c1ommvl_1.ivx - 1];
#line 18785 ""
	    tminn = dmin(r__1,r__2);
#line 18786 ""
	    if (tminn < tmin) {
#line 18787 ""
		tmin = tminn;
#line 18788 ""
		ivnext = c1ommvl_1.ivx;
#line 18789 ""
	    }
#line 18790 ""
/* L6999: */
#line 18790 ""
	}
#line 18791 ""
/* L6: */
#line 18791 ""
    }
#line 18792 ""
    if (tmin > 999.f) {
#line 18792 ""
	goto L7;
#line 18792 ""
    }
#line 18793 ""
    a1ll_2.ivxo[ilnc - 1] = ivnext;
#line 18794 ""
    ++cnn[ivnext - 1];
#line 18795 ""
    a1ll_2.ipo[ilnc - 1] = cnn[ivnext - 1];
#line 18796 ""
    a1ll_2.to[ilnc - 1] = tmin;

/*  Check if this voice is done */

#line 18800 ""
    tnote[ilnc - 1] = fnote_(a1ll_2.nodur, &ivnext, &cnn[ivnext - 1], 
	    c1ommvl_1.nacc);
#line 18801 ""
    if (cnn[ivnext - 1] == a1ll_2.nn[ivnext - 1]) {
#line 18802 ""
	xit[ivnext - 1] = 1e3f;
#line 18803 ""
    } else {
#line 18804 ""
	xit[ivnext - 1] += tnote[ilnc - 1];
#line 18805 ""
    }
#line 18806 ""
    ++ilnc;
#line 18807 ""
    goto L5;
#line 18808 ""
L7:
#line 18809 ""
    ntot = ilnc - 1;
#line 18810 ""
    if (ntot > 600) {
#line 18811 ""
	printl_(" ", (ftnlen)1);
#line 18812 ""
	printl_("Cannot have more than 600 notes per bar, stopping", (ftnlen)
		49);
#line 18813 ""
	stop1_();
#line 18814 ""
    }
#line 18815 ""
    i__1 = ntot - 1;
#line 18815 ""
    for (in = 1; in <= i__1; ++in) {
#line 18816 ""
	a1ll_2.tno[in - 1] = a1ll_2.to[in] - a1ll_2.to[in - 1];
#line 18817 ""
/* L8: */
#line 18817 ""
    }
#line 18818 ""
    a1ll_2.tno[ntot - 1] = fnote_(a1ll_2.nodur, &a1ll_2.ivxo[ntot - 1], &
	    a1ll_2.ipo[ntot - 1], c1ommvl_1.nacc);
#line 18819 ""
    tnote[ntot - 1] = a1ll_2.tno[ntot - 1];

/*  Done w/ list.  Initialize loop for building note blocks: */

#line 18823 ""
    ib = 1;
#line 18824 ""
    istart[0] = 1;
#line 18825 ""
    space[0] = 0.f;
#line 18826 ""
    in = 1;

/*  Start the loop */

#line 18830 ""
L9:
#line 18831 ""
    if (in == ntot) {
#line 18832 ""
	if (space[ib - 1] < comtol_1.tol) {
#line 18833 ""
	    space[ib - 1] = a1ll_2.tno[in - 1];

/*  Last gap in bar is spanned by a note, so cannot need a squeeze. */

#line 18837 ""
	    squez[ib - 1] = 1.f;
#line 18838 ""
	}
#line 18839 ""
	istop[ib - 1] = ntot;

/* From here flow out of this if block and into block-setup */

#line 18843 ""
    } else if (space[ib - 1] < comtol_1.tol) {

/* space hasn't been set yet, so tentatively set: */

#line 18847 ""
	space[ib - 1] = a1ll_2.tno[in - 1];
#line 18848 ""
	if (space[ib - 1] < comtol_1.tol) {
#line 18849 ""
	    ++in;
#line 18850 ""
	} else {

/*  Tentative space tno(in) is non-zero. Set squez, which will be kept (since */
/*    it is a unique property of the particular increment starting here) : */

#line 18855 ""
	    squez[ib - 1] = getsquez_(&in, &ntot, &space[ib - 1], tnote, 
		    a1ll_2.to);
#line 18856 ""
	    istop[ib - 1] = in;
#line 18857 ""
	}
#line 18858 ""
	goto L9;
#line 18859 ""
    } else if (a1ll_2.tno[in] < comtol_1.tol) {

/* This is not the last note in the space, so */

#line 18863 ""
	++in;
#line 18864 ""
	goto L9;
#line 18865 ""
    } else if ((r__1 = a1ll_2.tno[in] - space[ib - 1], dabs(r__1)) < 
	    comtol_1.tol) {

/*  Next increment has same space.  Does it have same squez? */

#line 18869 ""
	i__1 = in + 1;
#line 18869 ""
	xsquez = getsquez_(&i__1, &ntot, &space[ib - 1], tnote, a1ll_2.to);

/*  If it does have the same squez, loop, otherwise flow out */

#line 18873 ""
	if ((r__1 = xsquez - squez[ib - 1], dabs(r__1)) < comtol_1.tol) {

/* Keep spacing the same, update tentative stop point */

#line 18877 ""
	    ++in;
#line 18878 ""
	    istop[ib - 1] = in;
#line 18879 ""
	    goto L9;
#line 18880 ""
	}
#line 18881 ""
    }

/* At this point istart, istop, space, and squez are good, so close out block */

#line 18885 ""
    tstart[ib - 1] = a1ll_2.to[istart[ib - 1] - 1];

/*  Compute elemskips assuming no flattening to increase min space.  The formula */
/*  is only correct if f1eon(t) = sqrt(t/2); more generally (after possible */
/*  flattening in pmxb), elsperns = squez*feon(space/squez) */

#line 18891 ""
    r__1 = space[ib - 1] * squez[ib - 1];
#line 18891 ""
    elsperns = f1eon_(&r__1);
#line 18892 ""
    if (istop[ib - 1] == ntot) {
#line 18893 ""
	r__1 = (a1ll_2.lenbar - tstart[ib - 1]) / space[ib - 1];
#line 18893 ""
	nnsk = i_nint(&r__1);
#line 18894 ""
    } else {
#line 18895 ""
	r__1 = (a1ll_2.to[istop[ib - 1]] - tstart[ib - 1]) / space[ib - 1];
#line 18895 ""
	nnsk = i_nint(&r__1);
#line 18896 ""
    }
#line 18897 ""
    linecom_1.elskb += elsperns * nnsk;
#line 18898 ""
    if (c1omnotes_1.nptr[c1omnotes_1.ibarcnt] > c1omnotes_1.nptr[
	    c1omnotes_1.ibarcnt - 1]) {
#line 18899 ""
	catspace_(&space[ib - 1], &squez[ib - 1], &nnsk);
#line 18900 ""
    } else {

/*  This is the first entry for this bar */

#line 18904 ""
	c1omnotes_1.nnpd[c1omnotes_1.nptr[c1omnotes_1.ibarcnt - 1] - 1] = 
		nnsk;
#line 18905 ""
	c1omnotes_1.durb[c1omnotes_1.nptr[c1omnotes_1.ibarcnt - 1] - 1] = 
		space[ib - 1];
#line 18906 ""
	c1omnotes_1.sqzb[c1omnotes_1.nptr[c1omnotes_1.ibarcnt - 1] - 1] = 
		squez[ib - 1];
#line 18907 ""
	++c1omnotes_1.nptr[c1omnotes_1.ibarcnt];
#line 18908 ""
    }

/*  Update minimum space spanned by a note */

#line 18912 ""
    if ((r__1 = squez[ib - 1] - 1, dabs(r__1)) < comtol_1.tol) {
/* Computing MIN */
#line 18912 ""
	r__2 = linecom_1.tnminb[c1omnotes_1.ibarcnt - 1], r__3 = space[ib - 1]
		;
#line 18912 ""
	linecom_1.tnminb[c1omnotes_1.ibarcnt - 1] = dmin(r__2,r__3);
#line 18912 ""
    }
#line 18914 ""
    if (istop[ib - 1] == ntot) {
#line 18914 ""
	goto L15;
#line 18914 ""
    }

/*  End of spatial accounting for now */

#line 18918 ""
    ++ib;
#line 18919 ""
    istart[ib - 1] = istop[ib - 2] + 1;
#line 18920 ""
    in = istart[ib - 1];

/* Set tentative block space for new block */

#line 18924 ""
    space[ib - 1] = a1ll_2.tno[in - 1];
#line 18925 ""
    if (space[ib - 1] > comtol_1.tol) {
#line 18925 ""
	squez[ib - 1] = getsquez_(&in, &ntot, &space[ib - 1], tnote, 
		a1ll_2.to);
#line 18925 ""
    }
#line 18927 ""
    istop[ib - 1] = in;
#line 18928 ""
    goto L9;
#line 18929 ""
L15:
#line 18930 ""
    return 0;
} /* makeabar_ */

/* Subroutine */ int midievent_(char *typeq, integer *in1, integer *in2, 
	ftnlen typeq_len)
{
    /* System generated locals */
    integer i__1;
    real r__1;

    /* Builtin functions */
    integer lbit_shift(integer, integer), i_nint(real *), s_wsle(cilist *), 
	    do_lio(integer *, integer *, char *, ftnlen), e_wsle(void);

    /* Local variables */
    static integer i__;
    extern integer isetvarlen_(integer *, integer *), log2_(integer *);
    static integer idur;
    extern /* Subroutine */ int stop1_(void);
    static integer nbytes, misperq;

    /* Fortran I/O blocks */
    static cilist io___1177 = { 0, 6, 0, 0, 0 };



/*  We now store "conductor" events in mmidi(numchan,.), and count bytes */
/*    with imidi(numchan) */

#line 18949 ""
    i__1 = comevent_1.miditime - comevent_1.lasttime;
#line 18949 ""
    idur = isetvarlen_(&i__1, &nbytes);
#line 18950 ""
    commidi_1.imidi[commidi_1.numchan] = commidi_1.imidi[commidi_1.numchan] + 
	    nbytes + 1;
#line 18951 ""
    i__1 = nbytes;
#line 18951 ""
    for (i__ = 1; i__ <= i__1; ++i__) {
#line 18952 ""
	commidi_1.mmidi[commidi_1.numchan + (commidi_1.imidi[
		commidi_1.numchan] - i__) * 25 - 25] = (shortint) (idur % 256)
		;
#line 18953 ""
	idur = lbit_shift(idur, (ftnlen)-8);
#line 18954 ""
/* L1: */
#line 18954 ""
    }
#line 18955 ""
    commidi_1.mmidi[commidi_1.numchan + commidi_1.imidi[commidi_1.numchan] * 
	    25 - 25] = 255;
#line 18956 ""
    if (*(unsigned char *)typeq == 't') {

/*  Tempo event.  in1 = quarters per minute (integer) */

#line 18960 ""
	commidi_1.mmidi[commidi_1.numchan + (commidi_1.imidi[
		commidi_1.numchan] + 1) * 25 - 25] = 81;
#line 18961 ""
	commidi_1.mmidi[commidi_1.numchan + (commidi_1.imidi[
		commidi_1.numchan] + 2) * 25 - 25] = 3;
#line 18962 ""
	r__1 = 6e7f / *in1;
#line 18962 ""
	misperq = i_nint(&r__1);
#line 18963 ""
	for (i__ = 1; i__ <= 3; ++i__) {
#line 18964 ""
	    commidi_1.mmidi[commidi_1.numchan + (commidi_1.imidi[
		    commidi_1.numchan] + 6 - i__) * 25 - 25] = (shortint) (
		    misperq % 256);
#line 18965 ""
	    misperq = lbit_shift(misperq, (ftnlen)-8);
#line 18966 ""
/* L2: */
#line 18966 ""
	}
#line 18967 ""
	commidi_1.imidi[commidi_1.numchan] += 5;
#line 18968 ""
    } else if (*(unsigned char *)typeq == 'm') {

/*  Meter event.  in1=numerator, in2=denom (power of 2) */

#line 18972 ""
	commidi_1.mmidi[commidi_1.numchan + (commidi_1.imidi[
		commidi_1.numchan] + 1) * 25 - 25] = 88;
#line 18973 ""
	commidi_1.mmidi[commidi_1.numchan + (commidi_1.imidi[
		commidi_1.numchan] + 2) * 25 - 25] = 4;
#line 18974 ""
	commidi_1.mmidi[commidi_1.numchan + (commidi_1.imidi[
		commidi_1.numchan] + 3) * 25 - 25] = (shortint) (*in1);
#line 18975 ""
	if (*in2 > 0) {
#line 18976 ""
	    commidi_1.mmidi[commidi_1.numchan + (commidi_1.imidi[
		    commidi_1.numchan] + 4) * 25 - 25] = (shortint) log2_(in2)
		    ;
#line 18977 ""
	} else {
#line 18978 ""
	    commidi_1.mmidi[commidi_1.numchan + (commidi_1.imidi[
		    commidi_1.numchan] + 4) * 25 - 25] = 0;
#line 18979 ""
	}
#line 18980 ""
	commidi_1.mmidi[commidi_1.numchan + (commidi_1.imidi[
		commidi_1.numchan] + 5) * 25 - 25] = 24;
#line 18981 ""
	commidi_1.mmidi[commidi_1.numchan + (commidi_1.imidi[
		commidi_1.numchan] + 6) * 25 - 25] = 8;
#line 18982 ""
	commidi_1.imidi[commidi_1.numchan] += 6;
#line 18983 ""
    } else if (*(unsigned char *)typeq == 'k') {

/*  Keychange event.  in1 = isig */

#line 18987 ""
	commidi_1.mmidi[commidi_1.numchan + (commidi_1.imidi[
		commidi_1.numchan] + 1) * 25 - 25] = 89;
#line 18988 ""
	commidi_1.mmidi[commidi_1.numchan + (commidi_1.imidi[
		commidi_1.numchan] + 2) * 25 - 25] = 2;
#line 18989 ""
	commidi_1.mmidi[commidi_1.numchan + (commidi_1.imidi[
		commidi_1.numchan] + 3) * 25 - 25] = (shortint) ((*in1 + 256) 
		% 256);
#line 18990 ""
	commidi_1.mmidi[commidi_1.numchan + (commidi_1.imidi[
		commidi_1.numchan] + 4) * 25 - 25] = 0;
#line 18991 ""
	commidi_1.imidi[commidi_1.numchan] += 4;
#line 18992 ""
    } else {
#line 18993 ""
	s_wsle(&io___1177);
#line 18993 ""
	do_lio(&c__9, &c__1, "Program flameout in midievent", (ftnlen)29);
#line 18993 ""
	e_wsle();
#line 18994 ""
	stop1_();
#line 18995 ""
    }
#line 18996 ""
    comevent_1.lasttime = comevent_1.miditime;
#line 18997 ""
    return 0;
} /* midievent_ */

/* Subroutine */ int moveln_(integer *iuin, integer *iuout, logical *done)
{
    /* System generated locals */
    integer i__1;

    /* Builtin functions */
    integer s_rsfe(cilist *), do_fio(integer *, char *, ftnlen), e_rsfe(void),
	     s_wsfe(cilist *), e_wsfe(void);

    /* Local variables */
    extern integer llen_(char *, integer *, ftnlen);
    static char outq[129];
    static integer lenout;

    /* Fortran I/O blocks */
    static cilist io___1178 = { 0, 0, 1, "(a)", 0 };
    static cilist io___1181 = { 0, 0, 0, "(a)", 0 };


#line 19002 ""
    *done = FALSE_;
#line 19003 ""
    io___1178.ciunit = *iuin;
#line 19003 ""
    i__1 = s_rsfe(&io___1178);
#line 19003 ""
    if (i__1 != 0) {
#line 19003 ""
	goto L1;
#line 19003 ""
    }
#line 19003 ""
    i__1 = do_fio(&c__1, outq, (ftnlen)129);
#line 19003 ""
    if (i__1 != 0) {
#line 19003 ""
	goto L1;
#line 19003 ""
    }
#line 19003 ""
    i__1 = e_rsfe();
#line 19003 ""
    if (i__1 != 0) {
#line 19003 ""
	goto L1;
#line 19003 ""
    }
#line 19004 ""
    lenout = llen_(outq, &c__129, (ftnlen)129);
#line 19005 ""
    io___1181.ciunit = *iuout;
#line 19005 ""
    s_wsfe(&io___1181);
#line 19005 ""
    do_fio(&c__1, outq, lenout);
#line 19005 ""
    e_wsfe();
#line 19006 ""
    return 0;
#line 19007 ""
L1:
#line 19007 ""
    *done = TRUE_;
#line 19008 ""
    return 0;
} /* moveln_ */

/* Subroutine */ int mrec1_(char *lineq, integer *iccount, integer *ndxm, 
	ftnlen lineq_len)
{
    /* System generated locals */
    integer i__1, i__2;

    /* Builtin functions */
    integer i_indx(char *, char *, ftnlen, ftnlen);

    /* Local variables */
    extern integer ntindex_(char *, char *, integer *, ftnlen, ftnlen);


/*  This is called when (a) macro recording is just starting and */
/*  (b) at the start of a new line, if recording is on */

#line 19024 ""
    if (! commac_1.mrecord) {

/*  Starting the macro */

#line 19028 ""
	c1ommac_1.ip1mac[commac_1.macnum - 1] = inbuff_1.ipbuf - 
		inbuff_1.lbuf[inbuff_1.ilbuf - 2] + *iccount;
#line 19029 ""
	c1ommac_1.il1mac[commac_1.macnum - 1] = inbuff_1.ilbuf - 1;
#line 19030 ""
	c1ommac_1.ic1mac[commac_1.macnum - 1] = *iccount;
#line 19031 ""
	commac_1.mrecord = TRUE_;
#line 19032 ""
    }
#line 19033 ""
    if (*iccount < 128) {
#line 19034 ""
	i__1 = *iccount;
#line 19034 ""
	*ndxm = i_indx(lineq + i__1, "M", 128 - i__1, (ftnlen)1);
#line 19035 ""
	if (*ndxm > 0) {
#line 19035 ""
	    i__1 = *iccount;
#line 19035 ""
	    i__2 = 128 - *iccount;
#line 19035 ""
	    *ndxm = ntindex_(lineq + i__1, "M", &i__2, 128 - i__1, (ftnlen)1);
#line 19035 ""
	}
#line 19037 ""
	if (*ndxm > 0) {

/*  This line ends the macro. */

#line 19041 ""
	    c1ommac_1.ip2mac[commac_1.macnum - 1] = inbuff_1.ipbuf - 
		    inbuff_1.lbuf[inbuff_1.ilbuf - 2] + *iccount + *ndxm;
#line 19042 ""
	    c1ommac_1.il2mac[commac_1.macnum - 1] = inbuff_1.ilbuf - 1;
#line 19043 ""
	    commac_1.mrecord = FALSE_;
#line 19044 ""
	}
#line 19045 ""
    }
#line 19046 ""
    return 0;
} /* mrec1_ */

integer ncmid_(integer *iv, integer *ip)
{
    /* System generated locals */
    integer ret_val;

    /* Builtin functions */
    integer s_wsle(cilist *), do_lio(integer *, integer *, char *, ftnlen), 
	    e_wsle(void);
    /* Subroutine */ int s_stop(char *, ftnlen);

    /* Local variables */
    static integer icc;
    static real xtime;

    /* Fortran I/O blocks */
    static cilist io___1184 = { 0, 6, 0, 0, 0 };


#line 19066 ""
    if (comcc_1.ncc[*iv - 1] == 1) {
#line 19067 ""
	ret_val = comcc_1.ncmidcc[*iv - 1];
#line 19068 ""
    } else {
#line 19069 ""
	xtime = all_2.to[comipl2_1.ipl2[commvl_1.ivx + *ip * 24 - 25] - 1];
#line 19070 ""
	for (icc = comcc_1.ncc[*iv - 1]; icc >= 1; --icc) {
#line 19071 ""
	    if (xtime > comcc_1.tcc[*iv + icc * 24 - 25] - comtol_1.tol) {
#line 19072 ""
		ret_val = comcc_1.ncmidcc[*iv + icc * 24 - 25];
#line 19073 ""
		return ret_val;
#line 19074 ""
	    }
#line 19075 ""
/* L1: */
#line 19075 ""
	}
#line 19076 ""
	s_wsle(&io___1184);
#line 19076 ""
	do_lio(&c__9, &c__1, "Problem in ncmid()", (ftnlen)18);
#line 19076 ""
	e_wsle();
#line 19077 ""
	s_stop("", (ftnlen)0);
#line 19078 ""
    }
#line 19079 ""
    return ret_val;
} /* ncmid_ */

integer ncmidf_(char *clefq, ftnlen clefq_len)
{
    /* System generated locals */
    integer ret_val;

    /* Builtin functions */
    integer i_indx(char *, char *, ftnlen, ftnlen);


/*  Return middle line of a clef */

#line 19085 ""
    if (*(unsigned char *)clefq == '8') {

/*  treblelowoct; will treat as treble for this purpose */

#line 19089 ""
	ret_val = 35;
#line 19090 ""
    } else {
#line 19091 ""
	ret_val = (i_indx(" b6r5n4a3m2s1t0f7", clefq, (ftnlen)17, (ftnlen)1) /
		 2 << 1) + 21;
#line 19092 ""
    }
#line 19093 ""
    return ret_val;
} /* ncmidf_ */

/* Subroutine */ int newvoice_(integer *jv, char *clefq, logical *change, 
	ftnlen clefq_len)
{
    static integer j;
    extern integer ncmidf_(char *, ftnlen);

#line 19116 ""
    commvl_1.nvmx[*jv - 1] = 1;
#line 19117 ""
    commvl_1.ivmx[*jv - 1] = *jv;
#line 19118 ""
    all_1.itsofar[*jv - 1] = 0;
#line 19119 ""
    all_1.nnl[*jv - 1] = 0;
#line 19120 ""
    comfb_1.nfb[*jv - 1] = 0;
#line 19121 ""
    if (all_1.firstgulp || *change) {
#line 19122 ""
	comcc_1.ncmidcc[*jv - 1] = ncmidf_(clefq, (ftnlen)1);
#line 19123 ""
    } else {
#line 19124 ""
	comcc_1.ncmidcc[*jv - 1] = comcc_1.ncmidcc[*jv + comcc_1.ncc[*jv - 1] 
		* 24 - 25];
#line 19125 ""
    }
#line 19126 ""
    comcc_1.tcc[*jv - 1] = 0.f;
#line 19127 ""
    comcc_1.ncc[*jv - 1] = 1;
#line 19128 ""
    comudsp_1.nudoff[*jv - 1] = 0;
#line 19129 ""
    comcc_1.ndotmv[*jv - 1] = 0;
#line 19130 ""
    for (j = 1; j <= 200; ++j) {
#line 19131 ""
	all_1.irest[*jv + j * 24 - 25] = 0;
#line 19132 ""
	all_1.islur[*jv + j * 24 - 25] = 0;
#line 19133 ""
	all_1.ipl[*jv + j * 24 - 25] = 0;
#line 19134 ""
	all_1.nacc[*jv + j * 24 - 25] = 0;
#line 19135 ""
	all_1.iornq[*jv + j * 24 - 1] = 0;
#line 19136 ""
	all_1.mult[*jv + j * 24 - 25] = 0;
#line 19137 ""
	if (*jv <= 2) {
#line 19137 ""
	    all_1.isfig[*jv + (j << 1) - 3] = FALSE_;
#line 19137 ""
	}
#line 19138 ""
/* L5: */
#line 19138 ""
    }
#line 19139 ""
    return 0;
} /* newvoice_ */

/* Subroutine */ int notefq_(char *noteq, integer *lnote, integer *nolev, 
	integer *ncmid, ftnlen noteq_len)
{
    /* System generated locals */
    integer i__1;
    char ch__1[1], ch__2[1];
    icilist ici__1;

    /* Builtin functions */
    /* Subroutine */ int s_copy(char *, char *, ftnlen, ftnlen);
    integer s_wsfi(icilist *), do_fio(integer *, char *, ftnlen), e_wsfi(void)
	    ;

    /* Local variables */
    static integer nupfroma, i__;
    extern /* Character */ VOID chax_(char *, ftnlen, integer *);
    static integer iname, ioctup;
    static char noteqt[1];
    extern /* Character */ VOID upcaseq_(char *, ftnlen, char *, ftnlen);


/*  Returns name of note level with octave transpositions, updates noctup. */

#line 19148 ""
    nupfroma = (*nolev + 1) % 7;
#line 19149 ""
    iname = nupfroma + 97;
#line 19150 ""
    ioctup = (*nolev + 1) / 7 - 4;
#line 19151 ""
    chax_(ch__1, (ftnlen)1, &iname);
#line 19151 ""
    *(unsigned char *)noteqt = *(unsigned char *)&ch__1[0];
#line 19152 ""
    if (*ncmid == 23) {
#line 19152 ""
	upcaseq_(ch__1, (ftnlen)1, noteqt, (ftnlen)1);
#line 19152 ""
	*(unsigned char *)noteqt = *(unsigned char *)&ch__1[0];
#line 19152 ""
    }
#line 19153 ""
    if (ioctup == comoct_1.noctup) {
#line 19154 ""
	s_copy(noteq, noteqt, (ftnlen)8, (ftnlen)1);
#line 19155 ""
	*lnote = 1;

/*  Must ALWAYS check if lnote=1 for use with functions requiring a blank */

#line 19159 ""
    } else if (ioctup > comoct_1.noctup) {

/*  Raise octave.  Encase in {} */

#line 19163 ""
	ici__1.icierr = 0;
#line 19163 ""
	ici__1.icirnum = 1;
#line 19163 ""
	ici__1.icirlen = 8;
#line 19163 ""
	ici__1.iciunit = noteq;
#line 19163 ""
	ici__1.icifmt = "(8a1)";
#line 19163 ""
	s_wsfi(&ici__1);
#line 19163 ""
	do_fio(&c__1, "{", (ftnlen)1);
#line 19163 ""
	i__1 = ioctup - 1;
#line 19163 ""
	for (i__ = comoct_1.noctup; i__ <= i__1; ++i__) {
#line 19163 ""
	    chax_(ch__2, (ftnlen)1, &c__39);
#line 19163 ""
	    *(unsigned char *)&ch__1[0] = *(unsigned char *)&ch__2[0];
#line 19163 ""
	    do_fio(&c__1, ch__1, (ftnlen)1);
#line 19163 ""
	}
#line 19163 ""
	do_fio(&c__1, noteqt, (ftnlen)1);
#line 19163 ""
	do_fio(&c__1, "}", (ftnlen)1);
#line 19163 ""
	e_wsfi();
#line 19165 ""
	*lnote = ioctup + 3 - comoct_1.noctup;
#line 19166 ""
	comoct_1.noctup = ioctup;
#line 19167 ""
    } else {

/*  Lower octave */

#line 19171 ""
	ici__1.icierr = 0;
#line 19171 ""
	ici__1.icirnum = 1;
#line 19171 ""
	ici__1.icirlen = 8;
#line 19171 ""
	ici__1.iciunit = noteq;
#line 19171 ""
	ici__1.icifmt = "(8a1)";
#line 19171 ""
	s_wsfi(&ici__1);
#line 19171 ""
	do_fio(&c__1, "{", (ftnlen)1);
#line 19171 ""
	i__1 = comoct_1.noctup - 1;
#line 19171 ""
	for (i__ = ioctup; i__ <= i__1; ++i__) {
#line 19171 ""
	    chax_(ch__2, (ftnlen)1, &c__96);
#line 19171 ""
	    *(unsigned char *)&ch__1[0] = *(unsigned char *)&ch__2[0];
#line 19171 ""
	    do_fio(&c__1, ch__1, (ftnlen)1);
#line 19171 ""
	}
#line 19171 ""
	do_fio(&c__1, noteqt, (ftnlen)1);
#line 19171 ""
	do_fio(&c__1, "}", (ftnlen)1);
#line 19171 ""
	e_wsfi();
#line 19173 ""
	*lnote = comoct_1.noctup + 3 - ioctup;
#line 19174 ""
	comoct_1.noctup = ioctup;
#line 19175 ""
    }
#line 19176 ""
    return 0;
} /* notefq_ */

/* Subroutine */ int notex_(char *notexq, integer *lnote, ftnlen notexq_len)
{
    /* System generated locals */
    address a__1[4], a__2[3], a__3[5], a__4[2], a__5[8];
    integer i__1, i__2, i__3[4], i__4[3], i__5[5], i__6[2], i__7[8];
    real r__1;
    char ch__1[1];

    /* Builtin functions */
    integer i_nint(real *);
    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen),
	     s_copy(char *, char *, ftnlen, ftnlen);
    integer s_wsfi(icilist *), do_fio(integer *, char *, ftnlen), e_wsfi(void)
	    , pow_ii(integer *, integer *), i_sign(integer *, integer *);

    /* Local variables */
    extern /* Subroutine */ int addblank_(char *, integer *, ftnlen);
    static real raisedot;
    static integer ip;
    static char udq[1];
    extern integer log2_(integer *);
    extern /* Character */ VOID chax_(char *, ftnlen, integer *);
    static logical even;
    static integer nole, ldot, nodu;
    static char dotq[4];
    extern /* Character */ VOID udqq_(char *, ftnlen, integer *, integer *, 
	    integer *, integer *, integer *, integer *);
    static real zmin;
    static char numq[2];
    extern integer ncmid_(integer *, integer *);
    static real fnole;
    static char noteq[8];
    static integer lrest;
    static char restq[40];
    extern /* Subroutine */ int notefq_(char *, integer *, integer *, integer 
	    *, ftnlen);
    static integer lnoten;

    /* Fortran I/O blocks */
    static icilist io___1203 = { 0, noteq, 0, "(i2)", 2, 1 };
    static icilist io___1207 = { 0, numq, 0, "(i2)", 2, 1 };
    static icilist io___1208 = { 0, noteq+1, 0, "(i2)", 2, 1 };
    static icilist io___1209 = { 0, noteq+1, 0, "(i3)", 3, 1 };



/*  Returns non-beamed full note name */

#line 19206 ""
    ip = all_1.ipo[all_1.jn - 1];
#line 19207 ""
    nole = all_1.nolev[commvl_1.ivx + ip * 24 - 25];

/*  Check for special situations with 2nds (see precrd) */

#line 19211 ""
    if (bit_test(all_1.nacc[commvl_1.ivx + ip * 24 - 25],30)) {
#line 19212 ""
	--nole;
#line 19213 ""
    } else if (bit_test(all_1.nacc[commvl_1.ivx + ip * 24 - 25],31)) {
#line 19214 ""
	++nole;
#line 19215 ""
    }
#line 19216 ""
    nodu = all_1.nodur[commvl_1.ivx + ip * 24 - 25];
#line 19217 ""
    if (! bit_test(all_1.irest[commvl_1.ivx + ip * 24 - 25],0)) {
#line 19218 ""
	i__1 = ncmid_(&all_1.iv, &ip);
#line 19218 ""
	udqq_(ch__1, (ftnlen)1, &nole, &i__1, &all_1.islur[commvl_1.ivx + ip *
		 24 - 25], &commvl_1.nvmx[all_1.iv - 1], &commvl_1.ivx, &
		all_1.nv);
#line 19218 ""
	*(unsigned char *)udq = *(unsigned char *)&ch__1[0];
#line 19220 ""
    }

/*  Check figure level */

#line 19224 ""
    if (all_1.figbass && ! bit_test(all_1.irest[commvl_1.ivx + ip * 24 - 25],
	    0) && (commvl_1.ivx == 1 && all_1.isfig[(ip << 1) - 2] || 
	    commvl_1.ivx == comfig_1.ivxfig2 && all_1.isfig[(ip << 1) - 1])) {
#line 19227 ""
	if (*(unsigned char *)udq == 'u' || nodu >= 64) {

/*  Upper or no stem, fnole (in noleunits) set by notehead */

#line 19231 ""
	    fnole = (real) nole;
#line 19232 ""
	} else {

/*  Lower stem, fnole set by bottom of stem */

#line 19236 ""
	    fnole = nole - all_1.stemlen;
#line 19237 ""
	}
#line 19238 ""
	zmin = fnole - ncmid_(&commvl_1.ivx, &ip) + 4;
#line 19239 ""
	if (commvl_1.ivx == 1) {
/* Computing MAX */
#line 19240 ""
	    r__1 = 4 - zmin;
#line 19240 ""
	    i__1 = all_1.ifigdr[(all_1.iline << 1) - 2], i__2 = i_nint(&r__1);
#line 19240 ""
	    all_1.ifigdr[(all_1.iline << 1) - 2] = max(i__1,i__2);
#line 19241 ""
	} else {
/* Computing MAX */
#line 19242 ""
	    r__1 = 4 - zmin;
#line 19242 ""
	    i__1 = all_1.ifigdr[(all_1.iline << 1) - 1], i__2 = i_nint(&r__1);
#line 19242 ""
	    all_1.ifigdr[(all_1.iline << 1) - 1] = max(i__1,i__2);
#line 19243 ""
	}
#line 19244 ""
    }
#line 19245 ""
    if (! bit_test(all_1.irest[commvl_1.ivx + ip * 24 - 25],0)) {
#line 19246 ""
	i__1 = ncmid_(&all_1.iv, &ip);
#line 19246 ""
	notefq_(noteq, &lnoten, &nole, &i__1, (ftnlen)8);
#line 19247 ""
	if (lnoten == 1) {
#line 19247 ""
	    addblank_(noteq, &lnoten, (ftnlen)8);
#line 19247 ""
	}
#line 19248 ""
	if (nodu == 1) {
/* Writing concatenation */
#line 19249 ""
	    i__3[0] = 1, a__1[0] = all_1.sq;
#line 19249 ""
	    i__3[1] = 4, a__1[1] = "cccc";
#line 19249 ""
	    i__3[2] = 1, a__1[2] = udq;
#line 19249 ""
	    i__3[3] = lnoten, a__1[3] = noteq;
#line 19249 ""
	    s_cat(notexq, a__1, i__3, &c__4, (ftnlen)79);
#line 19250 ""
	    *lnote = lnoten + 6;
#line 19251 ""
	} else if (nodu == 2) {
/* Writing concatenation */
#line 19252 ""
	    i__3[0] = 1, a__1[0] = all_1.sq;
#line 19252 ""
	    i__3[1] = 3, a__1[1] = "ccc";
#line 19252 ""
	    i__3[2] = 1, a__1[2] = udq;
#line 19252 ""
	    i__3[3] = lnoten, a__1[3] = noteq;
#line 19252 ""
	    s_cat(notexq, a__1, i__3, &c__4, (ftnlen)79);
#line 19253 ""
	    *lnote = lnoten + 5;
#line 19254 ""
	} else if (nodu == 4) {
/* Writing concatenation */
#line 19255 ""
	    i__3[0] = 1, a__1[0] = all_1.sq;
#line 19255 ""
	    i__3[1] = 2, a__1[1] = "cc";
#line 19255 ""
	    i__3[2] = 1, a__1[2] = udq;
#line 19255 ""
	    i__3[3] = lnoten, a__1[3] = noteq;
#line 19255 ""
	    s_cat(notexq, a__1, i__3, &c__4, (ftnlen)79);
#line 19256 ""
	    *lnote = lnoten + 4;
#line 19257 ""
	} else if (nodu == 8) {
/* Writing concatenation */
#line 19258 ""
	    i__3[0] = 1, a__1[0] = all_1.sq;
#line 19258 ""
	    i__3[1] = 1, a__1[1] = "c";
#line 19258 ""
	    i__3[2] = 1, a__1[2] = udq;
#line 19258 ""
	    i__3[3] = lnoten, a__1[3] = noteq;
#line 19258 ""
	    s_cat(notexq, a__1, i__3, &c__4, (ftnlen)79);
#line 19259 ""
	    *lnote = lnoten + 3;
#line 19260 ""
	} else if (nodu == 16) {
/* Writing concatenation */
#line 19261 ""
	    i__3[0] = 1, a__1[0] = all_1.sq;
#line 19261 ""
	    i__3[1] = 1, a__1[1] = "q";
#line 19261 ""
	    i__3[2] = 1, a__1[2] = udq;
#line 19261 ""
	    i__3[3] = lnoten, a__1[3] = noteq;
#line 19261 ""
	    s_cat(notexq, a__1, i__3, &c__4, (ftnlen)79);
#line 19262 ""
	    *lnote = lnoten + 3;
#line 19263 ""
	} else if (nodu == 32) {
/* Writing concatenation */
#line 19264 ""
	    i__3[0] = 1, a__1[0] = all_1.sq;
#line 19264 ""
	    i__3[1] = 1, a__1[1] = "h";
#line 19264 ""
	    i__3[2] = 1, a__1[2] = udq;
#line 19264 ""
	    i__3[3] = lnoten, a__1[3] = noteq;
#line 19264 ""
	    s_cat(notexq, a__1, i__3, &c__4, (ftnlen)79);
#line 19265 ""
	    *lnote = lnoten + 3;
#line 19266 ""
	} else if (nodu == 64) {
/* Writing concatenation */
#line 19267 ""
	    i__4[0] = 1, a__2[0] = all_1.sq;
#line 19267 ""
	    i__4[1] = 2, a__2[1] = "wh";
#line 19267 ""
	    i__4[2] = lnoten, a__2[2] = noteq;
#line 19267 ""
	    s_cat(notexq, a__2, i__4, &c__3, (ftnlen)79);
#line 19268 ""
	    *lnote = lnoten + 3;
#line 19269 ""
	} else if (nodu == 128) {
/* Writing concatenation */
#line 19270 ""
	    i__4[0] = 1, a__2[0] = all_1.sq;
#line 19270 ""
	    i__4[1] = 5, a__2[1] = "breve";
#line 19270 ""
	    i__4[2] = lnoten, a__2[2] = noteq;
#line 19270 ""
	    s_cat(notexq, a__2, i__4, &c__3, (ftnlen)79);
#line 19271 ""
	    *lnote = lnoten + 6;
#line 19272 ""
	} else {
#line 19273 ""
	    s_copy(dotq, "p", (ftnlen)4, (ftnlen)1);
#line 19274 ""
	    ldot = 1;
#line 19275 ""
	    if (bit_test(all_1.iornq[commvl_1.ivx + ip * 24 - 1],13)) {

/*  Dotted note with ')' ornament */

#line 19279 ""
		s_copy(dotq, "m", (ftnlen)4, (ftnlen)1);
#line 19280 ""
	    } else if (bit_test(all_1.islur[commvl_1.ivx + ip * 24 - 25],3)) {

/*  Double dot */

#line 19284 ""
		s_copy(dotq, "pp", (ftnlen)4, (ftnlen)2);
#line 19285 ""
		ldot = 2;
#line 19286 ""
	    }
#line 19287 ""
	    if (nodu >= 192) {
/* Writing concatenation */
#line 19288 ""
		i__3[0] = 1, a__1[0] = all_1.sq;
#line 19288 ""
		i__3[1] = 5, a__1[1] = "breve";
#line 19288 ""
		i__3[2] = ldot, a__1[2] = dotq;
#line 19288 ""
		i__3[3] = lnoten, a__1[3] = noteq;
#line 19288 ""
		s_cat(notexq, a__1, i__3, &c__4, (ftnlen)79);
#line 19289 ""
		*lnote = lnoten + 6 + ldot;
#line 19290 ""
	    } else if (nodu >= 96) {
/* Writing concatenation */
#line 19291 ""
		i__3[0] = 1, a__1[0] = all_1.sq;
#line 19291 ""
		i__3[1] = 2, a__1[1] = "wh";
#line 19291 ""
		i__3[2] = ldot, a__1[2] = dotq;
#line 19291 ""
		i__3[3] = lnoten, a__1[3] = noteq;
#line 19291 ""
		s_cat(notexq, a__1, i__3, &c__4, (ftnlen)79);
#line 19292 ""
		*lnote = lnoten + 3 + ldot;
#line 19293 ""
	    } else if (nodu >= 48) {
/* Writing concatenation */
#line 19294 ""
		i__5[0] = 1, a__3[0] = all_1.sq;
#line 19294 ""
		i__5[1] = 1, a__3[1] = "h";
#line 19294 ""
		i__5[2] = 1, a__3[2] = udq;
#line 19294 ""
		i__5[3] = ldot, a__3[3] = dotq;
#line 19294 ""
		i__5[4] = lnoten, a__3[4] = noteq;
#line 19294 ""
		s_cat(notexq, a__3, i__5, &c__5, (ftnlen)79);
#line 19295 ""
		*lnote = lnoten + 3 + ldot;
#line 19296 ""
	    } else if (nodu >= 24) {
/* Writing concatenation */
#line 19297 ""
		i__5[0] = 1, a__3[0] = all_1.sq;
#line 19297 ""
		i__5[1] = 1, a__3[1] = "q";
#line 19297 ""
		i__5[2] = 1, a__3[2] = udq;
#line 19297 ""
		i__5[3] = ldot, a__3[3] = dotq;
#line 19297 ""
		i__5[4] = lnoten, a__3[4] = noteq;
#line 19297 ""
		s_cat(notexq, a__3, i__5, &c__5, (ftnlen)79);
#line 19298 ""
		*lnote = lnoten + 3 + ldot;
#line 19299 ""
	    } else if (nodu >= 12) {
/* Writing concatenation */
#line 19300 ""
		i__5[0] = 1, a__3[0] = all_1.sq;
#line 19300 ""
		i__5[1] = 1, a__3[1] = "c";
#line 19300 ""
		i__5[2] = 1, a__3[2] = udq;
#line 19300 ""
		i__5[3] = ldot, a__3[3] = dotq;
#line 19300 ""
		i__5[4] = lnoten, a__3[4] = noteq;
#line 19300 ""
		s_cat(notexq, a__3, i__5, &c__5, (ftnlen)79);
#line 19301 ""
		*lnote = lnoten + 3 + ldot;
#line 19302 ""
	    } else if (nodu >= 6) {
/* Writing concatenation */
#line 19303 ""
		i__5[0] = 1, a__3[0] = all_1.sq;
#line 19303 ""
		i__5[1] = 2, a__3[1] = "cc";
#line 19303 ""
		i__5[2] = 1, a__3[2] = udq;
#line 19303 ""
		i__5[3] = ldot, a__3[3] = dotq;
#line 19303 ""
		i__5[4] = lnoten, a__3[4] = noteq;
#line 19303 ""
		s_cat(notexq, a__3, i__5, &c__5, (ftnlen)79);
#line 19304 ""
		*lnote = lnoten + 4 + ldot;
#line 19305 ""
		compoi_1.ispoi = TRUE_;
#line 19306 ""
	    } else {
/* Writing concatenation */
#line 19307 ""
		i__5[0] = 1, a__3[0] = all_1.sq;
#line 19307 ""
		i__5[1] = 3, a__3[1] = "ccc";
#line 19307 ""
		i__5[2] = 1, a__3[2] = udq;
#line 19307 ""
		i__5[3] = ldot, a__3[3] = dotq;
#line 19307 ""
		i__5[4] = lnoten, a__3[4] = noteq;
#line 19307 ""
		s_cat(notexq, a__3, i__5, &c__5, (ftnlen)79);
#line 19308 ""
		*lnote = lnoten + 5 + ldot;
#line 19309 ""
		compoi_1.ispoi = TRUE_;
#line 19310 ""
	    }
#line 19311 ""
	    if (*(unsigned char *)dotq == 'm') {

/*  Need another call to the note, in case the first one has octave shifts */

#line 19315 ""
		if (lnoten == 2) {
/* Writing concatenation */
#line 19316 ""
		    i__3[0] = *lnote, a__1[0] = notexq;
#line 19316 ""
		    i__3[1] = 1, a__1[1] = "{";
#line 19316 ""
		    i__3[2] = 1, a__1[2] = noteq + 1;
#line 19316 ""
		    i__3[3] = 1, a__1[3] = "}";
#line 19316 ""
		    s_cat(notexq, a__1, i__3, &c__4, (ftnlen)79);
#line 19317 ""
		    *lnote += 3;
#line 19318 ""
		} else {
#line 19319 ""
		    i__1 = lnoten - 2;
/* Writing concatenation */
#line 19319 ""
		    i__6[0] = *lnote, a__4[0] = notexq;
#line 19319 ""
		    i__6[1] = lnoten - 1 - i__1, a__4[1] = noteq + i__1;
#line 19319 ""
		    s_cat(notexq, a__4, i__6, &c__2, (ftnlen)79);
#line 19320 ""
		    ++(*lnote);
#line 19321 ""
		}
#line 19322 ""
	    }
#line 19323 ""
	}
#line 19324 ""
    } else if (bit_test(all_1.islur[commvl_1.ivx + ip * 24 - 25],29)) {

/*  Blank rest */

/* Writing concatenation */
#line 19328 ""
	i__6[0] = 1, a__4[0] = all_1.sq;
#line 19328 ""
	i__6[1] = 2, a__4[1] = "sk";
#line 19328 ""
	s_cat(notexq, a__4, i__6, &c__2, (ftnlen)79);
#line 19329 ""
	*lnote = 3;
#line 19330 ""
    } else {

/*  Non-blank rest */

#line 19334 ""
	*lnote = 0;
#line 19335 ""
	nole = (nole + 20) % 100 - 20;

/*  Kluge to get pause symbol for rp: */

#line 19339 ""
	if (bit_test(all_1.islur[commvl_1.ivx + ip * 24 - 25],19)) {
#line 19339 ""
	    nodu = 64;
#line 19339 ""
	}
#line 19340 ""
	if (nodu <= 28) {

/*  Normal rest < or = double-dotted quarter */

#line 19344 ""
	    lrest = 3;
#line 19345 ""
	    if (nodu > 14) {
/* Writing concatenation */
#line 19346 ""
		i__6[0] = 1, a__4[0] = all_1.sq;
#line 19346 ""
		i__6[1] = 2, a__4[1] = "qp";
#line 19346 ""
		s_cat(restq, a__4, i__6, &c__2, (ftnlen)40);
#line 19347 ""
	    } else if (nodu > 7) {
/* Writing concatenation */
#line 19348 ""
		i__6[0] = 1, a__4[0] = all_1.sq;
#line 19348 ""
		i__6[1] = 2, a__4[1] = "ds";
#line 19348 ""
		s_cat(restq, a__4, i__6, &c__2, (ftnlen)40);
#line 19349 ""
	    } else if (nodu > 3) {
/* Writing concatenation */
#line 19350 ""
		i__6[0] = 1, a__4[0] = all_1.sq;
#line 19350 ""
		i__6[1] = 2, a__4[1] = "qs";
#line 19350 ""
		s_cat(restq, a__4, i__6, &c__2, (ftnlen)40);
#line 19351 ""
	    } else if (nodu > 1) {
/* Writing concatenation */
#line 19352 ""
		i__6[0] = 1, a__4[0] = all_1.sq;
#line 19352 ""
		i__6[1] = 2, a__4[1] = "hs";
#line 19352 ""
		s_cat(restq, a__4, i__6, &c__2, (ftnlen)40);
#line 19353 ""
	    } else {
/* Writing concatenation */
#line 19354 ""
		i__6[0] = 1, a__4[0] = all_1.sq;
#line 19354 ""
		i__6[1] = 3, a__4[1] = "qqs";
#line 19354 ""
		s_cat(restq, a__4, i__6, &c__2, (ftnlen)40);
#line 19355 ""
		lrest = 4;
#line 19356 ""
	    }

/*  Special case for rest at start of F-tuplet inside a forced beam */

#line 19360 ""
	    if (bit_test(all_1.nacc[commvl_1.ivx + ip * 24 - 25],18) && 
		    bit_test(all_1.nacc[commvl_1.ivx + ip * 24 - 25],19)) {
/* Writing concatenation */
#line 19362 ""
		i__4[0] = 1, a__2[0] = all_1.sq;
#line 19362 ""
		i__4[1] = 3, a__2[1] = "pt4";
#line 19362 ""
		i__4[2] = lrest, a__2[2] = restq;
#line 19362 ""
		s_cat(restq, a__2, i__4, &c__3, (ftnlen)40);
#line 19363 ""
		lrest += 4;
#line 19364 ""
	    }
#line 19365 ""
	    s_copy(notexq, restq, (ftnlen)79, (ftnlen)40);
#line 19366 ""
	    *lnote = lrest;

/*  At this point notexq=restq,lnote=lrest are name of rest.  Now raise if necc. */

#line 19370 ""
	    if (nole != 0) {
#line 19371 ""
		if (abs(nole) < 10) {
#line 19372 ""
		    i__1 = abs(nole) + 48;
#line 19372 ""
		    chax_(ch__1, (ftnlen)1, &i__1);
#line 19372 ""
		    s_copy(noteq, ch__1, (ftnlen)8, (ftnlen)1);
#line 19373 ""
		    lnoten = 1;
#line 19374 ""
		} else {
#line 19375 ""
		    s_wsfi(&io___1203);
#line 19375 ""
		    i__1 = abs(nole);
#line 19375 ""
		    do_fio(&c__1, (char *)&i__1, (ftnlen)sizeof(integer));
#line 19375 ""
		    e_wsfi();
#line 19376 ""
		    lnoten = 2;
#line 19377 ""
		}
#line 19378 ""
		if (nole > 0) {
/* Writing concatenation */
#line 19379 ""
		    i__5[0] = 1, a__3[0] = all_1.sq;
#line 19379 ""
		    i__5[1] = 5, a__3[1] = "raise";
#line 19379 ""
		    i__5[2] = lnoten, a__3[2] = noteq;
#line 19379 ""
		    i__5[3] = 1, a__3[3] = all_1.sq;
#line 19379 ""
		    i__5[4] = 9, a__3[4] = "internote";
#line 19379 ""
		    s_cat(notexq, a__3, i__5, &c__5, (ftnlen)79);
#line 19380 ""
		} else {
/* Writing concatenation */
#line 19381 ""
		    i__5[0] = 1, a__3[0] = all_1.sq;
#line 19381 ""
		    i__5[1] = 5, a__3[1] = "lower";
#line 19381 ""
		    i__5[2] = lnoten, a__3[2] = noteq;
#line 19381 ""
		    i__5[3] = 1, a__3[3] = all_1.sq;
#line 19381 ""
		    i__5[4] = 9, a__3[4] = "internote";
#line 19381 ""
		    s_cat(notexq, a__3, i__5, &c__5, (ftnlen)79);
#line 19382 ""
		}
#line 19383 ""
		*lnote = lnoten + 16;
/* Writing concatenation */
#line 19384 ""
		i__6[0] = *lnote, a__4[0] = notexq;
#line 19384 ""
		i__6[1] = lrest, a__4[1] = restq;
#line 19384 ""
		s_cat(notexq, a__4, i__6, &c__2, (ftnlen)79);
#line 19385 ""
		*lnote += lrest;
#line 19386 ""
	    }
#line 19387 ""
	    i__1 = log2_(&nodu);
#line 19387 ""
	    if (pow_ii(&c__2, &i__1) != nodu) {

/*  Deal with dots (on rests shorter than half rest) */

/* Writing concatenation */
#line 19391 ""
		i__6[0] = 1, a__4[0] = all_1.sq;
#line 19391 ""
		i__6[1] = 2, a__4[1] = "pt";
#line 19391 ""
		s_cat(restq, a__4, i__6, &c__2, (ftnlen)40);
#line 19392 ""
		lrest = 3;
#line 19393 ""
		i__1 = log2_(&nodu);
#line 19393 ""
		if (nodu << 1 > pow_ii(&c__2, &i__1) * 3) {
/* Writing concatenation */
#line 19394 ""
		    i__6[0] = 1, a__4[0] = all_1.sq;
#line 19394 ""
		    i__6[1] = 3, a__4[1] = "ppt";
#line 19394 ""
		    s_cat(restq, a__4, i__6, &c__2, (ftnlen)40);
#line 19395 ""
		    lrest = 4;
#line 19396 ""
		}
#line 19397 ""
		nole += 4;
#line 19398 ""
		raisedot = 0.f;

/*  Tweak dot positions for special cases */

#line 19402 ""
		even = (nole + 100) % 2 == 0;
#line 19403 ""
		if (! even && (nole < 0 || nole > 8)) {
#line 19404 ""
		    raisedot = 1.f;
#line 19405 ""
		}
#line 19406 ""
		if (nole >= 10 || nole <= -1) {
#line 19407 ""
		    s_wsfi(&io___1207);
#line 19407 ""
		    do_fio(&c__1, (char *)&nole, (ftnlen)sizeof(integer));
#line 19407 ""
		    e_wsfi();
/* Writing concatenation */
#line 19408 ""
		    i__3[0] = lrest, a__1[0] = restq;
#line 19408 ""
		    i__3[1] = 1, a__1[1] = "{";
#line 19408 ""
		    i__3[2] = 2, a__1[2] = numq;
#line 19408 ""
		    i__3[3] = 1, a__1[3] = "}";
#line 19408 ""
		    s_cat(restq, a__1, i__3, &c__4, (ftnlen)40);
#line 19409 ""
		    lrest += 4;
#line 19410 ""
		} else {
/* Writing concatenation */
#line 19411 ""
		    i__6[0] = lrest, a__4[0] = restq;
#line 19411 ""
		    i__1 = nole + 48;
#line 19411 ""
		    chax_(ch__1, (ftnlen)1, &i__1);
#line 19411 ""
		    i__6[1] = 1, a__4[1] = ch__1;
#line 19411 ""
		    s_cat(restq, a__4, i__6, &c__2, (ftnlen)40);
#line 19412 ""
		    ++lrest;
#line 19413 ""
		}
#line 19414 ""
		if (raisedot > 0.f) {
/* Writing concatenation */
#line 19415 ""
		    i__7[0] = 1, a__5[0] = all_1.sq;
#line 19415 ""
		    i__7[1] = 5, a__5[1] = "raise";
#line 19415 ""
		    i__7[2] = 1, a__5[2] = all_1.sq;
#line 19415 ""
		    i__7[3] = 9, a__5[3] = "internote";
#line 19415 ""
		    i__7[4] = 1, a__5[4] = all_1.sq;
#line 19415 ""
		    i__7[5] = 5, a__5[5] = "hbox{";
#line 19415 ""
		    i__7[6] = lrest, a__5[6] = restq;
#line 19415 ""
		    i__7[7] = 1, a__5[7] = "}";
#line 19415 ""
		    s_cat(restq, a__5, i__7, &c__8, (ftnlen)40);
#line 19417 ""
		    lrest += 23;
#line 19418 ""
		}
/* Writing concatenation */
#line 19419 ""
		i__6[0] = lrest, a__4[0] = restq;
#line 19419 ""
		i__6[1] = *lnote, a__4[1] = notexq;
#line 19419 ""
		s_cat(notexq, a__4, i__6, &c__2, (ftnlen)79);
#line 19420 ""
		*lnote += lrest;
#line 19421 ""
	    }
#line 19422 ""
	} else {

/*  Half rest or longer */

#line 19426 ""
	    if (nole == 0) {

/*  Half or longer rest is not raised or lowered */

#line 19430 ""
		if (nodu <= 56) {
/* Writing concatenation */
#line 19431 ""
		    i__6[0] = 1, a__4[0] = all_1.sq;
#line 19431 ""
		    i__6[1] = 6, a__4[1] = "hpause";
#line 19431 ""
		    s_cat(notexq, a__4, i__6, &c__2, (ftnlen)79);
#line 19432 ""
		    *lnote = 7;
#line 19433 ""
		} else if (nodu <= 112) {
#line 19434 ""
		    if (! bit_test(all_1.islur[commvl_1.ivx + ip * 24 - 25],
			    19) || bit_test(all_1.irest[commvl_1.ivx + ip * 
			    24 - 25],25)) {
/* Writing concatenation */
#line 19436 ""
			i__6[0] = 1, a__4[0] = all_1.sq;
#line 19436 ""
			i__6[1] = 5, a__4[1] = "pause";
#line 19436 ""
			s_cat(notexq, a__4, i__6, &c__2, (ftnlen)79);
#line 19437 ""
		    } else {
/* Writing concatenation */
#line 19438 ""
			i__6[0] = 1, a__4[0] = all_1.sq;
#line 19438 ""
			i__6[1] = 5, a__4[1] = "pausc";
#line 19438 ""
			s_cat(notexq, a__4, i__6, &c__2, (ftnlen)79);
#line 19439 ""
		    }
#line 19440 ""
		    *lnote = 6;
#line 19441 ""
		} else {
/* Writing concatenation */
#line 19442 ""
		    i__6[0] = 1, a__4[0] = all_1.sq;
#line 19442 ""
		    i__6[1] = 5, a__4[1] = "PAuse";
#line 19442 ""
		    s_cat(notexq, a__4, i__6, &c__2, (ftnlen)79);
#line 19443 ""
		    *lnote = 6;
#line 19444 ""
		}
#line 19445 ""
		i__1 = log2_(&nodu);
#line 19445 ""
		if (pow_ii(&c__2, &i__1) != nodu) {

/*  Dotted rest, hpause or longer */

/* Writing concatenation */
#line 19449 ""
		    i__6[0] = *lnote, a__4[0] = notexq;
#line 19449 ""
		    i__6[1] = 1, a__4[1] = "p";
#line 19449 ""
		    s_cat(notexq, a__4, i__6, &c__2, (ftnlen)79);
#line 19450 ""
		    ++(*lnote);
#line 19451 ""
		    i__1 = log2_(&nodu);
#line 19451 ""
		    if (nodu << 1 > pow_ii(&c__2, &i__1) * 3) {

/*  Double dotted long rest */

/* Writing concatenation */
#line 19455 ""
			i__6[0] = *lnote, a__4[0] = notexq;
#line 19455 ""
			i__6[1] = 1, a__4[1] = "p";
#line 19455 ""
			s_cat(notexq, a__4, i__6, &c__2, (ftnlen)79);
#line 19456 ""
			++(*lnote);
#line 19457 ""
		    }
#line 19458 ""
		}
#line 19459 ""
	    } else {

/*  Raised or lowered half or whole rest */

#line 19463 ""
		if (nodu == 32) {
/* Writing concatenation */
#line 19464 ""
		    i__6[0] = 1, a__4[0] = all_1.sq;
#line 19464 ""
		    i__6[1] = 10, a__4[1] = "lifthpause";
#line 19464 ""
		    s_cat(notexq, a__4, i__6, &c__2, (ftnlen)79);
#line 19465 ""
		    *lnote = 11;
#line 19466 ""
		} else if (nodu == 48) {
/* Writing concatenation */
#line 19467 ""
		    i__6[0] = 1, a__4[0] = all_1.sq;
#line 19467 ""
		    i__6[1] = 11, a__4[1] = "lifthpausep";
#line 19467 ""
		    s_cat(notexq, a__4, i__6, &c__2, (ftnlen)79);
#line 19468 ""
		    *lnote = 12;
#line 19469 ""
		} else if (nodu == 56) {
/* Writing concatenation */
#line 19470 ""
		    i__6[0] = 1, a__4[0] = all_1.sq;
#line 19470 ""
		    i__6[1] = 12, a__4[1] = "lifthpausepp";
#line 19470 ""
		    s_cat(notexq, a__4, i__6, &c__2, (ftnlen)79);
#line 19471 ""
		    *lnote = 13;
#line 19472 ""
		} else if (nodu == 64) {
/* Writing concatenation */
#line 19473 ""
		    i__6[0] = 1, a__4[0] = all_1.sq;
#line 19473 ""
		    i__6[1] = 9, a__4[1] = "liftpause";
#line 19473 ""
		    s_cat(notexq, a__4, i__6, &c__2, (ftnlen)79);
#line 19474 ""
		    *lnote = 10;
#line 19475 ""
		} else if (nodu == 96) {
/* Writing concatenation */
#line 19476 ""
		    i__6[0] = 1, a__4[0] = all_1.sq;
#line 19476 ""
		    i__6[1] = 10, a__4[1] = "liftpausep";
#line 19476 ""
		    s_cat(notexq, a__4, i__6, &c__2, (ftnlen)79);
#line 19477 ""
		    *lnote = 11;
#line 19478 ""
		} else if (nodu == 112) {
/* Writing concatenation */
#line 19479 ""
		    i__6[0] = 1, a__4[0] = all_1.sq;
#line 19479 ""
		    i__6[1] = 11, a__4[1] = "liftpausepp";
#line 19479 ""
		    s_cat(notexq, a__4, i__6, &c__2, (ftnlen)79);
#line 19480 ""
		    *lnote = 12;
#line 19481 ""
		} else if (nodu == 128) {
/* Writing concatenation */
#line 19482 ""
		    i__6[0] = 1, a__4[0] = all_1.sq;
#line 19482 ""
		    i__6[1] = 9, a__4[1] = "liftPAuse";
#line 19482 ""
		    s_cat(notexq, a__4, i__6, &c__2, (ftnlen)79);
#line 19483 ""
		    *lnote = 10;
#line 19484 ""
		} else {

/*  Assume dotted double whole rest */

/* Writing concatenation */
#line 19488 ""
		    i__6[0] = 1, a__4[0] = all_1.sq;
#line 19488 ""
		    i__6[1] = 10, a__4[1] = "liftPAusep";
#line 19488 ""
		    s_cat(notexq, a__4, i__6, &c__2, (ftnlen)79);
#line 19489 ""
		    *lnote = 11;
#line 19490 ""
		}

/*  Set up height spec */

#line 19494 ""
		i__1 = abs(nole) / 2;
#line 19494 ""
		nole = i_sign(&i__1, &nole);
#line 19495 ""
		if (nole <= 9 && nole >= 0) {
#line 19496 ""
		    i__1 = nole + 48;
#line 19496 ""
		    chax_(ch__1, (ftnlen)1, &i__1);
#line 19496 ""
		    s_copy(noteq, ch__1, (ftnlen)8, (ftnlen)1);
#line 19497 ""
		    lnoten = 1;
#line 19498 ""
		} else {
#line 19499 ""
		    s_copy(noteq, "{", (ftnlen)8, (ftnlen)1);
#line 19500 ""
		    if (nole >= -9) {
#line 19501 ""
			s_wsfi(&io___1208);
#line 19501 ""
			do_fio(&c__1, (char *)&nole, (ftnlen)sizeof(integer));
#line 19501 ""
			e_wsfi();
#line 19502 ""
			lnoten = 3;
#line 19503 ""
		    } else {
#line 19504 ""
			s_wsfi(&io___1209);
#line 19504 ""
			do_fio(&c__1, (char *)&nole, (ftnlen)sizeof(integer));
#line 19504 ""
			e_wsfi();
#line 19505 ""
			lnoten = 4;
#line 19506 ""
		    }
/* Writing concatenation */
#line 19507 ""
		    i__6[0] = lnoten, a__4[0] = noteq;
#line 19507 ""
		    i__6[1] = 1, a__4[1] = "}";
#line 19507 ""
		    s_cat(noteq, a__4, i__6, &c__2, (ftnlen)8);
#line 19508 ""
		    ++lnoten;
#line 19509 ""
		}
/* Writing concatenation */
#line 19510 ""
		i__6[0] = *lnote, a__4[0] = notexq;
#line 19510 ""
		i__6[1] = lnoten, a__4[1] = noteq;
#line 19510 ""
		s_cat(notexq, a__4, i__6, &c__2, (ftnlen)79);
#line 19511 ""
		*lnote += lnoten;
#line 19512 ""
	    }
#line 19513 ""
	}
#line 19514 ""
    }
#line 19515 ""
    return 0;
} /* notex_ */

integer ntindex_(char *line, char *s2q, integer *lenline, ftnlen line_len, 
	ftnlen s2q_len)
{
    /* System generated locals */
    address a__1[2];
    integer ret_val, i__1, i__2, i__3[2];
    char ch__1[1], ch__2[2];

    /* Builtin functions */
    integer i_indx(char *, char *, ftnlen, ftnlen), s_cmp(char *, char *, 
	    ftnlen, ftnlen);
    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);

    /* Local variables */
    static integer ic, len;
    extern /* Character */ VOID chax_(char *, ftnlen, integer *);
    static integer ndxs2, ndxbs;
    static logical intex;
    extern integer lenstr_(char *, integer *, ftnlen);


/*  Returns index(line,s2q) if NOT in TeX string, 0 otherwise */

#line 19524 ""
    ndxs2 = i_indx(line, s2q, line_len, s2q_len);
#line 19525 ""
    chax_(ch__1, (ftnlen)1, &c__92);
#line 19525 ""
    ndxbs = i_indx(line, ch__1, line_len, (ftnlen)1);
#line 19526 ""
    if (ndxbs == 0 || ndxs2 < ndxbs) {
#line 19527 ""
	ret_val = ndxs2;
#line 19528 ""
    } else {

/*  There are both bs and s2q, and bs is to the left of sq2. So check bs's to */
/*  right of first: End is '\ ', start is ' \' */

#line 19533 ""
	len = lenstr_(line, lenline, line_len);
#line 19534 ""
	intex = TRUE_;
#line 19535 ""
	i__1 = len;
#line 19535 ""
	for (ic = ndxbs + 1; ic <= i__1; ++ic) {
#line 19536 ""
	    if (ic == ndxs2) {
#line 19537 ""
		if (intex) {
#line 19538 ""
		    ret_val = 0;
#line 19539 ""
		    i__2 = ic;
#line 19539 ""
		    ndxs2 = i_indx(line + i__2, s2q, len - i__2, s2q_len) + 
			    ic;
#line 19540 ""
		} else {
#line 19541 ""
		    ret_val = ndxs2;
#line 19542 ""
		    return ret_val;
#line 19543 ""
		}
#line 19544 ""
	    } else /* if(complicated condition) */ {
#line 19544 ""
		i__2 = ic;
/* Writing concatenation */
#line 19544 ""
		chax_(ch__1, (ftnlen)1, &c__92);
#line 19544 ""
		i__3[0] = 1, a__1[0] = ch__1;
#line 19544 ""
		i__3[1] = 1, a__1[1] = " ";
#line 19544 ""
		s_cat(ch__2, a__1, i__3, &c__2, (ftnlen)2);
#line 19544 ""
		if (intex && s_cmp(line + i__2, ch__2, ic + 2 - i__2, (ftnlen)
			2) == 0) {
#line 19545 ""
		    intex = FALSE_;
#line 19546 ""
		} else /* if(complicated condition) */ {
#line 19546 ""
		    i__2 = ic;
/* Writing concatenation */
#line 19546 ""
		    i__3[0] = 1, a__1[0] = " ";
#line 19546 ""
		    chax_(ch__1, (ftnlen)1, &c__92);
#line 19546 ""
		    i__3[1] = 1, a__1[1] = ch__1;
#line 19546 ""
		    s_cat(ch__2, a__1, i__3, &c__2, (ftnlen)2);
#line 19546 ""
		    if (! intex && s_cmp(line + i__2, ch__2, ic + 2 - i__2, (
			    ftnlen)2) == 0) {
#line 19548 ""
			intex = TRUE_;
#line 19549 ""
		    }
#line 19549 ""
		}
#line 19549 ""
	    }
#line 19550 ""
/* L1: */
#line 19550 ""
	}
#line 19551 ""
    }
#line 19552 ""
    return ret_val;
} /* ntindex_ */

/* Subroutine */ int ntrbbb_(integer *n, char *char1q, char *ulqq, integer *
	iv, char *notexq, integer *lnote, ftnlen char1q_len, ftnlen ulqq_len, 
	ftnlen notexq_len)
{
    /* System generated locals */
    address a__1[3], a__2[2];
    integer i__1[3], i__2[2], i__3;
    char ch__1[1];

    /* Builtin functions */
    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);

    /* Local variables */
    static integer im, len;
    extern /* Character */ VOID chax_(char *, ftnlen, integer *);
    extern /* Subroutine */ int stop1_(void);
    static char tempq[4];
    extern /* Subroutine */ int printl_(char *, ftnlen), istring_(integer *, 
	    char *, integer *, ftnlen);


/*  This appends to notexq e.g. '\ibbbu1' */

#line 19563 ""
    if (*n >= 5) {
#line 19563 ""
	combbm_1.isbbm = TRUE_;
#line 19563 ""
    }
#line 19564 ""
    if (*lnote > 0) {
/* Writing concatenation */
#line 19565 ""
	i__1[0] = *lnote, a__1[0] = notexq;
#line 19565 ""
	chax_(ch__1, (ftnlen)1, &c__92);
#line 19565 ""
	i__1[1] = 1, a__1[1] = ch__1;
#line 19565 ""
	i__1[2] = 1, a__1[2] = char1q;
#line 19565 ""
	s_cat(notexq, a__1, i__1, &c__3, (ftnlen)79);
#line 19566 ""
    } else {
/* Writing concatenation */
#line 19567 ""
	chax_(ch__1, (ftnlen)1, &c__92);
#line 19567 ""
	i__2[0] = 1, a__2[0] = ch__1;
#line 19567 ""
	i__2[1] = 1, a__2[1] = char1q;
#line 19567 ""
	s_cat(notexq, a__2, i__2, &c__2, (ftnlen)79);
#line 19568 ""
    }
#line 19569 ""
    *lnote += 2;
#line 19570 ""
    i__3 = *n;
#line 19570 ""
    for (im = 1; im <= i__3; ++im) {
/* Writing concatenation */
#line 19571 ""
	i__2[0] = *lnote, a__2[0] = notexq;
#line 19571 ""
	i__2[1] = 1, a__2[1] = "b";
#line 19571 ""
	s_cat(notexq, a__2, i__2, &c__2, (ftnlen)79);
#line 19572 ""
	++(*lnote);
#line 19573 ""
/* L3: */
#line 19573 ""
    }

/*  add the number, 0 if 12 */

/*  5/25/08 Allow >12 */

#line 19579 ""
    if (*iv < 24) {
#line 19580 ""
	istring_(iv, tempq, &len, (ftnlen)4);
#line 19581 ""
    } else if (*iv == 24) {
#line 19582 ""
	*(unsigned char *)tempq = '0';
#line 19583 ""
	len = 1;
#line 19584 ""
    } else {
#line 19585 ""
	printl_("Sorry, too man open beams", (ftnlen)25);
#line 19586 ""
	stop1_();
#line 19587 ""
    }
/* Writing concatenation */
#line 19588 ""
    i__1[0] = *lnote, a__1[0] = notexq;
#line 19588 ""
    i__1[1] = 1, a__1[1] = ulqq;
#line 19588 ""
    i__1[2] = len, a__1[2] = tempq;
#line 19588 ""
    s_cat(notexq, a__1, i__1, &c__3, (ftnlen)79);
#line 19589 ""
    *lnote = *lnote + 1 + len;
#line 19590 ""
    return 0;
} /* ntrbbb_ */

integer numclef_(char *clefq, ftnlen clefq_len)
{
    /* System generated locals */
    integer ret_val;

    /* Builtin functions */
    integer i_indx(char *, char *, ftnlen, ftnlen);


/*  Returns the number to be used as argument of \setclef for MusiXTeX */
/*  For input 0-6 or tsmanrb return 0-7 */
/*            7      f              9 */
/*            8                     0 */

#line 19600 ""
    if (*(unsigned char *)clefq < 55) {
#line 19601 ""
	ret_val = *(unsigned char *)clefq - 48;
#line 19602 ""
    } else if (*(unsigned char *)clefq == '7') {
#line 19603 ""
	ret_val = 9;
#line 19604 ""
    } else if (*(unsigned char *)clefq == '8') {
#line 19605 ""
	ret_val = 0;
#line 19606 ""
    } else {
#line 19607 ""
	ret_val = i_indx("tsmanrbxxf", clefq, (ftnlen)10, (ftnlen)1) - 1;
#line 19608 ""
    }
#line 19609 ""
    return ret_val;
} /* numclef_ */

/* Subroutine */ int outbar_(integer *i__, integer *jlast)
{
    /* System generated locals */
    address a__1[3];
    integer i__1[3], i__2;
    real r__1;
    char ch__1[9], ch__2[1], ch__3[11];
    cilist ci__1;

    /* Builtin functions */
    double r_lg10(real *);
    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
    integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void);

    /* Local variables */
    extern /* Character */ VOID chax_(char *, ftnlen, integer *);
    static integer nfmt;

#line 19613 ""
    r__1 = *i__ + .5f;
#line 19613 ""
    nfmt = r_lg10(&r__1) + 2;
#line 19614 ""
    if (*jlast + 5 + nfmt < 80) {
#line 19615 ""
	ci__1.cierr = 0;
#line 19615 ""
	ci__1.ciunit = 6;
/* Writing concatenation */
#line 19615 ""
	i__1[0] = 5, a__1[0] = "(a5,i";
#line 19615 ""
	i__2 = nfmt + 48;
#line 19615 ""
	chax_(ch__2, (ftnlen)1, &i__2);
#line 19615 ""
	i__1[1] = 1, a__1[1] = ch__2;
#line 19615 ""
	i__1[2] = 3, a__1[2] = ",$)";
#line 19615 ""
	ci__1.cifmt = (s_cat(ch__1, a__1, i__1, &c__3, (ftnlen)9), ch__1);
#line 19615 ""
	s_wsfe(&ci__1);
#line 19615 ""
	do_fio(&c__1, "  Bar", (ftnlen)5);
#line 19615 ""
	do_fio(&c__1, (char *)&(*i__), (ftnlen)sizeof(integer));
#line 19615 ""
	e_wsfe();
#line 19616 ""
	ci__1.cierr = 0;
#line 19616 ""
	ci__1.ciunit = 15;
/* Writing concatenation */
#line 19616 ""
	i__1[0] = 5, a__1[0] = "(a5,i";
#line 19616 ""
	i__2 = nfmt + 48;
#line 19616 ""
	chax_(ch__2, (ftnlen)1, &i__2);
#line 19616 ""
	i__1[1] = 1, a__1[1] = ch__2;
#line 19616 ""
	i__1[2] = 3, a__1[2] = ",$)";
#line 19616 ""
	ci__1.cifmt = (s_cat(ch__1, a__1, i__1, &c__3, (ftnlen)9), ch__1);
#line 19616 ""
	s_wsfe(&ci__1);
#line 19616 ""
	do_fio(&c__1, "  Bar", (ftnlen)5);
#line 19616 ""
	do_fio(&c__1, (char *)&(*i__), (ftnlen)sizeof(integer));
#line 19616 ""
	e_wsfe();
#line 19617 ""
	*jlast = *jlast + 5 + nfmt;
#line 19618 ""
    } else {
#line 19619 ""
	ci__1.cierr = 0;
#line 19619 ""
	ci__1.ciunit = 6;
/* Writing concatenation */
#line 19619 ""
	i__1[0] = 7, a__1[0] = "(/,a5,i";
#line 19619 ""
	i__2 = nfmt + 48;
#line 19619 ""
	chax_(ch__2, (ftnlen)1, &i__2);
#line 19619 ""
	i__1[1] = 1, a__1[1] = ch__2;
#line 19619 ""
	i__1[2] = 3, a__1[2] = ",$)";
#line 19619 ""
	ci__1.cifmt = (s_cat(ch__3, a__1, i__1, &c__3, (ftnlen)11), ch__3);
#line 19619 ""
	s_wsfe(&ci__1);
#line 19619 ""
	do_fio(&c__1, "  Bar", (ftnlen)5);
#line 19619 ""
	do_fio(&c__1, (char *)&(*i__), (ftnlen)sizeof(integer));
#line 19619 ""
	e_wsfe();
#line 19620 ""
	ci__1.cierr = 0;
#line 19620 ""
	ci__1.ciunit = 15;
/* Writing concatenation */
#line 19620 ""
	i__1[0] = 7, a__1[0] = "(/,a5,i";
#line 19620 ""
	i__2 = nfmt + 48;
#line 19620 ""
	chax_(ch__2, (ftnlen)1, &i__2);
#line 19620 ""
	i__1[1] = 1, a__1[1] = ch__2;
#line 19620 ""
	i__1[2] = 3, a__1[2] = ",$)";
#line 19620 ""
	ci__1.cifmt = (s_cat(ch__3, a__1, i__1, &c__3, (ftnlen)11), ch__3);
#line 19620 ""
	s_wsfe(&ci__1);
#line 19620 ""
	do_fio(&c__1, "  Bar", (ftnlen)5);
#line 19620 ""
	do_fio(&c__1, (char *)&(*i__), (ftnlen)sizeof(integer));
#line 19620 ""
	e_wsfe();
#line 19621 ""
	*jlast = nfmt + 5;
#line 19622 ""
    }
#line 19623 ""
    return 0;
} /* outbar_ */

/* Subroutine */ int pmxa_(char *basenameq, integer *lbase, logical *isfirst, 
	integer *nsyout, integer *nbarss, logical *optimize, ftnlen 
	basenameq_len)
{
    /* Initialized data */

    static real wtimesig = .72f;
    static real wclef = .8f;
    static real wkeysig = .28f;

    /* System generated locals */
    integer i__1, i__2, i__3, i__4, i__5, i__6;
    real r__1, r__2, r__3, r__4;
    doublereal d__1, d__2;
    olist o__1;
    cllist cl__1;
    alist al__1;

    /* Builtin functions */
    integer s_wsle(cilist *), e_wsle(void), do_lio(integer *, integer *, char 
	    *, ftnlen), s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), 
	    e_wsfe(void), f_open(olist *), f_clos(cllist *), i_nint(real *);
    double pow_dd(doublereal *, doublereal *);
    integer f_rew(alist *);

    /* Local variables */
    extern /* Subroutine */ int g1etnote_(logical *, integer *, logical *, 
	    logical *);
    extern integer i1fnodur_(integer *, char *, ftnlen);
    extern /* Subroutine */ int makeabar_(void);
    static real xmtrnum0, heightil;
    extern /* Subroutine */ int findeonk_(integer *, integer *, real *, real *
	    , real *, real *, real *);
    static real elsstarg;
    static logical cstuplet;
    static real c__, d__;
    static integer i__, j, listcresc;
    extern /* Subroutine */ int getpmxmod_(logical *, char *, ftnlen);
    static integer isysendpg;
    static logical fulltrans;
    static integer ip, nomnsystp, kv;
    static real xn;
    static integer nns, isy, listdecresc, key1, key2;
    static real diff;
    static integer iflb, ifig, ifpb, ioff;
    extern doublereal feon_(real *);
    static real elsk[3999];
    static integer ikey;
    static real elss[125];
    static logical loop;
    static real wdpt;
    static integer iptr;
    static real diff1;
    static integer ibar1;
    extern doublereal f1eon_(real *);
    extern /* Subroutine */ int stop1_(void);
    static integer ipage, naccs;
    static real celsk[4000];
    static logical newmb[3999];
    static integer ibars;
    static real dtmin, dtmax, xelsk, wmins;
    static integer ivnow, ibarb4;
    static real fsyst;
    static integer isyst;
    static real elmin0, elmin1;
    static integer isysb4;
    static real omegag, facins, glueil;
    extern /* Subroutine */ int outbar_(integer *, integer *);
    static integer jprntb, nintpg, mtrdnp, mtrnmp;
    extern /* Subroutine */ int printl_(char *, ftnlen);
    static integer nshort;
    static real wminpt, poenom, celskb4, xiltxt;
    static integer nsystp;
    static real wsyspt;
    extern /* Subroutine */ int g1etset_(integer *, integer *, integer *, 
	    integer *, integer *, integer *, real *, integer *, integer *, 
	    integer *, integer *, logical *);
    static integer lenbeat, lastbar[126];
    static real xilfrac;
    static integer iflbnow;
    static logical bottreb;
    static integer mtrdenl, imovbrk, lenmult, iscount;
    static real sumelsk;
    static integer instnow, nsystpp;

    /* Fortran I/O blocks */
    static cilist io___1223 = { 0, 6, 0, 0, 0 };
    static cilist io___1224 = { 0, 6, 0, 0, 0 };
    static cilist io___1225 = { 0, 15, 0, "(a)", 0 };
    static cilist io___1226 = { 0, 19, 0, "(i6)", 0 };
    static cilist io___1238 = { 0, 6, 0, 0, 0 };
    static cilist io___1242 = { 0, 6, 0, 0, 0 };
    static cilist io___1248 = { 0, 15, 0, "(/,a20,i4,a1,i4)", 0 };
    static cilist io___1249 = { 0, 6, 0, "(/,a20,i4,a1,i4)", 0 };
    static cilist io___1254 = { 0, 6, 0, 0, 0 };
    static cilist io___1256 = { 0, 6, 0, 0, 0 };
    static cilist io___1257 = { 0, 6, 0, 0, 0 };
    static cilist io___1258 = { 0, 6, 0, 0, 0 };
    static cilist io___1259 = { 0, 15, 0, "(a,2i5)", 0 };
    static cilist io___1260 = { 0, 15, 0, "(a)", 0 };
    static cilist io___1262 = { 0, 12, 0, "(a)", 0 };
    static cilist io___1263 = { 0, 12, 0, 0, 0 };
    static cilist io___1264 = { 0, 12, 0, "(6f10.5/f10.5,3i5)", 0 };
    static cilist io___1265 = { 0, 12, 0, 0, 0 };
    static cilist io___1284 = { 0, 12, 0, 0, 0 };
    static cilist io___1299 = { 0, 12, 0, "(i5)", 0 };
    static cilist io___1317 = { 0, 12, 0, "(1pe12.5/i5,5e12.3)", 0 };
    static cilist io___1318 = { 0, 13, 0, "(i5)", 0 };
    static cilist io___1319 = { 0, 6, 0, "(/,a)", 0 };
    static cilist io___1320 = { 0, 6, 0, 0, 0 };
    static cilist io___1321 = { 0, 15, 0, "(/,a)", 0 };
    static cilist io___1322 = { 0, 15, 0, "()", 0 };


/* ccccccccccccccccccccccccccccccccccccccccccccccc */
/* c                                            cc */
/* c Subroutine, combine with pmxb.for */
/* c */
/* ccccccccccccccccccccccccccccccccccccccccccccccc */
/* c */
/* c  Need to consider X spaces in xtuplets when getting poenom, and */
/* c      maybe fbar? */
/* c  mx06a */
/* c    ID numbers for voices when number of voices is reduced. */
/* c */
/* c  mx03a */
/* c    account for new fracindent for new movements. */
/* c */
/* c  Known changes since pmxa. Version 1.1b (see pmxb for longer list) */
/* c */
/* c  Check ID codes for slurs. */
/* c  Version 1.24 still does not have details for spacing/positioning */
/* c    arpeggios if there are accidentals or shifted notes or crowded scores. */
/* c  Fix problem in 1.22 with arpeggios across multi-line staves */
/* c  Fix problem in 1.22 with flat key signatures */
/* c  Read setup data as strings */
/* c  Warning for octave designation plus +/- */
/* c  Don't pause for volta warning, */
/* c  Macros */
/* c  Correct fsyst to account for transposition and key changes. */
/* c  Check for nbars > nsyst */
/* c */
/* cccccccccccccccccccccccccccccccccc */
#line 19710 ""
    /* Parameter adjustments */
#line 19710 ""
    --nbarss;
#line 19710 ""

#line 19710 ""
    /* Function Body */
#line 19712 ""
    for (i__ = 1; i__ <= 125; ++i__) {
#line 19713 ""
	comshort_1.poefa[i__ - 1] = 1.f;
#line 19714 ""
/* L97: */
#line 19714 ""
    }
#line 19715 ""
    comis4bignv_1.is4bignv = FALSE_;
#line 19716 ""
    comis4bignv_1.aiset = FALSE_;
#line 19717 ""
    commus_1.whead20 = .3f;
#line 19718 ""
    comshort_1.ishort = 0;
#line 19719 ""
    if (! (*optimize)) {
#line 19720 ""
	s_wsle(&io___1223);
#line 19720 ""
	e_wsle();
#line 19721 ""
	s_wsle(&io___1224);
#line 19721 ""
	do_lio(&c__9, &c__1, "Starting first PMX pass", (ftnlen)23);
#line 19721 ""
	e_wsle();
#line 19722 ""
	s_wsfe(&io___1225);
#line 19722 ""
	do_fio(&c__1, " Starting first PMX pass", (ftnlen)24);
#line 19722 ""
	e_wsfe();
#line 19723 ""
    }
#line 19724 ""
    if (*isfirst) {
#line 19725 ""
	o__1.oerr = 0;
#line 19725 ""
	o__1.ounit = 19;
#line 19725 ""
	o__1.ofnmlen = 11;
#line 19725 ""
	o__1.ofnm = "pmxaerr.dat";
#line 19725 ""
	o__1.orl = 0;
#line 19725 ""
	o__1.osta = 0;
#line 19725 ""
	o__1.oacc = 0;
#line 19725 ""
	o__1.ofm = 0;
#line 19725 ""
	o__1.oblnk = 0;
#line 19725 ""
	f_open(&o__1);
#line 19726 ""
	s_wsfe(&io___1226);
#line 19726 ""
	do_fio(&c__1, (char *)&c__0, (ftnlen)sizeof(integer));
#line 19726 ""
	e_wsfe();
#line 19727 ""
	cl__1.cerr = 0;
#line 19727 ""
	cl__1.cunit = 19;
#line 19727 ""
	cl__1.csta = 0;
#line 19727 ""
	f_clos(&cl__1);
#line 19728 ""
    }
#line 19729 ""
    if (! (*optimize)) {
#line 19729 ""
	jprntb = 81;
#line 19729 ""
    }
#line 19730 ""
    commac_1.macuse = 0;
#line 19731 ""
    comkeys_1.ornrpt = FALSE_;
#line 19732 ""
    comkeys_1.stickys = FALSE_;
#line 19733 ""
    commac_1.mrecord = FALSE_;
#line 19734 ""
    commac_1.mplay = FALSE_;
#line 19735 ""
    c1omget_1.lastchar = FALSE_;
#line 19736 ""
    comnvst_2.novshrinktop = FALSE_;
#line 19737 ""
    cstuplet = FALSE_;
#line 19738 ""
    comslur_1.fontslur = TRUE_;
#line 19739 ""
    comligfont_1.isligfont = FALSE_;
#line 19740 ""
    fulltrans = FALSE_;
#line 19741 ""
    for (c1omnotes_1.ibarcnt = 1; c1omnotes_1.ibarcnt <= 3999; 
	    ++c1omnotes_1.ibarcnt) {
#line 19742 ""
	c1omnotes_1.udsp[c1omnotes_1.ibarcnt - 1] = 0.f;
#line 19743 ""
	c1omnotes_1.wminnh[c1omnotes_1.ibarcnt - 1] = -1.f;
#line 19744 ""
/* L42: */
#line 19744 ""
    }

/*  Initialize input buffer */

#line 19748 ""
    c1omget_1.lenbuf0 = inbuff_1.ipbuf;
#line 19749 ""
    inbuff_1.ipbuf = 0;
#line 19750 ""
    inbuff_1.ilbuf = 1;
#line 19751 ""
    g1etset_(&a1ll_2.nv, &comkeys_1.noinst, &a1ll_2.mtrnuml, &mtrdenl, &
	    mtrnmp, &mtrdnp, &xmtrnum0, comkeys_1.newkey, &compage_1.npages, &
	    compage_1.nsyst, &commus_1.musize, &bottreb);

/*  Set up list of instrument numbers (iv) */

#line 19756 ""
    ivnow = 0;
#line 19757 ""
    i__1 = comkeys_1.noinst;
#line 19757 ""
    for (instnow = 1; instnow <= i__1; ++instnow) {
#line 19758 ""
	i__2 = c1omget_1.nsperi[instnow - 1];
#line 19758 ""
	for (iscount = 1; iscount <= i__2; ++iscount) {
#line 19759 ""
	    ++ivnow;
#line 19760 ""
	    cominsttrans_1.instno[ivnow - 1] = instnow;
#line 19761 ""
/* L14: */
#line 19761 ""
	}
#line 19762 ""
/* L13: */
#line 19762 ""
    }

/*  Save initial meter for midi */

#line 19766 ""
    if (! (*isfirst) && compage_1.npages == 0) {
#line 19767 ""
	s_wsle(&io___1238);
#line 19767 ""
	do_lio(&c__9, &c__1, "Sorry, must have npages>0 for optimization.", (
		ftnlen)43);
#line 19767 ""
	e_wsle();
#line 19768 ""
	stop1_();
#line 19769 ""
    }
#line 19770 ""
    *nsyout = compage_1.nsyst;

/*  isig1 will be changed in getnote if there is a transposition */

#line 19774 ""
    comkeys_1.isig1 = comkeys_1.newkey[0];
#line 19775 ""
    if (compage_1.npages > compage_1.nsyst) {
#line 19776 ""
	printl_("npages > nsyst in input.  Please fix the input.", (ftnlen)47)
		;
#line 19777 ""
	stop1_();
#line 19778 ""
    }

/*  fbar = afterruleskip/elemskip */
/*  apt = width of small accidental + space in points (= 6 at 20pt) =wheadpt */

#line 19783 ""
    c1ommvl_1.fbar = 1.f;
#line 19784 ""
    c1omnotes_1.wheadpt = commus_1.whead20 * commus_1.musize;
#line 19785 ""
    ifig = 0;
#line 19786 ""
    compage_1.usefig = TRUE_;
#line 19787 ""
    lenbeat = i1fnodur_(&mtrdenl, "x", (ftnlen)1);
#line 19788 ""
    lenmult = 1;
#line 19789 ""
    if (mtrdenl == 2) {
#line 19790 ""
	lenbeat = 16;
#line 19791 ""
	lenmult = 2;
#line 19792 ""
    }
#line 19793 ""
    a1ll_2.lenbr1 = lenmult * a1ll_2.mtrnuml * lenbeat;
#line 19794 ""
    r__1 = lenmult * xmtrnum0 * lenbeat;
#line 19794 ""
    a1ll_2.lenbr0 = i_nint(&r__1);
#line 19795 ""
    a1ll_2.mtrnuml = 0;
#line 19796 ""
    if (a1ll_2.lenbr0 != 0) {
#line 19797 ""
	c1omnotes_1.ibaroff = 1;
#line 19798 ""
	a1ll_2.lenbar = a1ll_2.lenbr0;
#line 19799 ""
    } else {
#line 19800 ""
	c1omnotes_1.ibaroff = 0;
#line 19801 ""
	a1ll_2.lenbar = a1ll_2.lenbr1;
#line 19802 ""
    }
#line 19803 ""
    c1omnotes_1.ibarcnt = 0;
#line 19804 ""
    c1omnotes_1.nptr[0] = 1;
#line 19805 ""
    a1ll_2.iccount = 128;
#line 19806 ""
    compage_1.nmovbrk = 0;
#line 19807 ""
    compage_1.nflb = 0;
#line 19808 ""
    compage_1.nfpb = 0;
#line 19809 ""
    compage_1.ipagfpb[0] = 1;
#line 19810 ""
    compage_1.isysfpb[0] = 1;
#line 19811 ""
    compage_1.ibarflb[0] = 1;
#line 19812 ""
    compage_1.isysflb[0] = 1;
#line 19813 ""
    compage_1.nistaff[0] = a1ll_2.nv - 1;

/*  Check for pmx.mod */

#line 19817 ""
    c1omget_1.linesinpmxmod = 0;
#line 19818 ""
    getpmxmod_(&c_true, " ", (ftnlen)1);
#line 19819 ""
    if (! (*isfirst) && c1omget_1.linesinpmxmod > 0) {
#line 19820 ""
	s_wsle(&io___1242);
#line 19820 ""
	do_lio(&c__9, &c__1, "Sorry, cannot optimize if there is a pmx.mod f"\
		"ile", (ftnlen)49);
#line 19820 ""
	e_wsle();
#line 19821 ""
	stop1_();
#line 19822 ""
    }

/*  Initialize for loop over lines */

#line 19826 ""
    comkeys_1.nkeys = 1;
#line 19827 ""
    comkeys_1.ibrkch[0] = 1;
#line 19828 ""
    comkeys_1.mbrestsav = 0;
#line 19829 ""
    comkeys_1.shifton = FALSE_;
#line 19830 ""
    a1ll_2.firstline = TRUE_;
#line 19831 ""
    a1ll_2.newmeter = FALSE_;
#line 19832 ""
    c1omget_1.ihead = 0;
#line 19833 ""
    c1omget_1.isheadr = FALSE_;
#line 19834 ""
    comkeys_1.idsig = 0;
#line 19835 ""
    c1omnotes_1.iddot = 0;
#line 19836 ""
    compage_1.fintstf = -1.f;
#line 19837 ""
    compage_1.gintstf = 1.f;
#line 19838 ""
    listcresc = 0;
#line 19839 ""
    listdecresc = 0;
#line 19840 ""
L30:
#line 19840 ""
    loop = TRUE_;
#line 19841 ""
    comkeys_1.iskchb = FALSE_;
#line 19842 ""
    c1omget_1.issegno = FALSE_;
#line 19843 ""
    a1ll_2.nbars = 0;
#line 19844 ""
    c1omnotes_1.ibarmbr = 0;
#line 19845 ""
    i__1 = a1ll_2.nv;
#line 19845 ""
    for (a1ll_2.iv = 1; a1ll_2.iv <= i__1; ++a1ll_2.iv) {
#line 19846 ""
	c1ommvl_1.nvmx[a1ll_2.iv - 1] = 1;
#line 19847 ""
	c1ommvl_1.ivmx[a1ll_2.iv - 1] = a1ll_2.iv;
#line 19848 ""
	a1ll_2.itsofar[a1ll_2.iv - 1] = 0;
#line 19849 ""
	a1ll_2.nnl[a1ll_2.iv - 1] = 0;
#line 19850 ""
	for (j = 1; j <= 200; ++j) {
#line 19851 ""
	    a1ll_2.rest[a1ll_2.iv + j * 24 - 25] = FALSE_;
#line 19852 ""
	    c1ommvl_1.nacc[a1ll_2.iv + j * 24 - 25] = 0.f;
#line 19853 ""
/* L5: */
#line 19853 ""
	}
#line 19854 ""
/* L4: */
#line 19854 ""
    }
#line 19855 ""
    a1ll_2.iv = 1;
#line 19856 ""
    c1ommvl_1.ivx = 1;
#line 19857 ""
    c1omget_1.fbon = FALSE_;
#line 19858 ""
    comkeys_1.barend = FALSE_;
#line 19859 ""
    c1omget_1.isvolt = FALSE_;
#line 19860 ""
L2:
#line 19860 ""
    if (loop) {

/*  Within this short loop, nv voices are filled up for the duration of a block. */
/*  On exit (loop=.false.) the following are set: nnl(nv),itsofar(nv) */
/*  nodur(..),rest(..).  nnl will later be */
/*  increased and things slid around as accidental skips are added. */

#line 19867 ""
	g1etnote_(&loop, &ifig, optimize, &fulltrans);
#line 19868 ""
	if (c1omget_1.lastchar) {
#line 19868 ""
	    goto L20;
#line 19868 ""
	}
#line 19869 ""
	goto L2;
#line 19870 ""
    }
#line 19871 ""
    if (comkeys_1.mbrestsav > 0) {
#line 19872 ""
	printl_(" ", (ftnlen)1);
#line 19873 ""
	printl_("You must enter the same multibar rest in ALL parts", (ftnlen)
		50);
#line 19875 ""
	stop1_();
#line 19876 ""
    }
#line 19877 ""
    i__1 = a1ll_2.nbars;
#line 19877 ""
    for (a1ll_2.ibar = 1; a1ll_2.ibar <= i__1; ++a1ll_2.ibar) {
#line 19878 ""
	++c1omnotes_1.ibarcnt;

/*  The following is just a signal to start a new bar when cataloging spaces */
/*    for catspace(...) */

#line 19883 ""
	c1omnotes_1.nptr[c1omnotes_1.ibarcnt] = c1omnotes_1.nptr[
		c1omnotes_1.ibarcnt - 1];
#line 19884 ""
	newmb[c1omnotes_1.ibarcnt - 1] = FALSE_;
#line 19885 ""
	if (a1ll_2.newmeter && a1ll_2.ibar == 1) {
#line 19885 ""
	    newmb[c1omnotes_1.ibarcnt - 1] = TRUE_;
#line 19885 ""
	}

/*  Above is only for spacing calcs later on.  Remember new meter can only occur */
/*  at START of a new input line (ibar = 1) */

#line 19890 ""
	if (a1ll_2.ibar != c1omnotes_1.ibarmbr) {
#line 19891 ""
	    if (! (*optimize)) {
#line 19891 ""
		i__2 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff;
#line 19891 ""
		outbar_(&i__2, &jprntb);
#line 19891 ""
	    }
#line 19892 ""
	} else {
#line 19893 ""
	    if (! (*optimize)) {
#line 19894 ""
		s_wsfe(&io___1248);
#line 19894 ""
		do_fio(&c__1, " Multibar rest, bars", (ftnlen)20);
#line 19894 ""
		i__2 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff;
#line 19894 ""
		do_fio(&c__1, (char *)&i__2, (ftnlen)sizeof(integer));
#line 19894 ""
		do_fio(&c__1, "-", (ftnlen)1);
#line 19894 ""
		i__3 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			c1omnotes_1.mbrest - 1;
#line 19894 ""
		do_fio(&c__1, (char *)&i__3, (ftnlen)sizeof(integer));
#line 19894 ""
		e_wsfe();
#line 19896 ""
		s_wsfe(&io___1249);
#line 19896 ""
		do_fio(&c__1, " Multibar rest, bars", (ftnlen)20);
#line 19896 ""
		i__2 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff;
#line 19896 ""
		do_fio(&c__1, (char *)&i__2, (ftnlen)sizeof(integer));
#line 19896 ""
		do_fio(&c__1, "-", (ftnlen)1);
#line 19896 ""
		i__3 = c1omnotes_1.ibarcnt - c1omnotes_1.ibaroff + 
			c1omnotes_1.mbrest - 1;
#line 19896 ""
		do_fio(&c__1, (char *)&i__3, (ftnlen)sizeof(integer));
#line 19896 ""
		e_wsfe();
#line 19898 ""
		jprntb = 0;
#line 19899 ""
	    }
#line 19900 ""
	    c1omnotes_1.ibaroff = c1omnotes_1.ibaroff - c1omnotes_1.mbrest + 
		    1;
#line 19901 ""
	}
#line 19902 ""
	if (a1ll_2.firstline && a1ll_2.lenbr0 != 0) {
#line 19903 ""
	    if (a1ll_2.ibar == 1) {
#line 19904 ""
		a1ll_2.lenbar = a1ll_2.lenbr0;
#line 19905 ""
	    } else {
#line 19906 ""
		a1ll_2.lenbar = a1ll_2.lenbr1;
#line 19907 ""
	    }
#line 19908 ""
	}
#line 19909 ""
	if (a1ll_2.ibar > 1) {

/*  For bars after first, slide all stuff down to beginning of arrays */

#line 19913 ""
	    i__2 = a1ll_2.nv;
#line 19913 ""
	    for (a1ll_2.iv = 1; a1ll_2.iv <= i__2; ++a1ll_2.iv) {
#line 19914 ""
		i__3 = c1ommvl_1.nvmx[a1ll_2.iv - 1];
#line 19914 ""
		for (kv = 1; kv <= i__3; ++kv) {
#line 19915 ""
		    c1ommvl_1.ivx = c1ommvl_1.ivmx[a1ll_2.iv + kv * 24 - 25];
#line 19916 ""
		    ioff = a1ll_2.nib[c1ommvl_1.ivx + (a1ll_2.ibar - 1) * 24 
			    - 25];
#line 19917 ""
		    i__4 = a1ll_2.nib[c1ommvl_1.ivx + a1ll_2.ibar * 24 - 25] 
			    - ioff;
#line 19917 ""
		    for (ip = 1; ip <= i__4; ++ip) {
#line 19918 ""
			a1ll_2.nodur[c1ommvl_1.ivx + ip * 24 - 25] = 
				a1ll_2.nodur[c1ommvl_1.ivx + (ip + ioff) * 24 
				- 25];
#line 19919 ""
			a1ll_2.rest[c1ommvl_1.ivx + ip * 24 - 25] = 
				a1ll_2.rest[c1ommvl_1.ivx + (ip + ioff) * 24 
				- 25];
#line 19920 ""
			c1ommvl_1.nacc[c1ommvl_1.ivx + ip * 24 - 25] = 
				c1ommvl_1.nacc[c1ommvl_1.ivx + (ip + ioff) * 
				24 - 25];
#line 19921 ""
/* L12: */
#line 19921 ""
		    }
#line 19922 ""
/* L1199: */
#line 19922 ""
		}
#line 19923 ""
/* L11: */
#line 19923 ""
	    }
#line 19924 ""
	}
#line 19925 ""
	i__2 = a1ll_2.nv;
#line 19925 ""
	for (a1ll_2.iv = 1; a1ll_2.iv <= i__2; ++a1ll_2.iv) {
#line 19926 ""
	    i__3 = c1ommvl_1.nvmx[a1ll_2.iv - 1];
#line 19926 ""
	    for (kv = 1; kv <= i__3; ++kv) {
#line 19927 ""
		ioff = 0;
#line 19928 ""
		if (a1ll_2.ibar > 1) {
#line 19928 ""
		    ioff = a1ll_2.nib[c1ommvl_1.ivmx[a1ll_2.iv + kv * 24 - 25]
			     + (a1ll_2.ibar - 1) * 24 - 25];
#line 19928 ""
		}
#line 19929 ""
/* L6799: */
#line 19929 ""
	    }
#line 19930 ""
/* L67: */
#line 19930 ""
	}
#line 19931 ""
	makeabar_();
#line 19932 ""
	elsk[c1omnotes_1.ibarcnt - 1] = linecom_1.elskb + c1ommvl_1.fbar;
#line 19933 ""
/* L10: */
#line 19933 ""
    }
#line 19934 ""
    a1ll_2.newmeter = FALSE_;
#line 19935 ""
    a1ll_2.firstline = FALSE_;
#line 19936 ""
    goto L30;
#line 19937 ""
L20:

/* Vertical analysis. */

#line 19941 ""
    if (compage_1.npages == 0) {
#line 19942 ""
	if (compage_1.nsyst == 0) {
#line 19943 ""
	    s_wsle(&io___1254);
#line 19943 ""
	    do_lio(&c__9, &c__1, "When npages=0, must set nsyst=bars/syst, n"\
		    "ot 0", (ftnlen)46);
#line 19943 ""
	    e_wsle();
#line 19944 ""
	    stop1_();
#line 19945 ""
	}
#line 19946 ""
	compage_1.nsyst = (c1omnotes_1.ibarcnt - 1) / compage_1.nsyst + 1;
#line 19947 ""
	if (a1ll_2.nv == 1) {
#line 19948 ""
	    nsystpp = 12;
#line 19949 ""
	} else if (a1ll_2.nv == 2) {
#line 19950 ""
	    nsystpp = 7;
#line 19951 ""
	} else if (a1ll_2.nv == 3) {
#line 19952 ""
	    nsystpp = 5;
#line 19953 ""
	} else if (a1ll_2.nv == 4) {
#line 19954 ""
	    nsystpp = 3;
#line 19955 ""
	} else if (a1ll_2.nv <= 7) {
#line 19956 ""
	    nsystpp = 2;
#line 19957 ""
	} else {
#line 19958 ""
	    nsystpp = 1;
#line 19959 ""
	}
#line 19960 ""
	compage_1.npages = (compage_1.nsyst - 1) / nsystpp + 1;
#line 19961 ""
    }

/*  Check nsyst vs ibarcnt */

#line 19965 ""
    if (compage_1.nsyst > c1omnotes_1.ibarcnt) {
#line 19966 ""
	s_wsle(&io___1256);
#line 19966 ""
	e_wsle();
#line 19967 ""
	s_wsle(&io___1257);
#line 19967 ""
	do_lio(&c__9, &c__1, "nsyst,ibarcnt:", (ftnlen)14);
#line 19967 ""
	do_lio(&c__3, &c__1, (char *)&compage_1.nsyst, (ftnlen)sizeof(integer)
		);
#line 19967 ""
	do_lio(&c__3, &c__1, (char *)&c1omnotes_1.ibarcnt, (ftnlen)sizeof(
		integer));
#line 19967 ""
	e_wsle();
#line 19968 ""
	s_wsle(&io___1258);
#line 19968 ""
	do_lio(&c__9, &c__1, "There are more systems than bars.", (ftnlen)33);
#line 19968 ""
	e_wsle();
#line 19969 ""
	s_wsfe(&io___1259);
#line 19969 ""
	do_fio(&c__1, " nsyst,ibarcnt:", (ftnlen)15);
#line 19969 ""
	do_fio(&c__1, (char *)&compage_1.nsyst, (ftnlen)sizeof(integer));
#line 19969 ""
	do_fio(&c__1, (char *)&c1omnotes_1.ibarcnt, (ftnlen)sizeof(integer));
#line 19969 ""
	e_wsfe();
#line 19970 ""
	s_wsfe(&io___1260);
#line 19970 ""
	do_fio(&c__1, " There are more systems than bars.", (ftnlen)34);
#line 19970 ""
	e_wsfe();
#line 19971 ""
	stop1_();
#line 19972 ""
    }

/*  Set up dummy forced line & page breaks after last real one */

#line 19976 ""
    ++compage_1.nflb;
#line 19977 ""
    compage_1.ibarflb[compage_1.nflb] = c1omnotes_1.ibarcnt + 1;
#line 19978 ""
    compage_1.isysflb[compage_1.nflb] = compage_1.nsyst + 1;
#line 19979 ""
    ++compage_1.nfpb;
#line 19980 ""
    compage_1.ipagfpb[compage_1.nfpb] = compage_1.npages + 1;
#line 19981 ""
    compage_1.isysfpb[compage_1.nfpb] = compage_1.nsyst + 1;
#line 19982 ""
    heightil = compage_1.ptheight * 4.f / commus_1.musize;
#line 19983 ""
    o__1.oerr = 0;
#line 19983 ""
    o__1.ounit = 12;
#line 19983 ""
    o__1.ofnm = 0;
#line 19983 ""
    o__1.orl = 0;
#line 19983 ""
    o__1.osta = "SCRATCH";
#line 19983 ""
    o__1.oacc = 0;
#line 19983 ""
    o__1.ofm = 0;
#line 19983 ""
    o__1.oblnk = 0;
#line 19983 ""
    f_open(&o__1);
#line 19984 ""
    s_wsfe(&io___1262);
#line 19984 ""
    do_fio(&c__1, basenameq, (*lbase));
#line 19984 ""
    e_wsfe();
#line 19985 ""
    s_wsle(&io___1263);
#line 19985 ""
    do_lio(&c__3, &c__1, (char *)&(*lbase), (ftnlen)sizeof(integer));
#line 19985 ""
    e_wsle();

/* Pass to pmxb the initial signature, including effect of transposition. */

#line 19989 ""
    s_wsfe(&io___1264);
#line 19989 ""
    do_fio(&c__1, (char *)&c1ommvl_1.fbar, (ftnlen)sizeof(real));
#line 19989 ""
    do_fio(&c__1, (char *)&c1omnotes_1.wheadpt, (ftnlen)sizeof(real));
#line 19989 ""
    do_fio(&c__1, (char *)&cblock_1.etait, (ftnlen)sizeof(real));
#line 19989 ""
    do_fio(&c__1, (char *)&cblock_1.etatc, (ftnlen)sizeof(real));
#line 19989 ""
    do_fio(&c__1, (char *)&cblock_1.etacs1, (ftnlen)sizeof(real));
#line 19989 ""
    do_fio(&c__1, (char *)&cblock_1.etatop, (ftnlen)sizeof(real));
#line 19989 ""
    do_fio(&c__1, (char *)&cblock_1.etabot, (ftnlen)sizeof(real));
#line 19989 ""
    do_fio(&c__1, (char *)&cominbot_1.inbothd, (ftnlen)sizeof(integer));
#line 19989 ""
    do_fio(&c__1, (char *)&cblock_1.inhnoh, (ftnlen)sizeof(integer));
#line 19989 ""
    do_fio(&c__1, (char *)&comkeys_1.isig1, (ftnlen)sizeof(integer));
#line 19989 ""
    e_wsfe();
#line 19991 ""
    s_wsle(&io___1265);
#line 19991 ""
    do_lio(&c__3, &c__1, (char *)&compage_1.npages, (ftnlen)sizeof(integer));
#line 19991 ""
    do_lio(&c__4, &c__1, (char *)&compage_1.widthpt, (ftnlen)sizeof(real));
#line 19991 ""
    do_lio(&c__4, &c__1, (char *)&compage_1.ptheight, (ftnlen)sizeof(real));
#line 19991 ""
    do_lio(&c__4, &c__1, (char *)&compage_1.hoffpt, (ftnlen)sizeof(real));
#line 19991 ""
    do_lio(&c__4, &c__1, (char *)&compage_1.voffpt, (ftnlen)sizeof(real));
#line 19991 ""
    do_lio(&c__3, &c__1, (char *)&compage_1.nsyst, (ftnlen)sizeof(integer));
#line 19991 ""
    e_wsle();
#line 19992 ""
    iflbnow = -1;
#line 19993 ""
    isysb4 = 0;
#line 19994 ""
    i__1 = compage_1.nfpb;
#line 19994 ""
    for (ifpb = 1; ifpb <= i__1; ++ifpb) {

/*  Each time thru this loop is like a single score with several pages */

#line 19998 ""
	compage_1.npages = compage_1.ipagfpb[ifpb] - compage_1.ipagfpb[ifpb - 
		1];
#line 19999 ""
	compage_1.nsyst = compage_1.isysfpb[ifpb] - compage_1.isysfpb[ifpb - 
		1];
#line 20000 ""
	nomnsystp = (compage_1.nsyst - 1) / compage_1.npages + 1;
#line 20001 ""
	nshort = nomnsystp * compage_1.npages - compage_1.nsyst;
#line 20002 ""
	i__2 = compage_1.npages;
#line 20002 ""
	for (ipage = 1; ipage <= i__2; ++ipage) {
#line 20003 ""
	    nsystp = nomnsystp;
#line 20004 ""
	    if (ipage <= nshort) {
#line 20004 ""
		--nsystp;
#line 20004 ""
	    }

/*  Last system number on this page: */
#line 20007 ""
	    isysendpg = isysb4 + nsystp;
#line 20008 ""
	    nintpg = 0;
#line 20009 ""
	    i__3 = isysendpg;
#line 20009 ""
	    for (isy = isysb4 + 1; isy <= i__3; ++isy) {
#line 20010 ""
		if (compage_1.isysflb[iflbnow + 1] == isy) {
#line 20010 ""
		    ++iflbnow;
#line 20010 ""
		}
#line 20011 ""
		nintpg += compage_1.nistaff[iflbnow];
#line 20012 ""
/* L15: */
#line 20012 ""
	    }
#line 20013 ""
	    xilfrac = 0.f;
#line 20014 ""
	    xiltxt = 0.f;
#line 20015 ""
	    if (ipage == 1 && c1omget_1.ihead > 0) {

/*  Needn't zero out ihead after printing titles if we only allow titles at top? */

#line 20019 ""
		if ((c1omget_1.ihead & 1) == 1) {
#line 20020 ""
		    xiltxt += cblock_1.hgtin * 4 / commus_1.musize;
#line 20021 ""
		    xilfrac += cblock_1.etait;
#line 20022 ""
		}
#line 20023 ""
		if ((c1omget_1.ihead & 2) == 2) {
#line 20024 ""
		    xiltxt += cblock_1.hgtti * 4 / commus_1.musize;
#line 20025 ""
		    xilfrac += cblock_1.etatc;
#line 20026 ""
		}
#line 20027 ""
		if ((c1omget_1.ihead & 4) == 4) {
#line 20028 ""
		    xiltxt += cblock_1.hgtco * 4 / commus_1.musize;
#line 20029 ""
		    xilfrac += cblock_1.etacs1;
#line 20030 ""
		} else {

/* Use double the title-composer space if there is no composer */

#line 20034 ""
		    xilfrac += cblock_1.etatc;
#line 20035 ""
		}
#line 20036 ""
	    }
#line 20037 ""
	    d__ = xilfrac + nsystp - 1 + cblock_1.etatop + cblock_1.etabot;
#line 20038 ""
	    c__ = (real) nintpg;
#line 20039 ""
	    xn = heightil - xiltxt - (nintpg + nsystp << 2) - (nsystp - 1) * 
		    cblock_1.xilbn;
#line 20040 ""
	    if (bottreb) {
#line 20040 ""
		xn -= (nsystp - 1) * cblock_1.xilbtc;
#line 20040 ""
	    }
#line 20041 ""
	    if (c1omget_1.ihead == 0 && c1omget_1.isheadr) {
#line 20041 ""
		xn -= cblock_1.xilhdr;
#line 20041 ""
	    }
#line 20042 ""
	    if (ifig == 1) {
#line 20043 ""
		xn -= nsystp * cblock_1.xilfig;
#line 20044 ""
	    }
#line 20045 ""
	    glueil = (xn - cblock_1.b * c__) / (d__ + cblock_1.a * c__);
#line 20046 ""
	    omegag = (cblock_1.b * d__ + cblock_1.a * xn) / (d__ + cblock_1.a 
		    * c__);

/*  G = \interlines between systems */
/*  omega*G = \interlines between staves of the same system */
/*  \interstaff = 4+omega*G */
/*  C = total number of interstaff spaces in the page */
/*  D = omega-indep factors for scalable height = nsy-1 (intersystem glue) */
/*      + etatop + etabot + etatxt + */
/*  N = scaleable height (\interlignes) = height - htext - staff heights - xil */
/*  xil = extra interliges = (nsy-1)*xilbn + 10 if header and no titles */
/*                          + (nsy-1)*xiltcb    for treble clef bottoms */
/*                          + nsy*xilfig        for figures */
/*  G = N/(D + omega * C) = glueil,   (1) */
/*  But (empirically)  omega*G = a*G + b (2) */
/*      with a=1.071 and b=2.714 */
/*  Solving (1) and (2) gives */
/*      G = (N-b*C)/(D+a*C) , omega*G = (b*D+a*N)/(D+a*C) */
/*  Pass to pmxb    omega*G (=\interstaff-4) */
/*                  (etatop,bot,it,tc,cx)*G as inputs to \titles */

/*       glueil = (heightil-xiltxt-nsystp*(xil+4*nv)) */
/*    *             /(nsystp*(1+gfact*(nv-1))-1+etatop+etabot+xilfrac) */
/*       xnsttop = glueil*etatop */
/*       xintstaff = 4+gfact*glueil */

/*  Only the first page will get local adjustment now if needed, others in pmxb */

#line 20073 ""
	    if (ifpb == 1 && ipage == 1 && compage_1.fintstf > 0.f) {
#line 20074 ""
		facins = compage_1.fintstf;
#line 20075 ""
		compage_1.fintstf = -1.f;
#line 20076 ""
	    } else {

/*  gintstf = 1.0 by default, but may be changed with AI<x> */

#line 20080 ""
		facins = compage_1.gintstf;
#line 20081 ""
	    }
#line 20082 ""
	    s_wsle(&io___1284);
#line 20082 ""
	    do_lio(&c__3, &c__1, (char *)&nsystp, (ftnlen)sizeof(integer));
/* Computing MAX */
#line 20082 ""
	    r__2 = 0.f, r__3 = cblock_1.etatop * glueil;
#line 20082 ""
	    r__1 = dmax(r__2,r__3);
#line 20082 ""
	    do_lio(&c__4, &c__1, (char *)&r__1, (ftnlen)sizeof(real));
#line 20082 ""
	    r__4 = facins * (omegag + 4);
#line 20082 ""
	    do_lio(&c__4, &c__1, (char *)&r__4, (ftnlen)sizeof(real));
#line 20082 ""
	    e_wsle();
#line 20083 ""
	    c1omget_1.ihead = 0;
#line 20084 ""
	    c1omget_1.isheadr = FALSE_;
#line 20085 ""
	    isysb4 = isysendpg;
#line 20086 ""
/* L7: */
#line 20086 ""
	}
#line 20087 ""
/* L8: */
#line 20087 ""
    }

/*  Done with vertical, now do horizontals */

#line 20091 ""
    celsk[1] = elsk[0];
#line 20092 ""
    i__1 = c1omnotes_1.ibarcnt;
#line 20092 ""
    for (a1ll_2.ibar = 2; a1ll_2.ibar <= i__1; ++a1ll_2.ibar) {
#line 20093 ""
	celsk[a1ll_2.ibar] = celsk[a1ll_2.ibar - 1] + elsk[a1ll_2.ibar - 1];
#line 20094 ""
/* L21: */
#line 20094 ""
    }
#line 20095 ""
    lastbar[0] = 0;
#line 20096 ""
    ibar1 = 1;
#line 20097 ""
    wmins = -1.f;
#line 20098 ""
    iflb = 1;
#line 20099 ""
    imovbrk = 0;
#line 20100 ""
    ikey = 1;

/*  Return nsyst to its *total* value */

#line 20104 ""
    compage_1.nsyst = compage_1.isysfpb[compage_1.nfpb] - 1;
#line 20105 ""
    i__1 = compage_1.nsyst;
#line 20105 ""
    for (isyst = 1; isyst <= i__1; ++isyst) {
#line 20106 ""
	if (isyst == compage_1.isysflb[iflb]) {
#line 20106 ""
	    ++iflb;
#line 20106 ""
	}
#line 20107 ""
	if (compage_1.nmovbrk > 0 && imovbrk < compage_1.nmovbrk) {
#line 20108 ""
	    if (isyst == compage_1.isysmb[imovbrk + 1]) {
#line 20108 ""
		++imovbrk;
#line 20108 ""
	    }
#line 20109 ""
	}
#line 20110 ""
	ibarb4 = lastbar[isyst - 1];
#line 20111 ""
	if (isyst == 1) {
#line 20112 ""
	    if (*isfirst) {
#line 20112 ""
		elsstarg = celsk[compage_1.ibarflb[1] - 1] / (
			compage_1.isysflb[1] - 1 - c1omget_1.fracindent) * (1 
			- c1omget_1.fracindent);
#line 20112 ""
	    }
#line 20114 ""
	    celskb4 = 0.f;
#line 20115 ""
	} else {
#line 20116 ""
	    celskb4 = celsk[ibarb4];

/*  Must dimension isysmb(0:*) just so I can execute this test! */

#line 20120 ""
	    if (*isfirst) {
#line 20121 ""
		if (compage_1.nmovbrk > 0 && isyst == compage_1.isysmb[
			imovbrk]) {

/*  First syst after forced line break.  There may be indentation. */

#line 20125 ""
		    elsstarg = (celsk[compage_1.ibarflb[iflb] - 1] - celskb4) 
			    / (compage_1.isysflb[iflb] - isyst - 
			    compage_1.fracsys[imovbrk - 1]) * (1 - 
			    compage_1.fracsys[imovbrk - 1]);
#line 20128 ""
		} else {

/*  There is no indentation to deal with */

#line 20132 ""
		    elsstarg = (celsk[compage_1.ibarflb[iflb] - 1] - celskb4) 
			    / (compage_1.isysflb[iflb] - isyst);
#line 20134 ""
		}
#line 20135 ""
	    }
#line 20136 ""
	}
#line 20137 ""
	if (*isfirst) {
#line 20138 ""
	    diff1 = (r__1 = elsstarg - elsk[ibarb4], dabs(r__1));
#line 20139 ""
	    i__2 = c1omnotes_1.ibarcnt;
#line 20139 ""
	    for (a1ll_2.ibar = ibarb4 + 2; a1ll_2.ibar <= i__2; ++a1ll_2.ibar)
		     {
#line 20140 ""
		diff = elsstarg - (celsk[a1ll_2.ibar] - celskb4);
#line 20141 ""
		if (dabs(diff) >= diff1) {
#line 20141 ""
		    goto L24;
#line 20141 ""
		}
#line 20142 ""
		diff1 = dabs(diff);
#line 20143 ""
/* L23: */
#line 20143 ""
	    }
#line 20144 ""
L24:
#line 20144 ""
	    --a1ll_2.ibar;
#line 20145 ""
	    lastbar[isyst] = a1ll_2.ibar;
#line 20146 ""
	    nbarss[isyst] = a1ll_2.ibar - ibarb4;
#line 20147 ""
	} else {

/*  nbarss is given as an input, must compute lastbar and ibar */

#line 20151 ""
	    lastbar[isyst] = nbarss[isyst] + ibarb4;
#line 20152 ""
	    a1ll_2.ibar = lastbar[isyst];
#line 20153 ""
	}

/*  elss is # of elemskip in the syst. from notes & ars's, not ruleskips, ask's. */

#line 20157 ""
	elss[isyst - 1] = celsk[a1ll_2.ibar] - celskb4;
#line 20158 ""
	s_wsfe(&io___1299);
#line 20158 ""
	i__2 = lastbar[isyst - 1] + 1;
#line 20158 ""
	do_fio(&c__1, (char *)&i__2, (ftnlen)sizeof(integer));
#line 20158 ""
	e_wsfe();

/*  Transposed sigs are isig1, newkey(2,3,...). */

#line 20162 ""
	if (ikey == 1) {
#line 20163 ""
	    key1 = comkeys_1.isig1;
#line 20164 ""
	} else {
#line 20165 ""
	    key1 = comkeys_1.newkey[ikey - 1];
#line 20166 ""
	}
#line 20167 ""
	fsyst = wclef + abs(key1) * wkeysig + 2.f / commus_1.musize;
#line 20168 ""
	xelsk = 0.f;
#line 20169 ""
L1:
#line 20169 ""
	if (ikey < comkeys_1.nkeys) {
#line 20170 ""
	    if (comkeys_1.ibrkch[ikey] <= lastbar[isyst]) {

/*  Add space for all key changes */

#line 20174 ""
		++ikey;
#line 20175 ""
		key2 = comkeys_1.newkey[ikey - 1];
/* Computing MAX */
/* Computing MAX */
#line 20176 ""
		i__5 = abs(key1), i__6 = abs(key2);
#line 20176 ""
		i__3 = (i__2 = key2 - key1, abs(i__2)), i__4 = max(i__5,i__6);
#line 20176 ""
		naccs = max(i__3,i__4);
#line 20177 ""
		fsyst += naccs * wkeysig;

/*  Account for afterruleskips (fbar) */

#line 20181 ""
		xelsk += c1ommvl_1.fbar / 2;
#line 20182 ""
		if (comkeys_1.ibrkch[ikey - 1] < lastbar[isyst] && ! 
			comkeys_1.kchmid[ikey - 1]) {
#line 20182 ""
		    xelsk += -1.f;
#line 20182 ""
		}
#line 20184 ""
		key1 = key2;
#line 20185 ""
		goto L1;
#line 20186 ""
	    }
#line 20187 ""
	}

/*  Add extra fixed space for double bar */

#line 20191 ""
	if (isyst == compage_1.nsyst) {
#line 20192 ""
	    fsyst += 4.5f / commus_1.musize;
#line 20193 ""
	}

/*  Add extra fixed space for initial time signature */

#line 20197 ""
	if (isyst == 1) {
#line 20198 ""
	    fsyst += wtimesig;
#line 20199 ""
	}

/*  Add extra fixed space for time signature changes & user-defined spaces */

#line 20203 ""
	i__2 = lastbar[isyst];
#line 20203 ""
	for (ibars = ibarb4 + 1; ibars <= i__2; ++ibars) {
#line 20204 ""
	    if (newmb[ibars - 1]) {
#line 20204 ""
		fsyst += wtimesig;
#line 20204 ""
	    }
#line 20205 ""
	    fsyst += c1omnotes_1.udsp[ibars - 1] / commus_1.musize;
#line 20206 ""
/* L26: */
#line 20206 ""
	}
#line 20207 ""
	if (isyst == 1) {
#line 20208 ""
	    wdpt = compage_1.widthpt * (1 - c1omget_1.fracindent);
#line 20209 ""
	} else {
#line 20210 ""
	    if (compage_1.nmovbrk > 0 && imovbrk > 0 && isyst == 
		    compage_1.isysmb[imovbrk]) {
#line 20212 ""
		wdpt = compage_1.widthpt * (1 - compage_1.fracsys[imovbrk - 1]
			);
#line 20213 ""
	    } else {
#line 20214 ""
		wdpt = compage_1.widthpt;
#line 20215 ""
	    }
#line 20216 ""
	}
#line 20217 ""
	wsyspt = wdpt - fsyst * commus_1.musize - nbarss[isyst] * .4f;

/*  Checks for min spacing */
/*  Get min allowable space */

#line 20222 ""
	dtmin = 1e3f;
#line 20223 ""
	i__2 = ibar1 + nbarss[isyst] - 1;
#line 20223 ""
	for (a1ll_2.ibar = ibar1; a1ll_2.ibar <= i__2; ++a1ll_2.ibar) {
/* Computing MIN */
#line 20224 ""
	    r__1 = dtmin, r__2 = linecom_1.tnminb[a1ll_2.ibar - 1];
#line 20224 ""
	    dtmin = dmin(r__1,r__2);
#line 20225 ""
	    if (c1omnotes_1.wminnh[a1ll_2.ibar - 1] >= 0.f) {
#line 20225 ""
		wmins = c1omnotes_1.wminnh[a1ll_2.ibar - 1];
#line 20225 ""
	    }
#line 20226 ""
/* L45: */
#line 20226 ""
	}
#line 20227 ""
	if (wmins < 0.f) {
#line 20227 ""
	    wmins = .3f;
#line 20227 ""
	}
#line 20228 ""
	wminpt = (wmins + 1) * .3f * commus_1.musize;

/*  Find max duration & # of notes for this system */

#line 20232 ""
	dtmax = 0.f;
#line 20233 ""
	nns = 0;
#line 20234 ""
	i__2 = c1omnotes_1.nptr[ibar1 + nbarss[isyst] - 1] - 1;
#line 20234 ""
	for (iptr = c1omnotes_1.nptr[ibar1 - 1]; iptr <= i__2; ++iptr) {
/* Computing MAX */
#line 20235 ""
	    r__1 = dtmax, r__2 = c1omnotes_1.durb[iptr - 1];
#line 20235 ""
	    dtmax = dmax(r__1,r__2);
#line 20236 ""
	    nns += c1omnotes_1.nnpd[iptr - 1];
#line 20237 ""
/* L43: */
#line 20237 ""
	}
#line 20238 ""
	elmin0 = wsyspt * f1eon_(&dtmin) / (elss[isyst - 1] + xelsk);
#line 20239 ""
	if (elmin0 >= wminpt) {

/*  Subtract out fbar stuff to keep old way of passing sumelsk to pmxb; */
/*    there is no need to "flatten" */

#line 20244 ""
	    sumelsk = elss[isyst - 1] - c1ommvl_1.fbar * nbarss[isyst];
#line 20245 ""
	    comeon_1.eonk = 0.f;
#line 20246 ""
	    comeon_1.ewmxk = 1.f;
#line 20247 ""
	} else {
#line 20248 ""
	    elmin1 = wsyspt / ((c1ommvl_1.fbar * nbarss[isyst] + xelsk) / 
		    f1eon_(&dtmax) + nns);
#line 20249 ""
	    if (elmin1 <= wminpt) {
#line 20250 ""
		comeon_1.eonk = .9f;
#line 20251 ""
	    } else {

/*  Find eonk by Newton method */

#line 20255 ""
		i__2 = c1omnotes_1.nptr[ibar1 + nbarss[isyst] - 1] - 1;
#line 20255 ""
		r__1 = wsyspt / wminpt;
#line 20255 ""
		r__2 = c1ommvl_1.fbar * nbarss[isyst] + xelsk;
#line 20255 ""
		r__3 = (wminpt - elmin0) / (elmin1 - elmin0);
#line 20255 ""
		findeonk_(&c1omnotes_1.nptr[ibar1 - 1], &i__2, &r__1, &r__2, &
			dtmin, &dtmax, &r__3);
#line 20258 ""
		comeon_1.eonk = dmin(.9f,comeon_1.eonk);
#line 20259 ""
	    }
#line 20260 ""
	    d__1 = (doublereal) f1eon_(&dtmax);
#line 20260 ""
	    d__2 = (doublereal) comeon_1.eonk;
#line 20260 ""
	    comeon_1.ewmxk = pow_dd(&d__1, &d__2);

/*  Recompute poenom! */

#line 20264 ""
	    sumelsk = 0.f;
#line 20265 ""
	    i__2 = c1omnotes_1.nptr[ibar1 + nbarss[isyst] - 1] - 1;
#line 20265 ""
	    for (iptr = c1omnotes_1.nptr[ibar1 - 1]; iptr <= i__2; ++iptr) {
#line 20266 ""
		r__1 = c1omnotes_1.durb[iptr - 1] / c1omnotes_1.sqzb[iptr - 1]
			;
#line 20266 ""
		sumelsk += c1omnotes_1.nnpd[iptr - 1] * c1omnotes_1.sqzb[iptr 
			- 1] * feon_(&r__1);
#line 20268 ""
/* L44: */
#line 20268 ""
	    }
#line 20269 ""
	}
#line 20270 ""
	poenom = wsyspt / (sumelsk + c1ommvl_1.fbar * nbarss[isyst] + xelsk);

/* Set fracindent for output: orig if isyst=1, fracsys(imovbrk) if movbrk, else 0 */

#line 20274 ""
	if (isyst > 0) {
#line 20275 ""
	    if (compage_1.nmovbrk > 0 && imovbrk > 0 && isyst == 
		    compage_1.isysmb[imovbrk]) {
#line 20277 ""
		c1omget_1.fracindent = compage_1.fracsys[imovbrk - 1];
#line 20278 ""
	    } else {
#line 20279 ""
		c1omget_1.fracindent = 0.f;
#line 20280 ""
	    }
#line 20281 ""
	}
#line 20282 ""
	s_wsfe(&io___1317);
#line 20282 ""
	do_fio(&c__1, (char *)&poenom, (ftnlen)sizeof(real));
#line 20282 ""
	do_fio(&c__1, (char *)&nbarss[isyst], (ftnlen)sizeof(integer));
#line 20282 ""
	do_fio(&c__1, (char *)&sumelsk, (ftnlen)sizeof(real));
#line 20282 ""
	do_fio(&c__1, (char *)&fsyst, (ftnlen)sizeof(real));
#line 20282 ""
	do_fio(&c__1, (char *)&c1omget_1.fracindent, (ftnlen)sizeof(real));
#line 20282 ""
	do_fio(&c__1, (char *)&comeon_1.eonk, (ftnlen)sizeof(real));
#line 20282 ""
	do_fio(&c__1, (char *)&comeon_1.ewmxk, (ftnlen)sizeof(real));
#line 20282 ""
	e_wsfe();
#line 20284 ""
	ibar1 += nbarss[isyst];
#line 20285 ""
/* L22: */
#line 20285 ""
    }
#line 20286 ""
    al__1.aerr = 0;
#line 20286 ""
    al__1.aunit = 12;
#line 20286 ""
    f_rew(&al__1);
#line 20287 ""
    o__1.oerr = 0;
#line 20287 ""
    o__1.ounit = 13;
#line 20287 ""
    o__1.ofnm = 0;
#line 20287 ""
    o__1.orl = 0;
#line 20287 ""
    o__1.osta = "SCRATCH";
#line 20287 ""
    o__1.oacc = 0;
#line 20287 ""
    o__1.ofm = 0;
#line 20287 ""
    o__1.oblnk = 0;
#line 20287 ""
    f_open(&o__1);
#line 20288 ""
    s_wsfe(&io___1318);
#line 20288 ""
    do_fio(&c__1, (char *)&ifig, (ftnlen)sizeof(integer));
#line 20288 ""
    e_wsfe();
#line 20289 ""
    al__1.aerr = 0;
#line 20289 ""
    al__1.aunit = 13;
#line 20289 ""
    f_rew(&al__1);
#line 20290 ""
    inbuff_1.ilbuf = 1;
#line 20291 ""
    inbuff_1.ipbuf = 0;
#line 20292 ""
    if (! (*optimize)) {
#line 20293 ""
	s_wsfe(&io___1319);
#line 20293 ""
	do_fio(&c__1, " Done with first pass", (ftnlen)21);
#line 20293 ""
	e_wsfe();
#line 20294 ""
	s_wsle(&io___1320);
#line 20294 ""
	e_wsle();
#line 20295 ""
	s_wsfe(&io___1321);
#line 20295 ""
	do_fio(&c__1, " Done with first pass", (ftnlen)21);
#line 20295 ""
	e_wsfe();
#line 20296 ""
	s_wsfe(&io___1322);
#line 20296 ""
	e_wsfe();
#line 20297 ""
    }

/*  Following syntax is needed since pmxa is called with literal argument .false. */

#line 20301 ""
    if (*isfirst) {
#line 20301 ""
	*isfirst = FALSE_;
#line 20301 ""
    }
#line 20302 ""
    return 0;
} /* pmxa_ */

/* Subroutine */ int pmxb_(logical *inlast, real *poevec, integer *ncalls, 
	logical *optimize)
{
    /* System generated locals */
    address a__1[12], a__2[6], a__3[4], a__4[2], a__5[3], a__6[10], a__7[9], 
	    a__8[2], a__9[5], a__10[8], a__11[7], a__12[11], a__13[14];
    integer i__1, i__2, i__3[12], i__4[6], i__5[4], i__6[2], i__7, i__8[3], 
	    i__9[10], i__10[9], i__11[2], i__12[5], i__13, i__14[8], i__15[7],
	     i__16[11], i__17[14];
    real r__1, r__2;
    char ch__1[1], ch__2[46], ch__3[23], ch__4[26], ch__5[27], ch__6[20], 
	    ch__7[29], ch__8[8], ch__9[35], ch__10[14], ch__11[19], ch__12[
	    107], ch__13[17], ch__14[12], ch__15[11], ch__16[15], ch__17[13], 
	    ch__18[9], ch__19[32], ch__20[10], ch__21[4], ch__22[16], ch__23[
	    40], ch__24[24], ch__25[6], ch__26[18], ch__27[82], ch__28[66], 
	    ch__29[60], ch__30[45], ch__31[28], ch__32[11], ch__33[76], 
	    ch__34[38], ch__35[33], ch__36[43], ch__37[69], ch__38[41], 
	    ch__39[44], ch__40[5], ch__41[7], ch__42[25], ch__43[22], ch__44[
	    96];
    cilist ci__1;
    icilist ici__1;
    olist o__1;
    cllist cl__1;
    alist al__1;

    /* Builtin functions */
    integer s_wsle(cilist *), e_wsle(void), do_lio(integer *, integer *, char 
	    *, ftnlen), s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), 
	    e_wsfe(void), s_rsfe(cilist *), e_rsfe(void), s_rsle(cilist *), 
	    e_rsle(void);
    double r_mod(real *, real *);
    integer i_nint(real *), pow_ii(integer *, integer *), f_open(olist *);
    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
    double r_lg10(real *);
    integer i_indx(char *, char *, ftnlen, ftnlen);
    double r_dim(real *, real *);
    integer i_dim(integer *, integer *);
    /* Subroutine */ int s_copy(char *, char *, ftnlen, ftnlen);
    integer s_wsfi(icilist *), e_wsfi(void), lbit_shift(integer, integer), 
	    f_clos(cllist *), f_rew(alist *);

    /* Local variables */
    extern /* Subroutine */ int outbar_(integer *, integer *);
    static real ptsndb, ptsndv, ptsdflt;
    extern /* Subroutine */ int clefsym_(integer *, char *, integer *, 
	    integer *, ftnlen), wsclef_(integer *, integer *, integer *);
    static integer nvalue, islnow, iplnow, lvoltxt;
    static real fsyst;
    static integer nbarss;
    static real elsktot;
    static integer ndigbn, isdat;
    extern integer ncmid_(integer *, integer *);
    static integer indsym;
    extern /* Subroutine */ int wgmeter_(integer *, integer *), writesetsign_(
	    integer *, integer *, integer *, logical *);
    static integer mtrnms, ibarcnt0, lntmp;
    static real xnstbot;
    static integer iptemp, naccs, islide, ipnew, iudorn, iflagbot, idynd;
    extern /* Subroutine */ int setbits_(integer *, integer *, integer *, 
	    integer *);
    static real xmtrnum0;
    static integer itxtdyn, isdata, iarps;
    extern /* Subroutine */ int make1bar_(integer *, real *, real *, logical *
	    , real *, integer *, integer *, integer *), make2bar_(integer *, 
	    real *, real *, logical *, real *, integer *, integer *, integer *
	    , char *, ftnlen);
    static real hardb4;
    extern /* Subroutine */ int askfig_(char *, integer *, char *, integer *, 
	    logical *, logical *, ftnlen, ftnlen);
    extern integer igetbits_(integer *, integer *, integer *);
    extern /* Subroutine */ int newvoice_(integer *, char *, logical *, 
	    ftnlen);
    static logical lrptpend;
    extern /* Subroutine */ int setmeter_(integer *, integer *, integer *, 
	    integer *), puttitle_(integer *, real *, real *, char *, real *, 
	    real *, real *, integer *, logical *, char *, ftnlen, ftnlen);
    static integer i__;
    static char basenameq[44], pathnameq[40];
    extern /* Subroutine */ int midievent_(char *, integer *, integer *, 
	    ftnlen);
    static real xintstaff[75];
    static char shortfraq[3];
    static integer ia, ig, il, ip, it, kv, ip2, iv1, ibc, icc, ipa, ipi;
    static real esk;
    static char nmq[40];
    static integer iiv;
    static real poe, frac;
    static integer ifig, ndig;
    extern /* Character */ VOID chax_(char *, ftnlen, integer *);
    static real hesk[23];
    static integer ioff;
    static char fmtq[24];
    static logical loop;
    static real hpts[23];
    extern doublereal feon_(real *);
    static logical lrpt;
    static real wdpt;
    static logical rrpt;
    static integer lnmq, ntmp, icrd, idyn, jfig;
    static real tglp1;
    extern /* Subroutine */ int stop1_(void);
    static logical clchb;
    static integer lbase, lclef;
    static char charq[1];
    static logical clchv[24], slint;
    static integer istop[80];
    static real squez[80];
    static logical ismbr;
    static char rendq[3];
    static real etait, etatc, etacs1;
    static integer nsyst, lpath, iauto;
    static real slfac1;
    static integer lnote, nclef, iinst, ipnow;
    extern /* Subroutine */ int linebreakties_(integer *, integer *, integer *
	    , integer *, integer *, logical *, char *, ftnlen);
    static logical evolta;
    static integer numbms[24], istart[80];
    static logical cwrest[24], svolta;
    static char notexq[79];
    static logical onvolt;
    static real tstart[80];
    static logical putmbr, istype0;
    static real etatop, etabot;
    static integer inhnoh;
    extern /* Subroutine */ int getset_(integer *, integer *, integer *, 
	    integer *, integer *, integer *, real *, integer *, integer *, 
	    integer *, real *, logical *, char *, char *, char *, char *, 
	    integer *, integer *, ftnlen, ftnlen, ftnlen, ftnlen);
    static integer noinst, npages, ibcoff;
    static logical newclef;
    static integer lenbeat;
    extern /* Subroutine */ int topfile_(char *, integer *, integer *, char *,
	     integer *, integer *, real *, integer *, integer *, logical *, 
	    real *, logical *, ftnlen, ftnlen);
    static logical ispstie, vshrink;
    static integer isyscnt;
    static real xntrial;
    extern integer ifnodur_(integer *, char *, ftnlen);
    static integer ibmrep, isystpg, nhstot, jprntb, nhssys;
    extern /* Subroutine */ int getnote_(logical *);
    static real xnsttop[75];
    extern /* Subroutine */ int addmidi_(integer *, integer *, integer *, 
	    integer *, real *, logical *, logical *);

    /* Fortran I/O blocks */
    static cilist io___1323 = { 0, 6, 0, 0, 0 };
    static cilist io___1324 = { 0, 6, 0, 0, 0 };
    static cilist io___1325 = { 0, 6, 0, 0, 0 };
    static cilist io___1326 = { 0, 15, 0, "(a)", 0 };
    static cilist io___1330 = { 0, 12, 0, "(a)", 0 };
    static cilist io___1332 = { 0, 12, 0, 0, 0 };
    static cilist io___1334 = { 0, 12, 0, 0, 0 };
    static cilist io___1350 = { 0, 6, 0, 0, 0 };
    static cilist io___1351 = { 0, 12, 0, 0, 0 };
    static cilist io___1357 = { 0, 13, 0, 0, 0 };
    static cilist io___1359 = { 0, 14, 0, "(a)", 0 };
    static cilist io___1362 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1363 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1364 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1367 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1378 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1380 = { 0, 6, 0, "(/,a20,i4,a1,i4)", 0 };
    static cilist io___1381 = { 0, 15, 0, "(/,a20,i4,a1,i4)", 0 };
    static cilist io___1385 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1386 = { 0, 11, 0, "(a14,f4.1,a)", 0 };
    static cilist io___1395 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1404 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1407 = { 0, 6, 0, 0, 0 };
    static cilist io___1408 = { 0, 6, 0, 0, 0 };
    static cilist io___1409 = { 0, 11, 0, "(a20,i1,a)", 0 };
    static cilist io___1410 = { 0, 11, 0, "(a20,i2,a)", 0 };
    static cilist io___1411 = { 0, 11, 0, "(a20)", 0 };
    static cilist io___1412 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1414 = { 0, 11, 0, "(a11,i2,a2)", 0 };
    static cilist io___1415 = { 0, 11, 0, "(a11,i1,a2)", 0 };
    static cilist io___1416 = { 0, 12, 0, 0, 0 };
    static cilist io___1419 = { 0, 6, 0, 0, 0 };
    static cilist io___1420 = { 0, 6, 0, 0, 0 };
    static cilist io___1423 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1424 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1425 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1426 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1427 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1428 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1431 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1432 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1434 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1435 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1444 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1445 = { 0, 12, 0, 0, 0 };
    static cilist io___1447 = { 0, 14, 0, "(a9,i2,a10,i2,1x,a4)", 0 };
    static cilist io___1450 = { 0, 11, 0, fmtq, 0 };
    static cilist io___1452 = { 0, 6, 0, 0, 0 };
    static cilist io___1453 = { 0, 6, 0, 0, 0 };
    static cilist io___1454 = { 0, 11, 0, "(a)", 0 };
    static icilist io___1457 = { 0, nmq+12, 0, "(2i1)", 2, 1 };
    static icilist io___1458 = { 0, nmq+12, 0, "(a1,i2,a1,i1)", 5, 1 };
    static cilist io___1459 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1460 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1461 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1462 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1463 = { 0, 11, 0, "(a6,i2,a11)", 0 };
    static cilist io___1464 = { 0, 11, 0, "(a6,i1,a11)", 0 };
    static cilist io___1465 = { 0, 11, 0, "(a8,i1,a3)", 0 };
    static cilist io___1466 = { 0, 11, 0, "(a9,i2,a4)", 0 };
    static cilist io___1467 = { 0, 11, 0, "(a18,i1,a2)", 0 };
    static cilist io___1468 = { 0, 11, 0, "(a18,i2,a2)", 0 };
    static cilist io___1470 = { 0, 11, 0, "(a11,i1,a2)", 0 };
    static cilist io___1471 = { 0, 11, 0, "(a11,i2,a2)", 0 };
    static cilist io___1472 = { 0, 11, 0, "(a11,i3,a2)", 0 };
    static cilist io___1473 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1474 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1476 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1477 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1478 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1479 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1480 = { 0, 11, 0, "(a)", 0 };
    static icilist io___1485 = { 0, shortfraq, 0, "(i2)", 2, 1 };
    static cilist io___1486 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1487 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1488 = { 0, 11, 0, fmtq, 0 };
    static cilist io___1490 = { 0, 11, 0, fmtq, 0 };
    static cilist io___1491 = { 0, 11, 0, fmtq, 0 };
    static cilist io___1492 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1493 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1494 = { 0, 11, 0, fmtq, 0 };
    static cilist io___1495 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1496 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1497 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1498 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1499 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1500 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1501 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1502 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1503 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1504 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1505 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1506 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1507 = { 0, 11, 0, "(a)", 0 };
    static icilist io___1508 = { 0, shortfraq, 0, "(f3.2)", 3, 1 };
    static cilist io___1509 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1510 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1511 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1512 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1513 = { 0, 11, 0, "(a)", 0 };
    static icilist io___1514 = { 0, shortfraq, 0, "(i2)", 2, 1 };
    static cilist io___1515 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1516 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1517 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1518 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1519 = { 0, 11, 0, "(a)", 0 };
    static icilist io___1520 = { 0, shortfraq, 0, "(f3.2)", 3, 1 };
    static cilist io___1521 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1522 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1523 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1524 = { 0, 11, 0, "(a)", 0 };
    static icilist io___1525 = { 0, shortfraq, 0, "(i2)", 2, 1 };
    static cilist io___1526 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1527 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1528 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1529 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1530 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1531 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1532 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1533 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1534 = { 0, 11, 0, "(a16,i1,a14)", 0 };
    static cilist io___1535 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1536 = { 0, 12, 1, 0, 0 };
    static cilist io___1539 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1540 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1541 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1543 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1544 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1545 = { 0, 11, 0, "(a)", 0 };
    static icilist io___1546 = { 0, shortfraq, 0, "(i2)", 2, 1 };
    static cilist io___1547 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1548 = { 0, 11, 0, "(a)", 0 };
    static icilist io___1549 = { 0, shortfraq, 0, "(f3.2)", 3, 1 };
    static cilist io___1550 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1551 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1552 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1553 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1554 = { 0, 11, 0, "(a,2i1,a)", 0 };
    static cilist io___1555 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1556 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1572 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1573 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1581 = { 0, 11, 0, "(a11,f5.1,a4)", 0 };
    static cilist io___1582 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1584 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1585 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1586 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1587 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1588 = { 0, 6, 0, 0, 0 };
    static cilist io___1589 = { 0, 6, 0, 0, 0 };
    static cilist io___1590 = { 0, 15, 0, 0, 0 };
    static cilist io___1591 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1592 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1593 = { 0, 11, 0, fmtq, 0 };
    static cilist io___1594 = { 0, 11, 0, fmtq, 0 };
    static cilist io___1595 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1596 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1597 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1598 = { 0, 14, 0, "(a9,i2,a10,i2,1x,a5)", 0 };
    static cilist io___1599 = { 0, 6, 0, 0, 0 };
    static cilist io___1600 = { 0, 6, 0, 0, 0 };
    static cilist io___1601 = { 0, 6, 0, 0, 0 };
    static cilist io___1602 = { 0, 15, 0, "(/,a)", 0 };
    static cilist io___1603 = { 0, 15, 0, "(a)", 0 };


/* ccccccccccccccccccccccccc */
/* c */
/* c To Do */
/* c */
/* c  Resolve disagreement in final poe for 1st system, compared with *.mx2 */
/* c  Shift slurs on right- or left-shifted main notes (2/7/99) */
/* c  Various end-of-input-block repeat problems (ick142.pmx). */
/* c  Force multiplicity for un-beamed xtups. */
/* c  Clef change at end of piece */
/* c  Global "A" option to maximize "X" at a given time tick. */
/* c  Tighten test for end-of-bar hardspace, flgndv(ivx) due to right-shifted */
/* c       note.  See trubl18.pmx */
/* c  Tab character as space. */
/* c  Clef interference with second line of music. */
/* c  Add space for interferences between *different* lines of music? */
/* c  Shift arpeggios, both automatic and manual. */
/* c  Different musicsize for different instruments. */
/* c  Spacing checks for accid's on left-shifted chord notes */
/* c  Spacing checks for double dots */
/* c  Allow forced line breaks w/o setting nsyst. */
/* c  Cresc-Decresc. (Enhance MusiXTeX first?) */
/* c  Dynamic Marks. */
/* c  Bug with Voltas at line end (MusiXTeX problem?). */
/* c  Subtle bug w/ slur hgt over line brk, see trubl15.pmx */
/* c  Stem-end slurs. */
/* c  Allow units in indentation. */
/* c  Make inline TeX more context sensitive. */
/* c  Werner's 4/2/98 problem with "o?" */
/* c  Scor2prt converts e.g. "r0+0" into "r0 0", which seems to be wrong. */
/* c    converts e.g. "r2db" into "r2d", which might be wrong. */
/* c  Werner's generalsignature problem with Key change and new transposition. */
/* c    (wibug8.pmx) */
/* c  Unequal xtuplets */
/* c  Print both sets of bar #'s in tex file. */
/* c  Make barlines invisible \def\xbar{\empty} , fix fbar. */
/* c  Auto-tie slurs  'At' */
/* c  Forced line break anywhere (e.g. at a mid-bar repeat). */
/* c  Clef change at very start of file. */
/* c  Tighten test for M as macro terminator. */
/* c  Fix title so not separate limit on author length + composer length. */
/* c  Arpeggios in xtups. */
/* c */
/* c mx10b */
/* c  Option for instrument name at top center. Last item in P command: */
/* c    P[n]c         text is instrument name (use in parts) */
/* c    P[n]cstuff    text is stuff (up to 1st blank) */
/* c    P[n]c"stuff with spaces"   text is stuff with spaces */
/* c */
/* c Post version 1.43 */
/* c  Reduced space rqmt for multiplicity-0 graces (no flag) */
/* c  Removed last sepsym in centered whole-bar rests, fixes volta height bug. */
/* c */
/* c Version 1.43 */
/* c  Fix spacing for end-of-line signature change. */
/* c  Adjust left-shift of grace group for shifted accidentals. */
/* c  Put in extra space for left-shifted accidentals. */
/* c  Fix bug with dot-shift before accid-shift on chord note. */
/* c  Space-check for right-shifted main notes. */
/* c  Enable forcing stem direction of single notes in non-beamed xtups. */
/* c  Disallow clef change after last note before end of input block (pmxa) */
/* c  Print meter change before page break */
/* c  increase length of strings for \titles macro */
/* c version 1.42 */
/* c  Loosen up input syntax for "X" commands.  Subroutine getx() */
/* c  "B" and "P" in "X" commands */
/* c mx09b */
/* c  Allow multiple rests at start of xtup */
/* c  Add 64th rest */
/* c  Fix xtup numbers over rests. (subroutine levrn) */
/* c  Initialize notcrd=.false. every gulp. Avoids undefined state with e.g. */
/* c    c za / ( c a ... */
/* c  Allow double dots to be shifted. */
/* c  Fix spacing with double dotted notes; permit splitting small note. */
/* c  Fix \dotted printout so it works with old compiler */
/* c mx08b */
/* c  Automatic spaces if needed for shifted accidentals. */
/* c  Some Dynamics */
/* c  Increase accid. horiz. shift resolution to .o5 (use one more bit in nacc) */
/* c version 1.41 */
/* c  Allow ":" as last char of path name */
/* c  Dotted slurs "sb" */
/* c  Continue bar numbering at movement break "L[integer]Mc" */
/* c mx07b */
/* c  Whole-bar rests with double lines of music.  Fixed all options ? */
/* c  Shift accidentals, either [+|-][integer][+|-][number] or [<|>][number]. */
/* c  Option to suppress centering full-bar rests. "o" */
/* c mx06b */
/* c  Shift accid on left-shifted chord note. */
/* c  Rest as first note of xtup. */
/* c  Wrong slopes with small widths.  Scale slfac1 by widthpt_default/widthpt */
/* c  Allow Rb for single bar at movemnet break or end of piece. (islur(25)) */
/* c  Change # of inst at a movement break.  noinst is total # and must be used */
/* c    in 1st movement.  ninow is current.  nspern(1,...,ninow) is current */
/* c    staves/inst, nsperi(1,...,noinst) is original.  rename tells whether to */
/* c    reprint names in parindent at a movement break.  Default is .false. */
/* c    unless ninow changes, then .true.  But can force either with r+/- as */
/* c    option in 'M' */
/* c mx04b */
/* c  Double-dotted notes, separate+beamed, main+chord, still no extra space. */
/* c  ???  Don't shift slur ends on whole notes. */
/* c  (pmxa) Write line number of error in pmxaerr.dat */
/* c mx02b */
/* c  Admit "RD" before "/" (search for "rptfq2:" ) */
/* c  In doslur, for multi-line staves, single notes, check forced stem dir'n */
/* c    before setting stemup (used to set horiz offset). */
/* cccccccccccccccccccccccccccccc */

/*  FYI /all/ differs in appearance in function ncmid */

/* cccccccccccc */
/* c  islur  cc */
/* cccccccccccc */
/*  bit  meaning */
/*  0     slur activity on this note */
/*  1     t-slur here. */
/*  2     force 0-slope beam starting on this note */
/*  3     Double dotted note! */
/*  4     grace before main note */
/*  5     left repeat */
/*  6     right repeat */
/*  7     start Volta */
/*  8     doublebar */
/*  9     end Volta */
/*  10    on=>endvoltabox */
/*  11    on=>clefchange */
/*  12-14 0=>treble, ... , 6=>bass */
/*  15    on=> start new block for clef change (maybe diff. voice) */
/*  16    literal TeX string */
/*  17    1=up, 0=down stem for single note (override) See bit 30! */
/*  18    if on, prohibit beaming */
/*  19    if on, full bar rest as pause */
/*  20    Beam multiplicity down-up */
/*  21    Forced multiplicity for any beam including xtups */
/*  22-24 Value of forced multiplicity */
/*  25    single barline at movement break */
/*  26    doubleBAR (see bits 5,6,8) */
/*  27-28 Forced beam fine-tune height (1 to 3) */
/*  29    Blank rest */
/*  30    If on, get stem dir'n from bit 17 */
/*  31    If on, suppress printing number with xtuplet starting here */
/* cccccccccccc */
/* c  ipl    cc */
/* cccccccccccc */
/*  0     blank barline (must be iv=1) (would have used islur but no room) */
/*  1     look left for K rests, moved here from iornq(30) */
/*  2     treblelowoct */
/*  3     Open notehead in forced beam xtup */
/*  4     Set if single stem tremolo */
/*  5-6   termulo multiplicity - 1 */
/*  7 unused */
/*  8     left offset main note one headwidth */
/*  9     right offset main note one headwidth */
/*  10    chord present? */
/*  11-16 Forced beam height adjustment (-30 to +30) */
/*  17-22 Forced beam slope adjustment (-30 to +30) */
/*  23-26 Slur index for Way-after grace.  Inserted when slur is started. */
/*  27 5th bit for slur index for Way-after grace (100712) */
/*  28    key change: only in voice 1 */
/*  29    Grace after main note. (Type A) */
/*  30    In forced beam.  Signals need to check beam heights */
/*  31    Grace way after main note. (stretch to next note, type W) */
/* cccccccccccc */
/* c  iornq  cc */
/* cccccccccccc */
/*  0     Ornament "(".  Was user-defined horizontal slur shift on this note */
/*               until 9/24/97; changed that to irest(21) */
/*  1-13  stmgx+Tupf._) */
/*  14    Down fermata, was F */
/*  15    Trill w/o "tr", was U */
/*  16-18 Editorial s,f,n */
/*  19-20 >^ */
/*  21    "?" for editorial accid, w/ or w/o s,f,n */
/*  22    Set if ihornb governs ornament height.  Same in icrdorn. */
/*  23    Set in getorn if ANY note at time of this main note has ornament. */
/*             This is ONLY used in beamstrt to signal whether to do more */
/*             tests for whether ihornb is needed.  (ihornb is only needed */
/*             if nonchord+upbm, chord+upbm+top_note, chord+dnbm+bot_note) */
/*     (7/1/00)Also set if any dynamic, as ihornb will be needed when dnbm. */
/*  24    Slur on after or way-after grace.  Use as signal to START slur. */
/*  25    Tweak orn ht. Same in icrdorn for chord note */
/*  26    Insert user-defined space before this note (was 22) */
/*  27    Arpeggio stop or start (if 2 at same time), or all-in-this-chord */
/*  28    caesura or breath */
/* c  29    blank barline (must be iv=1) (would have used islur but no room) */
/*  29    coda */
/* c  30    "Look-left" option for keyboard rest */
/*  30    Part-by-part segno oG */
/*  31    Set if any note (main or chord) has cautionary accid, for space checks */
/* cccccccccccc */
/* c  irest  cc */
/* cccccccccccc */
/*  0        rest=1, no rest = 0 */
/*  1        There will be a vertical shift for number of this xtup */
/*  2        Set if 2-note tremolo starts here */
/*  3-4      nsolid, # of solid beams in 2-note tremolo */
/*  5-6      nindent, # of indented beams in 2-note tremolo */
/*  7        There is a horizontal shift for xtup number */
/*  9-13     Horiz shift, 1=>-1.5, ... , 31=>+1.5 */
/*  14       Flip up/down-ness of xtup number */
/*  15       Single-voice, single note shift  X(...)[p]S */
/*  16       Start single-voice, multinote shift with this note X(...)[p]: */
/*  17       End single-voice, multinote shift after this note. Enter symbol */
/*              after note. X: */
/*  18       User-defined hardspace after last note of bar, *after* this note. */
/*              Value still stored in udoff(ivx,nudoff(ivx)), not with other */
/*              hardspaces in udsp, to avoid confusion with time checks. */
/*  19       Move the dot.  Data stored in ndotmv,updot,rtdot */
/*  20       Set if right-shifted main or chord note here.  Use for space checks. */
/*  21       User-defined hardspace in xtup */
/*  22       User-defined slur shift horizontal slur shift. */
/*  23       Set on last note before staff-jumping a beam. */
/*  24       Set on first note after staff-jumping a beam */
/*  25       Suppress rest centering. "ro" */
/*  26       Dynamic on this note */
/*  27       Set if left-shifted main or chord note here.  Use for space checks. */
/*  28       Set if xtup starts on this note. */
/*  29       Set on lowest-voice note at same time as 1st note after jump-beam. */
/*  30       Set on note after end of jump-beam segment, to force new note group */
/*  31       Flag for cautionary accidental */
/* cccccccccccc */
/* c  nacc   cc */
/* cccccccccccc */
/*  0-1      0=no accid, 1=fl, 2=sh, 3=na */
/*  2        double */
/*  3        big */
/*  4-9      vertshift-32 */
/*  10-16    20*(horiz. shift + 5.35) (Recentered ver 2.32) */
/*  17       Midi-only accidental */
/*  18       2:1 xtup */
/*  19       Together with nacc(18), increase multiplicity by 1 and dot 1st note. */
/*  20       Set on last note of each seg except last seg of single-slope beam. */
/*  21       Set on 1st note of each seg except 1st seg of single-slope beam. */
/*  22-26    If .ne.0, printed xtup number for xtup starting on this note. */
/*  27       Set for dotted xtup note.  Mult dur by 1.5, mult next by .5 & increase */
/*             multiplicity by 1 */
/*  28       Set on main note of chord if accidentals are ordered. */
/*  29       Tag for chordal accidental shift...means add to autoshifts. */
/*  30-31    Set 30|31 if main note in a chord is part of a 2nd and needs to be shifted. */
/*             If upstem|downstem, main is upper|lower member of 2nd */
/*             Action is to interchange pitches only when notes are placed. */
/* cccccccccccc */
/* c  mult   cc */
/* cccccccccccc */
/*  0-3      Multiplicity+8 (mult= # of flags) */
/*  4        Set if slope adjustment for xtup bracket */
/*  5-9      16+slope adjustment */
/*  10-15    New stem length, [0-63] => (-4,0,+27.5) */
/*  16-22    64+Vertical offset of xtup # */
/*  27       Stemlength override */
/* c  28-30    New stem length. */
/* cccccccccccc */
/* c  isdat1 cc */
/* cccccccccccc */
/*  13-17    iv */
/*  3-10     ip */
/*  11       start/stop switch */
/*  12       kv-1 */
/*  19-25    ichar(code$) */
/*  26       force direction? */
/*  27       forced dir'n = up if on, set in sslur; also */
/*           final direction, set in doslur when beam is started, used on term. */
/*  28-31    ndxslur, set in doslur when beam is started, used on term. */
/* cccccccccccc */
/* c  isdat2 cc */
/* cccccccccccc */
/*  0        Chord switch.  Not set on main note. */
/*  1-2      left/right notehead shift.  Set only for chord note. */
/*  3        tie positioning */
/*  4        dotted slur */
/*  6-11     voff1 1-63  =>  -31...+31 */
/*  12-18    hoff1 1-127 => -6.3...+6.3 */
/*  19-25    nolev */
/*  26       \sluradjust    (p+s) */
/*  27       \nosluradjust  (p-s) */
/*  28       \tieadjust     (p+t) */
/*  29       \notieadjust   (p-t) */
/* cccccccccccc */
/* c  isdat3 cc */
/* cccccccccccc */
/*  0        set if midslur (at least one argument) */
/*  1        set if curve (2 more args) */
/*  2-7      32+first arg (height correction) (1st arg may be negative) */
/*  8-10     second arg (initial slope) */
/*  11-13    third arg (closing slope) */
/*  14-21    tie level for use in LineBreakTies */
/*  22-29    ncm for use in LineBreakTies */
/* cccccccccccc */
/* c  isdat4 cc  Set these all at turn-on using s option */
/* cccccccccccc */
/*  0-5      Linebreak seg 1 voff 1-63  =>  -31...+31 */
/*  6-12     Linebreak seg 1 hoff 1-127 => -6.3...+6.3 */
/*  16-21    Linebreak seg 2 voff 1-63  =>  -31...+31 */
/*  22-28    Linebreak seg 2 hoff 1-127 => -6.3...+6.3 */
/* cccccccccccc */
/*  icrdat   c */
/* cccccccccccc */
/*     0-7   ip within voice */
/*     8-11  ivx (together with 28th bit) */
/*     12-18 note level */
/*     19    accidental? */
/*     20-22 accidental value (1=natural, 2=flat, 3=sharp, 6=dflat, 7=dsharp) */
/*     23    shift left */
/*     24    shift right */
/*     25    arpeggio start or stop */
/*     26    flag for moved dot (here, not icrdot, since this is always reset!) */
/*     27    Midi-only accidental */
/*     28    (6/27/10) 5th bit for ivx, to allow up to 24 voices */
/*     29    Tag for accidental shift...means add to autoshifts. */
/*     31    Flag for cautionary accidental on chord note */
/* cccccccccccc */
/*  icrdot   c: */
/* cccccccccccc */
/*     0-6   10*abs(vertical dot shift in \internote) + 64 */
/*     7-13  10*abs(horizontal dot shift in \internote) + 64 */
/*     14-19 vert accidental shift-32 */
/*     20-26 20*(horiz accidental shift+3.2) */
/*     27-29 top-down level rank of chord note w/accid. Set in crdaccs. */

/*  Bits in icrdorn are same as in iornq, even tho most orns won't go in crds. */

/* ccccccccccccccccccccccccccccccc */
#line 20770 ""
    /* Parameter adjustments */
#line 20770 ""
    --poevec;
#line 20770 ""

#line 20770 ""
    /* Function Body */
#line 20770 ""
    comslope_1.bigslope = FALSE_;
#line 20771 ""
    comslope_1.novbm = FALSE_;
#line 20772 ""
    combottop_1.bottopgap = FALSE_;
#line 20773 ""
    comlyr_1.inputmlyr = FALSE_;
#line 20774 ""
    comhair_2.idhairuse = 0;
#line 20775 ""
    if (! (*optimize)) {
#line 20776 ""
	s_wsle(&io___1323);
#line 20776 ""
	e_wsle();
#line 20777 ""
	s_wsle(&io___1324);
#line 20777 ""
	do_lio(&c__9, &c__1, "Starting second PMX pass", (ftnlen)24);
#line 20777 ""
	e_wsle();
#line 20778 ""
	s_wsle(&io___1325);
#line 20778 ""
	e_wsle();
#line 20779 ""
	s_wsfe(&io___1326);
#line 20779 ""
	do_fio(&c__1, "Starting second PMX pass", (ftnlen)24);
#line 20779 ""
	e_wsfe();
#line 20780 ""
    }
#line 20781 ""
    newclef = FALSE_;
#line 20782 ""
    comclefrests_1.centrests = FALSE_;
#line 20783 ""
    ++(*ncalls);
#line 20784 ""
    comlast_1.islast = *inlast;
#line 20785 ""
    commac_1.macuse = 0;
#line 20786 ""
    isyscnt = 0;
#line 20787 ""
    all_1.stemmax = 8.2f;
#line 20788 ""
    all_1.stemmin = 3.9f;
#line 20789 ""
    all_1.stemlen = 6.f;
#line 20790 ""
    chax_(ch__1, (ftnlen)1, &c__92);
#line 20790 ""
    *(unsigned char *)all_1.sq = *(unsigned char *)&ch__1[0];
#line 20791 ""
    comignorenats_1.ignorenats = FALSE_;
#line 20792 ""
    comignorenats_1.newmbrhgt = FALSE_;
#line 20793 ""
    combc_1.bcspec = TRUE_;
#line 20794 ""
    comas3_1.topmods = FALSE_;
#line 20795 ""
    ismbr = FALSE_;
#line 20796 ""
    s_rsfe(&io___1330);
#line 20796 ""
    do_fio(&c__1, basenameq, (ftnlen)44);
#line 20796 ""
    e_rsfe();
#line 20797 ""
    s_rsle(&io___1332);
#line 20797 ""
    do_lio(&c__3, &c__1, (char *)&lbase, (ftnlen)sizeof(integer));
#line 20797 ""
    e_rsle();
#line 20798 ""
    s_rsle(&io___1334);
#line 20798 ""
    do_lio(&c__4, &c__1, (char *)&comask_1.fbar, (ftnlen)sizeof(real));
#line 20798 ""
    do_lio(&c__4, &c__1, (char *)&comask_1.wheadpt, (ftnlen)sizeof(real));
#line 20798 ""
    do_lio(&c__4, &c__1, (char *)&etait, (ftnlen)sizeof(real));
#line 20798 ""
    do_lio(&c__4, &c__1, (char *)&etatc, (ftnlen)sizeof(real));
#line 20798 ""
    do_lio(&c__4, &c__1, (char *)&etacs1, (ftnlen)sizeof(real));
#line 20798 ""
    do_lio(&c__4, &c__1, (char *)&etatop, (ftnlen)sizeof(real));
#line 20798 ""
    do_lio(&c__4, &c__1, (char *)&etabot, (ftnlen)sizeof(real));
#line 20798 ""
    do_lio(&c__3, &c__1, (char *)&cominbot_1.inbothd, (ftnlen)sizeof(integer))
	    ;
#line 20798 ""
    do_lio(&c__3, &c__1, (char *)&inhnoh, (ftnlen)sizeof(integer));
#line 20798 ""
    do_lio(&c__3, &c__1, (char *)&comtop_1.isig, (ftnlen)sizeof(integer));
#line 20798 ""
    e_rsle();
#line 20800 ""
    inbuff_1.ilbuf = 1;
#line 20801 ""
    inbuff_1.ipbuf = 0;
#line 20802 ""
    getset_(&all_1.nv, &noinst, &all_1.mtrnuml, &all_1.mtrdenl, &all_1.mtrnmp,
	     &all_1.mtrdnp, &xmtrnum0, &npages, &nsyst, &all_1.musicsize, &
	    comtop_1.fracindent, &istype0, comtop_1.inameq, comclefq_1.clefq, 
	    all_1.sepsymq, pathnameq, &lpath, &comtop_1.isig0, (ftnlen)79, (
	    ftnlen)1, (ftnlen)1, (ftnlen)40);
#line 20805 ""
    if (commidi_1.ismidi) {
#line 20806 ""
	if (xmtrnum0 > comtol_1.tol) {

/*  We have a pickup.  Some tricky stuff to get a meter: */

#line 20810 ""
	    xntrial = xmtrnum0;
#line 20811 ""
	    for (ip2 = 0; ip2 <= 5; ++ip2) {
#line 20812 ""
		if ((r__1 = r_mod(&xntrial, &c_b1065), dabs(r__1)) < 
			comtol_1.tol) {
#line 20812 ""
		    goto L6;
#line 20812 ""
		}
#line 20813 ""
		xntrial *= 2;
#line 20814 ""
/* L5: */
#line 20814 ""
	    }
#line 20815 ""
	    s_wsle(&io___1350);
#line 20815 ""
	    do_lio(&c__9, &c__1, "Problem finding meter for pickup bar", (
		    ftnlen)36);
#line 20815 ""
	    e_wsle();
#line 20816 ""
	    xntrial = 1.f;
#line 20817 ""
	    ip2 = 0;
#line 20818 ""
L6:
#line 20819 ""
	    i__1 = i_nint(&xntrial);
#line 20819 ""
	    i__2 = pow_ii(&c__2, &ip2) * all_1.mtrdenl;
#line 20819 ""
	    midievent_("m", &i__1, &i__2, (ftnlen)1);
#line 20820 ""
	} else {

/*  No pickup, enter the starting meter */

#line 20824 ""
	    midievent_("m", &all_1.mtrnuml, &all_1.mtrdenl, (ftnlen)1);
#line 20825 ""
	}
#line 20826 ""
    }

/*  Set musicsize from value passed in common, due to possible reset by S[n]m16 */

#line 20830 ""
    all_1.musicsize = commus_1.musize;
#line 20831 ""
    s_rsle(&io___1351);
#line 20831 ""
    do_lio(&c__3, &c__1, (char *)&npages, (ftnlen)sizeof(integer));
#line 20831 ""
    do_lio(&c__4, &c__1, (char *)&comtop_1.widthpt, (ftnlen)sizeof(real));
#line 20831 ""
    do_lio(&c__4, &c__1, (char *)&comtop_1.height, (ftnlen)sizeof(real));
#line 20831 ""
    do_lio(&c__4, &c__1, (char *)&comtop_1.hoffpt, (ftnlen)sizeof(real));
#line 20831 ""
    do_lio(&c__4, &c__1, (char *)&comtop_1.voffpt, (ftnlen)sizeof(real));
#line 20831 ""
    do_lio(&c__3, &c__1, (char *)&nsyst, (ftnlen)sizeof(integer));
#line 20831 ""
    i__1 = npages;
#line 20831 ""
    for (ipa = 1; ipa <= i__1; ++ipa) {
#line 20831 ""
	do_lio(&c__3, &c__1, (char *)&comnotes_1.nsystp[ipa - 1], (ftnlen)
		sizeof(integer));
#line 20831 ""
	do_lio(&c__4, &c__1, (char *)&xnsttop[ipa - 1], (ftnlen)sizeof(real));
#line 20831 ""
	do_lio(&c__4, &c__1, (char *)&xintstaff[ipa - 1], (ftnlen)sizeof(real)
		);
#line 20831 ""
    }
#line 20831 ""
    do_lio(&c__3, &c__1, (char *)&iauto, (ftnlen)sizeof(integer));
#line 20831 ""
    e_rsle();

/*  If default width ever changes, must adjust this stmt. */

#line 20836 ""
    slfac1 = 2.98156f / comtop_1.widthpt;
#line 20837 ""
    all_1.figbass = FALSE_;
#line 20838 ""
    s_rsle(&io___1357);
#line 20838 ""
    do_lio(&c__3, &c__1, (char *)&ifig, (ftnlen)sizeof(integer));
#line 20838 ""
    e_rsle();
#line 20839 ""
    if (ifig == 1) {
#line 20840 ""
	all_1.figbass = TRUE_;
#line 20841 ""
	o__1.oerr = 0;
#line 20841 ""
	o__1.ounit = 14;
#line 20841 ""
	o__1.ofnm = 0;
#line 20841 ""
	o__1.orl = 0;
#line 20841 ""
	o__1.osta = "SCRATCH";
#line 20841 ""
	o__1.oacc = 0;
#line 20841 ""
	o__1.ofm = 0;
#line 20841 ""
	o__1.oblnk = 0;
#line 20841 ""
	f_open(&o__1);
#line 20842 ""
	s_wsfe(&io___1359);
/* Writing concatenation */
#line 20842 ""
	i__3[0] = 1, a__1[0] = all_1.sq;
#line 20842 ""
	i__3[1] = 3, a__1[1] = "def";
#line 20842 ""
	i__3[2] = 1, a__1[2] = all_1.sq;
#line 20842 ""
	i__3[3] = 8, a__1[3] = "fixdrop{";
#line 20842 ""
	i__3[4] = 1, a__1[4] = all_1.sq;
#line 20842 ""
	i__3[5] = 7, a__1[5] = "advance";
#line 20842 ""
	i__3[6] = 1, a__1[6] = all_1.sq;
#line 20842 ""
	i__3[7] = 10, a__1[7] = "sysno by 1";
#line 20842 ""
	i__3[8] = 1, a__1[8] = all_1.sq;
#line 20842 ""
	i__3[9] = 6, a__1[9] = "ifcase";
#line 20842 ""
	i__3[10] = 1, a__1[10] = all_1.sq;
#line 20842 ""
	i__3[11] = 6, a__1[11] = "sysno%";
#line 20842 ""
	s_cat(ch__2, a__1, i__3, &c__12, (ftnlen)46);
#line 20842 ""
	do_fio(&c__1, ch__2, (ftnlen)46);
#line 20842 ""
	e_wsfe();
#line 20844 ""
    }
#line 20845 ""
    comget_1.lastchar = FALSE_;
#line 20846 ""
    ibcoff = 0;
#line 20847 ""
    if (xmtrnum0 > 0.f) {
#line 20847 ""
	ibcoff = -1;
#line 20847 ""
    }
#line 20848 ""
    o__1.oerr = 0;
#line 20848 ""
    o__1.ounit = 11;
#line 20848 ""
    o__1.ofnm = 0;
#line 20848 ""
    o__1.orl = 0;
#line 20848 ""
    o__1.osta = "SCRATCH";
#line 20848 ""
    o__1.oacc = 0;
#line 20848 ""
    o__1.ofm = 0;
#line 20848 ""
    o__1.oblnk = 0;
#line 20848 ""
    f_open(&o__1);

/*  vshrink for the first page is calculated in topfile, */
/*  and if true set interstaff=10.  vshrink affects Titles. */
/*  Must also save vshrink for page ending. */

#line 20854 ""
    topfile_(basenameq, &lbase, &all_1.nv, comclefq_1.clefq, &noinst, &
	    all_1.musicsize, xintstaff, &all_1.mtrnmp, &all_1.mtrdnp, &
	    vshrink, &comask_1.fbar, &comslur_1.fontslur, (ftnlen)44, (ftnlen)
	    1);

/*  ninow is working value of # of instruments.  noinst is max #, and # at start. */

#line 20859 ""
    comnotes_1.ninow = noinst;

/*  Save original printed meter in case movement breaks */

#line 20863 ""
    comget_1.movnmp = all_1.mtrnmp;
#line 20864 ""
    comget_1.movdnp = all_1.mtrdnp;

#line 20866 ""
    if (comlast_1.islast && all_1.figbass && all_1.musicsize == 16) {
#line 20866 ""
	s_wsfe(&io___1362);
/* Writing concatenation */
#line 20866 ""
	i__4[0] = 1, a__2[0] = all_1.sq;
#line 20866 ""
	i__4[1] = 3, a__2[1] = "def";
#line 20866 ""
	i__4[2] = 1, a__2[2] = all_1.sq;
#line 20866 ""
	i__4[3] = 8, a__2[3] = "figfont{";
#line 20866 ""
	i__4[4] = 1, a__2[4] = all_1.sq;
#line 20866 ""
	i__4[5] = 9, a__2[5] = "eightrm}%";
#line 20866 ""
	s_cat(ch__3, a__2, i__4, &c__6, (ftnlen)23);
#line 20866 ""
	do_fio(&c__1, ch__3, (ftnlen)23);
#line 20866 ""
	e_wsfe();
#line 20866 ""
    }

#line 20869 ""
    if (comlast_1.islast && comligfont_1.isligfont) {
#line 20870 ""
	if (all_1.musicsize == 16) {
#line 20871 ""
	    s_wsfe(&io___1363);
/* Writing concatenation */
#line 20871 ""
	    i__5[0] = 1, a__3[0] = all_1.sq;
#line 20871 ""
	    i__5[1] = 4, a__3[1] = "font";
#line 20871 ""
	    i__5[2] = 1, a__3[2] = all_1.sq;
#line 20871 ""
	    i__5[3] = 20, a__3[3] = "ligfont=cmrj at 8pt%";
#line 20871 ""
	    s_cat(ch__4, a__3, i__5, &c__4, (ftnlen)26);
#line 20871 ""
	    do_fio(&c__1, ch__4, (ftnlen)26);
#line 20871 ""
	    e_wsfe();
#line 20872 ""
	} else {
#line 20873 ""
	    s_wsfe(&io___1364);
/* Writing concatenation */
#line 20873 ""
	    i__5[0] = 1, a__3[0] = all_1.sq;
#line 20873 ""
	    i__5[1] = 4, a__3[1] = "font";
#line 20873 ""
	    i__5[2] = 1, a__3[2] = all_1.sq;
#line 20873 ""
	    i__5[3] = 21, a__3[3] = "ligfont=cmrj at 10pt%";
#line 20873 ""
	    s_cat(ch__5, a__3, i__5, &c__4, (ftnlen)27);
#line 20873 ""
	    do_fio(&c__1, ch__5, (ftnlen)27);
#line 20873 ""
	    e_wsfe();
#line 20874 ""
	}
#line 20875 ""
    }
#line 20876 ""
    lenbeat = ifnodur_(&all_1.mtrdenl, "x", (ftnlen)1);
#line 20877 ""
    if (all_1.mtrdenl == 2) {
#line 20877 ""
	lenbeat = 16;
#line 20877 ""
    }
#line 20878 ""
    all_1.lenb1 = all_1.mtrnuml * lenbeat;
#line 20879 ""
    if (all_1.mtrdenl == 2) {
#line 20879 ""
	all_1.lenb1 <<= 1;
#line 20879 ""
    }
#line 20880 ""
    setmeter_(&all_1.mtrnuml, &all_1.mtrdenl, &combeam_1.ibmtyp, &ibmrep);
#line 20881 ""
    r__1 = xmtrnum0 * lenbeat;
#line 20881 ""
    all_1.lenb0 = i_nint(&r__1);
#line 20882 ""
    if (all_1.mtrdenl == 2) {
#line 20882 ""
	all_1.lenb0 <<= 1;
#line 20882 ""
    }
#line 20883 ""
    if (all_1.lenb0 != 0) {
#line 20884 ""
	if (comlast_1.islast) {
#line 20884 ""
	    s_wsfe(&io___1367);
/* Writing concatenation */
#line 20884 ""
	    i__5[0] = 1, a__3[0] = all_1.sq;
#line 20884 ""
	    i__5[1] = 7, a__3[1] = "advance";
#line 20884 ""
	    i__5[2] = 1, a__3[2] = all_1.sq;
#line 20884 ""
	    i__5[3] = 11, a__3[3] = "barno by -1";
#line 20884 ""
	    s_cat(ch__6, a__3, i__5, &c__4, (ftnlen)20);
#line 20884 ""
	    do_fio(&c__1, ch__6, (ftnlen)20);
#line 20884 ""
	    e_wsfe();
#line 20884 ""
	}
#line 20885 ""
	all_1.lenbar = all_1.lenb0;
#line 20886 ""
    } else {
#line 20887 ""
	all_1.lenbar = all_1.lenb1;
#line 20888 ""
    }

/*  Initialize full-program variables */

#line 20892 ""
    comask_1.fixednew = 0.f;
#line 20893 ""
    comask_1.scaldold = 0.f;
#line 20894 ""
    comget_1.fintstf = -1.f;
#line 20895 ""
    comget_1.gintstf = 1.f;
#line 20896 ""
    comas2_1.nasksys = 0;
#line 20897 ""
    combibarcnt_1.ibarcnt = 0;
#line 20898 ""
    all_1.iline = 0;
#line 20899 ""
    comget_1.movbrk = 0;
#line 20900 ""
    isystpg = 0;
#line 20901 ""
    comnotes_1.ipage = 1;
#line 20902 ""
    all_1.iccount = 128;
#line 20903 ""
    comas3_1.iask = 0;
#line 20904 ""
    nhstot = 0;
#line 20905 ""
    comnsp_2.nb = 1;
#line 20906 ""
    if (! (*optimize)) {
#line 20906 ""
	jprntb = 81;
#line 20906 ""
    }
#line 20907 ""
    comtop_1.idsig = 0;
#line 20908 ""
    iflagbot = 0;

/*  Next 5 are raise-barno parameters.  irzbnd is integer part of default level. */

#line 20912 ""
    comsln_1.irzbnd = 3;
#line 20913 ""
    if (comtop_1.isig == 3 && *(unsigned char *)&comclefq_1.clefq[all_1.nv - 
	    1] == 't') {
#line 20913 ""
	comsln_1.irzbnd = 4;
#line 20913 ""
    }
#line 20914 ""
    comsln_1.is1n1 = 0;
#line 20915 ""
    comsln_1.isnx = 0;
#line 20916 ""
    comslur_1.slurcurve = 0.f;
#line 20917 ""
    comshort_1.ishort = 0;
#line 20918 ""
    comshort_1.nocodabn = FALSE_;
#line 20919 ""
    comshort_1.mbrsum = 0;
#line 20920 ""
    comshort_1.nmbr = 0;

/* 111109 Made global rather than per gulp */

#line 20924 ""
    comdyn_1.ndyn = 0;
#line 20925 ""
    compoi_1.ispoi = FALSE_;
#line 20926 ""
    slint = FALSE_;
#line 20927 ""
    lrptpend = FALSE_;
#line 20928 ""
    comget_1.rptnd1 = FALSE_;
#line 20929 ""
    *(unsigned char *)comget_1.rptfq2 = 'E';
#line 20930 ""
    comget_1.rptprev = FALSE_;
#line 20931 ""
    onvolt = FALSE_;
#line 20932 ""
    comnsp_2.flgndb = FALSE_;
#line 20933 ""
    comget_1.fbon = FALSE_;
#line 20934 ""
    comnotes_1.shifton = FALSE_;
#line 20935 ""
    comget_1.ornrpt = FALSE_;
#line 20936 ""
    comnotes_1.setis = FALSE_;
#line 20937 ""
    comarp_1.lowdot = FALSE_;
#line 20938 ""
    comnvi_1.rename = FALSE_;
#line 20939 ""
    comnotes_1.nobar1 = FALSE_;
#line 20940 ""
    comget_1.equalize = FALSE_;
#line 20941 ""
    comlast_1.usevshrink = TRUE_;
#line 20942 ""
    comslur_1.wrotepsslurdefaults = FALSE_;
#line 20943 ""
    comnotes_1.optlinebreakties = FALSE_;
#line 20944 ""
    comnotes_1.headerspecial = FALSE_;

/*  vshrink is initialized in topfile */

#line 20948 ""
    comget_1.stickys = FALSE_;

/*  ixrest = 1 or 2 if xtup has started with a rest */

#line 20952 ""
    for (commvl_1.ivx = 1; commvl_1.ivx <= 24; ++commvl_1.ivx) {
#line 20953 ""
	strtmid_1.ixrest[commvl_1.ivx - 1] = 0;
#line 20954 ""
	comfig_1.fullsize[commvl_1.ivx - 1] = 1.f;

/*  Set legacy note level to middle c as default */

#line 20958 ""
	comnotes_1.ndlev[commvl_1.ivx - 1] = 29;
#line 20959 ""
	comnotes_1.ndlev[commvl_1.ivx + 23] = 29;
#line 20960 ""
/* L1: */
#line 20960 ""
    }
#line 20961 ""
    comnotes_1.npreslur = 0;
#line 20962 ""
    nhssys = 0;
#line 20963 ""
    comslur_1.listslur = 0;
#line 20964 ""
    for (i__ = 1; i__ <= 202; ++i__) {
#line 20965 ""
	all_1.isdat1[i__ - 1] = 0;
#line 20966 ""
	all_1.isdat2[i__ - 1] = 0;
#line 20967 ""
/* L31: */
#line 20967 ""
    }
#line 20968 ""
    all_1.nsdat = 0;

/*  Initialize flag for figures in any other voice than 1 */

#line 20972 ""
    comfig_1.ivxfig2 = 0;

/*  Initialize for loop over gulps */

#line 20976 ""
    all_1.firstgulp = TRUE_;

/*  Start a gulp */

#line 20980 ""
L30:
#line 20980 ""
    loop = TRUE_;
#line 20981 ""
    comnotes_1.notcrd = TRUE_;
#line 20982 ""
    combjmp_1.isbjmp = FALSE_;
#line 20983 ""
    combjmp_1.isbj2 = FALSE_;
#line 20984 ""
    comfb_1.autofbon = FALSE_;
#line 20985 ""
    comfb_1.tautofb = 0.f;
#line 20986 ""
    all_1.nbars = 0;
#line 20987 ""
    comfig_1.nfigs[0] = 0;
#line 20988 ""
    comfig_1.nfigs[1] = 0;
#line 20989 ""
    comgrace_1.ngrace = 0;
#line 20990 ""
    comtrill_1.ntrill = 0;
#line 20991 ""
    comtrill_1.ncrd = 0;
#line 20992 ""
    comtrill_1.nudorn = 0;
#line 20993 ""
    comgrace_1.nlit = 0;
#line 20994 ""
    comgrace_1.nvolt = 0;
#line 20995 ""
    comgrace_1.ibarmbr = 0;
#line 20996 ""
    comudsp_1.nudsp = 0;
#line 20997 ""
    comdyn_1.ntxtdyn = 0;
#line 20998 ""
    comcb_1.nbc = 0;
#line 20999 ""
    comarpshift_1.numarpshift = 0;
#line 21000 ""
    for (i__ = 1; i__ <= 37; ++i__) {
#line 21001 ""
	comgrace_1.graspace[i__ - 1] = 0.f;
#line 21002 ""
/* L3: */
#line 21002 ""
    }

/*  Now initialize up to nv.  Do it in getnote as r'qd for 2nd voices per syst. */
/*  and also if nv increases in an 'M' directive. */

#line 21007 ""
    i__1 = all_1.nv;
#line 21007 ""
    for (all_1.iv = 1; all_1.iv <= i__1; ++all_1.iv) {
#line 21008 ""
	newvoice_(&all_1.iv, comclefq_1.clefq + (all_1.iv - 1), &c_false, (
		ftnlen)1);
#line 21009 ""
/* L4: */
#line 21009 ""
    }

/*  Check if endsymbol was set earlier */

#line 21013 ""
    if (comget_1.rptnd1) {
#line 21014 ""
	comget_1.rptnd1 = FALSE_;
#line 21015 ""
	*(unsigned char *)comget_1.rptfq2 = *(unsigned char *)comget_1.rptfq1;
#line 21016 ""
    } else {

/*  Only use if movbrk>0, to signal default ('RD') */

#line 21020 ""
	*(unsigned char *)comget_1.rptfq2 = 'E';
#line 21021 ""
    }
#line 21022 ""
    all_1.iv = 1;
#line 21023 ""
    commvl_1.ivx = 1;
#line 21024 ""
L2:
#line 21024 ""
    if (loop) {

/*  Within this loop, nv voices are filled up for the duration of the block. */
/*  On exit (loop=.false.) the following are set: nnl(nv),itsofar(nv) */
/*  nolev(nv,nnl(nv)),nodur(..),accq(..),irest(..). */
/*  nbars is for this input block. */
/*  Only at the beginning of an input block will there be a possible mtr change, */
/*  signalled by a nonzero mtrnuml. (which will be re-zeroed right after change) */

#line 21033 ""
	getnote_(&loop);
#line 21034 ""
	if (comget_1.lastchar) {
#line 21034 ""
	    goto L40;
#line 21034 ""
	}
#line 21035 ""
	goto L2;
#line 21036 ""
    }

/*  Finished an input block (gulp). */

#line 21040 ""
    if (commidi_1.ismidi) {

/*  Put rests into midi array for 2nd lines that were not used in this gulp. */

#line 21044 ""
	i__1 = all_1.nv;
#line 21044 ""
	for (all_1.iv = 1; all_1.iv <= i__1; ++all_1.iv) {
#line 21045 ""
	    if (commidi_1.twoline[all_1.iv - 1] && commvl_1.nvmx[all_1.iv - 1]
		     == 1) {
#line 21046 ""
		if (all_1.firstgulp && all_1.lenb0 != 0) {
#line 21047 ""
		    r__1 = (all_1.nbars - 1.f) * all_1.lenbar + all_1.lenb0;
#line 21047 ""
		    addmidi_(&commidi_1.midchan[all_1.iv + 23], &c__0, &c__0, 
			    &c__0, &r__1, &c_true, &c_false);
#line 21049 ""
		} else {
#line 21050 ""
		    r__1 = all_1.nbars * 1.f * all_1.lenbar;
#line 21050 ""
		    addmidi_(&commidi_1.midchan[all_1.iv + 23], &c__0, &c__0, 
			    &c__0, &r__1, &c_true, &c_false);
#line 21052 ""
		}
#line 21053 ""
	    }
#line 21054 ""
/* L60: */
#line 21054 ""
	}
#line 21055 ""
    }
#line 21056 ""
    comgrace_1.nvolt = 0;
#line 21057 ""
    for (all_1.iv = 1; all_1.iv <= 24; ++all_1.iv) {
#line 21058 ""
	comudsp_1.nudoff[all_1.iv - 1] = 0;
#line 21059 ""
	comcc_1.maxdotmv[all_1.iv - 1] = comcc_1.ndotmv[all_1.iv - 1];
#line 21060 ""
	comcc_1.ndotmv[all_1.iv - 1] = 0;
#line 21061 ""
/* L28: */
#line 21061 ""
    }

/*  Put stuff at top of p.1.  Must wait until now to have read title info. */

#line 21065 ""
    if (combibarcnt_1.ibarcnt == 0) {
#line 21066 ""
	puttitle_(&inhnoh, &xnsttop[comnotes_1.ipage - 1], &etatop, all_1.sq, 
		&etait, &etatc, &etacs1, &all_1.nv, &vshrink, all_1.sepsymq, (
		ftnlen)1, (ftnlen)1);
#line 21068 ""
	if (comnotes_1.headerspecial) {
#line 21068 ""
	    s_wsfe(&io___1378);
/* Writing concatenation */
#line 21068 ""
	    chax_(ch__1, (ftnlen)1, &c__92);
#line 21068 ""
	    i__6[0] = 1, a__4[0] = ch__1;
#line 21068 ""
	    i__6[1] = 28, a__4[1] = "special{header=psslurs.pro}%";
#line 21068 ""
	    s_cat(ch__7, a__4, i__6, &c__2, (ftnlen)29);
#line 21068 ""
	    do_fio(&c__1, ch__7, (ftnlen)29);
#line 21068 ""
	    e_wsfe();
#line 21068 ""
	}

/*  Write special header for first page */

#line 21073 ""
    }
#line 21074 ""
    i__1 = all_1.nbars;
#line 21074 ""
    for (all_1.ibar = 1; all_1.ibar <= i__1; ++all_1.ibar) {
#line 21075 ""
	++combibarcnt_1.ibarcnt;
#line 21076 ""
	comask_1.bar1syst = combibarcnt_1.ibarcnt == iauto;
/* Computing MAX */
#line 21077 ""
	r__1 = combibarcnt_1.ibarcnt + .001f + ibcoff;
#line 21077 ""
	i__2 = 0, i__7 = (integer) r_lg10(&r__1);
#line 21077 ""
	ndig = max(i__2,i__7);
#line 21078 ""
	if (comlast_1.islast) {
#line 21078 ""
	    ci__1.cierr = 0;
#line 21078 ""
	    ci__1.ciunit = 11;
/* Writing concatenation */
#line 21078 ""
	    i__8[0] = 6, a__5[0] = "(a11,i";
#line 21078 ""
	    i__2 = ndig + 50;
#line 21078 ""
	    chax_(ch__1, (ftnlen)1, &i__2);
#line 21078 ""
	    i__8[1] = 1, a__5[1] = ch__1;
#line 21078 ""
	    i__8[2] = 1, a__5[2] = ")";
#line 21078 ""
	    ci__1.cifmt = (s_cat(ch__8, a__5, i__8, &c__3, (ftnlen)8), ch__8);
#line 21078 ""
	    s_wsfe(&ci__1);
#line 21078 ""
	    do_fio(&c__1, "% Bar count", (ftnlen)11);
#line 21078 ""
	    i__7 = combibarcnt_1.ibarcnt + ibcoff;
#line 21078 ""
	    do_fio(&c__1, (char *)&i__7, (ftnlen)sizeof(integer));
#line 21078 ""
	    e_wsfe();
#line 21078 ""
	}
#line 21081 ""
	if (all_1.ibar != comgrace_1.ibarmbr) {
#line 21082 ""
	    if (! (*optimize)) {
#line 21082 ""
		i__2 = combibarcnt_1.ibarcnt + ibcoff;
#line 21082 ""
		outbar_(&i__2, &jprntb);
#line 21082 ""
	    }
#line 21083 ""
	} else {
#line 21084 ""
	    if (! (*optimize)) {
#line 21085 ""
		s_wsfe(&io___1380);
#line 21085 ""
		do_fio(&c__1, " Multibar rest, bars", (ftnlen)20);
#line 21085 ""
		i__2 = combibarcnt_1.ibarcnt + ibcoff;
#line 21085 ""
		do_fio(&c__1, (char *)&i__2, (ftnlen)sizeof(integer));
#line 21085 ""
		do_fio(&c__1, "-", (ftnlen)1);
#line 21085 ""
		i__7 = combibarcnt_1.ibarcnt + ibcoff + comgrace_1.mbrest - 1;
#line 21085 ""
		do_fio(&c__1, (char *)&i__7, (ftnlen)sizeof(integer));
#line 21085 ""
		e_wsfe();
#line 21087 ""
		s_wsfe(&io___1381);
#line 21087 ""
		do_fio(&c__1, " Multibar rest, bars", (ftnlen)20);
#line 21087 ""
		i__2 = combibarcnt_1.ibarcnt + ibcoff;
#line 21087 ""
		do_fio(&c__1, (char *)&i__2, (ftnlen)sizeof(integer));
#line 21087 ""
		do_fio(&c__1, "-", (ftnlen)1);
#line 21087 ""
		i__7 = combibarcnt_1.ibarcnt + ibcoff + comgrace_1.mbrest - 1;
#line 21087 ""
		do_fio(&c__1, (char *)&i__7, (ftnlen)sizeof(integer));
#line 21087 ""
		e_wsfe();
#line 21089 ""
		jprntb = 0;
#line 21090 ""
	    }
#line 21091 ""
	    ibcoff = ibcoff + comgrace_1.mbrest - 1;
/*          if (ibar.eq.1 .and. firstgulp .and. */
/*     *       .not.btest(islur(1,1),5)) xb4mbr = facmtr*musicsize */
#line 21094 ""
	    if (all_1.ibar == 1 && all_1.firstgulp && ! bit_test(all_1.islur[
		    0],5)) {
#line 21094 ""
		comgrace_1.xb4mbr = all_1.musicsize * -.2f;
#line 21094 ""
	    }
#line 21096 ""
	}

/*  Move the read to after end-of-bar hardspace checks, so we get right poenom */
/*  at end of a line. */
/*       if (bar1syst) read(12,*) poenom */

/*  Check for clef at start of bar.  No slide yet.  Also flags at end of prev. */
/*  bar.  This block is run at the start of every bar.  May fail for flag at */
/*  end of last bar.  To account for necc. hardspaces, compute and store */
/*    nhssys = # of hard spaces for this system */
/*    hesk(nhssys) = elemskips avialable */
/*    hpts(nhssys) = hard points needed, including notehead */
/*  Here, merely insert placeholder into output.  Later, when poe is computed, */
/*  compute additional pts and store them in hpttot(1...nhstot).  Finally in */
/*  subroutine askfig, write true pts where placeholders are. */

#line 21112 ""
	ioff = 0;
#line 21113 ""
	if (all_1.ibar > 1) {
#line 21113 ""
	    ioff = all_1.nib[(all_1.ibar - 1) * 24 - 24];
#line 21113 ""
	}
#line 21114 ""
	clchb = bit_test(all_1.islur[(ioff + 1) * 24 - 24],15);
#line 21115 ""
	putmbr = FALSE_;
#line 21116 ""
	if (ismbr) {
#line 21117 ""
	    if (clchb) {
/* cc */
/* cc  Clef change and multi-bar rest coming up.  Kluge to get space at end of rest. */
/* cc */
#line 21121 ""
		s_wsfe(&io___1385);
/* Writing concatenation */
#line 21121 ""
		i__9[0] = 1, a__6[0] = all_1.sq;
#line 21121 ""
		i__9[1] = 3, a__6[1] = "let";
#line 21121 ""
		i__9[2] = 1, a__6[2] = all_1.sq;
#line 21121 ""
		i__9[3] = 4, a__6[3] = "mbrt";
#line 21121 ""
		i__9[4] = 1, a__6[4] = all_1.sq;
#line 21121 ""
		i__9[5] = 6, a__6[5] = "mbrest";
#line 21121 ""
		i__9[6] = 1, a__6[6] = all_1.sq;
#line 21121 ""
		i__9[7] = 3, a__6[7] = "def";
#line 21121 ""
		i__9[8] = 1, a__6[8] = all_1.sq;
#line 21121 ""
		i__9[9] = 14, a__6[9] = "mbrest#1#2#3{%";
#line 21121 ""
		s_cat(ch__9, a__6, i__9, &c__10, (ftnlen)35);
#line 21121 ""
		do_fio(&c__1, ch__9, (ftnlen)35);
#line 21121 ""
		e_wsfe();
#line 21123 ""
		s_wsfe(&io___1386);
/* Writing concatenation */
#line 21123 ""
		i__6[0] = 1, a__4[0] = all_1.sq;
#line 21123 ""
		i__6[1] = 13, a__4[1] = "mbrt{#1}{#2}{";
#line 21123 ""
		s_cat(ch__10, a__4, i__6, &c__2, (ftnlen)14);
#line 21123 ""
		do_fio(&c__1, ch__10, (ftnlen)14);
#line 21123 ""
		r__1 = all_1.musicsize * .55f;
#line 21123 ""
		do_fio(&c__1, (char *)&r__1, (ftnlen)sizeof(real));
/* Writing concatenation */
#line 21123 ""
		i__10[0] = 1, a__7[0] = "}";
#line 21123 ""
		i__10[1] = 1, a__7[1] = all_1.sq;
#line 21123 ""
		i__10[2] = 6, a__7[2] = "global";
#line 21123 ""
		i__10[3] = 1, a__7[3] = all_1.sq;
#line 21123 ""
		i__10[4] = 3, a__7[4] = "let";
#line 21123 ""
		i__10[5] = 1, a__7[5] = all_1.sq;
#line 21123 ""
		i__10[6] = 6, a__7[6] = "mbrest";
#line 21123 ""
		i__10[7] = 1, a__7[7] = all_1.sq;
#line 21123 ""
		i__10[8] = 6, a__7[8] = "mbrt}%";
#line 21123 ""
		s_cat(ch__4, a__7, i__10, &c__9, (ftnlen)26);
#line 21123 ""
		do_fio(&c__1, ch__4, (ftnlen)26);
#line 21123 ""
		e_wsfe();
#line 21125 ""
	    }
#line 21126 ""
	    ismbr = FALSE_;
#line 21127 ""
	    putmbr = TRUE_;
#line 21128 ""
	}
#line 21129 ""
	if (all_1.ibar == comgrace_1.ibarmbr) {
#line 21129 ""
	    ismbr = TRUE_;
#line 21129 ""
	}

/*  Set flag here so at start of next bar, if there's a clef change, can add space */
/*    after the mbr with the above kluge */

#line 21134 ""
	if (! (clchb || comnsp_2.flgndb)) {
#line 21134 ""
	    goto L23;
#line 21134 ""
	}

/*  Must check available space */

#line 21138 ""
	ptsndb = 0.f;

/*  Zero out block signal */

#line 21142 ""
	if (clchb) {
#line 21142 ""
	    all_1.islur[(ioff + 1) * 24 - 24] = bit_clear(all_1.islur[(ioff + 
		    1) * 24 - 24],15);
#line 21142 ""
	}

/*  In this loop, we determine how much hardspace is needed (if any) */
/*  9/7/97  Note that for last bar in input block, if number of lines of */
/*    music decreases in new block, highest numbered ones won't be checked */
/*    since the loop below covers the new nvmx(iv), not necessarily the old */
/*    one. */
/*  4/18/98 Apparently nmxsav was a solution to the above problem */

#line 21151 ""
	i__2 = all_1.nv;
#line 21151 ""
	for (all_1.iv = 1; all_1.iv <= i__2; ++all_1.iv) {
#line 21152 ""
	    i__7 = comnsp_2.nvmxsav[all_1.iv - 1];
#line 21152 ""
	    for (kv = 1; kv <= i__7; ++kv) {
#line 21153 ""
		commvl_1.ivx = comnsp_2.ivmxsav[all_1.iv + kv * 24 - 25];
#line 21154 ""
		ptsndv = comnsp_2.flgndv[commvl_1.ivx - 1] * comask_1.wheadpt;
#line 21155 ""
		ioff = 0;
#line 21156 ""
		if (all_1.ibar > 1) {
#line 21157 ""
		    ioff = all_1.nib[commvl_1.ivx + (all_1.ibar - 1) * 24 - 
			    25];
#line 21158 ""
		    ip = ioff;
#line 21159 ""
		    if (all_1.ibar > 2) {
#line 21159 ""
			ip = ioff - all_1.nib[commvl_1.ivx + (all_1.ibar - 2) 
				* 24 - 25];
#line 21159 ""
		    }
/*            prevtn(ivx) = tnote(iand(ipl(ivx,ip),255)) */
#line 21161 ""
		    comnsp_2.prevtn[commvl_1.ivx - 1] = all_1.tnote[
			    comipl2_1.ipl2[commvl_1.ivx + ip * 24 - 25] - 1];

/* If ibar=1 (1st bar in input block), prevtn(ivx) was set at end of makeabar. */

#line 21165 ""
		}

/*  Only allow clef changes when ivx <= nv */

#line 21169 ""
		if (commvl_1.ivx <= all_1.nv) {
#line 21170 ""
		    clchv[all_1.iv - 1] = clchb && bit_test(all_1.islur[
			    all_1.iv + (ioff + 1) * 24 - 25],11);
#line 21171 ""
		    if (clchv[all_1.iv - 1]) {

/*  Clef change in this voice.  Turn off signal.  Get space avail. */

#line 21175 ""
			all_1.islur[all_1.iv + (ioff + 1) * 24 - 25] = 
				bit_clear(all_1.islur[all_1.iv + (ioff + 1) * 
				24 - 25],11);
#line 21176 ""
			if ((r__1 = comnsp_2.prevtn[all_1.iv - 1] - 
				comnsp_2.space[comnsp_2.nb - 1], dabs(r__1)) <
				 comtol_1.tol) {
#line 21176 ""
			    ptsndv += combmh_1.clefend * comask_1.wheadpt;
#line 21176 ""
			}
#line 21178 ""
		    }
#line 21179 ""
		}
/* Computing MAX */
#line 21180 ""
		r__1 = ptsndb, r__2 = ptsndv + comask_1.wheadpt * 
			spfacs_1.xspfac;
#line 21180 ""
		ptsndb = dmax(r__1,r__2);
#line 21181 ""
/* L1699: */
#line 21181 ""
	    }
#line 21182 ""
/* L16: */
#line 21182 ""
	}

/* ????  where is nb set???  nb probably in left over from makeabar */

#line 21186 ""
	r__1 = comnsp_2.space[comnsp_2.nb - 1] * squez[comnsp_2.nb - 1];
#line 21186 ""
	esk = feon_(&r__1);
#line 21187 ""
	ptsdflt = esk * comask_1.poenom - comask_1.wheadpt;
#line 21188 ""
	if ((ptsndb > ptsdflt || comnsp_2.ptsgnd > 0.f) && comget_1.movbrk == 
		0 && ! putmbr) {

/*  Must ADD hardspace!  So put in a placeholder, and store params for later. */

#line 21193 ""
	    if (comlast_1.islast) {
#line 21193 ""
		s_wsfe(&io___1395);
/* Writing concatenation */
#line 21193 ""
		i__6[0] = 1, a__4[0] = all_1.sq;
#line 21193 ""
		i__6[1] = 18, a__4[1] = "xardspace{    pt}%";
#line 21193 ""
		s_cat(ch__11, a__4, i__6, &c__2, (ftnlen)19);
#line 21193 ""
		do_fio(&c__1, ch__11, (ftnlen)19);
#line 21193 ""
		e_wsfe();
#line 21193 ""
	    }
#line 21194 ""
	    ++nhssys;
#line 21195 ""
	    if (ptsndb - ptsdflt > comnsp_2.ptsgnd - comask_1.poenom * 
		    comnsp_2.eskgnd) {
#line 21196 ""
		hesk[nhssys - 1] = esk;
#line 21197 ""
		hpts[nhssys - 1] = ptsndb + comask_1.wheadpt;
#line 21198 ""
	    } else {
#line 21199 ""
		hesk[nhssys - 1] = comnsp_2.eskgnd;
#line 21200 ""
		hpts[nhssys - 1] = comnsp_2.ptsgnd + comask_1.wheadpt;
#line 21201 ""
	    }
#line 21202 ""
	    comask_1.fixednew += hpts[nhssys - 1];
#line 21203 ""
	    comask_1.scaldold += hesk[nhssys - 1];
#line 21204 ""
	}
#line 21205 ""
	if (clchb) {
#line 21206 ""
	    i__2 = all_1.nv;
#line 21206 ""
	    for (all_1.iv = 1; all_1.iv <= i__2; ++all_1.iv) {
#line 21207 ""
		if (clchv[all_1.iv - 1]) {
/* Writing concatenation */
#line 21208 ""
		    i__6[0] = 1, a__4[0] = all_1.sq;
#line 21208 ""
		    i__6[1] = 6, a__4[1] = "znotes";
#line 21208 ""
		    s_cat(notexq, a__4, i__6, &c__2, (ftnlen)79);
#line 21209 ""
		    lnote = 7;
#line 21210 ""
		    i__7 = all_1.iv;
#line 21210 ""
		    for (iiv = 2; iiv <= i__7; ++iiv) {
/* Writing concatenation */
#line 21211 ""
			i__6[0] = lnote, a__4[0] = notexq;
#line 21211 ""
			i__6[1] = 1, a__4[1] = all_1.sepsymq + (iiv - 2);
#line 21211 ""
			s_cat(notexq, a__4, i__6, &c__2, (ftnlen)79);
#line 21212 ""
			++lnote;
#line 21213 ""
/* L24: */
#line 21213 ""
		    }

/*  Recompute ioff since it will vary from voice to voice */

#line 21217 ""
		    if (all_1.ibar == 1) {
#line 21218 ""
			ioff = 0;
#line 21219 ""
		    } else {
#line 21220 ""
			ioff = all_1.nib[all_1.iv + (all_1.ibar - 1) * 24 - 
				25];
#line 21221 ""
		    }

/*  Must call clefsym to get nclef, even if there is a movement break */

#line 21225 ""
		    clefsym_(&all_1.islur[all_1.iv + (ioff + 1) * 24 - 25], 
			    fmtq, &lclef, &nclef, (ftnlen)24);

/* If clefq = '8', must change '0' in pos'n 9 to '8' */

#line 21229 ""
		    if (bit_test(all_1.ipl[all_1.iv + (ioff + 1) * 24 - 25],2)
			    ) {
/* Writing concatenation */
#line 21229 ""
			i__8[0] = 8, a__5[0] = fmtq;
#line 21229 ""
			i__8[1] = 1, a__5[1] = "8";
#line 21229 ""
			i__8[2] = 1, a__5[2] = fmtq + 9;
#line 21229 ""
			s_cat(fmtq, a__5, i__8, &c__3, (ftnlen)24);
#line 21229 ""
		    }
#line 21231 ""
		    if (comget_1.movbrk == 0 && comlast_1.islast) {
#line 21231 ""
			s_wsfe(&io___1404);
/* Writing concatenation */
#line 21231 ""
			i__5[0] = lnote, a__3[0] = notexq;
#line 21231 ""
			i__5[1] = lclef, a__3[1] = fmtq;
#line 21231 ""
			i__5[2] = 1, a__3[2] = all_1.sq;
#line 21231 ""
			i__5[3] = 3, a__3[3] = "en%";
#line 21231 ""
			s_cat(ch__12, a__3, i__5, &c__4, (ftnlen)107);
#line 21231 ""
			do_fio(&c__1, ch__12, lnote + lclef + 4);
#line 21231 ""
			e_wsfe();
#line 21231 ""
		    }
#line 21234 ""
		    wsclef_(&all_1.iv, &comnotes_1.ninow, &nclef);

/*  Set new flag to be used just outside this loop, to kluge */
/*    any calls to \CenterBar for full-bar rests, to make room for clef. */

#line 21239 ""
		    newclef = TRUE_;

#line 21241 ""
		    if (bit_test(all_1.ipl[all_1.iv + (ioff + 1) * 24 - 25],2)
			    ) {

/* Find instrument number for voice iv */

#line 21245 ""
			iv1 = 1;
#line 21246 ""
			i__7 = comnotes_1.ninow;
#line 21246 ""
			for (iinst = 1; iinst <= i__7; ++iinst) {
#line 21247 ""
			    if (all_1.iv < iv1 + comnvi_1.nspern[iinst - 1]) {
#line 21247 ""
				goto L2222;
#line 21247 ""
			    }
#line 21248 ""
			    iv1 += comnvi_1.nspern[iinst - 1];
#line 21249 ""
/* L1111: */
#line 21249 ""
			}
#line 21250 ""
			s_wsle(&io___1407);
#line 21250 ""
			e_wsle();
#line 21251 ""
			s_wsle(&io___1408);
#line 21251 ""
			do_lio(&c__9, &c__1, "Should not be here in pmxb!", (
				ftnlen)27);
#line 21251 ""
			e_wsle();
#line 21252 ""
			stop1_();
#line 21253 ""
L2222:
#line 21254 ""
			if (iinst <= 9) {
#line 21255 ""
			    s_wsfe(&io___1409);
/* Writing concatenation */
#line 21255 ""
			    i__6[0] = 1, a__4[0] = all_1.sq;
#line 21255 ""
			    i__6[1] = 19, a__4[1] = "settrebleclefsymbol";
#line 21255 ""
			    s_cat(ch__6, a__4, i__6, &c__2, (ftnlen)20);
#line 21255 ""
			    do_fio(&c__1, ch__6, (ftnlen)20);
#line 21255 ""
			    do_fio(&c__1, (char *)&iinst, (ftnlen)sizeof(
				    integer));
/* Writing concatenation */
#line 21255 ""
			    i__11[0] = 1, a__8[0] = all_1.sq;
#line 21255 ""
			    i__11[1] = 13, a__8[1] = "treblelowoct%";
#line 21255 ""
			    s_cat(ch__10, a__8, i__11, &c__2, (ftnlen)14);
#line 21255 ""
			    do_fio(&c__1, ch__10, (ftnlen)14);
#line 21255 ""
			    e_wsfe();
#line 21257 ""
			} else {
#line 21258 ""
			    s_wsfe(&io___1410);
/* Writing concatenation */
#line 21258 ""
			    i__6[0] = 1, a__4[0] = all_1.sq;
#line 21258 ""
			    i__6[1] = 19, a__4[1] = "settrebleclefsymbol";
#line 21258 ""
			    s_cat(ch__6, a__4, i__6, &c__2, (ftnlen)20);
#line 21258 ""
			    do_fio(&c__1, ch__6, (ftnlen)20);
#line 21258 ""
			    do_fio(&c__1, (char *)&iinst, (ftnlen)sizeof(
				    integer));
/* Writing concatenation */
#line 21258 ""
			    i__11[0] = 1, a__8[0] = all_1.sq;
#line 21258 ""
			    i__11[1] = 13, a__8[1] = "treblelowoct%";
#line 21258 ""
			    s_cat(ch__10, a__8, i__11, &c__2, (ftnlen)14);
#line 21258 ""
			    do_fio(&c__1, ch__10, (ftnlen)14);
#line 21258 ""
			    e_wsfe();
#line 21260 ""
			}
#line 21261 ""
			comc8flag_1.c8flag[all_1.iv - 1] = TRUE_;
#line 21262 ""
		    } else {
#line 21263 ""
			if (*(unsigned char *)&comclefq_1.clefq[all_1.iv - 1] 
				== '8') {
#line 21264 ""
			    s_wsfe(&io___1411);
/* Writing concatenation */
#line 21264 ""
			    i__6[0] = 1, a__4[0] = all_1.sq;
#line 21264 ""
			    i__6[1] = 16, a__4[1] = "resetclefsymbols";
#line 21264 ""
			    s_cat(ch__13, a__4, i__6, &c__2, (ftnlen)17);
#line 21264 ""
			    do_fio(&c__1, ch__13, (ftnlen)17);
#line 21264 ""
			    e_wsfe();
#line 21265 ""
			}
#line 21266 ""
		    }
#line 21267 ""
		}
#line 21268 ""
/* L17: */
#line 21268 ""
	    }
#line 21269 ""
	    if (comlast_1.islast) {
#line 21269 ""
		s_wsfe(&io___1412);
/* Writing concatenation */
#line 21269 ""
		i__6[0] = 1, a__4[0] = all_1.sq;
#line 21269 ""
		i__6[1] = 11, a__4[1] = "pmxnewclefs";
#line 21269 ""
		s_cat(ch__14, a__4, i__6, &c__2, (ftnlen)12);
#line 21269 ""
		do_fio(&c__1, ch__14, (ftnlen)12);
#line 21269 ""
		e_wsfe();
#line 21269 ""
	    }
#line 21270 ""
	}
#line 21271 ""
L23:

/*  Kluge \CenterBar for whole bar rests if necessary */

#line 21275 ""
	if (newclef && comclefrests_1.centrests) {
#line 21276 ""
	    r__1 = all_1.musicsize * .55f;
#line 21276 ""
	    nvalue = i_nint(&r__1);
#line 21277 ""
	    if (nvalue > 10) {
#line 21278 ""
		s_wsfe(&io___1414);
/* Writing concatenation */
#line 21278 ""
		i__5[0] = 1, a__3[0] = all_1.sq;
#line 21278 ""
		i__5[1] = 3, a__3[1] = "def";
#line 21278 ""
		i__5[2] = 1, a__3[2] = all_1.sq;
#line 21278 ""
		i__5[3] = 6, a__3[3] = "value{";
#line 21278 ""
		s_cat(ch__15, a__3, i__5, &c__4, (ftnlen)11);
#line 21278 ""
		do_fio(&c__1, ch__15, (ftnlen)11);
#line 21278 ""
		do_fio(&c__1, (char *)&nvalue, (ftnlen)sizeof(integer));
#line 21278 ""
		do_fio(&c__1, "}%", (ftnlen)2);
#line 21278 ""
		e_wsfe();
#line 21280 ""
	    } else {
#line 21281 ""
		s_wsfe(&io___1415);
/* Writing concatenation */
#line 21281 ""
		i__5[0] = 1, a__3[0] = all_1.sq;
#line 21281 ""
		i__5[1] = 3, a__3[1] = "def";
#line 21281 ""
		i__5[2] = 1, a__3[2] = all_1.sq;
#line 21281 ""
		i__5[3] = 6, a__3[3] = "value{";
#line 21281 ""
		s_cat(ch__15, a__3, i__5, &c__4, (ftnlen)11);
#line 21281 ""
		do_fio(&c__1, ch__15, (ftnlen)11);
#line 21281 ""
		do_fio(&c__1, (char *)&nvalue, (ftnlen)sizeof(integer));
#line 21281 ""
		do_fio(&c__1, "}%", (ftnlen)2);
#line 21281 ""
		e_wsfe();
#line 21283 ""
	    }
#line 21284 ""
	}
#line 21285 ""
	newclef = FALSE_;
#line 21286 ""
	comclefrests_1.centrests = FALSE_;

/*  End of loop for end-of-bar hardspaces and non-movbrk clef symbol. */

#line 21290 ""
	if (comask_1.bar1syst) {
#line 21291 ""
	    s_rsle(&io___1416);
#line 21291 ""
	    do_lio(&c__4, &c__1, (char *)&comask_1.poenom, (ftnlen)sizeof(
		    real));
#line 21291 ""
	    e_rsle();
#line 21292 ""
	}

/*  Repeat symbols.  Haven't slid down yet, so use islur(1,nib(1,ibar-1)+1) */

#line 21296 ""
	if (all_1.ibar == 1) {
#line 21297 ""
	    islnow = all_1.islur[0];
#line 21298 ""
	    iplnow = all_1.ipl[0];
#line 21299 ""
	} else {
#line 21300 ""
	    islnow = all_1.islur[(all_1.nib[(all_1.ibar - 1) * 24 - 24] + 1) *
		     24 - 24];
#line 21301 ""
	    iplnow = all_1.ipl[(all_1.nib[(all_1.ibar - 1) * 24 - 24] + 1) * 
		    24 - 24];
#line 21302 ""
	}

/*  Check for R-symbols set at end of prior input block */

#line 21306 ""
	if (comget_1.movbrk == 0 && *(unsigned char *)comget_1.rptfq2 != 'E') 
		{
#line 21307 ""
	    if (*(unsigned char *)comget_1.rptfq2 == 'D') {
#line 21308 ""
		islnow = bit_set(islnow,26);
#line 21309 ""
	    } else if (*(unsigned char *)comget_1.rptfq2 == 'r') {
#line 21310 ""
		islnow = bit_set(islnow,6);
#line 21311 ""
	    } else if (*(unsigned char *)comget_1.rptfq2 == 'd') {
#line 21312 ""
		islnow = bit_set(islnow,8);
#line 21313 ""
	    } else if (*(unsigned char *)comget_1.rptfq2 == 'b') {
#line 21314 ""
		islnow = bit_set(islnow,25);
#line 21315 ""
	    } else {
#line 21316 ""
		s_wsle(&io___1419);
#line 21316 ""
		e_wsle();
#line 21317 ""
		s_wsle(&io___1420);
#line 21317 ""
		do_lio(&c__9, &c__1, "Illegal symbol with \"R\" at end of in"\
			"put block:", (ftnlen)46);
#line 21317 ""
		do_lio(&c__9, &c__1, comget_1.rptfq2, (ftnlen)1);
#line 21317 ""
		e_wsle();
#line 21319 ""
		stop1_();
#line 21320 ""
	    }
#line 21321 ""
	    *(unsigned char *)comget_1.rptfq2 = 'E';
#line 21322 ""
	}
#line 21323 ""
	if ((islnow & 352) != 0) {

/*  Bit 5(lrpt), 6(rrpt), or 8(doublebar) has been set */

#line 21327 ""
	    lrpt = bit_test(islnow,5);
#line 21328 ""
	    rrpt = bit_test(islnow,6);
#line 21329 ""
	    lrptpend = lrpt && comask_1.bar1syst;
#line 21330 ""
	    if (lrpt && ! lrptpend) {
#line 21331 ""
		if (rrpt) {
#line 21332 ""
		    if (comlast_1.islast) {
#line 21332 ""
			s_wsfe(&io___1423);
/* Writing concatenation */
#line 21332 ""
			i__6[0] = 1, a__4[0] = all_1.sq;
#line 21332 ""
			i__6[1] = 18, a__4[1] = "setleftrightrepeat";
#line 21332 ""
			s_cat(ch__11, a__4, i__6, &c__2, (ftnlen)19);
#line 21332 ""
			do_fio(&c__1, ch__11, (ftnlen)19);
#line 21332 ""
			e_wsfe();
#line 21332 ""
		    }
#line 21333 ""
		    comask_1.fixednew = comask_1.fixednew + comask_1.wheadpt *
			     spfacs_1.lrrptfac - .4f;
#line 21334 ""
		} else {
#line 21335 ""
		    if (comlast_1.islast) {
#line 21335 ""
			s_wsfe(&io___1424);
/* Writing concatenation */
#line 21335 ""
			i__6[0] = 1, a__4[0] = all_1.sq;
#line 21335 ""
			i__6[1] = 13, a__4[1] = "setleftrepeat";
#line 21335 ""
			s_cat(ch__10, a__4, i__6, &c__2, (ftnlen)14);
#line 21335 ""
			do_fio(&c__1, ch__10, (ftnlen)14);
#line 21335 ""
			e_wsfe();
#line 21335 ""
		    }
#line 21336 ""
		    comask_1.fixednew = comask_1.fixednew + comask_1.wheadpt *
			     spfacs_1.rptfac - .4f;
#line 21337 ""
		}
#line 21338 ""
	    } else if (rrpt) {
#line 21339 ""
		if (comlast_1.islast) {
#line 21339 ""
		    s_wsfe(&io___1425);
/* Writing concatenation */
#line 21339 ""
		    i__6[0] = 1, a__4[0] = all_1.sq;
#line 21339 ""
		    i__6[1] = 14, a__4[1] = "setrightrepeat";
#line 21339 ""
		    s_cat(ch__16, a__4, i__6, &c__2, (ftnlen)15);
#line 21339 ""
		    do_fio(&c__1, ch__16, (ftnlen)15);
#line 21339 ""
		    e_wsfe();
#line 21339 ""
		}
#line 21340 ""
		comask_1.fixednew = comask_1.fixednew + comask_1.wheadpt * 
			spfacs_1.rptfac - .4f;
#line 21341 ""
	    } else if (bit_test(islnow,8)) {
#line 21342 ""
		if (comlast_1.islast) {
#line 21342 ""
		    s_wsfe(&io___1426);
/* Writing concatenation */
#line 21342 ""
		    i__6[0] = 1, a__4[0] = all_1.sq;
#line 21342 ""
		    i__6[1] = 12, a__4[1] = "setdoublebar";
#line 21342 ""
		    s_cat(ch__17, a__4, i__6, &c__2, (ftnlen)13);
#line 21342 ""
		    do_fio(&c__1, ch__17, (ftnlen)13);
#line 21342 ""
		    e_wsfe();
#line 21342 ""
		}
#line 21343 ""
		comask_1.fixednew = comask_1.fixednew + comask_1.wheadpt * 
			spfacs_1.dbarfac - .4f;
#line 21344 ""
	    }
#line 21345 ""
	} else if (bit_test(islnow,26)) {

/*  doubleBAR */

#line 21349 ""
	    if (comlast_1.islast) {
#line 21349 ""
		s_wsfe(&io___1427);
/* Writing concatenation */
#line 21349 ""
		i__6[0] = 1, a__4[0] = all_1.sq;
#line 21349 ""
		i__6[1] = 12, a__4[1] = "setdoubleBAR";
#line 21349 ""
		s_cat(ch__17, a__4, i__6, &c__2, (ftnlen)13);
#line 21349 ""
		do_fio(&c__1, ch__17, (ftnlen)13);
#line 21349 ""
		e_wsfe();
#line 21349 ""
	    }
#line 21350 ""
	    comask_1.fixednew = comask_1.fixednew + comask_1.wheadpt * 
		    spfacs_1.ddbarfac - .4f;
#line 21351 ""
	} else if (bit_test(iplnow,0)) {

/*  no bar line */

#line 21355 ""
	    if (comlast_1.islast) {
#line 21356 ""
		if (comget_1.movbrk == 0) {
#line 21357 ""
		    s_wsfe(&io___1428);
/* Writing concatenation */
#line 21357 ""
		    i__6[0] = 1, a__4[0] = all_1.sq;
#line 21357 ""
		    i__6[1] = 12, a__4[1] = "setzalaligne";
#line 21357 ""
		    s_cat(ch__17, a__4, i__6, &c__2, (ftnlen)13);
#line 21357 ""
		    do_fio(&c__1, ch__17, (ftnlen)13);
#line 21357 ""
		    e_wsfe();
#line 21358 ""
		} else {

/*  Encountered "Rz" at start of input block at start of new movement,  Must */
/*    use newmovement macro with arg 4 rather than setzalaligne, since former */
/*    already redefines stoppiece. */

#line 21364 ""
		    *(unsigned char *)comget_1.rptfq2 = 'z';
#line 21365 ""
		}
#line 21366 ""
	    }
#line 21367 ""
	    comask_1.fixednew += -.4f;
#line 21368 ""
	}

/*  1st and 2nd endings */

#line 21372 ""
	svolta = bit_test(islnow,7);
#line 21373 ""
	evolta = bit_test(islnow,9);
#line 21374 ""
	if (evolta) {
#line 21375 ""
	    if (bit_test(islnow,10)) {
#line 21376 ""
		if (comlast_1.islast) {
#line 21376 ""
		    s_wsfe(&io___1431);
/* Writing concatenation */
#line 21376 ""
		    i__6[0] = 1, a__4[0] = all_1.sq;
#line 21376 ""
		    i__6[1] = 11, a__4[1] = "endvoltabox";
#line 21376 ""
		    s_cat(ch__14, a__4, i__6, &c__2, (ftnlen)12);
#line 21376 ""
		    do_fio(&c__1, ch__14, (ftnlen)12);
#line 21376 ""
		    e_wsfe();
#line 21376 ""
		}
#line 21377 ""
	    } else {
#line 21378 ""
		if (comlast_1.islast) {
#line 21378 ""
		    s_wsfe(&io___1432);
/* Writing concatenation */
#line 21378 ""
		    i__6[0] = 1, a__4[0] = all_1.sq;
#line 21378 ""
		    i__6[1] = 8, a__4[1] = "endvolta";
#line 21378 ""
		    s_cat(ch__18, a__4, i__6, &c__2, (ftnlen)9);
#line 21378 ""
		    do_fio(&c__1, ch__18, (ftnlen)9);
#line 21378 ""
		    e_wsfe();
#line 21378 ""
		}
#line 21379 ""
	    }
#line 21380 ""
	    onvolt = FALSE_;
#line 21381 ""
	}
#line 21382 ""
	if (svolta) {
#line 21383 ""
	    ++comgrace_1.nvolt;
#line 21384 ""
	    lvoltxt = i_indx(comgrace_1.voltxtq + (comgrace_1.nvolt - 1) * 20,
		     " ", (ftnlen)20, (ftnlen)1) - 1;
#line 21385 ""
	    if (lvoltxt == 1) {
#line 21386 ""
		if (comlast_1.islast) {
#line 21386 ""
		    s_wsfe(&io___1434);
/* Writing concatenation */
#line 21386 ""
		    i__5[0] = 1, a__3[0] = all_1.sq;
#line 21386 ""
		    i__5[1] = 8, a__3[1] = "Setvolta";
#line 21386 ""
		    i__5[2] = 1, a__3[2] = comgrace_1.voltxtq + (
			    comgrace_1.nvolt - 1) * 20;
#line 21386 ""
		    i__5[3] = 1, a__3[3] = "%";
#line 21386 ""
		    s_cat(ch__15, a__3, i__5, &c__4, (ftnlen)11);
#line 21386 ""
		    do_fio(&c__1, ch__15, (ftnlen)11);
#line 21386 ""
		    e_wsfe();
#line 21386 ""
		}
#line 21388 ""
	    } else {
#line 21389 ""
		if (comlast_1.islast) {
#line 21389 ""
		    s_wsfe(&io___1435);
/* Writing concatenation */
#line 21389 ""
		    i__12[0] = 1, a__9[0] = all_1.sq;
#line 21389 ""
		    i__12[1] = 8, a__9[1] = "Setvolta";
#line 21389 ""
		    i__12[2] = 1, a__9[2] = "{";
#line 21389 ""
		    i__12[3] = lvoltxt, a__9[3] = comgrace_1.voltxtq + (
			    comgrace_1.nvolt - 1) * 20;
#line 21389 ""
		    i__12[4] = 2, a__9[4] = "}%";
#line 21389 ""
		    s_cat(ch__19, a__9, i__12, &c__5, (ftnlen)32);
#line 21389 ""
		    do_fio(&c__1, ch__19, lvoltxt + 12);
#line 21389 ""
		    e_wsfe();
#line 21389 ""
		}
#line 21391 ""
	    }
#line 21392 ""
	    onvolt = TRUE_;
#line 21393 ""
	}
#line 21394 ""
	if (all_1.ibar > 1) {
#line 21395 ""
	    ipnow = all_1.nib[(all_1.ibar - 1) * 24 - 24] + 1;
#line 21396 ""
	} else {
#line 21397 ""
	    ipnow = 1;
#line 21398 ""
	}
#line 21399 ""
	iplnow = all_1.ipl[ipnow * 24 - 24];
#line 21400 ""
	if (comask_1.bar1syst) {

/*  If listslur>0, then there is at least one slur or tie carried over the break */

#line 21404 ""
	    ispstie = FALSE_;
#line 21405 ""
	    if (comnotes_1.optlinebreakties && ! comslur_1.fontslur && 
		    comslur_1.listslur != 0 && comlast_1.islast) {
#line 21405 ""
		linebreakties_(all_1.isdat1, all_1.isdat2, all_1.isdat3, 
			all_1.isdat4, &all_1.nsdat, &ispstie, all_1.sepsymq, (
			ftnlen)1);
#line 21405 ""
	    }
#line 21409 ""
	    ++all_1.iline;

/*  End an old system, Start a new system */

/*  Reduce space before mbrest at start of system */
/*  Need this even if no accidentals in key signature */

#line 21416 ""
	    if (all_1.ibar == comgrace_1.ibarmbr) {
#line 21416 ""
		comgrace_1.xb4mbr = all_1.musicsize * -.2f;
#line 21416 ""
	    }

#line 21418 ""
	    if (all_1.iline != 1) {

/*  Not first line. */
/*  Get corrected poe = points/elemskip for *previous* system */

#line 21423 ""
		wdpt = comtop_1.widthpt * (1 - comtop_1.fracindent);
#line 21424 ""
		poe = (wdpt - fsyst * all_1.musicsize - nbarss * .4f - 
			comask_1.fixednew) / (elsktot + comask_1.fbar * 
			nbarss - comask_1.scaldold);
#line 21426 ""
		++isyscnt;
#line 21427 ""
		poevec[isyscnt] = poe;

/*  Transfer data for system into global arrays to hold until very end */

#line 21431 ""
		i__2 = comas2_1.nasksys;
#line 21431 ""
		for (ia = 1; ia <= i__2; ++ia) {
#line 21432 ""
		    ++comas3_1.iask;
#line 21433 ""
		    comas3_1.ask[comas3_1.iask - 1] = (comas2_1.wasksys[ia - 
			    1] / poe - (r__1 = comas2_1.elasksys[ia - 1], 
			    dabs(r__1))) / comshort_1.poefa[all_1.iline - 2];

/*  Only admit negative ask if it was user-defined space, signalled by elask<=0. */

#line 21438 ""
		    if (comas2_1.elasksys[ia - 1] > 0.f) {
#line 21438 ""
			comas3_1.ask[comas3_1.iask - 1] = r_dim(&comas3_1.ask[
				comas3_1.iask - 1], &c_b1020);
#line 21438 ""
		    }
#line 21439 ""
/* L9: */
#line 21439 ""
		}
#line 21440 ""
		i__2 = nhssys;
#line 21440 ""
		for (ia = 1; ia <= i__2; ++ia) {
#line 21441 ""
		    ++nhstot;
/* Computing MAX */
#line 21442 ""
		    r__1 = hpts[ia - 1] - hesk[ia - 1] * poe;
#line 21442 ""
		    comhsp_1.hpttot[nhstot - 1] = dmax(r__1,0.f);
#line 21443 ""
/* L25: */
#line 21443 ""
		}

/*  Reset counters for new system */

#line 21447 ""
		comask_1.scaldold = 0.f;
#line 21448 ""
		comask_1.fixednew = 0.f;
#line 21449 ""
		comas2_1.nasksys = 0;
#line 21450 ""
		nhssys = 0;
#line 21451 ""
	    }

/*  End of if block for first bar of non-first system. Still 1st bar, any system */

#line 21455 ""
	    if (comlast_1.islast && all_1.figbass) {
#line 21455 ""
		s_wsfe(&io___1444);
/* Writing concatenation */
#line 21455 ""
		i__6[0] = 1, a__4[0] = all_1.sq;
#line 21455 ""
		i__6[1] = 8, a__4[1] = "fixdrop%";
#line 21455 ""
		s_cat(ch__18, a__4, i__6, &c__2, (ftnlen)9);
#line 21455 ""
		do_fio(&c__1, ch__18, (ftnlen)9);
#line 21455 ""
		e_wsfe();
#line 21455 ""
	    }
#line 21456 ""
	    ++isystpg;

/*  Try moving the next stmt way down, to fix a bug and get \eject printed at */
/*  end of single-system page. */
/*          if (isystpg .eq. nsystp(ipage)) isystpg = 0 */
#line 21461 ""
	    s_rsle(&io___1445);
#line 21461 ""
	    do_lio(&c__3, &c__1, (char *)&nbarss, (ftnlen)sizeof(integer));
#line 21461 ""
	    do_lio(&c__4, &c__1, (char *)&elsktot, (ftnlen)sizeof(real));
#line 21461 ""
	    do_lio(&c__4, &c__1, (char *)&fsyst, (ftnlen)sizeof(real));
#line 21461 ""
	    do_lio(&c__4, &c__1, (char *)&frac, (ftnlen)sizeof(real));
#line 21461 ""
	    do_lio(&c__4, &c__1, (char *)&comeon_1.eonk, (ftnlen)sizeof(real))
		    ;
#line 21461 ""
	    do_lio(&c__4, &c__1, (char *)&comeon_1.ewmxk, (ftnlen)sizeof(real)
		    );
#line 21461 ""
	    e_rsle();
#line 21462 ""
	    if (all_1.iline > 1) {
#line 21462 ""
		comtop_1.fracindent = frac;
#line 21462 ""
	    }
#line 21463 ""
	    if (all_1.figbass) {
#line 21464 ""
		all_1.ifigdr[(all_1.iline << 1) - 2] = 4;
#line 21465 ""
		all_1.ifigdr[(all_1.iline << 1) - 1] = 4;
#line 21466 ""
	    }
#line 21467 ""
	    all_1.slfac = slfac1 * all_1.musicsize * elsktot;
#line 21468 ""
	    if (all_1.iline != 1) {

/*  For the line just _finished_, put figdrop in separate file. */

#line 21472 ""
		if (all_1.figbass) {
#line 21472 ""
		    s_wsfe(&io___1447);
/* Writing concatenation */
#line 21472 ""
		    i__6[0] = 1, a__4[0] = all_1.sq;
#line 21472 ""
		    i__6[1] = 8, a__4[1] = "figdrop=";
#line 21472 ""
		    s_cat(ch__18, a__4, i__6, &c__2, (ftnlen)9);
#line 21472 ""
		    do_fio(&c__1, ch__18, (ftnlen)9);
#line 21472 ""
		    do_fio(&c__1, (char *)&all_1.ifigdr[(all_1.iline - 1 << 1)
			     - 2], (ftnlen)sizeof(integer));
/* Writing concatenation */
#line 21472 ""
		    i__8[0] = 1, a__5[0] = " ";
#line 21472 ""
		    i__8[1] = 1, a__5[1] = all_1.sq;
#line 21472 ""
		    i__8[2] = 8, a__5[2] = "figdtwo=";
#line 21472 ""
		    s_cat(ch__20, a__5, i__8, &c__3, (ftnlen)10);
#line 21472 ""
		    do_fio(&c__1, ch__20, (ftnlen)10);
#line 21472 ""
		    do_fio(&c__1, (char *)&all_1.ifigdr[(all_1.iline - 1 << 1)
			     - 1], (ftnlen)sizeof(integer));
/* Writing concatenation */
#line 21472 ""
		    i__11[0] = 1, a__8[0] = all_1.sq;
#line 21472 ""
		    i__11[1] = 3, a__8[1] = "or%";
#line 21472 ""
		    s_cat(ch__21, a__8, i__11, &c__2, (ftnlen)4);
#line 21472 ""
		    do_fio(&c__1, ch__21, (ftnlen)4);
#line 21472 ""
		    e_wsfe();
#line 21472 ""
		}

/*  Check slurs in top staff for interference w/ barno. Only check when */
/*  # if digits in barno >= |isig|  But to keep on/off phasing, must ALWAYS */
/*  keep track of ons and offs when |isig|<=3. */

#line 21480 ""
		r__1 = combibarcnt_1.ibarcnt + ibcoff + .01f;
#line 21480 ""
		ndigbn = (integer) r_lg10(&r__1) + 1;
#line 21481 ""
		comsln_1.isnx = 0;
#line 21482 ""
		if (ndigbn >= abs(comtop_1.isig) && comsln_1.is1n1 > 0) {

/*  There's a slur in top voice over the line break, hgt=is1n1, idcode=is2n1 */
/*  Look for termination in remainder of this input block.  If not found, */
/*  just use is1n1.  Remember, haven't slid down yet. */

#line 21488 ""
		    ioff = 0;
#line 21489 ""
		    if (all_1.ibar > 1) {
#line 21489 ""
			ioff = all_1.nib[commvl_1.ivmx[all_1.nv + 
				commvl_1.nvmx[all_1.nv - 1] * 24 - 25] + (
				all_1.ibar - 1) * 24 - 25];
#line 21489 ""
		    }
#line 21490 ""
		    i__2 = all_1.nsdat;
#line 21490 ""
		    for (isdat = 1; isdat <= i__2; ++isdat) {
#line 21491 ""
			if (igetbits_(&all_1.isdat1[isdat - 1], &c__5, &c__13)
				 == commvl_1.ivmx[all_1.nv + commvl_1.nvmx[
				all_1.nv - 1] * 24 - 25] && ! bit_test(
				all_1.isdat1[isdat - 1],11) && igetbits_(&
				all_1.isdat1[isdat - 1], &c__7, &c__19) == 
				comsln_1.is2n1) {

/*  Found slur ending.  Just check note height, can't do fine adjustments. */

/* Computing MAX */
#line 21497 ""
			    i__7 = comsln_1.is1n1, i__13 = igetbits_(&
				    all_1.isdat2[isdat - 1], &c__7, &c__19);
#line 21497 ""
			    comsln_1.is1n1 = max(i__7,i__13);
#line 21498 ""
			    goto L51;
#line 21499 ""
			}
#line 21500 ""
/* L50: */
#line 21500 ""
		    }

/*  If exiting loop normally, did not find end of slur.  c'est la vie. */

#line 21504 ""
L51:
#line 21505 ""
		    i__2 = ncmid_(&all_1.nv, &c__1) + 1 + comsln_1.irzbnd;
#line 21505 ""
		    comsln_1.isnx = i_dim(&comsln_1.is1n1, &i__2);
#line 21506 ""
		    if (comsln_1.isnx > 0) {

/*  AHA! Slur likely to interfere with barno. */

/*  Modified 090525 to use \bnrs */

#line 21512 ""
			slint = TRUE_;
#line 21513 ""
			s_copy(fmtq, "(a16,i1,a14)", (ftnlen)24, (ftnlen)12);
#line 21514 ""
			if (comsln_1.irzbnd + comsln_1.isnx > 9) {
#line 21514 ""
			    s_copy(fmtq, "(a16,i2,a14)", (ftnlen)24, (ftnlen)
				    12);
#line 21514 ""
			}
#line 21515 ""
			if (comlast_1.islast) {
#line 21515 ""
			    s_wsfe(&io___1450);
/* Writing concatenation */
#line 21515 ""
			    i__5[0] = 1, a__3[0] = all_1.sq;
#line 21515 ""
			    i__5[1] = 3, a__3[1] = "def";
#line 21515 ""
			    i__5[2] = 1, a__3[2] = all_1.sq;
#line 21515 ""
			    i__5[3] = 11, a__3[3] = "raisebarno{";
#line 21515 ""
			    s_cat(ch__22, a__3, i__5, &c__4, (ftnlen)16);
#line 21515 ""
			    do_fio(&c__1, ch__22, (ftnlen)16);
#line 21515 ""
			    i__2 = comsln_1.irzbnd + comsln_1.isnx;
#line 21515 ""
			    do_fio(&c__1, (char *)&i__2, (ftnlen)sizeof(
				    integer));
/* Writing concatenation */
#line 21515 ""
			    i__8[0] = 2, a__5[0] = ".5";
#line 21515 ""
			    i__8[1] = 1, a__5[1] = all_1.sq;
#line 21515 ""
			    i__8[2] = 11, a__5[2] = "internote}%";
#line 21515 ""
			    s_cat(ch__10, a__5, i__8, &c__3, (ftnlen)14);
#line 21515 ""
			    do_fio(&c__1, ch__10, (ftnlen)14);
#line 21515 ""
			    e_wsfe();
#line 21515 ""
			}
#line 21517 ""
		    }
#line 21518 ""
		}
#line 21519 ""
		if (comget_1.movbrk > 0) {

/*              movbrk = 0 */
/*  Move the reset down, so can use movbrk>0 to stop extra meter prints. */

/*  New movement.  Redefine stoppiece, contpiece.  These will be called either */
/*     explicitly or as part of alaligne. */
/*  indsym = 0,1,2 for doubleBAR , doublebar, rightrepeat. */
/*     This is passed to \newmovement. */

#line 21529 ""
		    if (*(unsigned char *)comget_1.rptfq2 == 'E') {
#line 21529 ""
			*(unsigned char *)comget_1.rptfq2 = 'D';
#line 21529 ""
		    }
#line 21530 ""
		    indsym = i_indx("Ddrbz", comget_1.rptfq2, (ftnlen)5, (
			    ftnlen)1) - 1;
#line 21531 ""
		    *(unsigned char *)comget_1.rptfq2 = 'E';

/*  Also check for Rd or Rr set the normal way */

#line 21535 ""
		    if (bit_test(islnow,8)) {
#line 21536 ""
			indsym = 1;
#line 21537 ""
		    } else if (bit_test(islnow,6)) {
#line 21538 ""
			indsym = 2;
#line 21539 ""
		    }
#line 21540 ""
		    if (indsym < 0) {
#line 21541 ""
			s_wsle(&io___1452);
#line 21541 ""
			e_wsle();
#line 21542 ""
			s_wsle(&io___1453);
#line 21542 ""
			do_lio(&c__9, &c__1, "Illegal end symbol before \"/\""
				, (ftnlen)29);
#line 21542 ""
			e_wsle();
#line 21543 ""
			stop1_();
#line 21544 ""
		    }

/*  Check for continuation (no bar number reset) */

#line 21548 ""
		    if (comlast_1.islast && comnotes_1.nobar1) {
#line 21549 ""
			s_wsfe(&io___1454);
/* Writing concatenation */
#line 21549 ""
			i__9[0] = 1, a__6[0] = all_1.sq;
#line 21549 ""
			i__9[1] = 7, a__6[1] = "advance";
#line 21549 ""
			i__9[2] = 1, a__6[2] = all_1.sq;
#line 21549 ""
			i__9[3] = 6, a__6[3] = "barno1";
#line 21549 ""
			i__9[4] = 1, a__6[4] = all_1.sq;
#line 21549 ""
			i__9[5] = 6, a__6[5] = "global";
#line 21549 ""
			i__9[6] = 1, a__6[6] = all_1.sq;
#line 21549 ""
			i__9[7] = 10, a__6[7] = "startbarno";
#line 21549 ""
			i__9[8] = 1, a__6[8] = all_1.sq;
#line 21549 ""
			i__9[9] = 6, a__6[9] = "barno%";
#line 21549 ""
			s_cat(ch__23, a__6, i__9, &c__10, (ftnlen)40);
#line 21549 ""
			do_fio(&c__1, ch__23, (ftnlen)40);
#line 21549 ""
			e_wsfe();

/*  Need above for shortening case mcm with Mc */

#line 21554 ""
		    }

/* Per Rainer's suggestion, changing \nbinstruments via 3rd arg of \newmovement */

#line 21558 ""
		    if (comlast_1.islast) {
/* Writing concatenation */
#line 21559 ""
			i__6[0] = 1, a__4[0] = all_1.sq;
#line 21559 ""
			i__6[1] = 11, a__4[1] = "newmovement";
#line 21559 ""
			s_cat(nmq, a__4, i__6, &c__2, (ftnlen)40);
#line 21560 ""
			lnmq = 12;
#line 21561 ""
			if (comget_1.movgap < 10) {
#line 21562 ""
			    lnmq = 14;
#line 21563 ""
			    s_wsfi(&io___1457);
#line 21563 ""
			    do_fio(&c__1, (char *)&comget_1.movgap, (ftnlen)
				    sizeof(integer));
#line 21563 ""
			    do_fio(&c__1, (char *)&indsym, (ftnlen)sizeof(
				    integer));
#line 21563 ""
			    e_wsfi();
#line 21564 ""
			} else {
#line 21565 ""
			    lnmq = 17;
#line 21566 ""
			    s_wsfi(&io___1458);
#line 21566 ""
			    do_fio(&c__1, "{", (ftnlen)1);
#line 21566 ""
			    do_fio(&c__1, (char *)&comget_1.movgap, (ftnlen)
				    sizeof(integer));
#line 21566 ""
			    do_fio(&c__1, "}", (ftnlen)1);
#line 21566 ""
			    do_fio(&c__1, (char *)&indsym, (ftnlen)sizeof(
				    integer));
#line 21566 ""
			    e_wsfi();
#line 21567 ""
			}
#line 21568 ""
			if (comnotes_1.ninow < 10) {
#line 21569 ""
			    ++lnmq;
#line 21570 ""
			    ici__1.icierr = 0;
#line 21570 ""
			    ici__1.icirnum = 1;
#line 21570 ""
			    ici__1.icirlen = 1;
#line 21570 ""
			    ici__1.iciunit = nmq + (lnmq - 1);
#line 21570 ""
			    ici__1.icifmt = "(i1)";
#line 21570 ""
			    s_wsfi(&ici__1);
#line 21570 ""
			    do_fio(&c__1, (char *)&comnotes_1.ninow, (ftnlen)
				    sizeof(integer));
#line 21570 ""
			    e_wsfi();
#line 21571 ""
			} else {
#line 21572 ""
			    lnmq += 4;
#line 21573 ""
			    i__2 = lnmq - 4;
#line 21573 ""
			    ici__1.icierr = 0;
#line 21573 ""
			    ici__1.icirnum = 1;
#line 21573 ""
			    ici__1.icirlen = lnmq - i__2;
#line 21573 ""
			    ici__1.iciunit = nmq + i__2;
#line 21573 ""
			    ici__1.icifmt = "(a1,i2,a1)";
#line 21573 ""
			    s_wsfi(&ici__1);
#line 21573 ""
			    do_fio(&c__1, "{", (ftnlen)1);
#line 21573 ""
			    do_fio(&c__1, (char *)&comnotes_1.ninow, (ftnlen)
				    sizeof(integer));
#line 21573 ""
			    do_fio(&c__1, "}", (ftnlen)1);
#line 21573 ""
			    e_wsfi();
#line 21574 ""
			}
#line 21575 ""
			++lnmq;
#line 21576 ""
			ici__1.icierr = 0;
#line 21576 ""
			ici__1.icirnum = 1;
#line 21576 ""
			ici__1.icirlen = 1;
#line 21576 ""
			ici__1.iciunit = nmq + (lnmq - 1);
#line 21576 ""
			ici__1.icifmt = "(a1)";
#line 21576 ""
			s_wsfi(&ici__1);
#line 21576 ""
			do_fio(&c__1, "%", (ftnlen)1);
#line 21576 ""
			e_wsfi();
#line 21577 ""
			if (comshort_1.ishort == 4) {

/* Ending Short-blank-coda */

#line 21581 ""
			    s_wsfe(&io___1459);
/* Writing concatenation */
#line 21581 ""
			    i__6[0] = 1, a__4[0] = all_1.sq;
#line 21581 ""
			    i__6[1] = 11, a__4[1] = "Endpiece}}%";
#line 21581 ""
			    s_cat(ch__14, a__4, i__6, &c__2, (ftnlen)12);
#line 21581 ""
			    do_fio(&c__1, ch__14, (ftnlen)12);
#line 21581 ""
			    e_wsfe();
#line 21582 ""
			}
#line 21583 ""
			s_wsfe(&io___1460);
#line 21583 ""
			do_fio(&c__1, nmq, lnmq);
#line 21583 ""
			e_wsfe();
#line 21584 ""
			if (comshort_1.ishort == 2) {
#line 21585 ""
			    s_wsfe(&io___1461);
/* Writing concatenation */
#line 21585 ""
			    i__6[0] = 1, a__4[0] = all_1.sq;
#line 21585 ""
			    i__6[1] = 12, a__4[1] = "stoppiece}}%";
#line 21585 ""
			    s_cat(ch__17, a__4, i__6, &c__2, (ftnlen)13);
#line 21585 ""
			    do_fio(&c__1, ch__17, (ftnlen)13);
#line 21585 ""
			    e_wsfe();
#line 21586 ""
			    comshort_1.ishort = 5;
#line 21587 ""
			} else if (comshort_1.ishort == 4) {
#line 21588 ""
			    s_wsfe(&io___1462);
/* Writing concatenation */
#line 21588 ""
			    i__4[0] = 1, a__2[0] = all_1.sq;
#line 21588 ""
			    i__4[1] = 3, a__2[1] = "let";
#line 21588 ""
			    i__4[2] = 1, a__2[2] = all_1.sq;
#line 21588 ""
			    i__4[3] = 9, a__2[3] = "stoppiece";
#line 21588 ""
			    i__4[4] = 1, a__2[4] = all_1.sq;
#line 21588 ""
			    i__4[5] = 9, a__2[5] = "holdstop%";
#line 21588 ""
			    s_cat(ch__24, a__2, i__4, &c__6, (ftnlen)24);
#line 21588 ""
			    do_fio(&c__1, ch__24, (ftnlen)24);
#line 21588 ""
			    e_wsfe();

/*  Since we bypass newmovement, need to set the vertical gap. */

#line 21593 ""
			    if (comget_1.movgap > 10) {
#line 21594 ""
				s_wsfe(&io___1463);
/* Writing concatenation */
#line 21594 ""
				i__6[0] = 1, a__4[0] = all_1.sq;
#line 21594 ""
				i__6[1] = 5, a__4[1] = "vskip";
#line 21594 ""
				s_cat(ch__25, a__4, i__6, &c__2, (ftnlen)6);
#line 21594 ""
				do_fio(&c__1, ch__25, (ftnlen)6);
#line 21594 ""
				do_fio(&c__1, (char *)&comget_1.movgap, (
					ftnlen)sizeof(integer));
/* Writing concatenation */
#line 21594 ""
				i__11[0] = 1, a__8[0] = all_1.sq;
#line 21594 ""
				i__11[1] = 10, a__8[1] = "internote%";
#line 21594 ""
				s_cat(ch__15, a__8, i__11, &c__2, (ftnlen)11);
#line 21594 ""
				do_fio(&c__1, ch__15, (ftnlen)11);
#line 21594 ""
				e_wsfe();
#line 21596 ""
			    } else if (comget_1.movgap > 0) {
#line 21597 ""
				s_wsfe(&io___1464);
/* Writing concatenation */
#line 21597 ""
				i__6[0] = 1, a__4[0] = all_1.sq;
#line 21597 ""
				i__6[1] = 5, a__4[1] = "vskip";
#line 21597 ""
				s_cat(ch__25, a__4, i__6, &c__2, (ftnlen)6);
#line 21597 ""
				do_fio(&c__1, ch__25, (ftnlen)6);
#line 21597 ""
				do_fio(&c__1, (char *)&comget_1.movgap, (
					ftnlen)sizeof(integer));
/* Writing concatenation */
#line 21597 ""
				i__11[0] = 1, a__8[0] = all_1.sq;
#line 21597 ""
				i__11[1] = 10, a__8[1] = "internote%";
#line 21597 ""
				s_cat(ch__15, a__8, i__11, &c__2, (ftnlen)11);
#line 21597 ""
				do_fio(&c__1, ch__15, (ftnlen)11);
#line 21597 ""
				e_wsfe();
#line 21599 ""
			    }
#line 21600 ""
			    comshort_1.ishort = 6;
#line 21601 ""
			}
#line 21602 ""
			if ((comshort_1.ishort == 5 || comshort_1.ishort == 6)
				 && ! comnvi_1.rename) {
#line 21603 ""
			    i__2 = comnotes_1.ninow;
#line 21603 ""
			    for (iinst = 1; iinst <= i__2; ++iinst) {
#line 21604 ""
				if (comlast_1.islast) {
#line 21605 ""
				    if (iinst < 10) {
#line 21606 ""
					s_wsfe(&io___1465);
/* Writing concatenation */
#line 21606 ""
					i__6[0] = 1, a__4[0] = all_1.sq;
#line 21606 ""
					i__6[1] = 7, a__4[1] = "setname";
#line 21606 ""
					s_cat(ch__8, a__4, i__6, &c__2, (
						ftnlen)8);
#line 21606 ""
					do_fio(&c__1, ch__8, (ftnlen)8);
#line 21606 ""
					do_fio(&c__1, (char *)&iinst, (ftnlen)
						sizeof(integer));
#line 21606 ""
					do_fio(&c__1, "{}%", (ftnlen)3);
#line 21606 ""
					e_wsfe();
#line 21607 ""
				    } else {
#line 21608 ""
					s_wsfe(&io___1466);
/* Writing concatenation */
#line 21608 ""
					i__6[0] = 1, a__4[0] = all_1.sq;
#line 21608 ""
					i__6[1] = 8, a__4[1] = "setname{";
#line 21608 ""
					s_cat(ch__18, a__4, i__6, &c__2, (
						ftnlen)9);
#line 21608 ""
					do_fio(&c__1, ch__18, (ftnlen)9);
#line 21608 ""
					do_fio(&c__1, (char *)&iinst, (ftnlen)
						sizeof(integer));
#line 21608 ""
					do_fio(&c__1, "}{}%", (ftnlen)4);
#line 21608 ""
					e_wsfe();
#line 21610 ""
				    }
#line 21611 ""
				}
#line 21612 ""
/* L62: */
#line 21612 ""
			    }
#line 21613 ""
			}
#line 21614 ""
			comnvi_1.rename = FALSE_;
#line 21615 ""
		    }

/*  Change generalmeter if necessary */

#line 21619 ""
		    if (comlast_1.islast) {
#line 21620 ""
			wgmeter_(&all_1.mtrnmp, &all_1.mtrdnp);
#line 21621 ""
		    }
/* Removed next line 211207 to fix beaming problem at new movement+meter change. */
/*              mtrnuml = 0 */

/*  (Moved all name-writing to getnote, right when 'M' is detected) */

#line 21627 ""
		    if (bit_test(iplnow,28)) {

/*  Key signature at movement break */

#line 21631 ""
			iplnow = bit_clear(iplnow,28);
#line 21632 ""
			if (comtop_1.isig > 0) {
#line 21633 ""
			    if (comlast_1.islast) {
#line 21633 ""
				s_wsfe(&io___1467);
/* Writing concatenation */
#line 21633 ""
				i__6[0] = 1, a__4[0] = all_1.sq;
#line 21633 ""
				i__6[1] = 17, a__4[1] = "generalsignature{";
#line 21633 ""
				s_cat(ch__26, a__4, i__6, &c__2, (ftnlen)18);
#line 21633 ""
				do_fio(&c__1, ch__26, (ftnlen)18);
#line 21633 ""
				do_fio(&c__1, (char *)&comtop_1.isig, (ftnlen)
					sizeof(integer));
#line 21633 ""
				do_fio(&c__1, "}%", (ftnlen)2);
#line 21633 ""
				e_wsfe();
#line 21633 ""
			    }
#line 21635 ""
			} else {
#line 21636 ""
			    if (comlast_1.islast) {
#line 21636 ""
				s_wsfe(&io___1468);
/* Writing concatenation */
#line 21636 ""
				i__6[0] = 1, a__4[0] = all_1.sq;
#line 21636 ""
				i__6[1] = 17, a__4[1] = "generalsignature{";
#line 21636 ""
				s_cat(ch__26, a__4, i__6, &c__2, (ftnlen)18);
#line 21636 ""
				do_fio(&c__1, ch__26, (ftnlen)18);
#line 21636 ""
				do_fio(&c__1, (char *)&comtop_1.isig, (ftnlen)
					sizeof(integer));
#line 21636 ""
				do_fio(&c__1, "}%", (ftnlen)2);
#line 21636 ""
				e_wsfe();
#line 21636 ""
			    }
#line 21638 ""
			}
#line 21639 ""
			if (comlast_1.islast && cominsttrans_1.laterinsttrans)
				 {
#line 21640 ""
			    writesetsign_(&cominsttrans_1.ninsttrans, 
				    cominsttrans_1.iinsttrans, 
				    cominsttrans_1.itranskey, &
				    cominsttrans_1.laterinsttrans);
#line 21642 ""
			}
#line 21643 ""
		    }
#line 21644 ""
		    if (comget_1.parmov >= -.1f) {

/*  Resent paragraph indentation */

#line 21648 ""
			ipi = comget_1.parmov * comtop_1.widthpt + .1f;
#line 21649 ""
			if (ipi < 10) {
#line 21650 ""
			    if (comlast_1.islast) {
#line 21650 ""
				s_wsfe(&io___1470);
/* Writing concatenation */
#line 21650 ""
				i__6[0] = 1, a__4[0] = all_1.sq;
#line 21650 ""
				i__6[1] = 10, a__4[1] = "parindent ";
#line 21650 ""
				s_cat(ch__15, a__4, i__6, &c__2, (ftnlen)11);
#line 21650 ""
				do_fio(&c__1, ch__15, (ftnlen)11);
#line 21650 ""
				do_fio(&c__1, (char *)&ipi, (ftnlen)sizeof(
					integer));
#line 21650 ""
				do_fio(&c__1, "pt", (ftnlen)2);
#line 21650 ""
				e_wsfe();
#line 21650 ""
			    }
#line 21652 ""
			} else if (ipi < 100) {
#line 21653 ""
			    if (comlast_1.islast) {
#line 21653 ""
				s_wsfe(&io___1471);
/* Writing concatenation */
#line 21653 ""
				i__6[0] = 1, a__4[0] = all_1.sq;
#line 21653 ""
				i__6[1] = 10, a__4[1] = "parindent ";
#line 21653 ""
				s_cat(ch__15, a__4, i__6, &c__2, (ftnlen)11);
#line 21653 ""
				do_fio(&c__1, ch__15, (ftnlen)11);
#line 21653 ""
				do_fio(&c__1, (char *)&ipi, (ftnlen)sizeof(
					integer));
#line 21653 ""
				do_fio(&c__1, "pt", (ftnlen)2);
#line 21653 ""
				e_wsfe();
#line 21653 ""
			    }
#line 21655 ""
			} else {
#line 21656 ""
			    if (comlast_1.islast) {
#line 21656 ""
				s_wsfe(&io___1472);
/* Writing concatenation */
#line 21656 ""
				i__6[0] = 1, a__4[0] = all_1.sq;
#line 21656 ""
				i__6[1] = 10, a__4[1] = "parindent ";
#line 21656 ""
				s_cat(ch__15, a__4, i__6, &c__2, (ftnlen)11);
#line 21656 ""
				do_fio(&c__1, ch__15, (ftnlen)11);
#line 21656 ""
				do_fio(&c__1, (char *)&ipi, (ftnlen)sizeof(
					integer));
#line 21656 ""
				do_fio(&c__1, "pt", (ftnlen)2);
#line 21656 ""
				e_wsfe();
#line 21656 ""
			    }
#line 21658 ""
			}
#line 21659 ""
		    }
#line 21660 ""
		    if (comshort_1.ishort == 6) {
#line 21661 ""
			if (iflagbot == 1) {
#line 21662 ""
			    s_wsfe(&io___1473);
/* Writing concatenation */
#line 21662 ""
			    i__5[0] = 1, a__3[0] = all_1.sq;
#line 21662 ""
			    i__5[1] = 5, a__3[1] = "vfill";
#line 21662 ""
			    i__5[2] = 1, a__3[2] = all_1.sq;
#line 21662 ""
			    i__5[3] = 5, a__3[3] = "eject";
#line 21662 ""
			    s_cat(ch__14, a__3, i__5, &c__4, (ftnlen)12);
#line 21662 ""
			    do_fio(&c__1, ch__14, (ftnlen)12);
#line 21662 ""
			    e_wsfe();
/*                  iflagbot = 0 */
/*                  ishort = 0 */
#line 21665 ""
			} else {
#line 21666 ""
			    s_wsfe(&io___1474);
/* Writing concatenation */
#line 21666 ""
			    i__6[0] = 1, a__4[0] = all_1.sq;
#line 21666 ""
			    i__6[1] = 9, a__4[1] = "contpiece";
#line 21666 ""
			    s_cat(ch__20, a__4, i__6, &c__2, (ftnlen)10);
#line 21666 ""
			    do_fio(&c__1, ch__20, (ftnlen)10);
#line 21666 ""
			    e_wsfe();
#line 21667 ""
			}

/*  Zero ishort later trying to write alaligne */

#line 21671 ""
		    }
#line 21672 ""
		}
/* End of movement break stuff */
#line 21673 ""
		if (isystpg == 1) {

/*  First line on a page (not 1st page, still first bar).  Tidy up old page */
/*  then eject. */

/*  Check for meter change at start of a new PAGE */

#line 21680 ""
		    if (all_1.mtrnuml > 0) {

/*  Meter change at start of a new page.  Ugly repeated coding here. */

#line 21684 ""
			mtrnms = all_1.mtrnuml;
#line 21685 ""
			setmeter_(&all_1.mtrnuml, &all_1.mtrdenl, &
				combeam_1.ibmtyp, &ibmrep);
#line 21686 ""
			all_1.mtrnuml = mtrnms;
#line 21687 ""
			if (comget_1.movbrk == 0 && comlast_1.islast) {
#line 21688 ""
			    wgmeter_(&all_1.mtrnmp, &all_1.mtrdnp);
#line 21689 ""
			}
#line 21690 ""
		    }

/*  Key signature change? */

#line 21694 ""
		    if (bit_test(iplnow,28) && comget_1.movbrk == 0) {
/* Writing concatenation */
#line 21695 ""
			i__14[0] = 1, a__10[0] = all_1.sq;
#line 21695 ""
			i__14[1] = 4, a__10[1] = "xbar";
#line 21695 ""
			i__14[2] = 1, a__10[2] = all_1.sq;
#line 21695 ""
			i__14[3] = 10, a__10[3] = "addspace{-";
#line 21695 ""
			i__14[4] = 1, a__10[4] = all_1.sq;
#line 21695 ""
			i__14[5] = 14, a__10[5] = "afterruleskip}";
#line 21695 ""
			i__14[6] = 1, a__10[6] = all_1.sq;
#line 21695 ""
			i__14[7] = 17, a__10[7] = "generalsignature{";
#line 21695 ""
			s_cat(notexq, a__10, i__14, &c__8, (ftnlen)79);
#line 21697 ""
			lnote = 49;
#line 21698 ""
			if (comtop_1.isig < 0) {
/* Writing concatenation */
#line 21699 ""
			    i__6[0] = 49, a__4[0] = notexq;
#line 21699 ""
			    i__6[1] = 1, a__4[1] = "-";
#line 21699 ""
			    s_cat(notexq, a__4, i__6, &c__2, (ftnlen)79);
#line 21700 ""
			    lnote = 50;
#line 21701 ""
			}
#line 21702 ""
			if (comlast_1.islast) {
#line 21702 ""
			    s_wsfe(&io___1476);
/* Writing concatenation */
#line 21702 ""
			    i__8[0] = lnote, a__5[0] = notexq;
#line 21702 ""
			    i__2 = abs(comtop_1.isig) + 48;
#line 21702 ""
			    chax_(ch__1, (ftnlen)1, &i__2);
#line 21702 ""
			    i__8[1] = 1, a__5[1] = ch__1;
#line 21702 ""
			    i__8[2] = 2, a__5[2] = "}%";
#line 21702 ""
			    s_cat(ch__27, a__5, i__8, &c__3, (ftnlen)82);
#line 21702 ""
			    do_fio(&c__1, ch__27, lnote + 3);
#line 21702 ""
			    e_wsfe();
#line 21702 ""
			}
#line 21704 ""
			if (comlast_1.islast && cominsttrans_1.laterinsttrans)
				 {
#line 21705 ""
			    writesetsign_(&cominsttrans_1.ninsttrans, 
				    cominsttrans_1.iinsttrans, 
				    cominsttrans_1.itranskey, &
				    cominsttrans_1.laterinsttrans);
#line 21707 ""
			}
#line 21708 ""
			if (comlast_1.islast && comignorenats_1.ignorenats) {
#line 21708 ""
			    s_wsfe(&io___1477);
/* Writing concatenation */
#line 21708 ""
			    i__6[0] = 1, a__4[0] = all_1.sq;
#line 21708 ""
			    i__6[1] = 11, a__4[1] = "ignorenats%";
#line 21708 ""
			    s_cat(ch__14, a__4, i__6, &c__2, (ftnlen)12);
#line 21708 ""
			    do_fio(&c__1, ch__14, (ftnlen)12);
#line 21708 ""
			    e_wsfe();
#line 21708 ""
			}
#line 21710 ""
			if (comlast_1.islast) {
#line 21710 ""
			    s_wsfe(&io___1478);
/* Writing concatenation */
#line 21710 ""
			    i__9[0] = 1, a__6[0] = all_1.sq;
#line 21710 ""
			    i__9[1] = 14, a__6[1] = "zchangecontext";
#line 21710 ""
			    i__9[2] = 1, a__6[2] = all_1.sq;
#line 21710 ""
			    i__9[3] = 10, a__6[3] = "addspace{-";
#line 21710 ""
			    i__9[4] = 1, a__6[4] = all_1.sq;
#line 21710 ""
			    i__9[5] = 14, a__6[5] = "afterruleskip}";
#line 21710 ""
			    i__9[6] = 1, a__6[6] = all_1.sq;
#line 21710 ""
			    i__9[7] = 10, a__6[7] = "zstoppiece";
#line 21710 ""
			    i__9[8] = 1, a__6[8] = all_1.sq;
#line 21710 ""
			    i__9[9] = 13, a__6[9] = "PMXbarnotrue%";
#line 21710 ""
			    s_cat(ch__28, a__6, i__9, &c__10, (ftnlen)66);
#line 21710 ""
			    do_fio(&c__1, ch__28, (ftnlen)66);
#line 21710 ""
			    e_wsfe();
#line 21710 ""
			}
#line 21713 ""
		    } else if (all_1.mtrnuml > 0 && comget_1.movbrk == 0) {

/*  Meter change but no signature change */

#line 21717 ""
			if (comlast_1.islast) {
#line 21717 ""
			    s_wsfe(&io___1479);
/* Writing concatenation */
#line 21717 ""
			    i__3[0] = 1, a__1[0] = all_1.sq;
#line 21717 ""
			    i__3[1] = 14, a__1[1] = "xchangecontext";
#line 21717 ""
			    i__3[2] = 1, a__1[2] = all_1.sq;
#line 21717 ""
			    i__3[3] = 10, a__1[3] = "addspace{-";
#line 21717 ""
			    i__3[4] = 1, a__1[4] = all_1.sq;
#line 21717 ""
			    i__3[5] = 14, a__1[5] = "afterruleskip}";
#line 21717 ""
			    i__3[6] = 1, a__1[6] = all_1.sq;
#line 21717 ""
			    i__3[7] = 3, a__1[7] = "let";
#line 21717 ""
			    i__3[8] = 1, a__1[8] = all_1.sq;
#line 21717 ""
			    i__3[9] = 4, a__1[9] = "bnat";
#line 21717 ""
			    i__3[10] = 1, a__1[10] = all_1.sq;
#line 21717 ""
			    i__3[11] = 9, a__1[11] = "barnoadd%";
#line 21717 ""
			    s_cat(ch__29, a__1, i__3, &c__12, (ftnlen)60);
#line 21717 ""
			    do_fio(&c__1, ch__29, (ftnlen)60);
#line 21717 ""
			    e_wsfe();
#line 21717 ""
			}
#line 21721 ""
			if (comlast_1.islast) {
#line 21721 ""
			    s_wsfe(&io___1480);
/* Writing concatenation */
#line 21721 ""
			    i__3[0] = 1, a__1[0] = all_1.sq;
#line 21721 ""
			    i__3[1] = 3, a__1[1] = "def";
#line 21721 ""
			    i__3[2] = 1, a__1[2] = all_1.sq;
#line 21721 ""
			    i__3[3] = 9, a__1[3] = "barnoadd{";
#line 21721 ""
			    i__3[4] = 1, a__1[4] = all_1.sq;
#line 21721 ""
			    i__3[5] = 3, a__1[5] = "let";
#line 21721 ""
			    i__3[6] = 1, a__1[6] = all_1.sq;
#line 21721 ""
			    i__3[7] = 8, a__1[7] = "barnoadd";
#line 21721 ""
			    i__3[8] = 1, a__1[8] = all_1.sq;
#line 21721 ""
			    i__3[9] = 5, a__1[9] = "bnat}";
#line 21721 ""
			    i__3[10] = 1, a__1[10] = all_1.sq;
#line 21721 ""
			    i__3[11] = 11, a__1[11] = "zstoppiece%";
#line 21721 ""
			    s_cat(ch__30, a__1, i__3, &c__12, (ftnlen)45);
#line 21721 ""
			    do_fio(&c__1, ch__30, (ftnlen)45);
#line 21721 ""
			    e_wsfe();
#line 21721 ""
			}
#line 21724 ""
		    } else {
#line 21725 ""
			if (comlast_1.islast) {
#line 21726 ""
			    if ((comshort_1.ishort == 4 || comshort_1.ishort 
				    == 2) && iflagbot == 1) {
#line 21728 ""
				ntmp = combibarcnt_1.ibarcnt - ibarcnt0 - 
					comshort_1.nmbr + comshort_1.mbrsum;
#line 21729 ""
				if (ntmp <= 9) {
#line 21730 ""
				    *(unsigned char *)shortfraq = (char) (
					    ntmp + 48);
#line 21731 ""
				    lntmp = 1;
#line 21732 ""
				} else {
#line 21733 ""
				    s_wsfi(&io___1485);
#line 21733 ""
				    do_fio(&c__1, (char *)&ntmp, (ftnlen)
					    sizeof(integer));
#line 21733 ""
				    e_wsfi();
#line 21734 ""
				    lntmp = 2;
#line 21735 ""
				}
#line 21736 ""
				s_wsfe(&io___1486);
/* Writing concatenation */
#line 21736 ""
				i__15[0] = 1, a__11[0] = all_1.sq;
#line 21736 ""
				i__15[1] = 10, a__11[1] = "endpiece}}";
#line 21736 ""
				i__15[2] = 1, a__11[2] = all_1.sq;
#line 21736 ""
				i__15[3] = 7, a__11[3] = "advance";
#line 21736 ""
				i__15[4] = 1, a__11[4] = all_1.sq;
#line 21736 ""
				i__15[5] = 5, a__11[5] = "barno";
#line 21736 ""
				i__15[6] = lntmp, a__11[6] = shortfraq;
#line 21736 ""
				s_cat(ch__31, a__11, i__15, &c__7, (ftnlen)28)
					;
#line 21736 ""
				do_fio(&c__1, ch__31, lntmp + 25);
#line 21736 ""
				e_wsfe();
#line 21738 ""
			    } else if (comshort_1.ishort != 6 && 
				    comshort_1.ishort != 2 || iflagbot != 1) {
#line 21740 ""
				s_wsfe(&io___1487);
/* Writing concatenation */
#line 21740 ""
				i__6[0] = 1, a__4[0] = all_1.sq;
#line 21740 ""
				i__6[1] = 10, a__4[1] = "stoppiece%";
#line 21740 ""
				s_cat(ch__15, a__4, i__6, &c__2, (ftnlen)11);
#line 21740 ""
				do_fio(&c__1, ch__15, (ftnlen)11);
#line 21740 ""
				e_wsfe();
#line 21741 ""
			    }
#line 21742 ""
			}
#line 21743 ""
		    }

/*  This is the key spot when vshrink is used.  Value of vshrink here comes from */
/*  just after the prior pagebreak, i.e., it is not affected by "Av" */
/*  that may have been entered at this pagebreak, since that only affects usevshrink. */
/*  So choose page *ending* (with or without \vfill) depending on old vshrink.  Then */
/*  check value of usevshrink to reset vshrink if necessary for the new page, where */
/*  we have to set \interstaff and later call puttitle. */
/*  Top of first page needs special treatment.  For this we use */
/*  novshrinktop, which was set in g1etnote on the first pass, since on */
/*  second pass, vshrink at top of page one is dealt with in topfile, which is called */
/*  *before* any reading in any "Av" at the top of the first input block. */

#line 21756 ""
		    if (! vshrink) {
#line 21757 ""
			if (comlast_1.islast && combottop_1.bottopgap) {
#line 21758 ""
			    if (dabs(combottop_1.botamt) > 1e-6f) {
#line 21759 ""
				if (combottop_1.botamt > 9.95f) {
#line 21760 ""
				    s_copy(fmtq, "(a,f4.1,a)", (ftnlen)24, (
					    ftnlen)10);
#line 21761 ""
				} else if (combottop_1.botamt > 0.f) {
#line 21762 ""
				    s_copy(fmtq, "(a,f3.1,a)", (ftnlen)24, (
					    ftnlen)10);
#line 21763 ""
				} else if (combottop_1.botamt > -9.95f) {
#line 21764 ""
				    s_copy(fmtq, "(a,f4.1,a)", (ftnlen)24, (
					    ftnlen)10);
#line 21765 ""
				} else {
#line 21766 ""
				    s_copy(fmtq, "(a,f5.1,a)", (ftnlen)24, (
					    ftnlen)10);
#line 21767 ""
				}
#line 21768 ""
				s_wsfe(&io___1488);
/* Writing concatenation */
#line 21768 ""
				i__5[0] = 1, a__3[0] = all_1.sq;
#line 21768 ""
				i__5[1] = 4, a__3[1] = "null";
#line 21768 ""
				i__5[2] = 1, a__3[2] = all_1.sq;
#line 21768 ""
				i__5[3] = 5, a__3[3] = "vskip";
#line 21768 ""
				s_cat(ch__15, a__3, i__5, &c__4, (ftnlen)11);
#line 21768 ""
				do_fio(&c__1, ch__15, (ftnlen)11);
#line 21768 ""
				do_fio(&c__1, (char *)&combottop_1.botamt, (
					ftnlen)sizeof(real));
/* Writing concatenation */
#line 21768 ""
				i__6[0] = 1, a__4[0] = all_1.sq;
#line 21768 ""
				i__6[1] = 10, a__4[1] = "Internote%";
#line 21768 ""
				s_cat(ch__32, a__4, i__6, &c__2, (ftnlen)11);
#line 21768 ""
				do_fio(&c__1, ch__32, (ftnlen)11);
#line 21768 ""
				e_wsfe();
#line 21770 ""
			    }
#line 21771 ""
			}
#line 21772 ""
			xnstbot = xnsttop[comnotes_1.ipage - 1] * etabot / 
				etatop;
#line 21773 ""
			if (xnstbot < 9.95f) {
#line 21774 ""
			    s_copy(fmtq, "(a,f3.1,a)", (ftnlen)24, (ftnlen)10)
				    ;
#line 21775 ""
			} else {
#line 21776 ""
			    s_copy(fmtq, "(a,f4.1,a)", (ftnlen)24, (ftnlen)10)
				    ;
#line 21777 ""
			}
#line 21778 ""
			if (comlast_1.islast) {
#line 21778 ""
			    s_wsfe(&io___1490);
/* Writing concatenation */
#line 21778 ""
			    i__6[0] = 1, a__4[0] = all_1.sq;
#line 21778 ""
			    i__6[1] = 5, a__4[1] = "vskip";
#line 21778 ""
			    s_cat(ch__25, a__4, i__6, &c__2, (ftnlen)6);
#line 21778 ""
			    do_fio(&c__1, ch__25, (ftnlen)6);
#line 21778 ""
			    do_fio(&c__1, (char *)&xnstbot, (ftnlen)sizeof(
				    real));
/* Writing concatenation */
#line 21778 ""
			    i__5[0] = 1, a__3[0] = all_1.sq;
#line 21778 ""
			    i__5[1] = 10, a__3[1] = "Interligne";
#line 21778 ""
			    i__5[2] = 1, a__3[2] = all_1.sq;
#line 21778 ""
			    i__5[3] = 6, a__3[3] = "eject%";
#line 21778 ""
			    s_cat(ch__26, a__3, i__5, &c__4, (ftnlen)18);
#line 21778 ""
			    do_fio(&c__1, ch__26, (ftnlen)18);
#line 21778 ""
			    e_wsfe();
#line 21778 ""
			}
#line 21780 ""
			if (comlast_1.islast && combottop_1.bottopgap) {
#line 21781 ""
			    if (dabs(combottop_1.topamt) > 1e-6f) {
#line 21782 ""
				if (combottop_1.topamt > 9.95f) {
#line 21783 ""
				    s_copy(fmtq, "(a,f4.1,a)", (ftnlen)24, (
					    ftnlen)10);
#line 21784 ""
				} else if (combottop_1.topamt > 0.f) {
#line 21785 ""
				    s_copy(fmtq, "(a,f3.1,a)", (ftnlen)24, (
					    ftnlen)10);
#line 21786 ""
				} else if (combottop_1.topamt > -9.95f) {
#line 21787 ""
				    s_copy(fmtq, "(a,f4.1,a)", (ftnlen)24, (
					    ftnlen)10);
#line 21788 ""
				} else {
#line 21789 ""
				    s_copy(fmtq, "(a,f5.1,a)", (ftnlen)24, (
					    ftnlen)10);
#line 21790 ""
				}
#line 21791 ""
				s_wsfe(&io___1491);
/* Writing concatenation */
#line 21791 ""
				i__5[0] = 1, a__3[0] = all_1.sq;
#line 21791 ""
				i__5[1] = 4, a__3[1] = "null";
#line 21791 ""
				i__5[2] = 1, a__3[2] = all_1.sq;
#line 21791 ""
				i__5[3] = 5, a__3[3] = "vskip";
#line 21791 ""
				s_cat(ch__15, a__3, i__5, &c__4, (ftnlen)11);
#line 21791 ""
				do_fio(&c__1, ch__15, (ftnlen)11);
#line 21791 ""
				do_fio(&c__1, (char *)&combottop_1.topamt, (
					ftnlen)sizeof(real));
/* Writing concatenation */
#line 21791 ""
				i__6[0] = 1, a__4[0] = all_1.sq;
#line 21791 ""
				i__6[1] = 10, a__4[1] = "Internote%";
#line 21791 ""
				s_cat(ch__32, a__4, i__6, &c__2, (ftnlen)11);
#line 21791 ""
				do_fio(&c__1, ch__32, (ftnlen)11);
#line 21791 ""
				e_wsfe();
#line 21793 ""
			    }
#line 21794 ""
			    combottop_1.bottopgap = FALSE_;
#line 21795 ""
			}
#line 21796 ""
		    } else {
#line 21797 ""
			if (comlast_1.islast) {
#line 21798 ""
			    if (iflagbot == 1 && comshort_1.ishort == 6) {

/* cleanup for case bcm only */

#line 21802 ""
				iflagbot = 0;
#line 21803 ""
				comshort_1.ishort = 0;
#line 21804 ""
			    } else {
#line 21805 ""
				s_wsfe(&io___1492);
/* Writing concatenation */
#line 21805 ""
				i__5[0] = 1, a__3[0] = all_1.sq;
#line 21805 ""
				i__5[1] = 5, a__3[1] = "vfill";
#line 21805 ""
				i__5[2] = 1, a__3[2] = all_1.sq;
#line 21805 ""
				i__5[3] = 6, a__3[3] = "eject%";
#line 21805 ""
				s_cat(ch__17, a__3, i__5, &c__4, (ftnlen)13);
#line 21805 ""
				do_fio(&c__1, ch__17, (ftnlen)13);
#line 21805 ""
				e_wsfe();
#line 21806 ""
				if (iflagbot == 1 && comshort_1.ishort == 2) {
/* Clean up case bsl only */
#line 21808 ""
				    s_wsfe(&io___1493);
/* Writing concatenation */
#line 21808 ""
				    i__4[0] = 1, a__2[0] = all_1.sq;
#line 21808 ""
				    i__4[1] = 12, a__2[1] = "makeatletter";
#line 21808 ""
				    i__4[2] = 1, a__2[2] = all_1.sq;
#line 21808 ""
				    i__4[3] = 9, a__2[3] = "fil@begin";
#line 21808 ""
				    i__4[4] = 1, a__2[4] = all_1.sq;
#line 21808 ""
				    i__4[5] = 11, a__2[5] = "makeatother";
#line 21808 ""
				    s_cat(ch__9, a__2, i__4, &c__6, (ftnlen)
					    35);
#line 21808 ""
				    do_fio(&c__1, ch__9, (ftnlen)35);
#line 21808 ""
				    e_wsfe();
#line 21810 ""
				    iflagbot = 0;
#line 21811 ""
				    comshort_1.ishort = 0;
#line 21812 ""
				}
#line 21813 ""
			    }
#line 21814 ""
			}
#line 21815 ""
		    }
#line 21816 ""
		    ++comnotes_1.ipage;

/*  Now that page is ejected, compute new vshrink */

#line 21820 ""
		    vshrink = xintstaff[comnotes_1.ipage - 1] > 20.f && 
			    comlast_1.usevshrink;
#line 21821 ""
		    if (vshrink) {
#line 21822 ""
			comarp_1.xinsnow = 10.f;
#line 21823 ""
		    } else {
#line 21824 ""
			comarp_1.xinsnow = xintstaff[comnotes_1.ipage - 1];
#line 21825 ""
		    }
#line 21826 ""
		    if (comget_1.fintstf > 0.f && comnotes_1.ipage > 1) {
#line 21827 ""
			comarp_1.xinsnow = comarp_1.xinsnow * 
				comget_1.fintstf / comget_1.gintstf;
#line 21828 ""
			comget_1.fintstf = -1.f;
#line 21829 ""
		    }
#line 21830 ""
		    if (comarp_1.xinsnow < 9.95f) {
#line 21831 ""
			s_copy(fmtq, "(a,f3.1,a)", (ftnlen)24, (ftnlen)10);
#line 21832 ""
		    } else if (comarp_1.xinsnow < 99.95f) {
#line 21833 ""
			s_copy(fmtq, "(a,f4.1,a)", (ftnlen)24, (ftnlen)10);
#line 21834 ""
		    } else {
#line 21835 ""
			s_copy(fmtq, "(a,f5.1,a)", (ftnlen)24, (ftnlen)10);
#line 21836 ""
		    }

/*  Vertical spacing parameters, then restart */

#line 21840 ""
		    if (comis4bignv_1.is4bignv) {
#line 21840 ""
			comarp_1.xinsnow *= .95f;
#line 21840 ""
		    }
#line 21841 ""
		    if (comlast_1.islast) {
#line 21842 ""
			s_wsfe(&io___1494);
/* Writing concatenation */
#line 21842 ""
			i__6[0] = 1, a__4[0] = all_1.sq;
#line 21842 ""
			i__6[1] = 11, a__4[1] = "interstaff{";
#line 21842 ""
			s_cat(ch__14, a__4, i__6, &c__2, (ftnlen)12);
#line 21842 ""
			do_fio(&c__1, ch__14, (ftnlen)12);
#line 21842 ""
			do_fio(&c__1, (char *)&comarp_1.xinsnow, (ftnlen)
				sizeof(real));
/* Writing concatenation */
#line 21842 ""
			i__8[0] = 1, a__5[0] = "}";
#line 21842 ""
			i__8[1] = 1, a__5[1] = all_1.sq;
#line 21842 ""
			i__8[2] = 9, a__5[2] = "contpiece";
#line 21842 ""
			s_cat(ch__15, a__5, i__8, &c__3, (ftnlen)11);
#line 21842 ""
			do_fio(&c__1, ch__15, (ftnlen)11);
#line 21842 ""
			e_wsfe();
#line 21844 ""
		    }

/*  Check for meter change at start of a new PAGE */

#line 21848 ""
		    if (all_1.mtrnuml > 0) {

/*  Meter change at start of a new page */

#line 21852 ""
			setmeter_(&all_1.mtrnuml, &all_1.mtrdenl, &
				combeam_1.ibmtyp, &ibmrep);
#line 21853 ""
			if (comget_1.movbrk == 0) {
#line 21854 ""
			    if (comlast_1.islast) {
#line 21855 ""
				wgmeter_(&all_1.mtrnmp, &all_1.mtrdnp);
#line 21856 ""
			    }
#line 21857 ""
			    if (all_1.mtrdnp > 0) {
#line 21858 ""
				if (comlast_1.islast) {
#line 21858 ""
				    s_wsfe(&io___1495);
/* Writing concatenation */
#line 21858 ""
				    i__6[0] = 1, a__4[0] = all_1.sq;
#line 21858 ""
				    i__6[1] = 10, a__4[1] = "newtimes2%";
#line 21858 ""
				    s_cat(ch__15, a__4, i__6, &c__2, (ftnlen)
					    11);
#line 21858 ""
				    do_fio(&c__1, ch__15, (ftnlen)11);
#line 21858 ""
				    e_wsfe();
#line 21858 ""
				}
#line 21859 ""
				if (all_1.ibar == comgrace_1.ibarmbr) {
#line 21859 ""
				    comgrace_1.xb4mbr = all_1.musicsize * 
					    -.2f;
#line 21859 ""
				}
#line 21860 ""
			    }
#line 21861 ""
			}
#line 21862 ""
		    }

/*  If no real titles here, which there probably will never be, make vertical */
/*  space at page top with \titles{...}.  headlog=.false.<=>no real titles */

#line 21867 ""
		    if (comshort_1.ishort == 4 && iflagbot == 1) {
#line 21868 ""
			comshort_1.ishort = 0;
#line 21869 ""
			iflagbot = 0;
#line 21870 ""
			s_wsfe(&io___1496);
/* Writing concatenation */
#line 21870 ""
			i__4[0] = 1, a__2[0] = all_1.sq;
#line 21870 ""
			i__4[1] = 12, a__2[1] = "makeatletter";
#line 21870 ""
			i__4[2] = 1, a__2[2] = all_1.sq;
#line 21870 ""
			i__4[3] = 9, a__2[3] = "fil@begin";
#line 21870 ""
			i__4[4] = 1, a__2[4] = all_1.sq;
#line 21870 ""
			i__4[5] = 11, a__2[5] = "makeatother";
#line 21870 ""
			s_cat(ch__9, a__2, i__4, &c__6, (ftnlen)35);
#line 21870 ""
			do_fio(&c__1, ch__9, (ftnlen)35);
#line 21870 ""
			e_wsfe();
#line 21872 ""
		    }
#line 21873 ""
		    puttitle_(&inhnoh, &xnsttop[comnotes_1.ipage - 1], &
			    etatop, all_1.sq, &etait, &etatc, &etacs1, &
			    all_1.nv, &vshrink, all_1.sepsymq, (ftnlen)1, (
			    ftnlen)1);
#line 21875 ""
		    if (comnotes_1.headerspecial) {
#line 21875 ""
			s_wsfe(&io___1497);
/* Writing concatenation */
#line 21875 ""
			chax_(ch__1, (ftnlen)1, &c__92);
#line 21875 ""
			i__6[0] = 1, a__4[0] = ch__1;
#line 21875 ""
			i__6[1] = 28, a__4[1] = "special{header=psslurs.pro}%"
				;
#line 21875 ""
			s_cat(ch__7, a__4, i__6, &c__2, (ftnlen)29);
#line 21875 ""
			do_fio(&c__1, ch__7, (ftnlen)29);
#line 21875 ""
			e_wsfe();
#line 21875 ""
		    }

/*  Write special header for first page */

#line 21880 ""
		} else {

/*  First bar of system, not a new page, force line break */

#line 21884 ""
		    if (bit_test(iplnow,28)) {

/*  Signature change */

/* Writing concatenation */
#line 21888 ""
			i__14[0] = 1, a__10[0] = all_1.sq;
#line 21888 ""
			i__14[1] = 4, a__10[1] = "xbar";
#line 21888 ""
			i__14[2] = 1, a__10[2] = all_1.sq;
#line 21888 ""
			i__14[3] = 10, a__10[3] = "addspace{-";
#line 21888 ""
			i__14[4] = 1, a__10[4] = all_1.sq;
#line 21888 ""
			i__14[5] = 14, a__10[5] = "afterruleskip}";
#line 21888 ""
			i__14[6] = 1, a__10[6] = all_1.sq;
#line 21888 ""
			i__14[7] = 17, a__10[7] = "generalsignature{";
#line 21888 ""
			s_cat(notexq, a__10, i__14, &c__8, (ftnlen)79);
#line 21890 ""
			lnote = 49;
#line 21891 ""
			if (comtop_1.isig < 0) {
/* Writing concatenation */
#line 21892 ""
			    i__6[0] = 49, a__4[0] = notexq;
#line 21892 ""
			    i__6[1] = 1, a__4[1] = "-";
#line 21892 ""
			    s_cat(notexq, a__4, i__6, &c__2, (ftnlen)79);
#line 21893 ""
			    lnote = 50;
#line 21894 ""
			}
#line 21895 ""
			if (comlast_1.islast) {
#line 21895 ""
			    s_wsfe(&io___1498);
/* Writing concatenation */
#line 21895 ""
			    i__8[0] = lnote, a__5[0] = notexq;
#line 21895 ""
			    i__2 = abs(comtop_1.isig) + 48;
#line 21895 ""
			    chax_(ch__1, (ftnlen)1, &i__2);
#line 21895 ""
			    i__8[1] = 1, a__5[1] = ch__1;
#line 21895 ""
			    i__8[2] = 2, a__5[2] = "}%";
#line 21895 ""
			    s_cat(ch__27, a__5, i__8, &c__3, (ftnlen)82);
#line 21895 ""
			    do_fio(&c__1, ch__27, lnote + 3);
#line 21895 ""
			    e_wsfe();
#line 21895 ""
			}
#line 21897 ""
			if (comlast_1.islast && cominsttrans_1.laterinsttrans)
				 {
#line 21898 ""
			    writesetsign_(&cominsttrans_1.ninsttrans, 
				    cominsttrans_1.iinsttrans, 
				    cominsttrans_1.itranskey, &
				    cominsttrans_1.laterinsttrans);
#line 21900 ""
			}
#line 21901 ""
			if (comlast_1.islast) {
#line 21901 ""
			    s_wsfe(&io___1499);
/* Writing concatenation */
#line 21901 ""
			    i__5[0] = 1, a__3[0] = all_1.sq;
#line 21901 ""
			    i__5[1] = 7, a__3[1] = "advance";
#line 21901 ""
			    i__5[2] = 1, a__3[2] = all_1.sq;
#line 21901 ""
			    i__5[3] = 8, a__3[3] = "barno-1%";
#line 21901 ""
			    s_cat(ch__13, a__3, i__5, &c__4, (ftnlen)17);
#line 21901 ""
			    do_fio(&c__1, ch__13, (ftnlen)17);
#line 21901 ""
			    e_wsfe();
#line 21901 ""
			}
#line 21902 ""
			if (all_1.mtrnuml != 0) {

/*  Meter+sig change, new line, may need mods if movement break here. */

#line 21906 ""
			    setmeter_(&all_1.mtrnuml, &all_1.mtrdenl, &
				    combeam_1.ibmtyp, &ibmrep);
#line 21907 ""
			    if (comlast_1.islast) {
#line 21908 ""
				wgmeter_(&all_1.mtrnmp, &all_1.mtrdnp);
#line 21909 ""
				if (comignorenats_1.ignorenats) {
#line 21909 ""
				    s_wsfe(&io___1500);
/* Writing concatenation */
#line 21909 ""
				    i__6[0] = 1, a__4[0] = all_1.sq;
#line 21909 ""
				    i__6[1] = 11, a__4[1] = "ignorenats%";
#line 21909 ""
				    s_cat(ch__14, a__4, i__6, &c__2, (ftnlen)
					    12);
#line 21909 ""
				    do_fio(&c__1, ch__14, (ftnlen)12);
#line 21909 ""
				    e_wsfe();
#line 21909 ""
				}
#line 21910 ""
				s_wsfe(&io___1501);
/* Writing concatenation */
#line 21910 ""
				i__3[0] = 1, a__1[0] = all_1.sq;
#line 21910 ""
				i__3[1] = 14, a__1[1] = "xchangecontext";
#line 21910 ""
				i__3[2] = 1, a__1[2] = all_1.sq;
#line 21910 ""
				i__3[3] = 10, a__1[3] = "addspace{-";
#line 21910 ""
				i__3[4] = 1, a__1[4] = all_1.sq;
#line 21910 ""
				i__3[5] = 14, a__1[5] = "afterruleskip}";
#line 21910 ""
				i__3[6] = 1, a__1[6] = all_1.sq;
#line 21910 ""
				i__3[7] = 10, a__1[7] = "zstoppiece";
#line 21910 ""
				i__3[8] = 1, a__1[8] = all_1.sq;
#line 21910 ""
				i__3[9] = 12, a__1[9] = "PMXbarnotrue";
#line 21910 ""
				i__3[10] = 1, a__1[10] = all_1.sq;
#line 21910 ""
				i__3[11] = 10, a__1[11] = "contpiece%";
#line 21910 ""
				s_cat(ch__33, a__1, i__3, &c__12, (ftnlen)76);
#line 21910 ""
				do_fio(&c__1, ch__33, (ftnlen)76);
#line 21910 ""
				e_wsfe();
#line 21913 ""
				s_wsfe(&io___1502);
/* Writing concatenation */
#line 21913 ""
				i__5[0] = 1, a__3[0] = all_1.sq;
#line 21913 ""
				i__5[1] = 10, a__3[1] = "addspace{-";
#line 21913 ""
				i__5[2] = 1, a__3[2] = all_1.sq;
#line 21913 ""
				i__5[3] = 15, a__3[3] = "afterruleskip}%";
#line 21913 ""
				s_cat(ch__5, a__3, i__5, &c__4, (ftnlen)27);
#line 21913 ""
				do_fio(&c__1, ch__5, (ftnlen)27);
#line 21913 ""
				e_wsfe();
#line 21915 ""
				wgmeter_(&all_1.mtrnmp, &all_1.mtrdnp);
#line 21916 ""
				if (comignorenats_1.ignorenats) {
#line 21916 ""
				    s_wsfe(&io___1503);
/* Writing concatenation */
#line 21916 ""
				    i__6[0] = 1, a__4[0] = all_1.sq;
#line 21916 ""
				    i__6[1] = 11, a__4[1] = "ignorenats%";
#line 21916 ""
				    s_cat(ch__14, a__4, i__6, &c__2, (ftnlen)
					    12);
#line 21916 ""
				    do_fio(&c__1, ch__14, (ftnlen)12);
#line 21916 ""
				    e_wsfe();
#line 21916 ""
				}
#line 21917 ""
				s_wsfe(&io___1504);
/* Writing concatenation */
#line 21917 ""
				i__6[0] = 1, a__4[0] = all_1.sq;
#line 21917 ""
				i__6[1] = 14, a__4[1] = "zchangecontext";
#line 21917 ""
				s_cat(ch__16, a__4, i__6, &c__2, (ftnlen)15);
#line 21917 ""
				do_fio(&c__1, ch__16, (ftnlen)15);
#line 21917 ""
				e_wsfe();
#line 21918 ""
			    }
#line 21919 ""
			} else {
#line 21920 ""
			    if (comlast_1.islast && 
				    comignorenats_1.ignorenats) {
#line 21920 ""
				s_wsfe(&io___1505);
/* Writing concatenation */
#line 21920 ""
				i__6[0] = 1, a__4[0] = all_1.sq;
#line 21920 ""
				i__6[1] = 11, a__4[1] = "ignorenats%";
#line 21920 ""
				s_cat(ch__14, a__4, i__6, &c__2, (ftnlen)12);
#line 21920 ""
				do_fio(&c__1, ch__14, (ftnlen)12);
#line 21920 ""
				e_wsfe();
#line 21920 ""
			    }
#line 21922 ""
			    if (comlast_1.islast) {
#line 21922 ""
				s_wsfe(&io___1506);
/* Writing concatenation */
#line 21922 ""
				i__3[0] = 1, a__1[0] = all_1.sq;
#line 21922 ""
				i__3[1] = 14, a__1[1] = "xchangecontext";
#line 21922 ""
				i__3[2] = 1, a__1[2] = all_1.sq;
#line 21922 ""
				i__3[3] = 10, a__1[3] = "addspace{-";
#line 21922 ""
				i__3[4] = 1, a__1[4] = all_1.sq;
#line 21922 ""
				i__3[5] = 14, a__1[5] = "afterruleskip}";
#line 21922 ""
				i__3[6] = 1, a__1[6] = all_1.sq;
#line 21922 ""
				i__3[7] = 10, a__1[7] = "zstoppiece";
#line 21922 ""
				i__3[8] = 1, a__1[8] = all_1.sq;
#line 21922 ""
				i__3[9] = 12, a__1[9] = "PMXbarnotrue";
#line 21922 ""
				i__3[10] = 1, a__1[10] = all_1.sq;
#line 21922 ""
				i__3[11] = 10, a__1[11] = "contpiece%";
#line 21922 ""
				s_cat(ch__33, a__1, i__3, &c__12, (ftnlen)76);
#line 21922 ""
				do_fio(&c__1, ch__33, (ftnlen)76);
#line 21922 ""
				e_wsfe();
#line 21922 ""
			    }
#line 21925 ""
			}
#line 21926 ""
		    } else if (all_1.mtrnuml == 0 && (comshort_1.ishort == 0 
			    || comshort_1.ishort == 6)) {

/*  No meter change */

#line 21931 ""
			if (comlast_1.islast) {
#line 21932 ""
			    if (comshort_1.ishort != 6) {
#line 21933 ""
				s_wsfe(&io___1507);
/* Writing concatenation */
#line 21933 ""
				i__6[0] = 1, a__4[0] = all_1.sq;
#line 21933 ""
				i__6[1] = 8, a__4[1] = "alaligne";
#line 21933 ""
				s_cat(ch__18, a__4, i__6, &c__2, (ftnlen)9);
#line 21933 ""
				do_fio(&c__1, ch__18, (ftnlen)9);
#line 21933 ""
				e_wsfe();
#line 21934 ""
			    } else {
#line 21935 ""
				comshort_1.ishort = 0;
#line 21936 ""
			    }
#line 21937 ""
			}
#line 21938 ""
		    } else if (comshort_1.ishort != 0) {
#line 21939 ""
			if (comshort_1.ishort == 1) {
/* Start short line */
#line 21940 ""
			    s_wsfi(&io___1508);
#line 21940 ""
			    do_fio(&c__1, (char *)&comshort_1.shortfrac, (
				    ftnlen)sizeof(real));
#line 21940 ""
			    e_wsfi();
#line 21941 ""
			    s_wsfe(&io___1509);
/* Writing concatenation */
#line 21941 ""
			    i__5[0] = 1, a__3[0] = all_1.sq;
#line 21941 ""
			    i__5[1] = 9, a__3[1] = "stoppiece";
#line 21941 ""
			    i__5[2] = 1, a__3[2] = all_1.sq;
#line 21941 ""
			    i__5[3] = 13, a__3[3] = "parindent 0pt";
#line 21941 ""
			    s_cat(ch__24, a__3, i__5, &c__4, (ftnlen)24);
#line 21941 ""
			    do_fio(&c__1, ch__24, (ftnlen)24);
#line 21941 ""
			    e_wsfe();
#line 21942 ""
			    s_wsfe(&io___1510);
/* Writing concatenation */
#line 21942 ""
			    i__5[0] = 1, a__3[0] = all_1.sq;
#line 21942 ""
			    i__5[1] = 5, a__3[1] = "vskip";
#line 21942 ""
			    i__5[2] = 1, a__3[2] = all_1.sq;
#line 21942 ""
			    i__5[3] = 7, a__3[3] = "parskip";
#line 21942 ""
			    s_cat(ch__10, a__3, i__5, &c__4, (ftnlen)14);
#line 21942 ""
			    do_fio(&c__1, ch__10, (ftnlen)14);
#line 21942 ""
			    e_wsfe();
#line 21943 ""
			    s_wsfe(&io___1511);
/* Writing concatenation */
#line 21943 ""
			    i__16[0] = 1, a__12[0] = all_1.sq;
#line 21943 ""
			    i__16[1] = 7, a__12[1] = "hbox to";
#line 21943 ""
			    i__16[2] = 1, a__12[2] = all_1.sq;
#line 21943 ""
			    i__16[3] = 6, a__12[3] = "hsize{";
#line 21943 ""
			    i__16[4] = 1, a__12[4] = all_1.sq;
#line 21943 ""
			    i__16[5] = 5, a__12[5] = "vbox{";
#line 21943 ""
			    i__16[6] = 1, a__12[6] = all_1.sq;
#line 21943 ""
			    i__16[7] = 6, a__12[7] = "hsize=";
#line 21943 ""
			    i__16[8] = 3, a__12[8] = shortfraq;
#line 21943 ""
			    i__16[9] = 1, a__12[9] = all_1.sq;
#line 21943 ""
			    i__16[10] = 6, a__12[10] = "hsize%";
#line 21943 ""
			    s_cat(ch__34, a__12, i__16, &c__11, (ftnlen)38);
#line 21943 ""
			    do_fio(&c__1, ch__34, (ftnlen)38);
#line 21943 ""
			    e_wsfe();
#line 21946 ""
			    s_wsfe(&io___1512);
/* Writing concatenation */
#line 21946 ""
			    i__6[0] = 1, a__4[0] = all_1.sq;
#line 21946 ""
			    i__6[1] = 9, a__4[1] = "contpiece";
#line 21946 ""
			    s_cat(ch__20, a__4, i__6, &c__2, (ftnlen)10);
#line 21946 ""
			    do_fio(&c__1, ch__20, (ftnlen)10);
#line 21946 ""
			    e_wsfe();
#line 21947 ""
			    s_wsfe(&io___1513);
/* Writing concatenation */
#line 21947 ""
			    i__4[0] = 1, a__2[0] = all_1.sq;
#line 21947 ""
			    i__4[1] = 12, a__2[1] = "makeatletter";
#line 21947 ""
			    i__4[2] = 1, a__2[2] = all_1.sq;
#line 21947 ""
			    i__4[3] = 9, a__2[3] = "fil@begin";
#line 21947 ""
			    i__4[4] = 1, a__2[4] = all_1.sq;
#line 21947 ""
			    i__4[5] = 11, a__2[5] = "makeatother";
#line 21947 ""
			    s_cat(ch__9, a__2, i__4, &c__6, (ftnlen)35);
#line 21947 ""
			    do_fio(&c__1, ch__9, (ftnlen)35);
#line 21947 ""
			    e_wsfe();
#line 21949 ""
			    ibarcnt0 = combibarcnt_1.ibarcnt;
#line 21950 ""
			    comshort_1.mbrsum = 0;
#line 21951 ""
			    comshort_1.ishort = 2;
#line 21952 ""
			    comshort_1.nmbr = 0;
#line 21953 ""
			} else if (comshort_1.ishort == 2) {
/* End short line, no new mv */
#line 21954 ""
			    ntmp = combibarcnt_1.ibarcnt - ibarcnt0 - 
				    comshort_1.nmbr + comshort_1.mbrsum;
#line 21955 ""
			    if (ntmp <= 9) {
#line 21956 ""
				*(unsigned char *)shortfraq = (char) (ntmp + 
					48);
#line 21957 ""
				lntmp = 1;
#line 21958 ""
			    } else {
#line 21959 ""
				s_wsfi(&io___1514);
#line 21959 ""
				do_fio(&c__1, (char *)&ntmp, (ftnlen)sizeof(
					integer));
#line 21959 ""
				e_wsfi();
#line 21960 ""
				lntmp = 2;
#line 21961 ""
			    }
#line 21962 ""
			    s_wsfe(&io___1515);
/* Writing concatenation */
#line 21962 ""
			    i__15[0] = 1, a__11[0] = all_1.sq;
#line 21962 ""
			    i__15[1] = 11, a__11[1] = "stoppiece}}";
#line 21962 ""
			    i__15[2] = 1, a__11[2] = all_1.sq;
#line 21962 ""
			    i__15[3] = 7, a__11[3] = "advance";
#line 21962 ""
			    i__15[4] = 1, a__11[4] = all_1.sq;
#line 21962 ""
			    i__15[5] = 5, a__11[5] = "barno";
#line 21962 ""
			    i__15[6] = lntmp, a__11[6] = shortfraq;
#line 21962 ""
			    s_cat(ch__7, a__11, i__15, &c__7, (ftnlen)29);
#line 21962 ""
			    do_fio(&c__1, ch__7, lntmp + 26);
#line 21962 ""
			    e_wsfe();

/*  Not clear why we needed this */
/*                     //sq//'startbarno'//sq//'barno%' */
#line 21967 ""
			    s_wsfe(&io___1516);
/* Writing concatenation */
#line 21967 ""
			    i__6[0] = 1, a__4[0] = all_1.sq;
#line 21967 ""
			    i__6[1] = 9, a__4[1] = "contpiece";
#line 21967 ""
			    s_cat(ch__20, a__4, i__6, &c__2, (ftnlen)10);
#line 21967 ""
			    do_fio(&c__1, ch__20, (ftnlen)10);
#line 21967 ""
			    e_wsfe();
#line 21968 ""
			    s_wsfe(&io___1517);
/* Writing concatenation */
#line 21968 ""
			    i__4[0] = 1, a__2[0] = all_1.sq;
#line 21968 ""
			    i__4[1] = 12, a__2[1] = "makeatletter";
#line 21968 ""
			    i__4[2] = 1, a__2[2] = all_1.sq;
#line 21968 ""
			    i__4[3] = 9, a__2[3] = "fil@begin";
#line 21968 ""
			    i__4[4] = 1, a__2[4] = all_1.sq;
#line 21968 ""
			    i__4[5] = 11, a__2[5] = "makeatother";
#line 21968 ""
			    s_cat(ch__9, a__2, i__4, &c__6, (ftnlen)35);
#line 21968 ""
			    do_fio(&c__1, ch__9, (ftnlen)35);
#line 21968 ""
			    e_wsfe();
#line 21970 ""
			    comshort_1.ishort = 0;
#line 21971 ""
			} else if (comshort_1.ishort == 5) {
/* End short line, new mvt */
#line 21972 ""
			    if (comnotes_1.nobar1) {
/* Continue bar numbering */
#line 21973 ""
				s_wsfe(&io___1518);
/* Writing concatenation */
#line 21973 ""
				i__10[0] = 1, a__7[0] = all_1.sq;
#line 21973 ""
				i__10[1] = 7, a__7[1] = "advance";
#line 21973 ""
				i__10[2] = 1, a__7[2] = all_1.sq;
#line 21973 ""
				i__10[3] = 5, a__7[3] = "barno";
#line 21973 ""
				*(unsigned char *)&ch__1[0] = 
					combibarcnt_1.ibarcnt - ibarcnt0 + 48;
#line 21973 ""
				i__10[4] = 1, a__7[4] = ch__1;
#line 21973 ""
				i__10[5] = 1, a__7[5] = all_1.sq;
#line 21973 ""
				i__10[6] = 10, a__7[6] = "startbarno";
#line 21973 ""
				i__10[7] = 1, a__7[7] = all_1.sq;
#line 21973 ""
				i__10[8] = 6, a__7[8] = "barno%";
#line 21973 ""
				s_cat(ch__35, a__7, i__10, &c__9, (ftnlen)33);
#line 21973 ""
				do_fio(&c__1, ch__35, (ftnlen)33);
#line 21973 ""
				e_wsfe();

/* Must leave in \startbarno to get msm with LMc to work. */

#line 21979 ""
			    }
#line 21980 ""
			    s_wsfe(&io___1519);
/* Writing concatenation */
#line 21980 ""
			    i__4[0] = 1, a__2[0] = all_1.sq;
#line 21980 ""
			    i__4[1] = 10, a__2[1] = "startpiece";
#line 21980 ""
			    i__4[2] = 1, a__2[2] = all_1.sq;
#line 21980 ""
			    i__4[3] = 8, a__2[3] = "addspace";
#line 21980 ""
			    i__4[4] = 1, a__2[4] = all_1.sq;
#line 21980 ""
			    i__4[5] = 14, a__2[5] = "afterruleskip%";
#line 21980 ""
			    s_cat(ch__9, a__2, i__4, &c__6, (ftnlen)35);
#line 21980 ""
			    do_fio(&c__1, ch__9, (ftnlen)35);
#line 21980 ""
			    e_wsfe();
#line 21982 ""
			    comshort_1.ishort = 0;
#line 21983 ""
			} else if (comshort_1.ishort == 3) {
/* May never come thru here. Stuff is done later at least for mcl.pmx */
/* Mid line gap, start coda */
#line 21985 ""
			    s_wsfi(&io___1520);
#line 21985 ""
			    do_fio(&c__1, (char *)&comshort_1.codafrac, (
				    ftnlen)sizeof(real));
#line 21985 ""
			    e_wsfi();
#line 21986 ""
			    s_wsfe(&io___1521);
/* Writing concatenation */
#line 21986 ""
			    i__16[0] = 1, a__12[0] = all_1.sq;
#line 21986 ""
			    i__16[1] = 9, a__12[1] = "endpiece}";
#line 21986 ""
			    i__16[2] = 1, a__12[2] = all_1.sq;
#line 21986 ""
			    i__16[3] = 7, a__12[3] = "advance";
#line 21986 ""
			    i__16[4] = 1, a__12[4] = all_1.sq;
#line 21986 ""
			    i__16[5] = 5, a__12[5] = "barno";
#line 21986 ""
			    *(unsigned char *)&ch__1[0] = 
				    combibarcnt_1.ibarcnt - ibarcnt0 + 48;
#line 21986 ""
			    i__16[6] = 1, a__12[6] = ch__1;
#line 21986 ""
			    i__16[7] = 1, a__12[7] = all_1.sq;
#line 21986 ""
			    i__16[8] = 10, a__12[8] = "startbarno";
#line 21986 ""
			    i__16[9] = 1, a__12[9] = all_1.sq;
#line 21986 ""
			    i__16[10] = 6, a__12[10] = "barno%";
#line 21986 ""
			    s_cat(ch__36, a__12, i__16, &c__11, (ftnlen)43);
#line 21986 ""
			    do_fio(&c__1, ch__36, (ftnlen)43);
#line 21986 ""
			    e_wsfe();
#line 21989 ""
			    s_wsfe(&io___1522);
/* Writing concatenation */
#line 21989 ""
			    i__14[0] = 1, a__10[0] = all_1.sq;
#line 21989 ""
			    i__14[1] = 5, a__10[1] = "hfill";
#line 21989 ""
			    i__14[2] = 1, a__10[2] = all_1.sq;
#line 21989 ""
			    i__14[3] = 5, a__10[3] = "vbox{";
#line 21989 ""
			    i__14[4] = 1, a__10[4] = all_1.sq;
#line 21989 ""
			    i__14[5] = 6, a__10[5] = "hsize=";
#line 21989 ""
			    i__14[6] = 3, a__10[6] = shortfraq;
#line 21989 ""
			    i__14[7] = 1, a__10[7] = "%";
#line 21989 ""
			    s_cat(ch__3, a__10, i__14, &c__8, (ftnlen)23);
#line 21989 ""
			    do_fio(&c__1, ch__3, (ftnlen)23);
#line 21989 ""
			    e_wsfe();
#line 21991 ""
			    s_wsfe(&io___1523);
/* Writing concatenation */
#line 21991 ""
			    i__6[0] = 1, a__4[0] = all_1.sq;
#line 21991 ""
			    i__6[1] = 9, a__4[1] = "contpiece";
#line 21991 ""
			    s_cat(ch__20, a__4, i__6, &c__2, (ftnlen)10);
#line 21991 ""
			    do_fio(&c__1, ch__20, (ftnlen)10);
#line 21991 ""
			    e_wsfe();
#line 21992 ""
			    s_wsfe(&io___1524);
/* Writing concatenation */
#line 21992 ""
			    i__4[0] = 1, a__2[0] = all_1.sq;
#line 21992 ""
			    i__4[1] = 12, a__2[1] = "makeatletter";
#line 21992 ""
			    i__4[2] = 1, a__2[2] = all_1.sq;
#line 21992 ""
			    i__4[3] = 9, a__2[3] = "fil@begin";
#line 21992 ""
			    i__4[4] = 1, a__2[4] = all_1.sq;
#line 21992 ""
			    i__4[5] = 11, a__2[5] = "makeatother";
#line 21992 ""
			    s_cat(ch__9, a__2, i__4, &c__6, (ftnlen)35);
#line 21992 ""
			    do_fio(&c__1, ch__9, (ftnlen)35);
#line 21992 ""
			    e_wsfe();
#line 21994 ""
			    comshort_1.ishort = 4;
#line 21995 ""
			} else if (comshort_1.ishort == 4) {
/* End coda */
#line 21996 ""
			    ntmp = combibarcnt_1.ibarcnt - ibarcnt0 - 
				    comshort_1.nmbr + comshort_1.mbrsum;
#line 21997 ""
			    if (ntmp <= 9) {
#line 21998 ""
				*(unsigned char *)shortfraq = (char) (ntmp + 
					48);
#line 21999 ""
				lntmp = 1;
#line 22000 ""
			    } else {
#line 22001 ""
				s_wsfi(&io___1525);
#line 22001 ""
				do_fio(&c__1, (char *)&ntmp, (ftnlen)sizeof(
					integer));
#line 22001 ""
				e_wsfi();
#line 22002 ""
				lntmp = 2;
#line 22003 ""
			    }
#line 22004 ""
			    s_wsfe(&io___1526);
/* Writing concatenation */
#line 22004 ""
			    i__15[0] = 1, a__11[0] = all_1.sq;
#line 22004 ""
			    i__15[1] = 10, a__11[1] = "endpiece}}";
#line 22004 ""
			    i__15[2] = 1, a__11[2] = all_1.sq;
#line 22004 ""
			    i__15[3] = 7, a__11[3] = "advance";
#line 22004 ""
			    i__15[4] = 1, a__11[4] = all_1.sq;
#line 22004 ""
			    i__15[5] = 5, a__11[5] = "barno";
#line 22004 ""
			    i__15[6] = lntmp, a__11[6] = shortfraq;
#line 22004 ""
			    s_cat(ch__31, a__11, i__15, &c__7, (ftnlen)28);
#line 22004 ""
			    do_fio(&c__1, ch__31, lntmp + 25);
#line 22004 ""
			    e_wsfe();
#line 22006 ""
			    s_wsfe(&io___1527);
/* Writing concatenation */
#line 22006 ""
			    i__6[0] = 1, a__4[0] = all_1.sq;
#line 22006 ""
			    i__6[1] = 9, a__4[1] = "contpiece";
#line 22006 ""
			    s_cat(ch__20, a__4, i__6, &c__2, (ftnlen)10);
#line 22006 ""
			    do_fio(&c__1, ch__20, (ftnlen)10);
#line 22006 ""
			    e_wsfe();
#line 22007 ""
			    s_wsfe(&io___1528);
/* Writing concatenation */
#line 22007 ""
			    i__4[0] = 1, a__2[0] = all_1.sq;
#line 22007 ""
			    i__4[1] = 12, a__2[1] = "makeatletter";
#line 22007 ""
			    i__4[2] = 1, a__2[2] = all_1.sq;
#line 22007 ""
			    i__4[3] = 9, a__2[3] = "fil@begin";
#line 22007 ""
			    i__4[4] = 1, a__2[4] = all_1.sq;
#line 22007 ""
			    i__4[5] = 11, a__2[5] = "makeatother";
#line 22007 ""
			    s_cat(ch__9, a__2, i__4, &c__6, (ftnlen)35);
#line 22007 ""
			    do_fio(&c__1, ch__9, (ftnlen)35);
#line 22007 ""
			    e_wsfe();
#line 22009 ""
			    comshort_1.ishort = 0;
#line 22010 ""
			    comshort_1.mbrsum = 0;
#line 22011 ""
			    comshort_1.nmbr = 0;
#line 22012 ""
			}
#line 22013 ""
		    } else if (all_1.mtrnuml != 0) {

/*  New meter, no new sig, end of line, not new page. */

/* \generalmeter{\meterfrac{3}{4}}% */
/* \xchangecontext\addspace{-\afterruleskip}% */
/* \zalaligne\generalmeter{\meterfrac{3}{4}}\addspace{-\afterruleskip}% */
/* \zchangecontext */

#line 22023 ""
			setmeter_(&all_1.mtrnuml, &all_1.mtrdenl, &
				combeam_1.ibmtyp, &ibmrep);
#line 22024 ""
			if (comget_1.movbrk == 0) {
#line 22025 ""
			    if (comlast_1.islast) {
#line 22026 ""
				wgmeter_(&all_1.mtrnmp, &all_1.mtrdnp);
#line 22027 ""
			    }
#line 22028 ""
			    if (all_1.mtrdnp > 0) {
#line 22029 ""
				if (comlast_1.islast) {
#line 22030 ""
				    s_wsfe(&io___1529);
/* Writing concatenation */
#line 22030 ""
				    i__3[0] = 1, a__1[0] = all_1.sq;
#line 22030 ""
				    i__3[1] = 3, a__1[1] = "let";
#line 22030 ""
				    i__3[2] = 1, a__1[2] = all_1.sq;
#line 22030 ""
				    i__3[3] = 4, a__1[3] = "bnat";
#line 22030 ""
				    i__3[4] = 1, a__1[4] = all_1.sq;
#line 22030 ""
				    i__3[5] = 8, a__1[5] = "barnoadd";
#line 22030 ""
				    i__3[6] = 1, a__1[6] = all_1.sq;
#line 22030 ""
				    i__3[7] = 3, a__1[7] = "def";
#line 22030 ""
				    i__3[8] = 1, a__1[8] = all_1.sq;
#line 22030 ""
				    i__3[9] = 9, a__1[9] = "barnoadd{";
#line 22030 ""
				    i__3[10] = 1, a__1[10] = all_1.sq;
#line 22030 ""
				    i__3[11] = 7, a__1[11] = "empty}%";
#line 22030 ""
				    s_cat(ch__23, a__1, i__3, &c__12, (ftnlen)
					    40);
#line 22030 ""
				    do_fio(&c__1, ch__23, (ftnlen)40);
#line 22030 ""
				    e_wsfe();
#line 22033 ""
				    s_wsfe(&io___1530);
/* Writing concatenation */
#line 22033 ""
				    i__17[0] = 1, a__13[0] = all_1.sq;
#line 22033 ""
				    i__17[1] = 14, a__13[1] = "xchangecontext"
					    ;
#line 22033 ""
				    i__17[2] = 1, a__13[2] = all_1.sq;
#line 22033 ""
				    i__17[3] = 10, a__13[3] = "addspace{-";
#line 22033 ""
				    i__17[4] = 1, a__13[4] = all_1.sq;
#line 22033 ""
				    i__17[5] = 14, a__13[5] = "afterruleskip}"
					    ;
#line 22033 ""
				    i__17[6] = 1, a__13[6] = all_1.sq;
#line 22033 ""
				    i__17[7] = 9, a__13[7] = "zalaligne";
#line 22033 ""
				    i__17[8] = 1, a__13[8] = all_1.sq;
#line 22033 ""
				    i__17[9] = 3, a__13[9] = "let";
#line 22033 ""
				    i__17[10] = 1, a__13[10] = all_1.sq;
#line 22033 ""
				    i__17[11] = 8, a__13[11] = "barnoadd";
#line 22033 ""
				    i__17[12] = 1, a__13[12] = all_1.sq;
#line 22033 ""
				    i__17[13] = 4, a__13[13] = "bnat";
#line 22033 ""
				    s_cat(ch__37, a__13, i__17, &c__14, (
					    ftnlen)69);
#line 22033 ""
				    do_fio(&c__1, ch__37, (ftnlen)69);
#line 22033 ""
				    e_wsfe();
#line 22036 ""
				    wgmeter_(&all_1.mtrnmp, &all_1.mtrdnp);
#line 22037 ""
				    s_wsfe(&io___1531);
/* Writing concatenation */
#line 22037 ""
				    i__4[0] = 1, a__2[0] = all_1.sq;
#line 22037 ""
				    i__4[1] = 10, a__2[1] = "addspace{-";
#line 22037 ""
				    i__4[2] = 1, a__2[2] = all_1.sq;
#line 22037 ""
				    i__4[3] = 14, a__2[3] = "afterruleskip}";
#line 22037 ""
				    i__4[4] = 1, a__2[4] = all_1.sq;
#line 22037 ""
				    i__4[5] = 14, a__2[5] = "zchangecontext";
#line 22037 ""
				    s_cat(ch__38, a__2, i__4, &c__6, (ftnlen)
					    41);
#line 22037 ""
				    do_fio(&c__1, ch__38, (ftnlen)41);
#line 22037 ""
				    e_wsfe();
#line 22039 ""
				}
#line 22040 ""
				if (all_1.ibar == comgrace_1.ibarmbr) {
#line 22040 ""
				    comgrace_1.xb4mbr = all_1.musicsize * 
					    -.2f;
#line 22040 ""
				}
#line 22041 ""
			    } else {
#line 22042 ""
				if (comlast_1.islast) {
#line 22042 ""
				    s_wsfe(&io___1532);
/* Writing concatenation */
#line 22042 ""
				    i__6[0] = 1, a__4[0] = all_1.sq;
#line 22042 ""
				    i__6[1] = 8, a__4[1] = "alaligne";
#line 22042 ""
				    s_cat(ch__18, a__4, i__6, &c__2, (ftnlen)
					    9);
#line 22042 ""
				    do_fio(&c__1, ch__18, (ftnlen)9);
#line 22042 ""
				    e_wsfe();
#line 22042 ""
				}
#line 22043 ""
			    }
#line 22044 ""
			} else {
#line 22045 ""
			    if (comlast_1.islast) {
#line 22045 ""
				s_wsfe(&io___1533);
/* Writing concatenation */
#line 22045 ""
				i__6[0] = 1, a__4[0] = all_1.sq;
#line 22045 ""
				i__6[1] = 8, a__4[1] = "alaligne";
#line 22045 ""
				s_cat(ch__18, a__4, i__6, &c__2, (ftnlen)9);
#line 22045 ""
				do_fio(&c__1, ch__18, (ftnlen)9);
#line 22045 ""
				e_wsfe();
#line 22045 ""
			    }
#line 22046 ""
			}
#line 22047 ""
		    }
#line 22048 ""
		}

/*  Modified 090525 to use \bnrs */

#line 22052 ""
		if (slint) {
#line 22053 ""
		    slint = FALSE_;
#line 22054 ""
		    if (comlast_1.islast) {
#line 22054 ""
			s_wsfe(&io___1534);
/* Writing concatenation */
#line 22054 ""
			i__5[0] = 1, a__3[0] = all_1.sq;
#line 22054 ""
			i__5[1] = 3, a__3[1] = "def";
#line 22054 ""
			i__5[2] = 1, a__3[2] = all_1.sq;
#line 22054 ""
			i__5[3] = 11, a__3[3] = "raisebarno{";
#line 22054 ""
			s_cat(ch__22, a__3, i__5, &c__4, (ftnlen)16);
#line 22054 ""
			do_fio(&c__1, ch__22, (ftnlen)16);
#line 22054 ""
			do_fio(&c__1, (char *)&comsln_1.irzbnd, (ftnlen)
				sizeof(integer));
/* Writing concatenation */
#line 22054 ""
			i__8[0] = 2, a__5[0] = ".5";
#line 22054 ""
			i__8[1] = 1, a__5[1] = all_1.sq;
#line 22054 ""
			i__8[2] = 11, a__5[2] = "internote}%";
#line 22054 ""
			s_cat(ch__10, a__5, i__8, &c__3, (ftnlen)14);
#line 22054 ""
			do_fio(&c__1, ch__10, (ftnlen)14);
#line 22054 ""
			e_wsfe();
#line 22054 ""
		    }
#line 22056 ""
		}
#line 22057 ""
		comget_1.movbrk = 0;
#line 22058 ""
	    }

/*  Clean up if we squelched bar number reset at movement break */

#line 22062 ""
	    if (comnotes_1.nobar1) {
#line 22063 ""
		if (comlast_1.islast) {
#line 22063 ""
		    s_wsfe(&io___1535);
/* Writing concatenation */
#line 22063 ""
		    i__6[0] = 1, a__4[0] = all_1.sq;
#line 22063 ""
		    i__6[1] = 11, a__4[1] = "startbarno1";
#line 22063 ""
		    s_cat(ch__14, a__4, i__6, &c__2, (ftnlen)12);
#line 22063 ""
		    do_fio(&c__1, ch__14, (ftnlen)12);
#line 22063 ""
		    e_wsfe();
#line 22063 ""
		}
#line 22064 ""
		comnotes_1.nobar1 = FALSE_;
#line 22065 ""
	    }
#line 22066 ""
	    i__2 = s_rsle(&io___1536);
#line 22066 ""
	    if (i__2 != 0) {
#line 22066 ""
		goto L14;
#line 22066 ""
	    }
#line 22066 ""
	    i__2 = do_lio(&c__3, &c__1, (char *)&iauto, (ftnlen)sizeof(
		    integer));
#line 22066 ""
	    if (i__2 != 0) {
#line 22066 ""
		goto L14;
#line 22066 ""
	    }
#line 22066 ""
	    i__2 = e_rsle();
#line 22066 ""
	    if (i__2 != 0) {
#line 22066 ""
		goto L14;
#line 22066 ""
	    }
#line 22067 ""
L14:

/*  We come thru here for the 1st bar of every system, so initialize is1n1 */

#line 22071 ""
	    comsln_1.is1n1 = 0;

/*  Brought down from above */

#line 22075 ""
	    if (isystpg == comnotes_1.nsystp[comnotes_1.ipage - 1]) {
#line 22076 ""
		isystpg = 0;

/*  The following is to avoid moving this reset of isystpg, but still send a signal */
/*  down below for last system shortening events */

#line 22081 ""
		if (comshort_1.ishort == 2) {
#line 22081 ""
		    iflagbot = 1;
#line 22081 ""
		}
#line 22082 ""
	    }

/*  Check for linebreak ties */

#line 22086 ""
	    if (ispstie) {
#line 22086 ""
		linebreakties_(all_1.isdat1, all_1.isdat2, all_1.isdat3, 
			all_1.isdat4, &all_1.nsdat, &ispstie, all_1.sepsymq, (
			ftnlen)1);
#line 22086 ""
	    }
#line 22089 ""
	} else {

/*  Not first bar of system */

#line 22093 ""
	    if (bit_test(iplnow,28)) {

/*  Signature change */

#line 22097 ""
		if (all_1.mtrnuml != 0) {

/*  Meter+signature change mid line, assume no movement break */

#line 22101 ""
		    setmeter_(&all_1.mtrnuml, &all_1.mtrdenl, &
			    combeam_1.ibmtyp, &ibmrep);
#line 22102 ""
		    if (comlast_1.islast) {
#line 22102 ""
			wgmeter_(&all_1.mtrnmp, &all_1.mtrdnp);
#line 22102 ""
		    }
/* Writing concatenation */
#line 22103 ""
		    i__6[0] = 1, a__4[0] = all_1.sq;
#line 22103 ""
		    i__6[1] = 17, a__4[1] = "generalsignature{";
#line 22103 ""
		    s_cat(notexq, a__4, i__6, &c__2, (ftnlen)79);
#line 22104 ""
		    lnote = 18;
#line 22105 ""
		    if (comtop_1.isig < 0) {
/* Writing concatenation */
#line 22106 ""
			i__6[0] = 18, a__4[0] = notexq;
#line 22106 ""
			i__6[1] = 1, a__4[1] = "-";
#line 22106 ""
			s_cat(notexq, a__4, i__6, &c__2, (ftnlen)79);
#line 22107 ""
			lnote = 19;
#line 22108 ""
		    }
#line 22109 ""
		    if (comlast_1.islast) {
#line 22110 ""
			iptemp = abs(comtop_1.isig) + 48;
#line 22111 ""
			chax_(ch__1, (ftnlen)1, &iptemp);
#line 22111 ""
			*(unsigned char *)charq = *(unsigned char *)&ch__1[0];
/* Writing concatenation */
#line 22112 ""
			i__8[0] = lnote, a__5[0] = notexq;
#line 22112 ""
			i__8[1] = 1, a__5[1] = charq;
#line 22112 ""
			i__8[2] = 2, a__5[2] = "}%";
#line 22112 ""
			s_cat(notexq, a__5, i__8, &c__3, (ftnlen)79);
#line 22113 ""
			lnote += 3;
#line 22114 ""
			s_wsfe(&io___1539);
#line 22114 ""
			do_fio(&c__1, notexq, lnote);
#line 22114 ""
			e_wsfe();
#line 22115 ""
			if (comlast_1.islast && cominsttrans_1.laterinsttrans)
				 {
#line 22116 ""
			    writesetsign_(&cominsttrans_1.ninsttrans, 
				    cominsttrans_1.iinsttrans, 
				    cominsttrans_1.itranskey, &
				    cominsttrans_1.laterinsttrans);
#line 22118 ""
			}
#line 22119 ""
			if (comignorenats_1.ignorenats) {
#line 22119 ""
			    s_wsfe(&io___1540);
/* Writing concatenation */
#line 22119 ""
			    i__6[0] = 1, a__4[0] = all_1.sq;
#line 22119 ""
			    i__6[1] = 11, a__4[1] = "ignorenats%";
#line 22119 ""
			    s_cat(ch__14, a__4, i__6, &c__2, (ftnlen)12);
#line 22119 ""
			    do_fio(&c__1, ch__14, (ftnlen)12);
#line 22119 ""
			    e_wsfe();
#line 22119 ""
			}
#line 22120 ""
			s_wsfe(&io___1541);
/* Writing concatenation */
#line 22120 ""
			i__6[0] = 1, a__4[0] = all_1.sq;
#line 22120 ""
			i__6[1] = 15, a__4[1] = "xchangecontext%";
#line 22120 ""
			s_cat(ch__22, a__4, i__6, &c__2, (ftnlen)16);
#line 22120 ""
			do_fio(&c__1, ch__22, (ftnlen)16);
#line 22120 ""
			e_wsfe();
#line 22121 ""
		    }
#line 22122 ""
		    if (all_1.ibar == comgrace_1.ibarmbr) {

/*  Compute space for multibar rest */

#line 22126 ""
			if (comtop_1.lastisig * comtop_1.isig >= 0) {
/* Computing MAX */
#line 22127 ""
			    i__2 = abs(comtop_1.lastisig), i__7 = abs(
				    comtop_1.isig);
#line 22127 ""
			    naccs = max(i__2,i__7);
#line 22128 ""
			} else {
#line 22129 ""
			    naccs = (i__2 = comtop_1.lastisig - comtop_1.isig,
				     abs(i__2));
#line 22130 ""
			}
#line 22131 ""
			comgrace_1.xb4mbr = all_1.musicsize * -.2f;
#line 22132 ""
		    }
#line 22133 ""
		} else {

/*  Signature change only */

/* Writing concatenation */
#line 22137 ""
		    i__14[0] = 1, a__10[0] = all_1.sq;
#line 22137 ""
		    i__14[1] = 4, a__10[1] = "xbar";
#line 22137 ""
		    i__14[2] = 1, a__10[2] = all_1.sq;
#line 22137 ""
		    i__14[3] = 10, a__10[3] = "addspace{-";
#line 22137 ""
		    i__14[4] = 1, a__10[4] = all_1.sq;
#line 22137 ""
		    i__14[5] = 14, a__10[5] = "afterruleskip}";
#line 22137 ""
		    i__14[6] = 1, a__10[6] = all_1.sq;
#line 22137 ""
		    i__14[7] = 17, a__10[7] = "generalsignature{";
#line 22137 ""
		    s_cat(notexq, a__10, i__14, &c__8, (ftnlen)79);
#line 22139 ""
		    lnote = 49;
#line 22140 ""
		    if (comtop_1.isig < 0) {
/* Writing concatenation */
#line 22141 ""
			i__6[0] = 49, a__4[0] = notexq;
#line 22141 ""
			i__6[1] = 1, a__4[1] = "-";
#line 22141 ""
			s_cat(notexq, a__4, i__6, &c__2, (ftnlen)79);
#line 22142 ""
			lnote = 50;
#line 22143 ""
		    }
#line 22144 ""
		    if (comlast_1.islast) {
#line 22144 ""
			s_wsfe(&io___1543);
/* Writing concatenation */
#line 22144 ""
			i__8[0] = lnote, a__5[0] = notexq;
#line 22144 ""
			i__2 = abs(comtop_1.isig) + 48;
#line 22144 ""
			chax_(ch__1, (ftnlen)1, &i__2);
#line 22144 ""
			i__8[1] = 1, a__5[1] = ch__1;
#line 22144 ""
			i__8[2] = 2, a__5[2] = "}%";
#line 22144 ""
			s_cat(ch__27, a__5, i__8, &c__3, (ftnlen)82);
#line 22144 ""
			do_fio(&c__1, ch__27, lnote + 3);
#line 22144 ""
			e_wsfe();
#line 22144 ""
		    }
#line 22146 ""
		    if (comlast_1.islast && cominsttrans_1.laterinsttrans) {
#line 22147 ""
			writesetsign_(&cominsttrans_1.ninsttrans, 
				cominsttrans_1.iinsttrans, 
				cominsttrans_1.itranskey, &
				cominsttrans_1.laterinsttrans);
#line 22149 ""
		    }
#line 22150 ""
		    if (comlast_1.islast && comignorenats_1.ignorenats) {
#line 22150 ""
			s_wsfe(&io___1544);
/* Writing concatenation */
#line 22150 ""
			i__6[0] = 1, a__4[0] = all_1.sq;
#line 22150 ""
			i__6[1] = 11, a__4[1] = "ignorenats%";
#line 22150 ""
			s_cat(ch__14, a__4, i__6, &c__2, (ftnlen)12);
#line 22150 ""
			do_fio(&c__1, ch__14, (ftnlen)12);
#line 22150 ""
			e_wsfe();
#line 22150 ""
		    }
#line 22152 ""
		    if (comlast_1.islast) {
#line 22152 ""
			s_wsfe(&io___1545);
/* Writing concatenation */
#line 22152 ""
			i__4[0] = 1, a__2[0] = all_1.sq;
#line 22152 ""
			i__4[1] = 14, a__2[1] = "zchangecontext";
#line 22152 ""
			i__4[2] = 1, a__2[2] = all_1.sq;
#line 22152 ""
			i__4[3] = 12, a__2[3] = "addspace{-.5";
#line 22152 ""
			i__4[4] = 1, a__2[4] = all_1.sq;
#line 22152 ""
			i__4[5] = 15, a__2[5] = "afterruleskip}%";
#line 22152 ""
			s_cat(ch__39, a__2, i__4, &c__6, (ftnlen)44);
#line 22152 ""
			do_fio(&c__1, ch__39, (ftnlen)44);
#line 22152 ""
			e_wsfe();
#line 22152 ""
		    }
#line 22154 ""
		    if (all_1.ibar == comgrace_1.ibarmbr) {

/*  Compute space for multibar rest */

#line 22158 ""
			if (comtop_1.lastisig * comtop_1.isig >= 0) {
/* Computing MAX */
#line 22159 ""
			    i__2 = abs(comtop_1.lastisig), i__7 = abs(
				    comtop_1.isig);
#line 22159 ""
			    naccs = max(i__2,i__7);
#line 22160 ""
			} else {
#line 22161 ""
			    naccs = (i__2 = comtop_1.lastisig - comtop_1.isig,
				     abs(i__2));
#line 22162 ""
			}
#line 22163 ""
			comgrace_1.xb4mbr = all_1.musicsize * -.2f;
#line 22164 ""
		    }
#line 22165 ""
		}
#line 22166 ""
	    } else if (comshort_1.ishort == 3) {

/*  Gap before coda, assumed no signature change! */

#line 22170 ""
		ntmp = combibarcnt_1.ibarcnt - ibarcnt0 - comshort_1.nmbr + 
			comshort_1.mbrsum;
#line 22171 ""
		if (ntmp <= 9) {
#line 22172 ""
		    *(unsigned char *)shortfraq = (char) (ntmp + 48);
#line 22173 ""
		    lntmp = 1;
#line 22174 ""
		} else {
#line 22175 ""
		    s_wsfi(&io___1546);
#line 22175 ""
		    do_fio(&c__1, (char *)&ntmp, (ftnlen)sizeof(integer));
#line 22175 ""
		    e_wsfi();
#line 22176 ""
		    lntmp = 2;
#line 22177 ""
		}
#line 22178 ""
		s_wsfe(&io___1547);
/* Writing concatenation */
#line 22178 ""
		i__15[0] = 1, a__11[0] = all_1.sq;
#line 22178 ""
		i__15[1] = 9, a__11[1] = "endpiece}";
#line 22178 ""
		i__15[2] = 1, a__11[2] = all_1.sq;
#line 22178 ""
		i__15[3] = 7, a__11[3] = "advance";
#line 22178 ""
		i__15[4] = 1, a__11[4] = all_1.sq;
#line 22178 ""
		i__15[5] = 5, a__11[5] = "barno";
#line 22178 ""
		i__15[6] = lntmp, a__11[6] = shortfraq;
#line 22178 ""
		s_cat(ch__5, a__11, i__15, &c__7, (ftnlen)27);
#line 22178 ""
		do_fio(&c__1, ch__5, lntmp + 24);
#line 22178 ""
		e_wsfe();
#line 22180 ""
		if (comshort_1.nocodabn) {
#line 22181 ""
		    s_wsfe(&io___1548);
/* Writing concatenation */
#line 22181 ""
		    i__6[0] = 1, a__4[0] = all_1.sq;
#line 22181 ""
		    i__6[1] = 7, a__4[1] = "nobarno";
#line 22181 ""
		    s_cat(ch__8, a__4, i__6, &c__2, (ftnlen)8);
#line 22181 ""
		    do_fio(&c__1, ch__8, (ftnlen)8);
#line 22181 ""
		    e_wsfe();
#line 22182 ""
		    comshort_1.nocodabn = FALSE_;
#line 22183 ""
		}
#line 22184 ""
		s_wsfi(&io___1549);
#line 22184 ""
		do_fio(&c__1, (char *)&comshort_1.codafrac, (ftnlen)sizeof(
			real));
#line 22184 ""
		e_wsfi();
#line 22185 ""
		s_wsfe(&io___1550);
/* Writing concatenation */
#line 22185 ""
		i__10[0] = 1, a__7[0] = all_1.sq;
#line 22185 ""
		i__10[1] = 5, a__7[1] = "hfill";
#line 22185 ""
		i__10[2] = 1, a__7[2] = all_1.sq;
#line 22185 ""
		i__10[3] = 5, a__7[3] = "vbox{";
#line 22185 ""
		i__10[4] = 1, a__7[4] = all_1.sq;
#line 22185 ""
		i__10[5] = 6, a__7[5] = "hsize=";
#line 22185 ""
		i__10[6] = 3, a__7[6] = shortfraq;
#line 22185 ""
		i__10[7] = 1, a__7[7] = all_1.sq;
#line 22185 ""
		i__10[8] = 6, a__7[8] = "hsize%";
#line 22185 ""
		s_cat(ch__7, a__7, i__10, &c__9, (ftnlen)29);
#line 22185 ""
		do_fio(&c__1, ch__7, (ftnlen)29);
#line 22185 ""
		e_wsfe();
#line 22187 ""
		s_wsfe(&io___1551);
/* Writing concatenation */
#line 22187 ""
		i__6[0] = 1, a__4[0] = all_1.sq;
#line 22187 ""
		i__6[1] = 9, a__4[1] = "contpiece";
#line 22187 ""
		s_cat(ch__20, a__4, i__6, &c__2, (ftnlen)10);
#line 22187 ""
		do_fio(&c__1, ch__20, (ftnlen)10);
#line 22187 ""
		e_wsfe();
#line 22188 ""
		s_wsfe(&io___1552);
/* Writing concatenation */
#line 22188 ""
		i__4[0] = 1, a__2[0] = all_1.sq;
#line 22188 ""
		i__4[1] = 12, a__2[1] = "makeatletter";
#line 22188 ""
		i__4[2] = 1, a__2[2] = all_1.sq;
#line 22188 ""
		i__4[3] = 9, a__2[3] = "fil@begin";
#line 22188 ""
		i__4[4] = 1, a__2[4] = all_1.sq;
#line 22188 ""
		i__4[5] = 11, a__2[5] = "makeatother";
#line 22188 ""
		s_cat(ch__9, a__2, i__4, &c__6, (ftnlen)35);
#line 22188 ""
		do_fio(&c__1, ch__9, (ftnlen)35);
#line 22188 ""
		e_wsfe();
#line 22190 ""
		comshort_1.ishort = 4;
#line 22191 ""
	    } else if (all_1.mtrnuml == 0) {

/*  No meter change */

#line 22195 ""
		if (comlast_1.islast) {
#line 22195 ""
		    s_wsfe(&io___1553);
/* Writing concatenation */
#line 22195 ""
		    i__6[0] = 1, a__4[0] = all_1.sq;
#line 22195 ""
		    i__6[1] = 4, a__4[1] = "xbar";
#line 22195 ""
		    s_cat(ch__40, a__4, i__6, &c__2, (ftnlen)5);
#line 22195 ""
		    do_fio(&c__1, ch__40, (ftnlen)5);
#line 22195 ""
		    e_wsfe();
#line 22195 ""
		}
#line 22196 ""
	    } else {

/*  Change meter midline */

#line 22200 ""
		setmeter_(&all_1.mtrnuml, &all_1.mtrdenl, &combeam_1.ibmtyp, &
			ibmrep);
#line 22201 ""
		if (comget_1.movbrk == 0) {
#line 22202 ""
		    if (comlast_1.islast) {
#line 22203 ""
			wgmeter_(&all_1.mtrnmp, &all_1.mtrdnp);
#line 22204 ""
		    }
#line 22205 ""
		    if (all_1.mtrdnp > 0) {
#line 22206 ""
			if (comlast_1.islast) {
#line 22207 ""
			    s_wsfe(&io___1554);
/* Writing concatenation */
#line 22207 ""
			    i__6[0] = 1, a__4[0] = all_1.sq;
#line 22207 ""
			    i__6[1] = 10, a__4[1] = "newtimes0%";
#line 22207 ""
			    s_cat(ch__15, a__4, i__6, &c__2, (ftnlen)11);
#line 22207 ""
			    do_fio(&c__1, ch__15, (ftnlen)11);
#line 22207 ""
			    e_wsfe();
#line 22208 ""
			}
#line 22209 ""
			if (all_1.ibar == comgrace_1.ibarmbr) {
#line 22209 ""
			    comgrace_1.xb4mbr = all_1.musicsize * -.2f;
#line 22209 ""
			}
#line 22210 ""
		    } else {
#line 22211 ""
			if (comlast_1.islast) {
#line 22211 ""
			    s_wsfe(&io___1555);
/* Writing concatenation */
#line 22211 ""
			    i__6[0] = 1, a__4[0] = all_1.sq;
#line 22211 ""
			    i__6[1] = 4, a__4[1] = "xbar";
#line 22211 ""
			    s_cat(ch__40, a__4, i__6, &c__2, (ftnlen)5);
#line 22211 ""
			    do_fio(&c__1, ch__40, (ftnlen)5);
#line 22211 ""
			    e_wsfe();
#line 22211 ""
			}
#line 22212 ""
		    }
#line 22213 ""
		}
#line 22214 ""
	    }
#line 22215 ""
	}

/*  Now that xbar's are written, can put in left-repeats at line beginnings */

#line 22219 ""
	if (lrptpend) {
#line 22220 ""
	    if (comlast_1.islast) {
#line 22220 ""
		s_wsfe(&io___1556);
/* Writing concatenation */
#line 22220 ""
		i__4[0] = 1, a__2[0] = all_1.sq;
#line 22220 ""
		i__4[1] = 7, a__2[1] = "advance";
#line 22220 ""
		i__4[2] = 1, a__2[2] = all_1.sq;
#line 22220 ""
		i__4[3] = 7, a__2[3] = "barno-1";
#line 22220 ""
		i__4[4] = 1, a__2[4] = all_1.sq;
#line 22220 ""
		i__4[5] = 10, a__2[5] = "leftrepeat";
#line 22220 ""
		s_cat(ch__5, a__2, i__4, &c__6, (ftnlen)27);
#line 22220 ""
		do_fio(&c__1, ch__5, (ftnlen)27);
#line 22220 ""
		e_wsfe();
#line 22220 ""
	    }
#line 22222 ""
	    lrptpend = FALSE_;
#line 22223 ""
	}
#line 22224 ""
	if (all_1.ibar > 1) {

/*  For bars after first, slide all stuff down to beginning of arrays */

#line 22228 ""
	    i__2 = all_1.nv;
#line 22228 ""
	    for (all_1.iv = 1; all_1.iv <= i__2; ++all_1.iv) {
#line 22229 ""
		i__7 = commvl_1.nvmx[all_1.iv - 1];
#line 22229 ""
		for (kv = 1; kv <= i__7; ++kv) {
#line 22230 ""
		    commvl_1.ivx = commvl_1.ivmx[all_1.iv + kv * 24 - 25];
#line 22231 ""
		    ioff = all_1.nib[commvl_1.ivx + (all_1.ibar - 1) * 24 - 
			    25];
#line 22232 ""
		    i__13 = all_1.nib[commvl_1.ivx + all_1.ibar * 24 - 25] - 
			    ioff;
#line 22232 ""
		    for (ip = 1; ip <= i__13; ++ip) {
#line 22233 ""
			all_1.nolev[commvl_1.ivx + ip * 24 - 25] = 
				all_1.nolev[commvl_1.ivx + (ip + ioff) * 24 - 
				25];
#line 22234 ""
			all_1.nodur[commvl_1.ivx + ip * 24 - 25] = 
				all_1.nodur[commvl_1.ivx + (ip + ioff) * 24 - 
				25];
#line 22235 ""
			all_1.nacc[commvl_1.ivx + ip * 24 - 25] = all_1.nacc[
				commvl_1.ivx + (ip + ioff) * 24 - 25];
#line 22236 ""
			all_1.irest[commvl_1.ivx + ip * 24 - 25] = 
				all_1.irest[commvl_1.ivx + (ip + ioff) * 24 - 
				25];
#line 22237 ""
			all_1.islur[commvl_1.ivx + ip * 24 - 25] = 
				all_1.islur[commvl_1.ivx + (ip + ioff) * 24 - 
				25];
#line 22238 ""
			all_1.ipl[commvl_1.ivx + ip * 24 - 25] = all_1.ipl[
				commvl_1.ivx + (ip + ioff) * 24 - 25];
#line 22239 ""
			all_1.iornq[commvl_1.ivx + ip * 24 - 1] = all_1.iornq[
				commvl_1.ivx + (ip + ioff) * 24 - 1];
#line 22240 ""
			all_1.mult[commvl_1.ivx + ip * 24 - 25] = all_1.mult[
				commvl_1.ivx + (ip + ioff) * 24 - 25];
#line 22241 ""
			if (all_1.figbass && commvl_1.ivx == 1 || 
				commvl_1.ivx == comfig_1.ivxfig2) {
#line 22242 ""
			    if (commvl_1.ivx == 1) {
#line 22243 ""
				all_1.isfig[(ip << 1) - 2] = all_1.isfig[(ip 
					+ ioff << 1) - 2];
#line 22244 ""
			    } else {
#line 22245 ""
				all_1.isfig[(ip << 1) - 1] = all_1.isfig[(ip 
					+ ioff << 1) - 1];
#line 22246 ""
			    }
#line 22247 ""
			}
#line 22248 ""
/* L12: */
#line 22248 ""
		    }
#line 22249 ""
		    if (commvl_1.ivx <= all_1.nv && comcc_1.ncc[all_1.iv - 1] 
			    > 1) {
#line 22250 ""
			islide = 0;
#line 22251 ""
			i__13 = comcc_1.ncc[all_1.iv - 1];
#line 22251 ""
			for (icc = 1; icc <= i__13; ++icc) {
#line 22252 ""
			    if (comcc_1.tcc[all_1.iv + icc * 24 - 25] <= (
				    real) all_1.lenbar) {

/*  This time will drop <=0 when slid. */

#line 22256 ""
				islide = icc - 1;
#line 22257 ""
				comcc_1.ncmidcc[all_1.iv - 1] = 
					comcc_1.ncmidcc[all_1.iv + icc * 24 - 
					25];
#line 22258 ""
			    } else {
#line 22259 ""
				comcc_1.tcc[all_1.iv + (icc - islide) * 24 - 
					25] = comcc_1.tcc[all_1.iv + icc * 24 
					- 25] - all_1.lenbar;
#line 22260 ""
				comcc_1.ncmidcc[all_1.iv + (icc - islide) * 
					24 - 25] = comcc_1.ncmidcc[all_1.iv + 
					icc * 24 - 25];
#line 22261 ""
			    }
#line 22262 ""
/* L13: */
#line 22262 ""
			}
#line 22263 ""
			comcc_1.ncc[all_1.iv - 1] -= islide;
#line 22264 ""
			comcc_1.tcc[all_1.iv - 1] = 0.f;
#line 22265 ""
		    }
#line 22266 ""
/* L1199: */
#line 22266 ""
		}
#line 22267 ""
/* L11: */
#line 22267 ""
	    }
#line 22268 ""
	    i__2 = comgrace_1.ngrace;
#line 22268 ""
	    for (ig = 1; ig <= i__2; ++ig) {
#line 22269 ""
		comgrace_1.ipg[ig - 1] -= all_1.nib[comgrace_1.ivg[ig - 1] + (
			all_1.ibar - 1) * 24 - 25];
#line 22270 ""
		if (all_1.ibar > 2) {
#line 22270 ""
		    comgrace_1.ipg[ig - 1] += all_1.nib[comgrace_1.ivg[ig - 1]
			     + (all_1.ibar - 2) * 24 - 25];
#line 22270 ""
		}
#line 22271 ""
/* L15: */
#line 22271 ""
	    }
#line 22272 ""
	    i__2 = comgrace_1.nlit;
#line 22272 ""
	    for (il = 1; il <= i__2; ++il) {
#line 22273 ""
		comgrace_1.iplit[il - 1] -= all_1.nib[comgrace_1.ivlit[il - 1]
			 + (all_1.ibar - 1) * 24 - 25];
#line 22274 ""
		if (all_1.ibar > 2) {
#line 22274 ""
		    comgrace_1.iplit[il - 1] += all_1.nib[comgrace_1.ivlit[il 
			    - 1] + (all_1.ibar - 2) * 24 - 25];
#line 22274 ""
		}
#line 22275 ""
/* L21: */
#line 22275 ""
	    }
#line 22276 ""
	    i__2 = comtrill_1.ntrill;
#line 22276 ""
	    for (it = 1; it <= i__2; ++it) {
#line 22277 ""
		comtrill_1.iptrill[it - 1] -= all_1.nib[comtrill_1.ivtrill[it 
			- 1] + (all_1.ibar - 1) * 24 - 25];
#line 22278 ""
		if (all_1.ibar > 2) {
#line 22278 ""
		    comtrill_1.iptrill[it - 1] += all_1.nib[
			    comtrill_1.ivtrill[it - 1] + (all_1.ibar - 2) * 
			    24 - 25];
#line 22278 ""
		}
#line 22280 ""
/* L22: */
#line 22280 ""
	    }
#line 22281 ""
	    i__2 = comtrill_1.ncrd;
#line 22281 ""
	    for (icrd = 1; icrd <= i__2; ++icrd) {
#line 22282 ""
		commvl_1.ivx = (15 & lbit_shift(comtrill_1.icrdat[icrd - 1], (
			ftnlen)-8)) + (igetbits_(&comtrill_1.icrdat[icrd - 1],
			 &c__1, &c__28) << 4);
#line 22284 ""
		ipnew = (255 & comtrill_1.icrdat[icrd - 1]) - all_1.nib[
			commvl_1.ivx + (all_1.ibar - 1) * 24 - 25];
#line 22285 ""
		if (all_1.ibar > 2) {
#line 22285 ""
		    ipnew += all_1.nib[commvl_1.ivx + (all_1.ibar - 2) * 24 - 
			    25];
#line 22285 ""
		}
#line 22286 ""
		comtrill_1.icrdat[icrd - 1] = -256 & comtrill_1.icrdat[icrd - 
			1];
#line 22287 ""
		comtrill_1.icrdat[icrd - 1] = max(0,ipnew) | 
			comtrill_1.icrdat[icrd - 1];
#line 22288 ""
/* L27: */
#line 22288 ""
	    }
#line 22289 ""
	    i__2 = comtrill_1.nudorn;
#line 22289 ""
	    for (iudorn = 1; iudorn <= i__2; ++iudorn) {
#line 22290 ""
		commvl_1.ivx = comivxudorn_1.ivxudorn[iudorn - 1];
#line 22291 ""
		ipnew = (255 & comtrill_1.kudorn[iudorn - 1]) - all_1.nib[
			commvl_1.ivx + (all_1.ibar - 1) * 24 - 25];
#line 22292 ""
		if (all_1.ibar > 2) {
#line 22292 ""
		    ipnew += all_1.nib[commvl_1.ivx + (all_1.ibar - 2) * 24 - 
			    25];
#line 22292 ""
		}
#line 22293 ""
		comtrill_1.kudorn[iudorn - 1] = -256 & comtrill_1.kudorn[
			iudorn - 1];
#line 22294 ""
		comtrill_1.kudorn[iudorn - 1] = max(0,ipnew) | 
			comtrill_1.kudorn[iudorn - 1];
#line 22295 ""
/* L29: */
#line 22295 ""
	    }
#line 22296 ""
	    i__2 = comdyn_1.ndyn;
#line 22296 ""
	    for (idyn = 1; idyn <= i__2; ++idyn) {
#line 22297 ""
		idynd = comdyn_1.idyndat[idyn - 1];
#line 22298 ""
		commvl_1.ivx = (15 & idynd) + (igetbits_(&comdyn_1.idynda2[
			idyn - 1], &c__1, &c__10) << 4);
#line 22299 ""
		ipnew = igetbits_(&idynd, &c__8, &c__4) - all_1.nib[
			commvl_1.ivx + (all_1.ibar - 1) * 24 - 25];

/* The following construction avoids array bound errors in some compilers */

#line 22303 ""
		if (all_1.ibar > 2) {
#line 22304 ""
		    ipnew += all_1.nib[commvl_1.ivx + (all_1.ibar - 2) * 24 - 
			    25];
#line 22305 ""
		}
#line 22306 ""
		ipnew = i_dim(&ipnew, &c__0);
#line 22307 ""
		setbits_(&idynd, &c__8, &c__4, &ipnew);
#line 22308 ""
		comdyn_1.idyndat[idyn - 1] = idynd;
#line 22309 ""
/* L42: */
#line 22309 ""
	    }
#line 22310 ""
	    i__2 = comdyn_1.ntxtdyn;
#line 22310 ""
	    for (itxtdyn = 1; itxtdyn <= i__2; ++itxtdyn) {
#line 22311 ""
		idynd = comdyn_1.ivxiptxt[itxtdyn - 1];
#line 22312 ""
		commvl_1.ivx = 31 & idynd;
#line 22313 ""
		ipnew = igetbits_(&idynd, &c__8, &c__5) - all_1.nib[
			commvl_1.ivx + (all_1.ibar - 1) * 24 - 25];
#line 22314 ""
		if (all_1.ibar > 2) {
#line 22315 ""
		    ipnew += all_1.nib[commvl_1.ivx + (all_1.ibar - 2) * 24 - 
			    25];
#line 22316 ""
		}
#line 22317 ""
		ipnew = i_dim(&ipnew, &c__0);
/*            call setbits(idynd,8,4,ipnew) */
#line 22319 ""
		setbits_(&idynd, &c__8, &c__5, &ipnew);
#line 22320 ""
		comdyn_1.ivxiptxt[itxtdyn - 1] = idynd;
#line 22321 ""
/* L43: */
#line 22321 ""
	    }
#line 22322 ""
	    i__2 = all_1.nsdat;
#line 22322 ""
	    for (isdat = 1; isdat <= i__2; ++isdat) {
#line 22323 ""
		isdata = all_1.isdat1[isdat - 1];
#line 22324 ""
		commvl_1.ivx = commvl_1.ivmx[igetbits_(&isdata, &c__5, &c__13)
			 + (igetbits_(&isdata, &c__1, &c__12) + 1) * 24 - 25];
#line 22325 ""
		ipnew = igetbits_(&isdata, &c__8, &c__3) - all_1.nib[
			commvl_1.ivx + (all_1.ibar - 1) * 24 - 25];
#line 22326 ""
		if (all_1.ibar > 2) {
#line 22327 ""
		    ipnew += all_1.nib[commvl_1.ivx + (all_1.ibar - 2) * 24 - 
			    25];
#line 22328 ""
		}
#line 22329 ""
		ipnew = i_dim(&ipnew, &c__0);
#line 22330 ""
		setbits_(&isdata, &c__8, &c__3, &ipnew);
#line 22331 ""
		all_1.isdat1[isdat - 1] = isdata;
#line 22332 ""
/* L41: */
#line 22332 ""
	    }
#line 22333 ""
	    i__2 = comcb_1.nbc;
#line 22333 ""
	    for (ibc = 1; ibc <= i__2; ++ibc) {
#line 22334 ""
		commvl_1.ivx = (15 & comcb_1.ibcdata[ibc - 1]) + (igetbits_(&
			comcb_1.ibcdata[ibc - 1], &c__1, &c__28) << 4);
#line 22335 ""
		ipnew = igetbits_(&comcb_1.ibcdata[ibc - 1], &c__8, &c__4) - 
			all_1.nib[commvl_1.ivx + (all_1.ibar - 1) * 24 - 25];
#line 22336 ""
		if (all_1.ibar > 2) {
#line 22337 ""
		    ipnew += all_1.nib[commvl_1.ivx + (all_1.ibar - 2) * 24 - 
			    25];
#line 22338 ""
		}
#line 22339 ""
		ipnew = i_dim(&ipnew, &c__0);
#line 22340 ""
		setbits_(&comcb_1.ibcdata[ibc - 1], &c__8, &c__4, &ipnew);
#line 22341 ""
/* L44: */
#line 22341 ""
	    }
#line 22342 ""
	    i__2 = comarpshift_1.numarpshift;
#line 22342 ""
	    for (iarps = 1; iarps <= i__2; ++iarps) {
#line 22343 ""
		comarpshift_1.iparpshift[iarps - 1] -= all_1.nib[
			comarpshift_1.ivarpshift[iarps - 1] + (all_1.ibar - 1)
			 * 24 - 25];
#line 22345 ""
		if (all_1.ibar > 2) {
#line 22346 ""
		    comarpshift_1.iparpshift[iarps - 1] += all_1.nib[
			    comarpshift_1.ivarpshift[iarps - 1] + (all_1.ibar 
			    - 2) * 24 - 25];
#line 22348 ""
		}
#line 22349 ""
/* L45: */
#line 22349 ""
	    }

/*  Bookkeeping for figures.  This will set nfigs = 0 if there are no figs left. */
/*  If there are figs left, it will reset all times relative to start of */
/*  current bar. */

#line 22355 ""
	    for (commvl_1.ivx = 1; commvl_1.ivx <= 2; ++commvl_1.ivx) {
#line 22356 ""
		if (all_1.figbass) {
#line 22357 ""
		    islide = 0;
#line 22358 ""
		    i__2 = comfig_1.nfigs[commvl_1.ivx - 1];
#line 22358 ""
		    for (jfig = 1; jfig <= i__2; ++jfig) {
#line 22359 ""
			if (comfig_1.itfig[commvl_1.ivx + (jfig << 1) - 3] < 
				all_1.lenbar) {

/*  This figure was already used */

#line 22363 ""
			    islide = jfig;
#line 22364 ""
			} else {
#line 22365 ""
			    comfig_1.itfig[commvl_1.ivx + (jfig - islide << 1)
				     - 3] = comfig_1.itfig[commvl_1.ivx + (
				    jfig << 1) - 3] - all_1.lenbar;
#line 22366 ""
			    s_copy(comfig_1.figq + (commvl_1.ivx + (jfig - 
				    islide << 1) - 3) * 10, comfig_1.figq + (
				    commvl_1.ivx + (jfig << 1) - 3) * 10, (
				    ftnlen)10, (ftnlen)10);
#line 22367 ""
			    comgrace_1.itoff[commvl_1.ivx + (jfig - islide << 
				    1) - 3] = comgrace_1.itoff[commvl_1.ivx + 
				    (jfig << 1) - 3];
#line 22368 ""
			    comfig_1.ivupfig[commvl_1.ivx + (jfig - islide << 
				    1) - 3] = comfig_1.ivupfig[commvl_1.ivx + 
				    (jfig << 1) - 3];
#line 22369 ""
			    comfig_1.ivvfig[commvl_1.ivx + (jfig - islide << 
				    1) - 3] = comfig_1.ivvfig[commvl_1.ivx + (
				    jfig << 1) - 3];
#line 22370 ""
			}
#line 22371 ""
/* L20: */
#line 22371 ""
		    }
#line 22372 ""
		    comfig_1.nfigs[commvl_1.ivx - 1] -= islide;
#line 22373 ""
		}
#line 22374 ""
		if (comfig_1.nfigs[1] == 0) {
#line 22374 ""
		    goto L47;
#line 22374 ""
		}
#line 22375 ""
/* L46: */
#line 22375 ""
	    }
#line 22376 ""
L47:
#line 22377 ""
	    ;
#line 22377 ""
	}

/*  End of sliding down for bars after first in gulp. */

/*  The following may not be needed by makeabar, but just in case... */

#line 22383 ""
	if (all_1.firstgulp && all_1.lenb0 != 0) {
#line 22384 ""
	    if (all_1.ibar == 1) {
#line 22385 ""
		all_1.lenbar = all_1.lenb0;
#line 22386 ""
	    } else {
#line 22387 ""
		all_1.lenbar = all_1.lenb1;
#line 22388 ""
	    }
#line 22389 ""
	}

/*  Equal line spacing stuff */

#line 22393 ""
	if (comget_1.equalize && comask_1.bar1syst) {
#line 22394 ""
	    if (isystpg == 1) {
#line 22395 ""
		s_wsfe(&io___1572);
/* Writing concatenation */
#line 22395 ""
		i__6[0] = 1, a__4[0] = all_1.sq;
#line 22395 ""
		i__6[1] = 8, a__4[1] = "starteq%";
#line 22395 ""
		s_cat(ch__18, a__4, i__6, &c__2, (ftnlen)9);
#line 22395 ""
		do_fio(&c__1, ch__18, (ftnlen)9);
#line 22395 ""
		e_wsfe();
#line 22396 ""
	    } else if (isystpg == comnotes_1.nsystp[comnotes_1.ipage - 1] - 1)
		     {
#line 22397 ""
		s_wsfe(&io___1573);
/* Writing concatenation */
#line 22397 ""
		i__6[0] = 1, a__4[0] = all_1.sq;
#line 22397 ""
		i__6[1] = 6, a__4[1] = "endeq%";
#line 22397 ""
		s_cat(ch__41, a__4, i__6, &c__2, (ftnlen)7);
#line 22397 ""
		do_fio(&c__1, ch__41, (ftnlen)7);
#line 22397 ""
		e_wsfe();
#line 22398 ""
	    }
#line 22399 ""
	}
#line 22400 ""
	make1bar_(&ibmrep, &tglp1, tstart, cwrest, squez, istop, numbms, 
		istart);
#line 22402 ""
	make2bar_(&comnotes_1.ninow, &tglp1, tstart, cwrest, squez, istop, 
		numbms, istart, comclefq_1.clefq, (ftnlen)1);

/*  Hardspace before barline? */

#line 22407 ""
	hardb4 = 0.f;
#line 22408 ""
	i__2 = all_1.nv;
#line 22408 ""
	for (all_1.iv = 1; all_1.iv <= i__2; ++all_1.iv) {
#line 22409 ""
	    i__7 = commvl_1.nvmx[all_1.iv - 1];
#line 22409 ""
	    for (kv = 1; kv <= i__7; ++kv) {
#line 22410 ""
		commvl_1.ivx = commvl_1.ivmx[all_1.iv + kv * 24 - 25];
#line 22411 ""
		if (bit_test(all_1.irest[commvl_1.ivx + all_1.nn[commvl_1.ivx 
			- 1] * 24 - 25],18)) {
#line 22412 ""
		    ++comudsp_1.nudoff[commvl_1.ivx - 1];
/* Computing MAX */
#line 22413 ""
		    r__1 = hardb4, r__2 = comudsp_1.udoff[commvl_1.ivx + 
			    comudsp_1.nudoff[commvl_1.ivx - 1] * 24 - 25];
#line 22413 ""
		    hardb4 = dmax(r__1,r__2);
#line 22414 ""
		}
#line 22415 ""
/* L3599: */
#line 22415 ""
	    }
#line 22416 ""
/* L35: */
#line 22416 ""
	}
#line 22417 ""
	if (hardb4 > 0.f) {
#line 22418 ""
	    if (comlast_1.islast) {
#line 22418 ""
		s_wsfe(&io___1581);
/* Writing concatenation */
#line 22418 ""
		i__6[0] = 1, a__4[0] = all_1.sq;
#line 22418 ""
		i__6[1] = 10, a__4[1] = "hardspace{";
#line 22418 ""
		s_cat(ch__15, a__4, i__6, &c__2, (ftnlen)11);
#line 22418 ""
		do_fio(&c__1, ch__15, (ftnlen)11);
#line 22418 ""
		do_fio(&c__1, (char *)&hardb4, (ftnlen)sizeof(real));
#line 22418 ""
		do_fio(&c__1, "pt}%", (ftnlen)4);
#line 22418 ""
		e_wsfe();
#line 22418 ""
	    }

/* This was causing an incorrect poe in an example, which did not affect main */
/*   spacing, but did cause an extra accidental space to be too small */

#line 22424 ""
	    comask_1.fixednew -= hardb4;
#line 22425 ""
	}
#line 22426 ""
/* L10: */
#line 22426 ""
    }
#line 22427 ""
    all_1.firstgulp = FALSE_;
#line 22428 ""
    all_1.lenb0 = 0;
#line 22429 ""
    goto L30;
#line 22430 ""
L40:
#line 22430 ""
    cl__1.cerr = 0;
#line 22430 ""
    cl__1.cunit = 12;
#line 22430 ""
    cl__1.csta = 0;
#line 22430 ""
    f_clos(&cl__1);
#line 22431 ""
    cl__1.cerr = 0;
#line 22431 ""
    cl__1.cunit = 13;
#line 22431 ""
    cl__1.csta = 0;
#line 22431 ""
    f_clos(&cl__1);
#line 22432 ""
    inbuff_1.ilbuf = 1;
#line 22433 ""
    inbuff_1.ipbuf = 0;
#line 22434 ""
    wdpt = comtop_1.widthpt;
#line 22435 ""
    if (all_1.iline == 1) {
#line 22435 ""
	wdpt = comtop_1.widthpt * (1 - comtop_1.fracindent);
#line 22435 ""
    }
#line 22436 ""
    poe = (wdpt - fsyst * all_1.musicsize - nbarss * .4f - comask_1.fixednew) 
	    / (elsktot + comask_1.fbar * nbarss - comask_1.scaldold);
#line 22438 ""
    poevec[nsyst] = poe;
#line 22439 ""
    if (! comlast_1.islast) {
#line 22440 ""
	cl__1.cerr = 0;
#line 22440 ""
	cl__1.cunit = 11;
#line 22440 ""
	cl__1.csta = 0;
#line 22440 ""
	f_clos(&cl__1);
#line 22441 ""
	cl__1.cerr = 0;
#line 22441 ""
	cl__1.cunit = 16;
#line 22441 ""
	cl__1.csta = 0;
#line 22441 ""
	f_clos(&cl__1);
#line 22442 ""
	if (all_1.figbass) {
#line 22442 ""
	    cl__1.cerr = 0;
#line 22442 ""
	    cl__1.cunit = 14;
#line 22442 ""
	    cl__1.csta = 0;
#line 22442 ""
	    f_clos(&cl__1);
#line 22442 ""
	}
#line 22443 ""
	return 0;
#line 22444 ""
    }
#line 22445 ""
    i__1 = comas2_1.nasksys;
#line 22445 ""
    for (ia = 1; ia <= i__1; ++ia) {
#line 22446 ""
	++comas3_1.iask;
#line 22447 ""
	comas3_1.ask[comas3_1.iask - 1] = (comas2_1.wasksys[ia - 1] / poe - (
		r__1 = comas2_1.elasksys[ia - 1], dabs(r__1))) / 
		comshort_1.poefa[all_1.iline - 1];
#line 22448 ""
	if (comas2_1.elasksys[ia - 1] > 0.f) {
#line 22448 ""
	    comas3_1.ask[comas3_1.iask - 1] = r_dim(&comas3_1.ask[
		    comas3_1.iask - 1], &c_b1020);
#line 22448 ""
	}
#line 22449 ""
/* L19: */
#line 22449 ""
    }
#line 22450 ""
    i__1 = nhssys;
#line 22450 ""
    for (ia = 1; ia <= i__1; ++ia) {
#line 22451 ""
	++nhstot;
/* Computing MAX */
#line 22452 ""
	r__1 = hpts[ia - 1] - hesk[ia - 1] * poe;
#line 22452 ""
	comhsp_1.hpttot[nhstot - 1] = dmax(r__1,0.f);
#line 22453 ""
/* L26: */
#line 22453 ""
    }
#line 22454 ""
    if (comlast_1.islast && onvolt) {
#line 22454 ""
	s_wsfe(&io___1582);
/* Writing concatenation */
#line 22454 ""
	i__6[0] = 1, a__4[0] = all_1.sq;
#line 22454 ""
	i__6[1] = 11, a__4[1] = "endvoltabox";
#line 22454 ""
	s_cat(ch__14, a__4, i__6, &c__2, (ftnlen)12);
#line 22454 ""
	do_fio(&c__1, ch__14, (ftnlen)12);
#line 22454 ""
	e_wsfe();
#line 22454 ""
    }
#line 22456 ""
    s_copy(rendq, "%  ", (ftnlen)3, (ftnlen)3);
#line 22457 ""
    if (comshort_1.ishort != 0) {
#line 22457 ""
	s_copy(rendq, "}}%", (ftnlen)3, (ftnlen)3);
#line 22457 ""
    }
#line 22458 ""
    if (*(unsigned char *)comget_1.rptfq2 != 'E') {

/* Terminal repeat.  Right or double? */

#line 22462 ""
	if (*(unsigned char *)comget_1.rptfq2 == 'r') {
#line 22463 ""
	    if (comlast_1.islast) {
#line 22463 ""
		s_wsfe(&io___1584);
/* Writing concatenation */
#line 22463 ""
		i__12[0] = 1, a__9[0] = all_1.sq;
#line 22463 ""
		i__12[1] = 14, a__9[1] = "setrightrepeat";
#line 22463 ""
		i__12[2] = 1, a__9[2] = all_1.sq;
#line 22463 ""
		i__12[3] = 8, a__9[3] = "endpiece";
#line 22463 ""
		i__12[4] = 3, a__9[4] = rendq;
#line 22463 ""
		s_cat(ch__5, a__9, i__12, &c__5, (ftnlen)27);
#line 22463 ""
		do_fio(&c__1, ch__5, (ftnlen)27);
#line 22463 ""
		e_wsfe();
#line 22463 ""
	    }
#line 22465 ""
	} else if (*(unsigned char *)comget_1.rptfq2 == 'd') {
#line 22466 ""
	    if (comlast_1.islast) {
#line 22466 ""
		s_wsfe(&io___1585);
/* Writing concatenation */
#line 22466 ""
		i__12[0] = 1, a__9[0] = all_1.sq;
#line 22466 ""
		i__12[1] = 12, a__9[1] = "setdoublebar";
#line 22466 ""
		i__12[2] = 1, a__9[2] = all_1.sq;
#line 22466 ""
		i__12[3] = 8, a__9[3] = "endpiece";
#line 22466 ""
		i__12[4] = 3, a__9[4] = rendq;
#line 22466 ""
		s_cat(ch__42, a__9, i__12, &c__5, (ftnlen)25);
#line 22466 ""
		do_fio(&c__1, ch__42, (ftnlen)25);
#line 22466 ""
		e_wsfe();
#line 22466 ""
	    }
#line 22468 ""
	} else if (*(unsigned char *)comget_1.rptfq2 == 'b') {
#line 22469 ""
	    if (comlast_1.islast) {
#line 22469 ""
		s_wsfe(&io___1586);
/* Writing concatenation */
#line 22469 ""
		i__8[0] = 1, a__5[0] = all_1.sq;
#line 22469 ""
		i__8[1] = 8, a__5[1] = "endpiece";
#line 22469 ""
		i__8[2] = 3, a__5[2] = rendq;
#line 22469 ""
		s_cat(ch__14, a__5, i__8, &c__3, (ftnlen)12);
#line 22469 ""
		do_fio(&c__1, ch__14, (ftnlen)12);
#line 22469 ""
		e_wsfe();
#line 22469 ""
	    }
#line 22470 ""
	} else if (*(unsigned char *)comget_1.rptfq2 == 'z') {
#line 22471 ""
	    if (comlast_1.islast) {
#line 22471 ""
		s_wsfe(&io___1587);
/* Writing concatenation */
#line 22471 ""
		i__12[0] = 1, a__9[0] = all_1.sq;
#line 22471 ""
		i__12[1] = 12, a__9[1] = "setzalaligne";
#line 22471 ""
		i__12[2] = 1, a__9[2] = all_1.sq;
#line 22471 ""
		i__12[3] = 8, a__9[3] = "Endpiece";
#line 22471 ""
		i__12[4] = 3, a__9[4] = rendq;
#line 22471 ""
		s_cat(ch__42, a__9, i__12, &c__5, (ftnlen)25);
#line 22471 ""
		do_fio(&c__1, ch__42, (ftnlen)25);
#line 22471 ""
		e_wsfe();
#line 22471 ""
	    }
#line 22473 ""
	} else {
#line 22474 ""
	    s_wsle(&io___1588);
#line 22474 ""
	    e_wsle();
#line 22475 ""
	    s_wsle(&io___1589);
#line 22475 ""
	    do_lio(&c__9, &c__1, "R? , ? not \"d\",\"r\",or\"b\",\"z\"; rptf"\
		    "q2:", (ftnlen)37);
#line 22475 ""
	    do_lio(&c__9, &c__1, comget_1.rptfq2, (ftnlen)1);
#line 22475 ""
	    e_wsle();
#line 22476 ""
	    s_wsle(&io___1590);
#line 22476 ""
	    do_lio(&c__9, &c__1, "R? , ? not \"d\",\"r\",or\"b\",\"z\"; rptf"\
		    "q2:", (ftnlen)37);
#line 22476 ""
	    do_lio(&c__9, &c__1, comget_1.rptfq2, (ftnlen)1);
#line 22476 ""
	    e_wsle();
#line 22477 ""
	    if (comlast_1.islast) {
#line 22477 ""
		s_wsfe(&io___1591);
/* Writing concatenation */
#line 22477 ""
		i__6[0] = 1, a__4[0] = all_1.sq;
#line 22477 ""
		i__6[1] = 8, a__4[1] = "Endpiece";
#line 22477 ""
		s_cat(ch__18, a__4, i__6, &c__2, (ftnlen)9);
#line 22477 ""
		do_fio(&c__1, ch__18, (ftnlen)9);
#line 22477 ""
		e_wsfe();
#line 22477 ""
	    }
#line 22478 ""
	}
#line 22479 ""
    } else {
#line 22480 ""
	s_wsfe(&io___1592);
/* Writing concatenation */
#line 22480 ""
	i__8[0] = 1, a__5[0] = all_1.sq;
#line 22480 ""
	i__8[1] = 8, a__5[1] = "Endpiece";
#line 22480 ""
	i__8[2] = 3, a__5[2] = rendq;
#line 22480 ""
	s_cat(ch__14, a__5, i__8, &c__3, (ftnlen)12);
#line 22480 ""
	do_fio(&c__1, ch__14, (ftnlen)12);
#line 22480 ""
	e_wsfe();
#line 22481 ""
    }
#line 22482 ""
    if (! vshrink) {
#line 22483 ""
	if (comlast_1.islast && combottop_1.bottopgap) {
#line 22484 ""
	    if (dabs(combottop_1.botamt) > 1e-6f) {
#line 22485 ""
		if (combottop_1.botamt > 9.95f) {
#line 22486 ""
		    s_copy(fmtq, "(a,f4.1,a)", (ftnlen)24, (ftnlen)10);
#line 22487 ""
		} else if (combottop_1.botamt > 0.f) {
#line 22488 ""
		    s_copy(fmtq, "(a,f3.1,a)", (ftnlen)24, (ftnlen)10);
#line 22489 ""
		} else if (combottop_1.botamt > -9.95f) {
#line 22490 ""
		    s_copy(fmtq, "(a,f4.1,a)", (ftnlen)24, (ftnlen)10);
#line 22491 ""
		} else {
#line 22492 ""
		    s_copy(fmtq, "(a,f5.1,a)", (ftnlen)24, (ftnlen)10);
#line 22493 ""
		}
#line 22494 ""
		s_wsfe(&io___1593);
/* Writing concatenation */
#line 22494 ""
		i__5[0] = 1, a__3[0] = all_1.sq;
#line 22494 ""
		i__5[1] = 4, a__3[1] = "null";
#line 22494 ""
		i__5[2] = 1, a__3[2] = all_1.sq;
#line 22494 ""
		i__5[3] = 5, a__3[3] = "vskip";
#line 22494 ""
		s_cat(ch__15, a__3, i__5, &c__4, (ftnlen)11);
#line 22494 ""
		do_fio(&c__1, ch__15, (ftnlen)11);
#line 22494 ""
		do_fio(&c__1, (char *)&combottop_1.botamt, (ftnlen)sizeof(
			real));
/* Writing concatenation */
#line 22494 ""
		i__6[0] = 1, a__4[0] = all_1.sq;
#line 22494 ""
		i__6[1] = 10, a__4[1] = "Internote%";
#line 22494 ""
		s_cat(ch__32, a__4, i__6, &c__2, (ftnlen)11);
#line 22494 ""
		do_fio(&c__1, ch__32, (ftnlen)11);
#line 22494 ""
		e_wsfe();
#line 22496 ""
	    }
#line 22497 ""
	}
#line 22498 ""
	xnstbot = xnsttop[comnotes_1.ipage - 1] * etabot / etatop;
#line 22499 ""
	if (xnstbot < 9.95f) {
#line 22500 ""
	    s_copy(fmtq, "(a,f3.1,a)", (ftnlen)24, (ftnlen)10);
#line 22501 ""
	} else {
#line 22502 ""
	    s_copy(fmtq, "(a,f4.1,a)", (ftnlen)24, (ftnlen)10);
#line 22503 ""
	}
#line 22504 ""
	if (comlast_1.islast) {
#line 22504 ""
	    s_wsfe(&io___1594);
/* Writing concatenation */
#line 22504 ""
	    i__6[0] = 1, a__4[0] = all_1.sq;
#line 22504 ""
	    i__6[1] = 5, a__4[1] = "vskip";
#line 22504 ""
	    s_cat(ch__25, a__4, i__6, &c__2, (ftnlen)6);
#line 22504 ""
	    do_fio(&c__1, ch__25, (ftnlen)6);
#line 22504 ""
	    do_fio(&c__1, (char *)&xnstbot, (ftnlen)sizeof(real));
/* Writing concatenation */
#line 22504 ""
	    i__4[0] = 1, a__2[0] = all_1.sq;
#line 22504 ""
	    i__4[1] = 10, a__2[1] = "Interligne";
#line 22504 ""
	    i__4[2] = 1, a__2[2] = all_1.sq;
#line 22504 ""
	    i__4[3] = 5, a__2[3] = "eject";
#line 22504 ""
	    i__4[4] = 1, a__2[4] = all_1.sq;
#line 22504 ""
	    i__4[5] = 9, a__2[5] = "endmuflex";
#line 22504 ""
	    s_cat(ch__5, a__2, i__4, &c__6, (ftnlen)27);
#line 22504 ""
	    do_fio(&c__1, ch__5, (ftnlen)27);
#line 22504 ""
	    e_wsfe();
#line 22504 ""
	}
#line 22506 ""
	if (comlast_1.islast) {
#line 22506 ""
	    s_wsfe(&io___1595);
/* Writing concatenation */
#line 22506 ""
	    i__6[0] = 1, a__4[0] = all_1.sq;
#line 22506 ""
	    i__6[1] = 3, a__4[1] = "bye";
#line 22506 ""
	    s_cat(ch__21, a__4, i__6, &c__2, (ftnlen)4);
#line 22506 ""
	    do_fio(&c__1, ch__21, (ftnlen)4);
#line 22506 ""
	    e_wsfe();
#line 22506 ""
	}
#line 22507 ""
    } else {
#line 22508 ""
	if (comlast_1.islast) {
#line 22508 ""
	    s_wsfe(&io___1596);
/* Writing concatenation */
#line 22508 ""
	    i__4[0] = 1, a__2[0] = all_1.sq;
#line 22508 ""
	    i__4[1] = 5, a__2[1] = "vfill";
#line 22508 ""
	    i__4[2] = 1, a__2[2] = all_1.sq;
#line 22508 ""
	    i__4[3] = 5, a__2[3] = "eject";
#line 22508 ""
	    i__4[4] = 1, a__2[4] = all_1.sq;
#line 22508 ""
	    i__4[5] = 9, a__2[5] = "endmuflex";
#line 22508 ""
	    s_cat(ch__43, a__2, i__4, &c__6, (ftnlen)22);
#line 22508 ""
	    do_fio(&c__1, ch__43, (ftnlen)22);
#line 22508 ""
	    e_wsfe();
#line 22508 ""
	}
#line 22510 ""
	if (comlast_1.islast) {
#line 22510 ""
	    s_wsfe(&io___1597);
/* Writing concatenation */
#line 22510 ""
	    i__6[0] = 1, a__4[0] = all_1.sq;
#line 22510 ""
	    i__6[1] = 3, a__4[1] = "bye";
#line 22510 ""
	    s_cat(ch__21, a__4, i__6, &c__2, (ftnlen)4);
#line 22510 ""
	    do_fio(&c__1, ch__21, (ftnlen)4);
#line 22510 ""
	    e_wsfe();
#line 22510 ""
	}
#line 22511 ""
    }
#line 22512 ""
    al__1.aerr = 0;
#line 22512 ""
    al__1.aunit = 11;
#line 22512 ""
    f_rew(&al__1);
#line 22513 ""
    if (all_1.figbass) {
#line 22514 ""
	s_wsfe(&io___1598);
/* Writing concatenation */
#line 22514 ""
	i__6[0] = 1, a__4[0] = all_1.sq;
#line 22514 ""
	i__6[1] = 8, a__4[1] = "figdrop=";
#line 22514 ""
	s_cat(ch__18, a__4, i__6, &c__2, (ftnlen)9);
#line 22514 ""
	do_fio(&c__1, ch__18, (ftnlen)9);
#line 22514 ""
	do_fio(&c__1, (char *)&all_1.ifigdr[(all_1.iline << 1) - 2], (ftnlen)
		sizeof(integer));
/* Writing concatenation */
#line 22514 ""
	i__8[0] = 1, a__5[0] = " ";
#line 22514 ""
	i__8[1] = 1, a__5[1] = all_1.sq;
#line 22514 ""
	i__8[2] = 8, a__5[2] = "figdtwo=";
#line 22514 ""
	s_cat(ch__20, a__5, i__8, &c__3, (ftnlen)10);
#line 22514 ""
	do_fio(&c__1, ch__20, (ftnlen)10);
#line 22514 ""
	do_fio(&c__1, (char *)&all_1.ifigdr[(all_1.iline << 1) - 1], (ftnlen)
		sizeof(integer));
/* Writing concatenation */
#line 22514 ""
	i__11[0] = 1, a__8[0] = all_1.sq;
#line 22514 ""
	i__11[1] = 4, a__8[1] = "fi}%";
#line 22514 ""
	s_cat(ch__40, a__8, i__11, &c__2, (ftnlen)5);
#line 22514 ""
	do_fio(&c__1, ch__40, (ftnlen)5);
#line 22514 ""
	e_wsfe();
#line 22517 ""
	al__1.aerr = 0;
#line 22517 ""
	al__1.aunit = 14;
#line 22517 ""
	f_rew(&al__1);
#line 22518 ""
    }
#line 22519 ""
    askfig_(pathnameq, &lpath, basenameq, &lbase, &all_1.figbass, &istype0, (
	    ftnlen)40, (ftnlen)44);
#line 22520 ""
    if (! (*optimize)) {
#line 22521 ""
	s_wsle(&io___1599);
#line 22521 ""
	e_wsle();
#line 22522 ""
	s_wsle(&io___1600);
/* Writing concatenation */
#line 22522 ""
	i__5[0] = 8, a__3[0] = "Writing ";
#line 22522 ""
	i__5[1] = lpath, a__3[1] = pathnameq;
#line 22522 ""
	i__5[2] = lbase, a__3[2] = basenameq;
#line 22522 ""
	i__5[3] = 4, a__3[3] = ".tex";
#line 22522 ""
	s_cat(ch__44, a__3, i__5, &c__4, (ftnlen)96);
#line 22522 ""
	do_lio(&c__9, &c__1, ch__44, lpath + 8 + lbase + 4);
#line 22522 ""
	e_wsle();
#line 22524 ""
	s_wsle(&io___1601);
#line 22524 ""
	do_lio(&c__9, &c__1, "Done with second PMX pass.", (ftnlen)26);
#line 22524 ""
	e_wsle();
#line 22525 ""
	s_wsfe(&io___1602);
/* Writing concatenation */
#line 22525 ""
	i__5[0] = 8, a__3[0] = "Writing ";
#line 22525 ""
	i__5[1] = lpath, a__3[1] = pathnameq;
#line 22525 ""
	i__5[2] = lbase, a__3[2] = basenameq;
#line 22525 ""
	i__5[3] = 4, a__3[3] = ".tex";
#line 22525 ""
	s_cat(ch__44, a__3, i__5, &c__4, (ftnlen)96);
#line 22525 ""
	do_fio(&c__1, ch__44, lpath + 8 + lbase + 4);
#line 22525 ""
	e_wsfe();
#line 22527 ""
	s_wsfe(&io___1603);
#line 22527 ""
	do_fio(&c__1, " Done with second PMX pass.  Now run TeX", (ftnlen)40);
#line 22527 ""
	e_wsfe();
#line 22528 ""
    }
#line 22529 ""
    return 0;
} /* pmxb_ */

/* Subroutine */ int poestats_(integer *nsyst, real *poe, real *poebar, real *
	devnorm)
{
    /* System generated locals */
    integer i__1;
    real r__1;

    /* Builtin functions */
    double sqrt(doublereal);

    /* Local variables */
    static real sumx;
    static integer isyst;
    static real sumxx;


/*  Compute avg. & norm. std. dev. of poe. */

#line 22537 ""
    /* Parameter adjustments */
#line 22537 ""
    --poe;
#line 22537 ""

#line 22537 ""
    /* Function Body */
#line 22537 ""
    sumx = 0.f;
#line 22538 ""
    sumxx = 0.f;
#line 22539 ""
    i__1 = *nsyst;
#line 22539 ""
    for (isyst = 1; isyst <= i__1; ++isyst) {
#line 22540 ""
	sumx += poe[isyst];
/* Computing 2nd power */
#line 22541 ""
	r__1 = poe[isyst];
#line 22541 ""
	sumxx += r__1 * r__1;
#line 22542 ""
/* L1: */
#line 22542 ""
    }
/* Computing 2nd power */
#line 22543 ""
    r__1 = sumx;
#line 22543 ""
    *devnorm = sqrt(*nsyst * sumxx / (r__1 * r__1) - 1);
#line 22544 ""
    *poebar = sumx / *nsyst;
#line 22545 ""
    return 0;
} /* poestats_ */

/* Subroutine */ int precrd_(integer *ivx, integer *ip, integer *nolevm, 
	integer *nacc, integer *ipl, integer *irest, char *udq, logical *
	twooftwo, integer *icashft, ftnlen udq_len)
{
    /* System generated locals */
    integer i__1, i__2, i__3;

    /* Builtin functions */
    integer lbit_shift(integer, integer), s_wsle(cilist *), e_wsle(void), 
	    do_lio(integer *, integer *, char *, ftnlen);

    /* Local variables */
    extern integer igetbits_(integer *, integer *, integer *);
    static integer i__, levminacc, levmaxacc, ip1, ile, ivx1, iold, ilev;
    static logical is2nd;
    extern /* Subroutine */ int stop1_(void);
    static integer kicrd[10], nolev, iaccid, naccid, iorder, icrdot0;
    extern /* Subroutine */ int crdaccs_(integer *, integer *, integer *, 
	    integer *, integer *, integer *, integer *, integer *, integer *, 
	    logical *, integer *);
    static integer levtabl[88];
    extern /* Subroutine */ int setbits_(integer *, integer *, integer *, 
	    integer *);

    /* Fortran I/O blocks */
    static cilist io___1611 = { 0, 6, 0, 0, 0 };
    static cilist io___1612 = { 0, 6, 0, 0, 0 };
    static cilist io___1623 = { 0, 6, 0, 0, 0 };
    static cilist io___1624 = { 0, 6, 0, 0, 0 };



/*  Analyzes chords, data to be used with slurs on chords and plain chords. */
/*  Check for 2nds, shift notes if neccesary. */
/*       ipl(10) chord present */
/*       irest(20) set if any note is right shifted */
/*       irest(27) set if any note is left shifted */
/*       ipl(8|9) left|right shift main note */
/*       icrdat(23|24)   ditto     chord note */
/*       udq is updown-ness, needed to analyze 2nds. */
/*       levtabl(i)=0 if no note at this level, -1 if main note, icrd if chord note. */
/*       icrdot(icrd)(27-29) sequence order of chord note if accid, top down */

#line 22567 ""
    for (i__ = 1; i__ <= 88; ++i__) {
#line 22568 ""
	levtabl[i__ - 1] = 0;
#line 22569 ""
/* L11: */
#line 22569 ""
    }
#line 22570 ""
    i__1 = comtrill_1.ncrd;
#line 22570 ""
    for (comtrill_1.icrd1 = 1; comtrill_1.icrd1 <= i__1; ++comtrill_1.icrd1) {
#line 22571 ""
	ivx1 = (15 & lbit_shift(comtrill_1.icrdat[comtrill_1.icrd1 - 1], (
		ftnlen)-8)) + (igetbits_(&comtrill_1.icrdat[comtrill_1.icrd1 
		- 1], &c__1, &c__28) << 4);
#line 22573 ""
	ip1 = 255 & comtrill_1.icrdat[comtrill_1.icrd1 - 1];
#line 22574 ""
	if (ip1 == *ip && ivx1 == *ivx) {
#line 22574 ""
	    goto L2;
#line 22574 ""
	}
#line 22575 ""
/* L1: */
#line 22575 ""
    }
#line 22576 ""
    s_wsle(&io___1611);
#line 22576 ""
    e_wsle();
#line 22577 ""
    s_wsle(&io___1612);
#line 22577 ""
    do_lio(&c__9, &c__1, "Cannot find first chord note in precrd. Send sourc"\
	    "e to Dr. Don!", (ftnlen)63);
#line 22577 ""
    e_wsle();
#line 22579 ""
    stop1_();
#line 22580 ""
L2:
#line 22581 ""
    comtrill_1.maxlev = *nolevm;
#line 22582 ""
    comtrill_1.minlev = *nolevm;
#line 22583 ""
    levtabl[*nolevm - 1] = -1;
#line 22584 ""
    is2nd = FALSE_;
#line 22585 ""
    naccid = 0;
#line 22586 ""
    levmaxacc = -100;
#line 22587 ""
    levminacc = 1000;

/*  Check 1st 3 bits of nacc for accid on main note of chord. */

#line 22591 ""
    if ((7 & *nacc) > 0) {
#line 22592 ""
	naccid = 1;

/*  Start list of notes with accid's.  There will be naccid of them. kicrd=0 if main, */
/*    otherwise icrd value for note with accidental. */

#line 22597 ""
	kicrd[0] = 0;
#line 22598 ""
	levmaxacc = *nolevm;
#line 22599 ""
	levminacc = *nolevm;

/*  Start the level-ranking */

#line 22603 ""
	icrdot0 = 1;
#line 22604 ""
    }
#line 22605 ""
    i__1 = comtrill_1.ncrd;
#line 22605 ""
    for (comtrill_1.icrd2 = comtrill_1.icrd1; comtrill_1.icrd2 <= i__1; 
	    ++comtrill_1.icrd2) {
#line 22606 ""
	nolev = igetbits_(&comtrill_1.icrdat[comtrill_1.icrd2 - 1], &c__7, &
		c__12);
#line 22607 ""
	levtabl[nolev - 1] = comtrill_1.icrd2;
#line 22608 ""
	comtrill_1.maxlev = max(comtrill_1.maxlev,nolev);
#line 22609 ""
	comtrill_1.minlev = min(comtrill_1.minlev,nolev);

/*  Check for accidental */

#line 22613 ""
	if (bit_test(comtrill_1.icrdat[comtrill_1.icrd2 - 1],19)) {
#line 22614 ""
	    ++naccid;
#line 22615 ""
	    levmaxacc = max(levmaxacc,nolev);
#line 22616 ""
	    levminacc = min(levminacc,nolev);

/*  Add this icrd to list of values for notes with accid's. */

#line 22620 ""
	    kicrd[naccid - 1] = comtrill_1.icrd2;
#line 22621 ""
	    if (! bit_test(*nacc,28)) {

/*  Order not forced, so get the level-ranking, top down */

#line 22625 ""
		iorder = 1;
#line 22626 ""
		i__2 = naccid - 1;
#line 22626 ""
		for (iaccid = 1; iaccid <= i__2; ++iaccid) {
#line 22627 ""
		    if (kicrd[iaccid - 1] == 0) {
#line 22628 ""
			if (*nolevm > nolev) {
#line 22629 ""
			    ++iorder;
#line 22630 ""
			} else {
#line 22631 ""
			    ++icrdot0;
#line 22632 ""
			}
#line 22633 ""
		    } else {
#line 22634 ""
			if (igetbits_(&comtrill_1.icrdat[kicrd[iaccid - 1] - 
				1], &c__7, &c__12) > nolev) {
#line 22636 ""
			    ++iorder;
#line 22637 ""
			} else {
#line 22638 ""
			    iold = igetbits_(&comtrill_1.icrdot[kicrd[iaccid 
				    - 1] - 1], &c__3, &c__27);
#line 22639 ""
			    i__3 = iold + 1;
#line 22639 ""
			    setbits_(&comtrill_1.icrdot[kicrd[iaccid - 1] - 1]
				    , &c__3, &c__27, &i__3);
#line 22640 ""
			}
#line 22641 ""
		    }
#line 22642 ""
/* L12: */
#line 22642 ""
		}
#line 22643 ""
		setbits_(&comtrill_1.icrdot[comtrill_1.icrd2 - 1], &c__3, &
			c__27, &iorder);
#line 22644 ""
	    }
#line 22645 ""
	}

/*  Exit loop if last note in this chord */

#line 22649 ""
	if (comtrill_1.icrd2 == comtrill_1.ncrd) {
#line 22649 ""
	    goto L4;
#line 22649 ""
	}
#line 22650 ""
	if (igetbits_(&comtrill_1.icrdat[comtrill_1.icrd2], &c__8, &c__0) != *
		ip || igetbits_(&comtrill_1.icrdat[comtrill_1.icrd2], &c__4, &
		c__8) + (igetbits_(&comtrill_1.icrdat[comtrill_1.icrd2], &
		c__1, &c__28) << 4) != *ivx) {
#line 22650 ""
	    goto L4;
#line 22650 ""
	}
/*     *      igetbits(icrdat(icrd2+1),4,8) .ne. ivx) go to 4 */
#line 22654 ""
/* L3: */
#line 22654 ""
    }
#line 22655 ""
    s_wsle(&io___1623);
#line 22655 ""
    e_wsle();
#line 22656 ""
    s_wsle(&io___1624);
#line 22656 ""
    do_lio(&c__9, &c__1, "Failed to find last chord note. Send source to Dr."\
	    " Don!", (ftnlen)55);
#line 22656 ""
    e_wsle();
#line 22657 ""
    stop1_();
#line 22658 ""
L4:

/*  Now icrd1, icrd2 define range of icrd for this chord. */

/*  Bypass autos-shifting if any manual shifts are present */

#line 22664 ""
    if (bit_test(*irest,20) || bit_test(*irest,27)) {
#line 22664 ""
	goto L10;
#line 22664 ""
    }

/*  Check for 2nds */

#line 22668 ""
    for (ilev = 1; ilev <= 87; ++ilev) {
#line 22669 ""
	if (levtabl[ilev - 1] != 0 && levtabl[ilev] != 0) {

/*  There is at least one 2nd.. */

#line 22673 ""
	    if (*(unsigned char *)udq == 'u') {

/*  Upstem. Start with 2nd just found and go up, rt-shifting upper */
/*     member of each pair */

#line 22678 ""
		ile = ilev;

/*  Set main-note flag for ANY right-shift */

#line 22682 ""
		*irest = bit_set(*irest,20);
#line 22683 ""
L7:
#line 22684 ""
		if (levtabl[ile] < 0) {

/*  Upstem, & upper member is main so must be rt-shifted. This would move */
/*    stem too, so we rt-shift the OTHER note, and set flag that signals */
/*    to interchange pitches just when these two notes are placed. */

#line 22690 ""
		    *nacc = bit_set(*nacc,30);
#line 22691 ""
		    comtrill_1.icrdat[levtabl[ile - 1] - 1] = bit_set(
			    comtrill_1.icrdat[levtabl[ile - 1] - 1],24);
#line 22692 ""
		} else {

/*  Upper member is chord note, must be rt-shifted */

#line 22696 ""
		    comtrill_1.icrdat[levtabl[ile] - 1] = bit_set(
			    comtrill_1.icrdat[levtabl[ile] - 1],24);
#line 22697 ""
		}
#line 22698 ""
		++ile;
#line 22699 ""
L8:
#line 22700 ""
		++ile;
#line 22701 ""
		if (ile < 87) {
#line 22702 ""
		    if (levtabl[ile - 1] != 0 && levtabl[ile] != 0) {
#line 22703 ""
			goto L7;
#line 22704 ""
		    } else {
#line 22705 ""
			goto L8;
#line 22706 ""
		    }
#line 22707 ""
		}
#line 22708 ""
		goto L10;
#line 22709 ""
	    } else {

/*  Downstem. Start at top and work down, left-shifting lower member of each pair. */
/*     We know that lowest pair is at (ilev,ilev+1). */

#line 22714 ""
		ile = 88;

/*  Set main-note flag for ANY right-shift */

#line 22718 ""
		*irest = bit_set(*irest,27);
#line 22719 ""
L9:
#line 22720 ""
		if (levtabl[ile - 1] != 0 && levtabl[ile - 2] != 0) {
#line 22721 ""
		    if (levtabl[ile - 2] < 0) {

/*  Dnstem, & lower member is main so must be left-shifted. This would move */
/*    stem too, so we left-shift the OTHER note, and set flag that signals */
/*    to interchange pitches just when these two notes are placed. */

#line 22727 ""
			*nacc = bit_set(*nacc,31);
#line 22728 ""
			comtrill_1.icrdat[levtabl[ile - 1] - 1] = bit_set(
				comtrill_1.icrdat[levtabl[ile - 1] - 1],23);
#line 22729 ""
		    } else {

/*  Lower member is chord note, must be shifted */

#line 22733 ""
			comtrill_1.icrdat[levtabl[ile - 2] - 1] = bit_set(
				comtrill_1.icrdat[levtabl[ile - 2] - 1],23);
#line 22735 ""
		    }
#line 22736 ""
		    --ile;
#line 22737 ""
		}
#line 22738 ""
		--ile;
#line 22739 ""
		if (ile >= ilev + 1) {
#line 22739 ""
		    goto L9;
#line 22739 ""
		}
#line 22740 ""
		goto L10;
#line 22741 ""
	    }
#line 22742 ""
	}
#line 22743 ""
/* L5: */
#line 22743 ""
    }
#line 22744 ""
L10:

/*  Done with 2nds, now do accid's.  Call even if just one, in case left shifts. */

#line 22748 ""
    if (naccid >= 1) {
#line 22748 ""
	crdaccs_(nacc, ipl, irest, &naccid, kicrd, nolevm, &levmaxacc, &
		levminacc, &icrdot0, twooftwo, icashft);
#line 22748 ""
    }
#line 22750 ""
    return 0;
} /* precrd_ */

/* Subroutine */ int printl_(char *string, ftnlen string_len)
{
    /* Builtin functions */
    integer s_wsle(cilist *), do_lio(integer *, integer *, char *, ftnlen), 
	    e_wsle(void), s_wsfe(cilist *), do_fio(integer *, char *, ftnlen),
	     e_wsfe(void);

    /* Fortran I/O blocks */
    static cilist io___1627 = { 0, 6, 0, 0, 0 };
    static cilist io___1628 = { 0, 15, 0, "(a)", 0 };



/*  Send string to console and to log file */

#line 22757 ""
    s_wsle(&io___1627);
#line 22757 ""
    do_lio(&c__9, &c__1, string, string_len);
#line 22757 ""
    e_wsle();
#line 22758 ""
    s_wsfe(&io___1628);
#line 22758 ""
    do_fio(&c__1, string, string_len);
#line 22758 ""
    e_wsfe();
#line 22759 ""
    return 0;
} /* printl_ */

/* Subroutine */ int putarp_(real *tnow, integer *iv, integer *ip, integer *
	nolev, integer *ncm, char *soutq, integer *lsout, ftnlen soutq_len)
{
    /* Initialized data */

    static char symq[8*2] = "raisearp" "arpeggio";

    /* System generated locals */
    address a__1[2], a__2[3], a__3[4];
    integer i__1, i__2[2], i__3[3], i__4[4];
    real r__1;
    char ch__1[1], ch__2[1];
    icilist ici__1;

    /* Builtin functions */
    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
    integer s_wsfi(icilist *), do_fio(integer *, char *, ftnlen), e_wsfi(void)
	    , s_wsle(cilist *), do_lio(integer *, integer *, char *, ftnlen), 
	    e_wsle(void);
    /* Subroutine */ int s_stop(char *, ftnlen);
    integer i_nint(real *);

    /* Local variables */
    static logical isarpshift;
    static integer iiv, nstaffshift;
    extern /* Character */ VOID chax_(char *, ftnlen, integer *);
    static integer iarp, isym, iarps, lnote;
    extern /* Subroutine */ int addstr_(char *, integer *, char *, integer *, 
	    ftnlen, ftnlen);
    static integer levbot, ilvert, invert;
    static char notexq[79];
    static integer iivivx1;

    /* Fortran I/O blocks */
    static icilist io___1634 = { 0, notexq+9, 0, "(f3.1,a2)", 5, 1 };
    static cilist io___1640 = { 0, 6, 0, 0, 0 };
    static cilist io___1641 = { 0, 6, 0, 0, 0 };



/*  NOTE iv in arg list is really ivx, referring to voice rather than staff. */

/*  Find which iarp, if any */

#line 22780 ""
    i__1 = comarp_1.narp;
#line 22780 ""
    for (iarp = 1; iarp <= i__1; ++iarp) {
#line 22781 ""
	if ((r__1 = *tnow - comarp_1.tar[iarp - 1], dabs(r__1)) < 
		comtol_1.tol) {
#line 22781 ""
	    goto L2;
#line 22781 ""
	}
#line 22782 ""
/* L1: */
#line 22782 ""
    }

/*  If here, this is the *first* call for this arp. */

#line 22786 ""
    ++comarp_1.narp;
#line 22787 ""
    comarp_1.tar[comarp_1.narp - 1] = *tnow + comtol_1.tol * .5f;
#line 22788 ""
    comarp_1.ivar1[comarp_1.narp - 1] = *iv;
#line 22789 ""
    comarp_1.ipar1[comarp_1.narp - 1] = *ip;
#line 22790 ""
    comarp_1.levar1[comarp_1.narp - 1] = *nolev;
#line 22791 ""
    comarp_1.ncmar1[comarp_1.narp - 1] = *ncm;
#line 22792 ""
    return 0;
#line 22793 ""
L2:

/*  If here, this is *second* call at this time, narp points to values from 1st. */

/*  Check for shift. Set IsArpShift and iarps */

#line 22799 ""
    i__1 = comarpshift_1.numarpshift;
#line 22799 ""
    for (iarps = 1; iarps <= i__1; ++iarps) {
#line 22800 ""
	if (comarpshift_1.ivarpshift[iarps - 1] == comarp_1.ivar1[iarp - 1] &&
		 comarpshift_1.iparpshift[iarps - 1] == comarp_1.ipar1[iarp - 
		1]) {
#line 22802 ""
	    isarpshift = TRUE_;
/* Writing concatenation */
#line 22803 ""
	    chax_(ch__1, (ftnlen)1, &c__92);
#line 22803 ""
	    i__2[0] = 1, a__1[0] = ch__1;
#line 22803 ""
	    i__2[1] = 8, a__1[1] = "loffset{";
#line 22803 ""
	    s_cat(notexq, a__1, i__2, &c__2, (ftnlen)79);
#line 22804 ""
	    s_wsfi(&io___1634);
#line 22804 ""
	    do_fio(&c__1, (char *)&comarpshift_1.arpshift[iarps - 1], (ftnlen)
		    sizeof(real));
#line 22804 ""
	    do_fio(&c__1, "}{", (ftnlen)2);
#line 22804 ""
	    e_wsfi();
#line 22805 ""
	    lnote = 14;
#line 22806 ""
	    goto L4;
#line 22807 ""
	}
#line 22808 ""
/* L3: */
#line 22808 ""
    }
#line 22809 ""
    isarpshift = FALSE_;
#line 22810 ""
    lnote = 0;
#line 22811 ""
L4:
#line 22812 ""
    if (*iv == comarp_1.ivar1[iarp - 1]) {

/*  Arp is in a single voice. */

/* Computing MIN */
#line 22816 ""
	i__1 = comarp_1.levar1[iarp - 1];
#line 22816 ""
	levbot = min(i__1,*nolev) - *ncm + 3;
#line 22817 ""
	invert = (i__1 = comarp_1.levar1[iarp - 1] - *nolev, abs(i__1)) + 1;
#line 22818 ""
    } else {

/*  Arp covers >1 voice.  Lower voice has to be the first, upper is current and */
/*    is where the symbol will be written. */
/*  Check whether ivx's ivar1(iarp) & iv are in same staff */

#line 22824 ""
	for (iiv = 1; iiv <= 24; ++iiv) {
#line 22825 ""
	    if (commvl_1.ivmx[iiv - 1] == comarp_1.ivar1[iarp - 1] || 
		    commvl_1.nvmx[iiv - 1] == 2 && commvl_1.ivmx[iiv + 23] == 
		    comarp_1.ivar1[iarp - 1]) {
#line 22827 ""
		iivivx1 = iiv;
#line 22828 ""
		goto L6;
#line 22829 ""
	    }
#line 22830 ""
/* L5: */
#line 22830 ""
	}
#line 22831 ""
	s_wsle(&io___1640);
#line 22831 ""
	do_lio(&c__9, &c__1, "Screwup#1 in putarp", (ftnlen)19);
#line 22831 ""
	e_wsle();
#line 22832 ""
	s_stop("", (ftnlen)0);
#line 22833 ""
L6:
#line 22834 ""
	for (iiv = 1; iiv <= 24; ++iiv) {
#line 22835 ""
	    if (commvl_1.ivmx[iiv - 1] == *iv || commvl_1.nvmx[iiv - 1] == 2 
		    && commvl_1.ivmx[iiv + 23] == *iv) {
#line 22835 ""
		goto L8;
#line 22835 ""
	    }

/*  Found iv for both voices (iivivx1, iiv), done looking */

#line 22840 ""
/* L7: */
#line 22840 ""
	}
#line 22841 ""
	s_wsle(&io___1641);
#line 22841 ""
	do_lio(&c__9, &c__1, "Screwup#2 in putarp", (ftnlen)19);
#line 22841 ""
	e_wsle();
#line 22842 ""
	s_stop("", (ftnlen)0);
#line 22843 ""
L8:
#line 22844 ""
	if (iivivx1 == iiv) {
#line 22845 ""
	    nstaffshift = 0;
#line 22846 ""
	} else {
#line 22847 ""
	    r__1 = comarp_1.xinsnow * 2;
#line 22847 ""
	    nstaffshift = -i_nint(&r__1);
#line 22848 ""
	}
#line 22849 ""
	levbot = nstaffshift + 3 + comarp_1.levar1[iarp - 1] - 
		comarp_1.ncmar1[iarp - 1];
#line 22850 ""
	invert = -levbot + 4 + *nolev - *ncm;
#line 22851 ""
    }

/*  isym will be (1,2) if invert is (even,odd).  If even, raise .5\internote */

#line 22855 ""
    isym = invert % 2 + 1;
#line 22856 ""
    ilvert = (invert + 1) / 2;
#line 22857 ""
    if (levbot >= 0 && levbot <= 9) {

/*  Single digit */

#line 22861 ""
	if (! isarpshift) {
/* Writing concatenation */
#line 22862 ""
	    chax_(ch__1, (ftnlen)1, &c__92);
#line 22862 ""
	    i__3[0] = 1, a__2[0] = ch__1;
#line 22862 ""
	    i__3[1] = 8, a__2[1] = symq + (isym - 1 << 3);
#line 22862 ""
	    i__1 = levbot + 48;
#line 22862 ""
	    chax_(ch__2, (ftnlen)1, &i__1);
#line 22862 ""
	    i__3[2] = 1, a__2[2] = ch__2;
#line 22862 ""
	    s_cat(notexq, a__2, i__3, &c__3, (ftnlen)79);
#line 22863 ""
	} else {
/* Writing concatenation */
#line 22864 ""
	    i__4[0] = lnote, a__3[0] = notexq;
#line 22864 ""
	    chax_(ch__1, (ftnlen)1, &c__92);
#line 22864 ""
	    i__4[1] = 1, a__3[1] = ch__1;
#line 22864 ""
	    i__4[2] = 8, a__3[2] = symq + (isym - 1 << 3);
#line 22864 ""
	    i__1 = levbot + 48;
#line 22864 ""
	    chax_(ch__2, (ftnlen)1, &i__1);
#line 22864 ""
	    i__4[3] = 1, a__3[3] = ch__2;
#line 22864 ""
	    s_cat(notexq, a__3, i__4, &c__4, (ftnlen)79);
#line 22866 ""
	}
#line 22867 ""
	lnote += 10;
#line 22868 ""
    } else {
#line 22869 ""
	if (! isarpshift) {
/* Writing concatenation */
#line 22870 ""
	    chax_(ch__1, (ftnlen)1, &c__92);
#line 22870 ""
	    i__3[0] = 1, a__2[0] = ch__1;
#line 22870 ""
	    i__3[1] = 8, a__2[1] = symq + (isym - 1 << 3);
#line 22870 ""
	    i__3[2] = 1, a__2[2] = "{";
#line 22870 ""
	    s_cat(notexq, a__2, i__3, &c__3, (ftnlen)79);
#line 22871 ""
	} else {
/* Writing concatenation */
#line 22872 ""
	    i__4[0] = lnote, a__3[0] = notexq;
#line 22872 ""
	    chax_(ch__1, (ftnlen)1, &c__92);
#line 22872 ""
	    i__4[1] = 1, a__3[1] = ch__1;
#line 22872 ""
	    i__4[2] = 8, a__3[2] = symq + (isym - 1 << 3);
#line 22872 ""
	    i__4[3] = 1, a__3[3] = "{";
#line 22872 ""
	    s_cat(notexq, a__3, i__4, &c__4, (ftnlen)79);
#line 22873 ""
	}
#line 22874 ""
	lnote += 10;
#line 22875 ""
	if (levbot >= -9) {

/*  Need two spaces for number */

#line 22879 ""
	    i__1 = lnote;
#line 22879 ""
	    ici__1.icierr = 0;
#line 22879 ""
	    ici__1.icirnum = 1;
#line 22879 ""
	    ici__1.icirlen = lnote + 3 - i__1;
#line 22879 ""
	    ici__1.iciunit = notexq + i__1;
#line 22879 ""
	    ici__1.icifmt = "(i2,a1)";
#line 22879 ""
	    s_wsfi(&ici__1);
#line 22879 ""
	    do_fio(&c__1, (char *)&levbot, (ftnlen)sizeof(integer));
#line 22879 ""
	    do_fio(&c__1, "}", (ftnlen)1);
#line 22879 ""
	    e_wsfi();
#line 22880 ""
	    lnote += 3;
#line 22881 ""
	} else {
#line 22882 ""
	    i__1 = lnote;
#line 22882 ""
	    ici__1.icierr = 0;
#line 22882 ""
	    ici__1.icirnum = 1;
#line 22882 ""
	    ici__1.icirlen = lnote + 4 - i__1;
#line 22882 ""
	    ici__1.iciunit = notexq + i__1;
#line 22882 ""
	    ici__1.icifmt = "(i3,a1)";
#line 22882 ""
	    s_wsfi(&ici__1);
#line 22882 ""
	    do_fio(&c__1, (char *)&levbot, (ftnlen)sizeof(integer));
#line 22882 ""
	    do_fio(&c__1, "}", (ftnlen)1);
#line 22882 ""
	    e_wsfi();
#line 22883 ""
	    lnote += 4;
#line 22884 ""
	}
#line 22885 ""
    }
#line 22886 ""
    if (ilvert > 9) {
#line 22887 ""
	i__1 = lnote;
#line 22887 ""
	ici__1.icierr = 0;
#line 22887 ""
	ici__1.icirnum = 1;
#line 22887 ""
	ici__1.icirlen = lnote + 4 - i__1;
#line 22887 ""
	ici__1.iciunit = notexq + i__1;
#line 22887 ""
	ici__1.icifmt = "(a1,i2,a1)";
#line 22887 ""
	s_wsfi(&ici__1);
#line 22887 ""
	do_fio(&c__1, "{", (ftnlen)1);
#line 22887 ""
	do_fio(&c__1, (char *)&ilvert, (ftnlen)sizeof(integer));
#line 22887 ""
	do_fio(&c__1, "}", (ftnlen)1);
#line 22887 ""
	e_wsfi();
#line 22888 ""
	lnote += 4;
#line 22889 ""
    } else {
/* Writing concatenation */
#line 22890 ""
	i__2[0] = lnote, a__1[0] = notexq;
#line 22890 ""
	i__1 = ilvert + 48;
#line 22890 ""
	chax_(ch__1, (ftnlen)1, &i__1);
#line 22890 ""
	i__2[1] = 1, a__1[1] = ch__1;
#line 22890 ""
	s_cat(notexq, a__1, i__2, &c__2, (ftnlen)79);
#line 22891 ""
	++lnote;
#line 22892 ""
    }
#line 22893 ""
    if (isarpshift) {
/* Writing concatenation */
#line 22894 ""
	i__2[0] = lnote, a__1[0] = notexq;
#line 22894 ""
	i__2[1] = 1, a__1[1] = "}";
#line 22894 ""
	s_cat(notexq, a__1, i__2, &c__2, (ftnlen)79);
#line 22895 ""
	++lnote;
#line 22896 ""
    }
#line 22897 ""
    addstr_(notexq, &lnote, soutq, lsout, lnote, (ftnlen)80);

/*  cancel out the stored time, to permit two arps at same time! */

#line 22901 ""
    comarp_1.tar[iarp - 1] = -1.f;
#line 22902 ""
    return 0;
} /* putarp_ */

/* Subroutine */ int putast_(real *elask, integer *indxask, char *outq, 
	ftnlen outq_len)
{
    /* System generated locals */
    address a__1[3];
    integer i__1, i__2[3];
    icilist ici__1;

    /* Builtin functions */
    integer s_wsfi(icilist *), do_fio(integer *, char *, ftnlen), e_wsfi(void)
	    ;
    /* Subroutine */ int s_copy(char *, char *, ftnlen, ftnlen), s_cat(char *,
	     char **, integer *, integer *, ftnlen);

    /* Local variables */
    static integer lp;
    static char tag[129], fmtq[9];

    /* Fortran I/O blocks */
    static icilist io___1647 = { 0, fmtq, 0, "(a5,i1,a3)", 9, 1 };


#line 22907 ""
    if (*elask >= 0.f) {
#line 22908 ""
	if (*elask < .995f) {
#line 22909 ""
	    lp = 3;
#line 22910 ""
	} else if (*elask < 9.995f) {
#line 22911 ""
	    lp = 4;
#line 22912 ""
	} else {
#line 22913 ""
	    lp = 5;
#line 22914 ""
	}
#line 22915 ""
	s_wsfi(&io___1647);
#line 22915 ""
	do_fio(&c__1, "(a2,f", (ftnlen)5);
#line 22915 ""
	do_fio(&c__1, (char *)&lp, (ftnlen)sizeof(integer));
#line 22915 ""
	do_fio(&c__1, ".2)", (ftnlen)3);
#line 22915 ""
	e_wsfi();
#line 22916 ""
    } else {
#line 22917 ""
	lp = 5;
#line 22918 ""
	s_copy(fmtq, "(a2,f5.1)", (ftnlen)9, (ftnlen)9);
#line 22919 ""
    }

/*  Overwrite as follows:  ...xyz*ask     *lmnop... -> */
/*                         ...xyz*ast{.nn}*lmnop... */
/*                         ...xyz*ast{n.nn}*lmnop... */
/*                         ...xyz*ast{nn.nn}*lmnop... */
/*  or for negative,       ...xyz*ast{-nn.n}*lmnop... */
#line 22926 ""
    i__1 = *indxask + 8;
#line 22926 ""
    s_copy(tag, outq + i__1, (ftnlen)129, 129 - i__1);
#line 22927 ""
    i__1 = *indxask + 2;
#line 22927 ""
    ici__1.icierr = 0;
#line 22927 ""
    ici__1.icirnum = 1;
#line 22927 ""
    ici__1.icirlen = 129 - i__1;
#line 22927 ""
    ici__1.iciunit = outq + i__1;
#line 22927 ""
    ici__1.icifmt = fmtq;
#line 22927 ""
    s_wsfi(&ici__1);
#line 22927 ""
    do_fio(&c__1, "t{", (ftnlen)2);
#line 22927 ""
    do_fio(&c__1, (char *)&(*elask), (ftnlen)sizeof(real));
#line 22927 ""
    e_wsfi();
/* Writing concatenation */
#line 22928 ""
    i__2[0] = *indxask + 4 + lp, a__1[0] = outq;
#line 22928 ""
    i__2[1] = 1, a__1[1] = "}";
#line 22928 ""
    i__2[2] = 129, a__1[2] = tag;
#line 22928 ""
    s_cat(outq, a__1, i__2, &c__3, (ftnlen)129);
#line 22929 ""
    return 0;
} /* putast_ */

/* Subroutine */ int putcb_(integer *ivx, integer *ip, char *notexq, integer *
	lnote, ftnlen notexq_len)
{
    /* System generated locals */
    address a__1[2];
    integer i__1, i__2[2];
    char ch__1[1];
    icilist ici__1;

    /* Builtin functions */
    /* Subroutine */ int s_stop(char *, ftnlen), s_copy(char *, char *, 
	    ftnlen, ftnlen), s_cat(char *, char **, integer *, integer *, 
	    ftnlen);
    integer s_wsfi(icilist *), do_fio(integer *, char *, ftnlen), e_wsfi(void)
	    ;

    /* Local variables */
    extern integer igetbits_(integer *, integer *, integer *);
    static integer ibc, ipbc, ivxbc;
    static real hshft;
    static integer ihshft, ivshft;
    extern /* Subroutine */ int printl_(char *, ftnlen);

#line 22935 ""
    i__1 = comcb_1.nbc;
#line 22935 ""
    for (ibc = 1; ibc <= i__1; ++ibc) {
#line 22936 ""
	ivxbc = (15 & comcb_1.ibcdata[ibc - 1]) + (igetbits_(&comcb_1.ibcdata[
		ibc - 1], &c__1, &c__28) << 4);
#line 22937 ""
	ipbc = igetbits_(&comcb_1.ibcdata[ibc - 1], &c__8, &c__4);
#line 22938 ""
	if (*ivx == ivxbc && *ip == ipbc) {
#line 22938 ""
	    goto L2;
#line 22938 ""
	}
#line 22939 ""
/* L1: */
#line 22939 ""
    }
#line 22940 ""
    printl_("Error in putbc, Call Dr. Don", (ftnlen)28);
#line 22941 ""
    s_stop("", (ftnlen)0);
#line 22942 ""
L2:
#line 22943 ""
    if (bit_test(comcb_1.ibcdata[ibc - 1],27)) {
#line 22944 ""
	*lnote = 8;
#line 22945 ""
	s_copy(notexq, "\\pbreath", (ftnlen)79, (ftnlen)8);
#line 22946 ""
    } else {
#line 22947 ""
	*lnote = 9;
#line 22948 ""
	s_copy(notexq, "\\pcaesura", (ftnlen)79, (ftnlen)9);
#line 22949 ""
    }
#line 22950 ""
    ivshft = igetbits_(&comcb_1.ibcdata[ibc - 1], &c__6, &c__13);
#line 22951 ""
    if (ivshft > 0) {
#line 22951 ""
	ivshft += -32;
#line 22951 ""
    }
#line 22952 ""
    if (ivshft < 0 || ivshft > 9) {
/* Writing concatenation */
#line 22953 ""
	i__2[0] = *lnote, a__1[0] = notexq;
#line 22953 ""
	i__2[1] = 1, a__1[1] = "{";
#line 22953 ""
	s_cat(notexq, a__1, i__2, &c__2, (ftnlen)79);
#line 22954 ""
	++(*lnote);
#line 22955 ""
	if (ivshft < -9) {
#line 22956 ""
	    i__1 = *lnote;
#line 22956 ""
	    ici__1.icierr = 0;
#line 22956 ""
	    ici__1.icirnum = 1;
#line 22956 ""
	    ici__1.icirlen = *lnote + 3 - i__1;
#line 22956 ""
	    ici__1.iciunit = notexq + i__1;
#line 22956 ""
	    ici__1.icifmt = "(i3)";
#line 22956 ""
	    s_wsfi(&ici__1);
#line 22956 ""
	    do_fio(&c__1, (char *)&ivshft, (ftnlen)sizeof(integer));
#line 22956 ""
	    e_wsfi();
#line 22957 ""
	    *lnote += 3;
#line 22958 ""
	} else {
#line 22959 ""
	    i__1 = *lnote;
#line 22959 ""
	    ici__1.icierr = 0;
#line 22959 ""
	    ici__1.icirnum = 1;
#line 22959 ""
	    ici__1.icirlen = *lnote + 2 - i__1;
#line 22959 ""
	    ici__1.iciunit = notexq + i__1;
#line 22959 ""
	    ici__1.icifmt = "(i2)";
#line 22959 ""
	    s_wsfi(&ici__1);
#line 22959 ""
	    do_fio(&c__1, (char *)&ivshft, (ftnlen)sizeof(integer));
#line 22959 ""
	    e_wsfi();
#line 22960 ""
	    *lnote += 2;
#line 22961 ""
	}
/* Writing concatenation */
#line 22962 ""
	i__2[0] = *lnote, a__1[0] = notexq;
#line 22962 ""
	i__2[1] = 1, a__1[1] = "}";
#line 22962 ""
	s_cat(notexq, a__1, i__2, &c__2, (ftnlen)79);
#line 22963 ""
	++(*lnote);
#line 22964 ""
    } else {
/* Writing concatenation */
#line 22965 ""
	i__2[0] = *lnote, a__1[0] = notexq;
#line 22965 ""
	*(unsigned char *)&ch__1[0] = ivshft + 48;
#line 22965 ""
	i__2[1] = 1, a__1[1] = ch__1;
#line 22965 ""
	s_cat(notexq, a__1, i__2, &c__2, (ftnlen)79);
#line 22966 ""
	++(*lnote);
#line 22967 ""
    }
#line 22968 ""
    ihshft = igetbits_(&comcb_1.ibcdata[ibc - 1], &c__8, &c__19);
#line 22969 ""
    if (ihshft == 0) {
/* Writing concatenation */
#line 22970 ""
	i__2[0] = *lnote, a__1[0] = notexq;
#line 22970 ""
	i__2[1] = 1, a__1[1] = "0";
#line 22970 ""
	s_cat(notexq, a__1, i__2, &c__2, (ftnlen)79);
#line 22971 ""
	++(*lnote);
#line 22972 ""
    } else {
#line 22973 ""
	hshft = (ihshft - 128) * .1f;

/*  -12.8<hshft<12.8 */

/* Writing concatenation */
#line 22977 ""
	i__2[0] = *lnote, a__1[0] = notexq;
#line 22977 ""
	i__2[1] = 1, a__1[1] = "{";
#line 22977 ""
	s_cat(notexq, a__1, i__2, &c__2, (ftnlen)79);
#line 22978 ""
	++(*lnote);
#line 22979 ""
	if (hshft < -9.95f) {
#line 22980 ""
	    i__1 = *lnote;
#line 22980 ""
	    ici__1.icierr = 0;
#line 22980 ""
	    ici__1.icirnum = 1;
#line 22980 ""
	    ici__1.icirlen = *lnote + 5 - i__1;
#line 22980 ""
	    ici__1.iciunit = notexq + i__1;
#line 22980 ""
	    ici__1.icifmt = "(f5.1)";
#line 22980 ""
	    s_wsfi(&ici__1);
#line 22980 ""
	    do_fio(&c__1, (char *)&hshft, (ftnlen)sizeof(real));
#line 22980 ""
	    e_wsfi();
#line 22981 ""
	    *lnote += 5;
#line 22982 ""
	} else if (hshft < -.05f || hshft > 9.95f) {
#line 22983 ""
	    i__1 = *lnote;
#line 22983 ""
	    ici__1.icierr = 0;
#line 22983 ""
	    ici__1.icirnum = 1;
#line 22983 ""
	    ici__1.icirlen = *lnote + 4 - i__1;
#line 22983 ""
	    ici__1.iciunit = notexq + i__1;
#line 22983 ""
	    ici__1.icifmt = "(f4.1)";
#line 22983 ""
	    s_wsfi(&ici__1);
#line 22983 ""
	    do_fio(&c__1, (char *)&hshft, (ftnlen)sizeof(real));
#line 22983 ""
	    e_wsfi();
#line 22984 ""
	    *lnote += 4;
#line 22985 ""
	} else {
#line 22986 ""
	    i__1 = *lnote;
#line 22986 ""
	    ici__1.icierr = 0;
#line 22986 ""
	    ici__1.icirnum = 1;
#line 22986 ""
	    ici__1.icirlen = *lnote + 3 - i__1;
#line 22986 ""
	    ici__1.iciunit = notexq + i__1;
#line 22986 ""
	    ici__1.icifmt = "(f3.1)";
#line 22986 ""
	    s_wsfi(&ici__1);
#line 22986 ""
	    do_fio(&c__1, (char *)&hshft, (ftnlen)sizeof(real));
#line 22986 ""
	    e_wsfi();
#line 22987 ""
	    *lnote += 3;
#line 22988 ""
	}
/* Writing concatenation */
#line 22989 ""
	i__2[0] = *lnote, a__1[0] = notexq;
#line 22989 ""
	i__2[1] = 1, a__1[1] = "}";
#line 22989 ""
	s_cat(notexq, a__1, i__2, &c__2, (ftnlen)79);
#line 22990 ""
	++(*lnote);
#line 22991 ""
    }
#line 22992 ""
    return 0;
} /* putcb_ */

/* Subroutine */ int putfig_(integer *ivx, integer *ifig, real *offnsk, 
	logical *figcheck, char *soutq, integer *lsout, ftnlen soutq_len)
{
    /* System generated locals */
    address a__1[6], a__2[2], a__3[3], a__4[11], a__5[4];
    integer i__1[6], i__2[2], i__3, i__4[3], i__5[11], i__6[4];
    real r__1;
    char ch__1[1], ch__2[22], ch__3[21], ch__4[20], ch__5[19], ch__6[18], 
	    ch__7[13], ch__8[2], ch__9[33], ch__10[11], ch__11[8];

    /* Builtin functions */
    /* Subroutine */ int s_copy(char *, char *, ftnlen, ftnlen), s_cat(char *,
	     char **, integer *, integer *, ftnlen);
    integer s_wsfi(icilist *), do_fio(integer *, char *, ftnlen), e_wsfi(void)
	    , i_indx(char *, char *, ftnlen, ftnlen);

    /* Local variables */
    static integer ic;
    static char sq[1];
    static integer nof;
    static char ch1q[1], ch2q[1];
    extern /* Character */ VOID chax_(char *, ftnlen, integer *);
    static integer nofa;
    static char figq[10];
    static integer lnof;
    static char nofq[5];
    static integer lnum, lnofa;
    static char nofaq[5];
    static integer icnum, lnote;
    extern /* Subroutine */ int addstr_(char *, integer *, char *, integer *, 
	    ftnlen, ftnlen);
    static char figutq[4], conttq[4], notexq[80];
    extern /* Subroutine */ int istring_(integer *, char *, integer *, ftnlen)
	    ;

    /* Fortran I/O blocks */
    static icilist io___1660 = { 0, notexq+5, 0, "(f6.2)", 6, 1 };
    static icilist io___1661 = { 0, notexq+5, 0, "(f5.2)", 5, 1 };
    static icilist io___1662 = { 0, notexq+5, 0, "(f4.2)", 4, 1 };
    static icilist io___1663 = { 0, notexq+5, 0, "(f3.2)", 3, 1 };
    static icilist io___1676 = { 0, notexq+5, 0, "(f6.2)", 6, 1 };
    static icilist io___1677 = { 0, notexq+5, 0, "(f5.2)", 5, 1 };
    static icilist io___1678 = { 0, notexq+5, 0, "(f4.2)", 4, 1 };
    static icilist io___1679 = { 0, notexq+5, 0, "(f3.2)", 3, 1 };


#line 23004 ""
    if (*ivx == 1) {
#line 23005 ""
	s_copy(figutq, "Figu", (ftnlen)4, (ftnlen)4);
#line 23006 ""
	s_copy(conttq, "Cont", (ftnlen)4, (ftnlen)4);
#line 23007 ""
    } else {
#line 23008 ""
	s_copy(figutq, "Figt", (ftnlen)4, (ftnlen)4);
#line 23009 ""
	s_copy(conttq, "Cott", (ftnlen)4, (ftnlen)4);
#line 23010 ""
    }
#line 23011 ""
    chax_(ch__1, (ftnlen)1, &c__92);
#line 23011 ""
    *(unsigned char *)sq = *(unsigned char *)&ch__1[0];
#line 23012 ""
    if (comfig_2.ivvfig[*ivx + (*ifig << 1) - 3] != 0) {

/*  Alter figdrop */

/* Writing concatenation */
#line 23016 ""
	i__1[0] = 1, a__1[0] = sq;
#line 23016 ""
	i__1[1] = 6, a__1[1] = "global";
#line 23016 ""
	i__1[2] = 1, a__1[2] = sq;
#line 23016 ""
	i__1[3] = 7, a__1[3] = "advance";
#line 23016 ""
	i__1[4] = 1, a__1[4] = sq;
#line 23016 ""
	i__1[5] = 7, a__1[5] = "figdrop";
#line 23016 ""
	s_cat(notexq, a__1, i__1, &c__6, (ftnlen)80);
#line 23017 ""
	lnote = 23;
#line 23018 ""
	if (comfig_2.ivvfig[*ivx + (*ifig << 1) - 3] < 0) {
/* Writing concatenation */
#line 23019 ""
	    i__2[0] = lnote, a__2[0] = notexq;
#line 23019 ""
	    i__2[1] = 1, a__2[1] = "-";
#line 23019 ""
	    s_cat(notexq, a__2, i__2, &c__2, (ftnlen)80);
#line 23020 ""
	    ++lnote;
#line 23021 ""
	}
/* Writing concatenation */
#line 23022 ""
	i__2[0] = lnote, a__2[0] = notexq;
#line 23022 ""
	*(unsigned char *)&ch__1[0] = (i__3 = comfig_2.ivvfig[*ivx + (*ifig <<
		 1) - 3], abs(i__3)) + 48;
#line 23022 ""
	i__2[1] = 1, a__2[1] = ch__1;
#line 23022 ""
	s_cat(notexq, a__2, i__2, &c__2, (ftnlen)80);
#line 23023 ""
	++lnote;
#line 23024 ""
	addstr_(notexq, &lnote, soutq, lsout, (ftnlen)80, (ftnlen)80);
#line 23025 ""
    }
#line 23026 ""
    if (dabs(*offnsk) > 1e-4f) {

/*  Write offset for floating figure, to two decimal places */

/* Writing concatenation */
#line 23030 ""
	i__2[0] = 1, a__2[0] = sq;
#line 23030 ""
	i__2[1] = 4, a__2[1] = "off{";
#line 23030 ""
	s_cat(notexq, a__2, i__2, &c__2, (ftnlen)80);
#line 23031 ""
	if (-(*offnsk) < -9.995f) {
#line 23032 ""
	    s_wsfi(&io___1660);
#line 23032 ""
	    r__1 = -(*offnsk);
#line 23032 ""
	    do_fio(&c__1, (char *)&r__1, (ftnlen)sizeof(real));
#line 23032 ""
	    e_wsfi();
#line 23033 ""
	    lnote = 11;
#line 23034 ""
	} else if (-(*offnsk) < -.995f || -(*offnsk) > 9.995f) {
#line 23035 ""
	    s_wsfi(&io___1661);
#line 23035 ""
	    r__1 = -(*offnsk);
#line 23035 ""
	    do_fio(&c__1, (char *)&r__1, (ftnlen)sizeof(real));
#line 23035 ""
	    e_wsfi();
#line 23036 ""
	    lnote = 10;
#line 23037 ""
	} else if (-(*offnsk) < -1e-4f || -(*offnsk) > .995f) {
#line 23038 ""
	    s_wsfi(&io___1662);
#line 23038 ""
	    r__1 = -(*offnsk);
#line 23038 ""
	    do_fio(&c__1, (char *)&r__1, (ftnlen)sizeof(real));
#line 23038 ""
	    e_wsfi();
#line 23039 ""
	    lnote = 9;
#line 23040 ""
	} else {
#line 23041 ""
	    s_wsfi(&io___1663);
#line 23041 ""
	    r__1 = -(*offnsk);
#line 23041 ""
	    do_fio(&c__1, (char *)&r__1, (ftnlen)sizeof(real));
#line 23041 ""
	    e_wsfi();
#line 23042 ""
	    lnote = 8;
#line 23043 ""
	}
/* Writing concatenation */
#line 23044 ""
	i__4[0] = lnote, a__3[0] = notexq;
#line 23044 ""
	i__4[1] = 1, a__3[1] = sq;
#line 23044 ""
	i__4[2] = 9, a__3[2] = "noteskip}";
#line 23044 ""
	s_cat(notexq, a__3, i__4, &c__3, (ftnlen)80);
#line 23045 ""
	i__3 = lnote + 10;
#line 23045 ""
	addstr_(notexq, &i__3, soutq, lsout, (ftnlen)80, (ftnlen)80);
#line 23046 ""
    }
#line 23047 ""
    s_copy(figq, comfig_2.figqq + (*ivx + (*ifig << 1) - 3) * 10, (ftnlen)10, 
	    (ftnlen)10);
#line 23048 ""
    ic = 1;
#line 23049 ""
    nof = -comfig_2.ivupfig[*ivx + (*ifig << 1) - 3];
#line 23050 ""
    nofa = -comfig_2.ivupfig[*ivx + (*ifig << 1) - 3] - 1;

/*  Beginning of manual loop */

#line 23054 ""
L1:
#line 23054 ""
    *(unsigned char *)ch1q = *(unsigned char *)&figq[ic - 1];

/*  Exit when first blank is encountered */

#line 23058 ""
    if (*(unsigned char *)ch1q == ' ') {
#line 23058 ""
	goto L2;
#line 23058 ""
    }

/*  Starting a level.  Set up vertical offset. */

#line 23062 ""
    istring_(&nof, nofq, &lnof, (ftnlen)5);
#line 23063 ""
    istring_(&nofa, nofaq, &lnofa, (ftnlen)5);
#line 23064 ""
    if (*(unsigned char *)ch1q == '0') {

/*  Continuation figure.  Next number is length (in noteskips). The number will */
/*    end at the first blank or char that is not digit or decimal point. If */
/*    colon, it is a separator and must be skipped */

#line 23070 ""
	icnum = ic + 1;
#line 23071 ""
L3:
#line 23072 ""
	++ic;
#line 23073 ""
	if (i_indx("0123456789.", figq + (ic - 1), (ftnlen)11, (ftnlen)1) > 0)
		 {
#line 23073 ""
	    goto L3;
#line 23073 ""
	}
#line 23074 ""
	lnum = ic - icnum;
/* Writing concatenation */
#line 23075 ""
	i__1[0] = 1, a__1[0] = sq;
#line 23075 ""
	i__1[1] = 4, a__1[1] = conttq;
#line 23075 ""
	i__1[2] = lnof, a__1[2] = nofq;
#line 23075 ""
	i__1[3] = 1, a__1[3] = "{";
#line 23075 ""
	i__1[4] = ic - 1 - (icnum - 1), a__1[4] = figq + (icnum - 1);
#line 23075 ""
	i__1[5] = 1, a__1[5] = "}";
#line 23075 ""
	s_cat(ch__2, a__1, i__1, &c__6, (ftnlen)22);
#line 23075 ""
	i__3 = ic + 7 - icnum + lnof;
#line 23075 ""
	addstr_(ch__2, &i__3, soutq, lsout, lnof + 6 + (ic - 1 - (icnum - 1)) 
		+ 1, (ftnlen)80);
#line 23077 ""
	if (*(unsigned char *)&figq[ic - 1] != ':') {
#line 23077 ""
	    --ic;
#line 23077 ""
	}
#line 23078 ""
    } else if (*(unsigned char *)ch1q == '#' || *(unsigned char *)ch1q == '-' 
	    || *(unsigned char *)ch1q == 'n') {
#line 23079 ""
	++ic;
#line 23080 ""
	*(unsigned char *)ch2q = *(unsigned char *)&figq[ic - 1];
#line 23081 ""
	if (*(unsigned char *)ch2q == ' ') {

/*  Figure is a stand-alone accidental, so must be centered */

#line 23085 ""
	    if (*(unsigned char *)ch1q == '#') {
/* Writing concatenation */
#line 23086 ""
		i__1[0] = 1, a__1[0] = sq;
#line 23086 ""
		i__1[1] = 4, a__1[1] = figutq;
#line 23086 ""
		i__1[2] = lnofa, a__1[2] = nofaq;
#line 23086 ""
		i__1[3] = 1, a__1[3] = "{";
#line 23086 ""
		i__1[4] = 1, a__1[4] = sq;
#line 23086 ""
		i__1[5] = 9, a__1[5] = "sharpfig}";
#line 23086 ""
		s_cat(ch__3, a__1, i__1, &c__6, (ftnlen)21);
#line 23086 ""
		i__3 = lnofa + 16;
#line 23086 ""
		addstr_(ch__3, &i__3, soutq, lsout, lnofa + 16, (ftnlen)80);
#line 23088 ""
	    } else if (*(unsigned char *)ch1q == '-') {
/* Writing concatenation */
#line 23089 ""
		i__1[0] = 1, a__1[0] = sq;
#line 23089 ""
		i__1[1] = 4, a__1[1] = figutq;
#line 23089 ""
		i__1[2] = lnofa, a__1[2] = nofaq;
#line 23089 ""
		i__1[3] = 1, a__1[3] = "{";
#line 23089 ""
		i__1[4] = 1, a__1[4] = sq;
#line 23089 ""
		i__1[5] = 8, a__1[5] = "flatfig}";
#line 23089 ""
		s_cat(ch__4, a__1, i__1, &c__6, (ftnlen)20);
#line 23089 ""
		i__3 = lnofa + 15;
#line 23089 ""
		addstr_(ch__4, &i__3, soutq, lsout, lnofa + 15, (ftnlen)80);
#line 23091 ""
	    } else if (*(unsigned char *)ch1q == 'n') {
/* Writing concatenation */
#line 23092 ""
		i__1[0] = 1, a__1[0] = sq;
#line 23092 ""
		i__1[1] = 4, a__1[1] = figutq;
#line 23092 ""
		i__1[2] = lnofa, a__1[2] = nofaq;
#line 23092 ""
		i__1[3] = 1, a__1[3] = "{";
#line 23092 ""
		i__1[4] = 1, a__1[4] = sq;
#line 23092 ""
		i__1[5] = 7, a__1[5] = "natfig}";
#line 23092 ""
		s_cat(ch__5, a__1, i__1, &c__6, (ftnlen)19);
#line 23092 ""
		i__3 = lnofa + 14;
#line 23092 ""
		addstr_(ch__5, &i__3, soutq, lsout, lnofa + 14, (ftnlen)80);
#line 23094 ""
	    }
#line 23095 ""
	    goto L2;
#line 23096 ""
	} else {

/*  Figure is an accidental followed by a number */
/*  First put the accidental (offset to the left) */

#line 23101 ""
	    if (*(unsigned char *)ch1q == '#') {
/* Writing concatenation */
#line 23102 ""
		i__1[0] = 1, a__1[0] = sq;
#line 23102 ""
		i__1[1] = 4, a__1[1] = figutq;
#line 23102 ""
		i__1[2] = lnofa, a__1[2] = nofaq;
#line 23102 ""
		i__1[3] = 1, a__1[3] = "{";
#line 23102 ""
		i__1[4] = 1, a__1[4] = sq;
#line 23102 ""
		i__1[5] = 6, a__1[5] = "fsmsh}";
#line 23102 ""
		s_cat(ch__6, a__1, i__1, &c__6, (ftnlen)18);
#line 23102 ""
		i__3 = lnofa + 13;
#line 23102 ""
		addstr_(ch__6, &i__3, soutq, lsout, lnofa + 13, (ftnlen)80);
#line 23105 ""
	    } else if (*(unsigned char *)ch1q == '-') {
/* Writing concatenation */
#line 23106 ""
		i__1[0] = 1, a__1[0] = sq;
#line 23106 ""
		i__1[1] = 4, a__1[1] = figutq;
#line 23106 ""
		i__1[2] = lnofa, a__1[2] = nofaq;
#line 23106 ""
		i__1[3] = 1, a__1[3] = "{";
#line 23106 ""
		i__1[4] = 1, a__1[4] = sq;
#line 23106 ""
		i__1[5] = 6, a__1[5] = "fsmfl}";
#line 23106 ""
		s_cat(ch__6, a__1, i__1, &c__6, (ftnlen)18);
#line 23106 ""
		i__3 = lnofa + 13;
#line 23106 ""
		addstr_(ch__6, &i__3, soutq, lsout, lnofa + 13, (ftnlen)80);
#line 23109 ""
	    } else if (*(unsigned char *)ch1q == 'n') {
/* Writing concatenation */
#line 23110 ""
		i__1[0] = 1, a__1[0] = sq;
#line 23110 ""
		i__1[1] = 4, a__1[1] = figutq;
#line 23110 ""
		i__1[2] = lnofa, a__1[2] = nofaq;
#line 23110 ""
		i__1[3] = 1, a__1[3] = "{";
#line 23110 ""
		i__1[4] = 1, a__1[4] = sq;
#line 23110 ""
		i__1[5] = 6, a__1[5] = "fsmna}";
#line 23110 ""
		s_cat(ch__6, a__1, i__1, &c__6, (ftnlen)18);
#line 23110 ""
		i__3 = lnofa + 13;
#line 23110 ""
		addstr_(ch__6, &i__3, soutq, lsout, lnofa + 13, (ftnlen)80);
#line 23113 ""
	    }

/*  Now put the number */

/* Writing concatenation */
#line 23117 ""
	    i__1[0] = 1, a__1[0] = sq;
#line 23117 ""
	    i__1[1] = 4, a__1[1] = figutq;
#line 23117 ""
	    i__1[2] = lnof, a__1[2] = nofq;
#line 23117 ""
	    i__1[3] = 1, a__1[3] = "{";
#line 23117 ""
	    i__1[4] = 1, a__1[4] = ch2q;
#line 23117 ""
	    i__1[5] = 1, a__1[5] = "}";
#line 23117 ""
	    s_cat(ch__7, a__1, i__1, &c__6, (ftnlen)13);
#line 23117 ""
	    i__3 = lnof + 8;
#line 23117 ""
	    addstr_(ch__7, &i__3, soutq, lsout, lnof + 8, (ftnlen)80);

/*  Mods for 2-digit fig with accidental. */

#line 23122 ""
	    if (*(unsigned char *)ch2q == '1') {
#line 23123 ""
		++ic;
#line 23124 ""
		--(*lsout);
/* Writing concatenation */
#line 23125 ""
		i__2[0] = 1, a__2[0] = figq + (ic - 1);
#line 23125 ""
		i__2[1] = 1, a__2[1] = "}";
#line 23125 ""
		s_cat(ch__8, a__2, i__2, &c__2, (ftnlen)2);
#line 23125 ""
		addstr_(ch__8, &c__2, soutq, lsout, (ftnlen)2, (ftnlen)80);
#line 23126 ""
	    }
#line 23127 ""
	}
#line 23128 ""
    } else if (*(unsigned char *)ch1q == '_') {

/*  Placeholder only (for lowering a figure).  Don't do anything! */

#line 23133 ""
    } else if (*(unsigned char *)ch1q == '1') {

/*  Mods for 2-digit fig with no accidental. */

#line 23137 ""
	++ic;
#line 23138 ""
	*(unsigned char *)ch2q = *(unsigned char *)&figq[ic - 1];
/* Writing concatenation */
#line 23139 ""
	i__5[0] = 1, a__4[0] = sq;
#line 23139 ""
	i__5[1] = 9, a__4[1] = "off{-2pt}";
#line 23139 ""
	i__5[2] = 1, a__4[2] = sq;
#line 23139 ""
	i__5[3] = 4, a__4[3] = figutq;
#line 23139 ""
	i__5[4] = lnof, a__4[4] = nofq;
#line 23139 ""
	i__5[5] = 1, a__4[5] = "{";
#line 23139 ""
	i__5[6] = 1, a__4[6] = "1";
#line 23139 ""
	i__5[7] = 1, a__4[7] = ch2q;
#line 23139 ""
	i__5[8] = 1, a__4[8] = "}";
#line 23139 ""
	i__5[9] = 1, a__4[9] = sq;
#line 23139 ""
	i__5[10] = 8, a__4[10] = "off{2pt}";
#line 23139 ""
	s_cat(ch__9, a__4, i__5, &c__11, (ftnlen)33);
#line 23139 ""
	i__3 = lnof + 28;
#line 23139 ""
	addstr_(ch__9, &i__3, soutq, lsout, lnof + 28, (ftnlen)80);
#line 23141 ""
    } else {

/*  Figure is a single number, maybe with s after */

/* Writing concatenation */
#line 23145 ""
	i__6[0] = 1, a__5[0] = sq;
#line 23145 ""
	i__6[1] = 4, a__5[1] = figutq;
#line 23145 ""
	i__6[2] = lnof, a__5[2] = nofq;
#line 23145 ""
	i__6[3] = 1, a__5[3] = "{";
#line 23145 ""
	s_cat(ch__10, a__5, i__6, &c__4, (ftnlen)11);
#line 23145 ""
	i__3 = lnof + 6;
#line 23145 ""
	addstr_(ch__10, &i__3, soutq, lsout, lnof + 6, (ftnlen)80);
#line 23147 ""
	i__3 = ic;
#line 23147 ""
	s_copy(ch2q, figq + i__3, (ftnlen)1, ic + 1 - i__3);
#line 23148 ""
	if (*(unsigned char *)ch2q == 's') {

/*  Use a special character. Insert font call */

#line 23152 ""
	    ++ic;
/* Writing concatenation */
#line 23153 ""
	    i__2[0] = 1, a__2[0] = sq;
#line 23153 ""
	    i__2[1] = 7, a__2[1] = "ligfont";
#line 23153 ""
	    s_cat(ch__11, a__2, i__2, &c__2, (ftnlen)8);
#line 23153 ""
	    addstr_(ch__11, &c__8, soutq, lsout, (ftnlen)8, (ftnlen)80);
#line 23154 ""
	}
/* Writing concatenation */
#line 23155 ""
	i__2[0] = 1, a__2[0] = ch1q;
#line 23155 ""
	i__2[1] = 1, a__2[1] = "}";
#line 23155 ""
	s_cat(ch__8, a__2, i__2, &c__2, (ftnlen)2);
#line 23155 ""
	addstr_(ch__8, &c__2, soutq, lsout, (ftnlen)2, (ftnlen)80);
#line 23156 ""
    }
#line 23157 ""
    if (ic >= 10) {
#line 23157 ""
	goto L2;
#line 23157 ""
    }
#line 23158 ""
    ++ic;
#line 23159 ""
    nof += 4;
#line 23160 ""
    nofa += 4;
#line 23161 ""
    goto L1;
#line 23162 ""
L2:
#line 23163 ""
    if (dabs(*offnsk) > 1e-4f) {
/* Writing concatenation */
#line 23164 ""
	i__2[0] = 1, a__2[0] = sq;
#line 23164 ""
	i__2[1] = 4, a__2[1] = "off{";
#line 23164 ""
	s_cat(notexq, a__2, i__2, &c__2, (ftnlen)80);
#line 23165 ""
	if (*offnsk < -9.995f) {
#line 23166 ""
	    s_wsfi(&io___1676);
#line 23166 ""
	    do_fio(&c__1, (char *)&(*offnsk), (ftnlen)sizeof(real));
#line 23166 ""
	    e_wsfi();
#line 23167 ""
	    lnote = 11;
#line 23168 ""
	} else if (*offnsk < -.995f || *offnsk > 9.995f) {
#line 23169 ""
	    s_wsfi(&io___1677);
#line 23169 ""
	    do_fio(&c__1, (char *)&(*offnsk), (ftnlen)sizeof(real));
#line 23169 ""
	    e_wsfi();
#line 23170 ""
	    lnote = 10;
#line 23171 ""
	} else if (*offnsk < -1e-4f || *offnsk > .995f) {
#line 23172 ""
	    s_wsfi(&io___1678);
#line 23172 ""
	    do_fio(&c__1, (char *)&(*offnsk), (ftnlen)sizeof(real));
#line 23172 ""
	    e_wsfi();
#line 23173 ""
	    lnote = 9;
#line 23174 ""
	} else {
#line 23175 ""
	    s_wsfi(&io___1679);
#line 23175 ""
	    do_fio(&c__1, (char *)&(*offnsk), (ftnlen)sizeof(real));
#line 23175 ""
	    e_wsfi();
#line 23176 ""
	    lnote = 8;
#line 23177 ""
	}
/* Writing concatenation */
#line 23178 ""
	i__4[0] = lnote, a__3[0] = notexq;
#line 23178 ""
	i__4[1] = 1, a__3[1] = sq;
#line 23178 ""
	i__4[2] = 9, a__3[2] = "noteskip}";
#line 23178 ""
	s_cat(notexq, a__3, i__4, &c__3, (ftnlen)80);
#line 23179 ""
	i__3 = lnote + 10;
#line 23179 ""
	addstr_(notexq, &i__3, soutq, lsout, (ftnlen)80, (ftnlen)80);
#line 23180 ""
    }
#line 23181 ""
    if (*ifig < comfig_2.nfigs[*ivx - 1]) {
#line 23182 ""
	++(*ifig);
#line 23183 ""
    } else {
#line 23184 ""
	comfig_2.nfigs[*ivx - 1] = 0;
#line 23185 ""
	*figcheck = FALSE_;
#line 23186 ""
    }
#line 23187 ""
    return 0;
} /* putfig_ */

/* Subroutine */ int putorn_(integer *iornq, integer *nolev, integer *nolevm, 
	integer *nodur, integer *nornb, char *ulq, integer *ibmcnt, integer *
	ivx, integer *ncm, integer *islur, integer *nvmx, integer *nv, 
	integer *ihornb, real *stemlin, char *outq, integer *lout, integer *
	ip, integer *islhgt, logical *beamon, logical *iscrd, ftnlen ulq_len, 
	ftnlen outq_len)
{
    /* System generated locals */
    address a__1[2], a__2[3], a__3[6];
    integer i__1, i__2, i__3[2], i__4[3], i__5[6];
    real r__1, r__2;
    char ch__1[1], ch__2[6];
    icilist ici__1;

    /* Builtin functions */
    integer pow_ii(integer *, integer *), i_nint(real *);
    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
    integer lbit_shift(integer, integer), i_dim(integer *, integer *), s_wsfi(
	    icilist *), do_fio(integer *, char *, ftnlen), e_wsfi(void);
    /* Subroutine */ int s_copy(char *, char *, ftnlen, ftnlen);

    /* Local variables */
    extern /* Subroutine */ int addblank_(char *, integer *, ftnlen);
    static logical usehornb;
    static char sq[1];
    extern integer log2_(integer *);
    extern /* Character */ VOID chax_(char *, ftnlen, integer *);
    static integer ioff, ibit;
    extern /* Character */ VOID udqq_(char *, ftnlen, integer *, integer *, 
	    integer *, integer *, integer *, integer *);
    extern integer lfmt1_(real *);
    static integer ibitt, ihorn, lform, lnote;
    static char noteq[8];
    static integer iornt;
    static char ulpzq[1];
    extern /* Subroutine */ int notefq_(char *, integer *, integer *, integer 
	    *, ftnlen);
    static integer lnoten, iudorn;
    static char notexq[79];
    static integer iclracc, ioffinc;
    static real stemlen;
    extern /* Subroutine */ int dotrill_(integer *, integer *, integer *, 
	    char *, integer *, char *, integer *, ftnlen, ftnlen);


/*  All args are individual array element *values* except nornb,ihornb,ulq. */
/*  notcrd = .true. if ornament is on main note. */
/*    nolevm is level of main note (for chords) */

#line 23207 ""
    /* Parameter adjustments */
#line 23207 ""
    ihornb -= 25;
#line 23207 ""
    ulq -= 25;
#line 23207 ""
    --nornb;
#line 23207 ""

#line 23207 ""
    /* Function Body */
#line 23207 ""
    chax_(ch__1, (ftnlen)1, &c__92);
#line 23207 ""
    *(unsigned char *)sq = *(unsigned char *)&ch__1[0];
#line 23208 ""
    *lout = 0;
#line 23209 ""
    usehornb = FALSE_;
#line 23210 ""
    if (*nodur < 64) {
#line 23211 ""
	stemlen = *stemlin;
#line 23212 ""
    } else {
#line 23213 ""
	stemlen = 0.f;
#line 23214 ""
    }

/*  Get up-downness. ulpzq is opposite from stem direction for both beams and */
/*    non beams.  Can use in name of ornament [ . or _ ] */

#line 23219 ""
    if (*beamon) {
#line 23220 ""
	if (*(unsigned char *)&ulq[*ivx + *ibmcnt * 24] == 'u') {
#line 23221 ""
	    *(unsigned char *)ulpzq = 'l';
#line 23222 ""
	} else {
#line 23223 ""
	    *(unsigned char *)ulpzq = 'u';
#line 23224 ""
	}
#line 23225 ""
    } else {
#line 23226 ""
	udqq_(ch__1, (ftnlen)1, nolevm, ncm, islur, nvmx, ivx, nv);
#line 23226 ""
	if (*(unsigned char *)&ch__1[0] == 'l') {
#line 23227 ""
	    *(unsigned char *)ulpzq = 'u';
#line 23228 ""
	} else {
#line 23229 ""
	    *(unsigned char *)ulpzq = 'l';
#line 23230 ""
	}
#line 23231 ""
    }

/*  To enable >1 ornament on a note, next line is top of manual loop. */

#line 23235 ""
L2:
#line 23236 ""
    if (bit_test(*iornq,29)) {
#line 23237 ""
	ibit = 29;
#line 23238 ""
    } else if (bit_test(*iornq,30)) {
#line 23239 ""
	ibit = 30;
#line 23240 ""
    } else {
#line 23241 ""
	i__1 = *iornq & 4194303;
#line 23241 ""
	ibit = log2_(&i__1);
#line 23242 ""
    }
#line 23243 ""
    iornt = pow_ii(&c__2, &ibit);

/*  Begin routine to set height.  Bits 0-13: (stmgx+Tupf._) */
/*  14: Down fermata, was F  15: Trill w/o "tr", was U, 16-18: edit. s,f,n */
/*  19-20: >^, 21: ? (with or w/o 16-18) */
/*  and 29-30: C (coda), G (new segno) */

/*  Do not use beam height for . or _ */

#line 23252 ""
    if (bit_test(*iornq,22) && (iornt & 6144) == 0) {

/*  Height is set by special beam stuff. */
/*  Do not leave ihorn set, do separately for every ornament */

#line 23257 ""
	ihorn = ihornb[*ivx + nornb[*ivx] * 24];
#line 23258 ""
	if (*(unsigned char *)ulpzq == 'u') {
#line 23258 ""
	    ihorn += -2;
#line 23258 ""
	}

/*  Following flag tells whether to increment nornb when exiting the subroutine. */

#line 23262 ""
	usehornb = TRUE_;
#line 23263 ""
    } else if (ibit == 14) {

/*  Down fermata.  Don't worry about upper chord notes. */

#line 23267 ""
	if (*(unsigned char *)ulpzq == 'l') {
/* Computing MIN */
#line 23268 ""
	    i__1 = *nolev, i__2 = *ncm - 3;
#line 23268 ""
	    ihorn = min(i__1,i__2);
#line 23269 ""
	} else {
/* Computing MIN */
#line 23270 ""
	    r__1 = *nolev - stemlen, r__2 = *ncm - 3.f;
#line 23270 ""
	    ihorn = dmin(r__1,r__2);
#line 23271 ""
	}
#line 23272 ""
    } else if (bit_test(iornt,13) || bit_test(iornt,0)) {

/*  ( or ) */

#line 23276 ""
	ihorn = *nolev;
#line 23277 ""
    } else if ((iornt & 6144) > 0) {

/* c  Staccato . or tenuto _ , but not special beam stuff.  Need up-down info */
/*  NOTE: removed .&_ from special beam treatment. */
/*  Staccato . or tenuto _  Need up-down info */

#line 23283 ""
	if (! (*iscrd) || comtrill_1.maxlev != *nolev && *(unsigned char *)
		ulpzq == 'l' || comtrill_1.minlev != *nolev && *(unsigned 
		char *)ulpzq == 'u') {
#line 23285 ""
	    ihorn = *nolev;
#line 23286 ""
	} else if (comtrill_1.maxlev == *nolev) {
#line 23287 ""
	    *(unsigned char *)ulpzq = 'u';
/* Computing MAX */
#line 23288 ""
	    r__1 = *nolev + stemlen, r__2 = *ncm + 3.f;
#line 23288 ""
	    ihorn = dmax(r__1,r__2);
#line 23289 ""
	} else {
#line 23290 ""
	    *(unsigned char *)ulpzq = 'l';
/* Computing MIN */
#line 23291 ""
	    r__1 = *nolev - stemlen, r__2 = *ncm - 3.f;
#line 23291 ""
	    ihorn = dmin(r__1,r__2);
#line 23292 ""
	}
#line 23293 ""
    } else if (*iscrd && *nolev == comtrill_1.minlev) {
#line 23294 ""
	if (*(unsigned char *)ulpzq == 'l') {
/* Computing MIN */
#line 23295 ""
	    i__1 = *nolev - 3, i__2 = *ncm - 6;
#line 23295 ""
	    ihorn = min(i__1,i__2);
#line 23296 ""
	} else {
/* Computing MIN */
#line 23297 ""
	    i__1 = *nolev - i_nint(&stemlen) - 3, i__2 = *ncm - 6;
#line 23297 ""
	    ihorn = min(i__1,i__2);
#line 23298 ""
	}
#line 23299 ""
    } else if (ibit == 10 && *nolev > 90) {

/*  Special treatment for fermata on a shifted rest */

#line 23303 ""
	ihorn = *ncm + 5;
#line 23304 ""
    } else if (*(unsigned char *)ulpzq == 'l') {

/*  (iscrd and nolev=maxlev) or (.not.iscrd) */

/* Computing MAX */
#line 23308 ""
	r__1 = *nolev + stemlen + 2, r__2 = *ncm + 5.f;
#line 23308 ""
	ihorn = dmax(r__1,r__2);
#line 23309 ""
    } else if (ibit == 29 || ibit == 30) {

/*  coda or new segno, no height tweak */

#line 23313 ""
	ihorn = *ncm + 5;
#line 23314 ""
    } else {
/* Computing MAX */
#line 23315 ""
	i__1 = *nolev + 2, i__2 = *ncm + 5;
#line 23315 ""
	ihorn = max(i__1,i__2);
#line 23316 ""
    }
#line 23317 ""
    ioff = 0;
#line 23318 ""
    iclracc = 0;

/*  Begin routine to set name.  Bits 0-13: (stmgx+Tupf._) */
/*  14: Down fermata, was F  15: Trill w/o "tr", was U, 16-18: edit. s,f,n */

#line 23323 ""
    if (bit_test(iornt,2)) {
/* Writing concatenation */
#line 23324 ""
	i__3[0] = 1, a__1[0] = sq;
#line 23324 ""
	i__3[1] = 5, a__1[1] = "shake";
#line 23324 ""
	s_cat(notexq, a__1, i__3, &c__2, (ftnlen)79);
#line 23325 ""
	lnote = 6;
#line 23326 ""
    } else if (bit_test(iornt,3)) {
/* Writing concatenation */
#line 23327 ""
	i__3[0] = 1, a__1[0] = sq;
#line 23327 ""
	i__3[1] = 7, a__1[1] = "mordent";
#line 23327 ""
	s_cat(notexq, a__1, i__3, &c__2, (ftnlen)79);
#line 23328 ""
	lnote = 8;
#line 23329 ""
    } else if (bit_test(iornt,1)) {
/* Writing concatenation */
#line 23330 ""
	i__3[0] = 1, a__1[0] = sq;
#line 23330 ""
	i__3[1] = 3, a__1[1] = "mtr";
#line 23330 ""
	s_cat(notexq, a__1, i__3, &c__2, (ftnlen)79);
#line 23331 ""
	lnote = 4;
#line 23332 ""
    } else if (bit_test(iornt,5)) {
/* Writing concatenation */
#line 23333 ""
	i__3[0] = 1, a__1[0] = sq;
#line 23333 ""
	i__3[1] = 3, a__1[1] = "xtr";
#line 23333 ""
	s_cat(notexq, a__1, i__3, &c__2, (ftnlen)79);
#line 23334 ""
	lnote = 4;
#line 23335 ""
    } else if (bit_test(iornt,6)) {
/* Writing concatenation */
#line 23336 ""
	i__3[0] = 1, a__1[0] = sq;
#line 23336 ""
	i__3[1] = 3, a__1[1] = "ptr";
#line 23336 ""
	s_cat(notexq, a__1, i__3, &c__2, (ftnlen)79);
#line 23337 ""
	lnote = 4;
#line 23338 ""
    } else if (bit_test(iornt,13)) {
/* Writing concatenation */
#line 23339 ""
	i__3[0] = 1, a__1[0] = sq;
#line 23339 ""
	i__3[1] = 3, a__1[1] = "rpn";
#line 23339 ""
	s_cat(notexq, a__1, i__3, &c__2, (ftnlen)79);
#line 23340 ""
	lnote = 4;
#line 23341 ""
    } else if (bit_test(iornt,0)) {
/* Writing concatenation */
#line 23342 ""
	i__3[0] = 1, a__1[0] = sq;
#line 23342 ""
	i__3[1] = 3, a__1[1] = "lpn";
#line 23342 ""
	s_cat(notexq, a__1, i__3, &c__2, (ftnlen)79);
#line 23343 ""
	lnote = 4;
#line 23344 ""
    } else if (bit_test(iornt,12)) {
/* Writing concatenation */
#line 23345 ""
	i__4[0] = 1, a__2[0] = sq;
#line 23345 ""
	i__4[1] = 1, a__2[1] = ulpzq;
#line 23345 ""
	i__4[2] = 2, a__2[2] = "st";
#line 23345 ""
	s_cat(notexq, a__2, i__4, &c__3, (ftnlen)79);
#line 23346 ""
	lnote = 4;
#line 23347 ""
    } else if (bit_test(iornt,11)) {
/* Writing concatenation */
#line 23348 ""
	i__4[0] = 1, a__2[0] = sq;
#line 23348 ""
	i__4[1] = 1, a__2[1] = ulpzq;
#line 23348 ""
	i__4[2] = 2, a__2[2] = "pz";
#line 23348 ""
	s_cat(notexq, a__2, i__4, &c__3, (ftnlen)79);
#line 23349 ""
	lnote = 4;
#line 23350 ""
    } else if (bit_test(iornt,8)) {
/* Writing concatenation */
#line 23351 ""
	i__3[0] = 1, a__1[0] = sq;
#line 23351 ""
	i__3[1] = 3, a__1[1] = "upz";
#line 23351 ""
	s_cat(notexq, a__1, i__3, &c__2, (ftnlen)79);
#line 23352 ""
	lnote = 4;
#line 23353 ""
	ioff = -2;
#line 23354 ""
    } else if (bit_test(iornt,9)) {
/* Writing concatenation */
#line 23355 ""
	i__3[0] = 1, a__1[0] = sq;
#line 23355 ""
	i__3[1] = 4, a__1[1] = "uppz";
#line 23355 ""
	s_cat(notexq, a__1, i__3, &c__2, (ftnlen)79);
#line 23356 ""
	lnote = 5;
#line 23357 ""
	ioff = -2;
#line 23358 ""
    } else if (bit_test(iornt,10)) {
#line 23359 ""
	if (*nodur < 48) {
/* Writing concatenation */
#line 23360 ""
	    i__3[0] = 1, a__1[0] = sq;
#line 23360 ""
	    i__3[1] = 9, a__1[1] = "fermataup";
#line 23360 ""
	    s_cat(notexq, a__1, i__3, &c__2, (ftnlen)79);
#line 23361 ""
	} else {
/* Writing concatenation */
#line 23362 ""
	    i__3[0] = 1, a__1[0] = sq;
#line 23362 ""
	    i__3[1] = 9, a__1[1] = "Fermataup";
#line 23362 ""
	    s_cat(notexq, a__1, i__3, &c__2, (ftnlen)79);
#line 23363 ""
	}
#line 23364 ""
	lnote = 10;
#line 23365 ""
	ioff = -2;
#line 23366 ""
    } else if (bit_test(iornt,14)) {
#line 23367 ""
	if (*nodur < 48) {
/* Writing concatenation */
#line 23368 ""
	    i__3[0] = 1, a__1[0] = sq;
#line 23368 ""
	    i__3[1] = 11, a__1[1] = "fermatadown";
#line 23368 ""
	    s_cat(notexq, a__1, i__3, &c__2, (ftnlen)79);
#line 23369 ""
	} else {
/* Writing concatenation */
#line 23370 ""
	    i__3[0] = 1, a__1[0] = sq;
#line 23370 ""
	    i__3[1] = 11, a__1[1] = "Fermatadown";
#line 23370 ""
	    s_cat(notexq, a__1, i__3, &c__2, (ftnlen)79);
#line 23371 ""
	}
#line 23372 ""
	lnote = 12;
#line 23373 ""
    } else if (bit_test(iornt,21)) {

/*  "?" in editorial ornament.  Clear bit 16-18 after use, since ibit=21 */

#line 23377 ""
	if (bit_test(*iornq,16)) {
/* Writing concatenation */
#line 23378 ""
	    i__3[0] = 1, a__1[0] = sq;
#line 23378 ""
	    i__3[1] = 6, a__1[1] = "qsharp";
#line 23378 ""
	    s_cat(notexq, a__1, i__3, &c__2, (ftnlen)79);
#line 23379 ""
	    lnote = 7;
#line 23380 ""
	    ioff = 2;
#line 23381 ""
	    *iornq = bit_clear(*iornq,16);
#line 23382 ""
	    iclracc = 16;
#line 23383 ""
	} else if (bit_test(*iornq,17)) {
/* Writing concatenation */
#line 23384 ""
	    i__3[0] = 1, a__1[0] = sq;
#line 23384 ""
	    i__3[1] = 5, a__1[1] = "qflat";
#line 23384 ""
	    s_cat(notexq, a__1, i__3, &c__2, (ftnlen)79);
#line 23385 ""
	    lnote = 6;
#line 23386 ""
	    ioff = 1;
#line 23387 ""
	    *iornq = bit_clear(*iornq,17);
#line 23388 ""
	    iclracc = 17;
#line 23389 ""
	} else if (bit_test(*iornq,18)) {
/* Writing concatenation */
#line 23390 ""
	    i__3[0] = 1, a__1[0] = sq;
#line 23390 ""
	    i__3[1] = 4, a__1[1] = "qnat";
#line 23390 ""
	    s_cat(notexq, a__1, i__3, &c__2, (ftnlen)79);
#line 23391 ""
	    lnote = 5;
#line 23392 ""
	    ioff = 2;
#line 23393 ""
	    *iornq = bit_clear(*iornq,18);
#line 23394 ""
	    iclracc = 18;
#line 23395 ""
	} else {
/* Writing concatenation */
#line 23396 ""
	    i__3[0] = 1, a__1[0] = sq;
#line 23396 ""
	    i__3[1] = 5, a__1[1] = "qedit";
#line 23396 ""
	    s_cat(notexq, a__1, i__3, &c__2, (ftnlen)79);
#line 23397 ""
	    lnote = 6;
#line 23398 ""
	    ioff = 0;
#line 23399 ""
	}
#line 23400 ""
    } else if (bit_test(iornt,16)) {
/* Writing concatenation */
#line 23401 ""
	i__3[0] = 1, a__1[0] = sq;
#line 23401 ""
	i__3[1] = 6, a__1[1] = "esharp";
#line 23401 ""
	s_cat(notexq, a__1, i__3, &c__2, (ftnlen)79);
#line 23402 ""
	lnote = 7;
#line 23403 ""
	ioff = 2;
#line 23404 ""
    } else if (bit_test(iornt,17)) {
/* Writing concatenation */
#line 23405 ""
	i__3[0] = 1, a__1[0] = sq;
#line 23405 ""
	i__3[1] = 5, a__1[1] = "eflat";
#line 23405 ""
	s_cat(notexq, a__1, i__3, &c__2, (ftnlen)79);
#line 23406 ""
	lnote = 6;
#line 23407 ""
	ioff = 1;
#line 23408 ""
    } else if (bit_test(iornt,18)) {
/* Writing concatenation */
#line 23409 ""
	i__3[0] = 1, a__1[0] = sq;
#line 23409 ""
	i__3[1] = 4, a__1[1] = "enat";
#line 23409 ""
	s_cat(notexq, a__1, i__3, &c__2, (ftnlen)79);
#line 23410 ""
	lnote = 5;
#line 23411 ""
	ioff = 2;
#line 23412 ""
    } else if (bit_test(iornt,19)) {
/* Writing concatenation */
#line 23413 ""
	i__3[0] = 1, a__1[0] = sq;
#line 23413 ""
	i__3[1] = 3, a__1[1] = "usf";
#line 23413 ""
	s_cat(notexq, a__1, i__3, &c__2, (ftnlen)79);
#line 23414 ""
	lnote = 4;
#line 23415 ""
	ioff = -2;
#line 23416 ""
    } else if (bit_test(iornt,20)) {
/* Writing concatenation */
#line 23417 ""
	i__3[0] = 1, a__1[0] = sq;
#line 23417 ""
	i__3[1] = 4, a__1[1] = "usfz";
#line 23417 ""
	s_cat(notexq, a__1, i__3, &c__2, (ftnlen)79);
#line 23418 ""
	lnote = 5;
#line 23419 ""
	ioff = -2;
#line 23420 ""
    } else if (bit_test(iornt,29)) {
/* Writing concatenation */
#line 23421 ""
	i__3[0] = 1, a__1[0] = sq;
#line 23421 ""
	i__3[1] = 5, a__1[1] = "ccoda";
#line 23421 ""
	s_cat(notexq, a__1, i__3, &c__2, (ftnlen)79);
#line 23422 ""
	lnote = 6;
#line 23423 ""
    } else if (bit_test(iornt,30)) {
/* Writing concatenation */
#line 23424 ""
	i__3[0] = 1, a__1[0] = sq;
#line 23424 ""
	i__3[1] = 6, a__1[1] = "ssegno";
#line 23424 ""
	s_cat(notexq, a__1, i__3, &c__2, (ftnlen)79);
#line 23425 ""
	lnote = 7;
#line 23426 ""
    }
#line 23427 ""
    iudorn = 0;

/*  User-defined level shift of ornament from default? */

#line 23431 ""
    if (bit_test(*iornq,25)) {

/*  Find which (if any) element of kudorn has the shift. */

#line 23435 ""
	i__1 = comtrill_1.nudorn;
#line 23435 ""
	for (iudorn = 1; iudorn <= i__1; ++iudorn) {
#line 23436 ""
	    if (ibit < 21 || ibit == 29 || ibit == 30) {
#line 23437 ""
		ibitt = ibit;

/*  Could have oes, but not oe? or oes? */

#line 23441 ""
	    } else if (iclracc > 0) {

/*  Earlier cleared edit. accid, meaning it was oes? */

#line 23445 ""
		ibitt = iclracc + 6;
#line 23446 ""
	    } else {
#line 23447 ""
		ibitt = 21;
#line 23448 ""
	    }
#line 23449 ""
	    ibitt = *ip + (*ivx % 16 << 8) + (*nolev << 12) + (ibitt << 19);
#line 23450 ""
	    if (ibitt == (33554431 & comtrill_1.kudorn[iudorn - 1]) && *ivx ==
		     comivxudorn_1.ivxudorn[iudorn - 1]) {
#line 23450 ""
		goto L4;
#line 23450 ""
	    }
#line 23452 ""
/* L3: */
#line 23452 ""
	}

/*  Nothing shifted on this note; exit this if block */

#line 23456 ""
	iudorn = 0;
#line 23457 ""
	goto L5;
#line 23458 ""
L4:
#line 23459 ""
	ioffinc = (63 & lbit_shift(comtrill_1.kudorn[iudorn - 1], (ftnlen)-25)
		) - 32;
#line 23460 ""
	if (ibit == 19 && ioffinc < -7) {

/*  Convert usf to lsf.  The reason has to do with positioning being impossile */
/*  for some mysterious reason when you drop \usf below the staff */

/* Writing concatenation */
#line 23465 ""
	    i__3[0] = 1, a__1[0] = sq;
#line 23465 ""
	    i__3[1] = 3, a__1[1] = "lsf";
#line 23465 ""
	    s_cat(notexq, a__1, i__3, &c__2, (ftnlen)79);
#line 23466 ""
	    ioffinc += 6;
#line 23467 ""
	}
#line 23468 ""
	ioff += ioffinc;
#line 23469 ""
    }
#line 23470 ""
L5:

/*  Shift level to avoid slur.  Conditions are */
/*   1.  There is a slur */
/*   2.  No user-defined orn height shift (btest(iornq,25)) */
/*   3.  upslur (islhgt>0) */
/*   4.  ornament is not segno(4), ._)(11-13), down ferm(14) or "(" (0) Bin=30737 */
/*   5.  islhgt+3 >=  height already computed. */

#line 23479 ""
    if (! bit_test(*iornq,25) && *islhgt > 0 && (iornt & 30737) == 0) {
#line 23479 ""
	i__1 = *islhgt + 3;
#line 23479 ""
	ioff += i_dim(&i__1, &ihorn);
#line 23479 ""
    }
#line 23482 ""
    i__1 = ihorn + ioff;
#line 23482 ""
    notefq_(noteq, &lnoten, &i__1, ncm, (ftnlen)8);
#line 23483 ""
    if (lnoten == 1) {
#line 23483 ""
	addblank_(noteq, &lnoten, (ftnlen)8);
#line 23483 ""
    }
#line 23484 ""
    if ((iornt & 32896) > 0) {

/*  T-trill or trill w/o "tr" */

#line 23488 ""
	dotrill_(ivx, ip, &iornt, noteq, &lnoten, notexq, &lnote, (ftnlen)8, (
		ftnlen)79);
#line 23489 ""
    } else {
/* Writing concatenation */
#line 23490 ""
	i__3[0] = lnote, a__1[0] = notexq;
#line 23490 ""
	i__3[1] = lnoten, a__1[1] = noteq;
#line 23490 ""
	s_cat(notexq, a__1, i__3, &c__2, (ftnlen)79);
#line 23491 ""
	lnote += lnoten;
#line 23492 ""
    }
#line 23493 ""
    if (iudorn > 0) {
#line 23494 ""
	if (bit_test(comtrill_1.kudorn[iudorn - 1],31)) {

/*  Horizontal shift */

#line 23498 ""
	    lform = lfmt1_(&comtrill_1.ornhshft[iudorn - 1]);
#line 23499 ""
	    ici__1.icierr = 0;
#line 23499 ""
	    ici__1.icirnum = 1;
#line 23499 ""
	    ici__1.icirlen = lform;
#line 23499 ""
	    ici__1.iciunit = noteq;
/* Writing concatenation */
#line 23499 ""
	    i__4[0] = 2, a__2[0] = "(f";
#line 23499 ""
	    i__1 = lform + 48;
#line 23499 ""
	    chax_(ch__1, (ftnlen)1, &i__1);
#line 23499 ""
	    i__4[1] = 1, a__2[1] = ch__1;
#line 23499 ""
	    i__4[2] = 3, a__2[2] = ".1)";
#line 23499 ""
	    ici__1.icifmt = (s_cat(ch__2, a__2, i__4, &c__3, (ftnlen)6), 
		    ch__2);
#line 23499 ""
	    s_wsfi(&ici__1);
#line 23499 ""
	    do_fio(&c__1, (char *)&comtrill_1.ornhshft[iudorn - 1], (ftnlen)
		    sizeof(real));
#line 23499 ""
	    e_wsfi();
/* Writing concatenation */
#line 23501 ""
	    i__5[0] = 1, a__3[0] = sq;
#line 23501 ""
	    i__5[1] = 8, a__3[1] = "roffset{";
#line 23501 ""
	    i__5[2] = lform, a__3[2] = noteq;
#line 23501 ""
	    i__5[3] = 2, a__3[3] = "}{";
#line 23501 ""
	    i__5[4] = lnote, a__3[4] = notexq;
#line 23501 ""
	    i__5[5] = 1, a__3[5] = "}";
#line 23501 ""
	    s_cat(notexq, a__3, i__5, &c__6, (ftnlen)79);
#line 23503 ""
	    lnote = lnote + lform + 12;
#line 23504 ""
	    comtrill_1.ornhshft[iudorn - 1] = 0.f;
#line 23505 ""
	    comtrill_1.kudorn[iudorn - 1] = bit_clear(comtrill_1.kudorn[
		    iudorn - 1],31);
#line 23506 ""
	}
#line 23507 ""
    }

/*  Zero out the bit for ornament just dealt with. */

#line 23511 ""
    *iornq = bit_clear(*iornq,ibit);
#line 23512 ""
    if (*lout == 0) {
#line 23513 ""
	s_copy(outq, notexq, (ftnlen)79, lnote);
#line 23514 ""
    } else {
/* Writing concatenation */
#line 23515 ""
	i__3[0] = *lout, a__1[0] = outq;
#line 23515 ""
	i__3[1] = lnote, a__1[1] = notexq;
#line 23515 ""
	s_cat(outq, a__1, i__3, &c__2, (ftnlen)79);
#line 23516 ""
    }
#line 23517 ""
    *lout += lnote;

/*  Check bits 0-21, go back if any are still set */
/*  If bit 29 or 30 had been set, would have been used first time thru, */
/*    and you wouldn't use both coda and segno on same note */

#line 23523 ""
    if ((*iornq & 4194303) > 0) {
#line 23523 ""
	goto L2;
#line 23523 ""
    }
#line 23524 ""
    if (usehornb) {
#line 23524 ""
	++nornb[*ivx];
#line 23524 ""
    }
#line 23525 ""
    return 0;
} /* putorn_ */

/* Subroutine */ int putshft_(integer *ivx, logical *onoff, char *soutq, 
	integer *lsout, ftnlen soutq_len)
{
    /* System generated locals */
    address a__1[3], a__2[4];
    integer i__1[3], i__2, i__3[4];
    real r__1;
    char ch__1[1], ch__2[6], ch__3[88];
    icilist ici__1;

    /* Builtin functions */
    double r_sign(real *, real *);
    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
    integer s_wsfi(icilist *), do_fio(integer *, char *, ftnlen), e_wsfi(void)
	    ;

    /* Local variables */
    static char sq[1];
    extern /* Character */ VOID chax_(char *, ftnlen, integer *);
    static integer ifmt;
    static real xoff;
    extern /* Subroutine */ int addstr_(char *, integer *, char *, integer *, 
	    ftnlen, ftnlen);
    static char notexq[80];

#line 23533 ""
    chax_(ch__1, (ftnlen)1, &c__92);
#line 23533 ""
    *(unsigned char *)sq = *(unsigned char *)&ch__1[0];

/*  Start user-defined offsets X(...): or X(...)S */

#line 23537 ""
    if (*onoff) {
#line 23537 ""
	++comudsp_1.nudoff[*ivx - 1];
#line 23537 ""
    }

/*  Xoff is in pts.  Round off to nearest .1.  Will use at end of shift. */

#line 23541 ""
    xoff = comudsp_1.udoff[*ivx + comudsp_1.nudoff[*ivx - 1] * 24 - 25];
#line 23542 ""
    r__1 = (integer) (dabs(xoff) * 10.f + .5f) / 10.f;
#line 23542 ""
    xoff = r_sign(&r__1, &xoff);
#line 23543 ""
    if (! (*onoff)) {
#line 23543 ""
	xoff = -xoff;
#line 23543 ""
    }
#line 23544 ""
    if (xoff < -9.95f) {
#line 23545 ""
	ifmt = 5;
#line 23546 ""
    } else if (xoff < -.95f || xoff > 9.95f) {
#line 23547 ""
	ifmt = 4;
#line 23548 ""
    } else {
#line 23549 ""
	ifmt = 3;
#line 23550 ""
    }
#line 23551 ""
    ici__1.icierr = 0;
#line 23551 ""
    ici__1.icirnum = 1;
#line 23551 ""
    ici__1.icirlen = 80;
#line 23551 ""
    ici__1.iciunit = notexq;
/* Writing concatenation */
#line 23551 ""
    i__1[0] = 2, a__1[0] = "(f";
#line 23551 ""
    i__2 = ifmt + 48;
#line 23551 ""
    chax_(ch__1, (ftnlen)1, &i__2);
#line 23551 ""
    i__1[1] = 1, a__1[1] = ch__1;
#line 23551 ""
    i__1[2] = 3, a__1[2] = ".1)";
#line 23551 ""
    ici__1.icifmt = (s_cat(ch__2, a__1, i__1, &c__3, (ftnlen)6), ch__2);
#line 23551 ""
    s_wsfi(&ici__1);
#line 23551 ""
    do_fio(&c__1, (char *)&xoff, (ftnlen)sizeof(real));
#line 23551 ""
    e_wsfi();
/* Writing concatenation */
#line 23552 ""
    i__3[0] = 1, a__2[0] = sq;
#line 23552 ""
    i__3[1] = 4, a__2[1] = "off{";
#line 23552 ""
    i__3[2] = ifmt, a__2[2] = notexq;
#line 23552 ""
    i__3[3] = 3, a__2[3] = "pt}";
#line 23552 ""
    s_cat(ch__3, a__2, i__3, &c__4, (ftnlen)88);
#line 23552 ""
    i__2 = ifmt + 8;
#line 23552 ""
    addstr_(ch__3, &i__2, soutq, lsout, ifmt + 8, (ftnlen)80);
#line 23554 ""
    return 0;
} /* putshft_ */

/* Subroutine */ int puttitle_(integer *inhnoh, real *xnsttop, real *etatop, 
	char *sq, real *etait, real *etatc, real *etacs1, integer *nv, 
	logical *vshrink, char *sepsymq, ftnlen sq_len, ftnlen sepsymq_len)
{
    /* System generated locals */
    address a__1[2], a__2[3], a__3[3], a__4[4];
    integer i__1[2], i__2, i__3[3], i__4, i__5[3], i__6[4];
    real r__1;
    char ch__1[8], ch__2[1], ch__3[10], ch__4[148], ch__5[129], ch__6[133];
    icilist ici__1;

    /* Builtin functions */
    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
    double r_lg10(real *);
    integer s_wsfi(icilist *), do_fio(integer *, char *, ftnlen), e_wsfi(void)
	    , s_wsfe(cilist *), e_wsfe(void);
    /* Subroutine */ int s_copy(char *, char *, ftnlen, ftnlen);

    /* Local variables */
    extern /* Subroutine */ int writflot_(real *, char *, integer *, ftnlen);
    static integer iv, lcq, ndig;
    extern /* Character */ VOID chax_(char *, ftnlen, integer *);
    static real xcsil, xtcil, vskil, xitil, glueil;
    extern integer lenstr_(char *, integer *, ftnlen);
    extern /* Subroutine */ int printl_(char *, ftnlen);
    static char notexq[127];
    static integer lenline;

    /* Fortran I/O blocks */
    static cilist io___1707 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1710 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1713 = { 0, 11, 0, "(a)", 0 };



/*  Called once per page, at top of page!  If vshrink, only called for p.1. */
/*  Actual titles only allowed on p.1. (set by headlog). */
/*  3/18/01:  The above comment is probably bogus...can use Tt on later pages. */

#line 23573 ""
    /* Parameter adjustments */
#line 23573 ""
    --sepsymq;
#line 23573 ""

#line 23573 ""
    /* Function Body */
/* Writing concatenation */
#line 23573 ""
    i__1[0] = 1, a__1[0] = sq;
#line 23573 ""
    i__1[1] = 6, a__1[1] = "znotes";
#line 23573 ""
    s_cat(notexq, a__1, i__1, &c__2, (ftnlen)127);
#line 23574 ""
    lenline = 7;
#line 23575 ""
    i__2 = *nv - 1;
#line 23575 ""
    for (iv = 1; iv <= i__2; ++iv) {
/* Writing concatenation */
#line 23576 ""
	i__1[0] = lenline, a__1[0] = notexq;
#line 23576 ""
	i__1[1] = 1, a__1[1] = sepsymq + iv;
#line 23576 ""
	s_cat(notexq, a__1, i__1, &c__2, (ftnlen)127);
#line 23577 ""
	++lenline;
#line 23578 ""
/* L22: */
#line 23578 ""
    }
/* Writing concatenation */
#line 23579 ""
    i__3[0] = lenline, a__2[0] = notexq;
#line 23579 ""
    i__3[1] = 1, a__2[1] = sq;
#line 23579 ""
    i__3[2] = 10, a__2[2] = "zcharnote{";
#line 23579 ""
    s_cat(notexq, a__2, i__3, &c__3, (ftnlen)127);
#line 23580 ""
    lenline += 11;
#line 23581 ""
    if (! comtitl_1.headlog) {
#line 23582 ""
	comtitl_1.inhead = *inhnoh;
#line 23583 ""
    }
#line 23584 ""
    if (*vshrink && comlast_1.usevshrink) {
#line 23585 ""
	comtitl_1.inhead = 16;
#line 23586 ""
    }
#line 23587 ""
    r__1 = comtitl_1.inhead + .01f;
#line 23587 ""
    ndig = (integer) r_lg10(&r__1) + 1;
#line 23588 ""
    i__2 = lenline;
#line 23588 ""
    ici__1.icierr = 0;
#line 23588 ""
    ici__1.icirnum = 1;
#line 23588 ""
    ici__1.icirlen = lenline + ndig + 10 - i__2;
#line 23588 ""
    ici__1.iciunit = notexq + i__2;
/* Writing concatenation */
#line 23588 ""
    i__3[0] = 2, a__2[0] = "(i";
#line 23588 ""
    i__4 = ndig + 48;
#line 23588 ""
    chax_(ch__2, (ftnlen)1, &i__4);
#line 23588 ""
    i__3[1] = 1, a__2[1] = ch__2;
#line 23588 ""
    i__3[2] = 5, a__2[2] = ",a10)";
#line 23588 ""
    ici__1.icifmt = (s_cat(ch__1, a__2, i__3, &c__3, (ftnlen)8), ch__1);
#line 23588 ""
    s_wsfi(&ici__1);
#line 23588 ""
    do_fio(&c__1, (char *)&comtitl_1.inhead, (ftnlen)sizeof(integer));
/* Writing concatenation */
#line 23588 ""
    i__5[0] = 2, a__3[0] = "}{";
#line 23588 ""
    i__5[1] = 1, a__3[1] = sq;
#line 23588 ""
    i__5[2] = 7, a__3[2] = "titles{";
#line 23588 ""
    s_cat(ch__3, a__3, i__5, &c__3, (ftnlen)10);
#line 23588 ""
    do_fio(&c__1, ch__3, (ftnlen)10);
#line 23588 ""
    e_wsfi();
#line 23590 ""
    lenline = lenline + ndig + 10;

/*  Vertical skip at top of page (\Il) = etatop*glueil.  Needed whether */
/*    headers are present or not. */

#line 23595 ""
    glueil = *xnsttop / *etatop;
#line 23596 ""
    vskil = *etatop * glueil;
#line 23597 ""
    if (*vshrink && comlast_1.usevshrink) {
#line 23597 ""
	vskil = 2.f;
#line 23597 ""
    }
#line 23598 ""
    writflot_(&vskil, notexq, &lenline, (ftnlen)127);
#line 23599 ""
    if (! comtitl_1.headlog) {
#line 23600 ""
	if (comlast_1.islast) {
#line 23600 ""
	    s_wsfe(&io___1707);
/* Writing concatenation */
#line 23600 ""
	    i__6[0] = lenline, a__4[0] = notexq;
#line 23600 ""
	    i__6[1] = 17, a__4[1] = "}{}{0}{}{0}{}{0}}";
#line 23600 ""
	    i__6[2] = 1, a__4[2] = sq;
#line 23600 ""
	    i__6[3] = 3, a__4[3] = "en%";
#line 23600 ""
	    s_cat(ch__4, a__4, i__6, &c__4, (ftnlen)148);
#line 23600 ""
	    do_fio(&c__1, ch__4, lenline + 21);
#line 23600 ""
	    e_wsfe();
#line 23600 ""
	}
#line 23602 ""
    } else {
/* Writing concatenation */
#line 23603 ""
	i__1[0] = lenline, a__1[0] = notexq;
#line 23603 ""
	i__1[1] = 2, a__1[1] = "}{";
#line 23603 ""
	s_cat(notexq, a__1, i__1, &c__2, (ftnlen)127);
#line 23604 ""
	lenline += 2;
#line 23605 ""
	lcq = lenstr_(comtitl_1.instrq, &c__120, (ftnlen)120);
#line 23606 ""
	if (lcq > 0) {
#line 23607 ""
	    xitil = *etait * glueil;
#line 23608 ""
	    if (*vshrink && comlast_1.usevshrink) {
#line 23608 ""
		xitil = 2.f;
#line 23608 ""
	    }
/* Writing concatenation */
#line 23609 ""
	    i__3[0] = lenline, a__2[0] = notexq;
#line 23609 ""
	    i__3[1] = lcq, a__2[1] = comtitl_1.instrq;
#line 23609 ""
	    i__3[2] = 2, a__2[2] = "}{";
#line 23609 ""
	    s_cat(notexq, a__2, i__3, &c__3, (ftnlen)127);

/* Null out instrument once used */

#line 23613 ""
	    s_copy(comtitl_1.instrq, " ", (ftnlen)120, (ftnlen)1);
#line 23614 ""
	    lenline = lenline + lcq + 2;
#line 23615 ""
	    writflot_(&xitil, notexq, &lenline, (ftnlen)127);
#line 23616 ""
	} else {
/* Writing concatenation */
#line 23617 ""
	    i__1[0] = lenline, a__1[0] = notexq;
#line 23617 ""
	    i__1[1] = 3, a__1[1] = "}{0";
#line 23617 ""
	    s_cat(notexq, a__1, i__1, &c__2, (ftnlen)127);
#line 23618 ""
	    lenline += 3;
#line 23619 ""
	}
#line 23620 ""
	if (comlast_1.islast) {
#line 23620 ""
	    s_wsfe(&io___1710);
/* Writing concatenation */
#line 23620 ""
	    i__1[0] = lenline, a__1[0] = notexq;
#line 23620 ""
	    i__1[1] = 2, a__1[1] = "}%";
#line 23620 ""
	    s_cat(ch__5, a__1, i__1, &c__2, (ftnlen)129);
#line 23620 ""
	    do_fio(&c__1, ch__5, lenline + 2);
#line 23620 ""
	    e_wsfe();
#line 23620 ""
	}
#line 23621 ""
	s_copy(notexq, "{", (ftnlen)127, (ftnlen)1);
#line 23622 ""
	lenline = 1;
#line 23623 ""
	lcq = lenstr_(comtitl_1.titleq, &c__120, (ftnlen)120);
#line 23624 ""
	if (lcq > 0) {
/* Writing concatenation */
#line 23625 ""
	    i__1[0] = lenline, a__1[0] = notexq;
#line 23625 ""
	    i__1[1] = lcq, a__1[1] = comtitl_1.titleq;
#line 23625 ""
	    s_cat(notexq, a__1, i__1, &c__2, (ftnlen)127);
#line 23626 ""
	    lenline += lcq;
#line 23627 ""
	} else {
#line 23628 ""
	    printl_(" ", (ftnlen)1);
#line 23629 ""
	    printl_("WARNING", (ftnlen)7);
#line 23630 ""
	    printl_("  In a title block, you have specified instrument and/or"
		    , (ftnlen)56);
#line 23632 ""
	    printl_("  composer but no title for the piece.", (ftnlen)38);
#line 23634 ""
	}
/* Writing concatenation */
#line 23635 ""
	i__1[0] = lenline, a__1[0] = notexq;
#line 23635 ""
	i__1[1] = 2, a__1[1] = "}{";
#line 23635 ""
	s_cat(notexq, a__1, i__1, &c__2, (ftnlen)127);
#line 23636 ""
	lenline += 2;
#line 23637 ""
	xtcil = *etatc * glueil;
#line 23638 ""
	lcq = lenstr_(comtitl_1.compoq, &c__120, (ftnlen)120);
#line 23639 ""
	if (lcq == 0) {
#line 23639 ""
	    xtcil *= 2;
#line 23639 ""
	}
#line 23640 ""
	if (*vshrink && comlast_1.usevshrink) {
#line 23640 ""
	    xtcil = 2.f;
#line 23640 ""
	}
#line 23641 ""
	writflot_(&xtcil, notexq, &lenline, (ftnlen)127);
/* Writing concatenation */
#line 23642 ""
	i__1[0] = lenline, a__1[0] = notexq;
#line 23642 ""
	i__1[1] = 2, a__1[1] = "}{";
#line 23642 ""
	s_cat(notexq, a__1, i__1, &c__2, (ftnlen)127);
#line 23643 ""
	lenline += 2;
#line 23644 ""
	if (lcq > 0) {
/* Writing concatenation */
#line 23645 ""
	    i__3[0] = lenline, a__2[0] = notexq;
#line 23645 ""
	    i__3[1] = lcq, a__2[1] = comtitl_1.compoq;
#line 23645 ""
	    i__3[2] = 2, a__2[2] = "}{";
#line 23645 ""
	    s_cat(notexq, a__2, i__3, &c__3, (ftnlen)127);
#line 23646 ""
	    lenline = lenline + 2 + lcq;

/*  Null out compoq so it does not get written later */

#line 23650 ""
	    s_copy(comtitl_1.compoq, " ", (ftnlen)120, (ftnlen)1);
#line 23651 ""
	    xcsil = *etacs1 * glueil;
#line 23652 ""
	    if (*vshrink && comlast_1.usevshrink) {
#line 23652 ""
		xcsil = 2.f;
#line 23652 ""
	    }
#line 23653 ""
	    writflot_(&xcsil, notexq, &lenline, (ftnlen)127);
#line 23654 ""
	} else {
/* Writing concatenation */
#line 23655 ""
	    i__1[0] = lenline, a__1[0] = notexq;
#line 23655 ""
	    i__1[1] = 3, a__1[1] = "}{0";
#line 23655 ""
	    s_cat(notexq, a__1, i__1, &c__2, (ftnlen)127);
#line 23656 ""
	    lenline += 3;
#line 23657 ""
	}
#line 23658 ""
	if (comlast_1.islast) {
#line 23658 ""
	    s_wsfe(&io___1713);
/* Writing concatenation */
#line 23658 ""
	    i__6[0] = lenline, a__4[0] = notexq;
#line 23658 ""
	    i__6[1] = 2, a__4[1] = "}}";
#line 23658 ""
	    i__6[2] = 1, a__4[2] = sq;
#line 23658 ""
	    i__6[3] = 3, a__4[3] = "en%";
#line 23658 ""
	    s_cat(ch__6, a__4, i__6, &c__4, (ftnlen)133);
#line 23658 ""
	    do_fio(&c__1, ch__6, lenline + 6);
#line 23658 ""
	    e_wsfe();
#line 23658 ""
	}
#line 23659 ""
	comtitl_1.headlog = FALSE_;
#line 23660 ""
    }
#line 23661 ""
    return 0;
} /* puttitle_ */

/* Subroutine */ int putxtn_(integer *ntupv, integer *iflop, integer *multb, 
	integer *iud, real *wheadpt, real *poenom, integer *nolev1, integer *
	islope, real *slfac, real *xnlmid, integer *islur, integer *lnote, 
	char *notexq, integer *ncmid, integer *nlnum, real *eloff, integer *
	iup, integer *irest, integer *mult, logical *usexnumt, ftnlen 
	notexq_len)
{
    /* System generated locals */
    address a__1[2], a__2[3];
    integer i__1[2], i__2[3], i__3;
    real r__1;
    char ch__1[1];
    icilist ici__1;

    /* Builtin functions */
    integer i_nint(real *), lbit_shift(integer, integer);
    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
    integer s_wsfi(icilist *), do_fio(integer *, char *, ftnlen), e_wsfi(void)
	    ;

    /* Local variables */
    extern integer igetbits_(integer *, integer *, integer *);
    extern /* Character */ VOID chax_(char *, ftnlen, integer *);
    static char noteq[8];
    extern /* Subroutine */ int notefq_(char *, integer *, integer *, integer 
	    *, ftnlen);
    static integer lnoten, istrtn;


/*  Places digit for xtuplet. */

#line 23673 ""
    if (*iflop != 0 && *multb > 0) {

/* Number goes on beam side, move R/L by .5 wheadpt for upper/lower */

#line 23677 ""
	*eloff -= *iud * .5f * *wheadpt / *poenom;

/*  Number goes on beam side, must use beam parameters to set pos'n */

#line 23681 ""
	*nlnum = *nolev1 + *islope / *slfac * *eloff + *iup * (*multb + 8);
#line 23682 ""
	if (*multb >= 2) {
#line 23682 ""
	    *nlnum += *iup;
#line 23682 ""
	}
#line 23683 ""
    } else {
#line 23684 ""
	r__1 = *xnlmid - 1 + *iud * 3 + *iflop * 11;
#line 23684 ""
	*nlnum = i_nint(&r__1);
#line 23685 ""
    }
#line 23686 ""
    if (! bit_test(*islur,31)) {

/*  Only print number when wanted.  First check vert, horiz offset */

#line 23690 ""
	if (bit_test(*irest,1)) {
#line 23690 ""
	    *nlnum = *nlnum + igetbits_(mult, &c__8, &c__16) - 64;
#line 23690 ""
	}
#line 23691 ""
	if (bit_test(*irest,7)) {
#line 23691 ""
	    *eloff += ((31 & lbit_shift(*irest, (ftnlen)-9)) * .1f - 1.6f) * *
		    wheadpt / *poenom;
#line 23691 ""
	}
#line 23693 ""
	if (! (*usexnumt)) {
/* Writing concatenation */
#line 23694 ""
	    chax_(ch__1, (ftnlen)1, &c__92);
#line 23694 ""
	    i__1[0] = 1, a__1[0] = ch__1;
#line 23694 ""
	    i__1[1] = 5, a__1[1] = "xnum{";
#line 23694 ""
	    s_cat(notexq, a__1, i__1, &c__2, (ftnlen)79);
#line 23695 ""
	    *lnote = 10;
#line 23696 ""
	    istrtn = 7;
#line 23697 ""
	} else {
/* Writing concatenation */
#line 23698 ""
	    chax_(ch__1, (ftnlen)1, &c__92);
#line 23698 ""
	    i__1[0] = 1, a__1[0] = ch__1;
#line 23698 ""
	    i__1[1] = 6, a__1[1] = "xnumt{";
#line 23698 ""
	    s_cat(notexq, a__1, i__1, &c__2, (ftnlen)79);
#line 23699 ""
	    *lnote = 11;
#line 23700 ""
	    istrtn = 8;
#line 23701 ""
	}
#line 23702 ""
	if (*eloff < .995f) {
#line 23703 ""
	    ici__1.icierr = 0;
#line 23703 ""
	    ici__1.icirnum = 1;
#line 23703 ""
	    ici__1.icirlen = 4;
#line 23703 ""
	    ici__1.iciunit = notexq + (istrtn - 1);
#line 23703 ""
	    ici__1.icifmt = "(i1,f3.2)";
#line 23703 ""
	    s_wsfi(&ici__1);
#line 23703 ""
	    do_fio(&c__1, (char *)&c__0, (ftnlen)sizeof(integer));
#line 23703 ""
	    do_fio(&c__1, (char *)&(*eloff), (ftnlen)sizeof(real));
#line 23703 ""
	    e_wsfi();
#line 23704 ""
	} else if (*eloff < 9.995f) {
#line 23705 ""
	    ici__1.icierr = 0;
#line 23705 ""
	    ici__1.icirnum = 1;
#line 23705 ""
	    ici__1.icirlen = 4;
#line 23705 ""
	    ici__1.iciunit = notexq + (istrtn - 1);
#line 23705 ""
	    ici__1.icifmt = "(f4.2)";
#line 23705 ""
	    s_wsfi(&ici__1);
#line 23705 ""
	    do_fio(&c__1, (char *)&(*eloff), (ftnlen)sizeof(real));
#line 23705 ""
	    e_wsfi();
#line 23706 ""
	} else {
#line 23707 ""
	    ici__1.icierr = 0;
#line 23707 ""
	    ici__1.icirnum = 1;
#line 23707 ""
	    ici__1.icirlen = 5;
#line 23707 ""
	    ici__1.iciunit = notexq + (istrtn - 1);
#line 23707 ""
	    ici__1.icifmt = "(f5.2)";
#line 23707 ""
	    s_wsfi(&ici__1);
#line 23707 ""
	    do_fio(&c__1, (char *)&(*eloff), (ftnlen)sizeof(real));
#line 23707 ""
	    e_wsfi();
#line 23708 ""
	    ++(*lnote);
#line 23709 ""
	}
#line 23710 ""
	notefq_(noteq, &lnoten, nlnum, ncmid, (ftnlen)8);
/* Writing concatenation */
#line 23711 ""
	i__2[0] = *lnote, a__2[0] = notexq;
#line 23711 ""
	i__2[1] = 1, a__2[1] = "}";
#line 23711 ""
	i__2[2] = lnoten, a__2[2] = noteq;
#line 23711 ""
	s_cat(notexq, a__2, i__2, &c__3, (ftnlen)79);
#line 23712 ""
	*lnote = *lnote + 1 + lnoten;
#line 23713 ""
	if (*ntupv < 10) {
#line 23714 ""
	    i__3 = *lnote;
#line 23714 ""
	    ici__1.icierr = 0;
#line 23714 ""
	    ici__1.icirnum = 1;
#line 23714 ""
	    ici__1.icirlen = *lnote + 1 - i__3;
#line 23714 ""
	    ici__1.iciunit = notexq + i__3;
#line 23714 ""
	    ici__1.icifmt = "(i1)";
#line 23714 ""
	    s_wsfi(&ici__1);
#line 23714 ""
	    do_fio(&c__1, (char *)&(*ntupv), (ftnlen)sizeof(integer));
#line 23714 ""
	    e_wsfi();
#line 23715 ""
	    ++(*lnote);
#line 23716 ""
	} else {
/* Writing concatenation */
#line 23717 ""
	    i__1[0] = *lnote, a__1[0] = notexq;
#line 23717 ""
	    i__1[1] = 1, a__1[1] = "{";
#line 23717 ""
	    s_cat(notexq, a__1, i__1, &c__2, (ftnlen)79);
#line 23718 ""
	    i__3 = *lnote + 1;
#line 23718 ""
	    ici__1.icierr = 0;
#line 23718 ""
	    ici__1.icirnum = 1;
#line 23718 ""
	    ici__1.icirlen = *lnote + 3 - i__3;
#line 23718 ""
	    ici__1.iciunit = notexq + i__3;
#line 23718 ""
	    ici__1.icifmt = "(i2)";
#line 23718 ""
	    s_wsfi(&ici__1);
#line 23718 ""
	    do_fio(&c__1, (char *)&(*ntupv), (ftnlen)sizeof(integer));
#line 23718 ""
	    e_wsfi();
/* Writing concatenation */
#line 23719 ""
	    i__1[0] = *lnote + 3, a__1[0] = notexq;
#line 23719 ""
	    i__1[1] = 1, a__1[1] = "}";
#line 23719 ""
	    s_cat(notexq, a__1, i__1, &c__2, (ftnlen)79);
#line 23720 ""
	    *lnote += 4;
#line 23721 ""
	}
#line 23722 ""
    }
#line 23723 ""
    return 0;
} /* putxtn_ */

/* Subroutine */ int read10_(char *string, logical *lastchar, ftnlen 
	string_len)
{
    /* Builtin functions */
    /* Subroutine */ int s_copy(char *, char *, ftnlen, ftnlen);

    /* Local variables */
    static integer ip1, ip2;
    extern /* Subroutine */ int getbuf_(char *, ftnlen);

#line 23737 ""
    if (! commac_1.mplay) {
#line 23738 ""
	if (inbuff_1.ilbuf > inbuff_1.nlbuf) {
#line 23738 ""
	    goto L999;
#line 23738 ""
	}
#line 23739 ""
	getbuf_(string, string_len);
#line 23740 ""
	return 0;
#line 23741 ""
L999:
#line 23741 ""
	*lastchar = TRUE_;
#line 23742 ""
	return 0;
#line 23743 ""
    } else {

/*  Play a macro.  Set pointer to first character needed in buffer */

#line 23747 ""
	if (c1ommac_1.ilmac == c1ommac_1.il1mac[commac_1.macnum - 1]) {

/*  Getting first line of macro */

#line 23751 ""
	    ip1 = c1ommac_1.ip1mac[commac_1.macnum - 1];
#line 23752 ""
	    c1ommac_1.iplmac = ip1 - c1ommac_1.ic1mac[commac_1.macnum - 1];
#line 23753 ""
	} else if (c1ommac_1.ilmac <= c1ommac_1.il2mac[commac_1.macnum - 1]) {

/*  Beyond first line of macro.  Advance line-start pointer. */

#line 23757 ""
	    c1ommac_1.iplmac += inbuff_1.lbuf[c1ommac_1.ilmac - 2];
#line 23758 ""
	    ip1 = c1ommac_1.iplmac + 1;
#line 23759 ""
	} else {

/*  Beyond last line of macro.  Terminate it! */

#line 23763 ""
	    commac_1.mplay = FALSE_;
#line 23764 ""
	    commac_1.endmac = TRUE_;
#line 23765 ""
	    return 0;
#line 23766 ""
	}
#line 23767 ""
	if (c1ommac_1.ilmac == c1ommac_1.il2mac[commac_1.macnum - 1]) {

/*  Getting last line of macro. */

#line 23771 ""
	    ip2 = c1ommac_1.ip2mac[commac_1.macnum - 1];
#line 23772 ""
	} else {

/*  Getting line before last line of macro. */

#line 23776 ""
	    ip2 = c1ommac_1.iplmac + inbuff_1.lbuf[c1ommac_1.ilmac - 1];
#line 23777 ""
	}
#line 23778 ""
	if (ip2 >= ip1) {
#line 23779 ""
	    s_copy(string, inbuff_1.bufq + (ip1 - 1), string_len, ip2 - (ip1 
		    - 1));
#line 23780 ""
	} else {

/*  Kluge for when macro start is on a line by itself */

#line 23784 ""
	    s_copy(string, " ", string_len, (ftnlen)1);
#line 23785 ""
	}
#line 23786 ""
	++c1ommac_1.ilmac;
#line 23787 ""
	return 0;
#line 23788 ""
    }
#line 23789 ""
    return 0;
} /* read10_ */

doublereal readin_(char *lineq, integer *iccount, integer *nline, ftnlen 
	lineq_len)
{
    /* System generated locals */
    address a__1[3];
    integer i__1[3];
    real ret_val;
    char ch__1[27], ch__2[6], ch__3[1];
    icilist ici__1;

    /* Builtin functions */
    integer i_indx(char *, char *, ftnlen, ftnlen), s_wsle(cilist *);
    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
    integer do_lio(integer *, integer *, char *, ftnlen), e_wsle(void), 
	    s_rsfi(icilist *), do_fio(integer *, char *, ftnlen), e_rsfi(void)
	    ;

    /* Local variables */
    static integer i1, i2, icf;
    extern /* Character */ VOID chax_(char *, ftnlen, integer *);
    static char durq[1];
    extern /* Subroutine */ int stop1_(void), getbuf_(char *, ftnlen), 
	    getchar_(char *, integer *, char *, ftnlen, ftnlen);

    /* Fortran I/O blocks */
    static cilist io___1722 = { 0, 6, 0, 0, 0 };



/*  Reads a piece of setup data from file lineq, gets a new lineq from */
/*  file 10 (jobname.pmx) and increments nline if needed,  passes over */
/*  comment lines */

#line 23798 ""
L4:
#line 23798 ""
    if (*iccount == 128) {
#line 23799 ""
L1:
#line 23799 ""
	getbuf_(lineq, (ftnlen)128);
#line 23800 ""
	++(*nline);
#line 23801 ""
	if (*(unsigned char *)lineq == '%') {
#line 23801 ""
	    goto L1;
#line 23801 ""
	}
#line 23802 ""
	*iccount = 0;
#line 23803 ""
    }
#line 23804 ""
    ++(*iccount);

/*  Find next non-blank or end of line */

#line 23808 ""
    for (*iccount = *iccount; *iccount <= 127; ++(*iccount)) {
#line 23809 ""
	if (*(unsigned char *)&lineq[*iccount - 1] != ' ') {
#line 23809 ""
	    goto L3;
#line 23809 ""
	}
#line 23810 ""
/* L2: */
#line 23810 ""
    }

/*  If here, need to get a new line */

#line 23814 ""
    *iccount = 128;
#line 23815 ""
    goto L4;
#line 23816 ""
L3:

/*  iccount now points to start of number to read */

#line 23820 ""
    i1 = *iccount;
#line 23821 ""
L5:
#line 23821 ""
    getchar_(lineq, iccount, durq, (ftnlen)128, (ftnlen)1);

/*  Remember that getchar increments iccount, then reads a character. */

#line 23825 ""
    if (i_indx("0123456789.-", durq, (ftnlen)12, (ftnlen)1) > 0) {
#line 23825 ""
	goto L5;
#line 23825 ""
    }
#line 23826 ""
    i2 = *iccount - 1;
#line 23827 ""
    if (i2 < i1) {
#line 23828 ""
	s_wsle(&io___1722);
/* Writing concatenation */
#line 23828 ""
	i__1[0] = 7, a__1[0] = "Found \"";
#line 23828 ""
	i__1[1] = 1, a__1[1] = durq;
#line 23828 ""
	i__1[2] = 19, a__1[2] = "\" instead of number";
#line 23828 ""
	s_cat(ch__1, a__1, i__1, &c__3, (ftnlen)27);
#line 23828 ""
	do_lio(&c__9, &c__1, ch__1, (ftnlen)27);
#line 23828 ""
	e_wsle();
#line 23829 ""
	stop1_();
#line 23830 ""
    }
#line 23831 ""
    icf = i2 - i1 + 49;
#line 23832 ""
    ici__1.icierr = 0;
#line 23832 ""
    ici__1.iciend = 0;
#line 23832 ""
    ici__1.icirnum = 1;
#line 23832 ""
    ici__1.icirlen = i2 - (i1 - 1);
#line 23832 ""
    ici__1.iciunit = lineq + (i1 - 1);
/* Writing concatenation */
#line 23832 ""
    i__1[0] = 2, a__1[0] = "(f";
#line 23832 ""
    chax_(ch__3, (ftnlen)1, &icf);
#line 23832 ""
    i__1[1] = 1, a__1[1] = ch__3;
#line 23832 ""
    i__1[2] = 3, a__1[2] = ".0)";
#line 23832 ""
    ici__1.icifmt = (s_cat(ch__2, a__1, i__1, &c__3, (ftnlen)6), ch__2);
#line 23832 ""
    s_rsfi(&ici__1);
#line 23832 ""
    do_fio(&c__1, (char *)&ret_val, (ftnlen)sizeof(real));
#line 23832 ""
    e_rsfi();
#line 23833 ""
    return ret_val;
} /* readin_ */

/* Subroutine */ int readmeter_(char *lineq, integer *iccount, integer *
	mtrnum, integer *mtrden, ftnlen lineq_len)
{
    /* System generated locals */
    address a__1[3];
    integer i__1, i__2[3];
    char ch__1[1], ch__2[4];
    icilist ici__1;

    /* Builtin functions */
    integer i_indx(char *, char *, ftnlen, ftnlen);
    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
    integer s_rsfi(icilist *), do_fio(integer *, char *, ftnlen), e_rsfi(void)
	    ;

    /* Local variables */
    static integer ns;
    extern /* Character */ VOID chax_(char *, ftnlen, integer *);
    static char durq[1];
    extern /* Subroutine */ int getchar_(char *, integer *, char *, ftnlen, 
	    ftnlen);

#line 23838 ""
    i__1 = *iccount;
#line 23838 ""
    chax_(ch__1, (ftnlen)1, &c__47);
#line 23838 ""
    if (i_indx(lineq + i__1, ch__1, *iccount + 3 - i__1, (ftnlen)1) == 0) {

/*  No slashes, so use old method */

#line 23842 ""
	getchar_(lineq, iccount, durq, (ftnlen)128, (ftnlen)1);
#line 23843 ""
	if (*(unsigned char *)durq == '-') {

/*  Negative numerator is used only to printed; signals vertical slash */

#line 23847 ""
	    getchar_(lineq, iccount, durq, (ftnlen)128, (ftnlen)1);
#line 23848 ""
	    *mtrnum = -(*(unsigned char *)durq - 48);
#line 23849 ""
	} else if (*(unsigned char *)durq == 'o') {

/*  Numerator is EXACTLY 1 */

#line 23853 ""
	    *mtrnum = 1;
#line 23854 ""
	} else {
#line 23855 ""
	    *mtrnum = *(unsigned char *)durq - 48;
#line 23856 ""
	    if (*mtrnum == 1) {

/*  Numerator is >9 */

#line 23860 ""
		getchar_(lineq, iccount, durq, (ftnlen)128, (ftnlen)1);
#line 23861 ""
		*mtrnum = *(unsigned char *)durq - 38;
#line 23862 ""
	    }
#line 23863 ""
	}
#line 23864 ""
	getchar_(lineq, iccount, durq, (ftnlen)128, (ftnlen)1);
#line 23865 ""
	if (*(unsigned char *)durq == 'o') {
#line 23866 ""
	    *mtrden = 1;
#line 23867 ""
	} else {
#line 23868 ""
	    *mtrden = *(unsigned char *)durq - 48;
#line 23869 ""
	    if (*mtrden == 1) {
#line 23870 ""
		getchar_(lineq, iccount, durq, (ftnlen)128, (ftnlen)1);
#line 23871 ""
		*mtrden = *(unsigned char *)durq - 38;
#line 23872 ""
	    }
#line 23873 ""
	}
#line 23874 ""
    } else {

/*  Expect the form m[n1]/[n2]/[n3]/[n4] . Advance iccount by one from '/' or 'm' */

#line 23878 ""
	++(*iccount);
#line 23879 ""
	chax_(ch__1, (ftnlen)1, &c__47);
#line 23879 ""
	ns = i_indx(lineq + (*iccount - 1), ch__1, 128 - (*iccount - 1), (
		ftnlen)1);
#line 23880 ""
	ici__1.icierr = 0;
#line 23880 ""
	ici__1.iciend = 0;
#line 23880 ""
	ici__1.icirnum = 1;
#line 23880 ""
	ici__1.icirlen = *iccount + ns - 2 - (*iccount - 1);
#line 23880 ""
	ici__1.iciunit = lineq + (*iccount - 1);
/* Writing concatenation */
#line 23880 ""
	i__2[0] = 2, a__1[0] = "(i";
#line 23880 ""
	i__1 = ns + 47;
#line 23880 ""
	chax_(ch__1, (ftnlen)1, &i__1);
#line 23880 ""
	i__2[1] = 1, a__1[1] = ch__1;
#line 23880 ""
	i__2[2] = 1, a__1[2] = ")";
#line 23880 ""
	ici__1.icifmt = (s_cat(ch__2, a__1, i__2, &c__3, (ftnlen)4), ch__2);
#line 23880 ""
	s_rsfi(&ici__1);
#line 23880 ""
	do_fio(&c__1, (char *)&(*mtrnum), (ftnlen)sizeof(integer));
#line 23880 ""
	e_rsfi();

/*  Reset iccount to start of second integer */

#line 23884 ""
	*iccount += ns;

/*  There must be either a slash or a blank at pos'n 2 or 3 */

#line 23888 ""
	chax_(ch__1, (ftnlen)1, &c__47);
#line 23888 ""
	ns = i_indx(lineq + (*iccount - 1), ch__1, (ftnlen)3, (ftnlen)1);
#line 23889 ""
	if (ns == 0) {
#line 23889 ""
	    ns = i_indx(lineq + (*iccount - 1), " ", (ftnlen)3, (ftnlen)1);
#line 23889 ""
	}
#line 23890 ""
	ici__1.icierr = 0;
#line 23890 ""
	ici__1.iciend = 0;
#line 23890 ""
	ici__1.icirnum = 1;
#line 23890 ""
	ici__1.icirlen = *iccount + ns - 2 - (*iccount - 1);
#line 23890 ""
	ici__1.iciunit = lineq + (*iccount - 1);
/* Writing concatenation */
#line 23890 ""
	i__2[0] = 2, a__1[0] = "(i";
#line 23890 ""
	i__1 = ns + 47;
#line 23890 ""
	chax_(ch__1, (ftnlen)1, &i__1);
#line 23890 ""
	i__2[1] = 1, a__1[1] = ch__1;
#line 23890 ""
	i__2[2] = 1, a__1[2] = ")";
#line 23890 ""
	ici__1.icifmt = (s_cat(ch__2, a__1, i__2, &c__3, (ftnlen)4), ch__2);
#line 23890 ""
	s_rsfi(&ici__1);
#line 23890 ""
	do_fio(&c__1, (char *)&(*mtrden), (ftnlen)sizeof(integer));
#line 23890 ""
	e_rsfi();

/*  Set iccount to last character used */

#line 23894 ""
	*iccount = *iccount + ns - 1;
#line 23895 ""
    }
#line 23896 ""
    return 0;
} /* readmeter_ */

/* Subroutine */ int readnum_(char *lineq, integer *iccount, char *durq, real 
	*fnum, ftnlen lineq_len, ftnlen durq_len)
{
    /* System generated locals */
    address a__1[3];
    integer i__1[3];
    char ch__1[27], ch__2[6], ch__3[1];
    icilist ici__1;

    /* Builtin functions */
    integer i_indx(char *, char *, ftnlen, ftnlen), s_wsle(cilist *);
    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
    integer do_lio(integer *, integer *, char *, ftnlen), e_wsle(void), 
	    s_rsfi(icilist *), do_fio(integer *, char *, ftnlen), e_rsfi(void)
	    ;

    /* Local variables */
    static integer i1, i2, icf;
    extern /* Character */ VOID chax_(char *, ftnlen, integer *);
    extern /* Subroutine */ int stop1_(void), getchar_(char *, integer *, 
	    char *, ftnlen, ftnlen);

    /* Fortran I/O blocks */
    static cilist io___1728 = { 0, 6, 0, 0, 0 };



/*  This reads a number starting at position iccount.  Remember that on exit, */
/*  getchar leaves iccount at the last character retrieved.  So must only */
/*  call this routine *after* detecting a number or decimal. */
/*  On exit, durq is next character after end of number. */

#line 23907 ""
    i1 = *iccount;
#line 23908 ""
L1:
#line 23908 ""
    getchar_(lineq, iccount, durq, (ftnlen)128, (ftnlen)1);
#line 23909 ""
    if (i_indx("0123456789.", durq, (ftnlen)11, (ftnlen)1) > 0) {
#line 23909 ""
	goto L1;
#line 23909 ""
    }
#line 23910 ""
    i2 = *iccount - 1;
#line 23911 ""
    if (i2 < i1) {
#line 23912 ""
	s_wsle(&io___1728);
/* Writing concatenation */
#line 23912 ""
	i__1[0] = 7, a__1[0] = "Found \"";
#line 23912 ""
	i__1[1] = 1, a__1[1] = durq;
#line 23912 ""
	i__1[2] = 19, a__1[2] = "\" instead of number";
#line 23912 ""
	s_cat(ch__1, a__1, i__1, &c__3, (ftnlen)27);
#line 23912 ""
	do_lio(&c__9, &c__1, ch__1, (ftnlen)27);
#line 23912 ""
	e_wsle();
#line 23913 ""
	stop1_();
#line 23914 ""
    } else if (*(unsigned char *)&lineq[i1 - 1] == '.' && *(unsigned char *)&
	    lineq[i2 - 1] == '.') {
#line 23915 ""
	--i2;
#line 23916 ""
	--(*iccount);
#line 23917 ""
    }
#line 23918 ""
    icf = i2 - i1 + 49;
#line 23919 ""
    ici__1.icierr = 0;
#line 23919 ""
    ici__1.iciend = 0;
#line 23919 ""
    ici__1.icirnum = 1;
#line 23919 ""
    ici__1.icirlen = i2 - (i1 - 1);
#line 23919 ""
    ici__1.iciunit = lineq + (i1 - 1);
/* Writing concatenation */
#line 23919 ""
    i__1[0] = 2, a__1[0] = "(f";
#line 23919 ""
    chax_(ch__3, (ftnlen)1, &icf);
#line 23919 ""
    i__1[1] = 1, a__1[1] = ch__3;
#line 23919 ""
    i__1[2] = 3, a__1[2] = ".0)";
#line 23919 ""
    ici__1.icifmt = (s_cat(ch__2, a__1, i__1, &c__3, (ftnlen)6), ch__2);
#line 23919 ""
    s_rsfi(&ici__1);
#line 23919 ""
    do_fio(&c__1, (char *)&(*fnum), (ftnlen)sizeof(real));
#line 23919 ""
    e_rsfi();
#line 23920 ""
    return 0;
} /* readnum_ */

/* Subroutine */ int setbits_(integer *isdata, integer *iwidbit, integer *
	ishift, integer *ivalue)
{
    /* Builtin functions */
    integer pow_ii(integer *, integer *), lbit_shift(integer, integer);

    /* Local variables */
    static integer ibase;


/*  Sets iwidbits of isdata, shifted by ishift, to ivalue */

#line 23926 ""
    ibase = pow_ii(&c__2, iwidbit) - 1;
#line 23927 ""
    *isdata = ~ lbit_shift(ibase, *ishift) & *isdata;
#line 23928 ""
    *isdata |= lbit_shift(*ivalue, *ishift);
#line 23929 ""
    return 0;
} /* setbits_ */

/* Subroutine */ int setbm2_(real *xelsk, integer *nnb, real *sumx, real *
	sumy, integer *ipb, integer *islope, integer *nolev1)
{
    /* System generated locals */
    integer i__1;
    real r__1, r__2;

    /* Builtin functions */
    integer i_nint(real *), i_sign(integer *, integer *);

    /* Local variables */
    static real em;
    static integer ibc, inb, iul;
    static real beta, smin, delta, ybeam, ynote, sumxx, sumxy, deficit;


/* The MEAN SQUARE slope algorithm */

#line 23951 ""
    /* Parameter adjustments */
#line 23951 ""
    --ipb;
#line 23951 ""
    --xelsk;
#line 23951 ""

#line 23951 ""
    /* Function Body */
#line 23951 ""
    ibc = all_1.ibmcnt[commvl_1.ivx - 1];
#line 23952 ""
    sumxx = 0.f;
#line 23953 ""
    sumxy = 0.f;
#line 23954 ""
    i__1 = *nnb;
#line 23954 ""
    for (inb = 1; inb <= i__1; ++inb) {
/* Computing 2nd power */
#line 23955 ""
	r__1 = xelsk[inb];
#line 23955 ""
	sumxx += r__1 * r__1;
#line 23956 ""
	sumxy += xelsk[inb] * all_1.nolev[commvl_1.ivx + ipb[inb] * 24 - 25];
#line 23957 ""
/* L2: */
#line 23957 ""
    }
#line 23958 ""
    delta = *nnb * sumxx - *sumx * *sumx;
#line 23959 ""
    em = (*nnb * sumxy - *sumx * *sumy) / delta;
#line 23960 ""
    r__1 = em * .5f * all_1.slfac;
#line 23960 ""
    *islope = i_nint(&r__1);
#line 23961 ""
    if (abs(*islope) > 9) {
#line 23961 ""
	*islope = i_sign(&c__9, islope);
#line 23961 ""
    }
#line 23962 ""
    beta = (*sumy - *islope / all_1.slfac * *sumx) / *nnb;
#line 23963 ""
    *nolev1 = i_nint(&beta);

/*   Check if any stems are too short */

#line 23967 ""
    smin = 100.f;
#line 23968 ""
    iul = -1;
#line 23969 ""
    if (*(unsigned char *)&all_1.ulq[commvl_1.ivx + ibc * 24 - 25] == 'u') {
#line 23969 ""
	iul = 1;
#line 23969 ""
    }
#line 23970 ""
    i__1 = *nnb;
#line 23970 ""
    for (inb = 1; inb <= i__1; ++inb) {
#line 23971 ""
	ybeam = *nolev1 + iul * all_1.stemlen + *islope * xelsk[inb] / 
		all_1.slfac;
#line 23972 ""
	ynote = (real) all_1.nolev[commvl_1.ivx + ipb[inb] * 24 - 25];
/* Computing MIN */
#line 23973 ""
	r__1 = smin, r__2 = iul * (ybeam - ynote);
#line 23973 ""
	smin = dmin(r__1,r__2);
#line 23974 ""
/* L4: */
#line 23974 ""
    }
#line 23975 ""
    if (smin < all_1.stemmin) {
#line 23976 ""
	deficit = all_1.stemmin - smin;
#line 23977 ""
	r__1 = *nolev1 + iul * deficit;
#line 23977 ""
	*nolev1 = i_nint(&r__1);
#line 23978 ""
    }
#line 23979 ""
    return 0;
} /* setbm2_ */

/* Subroutine */ int setmac_(char *lineq, integer *iccount, integer *ibarcnt, 
	integer *ibaroff, integer *nbars, char *charq, char *durq, integer *
	ivx, integer *nline, ftnlen lineq_len, ftnlen charq_len, ftnlen 
	durq_len)
{
    /* System generated locals */
    integer i__1, i__2;

    /* Builtin functions */
    integer s_wsle(cilist *), e_wsle(void), do_lio(integer *, integer *, char 
	    *, ftnlen), i_indx(char *, char *, ftnlen, ftnlen), i_nint(real *)
	    ;
    /* Subroutine */ int s_copy(char *, char *, ftnlen, ftnlen);

    /* Local variables */
    static real fnum;
    static integer ndxm;
    extern /* Subroutine */ int stop1_(void), m1rec1_(char *, integer *, 
	    integer *, integer *, integer *, integer *, ftnlen), getbuf_(char 
	    *, ftnlen), errmsg_(char *, integer *, integer *, char *, ftnlen, 
	    ftnlen), readnum_(char *, integer *, char *, real *, ftnlen, 
	    ftnlen), g1etchar_(char *, integer *, char *, ftnlen, ftnlen);

    /* Fortran I/O blocks */
    static cilist io___1743 = { 0, 6, 0, 0, 0 };
    static cilist io___1744 = { 0, 6, 0, 0, 0 };
    static cilist io___1745 = { 0, 6, 0, 0, 0 };



/*  Macro action */

#line 23992 ""
    g1etchar_(lineq, iccount, charq, (ftnlen)128, (ftnlen)1);
#line 23993 ""
    if (*(unsigned char *)charq == 'S' && *ivx != 1) {
#line 23994 ""
	s_wsle(&io___1743);
#line 23994 ""
	e_wsle();
#line 23995 ""
	s_wsle(&io___1744);
#line 23995 ""
	e_wsle();
#line 23996 ""
	s_wsle(&io___1745);
#line 23996 ""
	do_lio(&c__9, &c__1, "*********WARNING*********", (ftnlen)25);
#line 23996 ""
	e_wsle();
#line 23997 ""
	i__1 = *ibarcnt - *ibaroff + *nbars + 1;
#line 23997 ""
	errmsg_(lineq, iccount, &i__1, "\"MS...\" only put in parts by scor2"\
		"prt if in voice #1!", (ftnlen)128, (ftnlen)53);
#line 23999 ""
    }
#line 24000 ""
    if (i_indx("RSP ", charq, (ftnlen)4, (ftnlen)1) == 0) {
#line 24001 ""
	i__1 = *ibarcnt - *ibaroff + *nbars + 1;
#line 24001 ""
	errmsg_(lineq, iccount, &i__1, "Illegal character after \"M\" (macro"\
		")!", (ftnlen)128, (ftnlen)36);
#line 24003 ""
	stop1_();
#line 24004 ""
    } else if (*(unsigned char *)charq != ' ') {

/*  Record or playback a macro.  Get the number of the macro. */

#line 24008 ""
	g1etchar_(lineq, iccount, durq, (ftnlen)128, (ftnlen)1);
#line 24009 ""
	if (i_indx("123456789", durq, (ftnlen)9, (ftnlen)1) == 0) {
#line 24010 ""
	    i__1 = *ibarcnt - *ibaroff + *nbars + 1;
#line 24010 ""
	    errmsg_(lineq, iccount, &i__1, "Must input number after \"MR\""\
		    ",\"MP\", or \"MS\"!", (ftnlen)128, (ftnlen)43);
#line 24012 ""
	    stop1_();
#line 24013 ""
	}
#line 24014 ""
	readnum_(lineq, iccount, durq, &fnum, (ftnlen)128, (ftnlen)1);
#line 24015 ""
	commac_1.macnum = i_nint(&fnum);
#line 24016 ""
	if (*(unsigned char *)durq != ' ') {
#line 24017 ""
	    i__1 = *ibarcnt - *ibaroff + *nbars + 1;
#line 24017 ""
	    errmsg_(lineq, iccount, &i__1, "Macro number must be followed by"\
		    " a blank!", (ftnlen)128, (ftnlen)41);
#line 24019 ""
	    stop1_();
#line 24020 ""
	}
#line 24021 ""
	if (i_indx("RS", charq, (ftnlen)2, (ftnlen)1) > 0) {

/*  Record or save a macro */

#line 24025 ""
	    if (commac_1.macnum < 1 || commac_1.macnum > 20) {
#line 24026 ""
		i__1 = *iccount - 1;
#line 24026 ""
		i__2 = *ibarcnt - *ibaroff + *nbars + 1;
#line 24026 ""
		errmsg_(lineq, &i__1, &i__2, "Macro number not in range 1-20!"
			, (ftnlen)128, (ftnlen)31);
#line 24028 ""
		stop1_();
#line 24029 ""
	    }
#line 24030 ""
	    commac_1.macuse = bit_set(commac_1.macuse,commac_1.macnum);
#line 24031 ""
	    if (*(unsigned char *)charq == 'R') {
#line 24032 ""
		m1rec1_(lineq, iccount, ibarcnt, ibaroff, nbars, &ndxm, (
			ftnlen)128);
#line 24033 ""
	    } else if (*(unsigned char *)charq == 'S') {

/*  Save (Record but don't activate) */

#line 24037 ""
L1:
#line 24037 ""
		m1rec1_(lineq, iccount, ibarcnt, ibaroff, nbars, &ndxm, (
			ftnlen)128);
#line 24038 ""
		if (commac_1.mrecord) {
#line 24039 ""
		    getbuf_(lineq, (ftnlen)128);
#line 24040 ""
		    ++(*nline);
#line 24041 ""
		    *iccount = 0;
#line 24042 ""
		    goto L1;
#line 24043 ""
		}
#line 24044 ""
		*iccount = *iccount + ndxm + 1;
#line 24045 ""
	    }
#line 24046 ""
	} else {

/*  Playback the macro */

#line 24050 ""
	    if (! bit_test(commac_1.macuse,commac_1.macnum)) {
#line 24051 ""
		i__1 = *iccount - 1;
#line 24051 ""
		i__2 = *ibarcnt - *ibaroff + *nbars + 1;
#line 24051 ""
		errmsg_(lineq, &i__1, &i__2, "Cannot play a macro that has n"\
			"ot been recorded!", (ftnlen)128, (ftnlen)47);
#line 24053 ""
		stop1_();
#line 24054 ""
	    }
#line 24055 ""
	    commac_1.icchold = *iccount;
#line 24056 ""
	    s_copy(commac_1.lnholdq, lineq, (ftnlen)128, (ftnlen)128);
#line 24057 ""
	    *iccount = 128;
#line 24058 ""
	    commac_1.mplay = TRUE_;
#line 24059 ""
	    c1ommac_1.ilmac = c1ommac_1.il1mac[commac_1.macnum - 1];
#line 24060 ""
	}
#line 24061 ""
    }
#line 24062 ""
    return 0;
} /* setmac_ */

/* Subroutine */ int setmeter_(integer *mtrnuml, integer *mtrdenl, integer *
	ibmtyp, integer *ibmrep)
{

/*  Sets last 2 args depending on 1st 2, (logical) num, denom. */
/*  ibmtyp = 1, 2, or 3 defines set of masks for beam groupings. */
/*  1: all duple meters */
/*  2: triple w/ denom=4, subdivide in groups of 2 8ths */
/*  3: triple w/ denom=8, subdivide in groups of 3 8ths */
/*  Note that lenbar is set at top or when 'm' symbol is read in getnote */

#line 24073 ""
    if (*mtrdenl == 4) {
#line 24074 ""
	if (*mtrnuml % 3 == 0) {
#line 24075 ""
	    *ibmtyp = 2;
#line 24076 ""
	    *ibmrep = *mtrnuml / 3;
#line 24077 ""
	} else {
#line 24078 ""
	    *ibmtyp = 1;
#line 24079 ""
	    *ibmrep = *mtrnuml / 2;
#line 24080 ""
	}
#line 24081 ""
    } else if (*mtrdenl == 2) {
#line 24082 ""
	*ibmtyp = 1;
#line 24083 ""
	if (*mtrnuml == 3) {
#line 24084 ""
	    *ibmrep = 3;
#line 24085 ""
	} else {
#line 24086 ""
	    *ibmrep = (*mtrnuml << 1) / *mtrdenl;
#line 24087 ""
	}
#line 24088 ""
    } else if (*mtrdenl == 8 && (*mtrnuml == 8 || *mtrnuml == 4)) {

/*  Added 170726 */

#line 24092 ""
	*ibmtyp = 1;
#line 24093 ""
	*ibmrep = *mtrnuml / 4;
#line 24094 ""
    } else {

/*  Assumes mtrdenl=8 and 3/8, 6/8, 9/8, or 12/8 */

#line 24098 ""
	*ibmtyp = 3;
#line 24099 ""
	*ibmrep = *mtrnuml / 3;
#line 24100 ""
    }

/*  Reset so we don't keep writing new meters */

#line 24104 ""
    *mtrnuml = 0;

/*  Prevent ibmrep=0.  Needed for odd bars, e.g. 1/8, where beams don't matter */

#line 24108 ""
    *ibmrep = max(*ibmrep,1);
#line 24109 ""
    return 0;
} /* setmeter_ */

/* Subroutine */ int setupb_(real *xelsk, integer *nnb, real *sumx, real *
	sumy, integer *ipb, real *smed, integer *ixrest)
{
    /* System generated locals */
    integer i__1, i__2;
    real r__1, r__2;

    /* Builtin functions */
    double r_sign(real *, real *);
    integer i_nint(real *), i_sign(integer *, integer *);
    double sqrt(doublereal);

    /* Local variables */
    static integer i__, j;
    static real t;
    static integer n1, ip;
    static real yb1;
    static integer ibc, inb, jnb;
    static real off;
    static integer nsc, iul;
    static real syb, sum, ssq, off1, off2;
    static logical l1ng, l2ng;
    static real beta, smin, eskz0;
    static integer ipxt1;
    extern integer ncmid_(integer *, integer *);
    static real ybeam, xboff;
    static integer ndoub;
    static real slope[800];
    static integer issbs;
    static real ynote;
    extern /* Subroutine */ int setbm2_(real *, integer *, real *, real *, 
	    integer *, integer *, integer *);
    static integer nscmid;
    static real dnolev;
    static integer iplast, nolevo;
    static real xnolev2, deficit;
    static integer ipxtmid;


/* The outer combo algorithm */

#line 24143 ""
    /* Parameter adjustments */
#line 24143 ""
    --ipb;
#line 24143 ""
    --xelsk;
#line 24143 ""

#line 24143 ""
    /* Function Body */
#line 24143 ""
    ibc = all_1.ibmcnt[commvl_1.ivx - 1];
#line 24144 ""
    comxtup_2.nxtinbm[commvl_1.ivx - 1] = 0;
#line 24145 ""
    n1 = comipl2_1.ipl2[commvl_1.ivx + all_1.ibm1[commvl_1.ivx + ibc * 24 - 
	    25] * 24 - 25];

/*  Initialize counters used in this subroutine, and then later during actual */
/*    beam drawing, to count later segments of single-slope beam groups */

#line 24150 ""
    comxtup_2.nssb[commvl_1.ivx - 1] = 0;
#line 24151 ""
    comxtup_2.issb[commvl_1.ivx - 1] = 0;

/*  Set flag for xtup beam starting with rest (no others can start with rest) */

#line 24155 ""
    if (bit_test(all_1.irest[commvl_1.ivx + all_1.ipo[n1 - 1] * 24 - 25],0)) {
#line 24155 ""
	*ixrest = 1;
#line 24155 ""
    }

/* Figure how many elemskips to each note. Use the list, counting only non-rests. */

#line 24159 ""
    eskz0 = all_1.eskz[commvl_1.ivx + all_1.ibm1[commvl_1.ivx + ibc * 24 - 25]
	     * 24 - 25];
#line 24160 ""
    *nnb = 0;
#line 24161 ""
    *sumx = 0.f;
#line 24162 ""
    *sumy = 0.f;
#line 24163 ""
    ipxt1 = 0;
#line 24164 ""
    iplast = all_1.ibm2[commvl_1.ivx + ibc * 24 - 25];
#line 24165 ""
    i__1 = iplast;
#line 24165 ""
    for (ip = all_1.ibm1[commvl_1.ivx + ibc * 24 - 25]; ip <= i__1; ++ip) {
#line 24166 ""
	if (! bit_test(all_1.irest[commvl_1.ivx + ip * 24 - 25],0)) {
#line 24167 ""
	    ++(*nnb);
#line 24168 ""
	    ipb[*nnb] = ip;
#line 24169 ""
	    xelsk[*nnb] = all_1.eskz[commvl_1.ivx + ip * 24 - 25] - eskz0;
#line 24170 ""
	    *sumx += xelsk[*nnb];
#line 24171 ""
	    *sumy += all_1.nolev[commvl_1.ivx + ipb[*nnb] * 24 - 25];
#line 24172 ""
	    if (bit_test(all_1.nacc[commvl_1.ivx + ip * 24 - 25],21)) {

/*  This is the starting note of later segment of single-slope beam group */
/*  Temporarily store ip here. */

#line 24177 ""
		++comxtup_2.nssb[commvl_1.ivx - 1];
#line 24178 ""
		comxtup_2.lev1ssb[commvl_1.ivx + comxtup_2.nssb[commvl_1.ivx 
			- 1] * 24 - 25] = *nnb;
#line 24179 ""
	    }
#line 24180 ""
	}

/*  New xtup stuff here.  Final object is to get distance from start of xtup */
/*    to number. xtinbm counts xtups in this beam only.  mtupv is the printed */
/*    number.  ntupv is number of notes in xtup, and is only used to get */
/*    eloff, the distance from start of xtup to the number. */

#line 24187 ""
	if (bit_test(all_1.nacc[commvl_1.ivx + ip * 24 - 25],18)) {
#line 24187 ""
	    ++ndoub;
#line 24187 ""
	}
#line 24188 ""
	if (ipxt1 == 0 && all_1.nodur[commvl_1.ivx + ip * 24 - 25] == 0) {

/*  Xtup is starting here */

#line 24192 ""
	    ++comxtup_2.nxtinbm[commvl_1.ivx - 1];
#line 24193 ""
	    ipxt1 = ip;
#line 24194 ""
	    if (bit_test(all_1.nacc[commvl_1.ivx + ip * 24 - 25],18)) {
#line 24195 ""
		ndoub = 1;
#line 24196 ""
	    } else {
#line 24197 ""
		ndoub = 0;
#line 24198 ""
	    }
#line 24199 ""
	} else if (ipxt1 > 0 && all_1.nodur[commvl_1.ivx + ip * 24 - 25] > 0) 
		{

/*  Xtup ends here.  Set total number of notes in xtup. */

#line 24203 ""
	    comxtup_2.ntupv[commvl_1.ivx + comxtup_2.nxtinbm[commvl_1.ivx - 1]
		     * 24 - 25] = ip + 1 - ipxt1;

/*  Set printed number for embedded xtup. */

#line 24207 ""
	    comxtup_2.mtupv[commvl_1.ivx + comxtup_2.nxtinbm[commvl_1.ivx - 1]
		     * 24 - 25] = comxtup_2.ntupv[commvl_1.ivx + 
		    comxtup_2.nxtinbm[commvl_1.ivx - 1] * 24 - 25] + ndoub;

/*  Middle note of xtup if ntupv odd, note to left of gap if even. */

#line 24211 ""
	    ipxtmid = (ip + ipxt1) / 2;
#line 24212 ""
	    comxtup_2.eloff[commvl_1.ivx + comxtup_2.nxtinbm[commvl_1.ivx - 1]
		     * 24 - 25] = comeskz2_1.eskz2[commvl_1.ivx + ipxtmid * 
		    24 - 25] - comeskz2_1.eskz2[commvl_1.ivx + ipxt1 * 24 - 
		    25];
#line 24213 ""
	    if (comxtup_2.ntupv[commvl_1.ivx + comxtup_2.nxtinbm[commvl_1.ivx 
		    - 1] * 24 - 25] % 2 == 0) {
#line 24213 ""
		comxtup_2.eloff[commvl_1.ivx + comxtup_2.nxtinbm[commvl_1.ivx 
			- 1] * 24 - 25] += (comeskz2_1.eskz2[commvl_1.ivx + (
			ipxtmid + 1) * 24 - 25] - comeskz2_1.eskz2[
			commvl_1.ivx + ipxtmid * 24 - 25]) * .5f;
#line 24213 ""
	    }
#line 24216 ""
	    ipxt1 = 0;
#line 24217 ""
	}
#line 24218 ""
/* L2: */
#line 24218 ""
    }

/*  Reset nxtinbm for use as counter as #'s are posted by putxtn(..) */

#line 24222 ""
    comxtup_2.nxtinbm[commvl_1.ivx - 1] = 0;
#line 24223 ""
    *smed = 0.f;
/*      if (.not.btest(islur(ivx,ipb(1)),2)) then */
#line 24225 ""
    if (! bit_test(all_1.islur[commvl_1.ivx + ipb[1] * 24 - 25],2) && *nnb > 
	    1) {

/* No forced 0 slope */

/*        if (nnb .eq. 1) go to 6 */
#line 24230 ""
	nsc = 0;
#line 24231 ""
	i__1 = *nnb - 1;
#line 24231 ""
	for (inb = 1; inb <= i__1; ++inb) {
#line 24232 ""
	    i__2 = *nnb;
#line 24232 ""
	    for (jnb = inb + 1; jnb <= i__2; ++jnb) {
#line 24233 ""
		++nsc;
#line 24234 ""
		slope[nsc - 1] = (all_1.nolev[commvl_1.ivx + ipb[jnb] * 24 - 
			25] - all_1.nolev[commvl_1.ivx + ipb[inb] * 24 - 25]) 
			/ (xelsk[jnb] - xelsk[inb]);
#line 24236 ""
		if ((r__1 = slope[nsc - 1], dabs(r__1)) < 1e-4f) {
#line 24237 ""
		    ++nsc;
#line 24238 ""
		    slope[nsc - 1] = slope[nsc - 2];
#line 24239 ""
		    ++nsc;
#line 24240 ""
		    slope[nsc - 1] = slope[nsc - 2];
#line 24241 ""
		}
#line 24242 ""
/* L5999: */
#line 24242 ""
	    }
#line 24243 ""
/* L5: */
#line 24243 ""
	}
#line 24244 ""
	if (nsc == 1) {
#line 24245 ""
	    *smed = slope[0];
#line 24246 ""
	    goto L6;
#line 24247 ""
	}
#line 24248 ""
	nscmid = nsc / 2 + 1;
#line 24249 ""
	i__1 = nscmid;
#line 24249 ""
	for (i__ = 1; i__ <= i__1; ++i__) {
#line 24250 ""
	    i__2 = nsc;
#line 24250 ""
	    for (j = i__ + 1; j <= i__2; ++j) {
#line 24251 ""
		if (slope[j - 1] < slope[i__ - 1]) {
#line 24252 ""
		    t = slope[j - 1];
#line 24253 ""
		    slope[j - 1] = slope[i__ - 1];
#line 24254 ""
		    slope[i__ - 1] = t;
#line 24255 ""
		}
#line 24256 ""
/* L7999: */
#line 24256 ""
	    }
#line 24257 ""
/* L7: */
#line 24257 ""
	}
#line 24258 ""
	*smed = slope[nscmid - 1];
#line 24259 ""
	if (nsc == nsc / 2 << 1) {

/*  Even number of slopes in the list, so median is ambiguous */

#line 24263 ""
	    if ((r__2 = slope[nscmid - 2], dabs(r__2)) < (r__1 = slope[nscmid 
		    - 1], dabs(r__1)) - comtol_1.tol) {

/*  Lower-numbered one is truly less in absolute value, so use it */

#line 24267 ""
		*smed = slope[nscmid - 2];
#line 24268 ""
	    } else if ((r__1 = slope[nscmid - 2] + slope[nscmid - 1], dabs(
		    r__1)) < comtol_1.tol) {

/*  Two slopes are effectively equal.  Take the one with sign of the average */

#line 24272 ""
		sum = 0.f;
#line 24273 ""
		i__1 = nsc;
#line 24273 ""
		for (i__ = 1; i__ <= i__1; ++i__) {
#line 24274 ""
		    sum += slope[i__ - 1];
#line 24275 ""
/* L1: */
#line 24275 ""
		}
#line 24276 ""
		*smed = r_sign(smed, &sum);
#line 24277 ""
	    }
#line 24278 ""
	}
#line 24279 ""
L6:
#line 24280 ""
	r__1 = *smed * .5f * all_1.slfac;
#line 24280 ""
	comxtup_2.islope[commvl_1.ivx - 1] = i_nint(&r__1);
#line 24281 ""
	if ((i__1 = comxtup_2.islope[commvl_1.ivx - 1], abs(i__1)) > 9) {
#line 24281 ""
	    comxtup_2.islope[commvl_1.ivx - 1] = i_sign(&c__9, &
		    comxtup_2.islope[commvl_1.ivx - 1]);
#line 24281 ""
	}
#line 24283 ""
    } else {

/*  Forced horizontal beam */

#line 24287 ""
	comxtup_2.islope[commvl_1.ivx - 1] = 0;
#line 24288 ""
    }
#line 24289 ""
    beta = (*sumy - comxtup_2.islope[commvl_1.ivx - 1] / all_1.slfac * *sumx) 
	    / *nnb;

/*  If ixrest>0, this is a virtual nolev1 at location of rest.  Will first use */
/*  as is for placing xtup number and/or bracket, then reset it for start of */
/*  actual beam */

#line 24295 ""
    comxtup_2.nolev1[commvl_1.ivx - 1] = i_nint(&beta);

/*  Check if any stems are too short */

#line 24299 ""
    smin = 100.f;
#line 24300 ""
    iul = -1;
#line 24301 ""
    if (*(unsigned char *)&all_1.ulq[commvl_1.ivx + ibc * 24 - 25] == 'u') {
#line 24301 ""
	iul = 1;
#line 24301 ""
    }
#line 24302 ""
    ssq = 0.f;
#line 24303 ""
    syb = 0.f;
#line 24304 ""
    yb1 = comxtup_2.nolev1[commvl_1.ivx - 1] + iul * (all_1.stemlen + 
	    combmh_1.bmhgt * ((15 & all_1.mult[commvl_1.ivx + ipb[1] * 24 - 
	    25]) - 9));
#line 24306 ""
    i__1 = *nnb;
#line 24306 ""
    for (inb = 1; inb <= i__1; ++inb) {
#line 24307 ""
	ybeam = yb1 + comxtup_2.islope[commvl_1.ivx - 1] * xelsk[inb] / 
		all_1.slfac - iul * combmh_1.bmhgt * ((15 & all_1.mult[
		commvl_1.ivx + ipb[inb] * 24 - 25]) - 9);
#line 24309 ""
	syb += ybeam;
#line 24310 ""
	ynote = (real) all_1.nolev[commvl_1.ivx + ipb[inb] * 24 - 25];
#line 24311 ""
	off = ybeam - ynote;
#line 24312 ""
	if (inb == 1) {
#line 24313 ""
	    off1 = off;
#line 24314 ""
	} else if (inb == *nnb) {
#line 24315 ""
	    off2 = off;
#line 24316 ""
	}
#line 24317 ""
	ssq += off * off;
/* Computing MIN */
#line 24318 ""
	r__1 = smin, r__2 = iul * off;
#line 24318 ""
	smin = dmin(r__1,r__2);
#line 24319 ""
/* L4: */
#line 24319 ""
    }
#line 24320 ""
    dnolev = 0.f;
#line 24321 ""
    if (smin < all_1.stemmin) {
#line 24322 ""
	deficit = all_1.stemmin - smin;
#line 24323 ""
	nolevo = comxtup_2.nolev1[commvl_1.ivx - 1];
#line 24324 ""
	r__1 = comxtup_2.nolev1[commvl_1.ivx - 1] + iul * deficit;
#line 24324 ""
	comxtup_2.nolev1[commvl_1.ivx - 1] = i_nint(&r__1);
#line 24325 ""
	dnolev = (real) (comxtup_2.nolev1[commvl_1.ivx - 1] - nolevo);
#line 24326 ""
	off1 += dnolev;
#line 24327 ""
	off2 += dnolev;
#line 24328 ""
    }
/* Computing 2nd power */
#line 24329 ""
    r__1 = dnolev;
#line 24329 ""
    ssq = ssq + dnolev * 2 * (syb - *sumy) + r__1 * r__1;
#line 24330 ""
    if (! comxtup_2.vxtup[commvl_1.ivx - 1] && sqrt(ssq / *nnb) > 
	    all_1.stemmax && (dabs(off1) < all_1.stemmax || dabs(off2) < 
	    all_1.stemmax) && ! bit_test(all_1.islur[commvl_1.ivx + ipb[1] * 
	    24 - 25],2) && *nnb != 1) {
/*     *    .and. .not.btest(islur(ivx,ipb(1)),2)) then */

/*  The first check is to save trouble of putting xtup's in setbm2. */
/*  The penultimate check is that first and last stems aren't both excessive. */
/*  The last check is that a 0 slope has not been forced */

#line 24340 ""
	setbm2_(&xelsk[1], nnb, sumx, sumy, &ipb[1], &comxtup_2.islope[
		commvl_1.ivx - 1], &comxtup_2.nolev1[commvl_1.ivx - 1]);
#line 24341 ""
    }

/*  Check if beam starts or ends too high or low. */

#line 24345 ""
    xboff = combmh_1.bmhgt * ((15 & all_1.mult[commvl_1.ivx + ipb[1] * 24 - 
	    25]) - 9);
#line 24346 ""
    l1ng = iul * (comxtup_2.nolev1[commvl_1.ivx - 1] - ncmid_(&all_1.iv, &ipb[
	    1])) + xboff + 7 < 0.f;
#line 24347 ""
    xnolev2 = comxtup_2.nolev1[commvl_1.ivx - 1] + comxtup_2.islope[
	    commvl_1.ivx - 1] / all_1.slfac * xelsk[*nnb];
#line 24348 ""
    l2ng = iul * (xnolev2 - ncmid_(&all_1.iv, &ipb[*nnb])) + xboff + 7 < 0.f;
#line 24349 ""
    if (l1ng || l2ng) {

/*  Need to correct start or stop, also slope */

#line 24353 ""
	if (l1ng) {
#line 24354 ""
	    r__1 = ncmid_(&all_1.iv, &ipb[1]) - (xboff + 7.f) * iul;
#line 24354 ""
	    comxtup_2.nolev1[commvl_1.ivx - 1] = i_nint(&r__1);
#line 24355 ""
	}
#line 24356 ""
	if (l2ng) {
#line 24357 ""
	    r__1 = ncmid_(&all_1.iv, &ipb[*nnb]) - (xboff + 7.f) * iul;
#line 24357 ""
	    xnolev2 = (real) i_nint(&r__1);
#line 24358 ""
	}

/*  Since one or the other end has changed, need to change slope */

#line 24362 ""
	if (! bit_test(all_1.islur[commvl_1.ivx + ipb[1] * 24 - 25],2) && *
		nnb != 1) {
#line 24362 ""
	    r__1 = all_1.slfac * (xnolev2 - comxtup_2.nolev1[commvl_1.ivx - 1]
		    ) / xelsk[*nnb];
#line 24362 ""
	    comxtup_2.islope[commvl_1.ivx - 1] = i_nint(&r__1);
#line 24362 ""
	}
#line 24364 ""
    }
#line 24365 ""
    if (comxtup_2.nssb[commvl_1.ivx - 1] > 0) {

/*  This is a single-slope beam group.  Store start heights for later segs. */

#line 24369 ""
	i__1 = comxtup_2.nssb[commvl_1.ivx - 1];
#line 24369 ""
	for (issbs = 1; issbs <= i__1; ++issbs) {
#line 24370 ""
	    comxtup_2.lev1ssb[commvl_1.ivx + issbs * 24 - 25] = 
		    comxtup_2.nolev1[commvl_1.ivx - 1] + comxtup_2.islope[
		    commvl_1.ivx - 1] / all_1.slfac * xelsk[comxtup_2.lev1ssb[
		    commvl_1.ivx + issbs * 24 - 25]];
#line 24372 ""
/* L3: */
#line 24372 ""
	}
#line 24373 ""
    }
#line 24374 ""
    return 0;
} /* setupb_ */

/* Subroutine */ int sortpoe_(integer *nsyst, real *poe, integer *ipoe)
{
    /* System generated locals */
    integer i__1, i__2;

    /* Local variables */
    static integer io1, io2, iord, itemp;


/*  Initialize ipoe: */

#line 24383 ""
    /* Parameter adjustments */
#line 24383 ""
    --ipoe;
#line 24383 ""
    --poe;
#line 24383 ""

#line 24383 ""
    /* Function Body */
#line 24383 ""
    i__1 = *nsyst;
#line 24383 ""
    for (iord = 1; iord <= i__1; ++iord) {
#line 24384 ""
	ipoe[iord] = iord;
#line 24385 ""
/* L3: */
#line 24385 ""
    }

/*  Construct ipoe vector with pairwise interchanges.  When done, ipoe(1) will */
/*  be index of smallest poe, and ipoe(nsyst) will be index of biggest poe. */

#line 24390 ""
    i__1 = *nsyst - 1;
#line 24390 ""
    for (io1 = 1; io1 <= i__1; ++io1) {
#line 24391 ""
	i__2 = *nsyst;
#line 24391 ""
	for (io2 = io1 + 1; io2 <= i__2; ++io2) {
#line 24392 ""
	    if (poe[ipoe[io1]] > poe[ipoe[io2]]) {

/* Interchange the indices */

#line 24396 ""
		itemp = ipoe[io1];
#line 24397 ""
		ipoe[io1] = ipoe[io2];
#line 24398 ""
		ipoe[io2] = itemp;
#line 24399 ""
	    }
#line 24400 ""
/* L5: */
#line 24400 ""
	}
#line 24401 ""
/* L4: */
#line 24401 ""
    }
#line 24402 ""
    return 0;
} /* sortpoe_ */

/* Subroutine */ int spsslur_(char *lineq, integer *iccount, integer *iv, 
	integer *kv, integer *ip, integer *isdat1, integer *isdat2, integer *
	isdat3, integer *isdat4, integer *nsdat, logical *notcrd, integer *
	nolev, char *starter, ftnlen lineq_len, ftnlen starter_len)
{
    /* System generated locals */
    integer i__1, i__2;
    real r__1;

    /* Builtin functions */
    integer i_indx(char *, char *, ftnlen, ftnlen), s_cmp(char *, char *, 
	    ftnlen, ftnlen), i_nint(real *);

    /* Local variables */
    extern integer igetbits_(integer *, integer *, integer *);
    static integer ilb12;
    static real fnum;
    static char dumq[1], durq[1];
    static integer ihoff, isdat, ivoff, icurv1, idcode, nolevc, numint;
    extern /* Subroutine */ int getchar_(char *, integer *, char *, ftnlen, 
	    ftnlen), readnum_(char *, integer *, char *, real *, ftnlen, 
	    ftnlen), setbits_(integer *, integer *, integer *, integer *);


/*  Reads in slur data.  Record all h/v-shifts for non-chords, user-specified */
/*  ones for chords. */
/*  5/26/02  This subr is called ONLY for postscript slurs. */

/*  See subroutine doslur for bit values in isdat1,2,3 */


/*  Counter for signed integers.  1st is height, 2nd is horiz, 3rd is curve */

#line 24427 ""
    /* Parameter adjustments */
#line 24427 ""
    --isdat4;
#line 24427 ""
    --isdat3;
#line 24427 ""
    --isdat2;
#line 24427 ""
    --isdat1;
#line 24427 ""

#line 24427 ""
    /* Function Body */
#line 24427 ""
    numint = 0;
#line 24428 ""
    ivoff = 0;
#line 24429 ""
    ihoff = 0;
#line 24430 ""
    ++(*nsdat);
#line 24431 ""
    if (*(unsigned char *)starter == '{' || *(unsigned char *)starter == '}') 
	    {
#line 24431 ""
	isdat2[*nsdat] = bit_set(isdat2[*nsdat],3);
#line 24431 ""
    }
#line 24433 ""
    setbits_(&isdat1[*nsdat], &c__5, &c__13, iv);
#line 24434 ""
    i__1 = *kv - 1;
#line 24434 ""
    setbits_(&isdat1[*nsdat], &c__1, &c__12, &i__1);
#line 24435 ""
    setbits_(&isdat1[*nsdat], &c__8, &c__3, ip);
#line 24436 ""
    isdat3[*nsdat] = 0;
#line 24437 ""
    isdat4[*nsdat] = 0;
#line 24438 ""
    ilb12 = 0;

/*  Get ID code */

/* flag for tweaks of 1st or 2nd (0|1) seg of linebreak slur */
#line 24442 ""
    getchar_(lineq, iccount, durq, (ftnlen)128, (ftnlen)1);
#line 24443 ""
    if (i_indx("uldtb+-hfnHpsv ", durq, (ftnlen)15, (ftnlen)1) > 0) {

/*  Null id. Note for ps slurs, 'H' cannot be an ID */

#line 24447 ""
	--(*iccount);
#line 24448 ""
	if (*(unsigned char *)&lineq[*iccount - 1] == 't') {
#line 24449 ""
	    idcode = 1;
#line 24450 ""
	} else {
#line 24451 ""
	    idcode = 32;
#line 24452 ""
	}
#line 24453 ""
    } else {

/*  Set explicit idcode */

#line 24457 ""
	idcode = *(unsigned char *)durq;
#line 24458 ""
	i__1 = *iccount - 2;
#line 24458 ""
	if (s_cmp(lineq + i__1, "t", *iccount - 1 - i__1, (ftnlen)1) == 0) {

/*  Make t[ID] look like s[ID]t */

#line 24462 ""
	    isdat2[*nsdat] = bit_set(isdat2[*nsdat],3);
#line 24463 ""
	}
#line 24464 ""
	i__1 = *iccount;
#line 24464 ""
	if (s_cmp(lineq + i__1, "x", *iccount + 1 - i__1, (ftnlen)1) == 0) {

/*  Flag for 2-voice, indexed slurs */

#line 24468 ""
	    ++(*iccount);
#line 24469 ""
	    setbits_(&isdat1[*nsdat], &c__1, &c__1, &c__1);
#line 24470 ""
	}
#line 24471 ""
    }
#line 24472 ""
    setbits_(&isdat1[*nsdat], &c__7, &c__19, &idcode);

/*  Set start/stop: look thru list from end for same idcode,iv,kv */

#line 24476 ""
    for (isdat = *nsdat - 1; isdat >= 1; --isdat) {
#line 24477 ""
	if (idcode == igetbits_(&isdat1[isdat], &c__7, &c__19) && *iv == 
		igetbits_(&isdat1[isdat], &c__5, &c__13) && (*kv - 1 == 
		igetbits_(&isdat1[isdat], &c__1, &c__12) || bit_test(isdat1[
		isdat],1))) {

/*  Matched idcode & ivx.  On/off?.  If on, new is turnoff, leave bit 11 at 0. */

#line 24484 ""
	    if (bit_test(isdat1[isdat],11)) {
#line 24484 ""
		goto L3;
#line 24484 ""
	    }

/*  Found slur is a turnoff, so new one is a turnon.  Jump down to set bit */

#line 24488 ""
	    goto L4;
#line 24489 ""
	}
#line 24490 ""
/* L2: */
#line 24490 ""
    }

/*  If here, this is turnon. */

#line 24494 ""
L4:
#line 24495 ""
    isdat1[*nsdat] = bit_set(isdat1[*nsdat],11);
#line 24496 ""
L3:

/*  Now done with initial turnon- or turnoff-specifics. */

#line 24500 ""
    if (i_nint(&comslur_1.slurcurve) != 0 && bit_test(isdat1[*nsdat],11)) {

/*  There's a default curvature tweak */

#line 24504 ""
	icurv1 = i_nint(&comslur_1.slurcurve) + 3;
#line 24505 ""
	if (icurv1 == 2) {
#line 24505 ""
	    icurv1 = 1;
#line 24505 ""
	}
#line 24506 ""
	isdat3[*nsdat] = bit_set(isdat3[*nsdat],0);
#line 24507 ""
	i__1 = icurv1 + 32;
#line 24507 ""
	setbits_(&isdat3[*nsdat], &c__6, &c__2, &i__1);
#line 24508 ""
    }

/*  Loop for rest of input */

#line 24512 ""
L1:
#line 24512 ""
    getchar_(lineq, iccount, durq, (ftnlen)128, (ftnlen)1);
#line 24513 ""
    if (i_indx("uld", durq, (ftnlen)3, (ftnlen)1) > 0) {

/*  Force direction */

#line 24517 ""
	isdat1[*nsdat] = bit_set(isdat1[*nsdat],26);
#line 24518 ""
	if (*(unsigned char *)durq == 'u') {
#line 24518 ""
	    isdat1[*nsdat] = bit_set(isdat1[*nsdat],27);
#line 24518 ""
	}
#line 24519 ""
	goto L1;
#line 24520 ""
    } else if (i_indx("+-", durq, (ftnlen)2, (ftnlen)1) > 0) {
#line 24521 ""
	++numint;
#line 24522 ""
	if (numint == 1) {

/*  Vertical offset */

#line 24526 ""
	    ++(*iccount);
#line 24527 ""
	    readnum_(lineq, iccount, dumq, &fnum, (ftnlen)128, (ftnlen)1);
#line 24528 ""
	    --(*iccount);
#line 24529 ""
	    ivoff = i_nint(&fnum);
#line 24530 ""
	    if (*(unsigned char *)durq == '-') {
#line 24530 ""
		ivoff = -ivoff;
#line 24530 ""
	    }
#line 24531 ""
	} else if (numint == 2) {

/*  Horizontal offset */

#line 24535 ""
	    ++(*iccount);
#line 24536 ""
	    readnum_(lineq, iccount, dumq, &fnum, (ftnlen)128, (ftnlen)1);
#line 24537 ""
	    --(*iccount);

/*  fnum is abs(hshift), must be 0 to 6.3 */

#line 24541 ""
	    ihoff = fnum * 10 + .5f;
#line 24542 ""
	    if (*(unsigned char *)durq == '-') {
#line 24542 ""
		ihoff = -ihoff;
#line 24542 ""
	    }

/*  Later will set bits to 1...127 to represent -6.3,...+6.3 */

#line 24546 ""
	} else {

/*  Must be the 3rd signed integer, so it's a curve specification */

#line 24550 ""
	    isdat3[*nsdat] = bit_set(isdat3[*nsdat],0);
#line 24551 ""
	    ++(*iccount);
#line 24552 ""
	    readnum_(lineq, iccount, dumq, &fnum, (ftnlen)128, (ftnlen)1);
#line 24553 ""
	    icurv1 = i_nint(&fnum);
#line 24554 ""
	    if (*(unsigned char *)durq == '-') {
#line 24554 ""
		icurv1 = -icurv1;
#line 24554 ""
	    }
#line 24555 ""
	    i__1 = icurv1 + 32;
#line 24555 ""
	    setbits_(&isdat3[*nsdat], &c__6, &c__2, &i__1);
#line 24556 ""
	    if (*(unsigned char *)dumq != ':') {

/*  Back up the pointer and loop for more input */

#line 24560 ""
		--(*iccount);
#line 24561 ""
	    } else {

/*  Expect two single digits as parameters for curve */

#line 24565 ""
		isdat3[*nsdat] = bit_set(isdat3[*nsdat],1);
#line 24566 ""
		i__1 = *iccount;
#line 24566 ""
		i__2 = *(unsigned char *)&lineq[i__1] - 48;
#line 24566 ""
		setbits_(&isdat3[*nsdat], &c__3, &c__8, &i__2);
#line 24568 ""
		i__1 = *iccount + 1;
#line 24568 ""
		i__2 = *(unsigned char *)&lineq[i__1] - 48;
#line 24568 ""
		setbits_(&isdat3[*nsdat], &c__3, &c__11, &i__2);
#line 24570 ""
		*iccount += 2;
#line 24571 ""
	    }
#line 24572 ""
	}
#line 24573 ""
	goto L1;
#line 24574 ""
    } else if (*(unsigned char *)durq == 't') {
#line 24575 ""
	isdat2[*nsdat] = bit_set(isdat2[*nsdat],3);
#line 24576 ""
	goto L1;
#line 24577 ""
    } else if (*(unsigned char *)durq == 'b') {
#line 24578 ""
	isdat2[*nsdat] = bit_set(isdat2[*nsdat],4);
#line 24579 ""
	goto L1;
#line 24580 ""
    } else if (*(unsigned char *)durq == 's') {

/*  Endpoint tweaks for linebreak slurs. */

#line 24584 ""
	getchar_(lineq, iccount, durq, (ftnlen)128, (ftnlen)1);

/*  Next is vertical offset */

/* Must be +|- */
#line 24588 ""
	++(*iccount);
#line 24589 ""
	readnum_(lineq, iccount, dumq, &fnum, (ftnlen)128, (ftnlen)1);
#line 24590 ""
	if (*(unsigned char *)durq == '-') {
#line 24590 ""
	    fnum = -fnum;
#line 24590 ""
	}
#line 24591 ""
	i__1 = ilb12 << 4;
#line 24591 ""
	i__2 = i_nint(&fnum) + 32;
#line 24591 ""
	setbits_(&isdat4[*nsdat], &c__6, &i__1, &i__2);
#line 24592 ""
	if (i_indx("+-", dumq, (ftnlen)2, (ftnlen)1) > 0) {

/*  Also a horizontal offset */

#line 24596 ""
	    ++(*iccount);
#line 24597 ""
	    readnum_(lineq, iccount, durq, &fnum, (ftnlen)128, (ftnlen)1);
#line 24598 ""
	    if (*(unsigned char *)dumq == '-') {
#line 24598 ""
		fnum = -fnum;
#line 24598 ""
	    }
#line 24599 ""
	    i__1 = (ilb12 << 4) + 6;
#line 24599 ""
	    r__1 = fnum * 10;
#line 24599 ""
	    i__2 = i_nint(&r__1) + 64;
#line 24599 ""
	    setbits_(&isdat4[*nsdat], &c__7, &i__1, &i__2);
#line 24600 ""
	}
#line 24601 ""
	--(*iccount);
#line 24602 ""
	ilb12 = 1;
#line 24603 ""
	goto L1;
#line 24604 ""
    } else if (i_indx("fnhH", durq, (ftnlen)4, (ftnlen)1) > 0) {

/*  Special ps slur curvatures. */
/*  Translate to old \midslur args (1,4,5,6) */

#line 24609 ""
	icurv1 = i_indx("fnxhH", durq, (ftnlen)5, (ftnlen)1);
#line 24610 ""
	if (icurv1 == 5) {

/*  check for 2nd H */

#line 24614 ""
	    i__1 = *iccount;
#line 24614 ""
	    if (s_cmp(lineq + i__1, "H", *iccount + 1 - i__1, (ftnlen)1) == 0)
		     {
#line 24615 ""
		++(*iccount);
#line 24616 ""
		icurv1 = 6;
#line 24617 ""
	    }
#line 24618 ""
	}
#line 24619 ""
	isdat3[*nsdat] = bit_set(isdat3[*nsdat],0);
#line 24620 ""
	i__1 = icurv1 + 32;
#line 24620 ""
	setbits_(&isdat3[*nsdat], &c__6, &c__2, &i__1);
#line 24621 ""
	goto L1;
#line 24622 ""
    } else if (*(unsigned char *)durq == 'p') {
/* Local adjustment */
#line 24623 ""
	getchar_(lineq, iccount, durq, (ftnlen)128, (ftnlen)1);
/*  +|- */
#line 24624 ""
	getchar_(lineq, iccount, dumq, (ftnlen)128, (ftnlen)1);
/*  26       \sluradjust    (p+s) */
/*  27       \nosluradjust  (p-s) */
/*  28       \tieadjust     (p+t) */
/*  29       \notieadjust   (p-t) */
/*  s|t */
#line 24629 ""
	if (*(unsigned char *)durq == '+') {
#line 24630 ""
	    if (*(unsigned char *)dumq == 's') {
#line 24631 ""
		isdat2[*nsdat] = bit_set(isdat2[*nsdat],26);
#line 24632 ""
	    } else {
#line 24633 ""
		isdat2[*nsdat] = bit_set(isdat2[*nsdat],28);
#line 24634 ""
	    }
#line 24635 ""
	} else {
#line 24636 ""
	    if (*(unsigned char *)dumq == 's') {
#line 24637 ""
		isdat2[*nsdat] = bit_set(isdat2[*nsdat],27);
#line 24638 ""
	    } else {
#line 24639 ""
		isdat2[*nsdat] = bit_set(isdat2[*nsdat],29);
#line 24640 ""
	    }
#line 24641 ""
	}
#line 24642 ""
	goto L1;
#line 24643 ""
    } else if (*(unsigned char *)durq == 'v') {
/* Stem slur */
#line 24644 ""
	isdat1[*nsdat] = bit_set(isdat1[*nsdat],2);
#line 24645 ""
	goto L1;
#line 24646 ""
    }

/*  Record shifts */

#line 24650 ""
    i__1 = ivoff + 32;
#line 24650 ""
    setbits_(&isdat2[*nsdat], &c__6, &c__6, &i__1);
#line 24651 ""
    i__1 = ihoff + 64;
#line 24651 ""
    setbits_(&isdat2[*nsdat], &c__7, &c__12, &i__1);

/*  Record chord flag, note level, notehead shift */

#line 24655 ""
    if (*notcrd) {
#line 24656 ""
	setbits_(&isdat2[*nsdat], &c__7, &c__19, nolev);
#line 24657 ""
    } else {
#line 24658 ""
	nolevc = igetbits_(&comtrill_1.icrdat[comtrill_1.ncrd - 1], &c__7, &
		c__12);
#line 24659 ""
	setbits_(&isdat2[*nsdat], &c__7, &c__19, &nolevc);
#line 24660 ""
	isdat2[*nsdat] = bit_set(isdat2[*nsdat],0);
#line 24661 ""
	i__1 = igetbits_(&comtrill_1.icrdat[comtrill_1.ncrd - 1], &c__2, &
		c__23);
#line 24661 ""
	setbits_(&isdat2[*nsdat], &c__2, &c__1, &i__1);
#line 24662 ""
    }
#line 24663 ""
    return 0;
} /* spsslur_ */

/* Subroutine */ int sslur_(char *lineq, integer *iccount, integer *iv, 
	integer *kv, integer *ip, integer *isdat1, integer *isdat2, integer *
	isdat3, integer *nsdat, logical *notcrd, integer *nolev, char *
	starter, ftnlen lineq_len, ftnlen starter_len)
{
    /* System generated locals */
    integer i__1, i__2;

    /* Builtin functions */
    integer i_indx(char *, char *, ftnlen, ftnlen), i_nint(real *), s_cmp(
	    char *, char *, ftnlen, ftnlen);

    /* Local variables */
    extern integer igetbits_(integer *, integer *, integer *);
    static real fnum;
    static char dumq[1], durq[1];
    static integer ihoff, isdat, ivoff, icurv1, idcode, nolevc, numint;
    extern /* Subroutine */ int getchar_(char *, integer *, char *, ftnlen, 
	    ftnlen), readnum_(char *, integer *, char *, real *, ftnlen, 
	    ftnlen), setbits_(integer *, integer *, integer *, integer *);


/*  Reads in slur data.  Record all h/v-shifts for non-chords, user-specified */
/*  ones for chords. */
/*  5/26/02 now only for non-postscript slurs, use spsslur() for postscript */

/*  See subroutine doslur for bit values in isdat1,2,3 */


/*  Counter for signed integers.  1st is height, 2nd is horiz, 3rd is curve */

#line 24688 ""
    /* Parameter adjustments */
#line 24688 ""
    --isdat3;
#line 24688 ""
    --isdat2;
#line 24688 ""
    --isdat1;
#line 24688 ""

#line 24688 ""
    /* Function Body */
#line 24688 ""
    numint = 0;
#line 24689 ""
    ivoff = 0;
#line 24690 ""
    ihoff = 0;
#line 24691 ""
    ++(*nsdat);
#line 24692 ""
    if (*(unsigned char *)starter == '{' || *(unsigned char *)starter == '}') 
	    {
#line 24692 ""
	isdat2[*nsdat] = bit_set(isdat2[*nsdat],3);
#line 24692 ""
    }
#line 24694 ""
    setbits_(&isdat1[*nsdat], &c__5, &c__13, iv);
#line 24695 ""
    i__1 = *kv - 1;
#line 24695 ""
    setbits_(&isdat1[*nsdat], &c__1, &c__12, &i__1);
#line 24696 ""
    setbits_(&isdat1[*nsdat], &c__8, &c__3, ip);
#line 24697 ""
    isdat3[*nsdat] = 0;

/*  Get id letter */

#line 24701 ""
    if (*(unsigned char *)&lineq[*iccount - 1] == 't') {

/*  Old-style t-slur. Use special idcode = 1 */

#line 24705 ""
	idcode = 1;
#line 24706 ""
    } else {
#line 24707 ""
	getchar_(lineq, iccount, durq, (ftnlen)128, (ftnlen)1);
#line 24708 ""
	if (i_indx("uldtb+-hf ", durq, (ftnlen)10, (ftnlen)1) > 0) {

/*  Null id */

#line 24712 ""
	    idcode = 32;
#line 24713 ""
	    --(*iccount);
#line 24714 ""
	} else if (*(unsigned char *)durq == 'H') {

/*  Postscript slur, cannot use 'H' as code, must check for 2nd 'H' */

#line 24718 ""
	    idcode = 32;
#line 24719 ""
	    --(*iccount);

/*  There may be another "H", but no need to deal with it yet */

#line 24723 ""
	} else {

/*  Set explicit idcode */

#line 24727 ""
	    idcode = *(unsigned char *)durq;
#line 24728 ""
	}
#line 24729 ""
    }
#line 24730 ""
    setbits_(&isdat1[*nsdat], &c__7, &c__19, &idcode);

/*  Set start/stop: look thru list from end for same idcode,iv,kv */

#line 24734 ""
    for (isdat = *nsdat - 1; isdat >= 1; --isdat) {
#line 24735 ""
	if (idcode == igetbits_(&isdat1[isdat], &c__7, &c__19) && *iv == 
		igetbits_(&isdat1[isdat], &c__5, &c__13) && *kv - 1 == 
		igetbits_(&isdat1[isdat], &c__1, &c__12)) {

/*  Matched idcode & ivx.  On/off?.  If on, new is turnoff, leave bit 11 at 0. */

#line 24741 ""
	    if (bit_test(isdat1[isdat],11)) {
#line 24741 ""
		goto L3;
#line 24741 ""
	    }

/*  Found slur is a turnoff, so new one is a turnon.  Jump down to set bit */

#line 24745 ""
	    goto L4;
#line 24746 ""
	}
#line 24747 ""
/* L2: */
#line 24747 ""
    }

/*  If here, this is turnon. */

#line 24751 ""
L4:
#line 24752 ""
    isdat1[*nsdat] = bit_set(isdat1[*nsdat],11);
#line 24753 ""
L3:

/*  Now done with initial turnon- or turnoff-specifics.  Loop for rest of input */

#line 24757 ""
L1:
#line 24757 ""
    getchar_(lineq, iccount, durq, (ftnlen)128, (ftnlen)1);
#line 24758 ""
    if (i_indx("uld", durq, (ftnlen)3, (ftnlen)1) > 0) {

/*  Force direction */

#line 24762 ""
	isdat1[*nsdat] = bit_set(isdat1[*nsdat],26);
#line 24763 ""
	if (*(unsigned char *)durq == 'u') {
#line 24763 ""
	    isdat1[*nsdat] = bit_set(isdat1[*nsdat],27);
#line 24763 ""
	}
#line 24764 ""
	goto L1;
#line 24765 ""
    } else if (i_indx("+-", durq, (ftnlen)2, (ftnlen)1) > 0) {
#line 24766 ""
	++numint;
#line 24767 ""
	if (numint == 1) {

/*  Vertical offset */

#line 24771 ""
	    ++(*iccount);
#line 24772 ""
	    readnum_(lineq, iccount, dumq, &fnum, (ftnlen)128, (ftnlen)1);
#line 24773 ""
	    --(*iccount);
#line 24774 ""
	    ivoff = i_nint(&fnum);
#line 24775 ""
	    if (*(unsigned char *)durq == '-') {
#line 24775 ""
		ivoff = -ivoff;
#line 24775 ""
	    }
#line 24776 ""
	} else if (numint == 2) {

/*  Horizontal offset */

#line 24780 ""
	    ++(*iccount);
#line 24781 ""
	    readnum_(lineq, iccount, dumq, &fnum, (ftnlen)128, (ftnlen)1);
#line 24782 ""
	    --(*iccount);

/*  fnum is abs(hshift), must be 0 to 6.3 */

#line 24786 ""
	    ihoff = fnum * 10 + .5f;
#line 24787 ""
	    if (*(unsigned char *)durq == '-') {
#line 24787 ""
		ihoff = -ihoff;
#line 24787 ""
	    }

/*  Later will set bits to 1...127 to represent -6.3,...+6.3 */

#line 24791 ""
	} else {

/*  Must be the 3rd signed integer, so it's a curve specification */

#line 24795 ""
	    isdat3[*nsdat] = bit_set(isdat3[*nsdat],0);
#line 24796 ""
	    ++(*iccount);
#line 24797 ""
	    readnum_(lineq, iccount, dumq, &fnum, (ftnlen)128, (ftnlen)1);
#line 24798 ""
	    icurv1 = i_nint(&fnum);
#line 24799 ""
	    if (*(unsigned char *)durq == '-') {
#line 24799 ""
		icurv1 = -icurv1;
#line 24799 ""
	    }
#line 24800 ""
	    i__1 = icurv1 + 32;
#line 24800 ""
	    setbits_(&isdat3[*nsdat], &c__6, &c__2, &i__1);
#line 24801 ""
	    if (*(unsigned char *)dumq != ':') {

/*  Back up the pointer and loop for more input */

#line 24805 ""
		--(*iccount);
#line 24806 ""
	    } else {

/*  Expect two single digits as parameters for curve */

#line 24810 ""
		isdat3[*nsdat] = bit_set(isdat3[*nsdat],1);
#line 24811 ""
		i__1 = *iccount;
#line 24811 ""
		i__2 = *(unsigned char *)&lineq[i__1] - 48;
#line 24811 ""
		setbits_(&isdat3[*nsdat], &c__3, &c__8, &i__2);
#line 24813 ""
		i__1 = *iccount + 1;
#line 24813 ""
		i__2 = *(unsigned char *)&lineq[i__1] - 48;
#line 24813 ""
		setbits_(&isdat3[*nsdat], &c__3, &c__11, &i__2);
#line 24815 ""
		*iccount += 2;
#line 24816 ""
	    }
#line 24817 ""
	}
#line 24818 ""
	goto L1;
#line 24819 ""
    } else if (*(unsigned char *)durq == 't') {
#line 24820 ""
	isdat2[*nsdat] = bit_set(isdat2[*nsdat],3);
#line 24821 ""
	goto L1;
#line 24822 ""
    } else if (*(unsigned char *)durq == 'b') {
#line 24823 ""
	isdat2[*nsdat] = bit_set(isdat2[*nsdat],4);
#line 24824 ""
	goto L1;
#line 24825 ""
    } else if (i_indx("fhH", durq, (ftnlen)3, (ftnlen)1) > 0) {

/*  Special ps slur curvatures.  Translate to old \midslur args (1,4,5,6) */

#line 24829 ""
	icurv1 = i_indx("fhH", durq, (ftnlen)3, (ftnlen)1) + 2;
#line 24830 ""
	if (icurv1 == 3) {
#line 24831 ""
	    icurv1 = 1;
#line 24832 ""
	} else if (icurv1 == 5) {

/*  check for 2nd H */

#line 24836 ""
	    i__1 = *iccount;
#line 24836 ""
	    if (s_cmp(lineq + i__1, "H", *iccount + 1 - i__1, (ftnlen)1) == 0)
		     {
#line 24837 ""
		++(*iccount);
#line 24838 ""
		icurv1 = 6;
#line 24839 ""
	    }
#line 24840 ""
	}
#line 24841 ""
	isdat3[*nsdat] = bit_set(isdat3[*nsdat],0);

/*  Must change sign if downslur, but cannot do it now since we don't know */
/*    slur direction for sure. */

#line 24846 ""
	i__1 = icurv1 + 32;
#line 24846 ""
	setbits_(&isdat3[*nsdat], &c__6, &c__2, &i__1);
#line 24847 ""
	goto L1;
#line 24848 ""
    }

/*  Record shifts */

#line 24852 ""
    i__1 = ivoff + 32;
#line 24852 ""
    setbits_(&isdat2[*nsdat], &c__6, &c__6, &i__1);
#line 24853 ""
    i__1 = ihoff + 64;
#line 24853 ""
    setbits_(&isdat2[*nsdat], &c__7, &c__12, &i__1);

/*  Record chord flag, note level, notehead shift */

#line 24857 ""
    if (*notcrd) {
#line 24858 ""
	setbits_(&isdat2[*nsdat], &c__7, &c__19, nolev);
#line 24859 ""
    } else {
#line 24860 ""
	nolevc = igetbits_(&comtrill_1.icrdat[comtrill_1.ncrd - 1], &c__7, &
		c__12);
#line 24861 ""
	setbits_(&isdat2[*nsdat], &c__7, &c__19, &nolevc);
#line 24862 ""
	isdat2[*nsdat] = bit_set(isdat2[*nsdat],0);
#line 24863 ""
	i__1 = igetbits_(&comtrill_1.icrdat[comtrill_1.ncrd - 1], &c__2, &
		c__23);
#line 24863 ""
	setbits_(&isdat2[*nsdat], &c__2, &c__1, &i__1);
#line 24864 ""
    }
#line 24865 ""
    return 0;
} /* sslur_ */

/* Subroutine */ int stop1_(void)
{
    extern /* Subroutine */ int exit_(integer *);

#line 24868 ""
    exit_(&c__1);
#line 24869 ""
    return 0;
} /* stop1_ */

/* Subroutine */ int topfile_(char *basenameq, integer *lbase, integer *nv, 
	char *clefq, integer *noinst, integer *musicsize, real *xinstf1, 
	integer *mtrnmp, integer *mtrdnp, logical *vshrink, real *fbar, 
	logical *fontslur, ftnlen basenameq_len, ftnlen clefq_len)
{
    /* System generated locals */
    address a__1[3], a__2[2], a__3[4], a__4[2], a__5[6], a__6[5], a__7[10], 
	    a__8[20], a__9[12], a__10[8];
    integer i__1[3], i__2[2], i__3[4], i__4, i__5[2], i__6, i__7[6], i__8, 
	    i__9[5], i__10[10], i__11[20], i__12[12], i__13[8];
    real r__1;
    char ch__1[1], ch__2[50], ch__3[15], ch__4[10], ch__5[39], ch__6[14], 
	    ch__7[17], ch__8[16], ch__9[8], ch__10[12], ch__11[9], ch__12[13],
	     ch__13[11], ch__14[21], ch__15[7], ch__16[6], ch__17[30], ch__18[
	    19], ch__19[1], ch__20[2], ch__21[33], ch__22[25], ch__23[35], 
	    ch__24[81], ch__25[82], ch__26[18], ch__27[57], ch__28[44], 
	    ch__29[62], ch__30[54], ch__31[86], ch__32[41], ch__33[47];
    cilist ci__1;

    /* Builtin functions */
    integer s_wsfe(cilist *), do_fio(integer *, char *, ftnlen), e_wsfe(void);
    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
    integer s_wsfi(icilist *), e_wsfi(void), i_nint(real *);
    double r_lg10(real *);
    /* Subroutine */ int s_copy(char *, char *, ftnlen, ftnlen);

    /* Local variables */
    static integer k, im, iv;
    static char sq[1];
    static integer ipi;
    extern /* Character */ VOID chax_(char *, ftnlen, integer *);
    static char fmtq[24];
    extern /* Subroutine */ int writesetsign_(integer *, integer *, integer *,
	     logical *);
    static real facis;
    static char fbarq[5];
    static integer lname, lfmtq, iinst;
    static char clefqiv[1];
    extern integer numclef_(char *, ftnlen);
    extern /* Subroutine */ int wgmeter_(integer *, integer *);
    static integer nstaves;

    /* Fortran I/O blocks */
    static cilist io___1811 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1812 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1813 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1814 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1815 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1816 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1817 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1818 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1819 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1820 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1821 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1822 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1823 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1825 = { 0, 11, 0, "(a8,i1,a)", 0 };
    static cilist io___1826 = { 0, 11, 0, "(a9,i2,a)", 0 };
    static cilist io___1827 = { 0, 11, 0, "(a8,i1,a)", 0 };
    static cilist io___1828 = { 0, 11, 0, "(a9,i2,a)", 0 };
    static icilist io___1830 = { 0, fbarq, 0, "(f5.3)", 5, 1 };
    static cilist io___1831 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1832 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1833 = { 0, 11, 0, "(a7,i3,a2)", 0 };
    static cilist io___1834 = { 0, 11, 0, "(a8,i3,a2)", 0 };
    static cilist io___1835 = { 0, 11, 0, "(a8,i2,a2)", 0 };
    static cilist io___1836 = { 0, 11, 0, "(a8,i1,a2)", 0 };
    static cilist io___1837 = { 0, 11, 0, "(a8,i2,a2)", 0 };
    static cilist io___1838 = { 0, 11, 0, "(a8,i3,a2)", 0 };
    static cilist io___1839 = { 0, 11, 0, "(a8,i2,a2)", 0 };
    static cilist io___1840 = { 0, 11, 0, "(a8,i1,a2)", 0 };
    static cilist io___1841 = { 0, 11, 0, "(a8,i2,a2)", 0 };
    static cilist io___1842 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1843 = { 0, 11, 0, "(a19,i1,a1)", 0 };
    static cilist io___1844 = { 0, 11, 0, "(a19,i2,a1)", 0 };
    static cilist io___1847 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1848 = { 0, 11, 0, "(a11,i2,a)", 0 };
    static cilist io___1853 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1854 = { 0, 11, 0, "(a9,i2,a)", 0 };
    static cilist io___1855 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1856 = { 0, 11, 0, "(a21,i2,a)", 0 };
    static cilist io___1858 = { 0, 11, 0, "(a8,i1,a)", 0 };
    static cilist io___1859 = { 0, 11, 0, "(a9,i2,a)", 0 };
    static cilist io___1860 = { 0, 11, 0, "(a18,i2,a2)", 0 };
    static cilist io___1862 = { 0, 11, 0, "(a11,i1,a2)", 0 };
    static cilist io___1863 = { 0, 11, 0, "(a11,i2,a2)", 0 };
    static cilist io___1864 = { 0, 11, 0, "(a11,i3,a2)", 0 };
    static cilist io___1865 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1867 = { 0, 11, 0, fmtq, 0 };
    static cilist io___1868 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1869 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1870 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1871 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1872 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1873 = { 0, 11, 0, "(a)", 0 };


#line 24900 ""
    /* Parameter adjustments */
#line 24900 ""
    --clefq;
#line 24900 ""

#line 24900 ""
    /* Function Body */
#line 24900 ""
    chax_(ch__1, (ftnlen)1, &c__92);
#line 24900 ""
    *(unsigned char *)sq = *(unsigned char *)&ch__1[0];
#line 24901 ""
    *vshrink = *xinstf1 > 20.f && ! comnvst_1.novshrinktop;
#line 24902 ""
    if (*vshrink) {
#line 24903 ""
	comarp_1.xinsnow = 10.f;
#line 24904 ""
    } else {
#line 24905 ""
	comarp_1.xinsnow = *xinstf1;
#line 24906 ""
    }
#line 24907 ""
    if (! comlast_1.islast) {
#line 24907 ""
	return 0;
#line 24907 ""
    }

/* Initialize octave treble clef tracker */

#line 24911 ""
    for (im = 1; im <= 24; ++im) {
#line 24912 ""
	comc8flag_1.c8flag[im - 1] = FALSE_;
#line 24913 ""
/* L6: */
#line 24913 ""
    }
#line 24914 ""
    s_wsfe(&io___1811);
#line 24914 ""
    do_fio(&c__1, "%%%%%%%%%%%%%%%%%", (ftnlen)17);
#line 24914 ""
    e_wsfe();
#line 24915 ""
    s_wsfe(&io___1812);
#line 24915 ""
    do_fio(&c__1, "%", (ftnlen)1);
#line 24915 ""
    e_wsfe();
#line 24916 ""
    s_wsfe(&io___1813);
/* Writing concatenation */
#line 24916 ""
    i__1[0] = 2, a__1[0] = "% ";
#line 24916 ""
    i__1[1] = *lbase, a__1[1] = basenameq;
#line 24916 ""
    i__1[2] = 4, a__1[2] = ".tex";
#line 24916 ""
    s_cat(ch__2, a__1, i__1, &c__3, (ftnlen)50);
#line 24916 ""
    do_fio(&c__1, ch__2, *lbase + 6);
#line 24916 ""
    e_wsfe();
#line 24917 ""
    s_wsfe(&io___1814);
#line 24917 ""
    do_fio(&c__1, "%", (ftnlen)1);
#line 24917 ""
    e_wsfe();
#line 24918 ""
    s_wsfe(&io___1815);
#line 24918 ""
    do_fio(&c__1, "%%%%%%%%%%%%%%%%", (ftnlen)16);
#line 24918 ""
    e_wsfe();
#line 24919 ""
    s_wsfe(&io___1816);
/* Writing concatenation */
#line 24919 ""
    i__2[0] = 1, a__2[0] = sq;
#line 24919 ""
    i__2[1] = 14, a__2[1] = "input musixtex";
#line 24919 ""
    s_cat(ch__3, a__2, i__2, &c__2, (ftnlen)15);
#line 24919 ""
    do_fio(&c__1, ch__3, (ftnlen)15);
#line 24919 ""
    e_wsfe();
#line 24920 ""
    s_wsfe(&io___1817);
/* Writing concatenation */
#line 24920 ""
    i__2[0] = 1, a__2[0] = sq;
#line 24920 ""
    i__2[1] = 9, a__2[1] = "input pmx";
#line 24920 ""
    s_cat(ch__4, a__2, i__2, &c__2, (ftnlen)10);
#line 24920 ""
    do_fio(&c__1, ch__4, (ftnlen)10);
#line 24920 ""
    e_wsfe();
#line 24921 ""
    s_wsfe(&io___1818);
/* Writing concatenation */
#line 24921 ""
    i__3[0] = 1, a__3[0] = sq;
#line 24921 ""
    i__3[1] = 15, a__3[1] = "setmaxslurs{24}";
#line 24921 ""
    i__3[2] = 1, a__3[2] = sq;
#line 24921 ""
    i__3[3] = 22, a__3[3] = "setmaxinstruments{24}%";
#line 24921 ""
    s_cat(ch__5, a__3, i__3, &c__4, (ftnlen)39);
#line 24921 ""
    do_fio(&c__1, ch__5, (ftnlen)39);
#line 24921 ""
    e_wsfe();
#line 24923 ""
    if (! (*fontslur)) {
#line 24923 ""
	s_wsfe(&io___1819);
/* Writing concatenation */
#line 24923 ""
	i__2[0] = 1, a__2[0] = sq;
#line 24923 ""
	i__2[1] = 13, a__2[1] = "input musixps";
#line 24923 ""
	s_cat(ch__6, a__2, i__2, &c__2, (ftnlen)14);
#line 24923 ""
	do_fio(&c__1, ch__6, (ftnlen)14);
#line 24923 ""
	e_wsfe();
#line 24923 ""
    }

/* Need to input musixmad to permit more slurs. */

#line 24927 ""
    if (*musicsize == 20) {
#line 24928 ""
	s_wsfe(&io___1820);
/* Writing concatenation */
#line 24928 ""
	i__2[0] = 1, a__2[0] = sq;
#line 24928 ""
	i__2[1] = 16, a__2[1] = "normalmusicsize%";
#line 24928 ""
	s_cat(ch__7, a__2, i__2, &c__2, (ftnlen)17);
#line 24928 ""
	do_fio(&c__1, ch__7, (ftnlen)17);
#line 24928 ""
	e_wsfe();
#line 24929 ""
    } else if (*musicsize == 16) {
#line 24930 ""
	s_wsfe(&io___1821);
/* Writing concatenation */
#line 24930 ""
	i__2[0] = 1, a__2[0] = sq;
#line 24930 ""
	i__2[1] = 15, a__2[1] = "smallmusicsize%";
#line 24930 ""
	s_cat(ch__8, a__2, i__2, &c__2, (ftnlen)16);
#line 24930 ""
	do_fio(&c__1, ch__8, (ftnlen)16);
#line 24930 ""
	e_wsfe();
#line 24931 ""
    } else if (*musicsize == 24) {
#line 24932 ""
	s_wsfe(&io___1822);
/* Writing concatenation */
#line 24932 ""
	i__2[0] = 1, a__2[0] = sq;
#line 24932 ""
	i__2[1] = 15, a__2[1] = "largemusicsize%";
#line 24932 ""
	s_cat(ch__8, a__2, i__2, &c__2, (ftnlen)16);
#line 24932 ""
	do_fio(&c__1, ch__8, (ftnlen)16);
#line 24932 ""
	e_wsfe();
#line 24933 ""
    } else if (*musicsize == 29) {
#line 24934 ""
	s_wsfe(&io___1823);
/* Writing concatenation */
#line 24934 ""
	i__2[0] = 1, a__2[0] = sq;
#line 24934 ""
	i__2[1] = 15, a__2[1] = "Largemusicsize%";
#line 24934 ""
	s_cat(ch__8, a__2, i__2, &c__2, (ftnlen)16);
#line 24934 ""
	do_fio(&c__1, ch__8, (ftnlen)16);
#line 24934 ""
	e_wsfe();
#line 24935 ""
    }

/*  Set sizes. Have sizes per staff in isize(.) and noinst per staff in */
/*    nsperi(.) */

#line 24940 ""
    i__4 = *noinst;
#line 24940 ""
    for (iinst = 1; iinst <= i__4; ++iinst) {
#line 24941 ""
	if (comsize_1.isize[iinst - 1] == 1) {
#line 24942 ""
	    if (iinst <= 9) {
#line 24943 ""
		s_wsfe(&io___1825);
/* Writing concatenation */
#line 24943 ""
		i__2[0] = 1, a__2[0] = sq;
#line 24943 ""
		i__2[1] = 7, a__2[1] = "setsize";
#line 24943 ""
		s_cat(ch__9, a__2, i__2, &c__2, (ftnlen)8);
#line 24943 ""
		do_fio(&c__1, ch__9, (ftnlen)8);
#line 24943 ""
		do_fio(&c__1, (char *)&iinst, (ftnlen)sizeof(integer));
/* Writing concatenation */
#line 24943 ""
		i__5[0] = 1, a__4[0] = sq;
#line 24943 ""
		i__5[1] = 11, a__4[1] = "smallvalue%";
#line 24943 ""
		s_cat(ch__10, a__4, i__5, &c__2, (ftnlen)12);
#line 24943 ""
		do_fio(&c__1, ch__10, (ftnlen)12);
#line 24943 ""
		e_wsfe();
#line 24945 ""
	    } else {
#line 24946 ""
		s_wsfe(&io___1826);
/* Writing concatenation */
#line 24946 ""
		i__2[0] = 1, a__2[0] = sq;
#line 24946 ""
		i__2[1] = 8, a__2[1] = "setsize{";
#line 24946 ""
		s_cat(ch__11, a__2, i__2, &c__2, (ftnlen)9);
#line 24946 ""
		do_fio(&c__1, ch__11, (ftnlen)9);
#line 24946 ""
		do_fio(&c__1, (char *)&iinst, (ftnlen)sizeof(integer));
/* Writing concatenation */
#line 24946 ""
		i__1[0] = 1, a__1[0] = "}";
#line 24946 ""
		i__1[1] = 1, a__1[1] = sq;
#line 24946 ""
		i__1[2] = 11, a__1[2] = "smallvalue%";
#line 24946 ""
		s_cat(ch__12, a__1, i__1, &c__3, (ftnlen)13);
#line 24946 ""
		do_fio(&c__1, ch__12, (ftnlen)13);
#line 24946 ""
		e_wsfe();
#line 24948 ""
	    }
#line 24949 ""
	} else if (comsize_1.isize[iinst - 1] == 2) {
#line 24950 ""
	    if (iinst <= 9) {
#line 24951 ""
		s_wsfe(&io___1827);
/* Writing concatenation */
#line 24951 ""
		i__2[0] = 1, a__2[0] = sq;
#line 24951 ""
		i__2[1] = 7, a__2[1] = "setsize";
#line 24951 ""
		s_cat(ch__9, a__2, i__2, &c__2, (ftnlen)8);
#line 24951 ""
		do_fio(&c__1, ch__9, (ftnlen)8);
#line 24951 ""
		do_fio(&c__1, (char *)&iinst, (ftnlen)sizeof(integer));
/* Writing concatenation */
#line 24951 ""
		i__5[0] = 1, a__4[0] = sq;
#line 24951 ""
		i__5[1] = 10, a__4[1] = "tinyvalue%";
#line 24951 ""
		s_cat(ch__13, a__4, i__5, &c__2, (ftnlen)11);
#line 24951 ""
		do_fio(&c__1, ch__13, (ftnlen)11);
#line 24951 ""
		e_wsfe();
#line 24953 ""
	    } else {
#line 24954 ""
		s_wsfe(&io___1828);
/* Writing concatenation */
#line 24954 ""
		i__2[0] = 1, a__2[0] = sq;
#line 24954 ""
		i__2[1] = 8, a__2[1] = "setsize{";
#line 24954 ""
		s_cat(ch__11, a__2, i__2, &c__2, (ftnlen)9);
#line 24954 ""
		do_fio(&c__1, ch__11, (ftnlen)9);
#line 24954 ""
		do_fio(&c__1, (char *)&iinst, (ftnlen)sizeof(integer));
/* Writing concatenation */
#line 24954 ""
		i__1[0] = 1, a__1[0] = "}";
#line 24954 ""
		i__1[1] = 1, a__1[1] = sq;
#line 24954 ""
		i__1[2] = 10, a__1[2] = "tinyvalue%";
#line 24954 ""
		s_cat(ch__10, a__1, i__1, &c__3, (ftnlen)12);
#line 24954 ""
		do_fio(&c__1, ch__10, (ftnlen)12);
#line 24954 ""
		e_wsfe();
#line 24956 ""
	    }
#line 24957 ""
	}
#line 24958 ""
/* L5: */
#line 24958 ""
    }
#line 24959 ""
    s_wsfi(&io___1830);
#line 24959 ""
    do_fio(&c__1, (char *)&(*fbar), (ftnlen)sizeof(real));
#line 24959 ""
    e_wsfi();
#line 24960 ""
    s_wsfe(&io___1831);
/* Writing concatenation */
#line 24960 ""
    i__2[0] = 1, a__2[0] = sq;
#line 24960 ""
    i__2[1] = 13, a__2[1] = "nopagenumbers";
#line 24960 ""
    s_cat(ch__6, a__2, i__2, &c__2, (ftnlen)14);
#line 24960 ""
    do_fio(&c__1, ch__6, (ftnlen)14);
#line 24960 ""
    e_wsfe();
#line 24961 ""
    s_wsfe(&io___1832);
/* Writing concatenation */
#line 24961 ""
    i__3[0] = 1, a__3[0] = sq;
#line 24961 ""
    i__3[1] = 14, a__3[1] = "tracingstats=2";
#line 24961 ""
    i__3[2] = 1, a__3[2] = sq;
#line 24961 ""
    i__3[3] = 5, a__3[3] = "relax";
#line 24961 ""
    s_cat(ch__14, a__3, i__3, &c__4, (ftnlen)21);
#line 24961 ""
    do_fio(&c__1, ch__14, (ftnlen)21);
#line 24961 ""
    e_wsfe();
#line 24962 ""
    s_wsfe(&io___1833);
/* Writing concatenation */
#line 24962 ""
    i__2[0] = 1, a__2[0] = sq;
#line 24962 ""
    i__2[1] = 6, a__2[1] = "hsize=";
#line 24962 ""
    s_cat(ch__15, a__2, i__2, &c__2, (ftnlen)7);
#line 24962 ""
    do_fio(&c__1, ch__15, (ftnlen)7);
#line 24962 ""
    i__4 = i_nint(&comtop_1.widthpt);
#line 24962 ""
    do_fio(&c__1, (char *)&i__4, (ftnlen)sizeof(integer));
#line 24962 ""
    do_fio(&c__1, "pt", (ftnlen)2);
#line 24962 ""
    e_wsfe();
#line 24963 ""
    ci__1.cierr = 0;
#line 24963 ""
    ci__1.ciunit = 11;
/* Writing concatenation */
#line 24963 ""
    i__1[0] = 5, a__1[0] = "(a6,i";
#line 24963 ""
    r__1 = comtop_1.height + .1f;
#line 24963 ""
    i__4 = (integer) r_lg10(&r__1) + 49;
#line 24963 ""
    chax_(ch__1, (ftnlen)1, &i__4);
#line 24963 ""
    i__1[1] = 1, a__1[1] = ch__1;
#line 24963 ""
    i__1[2] = 4, a__1[2] = ",a2)";
#line 24963 ""
    ci__1.cifmt = (s_cat(ch__4, a__1, i__1, &c__3, (ftnlen)10), ch__4);
#line 24963 ""
    s_wsfe(&ci__1);
/* Writing concatenation */
#line 24963 ""
    i__2[0] = 1, a__2[0] = sq;
#line 24963 ""
    i__2[1] = 5, a__2[1] = "vsize";
#line 24963 ""
    s_cat(ch__16, a__2, i__2, &c__2, (ftnlen)6);
#line 24963 ""
    do_fio(&c__1, ch__16, (ftnlen)6);
#line 24963 ""
    i__6 = (integer) (comtop_1.height + .1f);
#line 24963 ""
    do_fio(&c__1, (char *)&i__6, (ftnlen)sizeof(integer));
#line 24963 ""
    do_fio(&c__1, "pt", (ftnlen)2);
#line 24963 ""
    e_wsfe();
#line 24965 ""
    if (dabs(comtop_1.hoffpt) > .1f) {
#line 24966 ""
	if (comtop_1.hoffpt <= -10.f) {
#line 24967 ""
	    s_wsfe(&io___1834);
/* Writing concatenation */
#line 24967 ""
	    i__2[0] = 1, a__2[0] = sq;
#line 24967 ""
	    i__2[1] = 7, a__2[1] = "hoffset";
#line 24967 ""
	    s_cat(ch__9, a__2, i__2, &c__2, (ftnlen)8);
#line 24967 ""
	    do_fio(&c__1, ch__9, (ftnlen)8);
#line 24967 ""
	    i__4 = i_nint(&comtop_1.hoffpt);
#line 24967 ""
	    do_fio(&c__1, (char *)&i__4, (ftnlen)sizeof(integer));
#line 24967 ""
	    do_fio(&c__1, "pt", (ftnlen)2);
#line 24967 ""
	    e_wsfe();
#line 24968 ""
	} else if (comtop_1.hoffpt < 0.f) {
#line 24969 ""
	    s_wsfe(&io___1835);
/* Writing concatenation */
#line 24969 ""
	    i__2[0] = 1, a__2[0] = sq;
#line 24969 ""
	    i__2[1] = 7, a__2[1] = "hoffset";
#line 24969 ""
	    s_cat(ch__9, a__2, i__2, &c__2, (ftnlen)8);
#line 24969 ""
	    do_fio(&c__1, ch__9, (ftnlen)8);
#line 24969 ""
	    i__4 = i_nint(&comtop_1.hoffpt);
#line 24969 ""
	    do_fio(&c__1, (char *)&i__4, (ftnlen)sizeof(integer));
#line 24969 ""
	    do_fio(&c__1, "pt", (ftnlen)2);
#line 24969 ""
	    e_wsfe();
#line 24970 ""
	} else if (comtop_1.hoffpt < 10.f) {
#line 24971 ""
	    s_wsfe(&io___1836);
/* Writing concatenation */
#line 24971 ""
	    i__2[0] = 1, a__2[0] = sq;
#line 24971 ""
	    i__2[1] = 7, a__2[1] = "hoffset";
#line 24971 ""
	    s_cat(ch__9, a__2, i__2, &c__2, (ftnlen)8);
#line 24971 ""
	    do_fio(&c__1, ch__9, (ftnlen)8);
#line 24971 ""
	    i__4 = i_nint(&comtop_1.hoffpt);
#line 24971 ""
	    do_fio(&c__1, (char *)&i__4, (ftnlen)sizeof(integer));
#line 24971 ""
	    do_fio(&c__1, "pt", (ftnlen)2);
#line 24971 ""
	    e_wsfe();
#line 24972 ""
	} else {
#line 24973 ""
	    s_wsfe(&io___1837);
/* Writing concatenation */
#line 24973 ""
	    i__2[0] = 1, a__2[0] = sq;
#line 24973 ""
	    i__2[1] = 7, a__2[1] = "hoffset";
#line 24973 ""
	    s_cat(ch__9, a__2, i__2, &c__2, (ftnlen)8);
#line 24973 ""
	    do_fio(&c__1, ch__9, (ftnlen)8);
#line 24973 ""
	    i__4 = i_nint(&comtop_1.hoffpt);
#line 24973 ""
	    do_fio(&c__1, (char *)&i__4, (ftnlen)sizeof(integer));
#line 24973 ""
	    do_fio(&c__1, "pt", (ftnlen)2);
#line 24973 ""
	    e_wsfe();
#line 24974 ""
	}
#line 24975 ""
    }
#line 24976 ""
    if (dabs(comtop_1.voffpt) > .1f) {
#line 24977 ""
	if (comtop_1.voffpt <= -10.f) {
#line 24978 ""
	    s_wsfe(&io___1838);
/* Writing concatenation */
#line 24978 ""
	    i__2[0] = 1, a__2[0] = sq;
#line 24978 ""
	    i__2[1] = 7, a__2[1] = "voffset";
#line 24978 ""
	    s_cat(ch__9, a__2, i__2, &c__2, (ftnlen)8);
#line 24978 ""
	    do_fio(&c__1, ch__9, (ftnlen)8);
#line 24978 ""
	    i__4 = i_nint(&comtop_1.voffpt);
#line 24978 ""
	    do_fio(&c__1, (char *)&i__4, (ftnlen)sizeof(integer));
#line 24978 ""
	    do_fio(&c__1, "pt", (ftnlen)2);
#line 24978 ""
	    e_wsfe();
#line 24979 ""
	} else if (comtop_1.voffpt < 0.f) {
#line 24980 ""
	    s_wsfe(&io___1839);
/* Writing concatenation */
#line 24980 ""
	    i__2[0] = 1, a__2[0] = sq;
#line 24980 ""
	    i__2[1] = 7, a__2[1] = "voffset";
#line 24980 ""
	    s_cat(ch__9, a__2, i__2, &c__2, (ftnlen)8);
#line 24980 ""
	    do_fio(&c__1, ch__9, (ftnlen)8);
#line 24980 ""
	    i__4 = i_nint(&comtop_1.voffpt);
#line 24980 ""
	    do_fio(&c__1, (char *)&i__4, (ftnlen)sizeof(integer));
#line 24980 ""
	    do_fio(&c__1, "pt", (ftnlen)2);
#line 24980 ""
	    e_wsfe();
#line 24981 ""
	} else if (comtop_1.voffpt < 10.f) {
#line 24982 ""
	    s_wsfe(&io___1840);
/* Writing concatenation */
#line 24982 ""
	    i__2[0] = 1, a__2[0] = sq;
#line 24982 ""
	    i__2[1] = 7, a__2[1] = "voffset";
#line 24982 ""
	    s_cat(ch__9, a__2, i__2, &c__2, (ftnlen)8);
#line 24982 ""
	    do_fio(&c__1, ch__9, (ftnlen)8);
#line 24982 ""
	    i__4 = i_nint(&comtop_1.voffpt);
#line 24982 ""
	    do_fio(&c__1, (char *)&i__4, (ftnlen)sizeof(integer));
#line 24982 ""
	    do_fio(&c__1, "pt", (ftnlen)2);
#line 24982 ""
	    e_wsfe();
#line 24983 ""
	} else {
#line 24984 ""
	    s_wsfe(&io___1841);
/* Writing concatenation */
#line 24984 ""
	    i__2[0] = 1, a__2[0] = sq;
#line 24984 ""
	    i__2[1] = 7, a__2[1] = "voffset";
#line 24984 ""
	    s_cat(ch__9, a__2, i__2, &c__2, (ftnlen)8);
#line 24984 ""
	    do_fio(&c__1, ch__9, (ftnlen)8);
#line 24984 ""
	    i__4 = i_nint(&comtop_1.voffpt);
#line 24984 ""
	    do_fio(&c__1, (char *)&i__4, (ftnlen)sizeof(integer));
#line 24984 ""
	    do_fio(&c__1, "pt", (ftnlen)2);
#line 24984 ""
	    e_wsfe();
#line 24985 ""
	}
#line 24986 ""
    }

/*  The default  raisebarno=3.5 internote, set in pmx.tex.  Increase to 4.5 if */
/*  3 sharps and treble clef, to avoid vertical clash with top space g# */

#line 24991 ""
    if (comtop_1.isig == 3 && *(unsigned char *)&clefq[*nv] == 't') {
#line 24991 ""
	s_wsfe(&io___1842);
/* Writing concatenation */
#line 24991 ""
	i__7[0] = 1, a__5[0] = sq;
#line 24991 ""
	i__7[1] = 3, a__5[1] = "def";
#line 24991 ""
	i__7[2] = 1, a__5[2] = sq;
#line 24991 ""
	i__7[3] = 14, a__5[3] = "raisebarno{4.5";
#line 24991 ""
	i__7[4] = 1, a__5[4] = sq;
#line 24991 ""
	i__7[5] = 10, a__5[5] = "internote}";
#line 24991 ""
	s_cat(ch__17, a__5, i__7, &c__6, (ftnlen)30);
#line 24991 ""
	do_fio(&c__1, ch__17, (ftnlen)30);
#line 24991 ""
	e_wsfe();
#line 24991 ""
    }
#line 24993 ""
    if (*noinst < 10) {
#line 24994 ""
	s_wsfe(&io___1843);
/* Writing concatenation */
#line 24994 ""
	i__3[0] = 1, a__3[0] = sq;
#line 24994 ""
	i__3[1] = 3, a__3[1] = "def";
#line 24994 ""
	i__3[2] = 1, a__3[2] = sq;
#line 24994 ""
	i__3[3] = 14, a__3[3] = "nbinstruments{";
#line 24994 ""
	s_cat(ch__18, a__3, i__3, &c__4, (ftnlen)19);
#line 24994 ""
	do_fio(&c__1, ch__18, (ftnlen)19);
#line 24994 ""
	do_fio(&c__1, (char *)&(*noinst), (ftnlen)sizeof(integer));
#line 24994 ""
	do_fio(&c__1, "}", (ftnlen)1);
#line 24994 ""
	e_wsfe();
#line 24996 ""
    } else {
#line 24997 ""
	s_wsfe(&io___1844);
/* Writing concatenation */
#line 24997 ""
	i__3[0] = 1, a__3[0] = sq;
#line 24997 ""
	i__3[1] = 3, a__3[1] = "def";
#line 24997 ""
	i__3[2] = 1, a__3[2] = sq;
#line 24997 ""
	i__3[3] = 14, a__3[3] = "nbinstruments{";
#line 24997 ""
	s_cat(ch__18, a__3, i__3, &c__4, (ftnlen)19);
#line 24997 ""
	do_fio(&c__1, ch__18, (ftnlen)19);
#line 24997 ""
	do_fio(&c__1, (char *)&(*noinst), (ftnlen)sizeof(integer));
#line 24997 ""
	do_fio(&c__1, "}", (ftnlen)1);
#line 24997 ""
	e_wsfe();
#line 24999 ""
    }
#line 25000 ""
    iv = 0;
#line 25001 ""
    i__4 = *noinst;
#line 25001 ""
    for (iinst = 1; iinst <= i__4; ++iinst) {
#line 25002 ""
	nstaves = comnvi_1.nsperi[iinst - 1];
#line 25003 ""
	if (iinst < 10) {
#line 25004 ""
	    s_wsfe(&io___1847);
/* Writing concatenation */
#line 25004 ""
	    i__3[0] = 1, a__3[0] = sq;
#line 25004 ""
	    i__3[1] = 9, a__3[1] = "setstaffs";
#line 25004 ""
	    i__6 = iinst + 48;
#line 25004 ""
	    chax_(ch__1, (ftnlen)1, &i__6);
#line 25004 ""
	    i__3[2] = 1, a__3[2] = ch__1;
#line 25004 ""
	    i__8 = nstaves + 48;
#line 25004 ""
	    chax_(ch__19, (ftnlen)1, &i__8);
#line 25004 ""
	    i__3[3] = 1, a__3[3] = ch__19;
#line 25004 ""
	    s_cat(ch__10, a__3, i__3, &c__4, (ftnlen)12);
#line 25004 ""
	    do_fio(&c__1, ch__10, (ftnlen)12);
#line 25004 ""
	    e_wsfe();
#line 25006 ""
	} else {
#line 25007 ""
	    s_wsfe(&io___1848);
/* Writing concatenation */
#line 25007 ""
	    i__2[0] = 1, a__2[0] = sq;
#line 25007 ""
	    i__2[1] = 10, a__2[1] = "setstaffs{";
#line 25007 ""
	    s_cat(ch__13, a__2, i__2, &c__2, (ftnlen)11);
#line 25007 ""
	    do_fio(&c__1, ch__13, (ftnlen)11);
#line 25007 ""
	    do_fio(&c__1, (char *)&iinst, (ftnlen)sizeof(integer));
/* Writing concatenation */
#line 25007 ""
	    i__5[0] = 1, a__4[0] = "}";
#line 25007 ""
	    i__6 = nstaves + 48;
#line 25007 ""
	    chax_(ch__1, (ftnlen)1, &i__6);
#line 25007 ""
	    i__5[1] = 1, a__4[1] = ch__1;
#line 25007 ""
	    s_cat(ch__20, a__4, i__5, &c__2, (ftnlen)2);
#line 25007 ""
	    do_fio(&c__1, ch__20, (ftnlen)2);
#line 25007 ""
	    e_wsfe();
#line 25009 ""
	}
#line 25010 ""
	++iv;
#line 25011 ""
	*(unsigned char *)clefqiv = *(unsigned char *)&clefq[iv];
#line 25012 ""
	if (*(unsigned char *)clefqiv == '8') {
#line 25013 ""
	    *(unsigned char *)clefqiv = 't';
#line 25014 ""
	    cominsttrans_1.itransamt[cominsttrans_1.instno[iv - 1] - 1] += 7;
#line 25015 ""
	    comc8flag_1.c8flag[iv - 1] = TRUE_;
#line 25016 ""
	}
#line 25017 ""
	if (nstaves == 1) {
#line 25018 ""
	    i__6 = numclef_(clefq + iv, (ftnlen)1) + 48;
#line 25018 ""
	    chax_(ch__1, (ftnlen)1, &i__6);
#line 25018 ""
	    s_copy(fmtq, ch__1, (ftnlen)24, (ftnlen)1);
#line 25019 ""
	    lfmtq = 1;
#line 25020 ""
	} else {
/* Writing concatenation */
#line 25021 ""
	    i__2[0] = 1, a__2[0] = "{";
#line 25021 ""
	    i__6 = numclef_(clefq + iv, (ftnlen)1) + 48;
#line 25021 ""
	    chax_(ch__1, (ftnlen)1, &i__6);
#line 25021 ""
	    i__2[1] = 1, a__2[1] = ch__1;
#line 25021 ""
	    s_cat(fmtq, a__2, i__2, &c__2, (ftnlen)24);
#line 25022 ""
	    lfmtq = 2;
#line 25023 ""
	    i__6 = nstaves;
#line 25023 ""
	    for (k = 2; k <= i__6; ++k) {
#line 25024 ""
		++iv;
/* Writing concatenation */
#line 25025 ""
		i__2[0] = lfmtq, a__2[0] = fmtq;
#line 25025 ""
		i__8 = numclef_(clefq + iv, (ftnlen)1) + 48;
#line 25025 ""
		chax_(ch__1, (ftnlen)1, &i__8);
#line 25025 ""
		i__2[1] = 1, a__2[1] = ch__1;
#line 25025 ""
		s_cat(fmtq, a__2, i__2, &c__2, (ftnlen)24);
#line 25026 ""
		++lfmtq;
#line 25027 ""
/* L2: */
#line 25027 ""
	    }
/* Writing concatenation */
#line 25028 ""
	    i__2[0] = lfmtq, a__2[0] = fmtq;
#line 25028 ""
	    i__2[1] = 1, a__2[1] = "}";
#line 25028 ""
	    s_cat(fmtq, a__2, i__2, &c__2, (ftnlen)24);
#line 25029 ""
	    ++lfmtq;
#line 25030 ""
	}
#line 25031 ""
	if (iinst < 10) {
#line 25032 ""
	    s_wsfe(&io___1853);
/* Writing concatenation */
#line 25032 ""
	    i__3[0] = 1, a__3[0] = sq;
#line 25032 ""
	    i__3[1] = 7, a__3[1] = "setclef";
#line 25032 ""
	    i__6 = iinst + 48;
#line 25032 ""
	    chax_(ch__1, (ftnlen)1, &i__6);
#line 25032 ""
	    i__3[2] = 1, a__3[2] = ch__1;
#line 25032 ""
	    i__3[3] = lfmtq, a__3[3] = fmtq;
#line 25032 ""
	    s_cat(ch__21, a__3, i__3, &c__4, (ftnlen)33);
#line 25032 ""
	    do_fio(&c__1, ch__21, lfmtq + 9);
#line 25032 ""
	    e_wsfe();
#line 25033 ""
	} else {
#line 25034 ""
	    s_wsfe(&io___1854);
/* Writing concatenation */
#line 25034 ""
	    i__2[0] = 1, a__2[0] = sq;
#line 25034 ""
	    i__2[1] = 8, a__2[1] = "setclef{";
#line 25034 ""
	    s_cat(ch__11, a__2, i__2, &c__2, (ftnlen)9);
#line 25034 ""
	    do_fio(&c__1, ch__11, (ftnlen)9);
#line 25034 ""
	    do_fio(&c__1, (char *)&iinst, (ftnlen)sizeof(integer));
/* Writing concatenation */
#line 25034 ""
	    i__5[0] = 1, a__4[0] = "}";
#line 25034 ""
	    i__5[1] = lfmtq, a__4[1] = fmtq;
#line 25034 ""
	    s_cat(ch__22, a__4, i__5, &c__2, (ftnlen)25);
#line 25034 ""
	    do_fio(&c__1, ch__22, lfmtq + 1);
#line 25034 ""
	    e_wsfe();
#line 25035 ""
	}
#line 25036 ""
	if (*(unsigned char *)&clefq[iv] == '8') {
#line 25037 ""
	    if (iinst < 10) {
#line 25038 ""
		s_wsfe(&io___1855);
/* Writing concatenation */
#line 25038 ""
		i__9[0] = 1, a__6[0] = sq;
#line 25038 ""
		i__9[1] = 19, a__6[1] = "settrebleclefsymbol";
#line 25038 ""
		i__6 = iinst + 48;
#line 25038 ""
		chax_(ch__1, (ftnlen)1, &i__6);
#line 25038 ""
		i__9[2] = 1, a__6[2] = ch__1;
#line 25038 ""
		i__9[3] = 1, a__6[3] = sq;
#line 25038 ""
		i__9[4] = 13, a__6[4] = "treblelowoct%";
#line 25038 ""
		s_cat(ch__23, a__6, i__9, &c__5, (ftnlen)35);
#line 25038 ""
		do_fio(&c__1, ch__23, (ftnlen)35);
#line 25038 ""
		e_wsfe();
#line 25040 ""
	    } else {
#line 25041 ""
		s_wsfe(&io___1856);
/* Writing concatenation */
#line 25041 ""
		i__2[0] = 1, a__2[0] = sq;
#line 25041 ""
		i__2[1] = 20, a__2[1] = "settrebleclefsymbol{";
#line 25041 ""
		s_cat(ch__14, a__2, i__2, &c__2, (ftnlen)21);
#line 25041 ""
		do_fio(&c__1, ch__14, (ftnlen)21);
#line 25041 ""
		do_fio(&c__1, (char *)&iinst, (ftnlen)sizeof(integer));
/* Writing concatenation */
#line 25041 ""
		i__1[0] = 1, a__1[0] = "}";
#line 25041 ""
		i__1[1] = 1, a__1[1] = sq;
#line 25041 ""
		i__1[2] = 13, a__1[2] = "treblelowoct%";
#line 25041 ""
		s_cat(ch__3, a__1, i__1, &c__3, (ftnlen)15);
#line 25041 ""
		do_fio(&c__1, ch__3, (ftnlen)15);
#line 25041 ""
		e_wsfe();
#line 25043 ""
	    }
#line 25044 ""
	    comc8flag_1.c8flag[iv - 1] = TRUE_;
#line 25045 ""
	}
#line 25046 ""
	for (lname = 79; lname >= 2; --lname) {
#line 25047 ""
	    if (*(unsigned char *)&comtop_1.inameq[(iinst - 1) * 79 + (lname 
		    - 1)] != ' ') {
#line 25047 ""
		goto L4;
#line 25047 ""
	    }
#line 25048 ""
/* L3: */
#line 25048 ""
	}
#line 25049 ""
L4:
#line 25050 ""
	comtop_1.lnam[iinst - 1] = lname;
#line 25051 ""
	if (iinst < 10) {
#line 25052 ""
	    s_wsfe(&io___1858);
/* Writing concatenation */
#line 25052 ""
	    i__2[0] = 1, a__2[0] = sq;
#line 25052 ""
	    i__2[1] = 7, a__2[1] = "setname";
#line 25052 ""
	    s_cat(ch__9, a__2, i__2, &c__2, (ftnlen)8);
#line 25052 ""
	    do_fio(&c__1, ch__9, (ftnlen)8);
#line 25052 ""
	    do_fio(&c__1, (char *)&iinst, (ftnlen)sizeof(integer));
/* Writing concatenation */
#line 25052 ""
	    i__1[0] = 1, a__1[0] = "{";
#line 25052 ""
	    i__1[1] = lname, a__1[1] = comtop_1.inameq + (iinst - 1) * 79;
#line 25052 ""
	    i__1[2] = 1, a__1[2] = "}";
#line 25052 ""
	    s_cat(ch__24, a__1, i__1, &c__3, (ftnlen)81);
#line 25052 ""
	    do_fio(&c__1, ch__24, lname + 2);
#line 25052 ""
	    e_wsfe();
#line 25054 ""
	} else {
#line 25055 ""
	    s_wsfe(&io___1859);
/* Writing concatenation */
#line 25055 ""
	    i__2[0] = 1, a__2[0] = sq;
#line 25055 ""
	    i__2[1] = 8, a__2[1] = "setname{";
#line 25055 ""
	    s_cat(ch__11, a__2, i__2, &c__2, (ftnlen)9);
#line 25055 ""
	    do_fio(&c__1, ch__11, (ftnlen)9);
#line 25055 ""
	    do_fio(&c__1, (char *)&iinst, (ftnlen)sizeof(integer));
/* Writing concatenation */
#line 25055 ""
	    i__1[0] = 2, a__1[0] = "}{";
#line 25055 ""
	    i__1[1] = lname, a__1[1] = comtop_1.inameq + (iinst - 1) * 79;
#line 25055 ""
	    i__1[2] = 1, a__1[2] = "}";
#line 25055 ""
	    s_cat(ch__25, a__1, i__1, &c__3, (ftnlen)82);
#line 25055 ""
	    do_fio(&c__1, ch__25, lname + 3);
#line 25055 ""
	    e_wsfe();
#line 25057 ""
	}
#line 25058 ""
/* L1: */
#line 25058 ""
    }
#line 25059 ""
    s_wsfe(&io___1860);
/* Writing concatenation */
#line 25059 ""
    i__2[0] = 1, a__2[0] = sq;
#line 25059 ""
    i__2[1] = 17, a__2[1] = "generalsignature{";
#line 25059 ""
    s_cat(ch__26, a__2, i__2, &c__2, (ftnlen)18);
#line 25059 ""
    do_fio(&c__1, ch__26, (ftnlen)18);
#line 25059 ""
    do_fio(&c__1, (char *)&comtop_1.isig, (ftnlen)sizeof(integer));
#line 25059 ""
    do_fio(&c__1, "}%", (ftnlen)2);
#line 25059 ""
    e_wsfe();
#line 25060 ""
    if (cominsttrans_1.earlytranson) {
#line 25060 ""
	writesetsign_(&cominsttrans_1.ninsttrans, cominsttrans_1.iinsttrans, 
		cominsttrans_1.itranskey, &cominsttrans_1.earlytranson);
#line 25060 ""
    }
#line 25062 ""
    wgmeter_(mtrnmp, mtrdnp);
#line 25063 ""
    r__1 = comtop_1.fracindent * comtop_1.widthpt;
#line 25063 ""
    ipi = i_nint(&r__1);
#line 25064 ""
    if (ipi < 10) {
#line 25065 ""
	s_wsfe(&io___1862);
/* Writing concatenation */
#line 25065 ""
	i__2[0] = 1, a__2[0] = sq;
#line 25065 ""
	i__2[1] = 10, a__2[1] = "parindent ";
#line 25065 ""
	s_cat(ch__13, a__2, i__2, &c__2, (ftnlen)11);
#line 25065 ""
	do_fio(&c__1, ch__13, (ftnlen)11);
#line 25065 ""
	do_fio(&c__1, (char *)&ipi, (ftnlen)sizeof(integer));
#line 25065 ""
	do_fio(&c__1, "pt", (ftnlen)2);
#line 25065 ""
	e_wsfe();
#line 25066 ""
    } else if (ipi < 100) {
#line 25067 ""
	s_wsfe(&io___1863);
/* Writing concatenation */
#line 25067 ""
	i__2[0] = 1, a__2[0] = sq;
#line 25067 ""
	i__2[1] = 10, a__2[1] = "parindent ";
#line 25067 ""
	s_cat(ch__13, a__2, i__2, &c__2, (ftnlen)11);
#line 25067 ""
	do_fio(&c__1, ch__13, (ftnlen)11);
#line 25067 ""
	do_fio(&c__1, (char *)&ipi, (ftnlen)sizeof(integer));
#line 25067 ""
	do_fio(&c__1, "pt", (ftnlen)2);
#line 25067 ""
	e_wsfe();
#line 25068 ""
    } else {
#line 25069 ""
	s_wsfe(&io___1864);
/* Writing concatenation */
#line 25069 ""
	i__2[0] = 1, a__2[0] = sq;
#line 25069 ""
	i__2[1] = 10, a__2[1] = "parindent ";
#line 25069 ""
	s_cat(ch__13, a__2, i__2, &c__2, (ftnlen)11);
#line 25069 ""
	do_fio(&c__1, ch__13, (ftnlen)11);
#line 25069 ""
	do_fio(&c__1, (char *)&ipi, (ftnlen)sizeof(integer));
#line 25069 ""
	do_fio(&c__1, "pt", (ftnlen)2);
#line 25069 ""
	e_wsfe();
#line 25070 ""
    }
#line 25071 ""
    s_wsfe(&io___1865);
/* Writing concatenation */
#line 25071 ""
    i__10[0] = 1, a__7[0] = sq;
#line 25071 ""
    i__10[1] = 11, a__7[1] = "elemskip1pt";
#line 25071 ""
    i__10[2] = 1, a__7[2] = sq;
#line 25071 ""
    i__10[3] = 13, a__7[3] = "afterruleskip";
#line 25071 ""
    i__10[4] = 5, a__7[4] = fbarq;
#line 25071 ""
    i__10[5] = 2, a__7[5] = "pt";
#line 25071 ""
    i__10[6] = 1, a__7[6] = sq;
#line 25071 ""
    i__10[7] = 17, a__7[7] = "beforeruleskip0pt";
#line 25071 ""
    i__10[8] = 1, a__7[8] = sq;
#line 25071 ""
    i__10[9] = 5, a__7[9] = "relax";
#line 25071 ""
    s_cat(ch__27, a__7, i__10, &c__10, (ftnlen)57);
#line 25071 ""
    do_fio(&c__1, ch__27, (ftnlen)57);
#line 25071 ""
    e_wsfe();
#line 25073 ""
    if (! (*vshrink)) {
#line 25074 ""
	if (*xinstf1 < 9.95f) {
#line 25075 ""
	    s_copy(fmtq, "(a,f3.1,a)", (ftnlen)24, (ftnlen)10);
#line 25076 ""
	} else {
#line 25077 ""
	    s_copy(fmtq, "(a,f4.1,a)", (ftnlen)24, (ftnlen)10);
#line 25078 ""
	}
#line 25079 ""
	facis = 1.f;
#line 25080 ""
	if (comis4bignv_1.is4bignv) {
#line 25080 ""
	    facis = .95f;
#line 25080 ""
	}
#line 25081 ""
	s_wsfe(&io___1867);
/* Writing concatenation */
#line 25081 ""
	i__7[0] = 1, a__5[0] = sq;
#line 25081 ""
	i__7[1] = 15, a__5[1] = "stafftopmarg0pt";
#line 25081 ""
	i__7[2] = 1, a__5[2] = sq;
#line 25081 ""
	i__7[3] = 15, a__5[3] = "staffbotmarg0pt";
#line 25081 ""
	i__7[4] = 1, a__5[4] = sq;
#line 25081 ""
	i__7[5] = 11, a__5[5] = "interstaff{";
#line 25081 ""
	s_cat(ch__28, a__5, i__7, &c__6, (ftnlen)44);
#line 25081 ""
	do_fio(&c__1, ch__28, (ftnlen)44);
#line 25081 ""
	r__1 = *xinstf1 * facis;
#line 25081 ""
	do_fio(&c__1, (char *)&r__1, (ftnlen)sizeof(real));
/* Writing concatenation */
#line 25081 ""
	i__1[0] = 1, a__1[0] = "}";
#line 25081 ""
	i__1[1] = 1, a__1[1] = sq;
#line 25081 ""
	i__1[2] = 5, a__1[2] = "relax";
#line 25081 ""
	s_cat(ch__15, a__1, i__1, &c__3, (ftnlen)7);
#line 25081 ""
	do_fio(&c__1, ch__15, (ftnlen)7);
#line 25081 ""
	e_wsfe();
#line 25083 ""
    } else {
#line 25084 ""
	s_wsfe(&io___1868);
/* Writing concatenation */
#line 25084 ""
	i__10[0] = 1, a__7[0] = sq;
#line 25084 ""
	i__10[1] = 15, a__7[1] = "stafftopmarg0pt";
#line 25084 ""
	i__10[2] = 1, a__7[2] = sq;
#line 25084 ""
	i__10[3] = 13, a__7[3] = "staffbotmarg5";
#line 25084 ""
	i__10[4] = 1, a__7[4] = sq;
#line 25084 ""
	i__10[5] = 10, a__7[5] = "Interligne";
#line 25084 ""
	i__10[6] = 1, a__7[6] = sq;
#line 25084 ""
	i__10[7] = 14, a__7[7] = "interstaff{10}";
#line 25084 ""
	i__10[8] = 1, a__7[8] = sq;
#line 25084 ""
	i__10[9] = 5, a__7[9] = "relax";
#line 25084 ""
	s_cat(ch__29, a__7, i__10, &c__10, (ftnlen)62);
#line 25084 ""
	do_fio(&c__1, ch__29, (ftnlen)62);
#line 25084 ""
	e_wsfe();
#line 25087 ""
    }
#line 25088 ""
    if (*nv == 1) {
#line 25088 ""
	s_wsfe(&io___1869);
/* Writing concatenation */
#line 25088 ""
	i__2[0] = 1, a__2[0] = sq;
#line 25088 ""
	i__2[1] = 11, a__2[1] = "nostartrule";
#line 25088 ""
	s_cat(ch__10, a__2, i__2, &c__2, (ftnlen)12);
#line 25088 ""
	do_fio(&c__1, ch__10, (ftnlen)12);
#line 25088 ""
	e_wsfe();
#line 25088 ""
    }
#line 25089 ""
    s_wsfe(&io___1870);
/* Writing concatenation */
#line 25089 ""
    i__3[0] = 1, a__3[0] = sq;
#line 25089 ""
    i__3[1] = 8, a__3[1] = "readmod{";
#line 25089 ""
    i__3[2] = *lbase, a__3[2] = basenameq;
#line 25089 ""
    i__3[3] = 1, a__3[3] = "}";
#line 25089 ""
    s_cat(ch__30, a__3, i__3, &c__4, (ftnlen)54);
#line 25089 ""
    do_fio(&c__1, ch__30, *lbase + 10);
#line 25089 ""
    e_wsfe();
#line 25090 ""
    if (comnvst_1.cstuplet) {
#line 25091 ""
	s_wsfe(&io___1871);
/* Writing concatenation */
#line 25091 ""
	i__11[0] = 1, a__8[0] = sq;
#line 25091 ""
	i__11[1] = 12, a__8[1] = "input tuplet";
#line 25091 ""
	i__11[2] = 1, a__8[2] = sq;
#line 25091 ""
	i__11[3] = 3, a__8[3] = "def";
#line 25091 ""
	i__11[4] = 1, a__8[4] = sq;
#line 25091 ""
	i__11[5] = 12, a__8[5] = "xnumt#1#2#3{";
#line 25091 ""
	i__11[6] = 1, a__8[6] = sq;
#line 25091 ""
	i__11[7] = 16, a__8[7] = "zcharnote{#2}{~}";
#line 25091 ""
	i__11[8] = 1, a__8[8] = sq;
#line 25091 ""
	i__11[9] = 3, a__8[9] = "def";
#line 25091 ""
	i__11[10] = 1, a__8[10] = sq;
#line 25091 ""
	i__11[11] = 10, a__8[11] = "tuplettxt{";
#line 25091 ""
	i__11[12] = 1, a__8[12] = sq;
#line 25091 ""
	i__11[13] = 9, a__8[13] = "smalltype";
#line 25091 ""
	i__11[14] = 1, a__8[14] = sq;
#line 25091 ""
	i__11[15] = 6, a__8[15] = "it{#3}";
#line 25091 ""
	i__11[16] = 1, a__8[16] = sq;
#line 25091 ""
	chax_(ch__1, (ftnlen)1, &c__47);
#line 25091 ""
	i__11[17] = 1, a__8[17] = ch__1;
#line 25091 ""
	i__11[18] = 1, a__8[18] = sq;
#line 25091 ""
	i__11[19] = 4, a__8[19] = "/}}%";
#line 25091 ""
	s_cat(ch__31, a__8, i__11, &c__20, (ftnlen)86);
#line 25091 ""
	do_fio(&c__1, ch__31, (ftnlen)86);
#line 25091 ""
	e_wsfe();
#line 25095 ""
	s_wsfe(&io___1872);
/* Writing concatenation */
#line 25095 ""
	i__12[0] = 1, a__9[0] = sq;
#line 25095 ""
	i__12[1] = 3, a__9[1] = "let";
#line 25095 ""
	i__12[2] = 1, a__9[2] = sq;
#line 25095 ""
	i__12[3] = 5, a__9[3] = "ovbkt";
#line 25095 ""
	i__12[4] = 1, a__9[4] = sq;
#line 25095 ""
	i__12[5] = 8, a__9[5] = "uptuplet";
#line 25095 ""
	i__12[6] = 1, a__9[6] = sq;
#line 25095 ""
	i__12[7] = 3, a__9[7] = "let";
#line 25095 ""
	i__12[8] = 1, a__9[8] = sq;
#line 25095 ""
	i__12[9] = 5, a__9[9] = "unbkt";
#line 25095 ""
	i__12[10] = 1, a__9[10] = sq;
#line 25095 ""
	i__12[11] = 11, a__9[11] = "downtuplet%";
#line 25095 ""
	s_cat(ch__32, a__9, i__12, &c__12, (ftnlen)41);
#line 25095 ""
	do_fio(&c__1, ch__32, (ftnlen)41);
#line 25095 ""
	e_wsfe();
#line 25097 ""
    }
#line 25098 ""
    s_wsfe(&io___1873);
/* Writing concatenation */
#line 25098 ""
    i__13[0] = 1, a__10[0] = sq;
#line 25098 ""
    i__13[1] = 11, a__10[1] = "startmuflex";
#line 25098 ""
    i__13[2] = 1, a__10[2] = sq;
#line 25098 ""
    i__13[3] = 10, a__10[3] = "startpiece";
#line 25098 ""
    i__13[4] = 1, a__10[4] = sq;
#line 25098 ""
    i__13[5] = 8, a__10[5] = "addspace";
#line 25098 ""
    i__13[6] = 1, a__10[6] = sq;
#line 25098 ""
    i__13[7] = 14, a__10[7] = "afterruleskip%";
#line 25098 ""
    s_cat(ch__33, a__10, i__13, &c__8, (ftnlen)47);
#line 25098 ""
    do_fio(&c__1, ch__33, (ftnlen)47);
#line 25098 ""
    e_wsfe();
#line 25100 ""
    return 0;
} /* topfile_ */

/* Character */ VOID udfq_(char *ret_val, ftnlen ret_val_len, integer *nolev, 
	integer *ncm)
{
    static integer ntest;


/*  Slur directions */

#line 25108 ""
    ntest = *nolev - *ncm;
#line 25109 ""
    if (ntest < 0 || ntest == 0 && combc_1.bcspec && *ncm == 23) {
#line 25111 ""
	*(unsigned char *)ret_val = 'd';
#line 25112 ""
    } else {
#line 25113 ""
	*(unsigned char *)ret_val = 'u';
#line 25114 ""
    }
#line 25115 ""
    return ;
} /* udfq_ */

/* Character */ VOID udqq_(char *ret_val, ftnlen ret_val_len, integer *nole, 
	integer *ncm, integer *isl, integer *nvmx, integer *ivx, integer *nv)
{
    /* System generated locals */
    real r__1;
    char ch__2[1];

    /* Local variables */
    extern /* Character */ VOID ulfq_(char *, ftnlen, real *, integer *);
    static char udqqq[1];


/*  Stem direction for single notes */

#line 25124 ""
    if (bit_test(*isl,30)) {

/*  Absolute override */

#line 25128 ""
	if (bit_test(*isl,17)) {
#line 25129 ""
	    *(unsigned char *)udqqq = 'u';
#line 25130 ""
	} else {
#line 25131 ""
	    *(unsigned char *)udqqq = 'l';
#line 25132 ""
	}
#line 25133 ""
    } else if (*nvmx == 1) {

/*  Single voice per staff, default */

#line 25137 ""
	r__1 = *nole * 1.f;
#line 25137 ""
	ulfq_(ch__2, (ftnlen)1, &r__1, ncm);
#line 25137 ""
	*(unsigned char *)udqqq = *(unsigned char *)&ch__2[0];
#line 25138 ""
    } else {

/*  Multi-voice per staff, 1st is lower, 2nd upper */

#line 25142 ""
	if (*ivx <= *nv) {
#line 25143 ""
	    *(unsigned char *)udqqq = 'l';
#line 25144 ""
	} else {
#line 25145 ""
	    *(unsigned char *)udqqq = 'u';
#line 25146 ""
	}
#line 25147 ""
    }
#line 25148 ""
    *(unsigned char *)ret_val = *(unsigned char *)udqqq;
#line 25149 ""
    return ;
} /* udqq_ */

/* Character */ VOID ulfq_(char *ret_val, ftnlen ret_val_len, real *xnolev, 
	integer *ncm)
{
    static real test;


/*  Stem directions */

#line 25157 ""
    test = *xnolev - *ncm;
#line 25158 ""
    if (test < -.001f || test < .001f && combc_1.bcspec && *ncm == 23) {
#line 25160 ""
	*(unsigned char *)ret_val = 'u';
#line 25161 ""
    } else {
#line 25162 ""
	*(unsigned char *)ret_val = 'l';
#line 25163 ""
    }
#line 25164 ""
    return ;
} /* ulfq_ */

/* Character */ VOID upcaseq_(char *ret_val, ftnlen ret_val_len, char *chq, 
	ftnlen chq_len)
{
    /* System generated locals */
    address a__1[2];
    integer i__1, i__2[2];
    char ch__2[1], ch__3[53];

    /* Builtin functions */
    integer s_wsle(cilist *);
    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
    integer do_lio(integer *, integer *, char *, ftnlen), e_wsle(void);
    /* Subroutine */ int s_stop(char *, ftnlen);

    /* Local variables */
    extern /* Character */ VOID chax_(char *, ftnlen, integer *);

    /* Fortran I/O blocks */
    static cilist io___1877 = { 0, 6, 0, 0, 0 };


#line 25168 ""
    if (*(unsigned char *)chq >= 61 && *(unsigned char *)chq < 122) {
#line 25169 ""
	i__1 = *(unsigned char *)chq - 32;
#line 25169 ""
	chax_(ch__2, (ftnlen)1, &i__1);
#line 25169 ""
	*(unsigned char *)ret_val = *(unsigned char *)&ch__2[0];
#line 25170 ""
    } else {
#line 25171 ""
	*(unsigned char *)ret_val = *(unsigned char *)chq;
#line 25172 ""
	s_wsle(&io___1877);
/* Writing concatenation */
#line 25172 ""
	i__2[0] = 52, a__1[0] = "Warning, upcaseq was called with improper a"\
		"rgument: ";
#line 25172 ""
	i__2[1] = 1, a__1[1] = chq;
#line 25172 ""
	s_cat(ch__3, a__1, i__2, &c__2, (ftnlen)53);
#line 25172 ""
	do_lio(&c__9, &c__1, ch__3, (ftnlen)53);
#line 25172 ""
	e_wsle();
#line 25174 ""
	s_stop("", (ftnlen)0);
#line 25175 ""
    }
#line 25176 ""
    return ;
} /* upcaseq_ */

/* Subroutine */ int wgmeter_(integer *mtrnmp, integer *mtrdnp)
{
    /* System generated locals */
    address a__1[4];
    integer i__1[4], i__2;
    char ch__1[1], ch__2[25], ch__3[26], ch__4[21], ch__5[24];

    /* Builtin functions */
    integer s_wsfe(cilist *);
    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
    integer do_fio(integer *, char *, ftnlen), e_wsfe(void);

    /* Local variables */
    static char sq[1];
    extern /* Character */ VOID chax_(char *, ftnlen, integer *);

    /* Fortran I/O blocks */
    static cilist io___1879 = { 0, 11, 0, "(a25,i1,a2,i1,a3)", 0 };
    static cilist io___1880 = { 0, 11, 0, "(a25,i1,a2,i2,a3)", 0 };
    static cilist io___1881 = { 0, 11, 0, "(a25,i2,a2,i1,a3)", 0 };
    static cilist io___1882 = { 0, 11, 0, "(a25,i2,a2,i2,a3)", 0 };
    static cilist io___1883 = { 0, 11, 0, "(a26,i1,a2,i1,a3)", 0 };
    static cilist io___1884 = { 0, 11, 0, "(a21,i1,a2)", 0 };
    static cilist io___1885 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1886 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1887 = { 0, 11, 0, "(a)", 0 };



/*  Writes meter stuff to file 11, so only called if islast=.true. */

#line 25183 ""
    if (*mtrdnp == 0) {
#line 25183 ""
	return 0;
#line 25183 ""
    }
#line 25184 ""
    chax_(ch__1, (ftnlen)1, &c__92);
#line 25184 ""
    *(unsigned char *)sq = *(unsigned char *)&ch__1[0];
#line 25185 ""
    if (*mtrnmp > 0 && *mtrnmp <= 9) {
#line 25186 ""
	if (*mtrdnp < 10) {
#line 25187 ""
	    s_wsfe(&io___1879);
/* Writing concatenation */
#line 25187 ""
	    i__1[0] = 1, a__1[0] = sq;
#line 25187 ""
	    i__1[1] = 13, a__1[1] = "generalmeter{";
#line 25187 ""
	    i__1[2] = 1, a__1[2] = sq;
#line 25187 ""
	    i__1[3] = 10, a__1[3] = "meterfrac{";
#line 25187 ""
	    s_cat(ch__2, a__1, i__1, &c__4, (ftnlen)25);
#line 25187 ""
	    do_fio(&c__1, ch__2, (ftnlen)25);
#line 25187 ""
	    do_fio(&c__1, (char *)&(*mtrnmp), (ftnlen)sizeof(integer));
#line 25187 ""
	    do_fio(&c__1, "}{", (ftnlen)2);
#line 25187 ""
	    do_fio(&c__1, (char *)&(*mtrdnp), (ftnlen)sizeof(integer));
#line 25187 ""
	    do_fio(&c__1, "}}%", (ftnlen)3);
#line 25187 ""
	    e_wsfe();
#line 25190 ""
	} else {
#line 25191 ""
	    s_wsfe(&io___1880);
/* Writing concatenation */
#line 25191 ""
	    i__1[0] = 1, a__1[0] = sq;
#line 25191 ""
	    i__1[1] = 13, a__1[1] = "generalmeter{";
#line 25191 ""
	    i__1[2] = 1, a__1[2] = sq;
#line 25191 ""
	    i__1[3] = 10, a__1[3] = "meterfrac{";
#line 25191 ""
	    s_cat(ch__2, a__1, i__1, &c__4, (ftnlen)25);
#line 25191 ""
	    do_fio(&c__1, ch__2, (ftnlen)25);
#line 25191 ""
	    do_fio(&c__1, (char *)&(*mtrnmp), (ftnlen)sizeof(integer));
#line 25191 ""
	    do_fio(&c__1, "}{", (ftnlen)2);
#line 25191 ""
	    do_fio(&c__1, (char *)&(*mtrdnp), (ftnlen)sizeof(integer));
#line 25191 ""
	    do_fio(&c__1, "}}%", (ftnlen)3);
#line 25191 ""
	    e_wsfe();
#line 25194 ""
	}
#line 25195 ""
    } else if (*mtrnmp >= 10) {
#line 25196 ""
	if (*mtrdnp < 10) {
#line 25197 ""
	    s_wsfe(&io___1881);
/* Writing concatenation */
#line 25197 ""
	    i__1[0] = 1, a__1[0] = sq;
#line 25197 ""
	    i__1[1] = 13, a__1[1] = "generalmeter{";
#line 25197 ""
	    i__1[2] = 1, a__1[2] = sq;
#line 25197 ""
	    i__1[3] = 10, a__1[3] = "meterfrac{";
#line 25197 ""
	    s_cat(ch__2, a__1, i__1, &c__4, (ftnlen)25);
#line 25197 ""
	    do_fio(&c__1, ch__2, (ftnlen)25);
#line 25197 ""
	    do_fio(&c__1, (char *)&(*mtrnmp), (ftnlen)sizeof(integer));
#line 25197 ""
	    do_fio(&c__1, "}{", (ftnlen)2);
#line 25197 ""
	    do_fio(&c__1, (char *)&(*mtrdnp), (ftnlen)sizeof(integer));
#line 25197 ""
	    do_fio(&c__1, "}}%", (ftnlen)3);
#line 25197 ""
	    e_wsfe();
#line 25200 ""
	} else {
#line 25201 ""
	    s_wsfe(&io___1882);
/* Writing concatenation */
#line 25201 ""
	    i__1[0] = 1, a__1[0] = sq;
#line 25201 ""
	    i__1[1] = 13, a__1[1] = "generalmeter{";
#line 25201 ""
	    i__1[2] = 1, a__1[2] = sq;
#line 25201 ""
	    i__1[3] = 10, a__1[3] = "meterfrac{";
#line 25201 ""
	    s_cat(ch__2, a__1, i__1, &c__4, (ftnlen)25);
#line 25201 ""
	    do_fio(&c__1, ch__2, (ftnlen)25);
#line 25201 ""
	    do_fio(&c__1, (char *)&(*mtrnmp), (ftnlen)sizeof(integer));
#line 25201 ""
	    do_fio(&c__1, "}{", (ftnlen)2);
#line 25201 ""
	    do_fio(&c__1, (char *)&(*mtrdnp), (ftnlen)sizeof(integer));
#line 25201 ""
	    do_fio(&c__1, "}}%", (ftnlen)3);
#line 25201 ""
	    e_wsfe();
#line 25204 ""
	}
#line 25205 ""
    } else if (*mtrnmp < 0) {
#line 25206 ""
	s_wsfe(&io___1883);
/* Writing concatenation */
#line 25206 ""
	i__1[0] = 1, a__1[0] = sq;
#line 25206 ""
	i__1[1] = 13, a__1[1] = "generalmeter{";
#line 25206 ""
	i__1[2] = 1, a__1[2] = sq;
#line 25206 ""
	i__1[3] = 11, a__1[3] = "meterfracS{";
#line 25206 ""
	s_cat(ch__3, a__1, i__1, &c__4, (ftnlen)26);
#line 25206 ""
	do_fio(&c__1, ch__3, (ftnlen)26);
#line 25206 ""
	i__2 = -(*mtrnmp);
#line 25206 ""
	do_fio(&c__1, (char *)&i__2, (ftnlen)sizeof(integer));
#line 25206 ""
	do_fio(&c__1, "}{", (ftnlen)2);
#line 25206 ""
	do_fio(&c__1, (char *)&(*mtrdnp), (ftnlen)sizeof(integer));
#line 25206 ""
	do_fio(&c__1, "}}%", (ftnlen)3);
#line 25206 ""
	e_wsfe();
#line 25209 ""
    } else if (*mtrdnp <= 4) {
#line 25210 ""
	s_wsfe(&io___1884);
/* Writing concatenation */
#line 25210 ""
	i__1[0] = 1, a__1[0] = sq;
#line 25210 ""
	i__1[1] = 13, a__1[1] = "generalmeter{";
#line 25210 ""
	i__1[2] = 1, a__1[2] = sq;
#line 25210 ""
	i__1[3] = 6, a__1[3] = "meterN";
#line 25210 ""
	s_cat(ch__4, a__1, i__1, &c__4, (ftnlen)21);
#line 25210 ""
	do_fio(&c__1, ch__4, (ftnlen)21);
#line 25210 ""
	do_fio(&c__1, (char *)&(*mtrdnp), (ftnlen)sizeof(integer));
#line 25210 ""
	do_fio(&c__1, "}%", (ftnlen)2);
#line 25210 ""
	e_wsfe();
#line 25212 ""
    } else if (*mtrdnp == 5) {
#line 25213 ""
	s_wsfe(&io___1885);
/* Writing concatenation */
#line 25213 ""
	i__1[0] = 1, a__1[0] = sq;
#line 25213 ""
	i__1[1] = 12, a__1[1] = "generalmeter";
#line 25213 ""
	i__1[2] = 1, a__1[2] = sq;
#line 25213 ""
	i__1[3] = 10, a__1[3] = "allabreve%";
#line 25213 ""
	s_cat(ch__5, a__1, i__1, &c__4, (ftnlen)24);
#line 25213 ""
	do_fio(&c__1, ch__5, (ftnlen)24);
#line 25213 ""
	e_wsfe();
#line 25214 ""
    } else if (*mtrdnp == 6) {
#line 25215 ""
	s_wsfe(&io___1886);
/* Writing concatenation */
#line 25215 ""
	i__1[0] = 1, a__1[0] = sq;
#line 25215 ""
	i__1[1] = 12, a__1[1] = "generalmeter";
#line 25215 ""
	i__1[2] = 1, a__1[2] = sq;
#line 25215 ""
	i__1[3] = 7, a__1[3] = "meterC%";
#line 25215 ""
	s_cat(ch__4, a__1, i__1, &c__4, (ftnlen)21);
#line 25215 ""
	do_fio(&c__1, ch__4, (ftnlen)21);
#line 25215 ""
	e_wsfe();
#line 25216 ""
    } else if (*mtrdnp == 7) {
#line 25217 ""
	s_wsfe(&io___1887);
/* Writing concatenation */
#line 25217 ""
	i__1[0] = 1, a__1[0] = sq;
#line 25217 ""
	i__1[1] = 12, a__1[1] = "generalmeter";
#line 25217 ""
	i__1[2] = 1, a__1[2] = sq;
#line 25217 ""
	i__1[3] = 10, a__1[3] = "meterIIIS%";
#line 25217 ""
	s_cat(ch__5, a__1, i__1, &c__4, (ftnlen)24);
#line 25217 ""
	do_fio(&c__1, ch__5, (ftnlen)24);
#line 25217 ""
	e_wsfe();
#line 25218 ""
    }
#line 25219 ""
    return 0;
} /* wgmeter_ */

/* Subroutine */ int writemidi_(char *jobname, integer *ljob, ftnlen 
	jobname_len)
{
    /* Initialized data */

    static shortint icmm[16] = { 0,1,2,3,4,5,6,7,8,10,11,12,13,14,15,16 };

    /* System generated locals */
    address a__1[4], a__2[7], a__3[3], a__4[2], a__5[12];
    integer i__1[4], i__2, i__3[7], i__4[3], i__5[2], i__6, i__7[12], i__8, 
	    i__9, i__10, i__11, i__12;
    char ch__1[14], ch__2[1], ch__3[12], ch__4[1], ch__5[1], ch__6[46], ch__7[
	    27], ch__8[29], ch__9[15], ch__10[1], ch__11[4], ch__12[81], 
	    ch__13[25];
    cllist cl__1;

    /* Builtin functions */
    integer s_wsfe(cilist *);
    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
    integer do_fio(integer *, char *, ftnlen), e_wsfe(void), lbit_shift(
	    integer, integer), s_wsfi(icilist *), e_wsfi(void), f_clos(cllist 
	    *);

    /* Local variables */
    static integer i__, kv, ib0, ib1, icm;
    extern /* Character */ VOID chax_(char *, ftnlen, integer *);
    static integer isec, mend, ndata, ibyte;
    static char byteq[1*4], instq[10], tempoq[10];
    extern /* Subroutine */ int printl_(char *, ftnlen);

    /* Fortran I/O blocks */
    static cilist io___1889 = { 0, 51, 0, "(a,$)", 0 };
    static cilist io___1890 = { 0, 52, 0, "(a6,10Z4)", 0 };
    static cilist io___1895 = { 0, 51, 0, "(a,$)", 0 };
    static cilist io___1896 = { 0, 52, 0, "(a6,8z4)", 0 };
    static cilist io___1897 = { 0, 51, 0, "(a,$)", 0 };
    static cilist io___1898 = { 0, 52, 0, "(a)", 0 };
    static cilist io___1899 = { 0, 51, 0, "(a,$)", 0 };
    static cilist io___1900 = { 0, 52, 0, "(a)", 0 };
    static cilist io___1903 = { 0, 51, 0, "(a,$)", 0 };
    static cilist io___1904 = { 0, 52, 0, "(z4)", 0 };
    static cilist io___1905 = { 0, 51, 0, "(a,$)", 0 };
    static cilist io___1906 = { 0, 52, 0, "(4z4)", 0 };
    static cilist io___1911 = { 0, 51, 0, "(a,$)", 0 };
    static cilist io___1912 = { 0, 52, 0, "(a4,z2,a7,11z4)", 0 };
    static cilist io___1913 = { 0, 51, 0, "(a,$)", 0 };
    static cilist io___1914 = { 0, 52, 0, "(4z4)", 0 };
    static cilist io___1915 = { 0, 51, 0, "(a,$)", 0 };
    static cilist io___1916 = { 0, 52, 0, "(a)", 0 };
    static icilist io___1918 = { 0, tempoq, 0, "(i2)", 10, 1 };
    static icilist io___1920 = { 0, instq, 0, "(i3)", 10, 1 };
    static cilist io___1921 = { 0, 51, 0, "(a,$)", 0 };
    static cilist io___1922 = { 0, 52, 0, "(z4)", 0 };
    static cilist io___1923 = { 0, 51, 0, "(a,$)", 0 };
    static cilist io___1924 = { 0, 52, 0, "(4z4)", 0 };



/*  Used to be icmm(0:nm); did midi fail when nv>16? */


/*  These are not consecutive because channel 9 is reserved for percussion. */


/*  Write Header */

#line 25272 ""
    s_wsfe(&io___1889);
/* Writing concatenation */
#line 25272 ""
    i__1[0] = 11, a__1[0] = "MThd\000\000\000\006\000\001\000";
#line 25272 ""
    *(unsigned char *)&ch__2[0] = commidi_1.numchan + 1;
#line 25272 ""
    i__1[1] = 1, a__1[1] = ch__2;
#line 25272 ""
    i__1[2] = 1, a__1[2] = "\000";
#line 25272 ""
    i__1[3] = 1, a__1[3] = "\360";
#line 25272 ""
    s_cat(ch__1, a__1, i__1, &c__4, (ftnlen)14);
#line 25272 ""
    do_fio(&c__1, ch__1, (ftnlen)14);
#line 25272 ""
    e_wsfe();
#line 25274 ""
    if (commidi_1.debugmidi) {
#line 25274 ""
	s_wsfe(&io___1890);
#line 25274 ""
	do_fio(&c__1, "\"MThd\"", (ftnlen)6);
#line 25274 ""
	do_fio(&c__1, (char *)&c__0, (ftnlen)sizeof(integer));
#line 25274 ""
	do_fio(&c__1, (char *)&c__0, (ftnlen)sizeof(integer));
#line 25274 ""
	do_fio(&c__1, (char *)&c__0, (ftnlen)sizeof(integer));
#line 25274 ""
	do_fio(&c__1, (char *)&c__6, (ftnlen)sizeof(integer));
#line 25274 ""
	do_fio(&c__1, (char *)&c__0, (ftnlen)sizeof(integer));
#line 25274 ""
	do_fio(&c__1, (char *)&c__1, (ftnlen)sizeof(integer));
#line 25274 ""
	do_fio(&c__1, (char *)&c__0, (ftnlen)sizeof(integer));
#line 25274 ""
	i__2 = commidi_1.numchan + 1;
#line 25274 ""
	do_fio(&c__1, (char *)&i__2, (ftnlen)sizeof(integer));
#line 25274 ""
	do_fio(&c__1, (char *)&c__0, (ftnlen)sizeof(integer));
#line 25274 ""
	do_fio(&c__1, (char *)&c__240, (ftnlen)sizeof(integer));
#line 25274 ""
	e_wsfe();
#line 25274 ""
    }

/*  Write the "conductor" track, for keys, meter, and tempos */
/*  Get the number of bytes in the conductor event stream */

#line 25281 ""
    ndata = commidi_1.imidi[commidi_1.numchan] + 1 - commmac_1.msecstrt[
	    commidi_1.numchan + commmac_1.nmidsec * 25 - 25];
#line 25282 ""
    i__2 = commmac_1.nmidsec - 1;
#line 25282 ""
    for (isec = 1; isec <= i__2; ++isec) {
#line 25283 ""
	ndata = ndata + 1 + commmac_1.msecend[commidi_1.numchan + isec * 25 - 
		25] - commmac_1.msecstrt[commidi_1.numchan + isec * 25 - 25];
#line 25284 ""
/* L15: */
#line 25284 ""
    }
#line 25285 ""
    ib1 = (*ljob + 31 + ndata + 4) / 256;
#line 25286 ""
    ib0 = *ljob + 31 + ndata + 4 - (ib1 << 8);
#line 25287 ""
    s_wsfe(&io___1895);
/* Writing concatenation */
#line 25287 ""
    i__3[0] = 6, a__2[0] = "MTrk\000\000";
#line 25287 ""
    *(unsigned char *)&ch__2[0] = ib1;
#line 25287 ""
    i__3[1] = 1, a__2[1] = ch__2;
#line 25287 ""
    *(unsigned char *)&ch__4[0] = ib0;
#line 25287 ""
    i__3[2] = 1, a__2[2] = ch__4;
#line 25287 ""
    i__3[3] = 1, a__2[3] = "\000";
#line 25287 ""
    i__3[4] = 1, a__2[4] = "\377";
#line 25287 ""
    i__3[5] = 1, a__2[5] = "\001";
#line 25287 ""
    *(unsigned char *)&ch__5[0] = *ljob + 27;
#line 25287 ""
    i__3[6] = 1, a__2[6] = ch__5;
#line 25287 ""
    s_cat(ch__3, a__2, i__3, &c__7, (ftnlen)12);
#line 25287 ""
    do_fio(&c__1, ch__3, (ftnlen)12);
#line 25287 ""
    e_wsfe();

/*  Text header */

#line 25292 ""
    if (commidi_1.debugmidi) {
#line 25292 ""
	s_wsfe(&io___1896);
#line 25292 ""
	do_fio(&c__1, "\"MTrk\"", (ftnlen)6);
#line 25292 ""
	do_fio(&c__1, (char *)&c__0, (ftnlen)sizeof(integer));
#line 25292 ""
	do_fio(&c__1, (char *)&c__0, (ftnlen)sizeof(integer));
#line 25292 ""
	do_fio(&c__1, (char *)&ib1, (ftnlen)sizeof(integer));
#line 25292 ""
	do_fio(&c__1, (char *)&ib0, (ftnlen)sizeof(integer));
#line 25292 ""
	do_fio(&c__1, (char *)&c__0, (ftnlen)sizeof(integer));
#line 25292 ""
	do_fio(&c__1, (char *)&c__255, (ftnlen)sizeof(integer));
#line 25292 ""
	do_fio(&c__1, (char *)&c__1, (ftnlen)sizeof(integer));
#line 25292 ""
	i__2 = *ljob + 27;
#line 25292 ""
	do_fio(&c__1, (char *)&i__2, (ftnlen)sizeof(integer));
#line 25292 ""
	e_wsfe();
#line 25292 ""
    }
#line 25295 ""
    s_wsfe(&io___1897);
#line 25295 ""
    do_fio(&c__1, jobname, (*ljob));
#line 25295 ""
    e_wsfe();
#line 25296 ""
    if (commidi_1.debugmidi) {
#line 25296 ""
	s_wsfe(&io___1898);
/* Writing concatenation */
#line 25296 ""
	chax_(ch__2, (ftnlen)1, &c__34);
#line 25296 ""
	i__4[0] = 1, a__3[0] = ch__2;
#line 25296 ""
	i__4[1] = *ljob, a__3[1] = jobname;
#line 25296 ""
	chax_(ch__4, (ftnlen)1, &c__34);
#line 25296 ""
	i__4[2] = 1, a__3[2] = ch__4;
#line 25296 ""
	s_cat(ch__6, a__3, i__4, &c__3, (ftnlen)46);
#line 25296 ""
	do_fio(&c__1, ch__6, *ljob + 2);
#line 25296 ""
	e_wsfe();
#line 25296 ""
    }

/*  (separate writes are needed to defeat compiler BUG!!!) */

#line 25300 ""
    s_wsfe(&io___1899);
/* Writing concatenation */
#line 25300 ""
    i__5[0] = 22, a__4[0] = ".mid, produced by PMX ";
#line 25300 ""
    i__5[1] = 5, a__4[1] = comver_1.versionc;
#line 25300 ""
    s_cat(ch__7, a__4, i__5, &c__2, (ftnlen)27);
#line 25300 ""
    do_fio(&c__1, ch__7, (ftnlen)27);
#line 25300 ""
    e_wsfe();
#line 25301 ""
    if (commidi_1.debugmidi) {
#line 25301 ""
	s_wsfe(&io___1900);
/* Writing concatenation */
#line 25301 ""
	chax_(ch__2, (ftnlen)1, &c__34);
#line 25301 ""
	i__1[0] = 1, a__1[0] = ch__2;
#line 25301 ""
	i__1[1] = 22, a__1[1] = ".mid, produced by PMX ";
#line 25301 ""
	i__1[2] = 5, a__1[2] = comver_1.versionc;
#line 25301 ""
	chax_(ch__4, (ftnlen)1, &c__34);
#line 25301 ""
	i__1[3] = 1, a__1[3] = ch__4;
#line 25301 ""
	s_cat(ch__8, a__1, i__1, &c__4, (ftnlen)29);
#line 25301 ""
	do_fio(&c__1, ch__8, (ftnlen)29);
#line 25301 ""
	e_wsfe();
#line 25301 ""
    }

/*  Conductor event data: Loop over sections. */

#line 25306 ""
    i__2 = commmac_1.nmidsec;
#line 25306 ""
    for (isec = 1; isec <= i__2; ++isec) {
#line 25307 ""
	if (isec < commmac_1.nmidsec) {
#line 25308 ""
	    mend = commmac_1.msecend[commidi_1.numchan + isec * 25 - 25];
#line 25309 ""
	} else {
#line 25310 ""
	    mend = commidi_1.imidi[commidi_1.numchan];
#line 25311 ""
	}
#line 25312 ""
	i__6 = mend;
#line 25312 ""
	for (i__ = commmac_1.msecstrt[commidi_1.numchan + isec * 25 - 25]; 
		i__ <= i__6; ++i__) {
#line 25313 ""
	    s_wsfe(&io___1903);
#line 25313 ""
	    *(unsigned char *)&ch__2[0] = (char) commidi_1.mmidi[
		    commidi_1.numchan + i__ * 25 - 25];
#line 25313 ""
	    do_fio(&c__1, ch__2, (ftnlen)1);
#line 25313 ""
	    e_wsfe();
#line 25314 ""
	    if (commidi_1.debugmidi) {
#line 25314 ""
		s_wsfe(&io___1904);
#line 25314 ""
		do_fio(&c__1, (char *)&commidi_1.mmidi[commidi_1.numchan + 
			i__ * 25 - 25], (ftnlen)sizeof(shortint));
#line 25314 ""
		e_wsfe();
#line 25314 ""
	    }
#line 25315 ""
/* L17: */
#line 25315 ""
	}
#line 25316 ""
/* L16: */
#line 25316 ""
    }

/*  And close out the time sig / tempo track. */

#line 25320 ""
    s_wsfe(&io___1905);
#line 25320 ""
    do_fio(&c__1, "\000\377/\000", (ftnlen)4);
#line 25320 ""
    e_wsfe();
#line 25321 ""
    if (commidi_1.debugmidi) {
#line 25321 ""
	s_wsfe(&io___1906);
#line 25321 ""
	do_fio(&c__1, (char *)&c__0, (ftnlen)sizeof(integer));
#line 25321 ""
	do_fio(&c__1, (char *)&c__255, (ftnlen)sizeof(integer));
#line 25321 ""
	do_fio(&c__1, (char *)&c__47, (ftnlen)sizeof(integer));
#line 25321 ""
	do_fio(&c__1, (char *)&c__0, (ftnlen)sizeof(integer));
#line 25321 ""
	e_wsfe();
#line 25321 ""
    }

/*  Loop over track for each voice:  The following sets up iv. */

#line 25325 ""
    all_1.iv = all_1.nv;
#line 25326 ""
    if (commidi_1.twoline[all_1.nv - 1]) {
#line 25327 ""
	kv = 2;
#line 25328 ""
    } else {
#line 25329 ""
	kv = 1;
#line 25330 ""
    }

#line 25332 ""
    i__2 = commidi_1.numchan - 1;
#line 25332 ""
    for (icm = 0; icm <= i__2; ++icm) {

/*  Get the number of bytes in the data stream */

#line 25336 ""
	ndata = commidi_1.imidi[icm] + 1 - commmac_1.msecstrt[icm + 
		commmac_1.nmidsec * 25 - 25];
#line 25337 ""
	i__6 = commmac_1.nmidsec - 1;
#line 25337 ""
	for (isec = 1; isec <= i__6; ++isec) {
#line 25338 ""
	    ndata = ndata + 1 + commmac_1.msecend[icm + isec * 25 - 25] - 
		    commmac_1.msecstrt[icm + isec * 25 - 25];
#line 25339 ""
/* L11: */
#line 25339 ""
	}

/*  Add 3 for instrum, 4 for bal,  plus 4 (for closing) to byte count, */

#line 25343 ""
	ndata += 11;

/*  Add 4+lnam(iinsiv(iv)) if lnam>0 , */

#line 25347 ""
	if (comtop_1.lnam[commvel_1.iinsiv[all_1.iv - 1] - 1] > 0) {
#line 25347 ""
	    ndata = ndata + 4 + comtop_1.lnam[commvel_1.iinsiv[all_1.iv - 1] 
		    - 1];
#line 25347 ""
	}

/*  Separate total byte counts into 4 bytes */

#line 25351 ""
	for (ibyte = 1; ibyte <= 4; ++ibyte) {
#line 25352 ""
	    if (ndata > 0) {
#line 25353 ""
		*(unsigned char *)&byteq[ibyte - 1] = (char) (ndata % 256);
#line 25354 ""
		ndata = lbit_shift(ndata, (ftnlen)-8);
#line 25355 ""
	    } else {
#line 25356 ""
		*(unsigned char *)&byteq[ibyte - 1] = '\0';
#line 25357 ""
	    }
#line 25358 ""
/* L2: */
#line 25358 ""
	}

/*  Now write front stuff for this track */

#line 25362 ""
	s_wsfe(&io___1911);
/* Writing concatenation */
#line 25362 ""
	i__7[0] = 4, a__5[0] = "MTrk";
#line 25362 ""
	i__7[1] = 1, a__5[1] = byteq + 3;
#line 25362 ""
	i__7[2] = 1, a__5[2] = byteq + 2;
#line 25362 ""
	i__7[3] = 1, a__5[3] = byteq + 1;
#line 25362 ""
	i__7[4] = 1, a__5[4] = byteq;
#line 25362 ""
	i__7[5] = 1, a__5[5] = "\000";
#line 25362 ""
	*(unsigned char *)&ch__2[0] = icmm[icm] + 192;
#line 25362 ""
	i__7[6] = 1, a__5[6] = ch__2;
#line 25362 ""
	*(unsigned char *)&ch__4[0] = commidi_1.midinst[commvel_1.iinsiv[
		all_1.iv - 1] - 1];
#line 25362 ""
	i__7[7] = 1, a__5[7] = ch__4;
#line 25362 ""
	i__7[8] = 1, a__5[8] = "\000";
#line 25362 ""
	*(unsigned char *)&ch__5[0] = icmm[icm] + 176;
#line 25362 ""
	i__7[9] = 1, a__5[9] = ch__5;
#line 25362 ""
	i__7[10] = 1, a__5[10] = "\n";
#line 25362 ""
	*(unsigned char *)&ch__10[0] = commvel_1.midbc[icm];
#line 25362 ""
	i__7[11] = 1, a__5[11] = ch__10;
#line 25362 ""
	s_cat(ch__9, a__5, i__7, &c__12, (ftnlen)15);
#line 25362 ""
	do_fio(&c__1, ch__9, (ftnlen)15);
#line 25362 ""
	e_wsfe();
#line 25365 ""
	if (commidi_1.debugmidi) {
#line 25365 ""
	    s_wsfe(&io___1912);
#line 25365 ""
	    do_fio(&c__1, "icm=", (ftnlen)4);
#line 25365 ""
	    do_fio(&c__1, (char *)&icm, (ftnlen)sizeof(integer));
#line 25365 ""
	    do_fio(&c__1, " \"MTrk\"", (ftnlen)7);
#line 25365 ""
	    i__6 = *(unsigned char *)&byteq[3];
#line 25365 ""
	    do_fio(&c__1, (char *)&i__6, (ftnlen)sizeof(integer));
#line 25365 ""
	    i__8 = *(unsigned char *)&byteq[2];
#line 25365 ""
	    do_fio(&c__1, (char *)&i__8, (ftnlen)sizeof(integer));
#line 25365 ""
	    i__9 = *(unsigned char *)&byteq[1];
#line 25365 ""
	    do_fio(&c__1, (char *)&i__9, (ftnlen)sizeof(integer));
#line 25365 ""
	    i__10 = *(unsigned char *)&byteq[0];
#line 25365 ""
	    do_fio(&c__1, (char *)&i__10, (ftnlen)sizeof(integer));
#line 25365 ""
	    do_fio(&c__1, (char *)&c__0, (ftnlen)sizeof(integer));
#line 25365 ""
	    i__11 = icmm[icm] + 192;
#line 25365 ""
	    do_fio(&c__1, (char *)&i__11, (ftnlen)sizeof(integer));
#line 25365 ""
	    do_fio(&c__1, (char *)&commidi_1.midinst[commvel_1.iinsiv[
		    all_1.iv - 1] - 1], (ftnlen)sizeof(integer));
#line 25365 ""
	    do_fio(&c__1, (char *)&c__0, (ftnlen)sizeof(integer));
#line 25365 ""
	    i__12 = icmm[icm] + 176;
#line 25365 ""
	    do_fio(&c__1, (char *)&i__12, (ftnlen)sizeof(integer));
#line 25365 ""
	    do_fio(&c__1, (char *)&c__10, (ftnlen)sizeof(integer));
#line 25365 ""
	    do_fio(&c__1, (char *)&commvel_1.midbc[icm], (ftnlen)sizeof(
		    integer));
#line 25365 ""
	    e_wsfe();
#line 25365 ""
	}
#line 25369 ""
	if (comtop_1.lnam[commvel_1.iinsiv[all_1.iv - 1] - 1] > 0) {

/*  Add instrument name as sequence name */

#line 25373 ""
	    s_wsfe(&io___1913);
/* Writing concatenation */
#line 25373 ""
	    i__5[0] = 3, a__4[0] = "\000\377\003";
#line 25373 ""
	    *(unsigned char *)&ch__2[0] = comtop_1.lnam[commvel_1.iinsiv[
		    all_1.iv - 1] - 1];
#line 25373 ""
	    i__5[1] = 1, a__4[1] = ch__2;
#line 25373 ""
	    s_cat(ch__11, a__4, i__5, &c__2, (ftnlen)4);
#line 25373 ""
	    do_fio(&c__1, ch__11, (ftnlen)4);
#line 25373 ""
	    e_wsfe();
#line 25375 ""
	    if (commidi_1.debugmidi) {
#line 25375 ""
		s_wsfe(&io___1914);
#line 25375 ""
		do_fio(&c__1, (char *)&c__0, (ftnlen)sizeof(integer));
#line 25375 ""
		do_fio(&c__1, (char *)&c__255, (ftnlen)sizeof(integer));
#line 25375 ""
		do_fio(&c__1, (char *)&c__3, (ftnlen)sizeof(integer));
#line 25375 ""
		do_fio(&c__1, (char *)&comtop_1.lnam[commvel_1.iinsiv[
			all_1.iv - 1] - 1], (ftnlen)sizeof(integer));
#line 25375 ""
		e_wsfe();
#line 25375 ""
	    }
#line 25376 ""
	    s_wsfe(&io___1915);
#line 25376 ""
	    do_fio(&c__1, comtop_1.inameq + (commvel_1.iinsiv[all_1.iv - 1] - 
		    1) * 79, comtop_1.lnam[commvel_1.iinsiv[all_1.iv - 1] - 1]
		    );
#line 25376 ""
	    e_wsfe();
#line 25378 ""
	    if (commidi_1.debugmidi) {
#line 25378 ""
		s_wsfe(&io___1916);
/* Writing concatenation */
#line 25378 ""
		chax_(ch__2, (ftnlen)1, &c__34);
#line 25378 ""
		i__4[0] = 1, a__3[0] = ch__2;
#line 25378 ""
		i__4[1] = comtop_1.lnam[commvel_1.iinsiv[all_1.iv - 1] - 1], 
			a__3[1] = comtop_1.inameq + (commvel_1.iinsiv[
			all_1.iv - 1] - 1) * 79;
#line 25378 ""
		chax_(ch__4, (ftnlen)1, &c__34);
#line 25378 ""
		i__4[2] = 1, a__3[2] = ch__4;
#line 25378 ""
		s_cat(ch__12, a__3, i__4, &c__3, (ftnlen)81);
#line 25378 ""
		do_fio(&c__1, ch__12, comtop_1.lnam[commvel_1.iinsiv[all_1.iv 
			- 1] - 1] + 2);
#line 25378 ""
		e_wsfe();
#line 25378 ""
	    }
#line 25380 ""
	}
#line 25381 ""
	s_wsfi(&io___1918);
#line 25381 ""
	do_fio(&c__1, (char *)&icm, (ftnlen)sizeof(integer));
#line 25381 ""
	e_wsfi();
#line 25382 ""
	s_wsfi(&io___1920);
#line 25382 ""
	do_fio(&c__1, (char *)&commidi_1.midinst[commvel_1.iinsiv[all_1.iv - 
		1] - 1], (ftnlen)sizeof(integer));
#line 25382 ""
	e_wsfi();
/* Writing concatenation */
#line 25383 ""
	i__1[0] = 16, a__1[0] = "MIDI instrument ";
#line 25383 ""
	i__1[1] = 2, a__1[1] = tempoq;
#line 25383 ""
	i__1[2] = 4, a__1[2] = " is ";
#line 25383 ""
	i__1[3] = 3, a__1[3] = instq;
#line 25383 ""
	s_cat(ch__13, a__1, i__1, &c__4, (ftnlen)25);
#line 25383 ""
	printl_(ch__13, (ftnlen)25);

/*  Notes: Loop over sections. */

#line 25387 ""
	i__6 = commmac_1.nmidsec;
#line 25387 ""
	for (isec = 1; isec <= i__6; ++isec) {
#line 25388 ""
	    if (isec < commmac_1.nmidsec) {
#line 25389 ""
		mend = commmac_1.msecend[icm + isec * 25 - 25];
#line 25390 ""
	    } else {
#line 25391 ""
		mend = commidi_1.imidi[icm];
#line 25392 ""
	    }
#line 25393 ""
	    i__8 = mend;
#line 25393 ""
	    for (i__ = commmac_1.msecstrt[icm + isec * 25 - 25]; i__ <= i__8; 
		    ++i__) {
#line 25394 ""
		s_wsfe(&io___1921);
#line 25394 ""
		*(unsigned char *)&ch__2[0] = (char) commidi_1.mmidi[icm + 
			i__ * 25 - 25];
#line 25394 ""
		do_fio(&c__1, ch__2, (ftnlen)1);
#line 25394 ""
		e_wsfe();
#line 25395 ""
		if (commidi_1.debugmidi) {
#line 25395 ""
		    s_wsfe(&io___1922);
#line 25395 ""
		    do_fio(&c__1, (char *)&commidi_1.mmidi[icm + i__ * 25 - 
			    25], (ftnlen)sizeof(shortint));
#line 25395 ""
		    e_wsfe();
#line 25395 ""
		}
#line 25396 ""
/* L10: */
#line 25396 ""
	    }
#line 25397 ""
/* L9: */
#line 25397 ""
	}

/*  Closing 4 bytes */

#line 25401 ""
	s_wsfe(&io___1923);
/* Writing concatenation */
#line 25401 ""
	chax_(ch__2, (ftnlen)1, &c__0);
#line 25401 ""
	i__1[0] = 1, a__1[0] = ch__2;
#line 25401 ""
	i__1[1] = 1, a__1[1] = "\377";
#line 25401 ""
	i__1[2] = 1, a__1[2] = "/";
#line 25401 ""
	i__1[3] = 1, a__1[3] = "\000";
#line 25401 ""
	s_cat(ch__11, a__1, i__1, &c__4, (ftnlen)4);
#line 25401 ""
	do_fio(&c__1, ch__11, (ftnlen)4);
#line 25401 ""
	e_wsfe();
#line 25402 ""
	if (commidi_1.debugmidi) {
#line 25402 ""
	    s_wsfe(&io___1924);
#line 25402 ""
	    do_fio(&c__1, (char *)&c__0, (ftnlen)sizeof(integer));
#line 25402 ""
	    do_fio(&c__1, (char *)&c__255, (ftnlen)sizeof(integer));
#line 25402 ""
	    do_fio(&c__1, (char *)&c__47, (ftnlen)sizeof(integer));
#line 25402 ""
	    do_fio(&c__1, (char *)&c__0, (ftnlen)sizeof(integer));
#line 25402 ""
	    e_wsfe();
#line 25402 ""
	}
#line 25403 ""
	if (kv == 2) {
#line 25404 ""
	    kv = 1;
#line 25405 ""
	} else if (all_1.iv == 1) {
#line 25406 ""
	    goto L5;
#line 25407 ""
	} else {
#line 25408 ""
	    --all_1.iv;
#line 25409 ""
	    if (commidi_1.twoline[all_1.iv - 1]) {
#line 25409 ""
		kv = 2;
#line 25409 ""
	    }
#line 25410 ""
	}
#line 25411 ""
L5:
#line 25411 ""
	;
#line 25411 ""
    }
/*      write(*,'(1x,a12,(10i6))')'Bytes used:',(imidi(icm),icm=0,numchan) */
/*      write(15,'(1x,a12,(10i6))') */
/*     *                          'Bytes used:',(imidi(icm),icm=0,numchan) */
#line 25415 ""
    cl__1.cerr = 0;
#line 25415 ""
    cl__1.cunit = 51;
#line 25415 ""
    cl__1.csta = 0;
#line 25415 ""
    f_clos(&cl__1);
#line 25416 ""
    if (commidi_1.debugmidi) {
#line 25416 ""
	cl__1.cerr = 0;
#line 25416 ""
	cl__1.cunit = 52;
#line 25416 ""
	cl__1.csta = 0;
#line 25416 ""
	f_clos(&cl__1);
#line 25416 ""
    }
#line 25417 ""
    return 0;
} /* writemidi_ */

/* Subroutine */ int writesetsign_(integer *ninsttrans, integer *iinsttrans, 
	integer *itranskey, logical *flag__)
{
    /* System generated locals */
    address a__1[2];
    integer i__1, i__2[2], i__3;
    char ch__1[1], ch__2[80];
    icilist ici__1;

    /* Builtin functions */
    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
    integer s_wsfi(icilist *), do_fio(integer *, char *, ftnlen), e_wsfi(void)
	    , s_wsfe(cilist *), e_wsfe(void);

    /* Local variables */
    static integer i__;
    extern /* Character */ VOID chax_(char *, ftnlen, integer *);
    static integer lnote;
    static char notexq[79];

    /* Fortran I/O blocks */
    static cilist io___1928 = { 0, 11, 0, "(a)", 0 };



/*  Assumes notexq is blank */

#line 25428 ""
    /* Parameter adjustments */
#line 25428 ""
    --itranskey;
#line 25428 ""
    --iinsttrans;
#line 25428 ""

#line 25428 ""
    /* Function Body */
#line 25428 ""
    i__1 = *ninsttrans;
#line 25428 ""
    for (i__ = 1; i__ <= i__1; ++i__) {
/* Writing concatenation */
#line 25429 ""
	chax_(ch__1, (ftnlen)1, &c__92);
#line 25429 ""
	i__2[0] = 1, a__1[0] = ch__1;
#line 25429 ""
	i__2[1] = 7, a__1[1] = "setsign";
#line 25429 ""
	s_cat(notexq, a__1, i__2, &c__2, (ftnlen)79);
#line 25430 ""
	lnote = 8;
#line 25431 ""
	if (iinsttrans[i__] < 10) {
/* Writing concatenation */
#line 25432 ""
	    i__2[0] = lnote, a__1[0] = notexq;
#line 25432 ""
	    i__3 = iinsttrans[i__] + 48;
#line 25432 ""
	    chax_(ch__1, (ftnlen)1, &i__3);
#line 25432 ""
	    i__2[1] = 1, a__1[1] = ch__1;
#line 25432 ""
	    s_cat(notexq, a__1, i__2, &c__2, (ftnlen)79);
#line 25433 ""
	    ++lnote;
#line 25434 ""
	} else {
#line 25435 ""
	    i__3 = lnote;
#line 25435 ""
	    ici__1.icierr = 0;
#line 25435 ""
	    ici__1.icirnum = 1;
#line 25435 ""
	    ici__1.icirlen = lnote + 4 - i__3;
#line 25435 ""
	    ici__1.iciunit = notexq + i__3;
#line 25435 ""
	    ici__1.icifmt = "(a1,i2,a1)";
#line 25435 ""
	    s_wsfi(&ici__1);
#line 25435 ""
	    do_fio(&c__1, "{", (ftnlen)1);
#line 25435 ""
	    do_fio(&c__1, (char *)&iinsttrans[i__], (ftnlen)sizeof(integer));
#line 25435 ""
	    do_fio(&c__1, "}", (ftnlen)1);
#line 25435 ""
	    e_wsfi();
#line 25437 ""
	    lnote += 4;
#line 25438 ""
	}
#line 25439 ""
	if (itranskey[i__] < 0) {
#line 25440 ""
	    i__3 = lnote;
#line 25440 ""
	    ici__1.icierr = 0;
#line 25440 ""
	    ici__1.icirnum = 1;
#line 25440 ""
	    ici__1.icirlen = lnote + 4 - i__3;
#line 25440 ""
	    ici__1.iciunit = notexq + i__3;
#line 25440 ""
	    ici__1.icifmt = "(a1,i2,a1)";
#line 25440 ""
	    s_wsfi(&ici__1);
#line 25440 ""
	    do_fio(&c__1, "{", (ftnlen)1);
#line 25440 ""
	    do_fio(&c__1, (char *)&itranskey[i__], (ftnlen)sizeof(integer));
#line 25440 ""
	    do_fio(&c__1, "}", (ftnlen)1);
#line 25440 ""
	    e_wsfi();
#line 25442 ""
	    lnote += 4;
#line 25443 ""
	} else {
/* Writing concatenation */
#line 25444 ""
	    i__2[0] = lnote, a__1[0] = notexq;
#line 25444 ""
	    i__3 = itranskey[i__] + 48;
#line 25444 ""
	    chax_(ch__1, (ftnlen)1, &i__3);
#line 25444 ""
	    i__2[1] = 1, a__1[1] = ch__1;
#line 25444 ""
	    s_cat(notexq, a__1, i__2, &c__2, (ftnlen)79);
#line 25445 ""
	    ++lnote;
#line 25446 ""
	}
#line 25447 ""
	s_wsfe(&io___1928);
/* Writing concatenation */
#line 25447 ""
	i__2[0] = lnote, a__1[0] = notexq;
#line 25447 ""
	i__2[1] = 1, a__1[1] = "%";
#line 25447 ""
	s_cat(ch__2, a__1, i__2, &c__2, (ftnlen)80);
#line 25447 ""
	do_fio(&c__1, ch__2, lnote + 1);
#line 25447 ""
	e_wsfe();
#line 25448 ""
/* L1: */
#line 25448 ""
    }
#line 25449 ""
    *flag__ = FALSE_;
#line 25450 ""
    return 0;
} /* writesetsign_ */

/* Subroutine */ int writflot_(real *x, char *notexq, integer *lenline, 
	ftnlen notexq_len)
{
    /* System generated locals */
    integer i__1;
    icilist ici__1;

    /* Builtin functions */
    integer s_wsfi(icilist *), do_fio(integer *, char *, ftnlen), e_wsfi(void)
	    ;

#line 25454 ""
    if (*x < .95f) {
#line 25455 ""
	i__1 = *lenline;
#line 25455 ""
	ici__1.icierr = 0;
#line 25455 ""
	ici__1.icirnum = 1;
#line 25455 ""
	ici__1.icirlen = *lenline + 2 - i__1;
#line 25455 ""
	ici__1.iciunit = notexq + i__1;
#line 25455 ""
	ici__1.icifmt = "(f2.1)";
#line 25455 ""
	s_wsfi(&ici__1);
#line 25455 ""
	do_fio(&c__1, (char *)&(*x), (ftnlen)sizeof(real));
#line 25455 ""
	e_wsfi();
#line 25456 ""
	*lenline += 2;
#line 25457 ""
    } else if (*x < 9.95f) {
#line 25458 ""
	i__1 = *lenline;
#line 25458 ""
	ici__1.icierr = 0;
#line 25458 ""
	ici__1.icirnum = 1;
#line 25458 ""
	ici__1.icirlen = *lenline + 3 - i__1;
#line 25458 ""
	ici__1.iciunit = notexq + i__1;
#line 25458 ""
	ici__1.icifmt = "(f3.1)";
#line 25458 ""
	s_wsfi(&ici__1);
#line 25458 ""
	do_fio(&c__1, (char *)&(*x), (ftnlen)sizeof(real));
#line 25458 ""
	e_wsfi();
#line 25459 ""
	*lenline += 3;
#line 25460 ""
    } else {
#line 25461 ""
	i__1 = *lenline;
#line 25461 ""
	ici__1.icierr = 0;
#line 25461 ""
	ici__1.icirnum = 1;
#line 25461 ""
	ici__1.icirlen = *lenline + 4 - i__1;
#line 25461 ""
	ici__1.iciunit = notexq + i__1;
#line 25461 ""
	ici__1.icifmt = "(f4.1)";
#line 25461 ""
	s_wsfi(&ici__1);
#line 25461 ""
	do_fio(&c__1, (char *)&(*x), (ftnlen)sizeof(real));
#line 25461 ""
	e_wsfi();
#line 25462 ""
	*lenline += 4;
#line 25463 ""
    }
#line 25464 ""
    return 0;
} /* writflot_ */

/* Subroutine */ int wsclef_(integer *iv, integer *ninow, integer *nclef)
{
    /* System generated locals */
    address a__1[3], a__2[2], a__3[4];
    integer i__1, i__2[3], i__3[2], i__4, i__5[4];
    char ch__1[1], ch__2[1], ch__3[9], ch__4[42], ch__5[33];

    /* Builtin functions */
    integer s_wsle(cilist *), e_wsle(void), do_lio(integer *, integer *, char 
	    *, ftnlen);
    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen);
    integer s_wsfi(icilist *), do_fio(integer *, char *, ftnlen), e_wsfi(void)
	    , s_wsfe(cilist *), e_wsfe(void);

    /* Local variables */
    static integer iv1, iv2, iiv;
    extern /* Character */ VOID chax_(char *, ftnlen, integer *);
    static integer ltem;
    static char temq[40];
    extern /* Subroutine */ int stop1_(void);
    static integer iinst;
    extern integer numclef_(char *, ftnlen);

    /* Fortran I/O blocks */
    static cilist io___1931 = { 0, 6, 0, 0, 0 };
    static cilist io___1932 = { 0, 6, 0, 0, 0 };
    static icilist io___1936 = { 0, temq, 0, "(a9,i2,a1)", 40, 1 };
    static cilist io___1937 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1939 = { 0, 11, 0, "(a)", 0 };
    static cilist io___1940 = { 0, 11, 0, "(a)", 0 };



/*  Writes \setclef for instrument containing *staff* iv */


/* In pmx271, had removed clefq, so with 2 or more staves in */
/*   an instrument, had problems. So replace in 272 */

#line 25484 ""
    if (*nclef < 7) {
#line 25485 ""
	i__1 = *nclef + 48;
#line 25485 ""
	chax_(ch__1, (ftnlen)1, &i__1);
#line 25485 ""
	*(unsigned char *)&comclefq_1.clefq[*iv - 1] = *(unsigned char *)&
		ch__1[0];
#line 25486 ""
    } else {
#line 25487 ""
	*(unsigned char *)&comclefq_1.clefq[*iv - 1] = '9';
#line 25488 ""
    }
#line 25489 ""
    if (! comlast_1.islast) {
#line 25489 ""
	return 0;
#line 25489 ""
    }
#line 25490 ""
    iv1 = 1;
#line 25491 ""
    i__1 = *ninow;
#line 25491 ""
    for (iinst = 1; iinst <= i__1; ++iinst) {
#line 25492 ""
	if (*iv < iv1 + comnvi_1.nspern[iinst - 1]) {
#line 25492 ""
	    goto L2;
#line 25492 ""
	}
#line 25493 ""
	iv1 += comnvi_1.nspern[iinst - 1];
#line 25494 ""
/* L1: */
#line 25494 ""
    }
#line 25495 ""
    s_wsle(&io___1931);
#line 25495 ""
    e_wsle();
#line 25496 ""
    s_wsle(&io___1932);
#line 25496 ""
    do_lio(&c__9, &c__1, "Should not be here in wsclef!", (ftnlen)29);
#line 25496 ""
    e_wsle();
#line 25497 ""
    stop1_();
#line 25498 ""
L2:

/*  Here, iinst is the instrument number with staff of clef change */

#line 25502 ""
    iv2 = iv1 + comnvi_1.nspern[iinst - 1] - 1;
#line 25503 ""
    if (iinst < 10) {
/* Writing concatenation */
#line 25504 ""
	chax_(ch__1, (ftnlen)1, &c__92);
#line 25504 ""
	i__2[0] = 1, a__1[0] = ch__1;
#line 25504 ""
	i__2[1] = 7, a__1[1] = "setclef";
#line 25504 ""
	i__1 = iinst + 48;
#line 25504 ""
	chax_(ch__2, (ftnlen)1, &i__1);
#line 25504 ""
	i__2[2] = 1, a__1[2] = ch__2;
#line 25504 ""
	s_cat(temq, a__1, i__2, &c__3, (ftnlen)40);
#line 25505 ""
	ltem = 9;
#line 25506 ""
    } else {
#line 25507 ""
	s_wsfi(&io___1936);
/* Writing concatenation */
#line 25507 ""
	chax_(ch__1, (ftnlen)1, &c__92);
#line 25507 ""
	i__3[0] = 1, a__2[0] = ch__1;
#line 25507 ""
	i__3[1] = 8, a__2[1] = "setclef{";
#line 25507 ""
	s_cat(ch__3, a__2, i__3, &c__2, (ftnlen)9);
#line 25507 ""
	do_fio(&c__1, ch__3, (ftnlen)9);
#line 25507 ""
	do_fio(&c__1, (char *)&iinst, (ftnlen)sizeof(integer));
#line 25507 ""
	do_fio(&c__1, "}", (ftnlen)1);
#line 25507 ""
	e_wsfi();
#line 25508 ""
	ltem = 12;
#line 25509 ""
    }
#line 25510 ""
    if (iv1 == iv2) {

/*  Only one staff (iv) in instrument with clef change */

#line 25514 ""
	s_wsfe(&io___1937);
/* Writing concatenation */
#line 25514 ""
	i__2[0] = ltem, a__1[0] = temq;
#line 25514 ""
	i__2[1] = 1, a__1[1] = comclefq_1.clefq + (*iv - 1);
#line 25514 ""
	i__2[2] = 1, a__1[2] = "%";
#line 25514 ""
	s_cat(ch__4, a__1, i__2, &c__3, (ftnlen)42);
#line 25514 ""
	do_fio(&c__1, ch__4, ltem + 2);
#line 25514 ""
	e_wsfe();
#line 25515 ""
    } else {
/* Writing concatenation */
#line 25516 ""
	i__3[0] = ltem, a__2[0] = temq;
#line 25516 ""
	i__3[1] = 1, a__2[1] = "{";
#line 25516 ""
	s_cat(temq, a__2, i__3, &c__2, (ftnlen)40);
#line 25517 ""
	++ltem;

/*  Loop over staves, but clefq has only changed for one of them */

#line 25521 ""
	i__1 = iv2;
#line 25521 ""
	for (iiv = iv1; iiv <= i__1; ++iiv) {
/* Writing concatenation */
#line 25522 ""
	    i__3[0] = ltem, a__2[0] = temq;
#line 25522 ""
	    i__4 = numclef_(comclefq_1.clefq + (iiv - 1), (ftnlen)1) + 48;
#line 25522 ""
	    chax_(ch__1, (ftnlen)1, &i__4);
#line 25522 ""
	    i__3[1] = 1, a__2[1] = ch__1;
#line 25522 ""
	    s_cat(temq, a__2, i__3, &c__2, (ftnlen)40);
#line 25523 ""
	    ++ltem;
#line 25524 ""
/* L3: */
#line 25524 ""
	}
#line 25525 ""
	s_wsfe(&io___1939);
/* Writing concatenation */
#line 25525 ""
	i__3[0] = ltem, a__2[0] = temq;
#line 25525 ""
	i__3[1] = 2, a__2[1] = "}%";
#line 25525 ""
	s_cat(ch__4, a__2, i__3, &c__2, (ftnlen)42);
#line 25525 ""
	do_fio(&c__1, ch__4, ltem + 2);
#line 25525 ""
	e_wsfe();
#line 25526 ""
    }
#line 25527 ""
    if (comc8flag_1.c8flag[*iv - 1]) {

/* If we change FROM octave treble clef to some other, need the following. */

#line 25531 ""
	s_wsfe(&io___1940);
/* Writing concatenation */
#line 25531 ""
	i__5[0] = 20, a__3[0] = "\\settrebleclefsymbol";
#line 25531 ""
	i__1 = iinst + 48;
#line 25531 ""
	chax_(ch__1, (ftnlen)1, &i__1);
#line 25531 ""
	i__5[1] = 1, a__3[1] = ch__1;
#line 25531 ""
	i__5[2] = 1, a__3[2] = "\\";
#line 25531 ""
	i__5[3] = 11, a__3[3] = "trebleclef%";
#line 25531 ""
	s_cat(ch__5, a__3, i__5, &c__4, (ftnlen)33);
#line 25531 ""
	do_fio(&c__1, ch__5, (ftnlen)33);
#line 25531 ""
	e_wsfe();
#line 25533 ""
	comc8flag_1.c8flag[*iv - 1] = FALSE_;
#line 25534 ""
    }
#line 25535 ""
    return 0;
} /* wsclef_ */

/* Subroutine */ int chkpmxlyr_(char *lineq, integer *iccount, integer *
	lyrerr, ftnlen lineq_len)
{
    /* System generated locals */
    integer i__1;
    char ch__1[1];

    /* Builtin functions */
    integer s_cmp(char *, char *, ftnlen, ftnlen), i_indx(char *, char *, 
	    ftnlen, ftnlen);

    /* Local variables */
    extern /* Character */ VOID chax_(char *, ftnlen, integer *);
    static char charq[1];
    extern /* Subroutine */ int g1etchar_(char *, integer *, char *, ftnlen, 
	    ftnlen);

#line 25540 ""
    *lyrerr = 0;

/*  On entry, last char was " */

#line 25544 ""
L18:
#line 25544 ""
    g1etchar_(lineq, iccount, charq, (ftnlen)128, (ftnlen)1);
#line 25545 ""
    if (*iccount == 121) {
#line 25546 ""
	*lyrerr = 2;
#line 25547 ""
	return 0;
#line 25548 ""
    } else /* if(complicated condition) */ {
#line 25548 ""
	i__1 = *iccount - 2;
#line 25548 ""
	chax_(ch__1, (ftnlen)1, &c__34);
#line 25548 ""
	if (*(unsigned char *)charq == *(unsigned char *)&ch__1[0] && ! (
		s_cmp(lineq + i__1, "\\", *iccount - 1 - i__1, (ftnlen)1) == 
		0)) {
#line 25550 ""
	    g1etchar_(lineq, iccount, charq, (ftnlen)128, (ftnlen)1);

/*  Check for raise/lower command */

#line 25554 ""
	    if (*(unsigned char *)charq == '@') {

/*   @  positions lyrics vertically for current voice */
/*     [a,b]  above or below of the staff */
/*        +/- i offset, \internotes */

#line 25560 ""
		g1etchar_(lineq, iccount, charq, (ftnlen)128, (ftnlen)1);
#line 25561 ""
		if (i_indx("ab", charq, (ftnlen)2, (ftnlen)1) == 0) {
#line 25562 ""
		    *lyrerr = 3;
#line 25563 ""
		    return 0;
#line 25564 ""
		}
#line 25565 ""
		g1etchar_(lineq, iccount, charq, (ftnlen)128, (ftnlen)1);
#line 25566 ""
		if (i_indx("+-", charq, (ftnlen)2, (ftnlen)1) == 0) {
#line 25567 ""
		    *lyrerr = 4;
#line 25568 ""
		    return 0;
#line 25569 ""
		}
#line 25570 ""
		g1etchar_(lineq, iccount, charq, (ftnlen)128, (ftnlen)1);
#line 25571 ""
		if (i_indx("0123456789", charq, (ftnlen)10, (ftnlen)1) == 0) {
#line 25572 ""
		    *lyrerr = 5;
#line 25573 ""
		    return 0;
#line 25574 ""
		}
#line 25575 ""
	    } else if (*(unsigned char *)charq != ' ') {

/*  2nd " must be followed by ' ' */

#line 25579 ""
		*lyrerr = 1;
#line 25580 ""
		return 0;
#line 25581 ""
	    }
#line 25582 ""
	    return 0;
#line 25583 ""
	}
#line 25583 ""
    }
#line 25584 ""
    goto L18;
} /* chkpmxlyr_ */

/* Subroutine */ int dopmxlyr_(char *lineq, integer *iccount, ftnlen 
	lineq_len)
{
    /* System generated locals */
    address a__1[4], a__2[6], a__3[7];
    integer i__1, i__2[4], i__3[6], i__4, i__5[7];
    char ch__1[1];

    /* Builtin functions */
    integer i_indx(char *, char *, ftnlen, ftnlen), s_cmp(char *, char *, 
	    ftnlen, ftnlen), s_wsle(cilist *), do_lio(integer *, integer *, 
	    char *, ftnlen), e_wsle(void);
    /* Subroutine */ int s_cat(char *, char **, integer *, integer *, ftnlen),
	     s_copy(char *, char *, ftnlen, ftnlen);

    /* Local variables */
    static char sq[1];
    static integer i2nd, iend;
    extern /* Character */ VOID chax_(char *, ftnlen, integer *);
    extern /* Subroutine */ int stop1_(void);
    static integer itilde;
    static char lineqt[128];
    static integer istart;
    extern integer lenstr_(char *, integer *, ftnlen);

    /* Fortran I/O blocks */
    static cilist io___1947 = { 0, 6, 0, 0, 0 };



/* lineq has " at iccount. Find end of lyrics string, replace "..." */
/*   with \pmxlyr{...}\, but also look for ~ in lyrics and replace with '\ll ', */
/*   (unless preceded with '\'), check length */

#line 25594 ""
    chax_(ch__1, (ftnlen)1, &c__92);
#line 25594 ""
    *(unsigned char *)sq = *(unsigned char *)&ch__1[0];
#line 25595 ""
    iend = lenstr_(lineq, &c__128, (ftnlen)128);

/* Find position of closing '"'; must bypass any \" which is used for umlaut */

#line 25599 ""
    i__1 = *iccount;
#line 25599 ""
    chax_(ch__1, (ftnlen)1, &c__34);
#line 25599 ""
    i2nd = *iccount + i_indx(lineq + i__1, ch__1, 128 - i__1, (ftnlen)1);
#line 25600 ""
L2:
#line 25601 ""
    i__1 = i2nd - 2;
#line 25601 ""
    if (s_cmp(lineq + i__1, "\\", i2nd - 1 - i__1, (ftnlen)1) == 0) {
#line 25602 ""
	i__1 = i2nd;
#line 25602 ""
	chax_(ch__1, (ftnlen)1, &c__34);
#line 25602 ""
	i2nd += i_indx(lineq + i__1, ch__1, 128 - i__1, (ftnlen)1);
#line 25603 ""
	goto L2;
#line 25604 ""
    }
#line 25605 ""
    istart = *iccount;
#line 25606 ""
L1:
#line 25606 ""
    i__1 = istart;
#line 25606 ""
    itilde = istart + i_indx(lineq + i__1, "~", i2nd - 1 - i__1, (ftnlen)1);
#line 25607 ""
    if (itilde > istart && itilde < i2nd) {

/*  Replace tilde if not preceded by \ */

#line 25611 ""
	if (iend >= 117) {
#line 25612 ""
	    s_wsle(&io___1947);
#line 25612 ""
	    do_lio(&c__9, &c__1, "Sorry, lyric string is too long, stopping", 
		    (ftnlen)41);
#line 25612 ""
	    e_wsle();
#line 25613 ""
	    stop1_();
#line 25614 ""
	} else /* if(complicated condition) */ {
#line 25614 ""
	    i__1 = itilde - 2;
#line 25614 ""
	    if (s_cmp(lineq + i__1, sq, itilde - 1 - i__1, (ftnlen)1) == 0) {
#line 25615 ""
		istart = itilde;
#line 25616 ""
		goto L1;
#line 25617 ""
	    }
#line 25617 ""
	}
#line 25618 ""
	i__1 = itilde;
/* Writing concatenation */
#line 25618 ""
	i__2[0] = itilde - 1, a__1[0] = lineq;
#line 25618 ""
	i__2[1] = 1, a__1[1] = sq;
#line 25618 ""
	i__2[2] = 3, a__1[2] = "lk ";
#line 25618 ""
	i__2[3] = iend - i__1, a__1[3] = lineq + i__1;
#line 25618 ""
	s_cat(lineqt, a__1, i__2, &c__4, (ftnlen)128);
#line 25620 ""
	iend = lenstr_(lineqt, &c__128, (ftnlen)128);
#line 25621 ""
	i2nd += 3;
#line 25622 ""
	s_copy(lineq, lineqt, (ftnlen)128, (ftnlen)128);
#line 25623 ""
	goto L1;
#line 25624 ""
    }
#line 25625 ""
    if (*iccount == 1) {
#line 25626 ""
	i__1 = i2nd;
/* Writing concatenation */
#line 25626 ""
	i__3[0] = 1, a__2[0] = sq;
#line 25626 ""
	i__3[1] = 7, a__2[1] = "pmxlyr{";
#line 25626 ""
	i__3[2] = i2nd - 2, a__2[2] = lineq + 1;
#line 25626 ""
	i__3[3] = 1, a__2[3] = "}";
#line 25626 ""
	i__3[4] = 1, a__2[4] = sq;
#line 25626 ""
	i__3[5] = 128 - i__1, a__2[5] = lineq + i__1;
#line 25626 ""
	s_cat(lineqt, a__2, i__3, &c__6, (ftnlen)128);
#line 25628 ""
    } else {
#line 25629 ""
	i__1 = *iccount;
#line 25629 ""
	i__4 = i2nd;
/* Writing concatenation */
#line 25629 ""
	i__5[0] = *iccount - 1, a__3[0] = lineq;
#line 25629 ""
	i__5[1] = 1, a__3[1] = sq;
#line 25629 ""
	i__5[2] = 7, a__3[2] = "pmxlyr{";
#line 25629 ""
	i__5[3] = i2nd - 1 - i__1, a__3[3] = lineq + i__1;
#line 25629 ""
	i__5[4] = 1, a__3[4] = "}";
#line 25629 ""
	i__5[5] = 1, a__3[5] = sq;
#line 25629 ""
	i__5[6] = 128 - i__4, a__3[6] = lineq + i__4;
#line 25629 ""
	s_cat(lineqt, a__3, i__5, &c__7, (ftnlen)128);
#line 25632 ""
    }
#line 25633 ""
    i2nd += 8;
#line 25634 ""
    s_copy(lineq, lineqt, (ftnlen)128, (ftnlen)128);
#line 25635 ""
    i__1 = i2nd;
#line 25635 ""
    if (s_cmp(lineq + i__1, "@", i2nd + 1 - i__1, (ftnlen)1) == 0) {
#line 25636 ""
	i__1 = i2nd + 1;
#line 25636 ""
	i__4 = i2nd + 4;
/* Writing concatenation */
#line 25636 ""
	i__3[0] = i2nd, a__2[0] = lineq;
#line 25636 ""
	i__3[1] = 3, a__2[1] = "at{";
#line 25636 ""
	i__3[2] = i2nd + 4 - i__1, a__2[2] = lineq + i__1;
#line 25636 ""
	i__3[3] = 1, a__2[3] = "}";
#line 25636 ""
	i__3[4] = 1, a__2[4] = sq;
#line 25636 ""
	i__3[5] = 128 - i__4, a__2[5] = lineq + i__4;
#line 25636 ""
	s_cat(lineqt, a__2, i__3, &c__6, (ftnlen)128);
#line 25638 ""
	s_copy(lineq, lineqt, (ftnlen)128, (ftnlen)128);
#line 25639 ""
    }
#line 25640 ""
    return 0;
} /* dopmxlyr_ */

/* Subroutine */ int inst2chan_(integer *midc, integer *midi, integer *
	midchan, integer *nv, shortint *iinsiv, logical *twoline)
{
    static integer iv;


/*      propagate per-instrument quantities to per-channel ones */

#line 25650 ""
    /* Parameter adjustments */
#line 25650 ""
    --twoline;
#line 25650 ""
    --iinsiv;
#line 25650 ""
    midchan -= 25;
#line 25650 ""
    --midi;
#line 25650 ""

#line 25650 ""
    /* Function Body */
#line 25650 ""
    for (iv = *nv; iv >= 1; --iv) {
#line 25651 ""
	if (twoline[iv]) {
#line 25652 ""
	    midc[midchan[iv + 48]] = midi[iinsiv[iv]];
#line 25653 ""
	}
#line 25654 ""
	midc[midchan[iv + 24]] = midi[iinsiv[iv]];
#line 25655 ""
    }
#line 25656 ""
    return 0;
} /* inst2chan_ */

/* Main program alias */ int pmxab_ () { MAIN__ (); return 0; }
